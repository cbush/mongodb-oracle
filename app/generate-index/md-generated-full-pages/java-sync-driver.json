{
  "https://www.mongodb.com/docs/drivers/java/sync/current/api-documentation/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # API Documentation ← [Time Series Collections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/time-series/ \"Previous Section\")[FAQ](https://mongodb.com/docs/drivers/java/sync/current/faq/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Fundamentals Learn how to perform the following tasks using the Java driver in the Fundamentals section: * [Connect to MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/)\n* [Use the Stable API](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/stable-api/)\n* [Authenticate with MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/auth/)\n* [Convert between MongoDB Data Formats and Java Objects](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/)\n* [Read from and Write to MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/)\n* [Simplify your Code with Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/)\n* [Transform your Data](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/aggregation/)\n* [Create Indexes to Speed Up Queries](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/indexes/)\n* [Sort Using Collations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/collations/)\n* [Log Events in the Driver](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/logging/)\n* [Monitor Driver Events](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/monitoring/)\n* [Store and Retrieve Large Files in MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/gridfs/)\n* [Encrypt Fields in a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/csfle/)\n* [Use a Time Series Collection](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/time-series/) ← [Run a Command](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/command/ \"Previous Section\")[Connection Guide](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Usage Examples On this page * [Overview](#overview)\n* [How to Use the Usage Examples](#how-to-use-the-usage-examples) ## Overview Usage examples provide convenient starting points for popular MongoDB operations. Each example provides the following information: * An explanation of the operation in the example showing the purpose and a sample use case for the method\n* An explanation of how to use the operation, including parameters, return values, and common exceptions you might encounter\n* A full Java class that you can copy and paste to run the example in your own environment ## How to Use the Usage Examples These examples use the [sample datasets](https://www.mongodb.com/docs/atlas/sample-data/?jmp=docs%5Fdriver%5Fjava)provided by Atlas. You can load them into your database on the free tier of MongoDB Atlas by following the[Get Started with Atlas Guide](https://www.mongodb.com/docs/atlas/getting-started/#atlas-getting-started?jmp=docs%5Fdriver%5Fjava)or you can[import the sample dataset into a local MongoDB instance.](https://www.mongodb.com/docs/guides/server/import/) Once you have imported the dataset, you can copy and paste a usage example into your development environment of choice. You can follow the[quick start guide](https://mongodb.com/docs/drivers/java/sync/current/quick-start/) to learn more about getting started with the MongoDB Java driver. Once you've copied a usage example, you'll need to edit the connection URI to get the example connected to your MongoDB instance: `| // Replace the following with your MongoDB deployment's connection string. |\n| -------------------------------------------------------------------------- |\n| String uri = \"<connection string uri>\";                                    | ` You can use the [Atlas Connectivity Guide](https://www.mongodb.com/docs/guides/cloud/connectionstring/)to learn how to allow connections to your instance of Atlas and to find the[connection string](https://www.mongodb.com/docs/manual/reference/connection-string/) you use to replace the`uri` variable in usage examples. If your instance uses[SCRAM authentication](https://www.mongodb.com/docs/manual/core/security-scram/), you can replace`<user>` with your username, `<password>` with your password, and`<cluster-url>` with the IP address or URL of your instance. For more information about connecting to your MongoDB instance, see our[Connection Guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/) ← [Quick Reference](https://mongodb.com/docs/drivers/java/sync/current/quick-reference/ \"Previous Section\")[Find Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/find-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/legacy/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Migrate from the Legacy API On this page * [Overview](#overview)\n* [API Changes](#api-changes) ## Overview In this section, you can identify the changes you need to make to migrate from the legacy API to the current API. The legacy API, packaged as the `mongodb-driver-legacy` JAR, contains the legacy synchronous Java driver and uses naming conventions used in earlier versions of the driver. The current API, packaged as the `mongodb-driver-sync` JAR, contains the current synchronous Java driver. It features the `MongoCollection`interface as an entry point to CRUD operations. It does not contain the legacy API. To perform a migration from the legacy API to the current API, ensure your code no longer references the legacy API, updating your code when necessary. Then, replace the legacy API and any uber JAR that contains it with the current API JAR in your application dependencies. In addition to updating your application to handle any necessary changes, always check for any other differences in options and return values before moving it to production. ## API Changes The following table shows the majority of the changes in class and method names between the legacy and current API.\n\n In addition to the preceding items, consider the following changes: * The current API uses `Options` classes and method chaining rather than overloaded methods.\n* The current API uses relaxed JSON format by default in driver versions 4.0 and later. If your application relies on the strict JSON format, use the strict mode when reading or writing data. Learn how to specify the JSON format in the current API in the [Document Data Format: Extended JSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-extended-json/#std-label-java-extended-json)guide.\n* The default generic type for `MongoCollection` in the current API is[org.bson.Document](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/Document.html). You can specify [BasicDBObject](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/BasicDBObject.html)as a type parameter if it eases your migration.\n* In the current API, the aggregation pipeline you pass to the `aggregate()`method accepts a list of objects that extend the `Bson` interface whereas in the legacy API, it accepts a list of objects that extend the`DBObject` interface.  \nThe method signatures also differ between the APIs. See the following API documentation for more information:  \n   * [aggregate()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#aggregate%28java.util.List%29) method in the current API  \n   * [aggregate()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-legacy/com/mongodb/DBCollection.html#aggregate%28java.util.List,com.mongodb.AggregationOptions%29) method in the legacy API  \n   * [Bson](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/conversions/Bson.html) interface  \n   * [DBObject](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/DBObject.html) interface ← [Upgrade Driver Versions](https://mongodb.com/docs/drivers/java/sync/current/upgrade/ \"Previous Section\")",
  "https://www.mongodb.com/docs/drivers/java/sync/current/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Quick Start On this page * [Introduction](#introduction)\n* [Set up Your Project](#set-up-your-project)\n* [Install the Java Development Kit (JDK)](#install-the-java-development-kit--jdk-)\n* [Create the Project](#create-the-project)\n* [Add MongoDB as a Dependency](#add-mongodb-as-a-dependency)\n* [Create a MongoDB Cluster](#create-a-mongodb-cluster)\n* [Set up a Free Tier Cluster in Atlas](#set-up-a-free-tier-cluster-in-atlas)\n* [Query Your MongoDB Cluster from Your Application](#query-your-mongodb-cluster-from-your-application)\n* [Working with POJOs (Optional)](#working-with-pojos--optional-)\n* [Next steps](#next-steps) ## Introduction This guide shows you how to create an application that uses the **Java driver**to connect to a **MongoDB Atlas cluster**. If you prefer to connect to MongoDB using a different driver or programming language, see our[list of official MongoDB drivers.](https://www.mongodb.com/docs/drivers/) The Java driver lets you connect to and communicate with MongoDB clusters from a Java application. MongoDB Atlas is a fully-managed cloud database service that hosts your data on MongoDB clusters. In this guide, we show you how to get started with your own free (no credit card required) cluster. Consult the following steps to connect your Java application with a MongoDB Atlas cluster. ## Set up Your Project ### Install the Java Development Kit (JDK) Make sure that your system has JDK 8 or later installed. For more information on how to check your version of Java and install the JDK, see the[Oracle Overview of JDK Installation documentation](https://www.oracle.com/java/technologies/javase-downloads.html). ### Create the Project This guide shows you how to add the MongoDB Java driver dependencies using Maven or Gradle. We recommend that you use an integrated development environment (IDE) such as Intellij IDEA or Eclipse IDE make it more convenient to configure Maven or Gradle to build and run your project. If you are not using an IDE, see[Building Maven](https://maven.apache.org/guides/development/guide-building-maven.html)or[Creating New Gradle Builds](https://guides.gradle.org/creating-new-gradle-builds/)for more information on how to set up your project. ### Add MongoDB as a Dependency If you are using [Maven](https://maven.apache.org/), add the following to your `pom.xml` dependencies list: `| <dependencies>                               |\n| -------------------------------------------- |\n| <dependency>                                 |\n| <groupId>org.mongodb</groupId>               |\n| <artifactId>mongodb-driver-sync</artifactId> |\n| <version>4.9.0</version>                     |\n| </dependency>                                |\n| </dependencies>                              | ` If you are using [Gradle](https://gradle.org/), add the following to your`build.gradle` dependencies list: ``` dependencies {   implementation 'org.mongodb:mongodb-driver-sync:4.9.0' } \n``` Once you configure your dependencies, ensure they are available to your project which may require running your dependency manager and refreshing the project in your IDE. ## Create a MongoDB Cluster\n\n After setting up your Java project dependencies, create a MongoDB cluster where you can store and manage your data. Complete the[Get Started with Atlas](https://www.mongodb.com/docs/atlas/getting-started/?jmp=docs%5Fdriver%5Fjava) guide to set up a new Atlas account, create and launch a free tier MongoDB cluster, load datasets, and interact with the data. After completing the steps in the Atlas guide, you should have a new MongoDB cluster deployed in Atlas, a new database user, and sample datasets loaded into your cluster. #### Connect to your Cluster In this step, we create and run an application that uses the MongoDB Java driver to connect to your MongoDB cluster and run a query on the sample data. We pass instructions to the driver on how to connect to your MongoDB cluster in a string called the _connection string_. This string includes information on the hostname or IP address and port of your cluster, authentication mechanism, user credentials when applicable, and other connection options. If you are connecting to an instance or cluster that is not hosted by Atlas, see [Other Ways to Connect to MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-java-other-ways-to-connect) for instructions on how to format your connection string. To retrieve your connection string for the cluster and user you created in the previous step, log into your Atlas account and navigate to theDatabase section and click the Connect button for the cluster that you want to connect to as shown below. ![Atlas Connection GUI cluster selection screen](https://mongodb.com/docs/drivers/java/sync/current/includes/figures/atlas_connection_select_cluster.png) Proceed to the Connect Your Application step and select the Java driver. Select \"4.1 or Later\" for the version. Click the Copy icon to copy the _connection string_ to your clipboard as shown below. ![Atlas Connection GUI connection string screen](https://mongodb.com/docs/drivers/java/sync/current/includes/figures/atlas_connection_copy_string_java.png) Save your Atlas connection string in a safe location that you can access for the next step. ### Query Your MongoDB Cluster from Your Application Next, create a file to contain your application called `QuickStart.java`in the base package directory of your project. Use the following sample code to run a query on your sample dataset in MongoDB Atlas, replacing the value of the `uri` variable with your MongoDB Atlas connection string. ```java import static com.mongodb.client.model.Filters.eq; import org.bson.Document; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; public class QuickStart {     public static void main( String[] args ) {         // Replace the placeholder with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {             MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");             MongoCollection<Document> collection = database.getCollection(\"movies\");             Document doc = collection.find(eq(\"title\", \"Back to the Future\")).first();             if (doc != null) {                 System.out.println(doc.toJson());             } else {                 System.out.println(\"No matching documents found.\");             }         }     } } \n``` When you run the `QuickStart` class, it should output the details of the movie from the sample dataset which will look something like this: ``` {   _id: ...,   plot: 'A young man is accidentally sent 30 years into the past...',   genres: [ 'Adventure', 'Comedy', 'Sci-Fi' ],   ...   title: 'Back to the Future',   ... } \n```\n\n ## Important ### Known connection issue when using TLS v1.3 If you encounter an error connecting to your MongoDB instance or cluster that resembles the following while running your application, you may need to update your JDK to the latest patch release: ``` javax.net.ssl.SSLHandshakeException: extension (5) should not be presented in certificate_request \n``` This exception is a known issue when using the TLS 1.3 protocol with specific versions of JDK, but was fixed for the following releases: * JDK 11.0.7\n* JDK 13.0.3\n* JDK 14.0.2 To resolve this error, update your JDK to one of the preceding patch versions or a newer one. After completing this step, you should have a working application that uses the Java driver to connect to your MongoDB cluster, run a query on the sample data, and print out the result. ### Working with POJOs (Optional) In the previous section, you ran a query on a sample collection to retrieve data in the map-like class `Document`. In this section, you can learn to use your own Plain Old Java Object (POJO) to store and retrieve data from MongoDB. Create a file called `Movie.java` in the base package directory of your project and add the following code for a class that includes the following fields, setters, and getters: ```java public class Movie {     String plot;     List<String> genres;     String title;     public String getPlot() {         return plot;     }     public void setPlot(String plot) {         this.plot = plot;     }     public List<String> getGenres() {         return genres;     }     public void setGenres(List<String> genres) {         this.genres = genres;     }     public String getTitle() {         return title;     }     public void setTitle(String title) {         this.title = title;     }     @Override     public String toString() {         return \"Movie [\\n  plot=\" + plot + \",\\n  genres=\" + genres + \",\\n  title=\" + title + \"\\n]\";     } } \n``` Create a new file `QuickStartPojoExample.java` in the same package directory as your `Movie` file in your project. Use the following sample code to run a query on your sample dataset in MongoDB Atlas, replacing the value of the `uri` variable with your MongoDB Atlas connection string. Ensure you replace the \"<password>\" section of the connection string with the password you created for your user that has **atlasAdmin** permissions: ```java import static com.mongodb.MongoClientSettings.getDefaultCodecRegistry; import static com.mongodb.client.model.Filters.eq; import static org.bson.codecs.configuration.CodecRegistries.fromProviders; import static org.bson.codecs.configuration.CodecRegistries.fromRegistries; import org.bson.codecs.configuration.CodecProvider; import org.bson.codecs.configuration.CodecRegistry; import org.bson.codecs.pojo.PojoCodecProvider; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; public class QuickStartPojoExample {     public static void main(String[] args) {         CodecProvider pojoCodecProvider = PojoCodecProvider.builder().automatic(true).build();         CodecRegistry pojoCodecRegistry = fromRegistries(getDefaultCodecRegistry(), fromProviders(pojoCodecProvider));         // Replace the uri string with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n             MongoCollection<Movie> collection = database.getCollection(\"movies\", Movie.class);             Movie movie = collection.find(eq(\"title\", \"Back to the Future\")).first();             System.out.println(movie);         }     } } \n``` When you run the `QuickStartPojoExample` class, it should output the details of the movie from the sample dataset which should look something like this: ``` Movie [   plot=A young man is accidentally sent 30 years into the past...,   genres=[Adventure, Comedy, Sci-Fi],   title=Back to the Future ] \n``` If you receive no output or an error, check whether you included the proper connection string in your Java class, and whether you loaded the sample dataset into your MongoDB Atlas cluster. See the following links for more information on using POJOs to store and retrieve data: * [Guide on using POJOs to store and retrieve data](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/)\n* [Guide on custom serialization of POJOs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/) ## Next steps Learn how to read and modify data using the Java driver in our Fundamentals CRUD guide or how to perform common operations from our[Usage Examples.](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/) ← [MongoDB Java Driver](https://mongodb.com/docs/drivers/java/sync/current/ \"Previous Section\")[Quick Reference](https://mongodb.com/docs/drivers/java/sync/current/quick-reference/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/issues-and-help/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Issues & Help On this page * [Bugs / Feature Requests](#bugs---feature-requests)\n* [Pull Requests](#pull-requests) We are lucky to have a vibrant MongoDB Java community that includes users with varying levels of experience using the Java driver. We find the quickest way to get support for general questions is through the [MongoDB Community Forums](https://community.mongodb.com). Refer to our [support channels](https://www.mongodb.org/about/support)documentation for more information. ## Bugs / Feature Requests If you think you've found a bug or want to see a new feature in the Java driver, please open a case in our issue management tool, JIRA: * [Create an account and login](https://jira.mongodb.org).\n* Navigate to [the JAVA project](https://jira.mongodb.org/browse/JAVA).\n* Click Create. Please provide as much information as possible about the issue and the steps to reproduce it. Bug reports in JIRA for the Java driver and the Core Server (i.e. SERVER) project are **public**. If you’ve identified a security vulnerability in a driver or any other MongoDB project, please report it according to the instructions found in the[Create a Vulnerability Report page.](https://www.mongodb.com/docs/manual/tutorial/create-a-vulnerability-report/) ## Pull Requests We are happy to accept contributions to help improve the driver. We will guide user contributions to ensure they meet the standards of the codebase. Please ensure that any pull requests include documentation, tests, and pass the**gradle** checks. To get started check out the source and work on a branch: `| $ git clone https://github.com/mongodb/mongo-java-driver.git |\n| ------------------------------------------------------------ |\n| $ cd mongo-java-driver                                       |\n| $ git checkout -b myNewFeature                               | ` Finally, ensure that the code passes gradle checks. ```bash $ ./gradlew check \n``` ← [FAQ](https://mongodb.com/docs/drivers/java/sync/current/faq/ \"Previous Section\")[Compatibility](https://mongodb.com/docs/drivers/java/sync/current/compatibility/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/faq/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # FAQ On this page * [General](#general)\n* [Why are there two types of MongoClient in the Java driver?](#why-are-there-two-types-of-mongoclient-in-the-java-driver-)\n* [Which type of MongoClient should I use?](#which-type-of-mongoclient-should-i-use-)\n* [How do I use the MongoClientSettings class?](#how-do-i-use-the-mongoclientsettings-class-)\n* [How do I fix: \"javax.net.ssl.SSLHandshakeException: extension (5) should not be presented in certificate\\_request\"?](#how-do-i-fix---javax.net.ssl.sslhandshakeexception--extension--5--should-not-be-presented-in-certificate%5Frequest--)\n* [POJOs](#pojos)\n* [Do I have to specify an ID field value myself?](#do-i-have-to-specify-an-id-field-value-myself-)\n* [Can the ID field be a compound key?](#can-the-id-field-be-a-compound-key-)\n* [Can I use polymorphism in a POJO accessor?](#can-i-use-polymorphism-in-a-pojo-accessor-)\n* [What is a discriminator?](#what-is-a-discriminator-)\n* [Can I control serialization of LocalDate?](#can-i-control-serialization-of-localdate-)\n* [Can I serialize a java.util.Date as a string in format **yyyy-mm-dd**?](#can-i-serialize-a-java.util.date-as-a-string-in-format-yyyy-mm-dd-)\n* [Can I make POJOs read/write directly to the field and not use the getters/setters at all?](#can-i-make-pojos-read-write-directly-to-the-field-and-not-use-the-getters-setters-at-all-)\n* [Can I mix private, protected, and public setters and getters?](#can-i-mix-private--protected--and-public-setters-and-getters-)\n* [How do I fix: \"org.bson.codecs.configuration.CodecConfigurationException: Can't find a codec for class X.\"?](#how-do-i-fix---org.bson.codecs.configuration.codecconfigurationexception--can-t-find-a-codec-for-class-x.--)\n* [How do I specify the collection name for a particular POJO class? Is there an annotation?](#how-do-i-specify-the-collection-name-for-a-particular-pojo-class--is-there-an-annotation-)\n* [Legacy API](#legacy-api)\n* [How do I connect to my MongoDB instance with the legacy API?](#how-do-i-connect-to-my-mongodb-instance-with-the-legacy-api-)\n* [How do I use the legacy MongoClientOptions and MongoClientURI Classes?](#how-do-i-use-the-legacy-mongoclientoptions-and-mongoclienturi-classes-)\n* [Support](#support) ## General ### Why are there two types of `MongoClient` in the Java driver? There are two types of `MongoClient` because we wanted a cleaner API for new users that didn't have the confusion of including multiple CRUD APIs. We wanted to ensure that the new CRUD API was available in a Java package structure that would work well with Java module support introduced in Java 9. ### Which type of `MongoClient` should I use? New applications should generally use the`com.mongodb.client.MongoClient` interface, which supports:\n\n You should use the `com.mongodb.MongoClient` class if you require support for the legacy API, which supports: * Configuration with `MongoClientOptions` and `MongoClientURI`\n* CRUD API using `DB`, and from there, `DBCollection`. You can access this API via the `getDB()` method. For applications that require a mix of the new and legacy APIs, `com.mongodb.MongoClient` also supports: * Configuration with `MongoClientSettings` and `ConnectionString`, the only difference being that you create instances via constructors instead of a factory class.\n* CRUD API using `MongoDatabase`, and from there, `MongoCollection`. You can access this API via the `getDatabase()` method. ### How do I use the `MongoClientSettings` class? You can use the `MongoClientSettings` class to specify configurations for`MongoClient` instances. To construct `MongoClientSettings` instances, use the`MongoClientSettings.Builder` class. Here are the sections of our documentation that show how to perform different tasks with the `MongoClientSettings` class: * [Specify Multiple Hosts](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-mongo-client-settings-multiple-hosts)\n* [Enable TLS/SSL](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/tls/#std-label-tls-enable)\n* [Authenticate with Credentials](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/auth/#std-label-mongo-client-setting-with-mongo-credential-example)\n* [Enable Compression](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/network-compression/#std-label-enable-compression)\n* [Add Listeners For Driver and Database Events](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/monitoring/#std-label-listener-mongo-client-settings-example)\n* [Get the Default Codec Registry](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/#std-label-get-default-codec-registry-example) For more information on the `MongoClientSettings` class, see the[API Documentation for MongoClientSettings.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html) ### How do I fix: \"javax.net.ssl.SSLHandshakeException: extension (5) should not be presented in certificate\\_request\"? This is a [known error](https://bugs.openjdk.java.net/browse/JDK-8236039) that can occur when using the TLS 1.3 protocol with specific versions of the JDK. If you encounter this error when connecting to your MongoDB instance or cluster, update your JDK to one of the following patch versions or newer: * JDK 11.0.7\n* JDK 13.0.3\n* JDK 14.0.2 ## POJOs ### Do I have to specify an ID field value myself? No, the `PojoCodecProvider` automatically generates an ObjectId. ### Can the ID field be a compound key? Yes. For an example of this, see [our implementation](https://github.com/niccottrell/mongo-java-tests/blob/master/src/test/PojoCompoundIdTest.java) ### Can I use polymorphism in a POJO accessor? Yes, by using a discriminator. ### What is a discriminator? A discriminator is a property that identifies a specific document schema. You can use it for inheritance and storing multiple types of documents within the same collection or parent document (if you embed sub-documents). For example, if you have an `Event` class that you extend in Java (e.g.`MachineEvent` or `NetworkEvent`), using a discriminator identifies which class the `PojoCodecProvider` should use to serialize/deserialize the document. For more information, see our [POJO Customization guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/#std-label-pojo-discriminators)\n\n Yes, the 3.7 Java driver adds native support for `JSR-310 Instant`,`LocalDate` & `LocalDateTime`. ### Can I serialize a `java.util.Date` as a string in format **yyyy-mm-dd**? Yes, you can build your own codec for this class and add it to the registry. Add the codec to the first in the list of providers, before the default codec registry and before the `PojoCodecProvider`: `| CodecRegistry registry = CodecRegistries.fromRegistries( |\n| -------------------------------------------------------- |\n| CodecRegistries.fromCodecs(                              |\n| new MyDateAsStringCodec()),                              |\n| MongoClientSettings.getDefaultCodecRegistry(),           |\n| fromProviders(pojoCodecProvider));                       | ` ### Can I make POJOs read/write directly to the field and not use the getters/setters at all? You can configure the `PojoCodecProvider` to use the`SET_PRIVATE_FIELDS_CONVENTION`, which sets a private field through reflection if no public setter is available. ### Can I mix private, protected, and public setters and getters? No. The native POJO codec assumes that getters/setters have the same modifiers for each field. For example, the following methods throws an exception during encoding: ```java private String getField(); public String setField(String x); \n``` ### How do I fix: \"org.bson.codecs.configuration.CodecConfigurationException: Can't find a codec for class X.\"? This exception means you need to register a codec for the class since there is none at the moment. ### How do I specify the collection name for a particular POJO class? Is there an annotation? There is no annotation. We recommend adding a static string in your class as shown: ```java public class Person {    public static final String COLLECTION_NAME = \"people\"; } \n``` The following snippet specifies the collection name for a particular POJO class: ```java database.getCollection(Person.COLLECTION_NAME, Person.class); \n``` ## Legacy API ### How do I connect to my MongoDB instance with the legacy API? The following example shows how to connect to a MongoDB instance with the legacy API and the current API. Imagine we are connecting to a collection that contains only this document: ``` {\"_id\": 1, \"val\": 1} \n``` The output of the preceding code snippet should look like this: ``` {\"_id\": 1, \"val\": 1} \n``` For more information on the legacy classes and methods used in the preceding example, see the following API documentation pages:\n\n See the [Migrate from the Legacy API](https://mongodb.com/docs/drivers/java/sync/current/legacy/#std-label-java-legacy-api) page for a list of differences between the legacy and current API. ### How do I use the legacy `MongoClientOptions` and `MongoClientURI` Classes? Here is an example showing how to use the legacy `MongoClientOptions` and`MongoClientURI` classes to set your write concern: For more information on the legacy classes and methods used in the preceding example, see the following API Documentation pages: * [Legacy API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-legacy/index.html)\n* [MongoClient](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-legacy/com/mongodb/MongoClient.html)\n* [MongoClientOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-legacy/com/mongodb/MongoClientOptions.html)\n* [MongoClientURI](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-legacy/com/mongodb/MongoClientURI.html) See the [Migrate from the Legacy API](https://mongodb.com/docs/drivers/java/sync/current/legacy/#std-label-java-legacy-api) page for a list of differences between the legacy and current API. ## Support If you are unable to find the answer to your question here, try our forums and support channels listed in the [Issues and Help](https://mongodb.com/docs/drivers/java/sync/current/issues-and-help/)section. ← [API Documentation](https://mongodb.com/docs/drivers/java/sync/current/api-documentation/ \"Previous Section\")[Issues & Help](https://mongodb.com/docs/drivers/java/sync/current/issues-and-help/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # MongoDB Java Driver ## Introduction Welcome to the documentation site for the Java Driver, the official MongoDB driver for synchronous Java applications. Download it using[Maven](https://maven.apache.org/) or[Gradle](https://gradle.org/), or set up a runnable project by following our Quick Start guide. If your Java application requires asynchronous stream processing, use the[Reactive Streams Driver](https://www.mongodb.com/docs/drivers/reactive-streams/) which uses Reactive Streams to make non-blocking calls to MongoDB. ## Quick Start Learn how to establish a connection to MongoDB Atlas and begin working with data in the [Quick Start](https://mongodb.com/docs/drivers/java/sync/current/quick-start/) section. ## Quick Reference See driver syntax examples for common MongoDB commands in the[Quick Reference](https://mongodb.com/docs/drivers/java/sync/current/quick-reference/#std-label-java-quick-reference) section. ## Usage Examples For fully runnable code snippets and explanations for common methods, see the [Usage Examples](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/) section. ## Fundamentals Learn how to perform the following tasks using the Java driver in the Fundamentals section: * [Connect to MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/)\n* [Use the Stable API](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/stable-api/)\n* [Authenticate with MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/auth/)\n* [Convert between MongoDB Data Formats and Java Objects](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/)\n* [Read from and Write to MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/)\n* [Simplify your Code with Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/)\n* [Transform your Data](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/aggregation/)\n* [Create Indexes to Speed Up Queries](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/indexes/)\n* [Sort Using Collations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/collations/)\n* [Log Events in the Driver](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/logging/)\n* [Monitor Driver Events](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/monitoring/)\n* [Store and Retrieve Large Files in MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/gridfs/)\n* [Encrypt Fields in a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/csfle/)\n* [Use a Time Series Collection](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/time-series/) ## API Documentation The MongoDB Java driver API documentation contains several libraries organized by functionality. For detailed information about classes and methods in each library, see the following table for their descriptions and links to the API documentation.\n\n ## FAQ For answers to commonly asked questions about the MongoDB Java Driver, see the [Frequently Asked Questions (FAQ)](https://mongodb.com/docs/drivers/java/sync/current/faq/)section. ## Issues & Help Learn how to report bugs, contribute to the driver, and find additional resources for asking questions and receiving help in the[Issues & Help](https://mongodb.com/docs/drivers/java/sync/current/issues-and-help/) section. ## Compatibility For the compatibility charts that show the recommended Java Driver version for each MongoDB Server version, see the[Compatibility](https://mongodb.com/docs/drivers/java/sync/current/compatibility/) section. ## What's New For a list of new features and changes in each version, see the[What's New](https://mongodb.com/docs/drivers/java/sync/current/whats-new/) section. ## Upgrade Driver Versions Learn what changes you may need to make to your application to upgrade driver versions in the [Upgrade Driver Versions](https://mongodb.com/docs/drivers/java/sync/current/upgrade/#std-label-java-upgrade-driver)section. ## Migrate from the Legacy API Learn what changes you may need to make to your application to migrate from the legacy API to the current API in the [Migrate from the Legacy API](https://mongodb.com/docs/drivers/java/sync/current/legacy/#std-label-java-legacy-api) section. ## Learn Visit the Developer Hub and MongoDB University to learn more about the MongoDB Java driver. ### Developer Hub The Developer Hub provides tutorials and social engagement for developers. To learn how to use MongoDB features with the Java driver, see the [How To's and Articles page.](https://www.mongodb.com/developer/learn/?content=Articles&text=java#main) To ask questions and engage in discussions with fellow developers using the Java Driver, see the [forums page.](https://www.mongodb.com/community/forums/tag/java) ### MongoDB University MongoDB University provides free courses to teach everyone how to use MongoDB. #### Take the free online course taught by MongoDB instructors | ![MongoDB Java Course Hero](https://mongodb.com/docs/drivers/java/sync/current/includes/figures/M220J_hero.jpg) | [Using MongoDB with Java](https://learn.mongodb.com/learning-paths/using-mongodb-with-java)Learn the essentials of Java application development with MongoDB. |\n| -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- | [Quick Start](https://mongodb.com/docs/drivers/java/sync/current/quick-start/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/whats-new/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # What's New On this page * [What's New in 4.9](#what-s-new-in-4.9)\n* [What's New in 4.8](#what-s-new-in-4.8)\n* [What's New in 4.7.1](#what-s-new-in-4.7.1)\n* [What's New in 4.7](#what-s-new-in-4.7)\n* [What's New in 4.6](#what-s-new-in-4.6)\n* [What's New in 4.5](#what-s-new-in-4.5)\n* [What's New in 4.4](#what-s-new-in-4.4)\n* [What's New in 4.3](#what-s-new-in-4.3)\n* [What's New in 4.2](#what-s-new-in-4.2)\n* [What's New in 4.1](#what-s-new-in-4.1)\n* [What's New in 4.0](#what-s-new-in-4.0) Learn what's new in: * [Version 4.9](#std-label-version-4.9)\n* [Version 4.8](#std-label-version-4.8)\n* [Version 4.7.1](#std-label-version-4.7.1)\n* [Version 4.7.0](#std-label-version-4.7.0)\n* [Version 4.6](#std-label-version-4.6)\n* [Version 4.5](#std-label-version-4.5)\n* [Version 4.4](#std-label-version-4.4)\n* [Version 4.3](#std-label-version-4.3)\n* [Version 4.2](#std-label-version-4.2)\n* [Version 4.1](#std-label-version-4.1)\n* [Version 4.0](#std-label-version-4.0) ## What's New in 4.9 * Added a new exception to identify when a constructor annotated by`BsonCreator` contains parameters with annotations other than`BsonProperty` or `BsonId`.\n* Changed the log message format for command monitoring messages reported by the `org.mongodb.driver.protocol.command` package.\n* Added support for the `$documents` aggregation pipeline stage to the[Aggregates](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates#documents%28java.util.List%29)helper class.\n* Added [MongoClientSettings.Builder.applyToLoggerSettings()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html#applyToLoggerSettings%28com.mongodb.Block%29)and [LoggerSettings.Builder.maxDocumentLength()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/LoggerSettings.Builder.html#maxDocumentLength%28int%29)methods that let you specify a maximum length for the extended JSON representation of a BSON document in a log message. ## What's New in 4.8\n\n ## Important ### Deprecation Notice The `IterableCodec` and `MapCodec` classes are deprecated. Instead, use `CollectionCodec` and `MapCodecV2`. These support any class that implements `Collection` or`Map`. Behavioral changes with the 4.8 driver release include: * Requirement that you add an explicit dependency on the `org.bson.codecs.record`module if your application deploys the driver in an OSGi container and relies on the driver for encoding and decoding Java records.\n* Logging of new connection messages at the `DEBUG` level instead of at `INFO`. New features of the 4.8 driver release include: * Support for authentication with AWS. The driver takes an optional dependency on both AWS SDK version 1 and version 2.\n* Support for obtaining credentials from the environment for both GCP and Azure for in-use encryption.\n* Support for deserialization of records containing components with generic parameters.\n* Support for deserialization of records containing components with more specific container types, such as `SortedSet`, `NavigableMap`, `LinkedList`, or `TreeSet`.\n* Support for recursive record types, records whose type definitions contain cycles.\n* Inclusion of the `disambiguatedPaths` field in change stream update events when the `showExpandedEvents` server feature is enabled on MongoDB v6.1 and later. Learn more about this field from the [getDisambiguatedPaths()](https://mongodb.github.io/mongo-java-driver/4.8/apidocs/mongodb-driver-core/com/mongodb/client/model/changestream/UpdateDescription.html#getDisambiguatedPaths%28%29)API documentation. Learn more about the `showExpandedEvents` setting from the [Expanded Events](https://www.mongodb.com/docs/manual/reference/change-events/#expanded-events)server documentation. ## What's New in 4.7.1 The 4.7.1 driver patches a bug that affects Client-Side Field Level Encryption and Queryable Encryption. The bug can cause data corruption when rotating [Data Encryption Keys](https://www.mongodb.com/docs/manual/core/csfle/fundamentals/keys-key-vaults/#std-label-csfle-key-architecture)(DEKs) encrypted with a [Customer Master Key](https://www.mongodb.com/docs/manual/core/csfle/fundamentals/keys-key-vaults/#std-label-csfle-key-architecture)hosted on Google Cloud Key Management Service or Azure Key Vault. The bug was present in version 4.7.0 of the driver in the `RewrapManyDataKey` method and causes the loss of your DEKs. ## Important ### Back Up your Key Vault Collection Always back up your [Key Vault Collection](https://www.mongodb.com/docs/manual/core/csfle/fundamentals/keys-key-vaults/#std-label-csfle-reference-key-vault)before you rotate your DEKs. If you lose your DEKs, you lose access to all the data encrypted with those keys. ## What's New in 4.7 New features of the 4.7 driver release include:\n\n ## What's New in 4.6 New features of the 4.6 Java driver release include: * The buffer pool is now shared across all `MongoClient` instances. The buffer pool prunes buffers that have been idle for one minute.\n* Added an API to specify suppliers for AWS KMS credentials for Client-Side Field Level Encryption (CSFLE). See the[AutoEncryptionSettings.Builder.kmsProviderPropertySuppliers()](https://mongodb.github.io/mongo-java-driver/4.6/apidocs/mongodb-driver-core/com/mongodb/AutoEncryptionSettings.Builder.html#kmsProviderPropertySuppliers%28java.util.Map%29)and the [ClientEncryptionSettings.Builder.kmsProviderPropertySuppliers()](https://mongodb.github.io/mongo-java-driver/4.6/apidocs/mongodb-driver-core/com/mongodb/ClientEncryptionSettings.html#getKmsProviderPropertySuppliers%28%29)API documentation for more information.\n* Added compatibility to `org.mongodb:mongodb-crypt`, a dependency for CSFLE, for Apple M1 ARM-based hardware.\n* Added a service provider interface (SPI) to allow the driver to specify a custom DNS client. See the [DnsClient](https://mongodb.github.io/mongo-java-driver/4.6/apidocs/mongodb-driver-core/com/mongodb/spi/dns/DnsClient.html)and the [DnsClientProvider](https://mongodb.github.io/mongo-java-driver/4.6/apidocs/mongodb-driver-core/com/mongodb/spi/dns/DnsClientProvider.html)interface API documentation for more information.\n* Added driver support for encoding and decoding between [Java records](https://docs.oracle.com/en/java/javase/17/language/records.html)and BSON documents, which is enabled by default. See [Document Data Format: Records](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-record/#std-label-fundamentals-records)for more information. ## What's New in 4.5 New features of the 4.5 Java driver release include:\n\n ## What's New in 4.4 New features of the 4.4 Java driver release include: * Compatibility with MongoDB 5.1 and support for Java 17\n* Added support for index hints in an `AggregateIterable`\n* Added support for the `$merge` and `$out` aggregation stages on secondaries\n* Use of the `mergeObjects()` method in the `Updates` builder\n* `DocumentCodec` does not ignore a [CodecRegistry](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/#std-label-codecs-codecregistry) when writing to an `Iterable` or a `Map` instance ## What's New in 4.3 New features of the 4.3 Java driver release include: * Added support for the MongoDB Stable API. For more information, see our[Stable API guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/stable-api/#std-label-stable-api-java)  \n## Note  \nStarting from February 2022, the **Versioned API** is known the**Stable API**. All concepts and features remain the same with this naming change.\n* Added support for connection to[MongoDB Atlas Serverless Instances](https://www.mongodb.com/cloud/atlas/serverless). For more information on setup, see our documentation on how to[Create a New Serverless Instance](https://www.mongodb.com/docs/atlas/tutorial/create-new-serverless-instance/?jmp=docs%5Fdriver%5Fjava)\n* Added a builder API for the `setWindowFields` pipeline stage to allow the use of window operators\n* Added support for setting Netty [io.netty.handler.ssl.SslContext](https://netty.io/4.1/api/io/netty/handler/ssl/SslContext.html)\n* Added support for snapshot reads to `ClientSession`\n* Limited the rate of establishing new connections per connection pool\n* Removed most restrictions on allowed characters in the field names of documents you insert or replace. This is a behavioral change for any application that is relying on client-side enforcement of these restrictions. The following table shows the restriction status on allowed characters in the field names of documents:\n\n ## Note Unacknowledged writes using dollar-prefixed or dotted keys may be silently rejected by pre-5.0 servers, where some restrictions on field names are still enforced in the server. ## What's New in 4.2 New features of the 4.2 Java driver release include: * Added Azure and GCP key stores to client-side field level encryption\n* Added Kerberos caching tickets for reuse in multiple authentication requests- Added [MongoClients](https://mongodb.github.io/mongo-java-driver/4.2/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClients.html) instances with `MongoClientSettings` or `ConnectionString` as the configuration\n* Use of the `explain()` method on [find](https://mongodb.github.io/mongo-java-driver/4.2/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#explain%28%29) and [aggregate](https://mongodb.github.io/mongo-java-driver/4.2/apidocs/mongodb-driver-sync/com/mongodb/client/AggregateIterable.html#explain%28%29) commands\n* Added a [JsonObject](https://mongodb.github.io/mongo-java-driver/4.2/apidocs/bson/org/bson/json/JsonObject.html) class to make encoding from and decoding to JSON more efficient by avoiding an intermediate Map representation\n* Added a [BsonRepresentation](https://mongodb.github.io/mongo-java-driver/4.2/apidocs/bson/org/bson/codecs/pojo/annotations/BsonRepresentation.html) annotation that allows you to represent the `ObjectId` BSON values as a `String` in [POJO](https://en.wikipedia.org/wiki/Plain%5Fold%5FJava%5Fobject) classes\n* Added a [Filters.empty()](https://mongodb.github.io/mongo-java-driver/4.2/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#empty%28%29) method ## Important There are breaking changes that may affect your application. See the[Upgrading Guide](https://mongodb.github.io/mongo-java-driver/4.2/upgrading/)for more information. ## What's New in 4.1 New features of the 4.1 Java driver release include: * Significant reduction in client-perceived failover times during planned maintenance events\n* The [update()](https://mongodb.github.io/mongo-java-driver/4.1/apidocs/mongodb-driver-core/com/mongodb/client/model/UpdateOptions.html#hint%28org.bson.conversions.Bson%29) and [delete()](https://mongodb.github.io/mongo-java-driver/4.1/apidocs/mongodb-driver-core/com/mongodb/client/model/DeleteOptions.html#hint%28org.bson.conversions.Bson%29) methods now support index hints\n* The `find()` method supports [allowDiskUse()](https://mongodb.github.io/mongo-java-driver/4.1/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#allowDiskUse%28java.lang.Boolean%29) for sorts that require too much memory to execute in RAM\n* Added support for the MONGODB-AWS authentication mechanism using Amazon Web Services (AWS) Identity and Access Management (IAM) credentials\n* Authentication requires fewer round trips to the server, resulting in faster connection setup ## What's New in 4.0 This release adds no new features. ← [Compatibility](https://mongodb.com/docs/drivers/java/sync/current/compatibility/ \"Previous Section\")[Upgrade Driver Versions](https://mongodb.com/docs/drivers/java/sync/current/upgrade/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/upgrade/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Upgrade Driver Versions On this page * [Overview](#overview)\n* [Breaking Changes](#breaking-changes)\n* [Server Release Compatibility Changes](#server-release-compatibility-changes) ## Overview In this section, you can identify the changes you need to make to your application to upgrade your driver to a new version. Before you upgrade, perform the following actions: * Ensure the new version is compatible with the MongoDB server versions your application connects to and the Java Runtime Environment (JRE) your application runs on. See the [Java Compatibility](https://mongodb.com/docs/drivers/java/sync/current/compatibility/#std-label-java-compatibility-tables)page for this information.\n* Address any breaking changes between the current version of the driver your application is using and your planned upgrade version in the[Breaking Changes](#std-label-java-breaking-changes) section. To learn more about the MongoDB server release compatibility changes, see the[Server Release Compatibility Changes](#std-label-java-server-release-changes) section. ## Tip To minimize the amount of changes your application may require when upgrading driver versions in the future, use the[Stable API.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/stable-api/#std-label-stable-api-java) ## Breaking Changes A breaking change is a modification in a convention or behavior in a specific version of the driver that may prevent your application from working properly if not addressed before upgrading. The breaking changes in this section are categorized by the driver version that introduced them. When upgrading driver versions, address all the breaking changes between the current and upgrade versions. For example, if you are upgrading the driver from v4.0 to v4.5, address all breaking changes from the version after v4.0 including any listed under v4.5. ### Version 4.8 Breaking Changes * The driver ends support for connecting to MongoDB server versions v3.4 and earlier. To learn more about this change, see the [Version 4.8 Server Release Support Changes](#std-label-java-server-release-change-v4.8)section.\n* You must add an explicit dependency on the `org.bson.codecs.record`module if your application deploys the driver in an OSGi container and relies on the driver for encoding and decoding Java records.\n* The `RecordCodec`, implemented in v4.6, deserialized POJOs and record classes that are specified as type parameters of `List` or `Map` fields of a record as `Document` values instead of their respective classes. This version now deserializes them to the proper record and POJO types.  \nFor example, the following record class definitions show a `Book` record that contains a `List` that receives a `Chapter` type parameter:  \n`| public record Book(String title, List<Chapter> chapters) {} |  \n| ----------------------------------------------------------- |  \n| public record Chapter(Integer number, String text) {}       |  \n`  \nStarting in this version, the codec deserializes data in the `List` into`Chapter` record classes instead of `Document` values. ### Version 4.7 Breaking Changes * The `setWindowFields` builder API is no longer beta. The new builder breaks binary and source compatibility. See the[Aggregates API documentation](https://mongodb.github.io/mongo-java-driver/4.7/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html)for information the new `setWindowFields()` method signatures.  \nIf your application uses this builder in a version prior to v4.7, update your source code to use the new method signature and rebuild your binary. ### Version 4.2 Breaking Changes\n\n ### Version 4.0 Breaking Changes * Several classes and methods marked as deprecated in the 3.12 release were removed in this version.\n* The insert helper methods return an insert result object instead of`void`.\n* The `toJson()` methods on `BsonDocument`, `Document`, and`DbObject` return a relaxed JSON format instead of a strict JSON format. This makes the JSON documents more readable, but can make it more difficult to identify the BSON type information, such as the difference between a 32-bit and 64-bit integer. If your application relies on the strict JSON format, use the strict mode when reading or writing data. Learn how to specify the JSON format in the current API in the[Document Data Format: Extended JSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-extended-json/#std-label-java-extended-json) guide.\n* The default BSON representation of `java.util.UUID` value was changed from `JAVA_LEGACY` to `UNSPECIFIED`. Applications that store or retrieve UUID values must explicitly specify which representation to use. You can specify the representation in the `uuidRepresentation` property of`MongoClientSettings`.\n* The connection pool no longer restricts the number of wait queue threads or asynchronous tasks that require a connection to MongoDB. The application should throttle requests as necessary rather than depend on the driver to throw a `MongoWaitQueueFullException`.\n* The driver no longer logs using the `java.util.logging` (JUL) package and only supports the SLF4J logging framework.\n* The embedded and Android drivers were removed. If your application relies on these drivers, you must continue to use a 3.x Java driver version.\n* The uber JARs, `mongo-java-driver` and `mongodb-driver`, are no longer published. If your application relies on one of these, you must switch to either `mongodb-driver-sync` or `mongodb-driver-legacy`depending on which API the application uses. Make sure you remove the uber JARs from your dependencies.\n* Updates to several classes introduced binary compatibility breaks, such as the method signature change to the insert helper methods. Recompile any classes that link to the driver against this version or later to ensure that they continue to work. ## Server Release Compatibility Changes A server release compatibility change is a modification to the MongoDB Java Driver that discontinues support for a set of MongoDB server versions. The driver discontinues support for a MongoDB server version after it reaches end-of-life (EOL). To learn more about the MongoDB support for EOL products, see the [Legacy Support Policy.](https://www.mongodb.com/support-policy/legacy) ### Version 4.8 Server Release Support Changes * The v4.8 driver drops support for MongoDB server v3.4 and earlier. To use the v4.8 driver, your MongoDB server must be v3.6 or later. To learn how to upgrade your MongoDB server to v3.6, follow the link that corresponds to your MongoDB deployment configuration:  \n   * [Upgrade a Replica Set to 3.6](https://www.mongodb.com/docs/manual/release-notes/3.6-upgrade-replica-set/#std-label-3.6-upgrade-replica-set)  \n   * [Upgrade a Standalone to 3.6](https://www.mongodb.com/docs/manual/release-notes/3.6-upgrade-standalone/#std-label-3.6-upgrade-standalone)  \n   * [Upgrade a Sharded Cluster to 3.6](https://www.mongodb.com/docs/manual/release-notes/3.6-upgrade-sharded-cluster/#std-label-3.6-upgrade-sharded-cluster) ← [What's New](https://mongodb.com/docs/drivers/java/sync/current/whats-new/ \"Previous Section\")[Migrate from the Legacy API](https://mongodb.com/docs/drivers/java/sync/current/legacy/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/quick-reference/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Quick Reference This page shows the driver syntax for several MongoDB commands and links to their related reference and API documentation.\n\n ← [Quick Start](https://mongodb.com/docs/drivers/java/sync/current/quick-start/ \"Previous Section\")[Usage Examples](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/find-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Find Operations * [Find a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/findOne/)\n* [Find Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/find/) ← [Usage Examples](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/ \"Previous Section\")[Find a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/findOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/insert-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Insert Operations * [Insert a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertOne/)\n* [Insert Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertMany/) ← [Find Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/find/ \"Previous Section\")[Insert a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/deleteMany/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Delete Multiple Documents You can delete multiple documents from a collection in a single operation by calling the `deleteMany()` method on a `MongoCollection` object. To specify which documents to delete, pass a query filter that matches the documents you want to delete. If you provide an empty document, MongoDB matches all documents in the collection and deletes them. While you can use `deleteMany()` to delete all documents in a collection, consider using the `drop()` method instead for better performance. Upon successful deletion, this method returns an instance of`DeleteResult`. You can retrieve information such as the number of documents deleted by calling the `getDeletedCount()` method on the`DeleteResult` instance. If your delete operation fails, the driver raises an exception. For more information on the types of exceptions raised under specific conditions, see the API documentation for `deleteMany()`, linked at the bottom of this page. ## Example The following snippet deletes multiple documents from the `movies`collection in the `sample_mflix` database. The query filter passed to the `deleteMany()` method matches all movie documents that contain a `rating` of less than **1.9** in the `imdb`sub-document. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n\n ` When you run the example, you should see output that reports the number of documents deleted in your call to `deleteMany()`. ``` Deleted document count: 4 \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [deleteMany()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#deleteMany%28org.bson.conversions.Bson%29)\n* [DeleteResult](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/result/DeleteResult.html)\n* [drop()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#drop%28%29) ← [Delete a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/deleteOne/ \"Previous Section\")[Perform Bulk Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/bulkWrite/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/count/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Count Documents There are two instance methods in the `MongoCollection` class that you can call to count the number of documents in a collection: * `countDocuments()` returns the number of documents in the collection that match a specified query. If you specify an empty query filter, the method returns the total number of documents in the collection.\n* `estimatedDocumentCount()` returns an **estimation** of the number of documents in the collection based on the collection metadata. You cannot specify a query when using this method. The `estimatedDocumentCount()` method returns more quickly than the`countDocuments()` method because it uses the collection's metadata rather than scanning the entire collection. The `countDocuments()` method returns an **accurate** count of the number of documents and supports specifying a filter. When you call the `countDocuments()` method, you can optionally pass a**query filter** parameter. You cannot pass any parameters when you call`estimatedDocumentCount()`. ## Important ### Stable API V1 and MongoDB Server Issue If you are using the Stable API `V1` with the \"strict\" option and a MongoDB server version between 5.0.0 and 5.0.8 inclusive, method calls to`estimatedDocumentCount()` may error due to a server bug. Upgrade to MongoDB server 5.0.9 or set the Stable API \"strict\" option to`false` to avoid this issue. You can also pass an optional parameter to either of these methods to specify the behavior of the call: | Method                   | Optional Parameter Class      | Description                                                                                                                                          |\n| ------------------------ | ----------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| countDocuments()         | CountOptions                  | You can specify a maximum number of documents to count by using thelimit() method or the maximum amount of execution time using themaxTime() method. |\n| estimatedDocumentCount() | EstimatedDocumentCountOptions | You can specify the maximum execution time using the maxTime()method.                                                                                | Both methods return the number of matching documents as a `long` primitive. ## Example The following example estimates the number of documents in the`movies` collection in the `sample_mflix` database, and then returns an accurate count of the number of documents in the `movies`collection with `Canada` in the `countries` field. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n\n ` If you run the preceding sample code, you should see output that looks something like this (exact numbers may vary depending on your data): ``` Estimated number of documents in the movies collection: 23541 Number of movies from Spain: 755 \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [countDocuments()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#countDocuments%28%29)\n* [estimatedDocumentCount()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#estimatedDocumentCount%28%29)\n* [CountOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/CountOptions.html)\n* [EstimatedDocumentCountOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/EstimatedDocumentCountOptions.html) ← [Watch for Changes](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/watch/ \"Previous Section\")[Retrieve Distinct Values of a Field](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/distinct/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/compatibility/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Compatibility On this page * [MongoDB Compatibility](#mongodb-compatibility)\n* [Compatibility Table Legend](#compatibility-table-legend)\n* [Language Compatibility](#language-compatibility) ## MongoDB Compatibility The following compatibility table specifies the recommended version(s) of the MongoDB Java Driver for use with a specific version of MongoDB. The first column lists the driver version(s). ### Compatibility Table Legend | Icon    | Explanation                                                                                            |\n| ------- | ------------------------------------------------------------------------------------------------------ |\n| ✓       | All features are supported.                                                                            |\n| ⊛       | The Driver version will work with the MongoDB version, but not all new MongoDB features are supported. |\n| No mark | The Driver version is not tested with the MongoDB version.                                             |\n\n ## Language Compatibility The following compatibility table specifies the recommended version(s) of the MongoDB Java Driver for use with a specific version of Java. The first column lists the driver version(s).\n\n | \\[[1](#ref-lts-note-id1)\\] | In the future, only LTS Java versions will be explicitly listed. |\n| -------------------------- | ---------------------------------------------------------------- | For more information on how to read the compatibility tables, see our guide on[MongoDB Compatibility Tables.](https://www.mongodb.com/docs/drivers/about-compatibility/#std-label-about-driver-compatibility) ← [Issues & Help](https://mongodb.com/docs/drivers/java/sync/current/issues-and-help/ \"Previous Section\")[What's New](https://mongodb.com/docs/drivers/java/sync/current/whats-new/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/insertMany/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Insert Multiple Documents You can insert multiple documents into a collection in a single operation by calling the `insertMany()` method on a `MongoCollection`object. To insert them, add your `Document` objects to a `List` and pass that `List` as an argument to `insertMany()`. If you call the `insertMany()` method on a collection that does not exist yet, the server creates it for you. Upon successful insertion, `insertMany()` returns an instance of`InsertManyResult`. You can retrieve information such as the `_id`fields of the documents you inserted by calling the `getInsertedIds()`method on the `InsertManyResult` instance. If your insert operation fails, the driver raises an exception. For more information on the types of exceptions raised under specific conditions, see the API documentation for `insertMany()`, linked at the bottom of this page. ## Example The following snippet inserts multiple documents into the `movies`collection. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n\n ` When you run the example, you should see output that resembles the following with the inserted documents' `ObjectId` values in each of the value fields: ``` Inserted document ids: {0=BsonObjectId{value=...}, 1=BsonObjectId{value=...}} \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [insertMany()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#insertMany%28java.util.List%29)\n* [Document](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/Document.html)\n* [InsertManyResult](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/result/InsertManyResult.html) ← [Insert a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertOne/ \"Previous Section\")[Update & Replace Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/update-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/findOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Find a Document You can retrieve a single document in a collection by chaining together the `find()` and `first()` methods on a `MongoCollection` object. You can pass a query filter to the `find()` method to query for and return documents that match the filter in the collection. If you do not include a filter, MongoDB returns all the documents in the collection. The`first()` method returns the first matching document. For more information on querying MongoDB with the Java driver, see our[guide on Querying Documents.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/retrieve/) You can also chain other methods to the `find()` method such as `sort()` which organizes the matched documents in a specified order, and`projection()` which configures the fields included in the returned documents. For more information on the `sort()` method, see our[guide on Sorting](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/). For more information on the `projection()` method, see our[guide on Projections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/project/) The `find()` method returns an instance of `FindIterable`, a class that offers several methods to access, organize, and traverse the results.`FindIterable` also inherits methods from its parent class,`MongoIterable` such as `first()`. The `first()` method returns the first document from the retrieved results or `null` if there are no results. ## Example The following snippet finds a single document from the `movies` collection. It uses the following objects and methods: * A **query filter** that is passed to the `find()` method. The `eq`filter matches only movies with the title exactly matching the text`'The Room'`.\n* A **sort** that organizes matched documents in descending order by rating, so if our query matches multiple documents the returned document is the one with the highest rating.\n* A **projection** that includes the objects in the `title` and `imdb`fields and excludes the `_id` field using the helper method`excludeId()`. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n\n ` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [FindIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html)\n* [MongoIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoIterable.html)\n* [find()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#find%28%29)\n* [first()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoIterable.html#first%28%29) ← [Find Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/find-operations/ \"Previous Section\")[Find Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/find/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/delete-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Delete Operations * [Delete a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/deleteOne/)\n* [Delete Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/deleteMany/) ← [Replace a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/replaceOne/ \"Previous Section\")[Delete a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/deleteOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/update-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Update & Replace Operations * [Update a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/updateOne/)\n* [Update Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/updateMany/)\n* [Replace a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/replaceOne/) ← [Insert Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertMany/ \"Previous Section\")[Update a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/updateOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/bulkWrite/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Perform Bulk Operations The `bulkWrite()` method performs batch write operations against a_single_ collection. This method reduces the number of network round trips from your application to your MongoDB instance which increases the performance of your application. Since you only receive the success status after all the operations return, we recommend you use this if that meets the requirements of your use case. You can specify one or more of the following write operations in`bulkWrite()`: * `insertOne`\n* `updateOne`\n* `updateMany`\n* `deleteOne`\n* `deleteMany`\n* `replaceOne` The `bulkWrite()` method accepts the following parameters: * A `List` of objects that implement `WriteModel`: the classes that implement `WriteModel` correspond to the aforementioned write operations. E.g. the `InsertOneModel` class wraps the `insertOne` write operation. See the links to the API documentation at the bottom of this page for more information on each class.\n* `BulkWriteOptions`: _optional_ object that specifies settings such as whether to ensure your MongoDB instance orders your write operations. ## Note Retryable writes run on MongoDB server versions 3.6 or later in bulk write operations unless they include one or more instances of`UpdateManyModel` or `DeleteManyModel`. ## Tip By default, MongoDB executes bulk write operations one-by-one in the specified order (i.e. serially). During an ordered bulk write, if an error occurs during the processing of an operation, MongoDB returns without processing the remaining operations in the list. In contrast, when you set `ordered` to `false`, MongoDB continues to process remaining write operations in the list in the event of an error. Unordered operations are theoretically faster since MongoDB can execute them in parallel, but you should only use them if your writes do not depend on order. The `bulkWrite()` method returns a `BulkWriteResult` object that contains information about the write operation results including the number of documents inserted, modified, and deleted. If one or more of your operations attempts to set a value that violates a unique index on your collection, an exception is raised that should look something like this: `| The bulk write operation failed due to an error: Bulk write operation error on server <hostname>. Write errors: [BulkWriteError{index=0, code=11000, message='E11000 duplicate key error collection: ... }]. |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ` Similarly, if you attempt to perform a bulk write against a collection that uses schema validation and one or more of your write operations provide an unexpected format, you may encounter exceptions. ## Example The following code sample performs an ordered bulk write operation on the`movies` collection in the `sample_mflix` database. The example call to `bulkWrite()` includes examples of the `InsertOneModel`,`UpdateOneModel`, and `DeleteOneModel`. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb) ```java package usage.examples; import java.util.Arrays; import org.bson.Document; import com.mongodb.MongoException; import com.mongodb.bulk.BulkWriteResult; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; import com.mongodb.client.model.DeleteOneModel; import com.mongodb.client.model.InsertOneModel; import com.mongodb.client.model.ReplaceOneModel; import com.mongodb.client.model.UpdateOneModel; import com.mongodb.client.model.UpdateOptions; public class BulkWrite {     public static void main(String[] args) {         // Replace the uri string with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {\n\n             MongoCollection<Document> collection = database.getCollection(\"movies\");             try {                 BulkWriteResult result = collection.bulkWrite(                         Arrays.asList(                                 new InsertOneModel<>(new Document(\"name\", \"A Sample Movie\")),                                 new InsertOneModel<>(new Document(\"name\", \"Another Sample Movie\")),                                 new InsertOneModel<>(new Document(\"name\", \"Yet Another Sample Movie\")),                                 new UpdateOneModel<>(new Document(\"name\", \"A Sample Movie\"),                                         new Document(\"$set\", new Document(\"name\", \"An Old Sample Movie\")),                                         new UpdateOptions().upsert(true)),                                 new DeleteOneModel<>(new Document(\"name\", \"Yet Another Sample Movie\")),                                 new ReplaceOneModel<>(new Document(\"name\", \"Yet Another Sample Movie\"),                                         new Document(\"name\", \"The Other Sample Movie\").append(\"runtime\",  \"42\"))                                 ));                 System.out.println(\"Result statistics:\" +                         \"\\ninserted: \" + result.getInsertedCount() +                         \"\\nupdated: \" + result.getModifiedCount() +                         \"\\ndeleted: \" + result.getDeletedCount());             } catch (MongoException me) {                 System.err.println(\"The bulk write operation failed due to an error: \" + me);             }         }     } } \n``` The output should look something like this: ``` Result statistics: inserted: 3 updated: 2 deleted: 1 \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following resources:\n\n ← [Delete Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/deleteMany/ \"Previous Section\")[Watch for Changes](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/watch/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/updateOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Update a Document You can update a single document using the `updateOne()` method on a `MongoCollection` object. The method accepts a **filter** that matches the document you want to update and an **update** statement that instructs the driver how to change the matching document. The `updateOne()` method only updates the first document that matches the filter. To perform an update with the `updateOne()` method, you must pass a query filter and an update document. The query filter specifies the criteria for which document to perform the update on and the update document provides instructions on what changes to make to it. You can optionally pass an instance of `UpdateOptions` to the `updateOne()` method in order to specify the method's behavior. For example, if you set the `upsert` field of the `UpdateOptions` object to `true`, the operation inserts a new document from the fields in both the query and update document if no documents match the query filter. See the link to the `UpdateOptions` API documentation at the bottom of this page for more information. Upon successful execution, the `updateOne()` method returns an instance of `UpdateResult`. You can retrieve information such as the number of documents modified by calling the `getModifiedCount()` method, or the value of the `_id` field by calling the `getUpsertedId()` method if you specified `upsert(true)` in an `UpdateOptions` instance. If your update operation fails, the driver raises an exception. For example, if you try to set a value for the immutable field `_id` in your update document, the method throws a `MongoWriteException` with the message: `| Performing an update on the path '_id' would modify the immutable field '_id' |\n| ----------------------------------------------------------------------------- | ` If your update document contains a change that violates unique index rules, the method throws a `MongoWriteException` with an error message that should look something like this: ``` E11000 duplicate key error collection: ... \n``` For more information on the types of exceptions raised under specific conditions, see the API documentation for `updateOne()`, linked at the bottom of this page. ## Example In this example, we update the first match for our query in the `movies`collection of the `sample_mflix` database. We perform the following updates to the matching document: * Set the value of `runtime` to `99`\n* Add `Sports` to the array of `genres` only if it does not already exist\n* Set the value of `lastUpdated` to the current time. We use the `Updates` builder, a factory class that contains static helper methods, to construct the update document. While you can pass an update document instead of using the builder, the builder provides type checking and simplified syntax. For more information on the `Updates` builder, see our[guide on the Updates builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/) ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb) ```java package usage.examples; import org.bson.Document; import org.bson.conversions.Bson; import com.mongodb.MongoException; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; import com.mongodb.client.model.UpdateOptions; import com.mongodb.client.model.Updates; import com.mongodb.client.result.UpdateResult; public class UpdateOne {     public static void main(String[] args) {         // Replace the uri string with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {             MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n\n             Document query = new Document().append(\"title\",  \"Cool Runnings 2\");             Bson updates = Updates.combine(                     Updates.set(\"runtime\", 99),                     Updates.addToSet(\"genres\", \"Sports\"),                     Updates.currentTimestamp(\"lastUpdated\"));             UpdateOptions options = new UpdateOptions().upsert(true);             try {                 UpdateResult result = collection.updateOne(query, updates, options);                 System.out.println(\"Modified document count: \" + result.getModifiedCount());                 System.out.println(\"Upserted id: \" + result.getUpsertedId()); // only contains a value when an upsert is performed             } catch (MongoException me) {                 System.err.println(\"Unable to update due to an error: \" + me);             }         }     } } \n``` After you run the example, you should see output that looks something like this: ``` Modified document count: 1 Upserted id: null \n``` Or if the example resulted in an upsert: ``` Modified document count: 0 Upserted id: BsonObjectId{value=...} \n``` If you query the updated document, it should look something like this: ``` Document {   { _id=...,     plot=...,     genres=[Adventure, Comedy, Family, Sports],     runtime=99,     ...     lastUpdated=Timestamp{...}   } } \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation:\n\n ← [Update & Replace Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/update-operations/ \"Previous Section\")[Update Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/updateMany/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/replaceOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Replace a Document You can replace a single document using the `replaceOne()` method on a `MongoCollection` object. This method removes all the existing fields and values from a document (except the `_id` field) and substitutes it with your replacement document. The `replaceOne()` method accepts a query filter that matches the document you want to replace and a replacement document that contains the data you want to save in place of the matched document. The `replaceOne()`method only replaces the first document that matches the filter. You can optionally pass an instance of `ReplaceOptions` to the `replaceOne()` method in order to specify the method's behavior. For example, if you set the `upsert`field of the `ReplaceOptions` object to `true`, the operation inserts a new document from the fields in the replacement document if no documents match the query filter. See the link to the `ReplaceOptions` API documentation at the bottom of this page for more information. Upon successful execution, the `replaceOne()` method returns an instance of `UpdateResult`. You can retrieve information such as the number of documents modified by calling the `getModifiedCount()` method. You can also retrieve the value of the document's `_id` field by calling the`getUpsertedId()` method if you set `upsert(true)` in the`ReplaceOptions` instance and the operation resulted in the insertion of a new document. If your replacement operation fails, the driver raises an exception. For example, if you try to specify a value for the immutable field`_id` in your replacement document that differs from the original document, the method throws a `MongoWriteException` with the message: `| After applying the update, the (immutable) field '_id' was found to have been altered to _id: ObjectId('...) |\n| ------------------------------------------------------------------------------------------------------------ | ` If your replacement document contains a change that violates unique index rules, the method throws a `MongoWriteException` with an error message that should look something like this: ``` E11000 duplicate key error collection: ... \n``` For more information on the types of exceptions raised under specific conditions, see the API documentation for `replaceOne()`, linked at the bottom of this page. ## Example In this example, we replace the first match of our query filter in the`movies` collection of the `sample_mflix` database with a replacement document. All the fields except for the `_id` field are deleted from the original document and are substituted by the replacement document. Before the `replaceOne()` operation runs, the original document contains several fields describing the movie. After the operation runs, the resulting document contains only the fields specified by the replacement document (`title` and `fullplot`) and the `_id` field. The following snippet uses the following objects and methods: * A **query filter** that is passed to the `replaceOne()` method. The `eq`filter matches only movies with the title exactly matching the text`'Music of the Heart'`.\n* A **replacement document** that contains the document that replaces the matching document if it exists.\n* A **ReplaceOptions** object with the `upsert` option set to `true`. This option specifies that the method should insert the data contained in the replacement document if the query filter does not match any documents. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb) ```java package usage.examples; import static com.mongodb.client.model.Filters.eq; import org.bson.Document; import org.bson.conversions.Bson; import com.mongodb.MongoException; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; import com.mongodb.client.model.ReplaceOptions; import com.mongodb.client.result.UpdateResult; public class ReplaceOne {     public static void main(String[] args) {         // Replace the uri string with your MongoDB deployment's connection string\n\n         try (MongoClient mongoClient = MongoClients.create(uri)) {             MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");             MongoCollection<Document> collection = database.getCollection(\"movies\");             Bson query = eq(\"title\", \"Music of the Heart\");             Document replaceDocument = new Document().                     append(\"title\", \"50 Violins\").                     append(\"fullplot\", \" A dramatization of the true story of Roberta Guaspari who co-founded the Opus 118 Harlem School of Music\");             ReplaceOptions opts = new ReplaceOptions().upsert(true);             UpdateResult result = collection.replaceOne(query, replaceDocument, opts);             System.out.println(\"Modified document count: \" + result.getModifiedCount());             System.out.println(\"Upserted id: \" + result.getUpsertedId()); // only contains a value when an upsert is performed         } catch (MongoException me) {             System.err.println(\"Unable to replace due to an error: \" + me);         }     } } \n``` After you run the example, you should see output that looks something like this: ``` Modified document count: 1 Upserted id: null \n``` Or if the example resulted in an upsert: ``` Modified document count: 0 Upserted id: BsonObjectId{value=...} \n``` If you query the replaced document, it should look something like this: ``` Document {   { _id=...,     title=50 Violins,     fullplot=A dramatization of the true story of Roberta Guaspari who co-founded the Opus 118 Harlem School of Music   } } \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [ReplaceOne](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#replaceOne%28org.bson.conversions.Bson,TDocument%29)\n* [ReplaceOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/ReplaceOptions.html?is-external=true)\n* [UpdateResult](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/result/UpdateResult.html)\n* [eq()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#eq%28java.lang.String,TItem%29) ← [Update Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/updateMany/ \"Previous Section\")[Delete Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/delete-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/updateMany/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Update Multiple Documents You can update multiple documents using the `updateMany()` method on a `MongoCollection` object. The method accepts a **filter** that matches the document you want to update and an **update** statement that instructs the driver how to change the matching document. The `updateMany()` method updates all the documents in the collection that match the filter. To perform an update with the `updateMany()` method, you must pass a query filter and an update document. The query filter specifies which documents in the collection to match and the update document provides instructions on what changes to make to them. You can optionally pass an instance of `UpdateOptions` to the `updateMany()` method in order to modify the behavior of the call. For example, if you set the`upsert` field of the `UpdateOptions` object to `true` and no documents match the specified query filter, the operation inserts a new document composed of the fields from both the query and update document. Upon successful execution, the `updateMany()` method returns an instance of `UpdateResult`. You can retrieve information such as the number of documents modified by calling the `getModifiedCount()` method. If you specified `upsert(true)` in an `UpdateOptions` object and the operation results in an insert, you can retrieve the `_id` field of the new document by calling the `getUpsertedId()` method on the`UpdateResult` instance. If your update operation fails, the driver raises an exception and does not update any of the documents matching the filter. For example, if you try to set a value for the immutable field `_id` in your update document, the`updateMany()` method does not update any documents and throws a`MongoWriteException` with the message: `| Performing an update on the path '_id' would modify the immutable field '_id' |\n| ----------------------------------------------------------------------------- | ` If your update document contains a change that violates unique index rules, the method throws a `MongoWriteException` with an error message that should look something like this: ``` E11000 duplicate key error collection: ... \n``` For more information on the types of exceptions raised under specific conditions, see the API documentation for `updateMany()`, linked at the bottom of this page. ## Example In this example, we update documents that match our query in the `movies`collection of the `sample_mflix` database. We perform the following updates to the matching documents: * Add `Frequently Discussed` to the array of `genres` only if it does not already exist\n* Set the value of `lastUpdated` to the current time. We use the `Updates` builder, a factory class that contains static helper methods to construct the update document. While you can pass an update document instead of using the builder, the builder provides type checking and simplified syntax. Read our[guide on Updates](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/) in the Builders section for more information. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb) ```java package usage.examples; import static com.mongodb.client.model.Filters.gt; import org.bson.Document; import org.bson.conversions.Bson; import com.mongodb.MongoException; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; import com.mongodb.client.model.Updates; import com.mongodb.client.result.UpdateResult; public class UpdateMany {     public static void main(String[] args) {         // Replace the uri string with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {             MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n\n             Bson query = gt(\"num_mflix_comments\", 50);             Bson updates = Updates.combine(                     Updates.addToSet(\"genres\", \"Frequently Discussed\"),                     Updates.currentTimestamp(\"lastUpdated\"));             try {                 UpdateResult result = collection.updateMany(query, updates);                 System.out.println(\"Modified document count: \" + result.getModifiedCount());             } catch (MongoException me) {                 System.err.println(\"Unable to update due to an error: \" + me);             }         }     } } \n``` After you run the example, you should see output that looks something like this: ``` Modified document count: 53 \n``` If you query the updated document or documents, they should look something like this: ``` [   Document {     { _id=...,       plot=...,       genres=[..., Frequently Discussed, ...],       ...       lastUpdated=Timestamp{...}     }   },   ... ] \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [UpdateMany](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#updateMany%28org.bson.conversions.Bson,java.util.List,com.mongodb.client.model.UpdateOptions%29)\n* [UpdateOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/UpdateOptions.html)\n* [combine()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#combine%28org.bson.conversions.Bson...%29)\n* [addToSet()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#addToSet%28java.lang.String,TItem%29)\n* [currentTimestamp()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#currentTimestamp%28java.lang.String%29)\n* [UpdateResult](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/result/UpdateResult.html) ← [Update a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/updateOne/ \"Previous Section\")[Replace a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/replaceOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/command/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Run a Command You can run all raw database operations using the`MongoDatabase.runCommand()` method. A raw database operation is a command you can execute directly on the MongoDB server CLI. These commands include administrative and diagnostic tasks, such as fetching server stats or initializing a replica set. Call the `runCommand()`method with a `Bson` command object on an instance of a `MongoDatabase`to run your raw database operation. ## Tip Use the [MongoDB Shell](https://www.mongodb.com/docs/mongodb-shell/) for administrative tasks instead of the Java driver whenever possible, since these tasks are often quicker and easier to implement with the shell than in a Java application. The `runCommand()` method accepts a command in the form of a `Bson` object. By default, `runCommand` returns an object of type`org.bson.Document` containing the output of the database command. You can specify a return type for `runCommand()` as an optional second parameter. ## Example In the following sample code, we send the `dbStats` command to request statistics from a specific MongoDB database. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n\n ` When you run the preceding command, you should see output similar to the following: ``` dbStats: {\"db\": \"sample_mflix\", \"collections\": 5, \"views\": 0, \"objects\": 75595, \"avgObjSize\": 692.1003770090614, \"dataSize\": 52319328, \"storageSize\": 29831168, \"numExtents\": 0, \"indexes\": 9, \"indexSize\": 14430208, \"fileSize\": 0, \"nsSizeMB\": 0, \"ok\": 1} \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following resources: * [runCommand()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#runCommand%28org.bson.conversions.Bson%29) API Documentation\n* [Database Commands](https://www.mongodb.com/docs/manual/reference/command/) Server Manual Entry\n* [dbStats](https://www.mongodb.com/docs/manual/reference/command/dbStats/) Server Manual Entry ← [Retrieve Distinct Values of a Field](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/distinct/ \"Previous Section\")[Fundamentals](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/insertOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Insert a Document You can insert a single document into a collection using the `insertOne()`method on a `MongoCollection` object. To insert a document, construct a`Document` object that contains the fields and values that you want to store. If you call the `insertOne()` method on a collection that does not exist yet, the server automatically creates it for you. Upon a successful insertion, `insertOne()` returns an instance of`InsertOneResult`. You can retrieve information such as the `_id`field of the document you inserted by calling the `getInsertedId()`method on the `InsertOneResult` instance. If your insert operation fails, the driver raises an exception. For more information on the types of exceptions raised under specific conditions, see the API documentation for `insertOne()`, linked at the bottom of this page. ## Example The following snippet inserts a single document into the `movies`collection. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n\n ` When you run the example, you should see output that resembles the following with the inserted document's `ObjectId` in the value field: ``` Inserted document id: BsonObjectId{value=...} \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [insertOne()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#insertOne%28TDocument%29)\n* [Document](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/Document.html)\n* [InsertOneResult](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/result/InsertOneResult.html) ← [Insert Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insert-operations/ \"Previous Section\")[Insert Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertMany/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/find/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Find Multiple Documents You can query for multiple documents in a collection by calling the `find()`method on a `MongoCollection` object. Pass a query filter to the`find()` method to query for and return documents that match the filter in the collection. If you do not include a filter, MongoDB returns all the documents in the collection. For more information on querying MongoDB with the Java driver, see our[guide on Querying Documents.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/retrieve/) You can also chain methods to the `find()` method such as `sort()` which organizes the matched documents in a specified order and`projection()` which configures the included fields in the returned documents. For more information on the `sort()` method, see our[guide on Sorting](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/). For more information on the `projection()` method, see our[guide on Projections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/project/) The `find()` method returns an instance of `FindIterable`, a class that offers several methods to access, organize, and traverse the results.`FindIterable` also inherits methods from its parent class,`MongoIterable` which implements the core Java interface `Iterable`. You can call the `iterator()` method on the `MongoIterable` which returns a `MongoCursor` instance that you can use to traverse the results. You can call methods on the `MongoCursor` such as `hasNext()` to check whether additional results exist, or `next()` to return the next document in the collection. If no documents match the query, calling `hasNext()`returns `false` and therefore calling `next()` throws an exception. If you call `next()` on the iterator either after it has returned the final result or when no results exist, it throws an exception of type`java.util.NoSuchElementException`. Always use `hasNext()` to check that additional results exist before you call `next()`. ## Example The following snippet finds and prints all documents that match a query on the `movies` collection. It uses the following objects and methods: * A **query filter** that is passed to the `find()` method. The `lt()`filter matches only movies with a runtime of less than 15 minutes.\n* A **sort** that organizes returned documents in descending order by title (\"Z\" before \"A\").\n* A **projection** that includes the objects in the `title` and `imdb`fields and excludes the `_id` field using the helper method`excludeId()`. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n\n ` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [FindIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html)\n* [MongoIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoIterable.html)\n* [MongoCursor](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCursor.html)\n* [find()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#find%28%29) ← [Find a Document](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/findOne/ \"Previous Section\")[Insert Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insert-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/deleteOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Delete a Document You can delete a single document from a collection using the `deleteOne()`method on a `MongoCollection` object. The method accepts a query filter that matches the document you want to delete. If you do not specify a filter, MongoDB matches the first document in the collection. The`deleteOne()` method only deletes the first document matched. This method returns an instance of `DeleteResult` which contains information including how many documents were deleted as a result of the operation. If your delete operation fails, the driver raises an exception. For more information on the types of exceptions raised under specific conditions, see the API documentation for `deleteOne()`, linked at the bottom of this page. ## Example The following snippet deletes a single document from the `movies`collection of the `sample_mflix` database. The example uses the `eq()`filter to match movies with the `title` exactly matching the text`'The Garbage Pail Kids Movie'`. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n\n ` When you run the example, if the query filter you passed in your call to`deleteOne()` matches a document and removes it, you should see output that looks something like this: ``` Deleted document count: 1 \n``` If your query filter does not match a document in your collection, your call to `deleteOne()` removes no documents and returns the following: ``` Deleted document count: 0 \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following API Documentation: * [deleteOne()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#deleteOne%28org.bson.conversions.Bson%29)\n* [DeleteResult](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/result/DeleteResult.html)\n* [eq()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#eq%28java.lang.String,TItem%29) ← [Delete Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/delete-operations/ \"Previous Section\")[Delete Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/deleteMany/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/watch/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Watch for Changes You can keep track of changes to data in MongoDB, such as changes to a collection, database, or deployment, by opening a **change stream**. A change stream allows applications to watch for changes to data and react to them. The change stream returns **change event** documents when changes occur. A change event contains information about the updated data. Open a change stream by calling the `watch()` method on a`MongoCollection`, `MongoDatabase`, or `MongoClient` object as shown in the following code example: `| ChangeStreamIterable<Document> changeStream = database.watch(); |\n| --------------------------------------------------------------- | ` The `watch()` method optionally takes an **aggregation pipeline** which consists of an array of **stages** as the first parameter to filter and transform the change event output as follows: ```java List<Bson> pipeline = Arrays.asList(                         Aggregates.match(                            Filters.lt(\"fullDocument.runtime\", 15))); ChangeStreamIterable<Document> changeStream = database.watch(pipeline); \n``` The `watch()` method returns an instance of `ChangeStreamIterable`, a class that offers several methods to access, organize, and traverse the results.`ChangeStreamIterable` also inherits methods from its parent class,`MongoIterable` which implements the core Java interface `Iterable`. You can call `forEach()` on the `ChangeStreamIterable` to handle events as they occur, or you can use the `iterator()` method which returns a `MongoCursor` instance that you can use to traverse the results. You can call methods on the `MongoCursor` such as `hasNext()` to check whether additional results exist, `next()` to return the next document in the collection, or `tryNext()`, to immediately return either the next available element in the change stream or `null`. Unlike the`MongoCursor` returned by other queries, a `MongoCursor` associated with a change stream waits until a change event arrives before returning a result from `next()`. As a result, calls to `next()`using a change stream's `MongoCursor` never throw a`java.util.NoSuchElementException`. To configure options for processing the documents returned from the change stream, use member methods of the `ChangeStreamIterable` object returned by `watch()`. See the link to the `ChangeStreamIterable` API documentation at the bottom of this example for more details on the available methods. ## How to Process Change Stream Events with a Callback To capture events from a change stream, call the `forEach()` method with a callback function as shown below: ```java changeStream.forEach(event -> System.out.println(\"Change observed: \" + event)); \n``` The callback function triggers when a change event is emitted. You can specify logic in the callback to process the event document when it is received. ## Important ### forEach() blocks the current thread Calls to `forEach()` block the current thread as long as the corresponding change stream listens for events. If your program needs to continue executing other logic, such as processing requests or responding to user input, consider creating and listening to your change stream in a separate thread. ## Note For update operation change events, change streams only return the modified fields by default rather than the entire updated document. You can configure your change stream to also return the most current version of the document by calling the `fullDocument()` member method of the `ChangeStreamIterable`object with the value `FullDocument.UPDATE_LOOKUP` as follows: ```java ChangeStreamIterable<Document> changeStream = database.watch()           .fullDocument(FullDocument.UPDATE_LOOKUP); \n``` ## Example The following example uses two separate applications to demonstrate how to listen for changes using a change stream:\n\n First, run `Watch` to open the change stream on the collection and define a callback on the change stream using the `forEach()` method. While `Watch` is running, run `WatchCompanion` to generate change events by performing changes to the collection. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb) `Watch`: ```java package usage.examples; import org.bson.Document; import org.bson.conversions.Bson; import com.mongodb.client.ChangeStreamIterable; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; import com.mongodb.client.model.Filters; import com.mongodb.client.model.changestream.FullDocument; public class Watch {     public static void main( String[] args ) {         // Replace the uri string with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {             MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");             MongoCollection<Document> collection = database.getCollection(\"movies\");             List<Bson> pipeline = Arrays.asList(                 Aggregates.match(                         Filters.in(\"operationType\",                                 Arrays.asList(\"insert\", \"update\"))));             ChangeStreamIterable<Document> changeStream = database.watch(pipeline)                 .fullDocument(FullDocument.UPDATE_LOOKUP);             // variables referenced in a lambda must be final; final array gives us a mutable integer             final int[] numberOfEvents = {0};             changeStream.forEach(event -> {             System.out.println(\"Received a change to the collection: \" + event);                 if (++numberOfEvents[0] >= 2) {                   System.exit(0);                 }             });         }     } } \n``` `WatchCompanion`: ```java package usage.examples; import java.util.Arrays; import org.bson.Document; import org.bson.types.ObjectId; import com.mongodb.MongoException; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; import com.mongodb.client.result.InsertOneResult; public class WatchCompanion {     public static void main(String[] args) {         // Replace the uri string with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {             MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");\n\n             try {                 InsertOneResult insertResult = collection.insertOne(new Document(\"test\", \"sample movie document\"));                 System.out.println(\"Success! Inserted document id: \" + insertResult.getInsertedId());                 UpdateResult updateResult = collection.updateOne(new Document(\"test\", \"sample movie document\"), Updates.set(\"field2\", \"sample movie document update\"));                 System.out.println(\"Updated \" + updateResult.getModifiedCount() + \" document.\");                 DeleteResult deleteResult = collection.deleteOne(new Document(\"field2\", \"sample movie document update\"));                 System.out.println(\"Deleted \" + deleteResult.getDeletedCount() + \" document.\");             } catch (MongoException me) {                 System.err.println(\"Unable to insert, update, or replace due to an error: \" + me);             }         }     } } \n``` If you run the preceding applications in sequence, you should see output from the `Watch` application that is similar to the following. Only the`insert` and `update` operations are printed, since the aggregation pipeline filters out the `delete` operation: ``` Received a change to the collection: ChangeStreamDocument{   operationType=OperationType{value='insert'},   resumeToken={\"_data\": \"825E...\"},   namespace=sample_mflix.movies,   destinationNamespace=null,   fullDocument=Document{{_id=5ec3..., test=sample movie document}},   documentKey={\"_id\": {\"$oid\": \"5ec3...\"}},   clusterTime=Timestamp{...},   updateDescription=null,   txnNumber=null,   lsid=null,   wallTime=BsonDateTime{value=1657...} } Received a change to the collection: ChangeStreamDocument{   operationType=OperationType{value='update'},   resumeToken={\"_data\": \"825E...\"},   namespace=sample_mflix.movies,   destinationNamespace=null,   fullDocument=Document{{_id=5ec3..., test=sample movie document, field2=sample movie document update}},   documentKey={\"_id\": {\"$oid\": \"5ec3...\"}},   clusterTime=Timestamp{...},   updateDescription=UpdateDescription{removedFields=[], updatedFields={\"field2\": \"sample movie document update\"}},   txnNumber=null,   lsid=null,   wallTime=BsonDateTime{value=1657...} } \n``` You should also see output from the `WatchCompanion` application that is similar to the following: ``` Success! Inserted document id: BsonObjectId{value=5ec3...} Updated 1 document. Deleted 1 document. \n``` ## Tip ### Legacy API If you are using the legacy API,[see our FAQ page](https://mongodb.com/docs/drivers/java/sync/current/faq/#std-label-faq-legacy-connection)to learn what changes you need to make to this code example. For additional information on the classes and methods mentioned on this page, see the following resources:\n\n ← [Perform Bulk Operations](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/bulkWrite/ \"Previous Section\")[Count Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/count/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/usage-examples/distinct/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Retrieve Distinct Values of a Field You can retrieve a list of distinct values for a field across a collection by calling the `distinct()` method on a `MongoCollection`object. Pass the document field name as the first parameter and the class you want to cast the results to as the second parameter as shown below: `| collection.distinct(\"countries\", String.class); |\n| ----------------------------------------------- | ` You can specify a field on the document or one within an **embedded document**using **dot notation**. The following method call returns each distinct value of the `wins` field in the `awards` embedded document: ```java collection.distinct(\"awards.wins\", Integer.class); \n``` You can optionally pass a query filter to the method to limit the set of documents from which your MongoDB instance retrieves distinct values as follows: ```java collection.distinct(\"type\", Filters.eq(\"languages\", \"French\"), String.class); \n``` The `distinct()` method returns an object that implements the`DistinctIterable` interface. This interface contains methods to access, organize, and traverse the results. It also inherits methods from its parent interface, `MongoIterable`, such as `first()` which returns the first result and `cursor()` which returns an instance of a `MongoCursor`. ## Example The following snippet retrieves a list of distinct values for the `year`document field from the `movies` collection. It uses a query filter to match movies that include \"Carl Franklin\" as one of the values in the`directors` array. ## Note This example connects to an instance of MongoDB using a connection URI. To learn more about connecting to your MongoDB instance, see the[connection guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb) ```java package usage.examples; import org.bson.Document; import com.mongodb.MongoException; import com.mongodb.client.DistinctIterable; import com.mongodb.client.MongoClient; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoCursor; import com.mongodb.client.MongoDatabase; import com.mongodb.client.model.Filters; public class Distinct {     public static void main(String[] args) {         // Replace the uri string with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {             MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\");             MongoCollection<Document> collection = database.getCollection(\"movies\");             try {                 DistinctIterable<Integer> docs = collection.distinct(\"year\", Filters.eq(\"directors\", \"Carl Franklin\"), Integer.class);                 MongoCursor<Integer> results = docs.iterator();                 while(results.hasNext()) {                     System.out.println(results.next());                 }             } catch (MongoException me) {                 System.err.println(\"An error occurred: \" + me);             }         }     } } \n``` When you run the example, you should see output that reports each distinct year for all the movies that Carl Franklin was included as a director, which should look something like this: ``` 1992 1995 1998 ... \n``` ## Tip ### Legacy API\n\n For additional information on the classes and methods mentioned on this page, see the following resources: * [distinct()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#distinct%28java.lang.String,java.lang.Class%29) API Documentation\n* [DistinctIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/DistinctIterable.html) API Documentation\n* [Dot Notation](https://www.mongodb.com/docs/manual/core/document/#embedded-documents) Server Manual Entry\n* [MongoIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoIterable.html) API Documentation ← [Count Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/count/ \"Previous Section\")[Run a Command](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/command/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/pojos/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) [MongoDB Java Driver](https://mongodb.com/docs/drivers/java/sync/current/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # CRUD Operations CRUD (Create, Read, Update, Delete) operations enable you to work with data stored in MongoDB. * [Read Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/) find and return documents stored in your database.\n* [Write Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/) insert, modify, or delete documents in your database. Some operations combine aspects of read and write operations. See our guide on [compound operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/compound-operations/)to learn more about these hybrid methods. ← [Codecs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/ \"Previous Section\")[Read Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Builders On this page * [Overview](#overview)\n* [Why Use Builders?](#why-use-builders-)\n* [Scenario](#scenario)\n* [Using the MongoDB Shell](#using-the-mongodb-shell)\n* [Without Using Builders](#without-using-builders)\n* [Using Builders](#using-builders)\n* [Available Builders](#available-builders) ## Overview This section includes guides on how to use each of the available builders, and demonstrates the utility the MongoDB Java driver builder classes provide. The Java driver provides classes to simplify the process for developers to use CRUD operations and the Aggregation API. The static utility methods allow you to build a query more efficiently. ## Why Use Builders? Using the builders class, you leverage the power of: * The Java compiler and the IDE to find errors during development\n* The IDE for discovery and code completion When using builders, the Java compiler and the IDE catch errors such as misspelled operators early on. When using the MongoDB shell or plain Java, you write operators as strings and get no visual indication of a problem, pushing these errors to runtime instead of compile time With the builder classes, you write operators as methods. The IDE instantly underlines and gives you a red bar on the right indicating something is wrong. While developing, the IDE also shows you the methods you can use. It automatically completes your code with placeholder parameters once you select which method you want to use. ## Scenario Imagine we want to send a marketing email to all users in our `users`collection with the following criteria: * Users that identify as \"female\" gender\n* Users that are older than \"29\" We only want their email address, so we'll ensure our query doesn't return data we pay bandwidth costs for but don't need. ### Using the MongoDB Shell `| collection.find({ \"gender\": \"female\", \"age\" : { \"$gt\": 29 }}, { \"_id\": 0, \"email\": 1 }) |\n| --------------------------------------------------------------------------------------- | ` ### Without Using Builders ```java Bson filter = new Document().append(\"gender\", \"female\").append(\"age\", new Document().append(\"$gt\", 29)); Bson projection = new Document().append(\"_id\", 0).append(\"email\", 1); collection.find(filter).projection(projection); \n``` ### Using Builders ```java import static com.mongodb.client.model.Filters.*; import static com.mongodb.client.model.Projections.*; ... Bson filter = and(eq(\"gender\", \"female\"), gt(\"age\", 29)); Bson projection = fields(excludeId(), include(\"email\")); collection.find(filter).projection(projection); \n``` ## Available Builders * [Filters](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/#std-label-filters-builders) for building query filters.\n* [Projections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/projections/#std-label-projections-builders) for building projections.\n* [Sorts](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/sort/#std-label-sorts-builders) for building sort criteria.\n* [Updates](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/#std-label-updates-builders) for building updates.\n* [Aggregates](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/aggregates/#std-label-aggregates-builders) for building aggregation pipelines.\n* [Indexes](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/indexes/#std-label-indexes-builders) for creating index keys. ← [Compound Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/compound-operations/ \"Previous Section\")[Aggregates Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/aggregates/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Data Formats * [Document Data Format: BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/)\n* [Document Data Format: Extended JSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-extended-json/)\n* [Documents](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/documents/)\n* [Document Data Format: POJOs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/)\n* [Document Data Format: Records](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-record/)\n* [POJO Customization](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/)\n* [Codecs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/) ← [Databases and Collections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/databases-collections/ \"Previous Section\")[Document Data Format: BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/logging/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Logging On this page * [Overview](#overview)\n* [Set Up a Logger](#set-up-a-logger)\n* [Background](#background)\n* [Example - Set Up](#example---set-up)\n* [Configure Your Logger](#configure-your-logger)\n* [Example - Configure](#example---configure)\n* [Logger Names](#logger-names)\n* [Example - Names](#example---names) ## Overview In this guide, you can learn how to set up and configure a logger in the MongoDB Java driver. You will learn how to: * Set up a logger using the Simple Logging Facade For Java (SLF4J)\n* Configure the log level of your logger This guide shows how to record events in the driver. If you would like to learn how to use information about the activity of the driver in code, consider reading our[guide on monitoring.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/monitoring/) ## Set Up a Logger This section gives background on the dependencies necessary to set up a logger and provides an example logger setup. ### Background The MongoDB Java driver uses the Simple Logging Facade For Java (SLF4J). SLF4J allows you to specify your logging framework of choice at deployment time. For more information on SLF4J,[see the SLF4J documentation.](http://www.slf4j.org/) Setting up a logger is optional. When you start your application the MongoDB Java driver looks for the `slf4j-api` artifact in your classpath. If the driver can't find the `slf4j-api` artifact, the driver logs the following warning with`java.util.logging` and disables all further logging: `| WARNING: SLF4J not found on the classpath.  Logging is disabled for the 'org.mongodb.driver' component |\n| ------------------------------------------------------------------------------------------------------ | ` To set up a logger, you must include the following in your project. * The `slf4j-api` artifact\n* A logging framework\n* A **binding** ## Note For the most popular logging frameworks, there is often a single binding artifact that lists the `slf4j-api` and the logging framework as dependencies. This means that you can set up a logger by adding one artifact to your project's dependency list. You will see this in the example below. A binding is a piece of code that connects the `slf4j-api` artifact with a logging framework. The following example shows how to bind the `slf4j-api` artifact to the two most popular logging frameworks, Log4j2 and Logback. ### Example - Set Up This example shows how to set up your logger. Click the tab corresponding to the logging framework you would like to use in your project. ## Tip ### Dependency Versions The following versions listed are illustrative rather than a source of truth. You should check the official documentation for SLF4J and your logging framework of choice for guaranteed up-to-date version information. * [SLF4J documentation](http://www.slf4j.org/)\n* [Logback documentation](https://logback.qos.ch/)\n* [Log4j2 documentation](https://logging.apache.org/log4j/2.x/manual/) ## Configure Your Logger To configure your logger, you must use the configuration system of the logging framework bound to SLF4J. In the following example we show how you can use your logging framework's configuration system to set your logger's **log level**. A logger's log level specifies a lower bound for how urgent a message must be for the logger to output that message. ### Example - Configure This example shows how to configure your logger's log level to INFO. Select the tab corresponding to the logging framework you are using in your project. ## Logger Names Your logger uses logger names to help organize different logging events. Logger names are strings that form a hierarchy. A logger is an ancestor of another logger if its name followed by a `\".\"` is a prefix of the other logger's name. For example,`\"grandparent\"` is an ancestor of `\"grandparent.parent\"` which is an ancestor of `\"grandparent.parent.child\"`. For a concrete example, this is what a logger hierarchy looks like in code. ```java\n\n import org.slf4j.LoggerFactory; ... Logger logger_parent = LoggerFactory.getLogger(\"parent\"); Logger logger_child = LoggerFactory.getLogger(\"parent.child\"); \n``` A logger inherits the properties of its ancestor logger and can define its own. You can think of this as similar to class inheritance in Java. The MongoDB Java driver defines the following logger names to organize different logging events in the driver. Here are the logger names defined in the driver and the logging events they correspond to. * `org.mongodb.driver.authenticator` : authentication\n* `org.mongodb.driver.client` : events related to `MongoClient` instances\n* `org.mongodb.driver.cluster` : monitoring of MongoDB servers\n* `org.mongodb.driver.connection` : connections and connection pools\n* `org.mongodb.driver.connection.tls` : TLS/SSL\n* `org.mongodb.driver.operation` : operations, including logging related to automatic retries\n* `org.mongodb.driver.protocol` : commands sent to and replies received from MongoDB servers\n* `org.mongodb.driver.uri` : connection string parsing\n* `org.mongodb.driver.management` : JMX (Java Management Extensions) ### Example - Names This example shows how to change the log level for a specific driver logger. We set the root logger to OFF and the `org.mongodb.driver.connection` logger to INFO. This will cause the application to only log messages related to connecting to a MongoDB instance. Select the tab corresponding to the logging framework you are using in your project. ← [Collations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/collations/ \"Previous Section\")[Monitoring](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/monitoring/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/indexes/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Indexes On this page * [Overview](#overview)\n* [Query Coverage and Performance](#query-coverage-and-performance)\n* [Operational Considerations](#operational-considerations)\n* [Index Types](#index-types)\n* [Single Field and Compound Indexes](#single-field-and-compound-indexes)\n* [Multikey Indexes (Indexes on Array Fields)](#multikey-indexes--indexes-on-array-fields-)\n* [Text Indexes](#text-indexes)\n* [Geospatial Indexes](#geospatial-indexes)\n* [Unique Indexes](#unique-indexes)\n* [Clustered Indexes](#clustered-indexes)\n* [Remove an Index](#remove-an-index)\n* [Remove an Index Using an Index Specification Document](#remove-an-index-using-an-index-specification-document)\n* [Remove an Index Using a Name Field](#remove-an-index-using-a-name-field)\n* [Remove an Index Using a Wildcard Character](#remove-an-index-using-a-wildcard-character) ## Overview In this guide, you can learn how to use **indexes** with the MongoDB Java driver. Indexes support the efficient execution of queries in MongoDB. Without indexes, MongoDB must scan _every_ document in a collection (a **collection scan**) to find the documents that match each query. These collection scans are slow and can negatively affect the performance of your application. If an appropriate index exists for a query, MongoDB can use the index to limit the number of documents it must inspect. Indexes also: * Allow efficient sorting\n* Enable special capabilities like [geospatial](#std-label-geo-indexes) search\n* Allow adding constraints to ensure a field value is [unique](#std-label-unique-indexes)\n* And [more](https://www.mongodb.com/docs/manual/indexes/) ## Tip Indexes are also used by update operations when finding the documents to update, delete operations when finding the documents to delete, and by [certain stages](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/#pipeline-operators-and-indexes) in the aggregation pipeline. ### Query Coverage and Performance When you execute a query against MongoDB, your command can include various elements: * Query criteria that specify fields and values you are looking for\n* Options that affect the query's execution (e.g. read concern)\n* Projection criteria to specify the fields MongoDB should return (optional)\n* Sort criteria to specify the order documents will be returned from MongoDB (optional) When all the fields specified in the query, projection, and sort are in the same index, MongoDB returns results directly from the index, also called a **covered query**. ## Important ### Sort Order Sort criteria must match or invert the order of the index. Consider an index on the field `name` in ascending order (A-Z) and `age` in descending order (9-0): `| name_1_age_-1 |\n| ------------- | ` MongoDB would use this index when you sort your data by either: * `name` ascending, `age` descending\n* `name` descending, `age` ascending Specifying a sort order of `name` and age ascending or name and `age`descending would require an in-memory sort. For additional information on how to ensure your index covers your query criteria and projection, see the MongoDB manual articles on [query coverage.](https://www.mongodb.com/docs/manual/core/query-optimization/#covered-query) ### Operational Considerations To improve query performance, build indexes on fields that appear often in your application's queries and operations that return sorted results. Each index that you add consumes disk space and memory when active so you should track index memory and disk usage for capacity planning. In addition, when a write operation updates an indexed field, MongoDB also has to update the related index.\n\n For more information on designing your data model and choosing indexes appropriate for your application, see the MongoDB server documentation on [Indexing Strategies](https://www.mongodb.com/docs/manual/applications/indexes/) and[Data Modeling and Indexes.](https://www.mongodb.com/docs/manual/core/data-model-operations/#indexes) ## Index Types MongoDB supports a number of different index types to support querying your data. The following sections describe the most common index types and provide sample code for creating each index type. For a full list of index types, see[Indexes.](https://www.mongodb.com/docs/manual/indexes/) ## Tip The MongoDB Java Driver provides the [Indexes](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Indexes.html) class that includes static factory methods to create index specification documents for different MongoDB Index key types. The following examples use the[createIndex()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#createIndex%28org.bson.conversions.Bson,com.mongodb.client.model.IndexOptions%29)method to create various indexes, and the following setup: ```java import com.mongodb.DuplicateKeyException; import com.mongodb.MongoCommandException; import com.mongodb.client.*; import com.mongodb.client.model.IndexOptions; import com.mongodb.client.model.Indexes; import com.mongodb.client.model.Sorts; import com.mongodb.client.model.geojson.Point; import com.mongodb.client.model.geojson.Position; import org.apache.log4j.BasicConfigurator; import org.bson.Document; import org.bson.conversions.Bson; import static com.mongodb.client.model.Filters.*; import static com.mongodb.client.model.Projections.*; \n``` ```java final String uri = \"mongodb+srv://<atlas-uri>/<dbname>?retryWrites=true&w=majority\"; mongoClient = MongoClients.create(uri); database = mongoClient.getDatabase(\"sample_mflix\"); collection = database.getCollection(\"movies\"); \n``` ### Single Field and Compound Indexes #### Single Field Indexes [Single field indexes](https://www.mongodb.com/docs/manual/core/index-single/) are indexes with a reference to a single field within a collection's documents. They improve single field query and sort performance, and support [TTL Indexes](https://www.mongodb.com/docs/manual/core/index-ttl/) that automatically remove documents from a collection after a certain amount of time or at a specific clock time. ## Note The `_id_` index is an example of a single field index. This index is automatically created on the `_id` field when a new collection is created. The following example creates an index in ascending order on the `title` field: ```java String resultCreateIndex = collection.createIndex(Indexes.ascending(\"title\")); System.out.println(String.format(\"Index created: %s\", resultCreateIndex)); \n``` The following is an example of a query that would be covered by the index created in the preceding code snippet: ```java Bson filter = eq(\"title\", \"Batman\"); Bson sort = Sorts.ascending(\"title\"); Bson projection = fields(include(\"title\"), excludeId()); FindIterable<Document> cursor = collection.find(filter).sort(sort).projection(projection); \n``` See the MongoDB server manual section on [single field indexes](https://www.mongodb.com/docs/manual/core/index-single/) for more information. #### Compound Indexes [Compound](https://www.mongodb.com/docs/manual/core/index-compound/) indexes hold references to multiple fields within a collection's documents, improving query and sort performance. ## Tip\n\n The following example creates a compound index on the `type` and `rated` fields: ```java String resultCreateIndex = collection.createIndex(Indexes.ascending(\"type\", \"rated\")); System.out.println(String.format(\"Index created: %s\", resultCreateIndex)); \n``` The following is an example of a query that would be covered by the index created in the preceding code snippet: ```java Bson filter = and(eq(\"type\", \"movie\"), eq(\"rated\", \"G\")); Bson sort = Sorts.ascending(\"type\", \"rated\"); Bson projection = fields(include(\"type\", \"rated\"), excludeId()); FindIterable<Document> cursor = collection.find(filter).sort(sort).projection(projection); \n``` See the MongoDB server manual section on [Compound indexes](https://www.mongodb.com/docs/manual/core/index-compound/) for more information. ### Multikey Indexes (Indexes on Array Fields) **Multikey indexes** are indexes that improve performance for queries that specify a field with an index that contains an array value. You can define a multikey index using the same syntax as a single field or compound index. The following example creates a compound, multikey index on the `rated`, `genres` (an array of Strings), and `title` fields: ```java String resultCreateIndex = collection.createIndex(Indexes.ascending(\"rated\", \"genres\", \"title\")); System.out.println(String.format(\"Index created: %s\", resultCreateIndex)); \n``` The following is an example of a query that would be covered by the index created in the preceding code snippet: ```java Bson filter = and(eq(\"genres\", \"Animation\"), eq(\"rated\", \"G\")); Bson sort = Sorts.ascending(\"title\"); Bson projection = fields(include(\"title\", \"rated\"), excludeId()); FindIterable<Document> cursor = collection.find(filter).sort(sort).projection(projection); \n``` Multikey indexes behave differently from non-multikey indexes in terms of query coverage, index bound computation, and sort behavior. For a full explanation of multikey indexes, including a discussion of their behavior and limitations, refer to the [Multikey Indexes page](https://www.mongodb.com/docs/manual/core/index-multikey/) in the MongoDB manual. ### Text Indexes **Text indexes** support text search queries on string content. These indexes can include any field whose value is a string or an array of string elements. MongoDB supports text search for various languages. You can specify the default language as an option when creating the index. ## Tip Text indexes differ from the more powerful[Atlas full text search indexes](https://www.mongodb.com/docs/atlas/atlas-search/?jmp=docs%5Fdriver%5Fjava). Atlas users should use Atlas search. #### Single Field The following example creates a text index on the `plot` field: ```java // create a text index of the \"plot\" field in the \"movies\" collection // if a text index already exists with a different configuration, this will // error try {     String resultCreateIndex = collection.createIndex(Indexes.text(\"plot\"));     System.out.println(String.format(\"Index created: %s\", resultCreateIndex)); } catch (MongoCommandException e) {     if (e.getErrorCodeName().equals(\"IndexOptionsConflict\"))         System.out.println(\"there's an existing text index with different options\"); } \n``` The following is an example of a query that would use the index created in the preceding code snippet. Note that the `sort` is omitted because text indexes do not contain sort order. ```java Bson filter = text(\"java coffee shop\"); Bson projection = fields(include(\"fullplot\"), excludeId()); FindIterable<Document> cursor = collection.find(filter).projection(projection); \n``` #### Multiple Fields A collection can only contain one text index. If you want to create a text index for multiple text fields, you need to create a compound index. A text search runs on all the text fields within the compound index. The following snippet creates a compound text index for the `title` and `genre`fields: ```java collection.createIndex(Indexes.compoundIndex(Indexes.text(\"title\"), Indexes.text(\"genre\"))); \n```\n\n * [Compound Text Index Restrictions](https://www.mongodb.com/docs/manual/core/index-text/#std-label-text-index-compound)\n* [Text Indexes](https://www.mongodb.com/docs/manual/core/index-text/) ### Geospatial Indexes MongoDB supports queries of geospatial coordinate data using **2dsphere indexes**. With a `2dsphere` index, you can query the geospatial data for inclusion, intersection, and proximity. For more information on querying geospatial data, see[Geospatial Queries.](https://www.mongodb.com/docs/manual/geospatial-queries/) To create a `2dsphere` index, you must specify a field that contains only **GeoJSON objects**. For more details on this type, see the MongoDB server manual page on [GeoJSON objects.](https://www.mongodb.com/docs/manual/reference/geojson/) The `location.geo` field in the following sample document from the `theaters` collection in the `sample_mflix`database is a GeoJSON Point object that describes the coordinates of the theater: ```javascript {    \"_id\" : ObjectId(\"59a47286cfa9a3a73e51e75c\"),    \"theaterId\" : 104,    \"location\" : {       \"address\" : {          \"street1\" : \"5000 W 147th St\",          \"city\" : \"Hawthorne\",          \"state\" : \"CA\",          \"zipcode\" : \"90250\"       },       \"geo\" : {          \"type\" : \"Point\",          \"coordinates\" : [             -118.36559,             33.897167          ]       }    } } \n``` The following example creates a `2dsphere` index on the `location.geo` field: ## Important Attempting to create a geospatial index on a field that is covered by a geospatial index will result in an error. ```java // if an existing geo index exists, this will error try {     String resultCreateIndex = collection.createIndex(Indexes.geo2dsphere(\"location.geo\"));     System.out.println(String.format(\"Index created: %s\", resultCreateIndex)); } catch (MongoCommandException e) {     if (e.getErrorCodeName().equals(\"IndexOptionsConflict\"))         System.out.println(\"there's an existing text index with different options\"); } \n``` The following is an example of a geospatial query using the \"location.geo\" index. ```java // MongoDB Headquarters in NY, NY. Point refPoint = new Point(new Position(-73.98456, 40.7612)); Bson filter = near(\"location.geo\", refPoint, 1000.0, 0.0); FindIterable<Document> cursor = collection.find(filter); \n``` MongoDB also supports `2d` indexes for calculating distances on a Euclidean plane and for working with the \"legacy coordinate pairs\" syntax used in MongoDB 2.2 and earlier. See the [Geospatial Queries page](https://www.mongodb.com/docs/manual/geospatial-queries/)in the MongoDB server manual for more information. ### Unique Indexes Unique indexes ensure that the indexed fields do not store duplicate values. By default, MongoDB creates a unique index on the `_id` field during the creation of a collection. To create a unique index, specify the field or combination of fields that you want to prevent duplication on and set the `unique` option to `true`. The following example creates a unique, descending index on the `theaterId` field: ```java // this will fail if any duplicate values exist on the field you are indexing try {     IndexOptions indexOptions = new IndexOptions().unique(true);\n\n     System.out.println(String.format(\"Index created: %s\", resultCreateIndex)); } catch (DuplicateKeyException e) {     System.out.printf(\"duplicate field values encountered, couldn't create index: \\t%s\\n\", e); } \n``` ## Important If you perform a write operation that stores a duplicate value that violates the unique index, the MongoDB Java driver will raise a `DuplicateKeyException`, and MongoDB will throw an error resembling the following: ``` E11000 duplicate key error index \n``` Refer to the [Unique Indexes page](https://www.mongodb.com/docs/manual/core/index-unique/) in the MongoDB server manual for more information. ### Clustered Indexes **Clustered indexes** instruct a collection to store documents ordered by a key value. To create a clustered index, specify the clustered index option with the `_id` field as the key and the unique field as`true` when you create your collection. The following example creates a clustered index on the `_id` field in the `vendors` collection: ```java MongoDatabase database = mongoClient.getDatabase(\"tea\"); ClusteredIndexOptions clusteredIndexOptions = new ClusteredIndexOptions(new Document(\"_id\", 1), true); CreateCollectionOptions createCollectionOptions = new CreateCollectionOptions().clusteredIndexOptions(clusteredIndexOptions); database.createCollection(\"vendors\", createCollectionOptions); \n``` See the MongoDB server manual sections for more information: * [Clustered Index](https://www.mongodb.com/docs/v6.0/reference/method/db.createCollection/#std-label-db.createCollection.clusteredIndex)\n* [Clustered Collections](https://www.mongodb.com/docs/v6.0/core/clustered-collections/) ## Remove an Index You can remove any unused index except the default unique index on the`_id` field. The following sections show the ways to remove indexes: * Using an index specification document\n* Using an indexed name field\n* Using a wildcard character to remove all indexes ### Remove an Index Using an Index Specification Document Pass an **index specification document** to the `dropIndex()` method to remove an index from a collection. An index specification document is a `Bson` instance that specifies the type of index on a specified field. The following snippet removes an ascending index on the `title` field in a collection: ```java collection.dropIndex(Indexes.ascending(\"title\")); \n``` ## Important If you want to drop a text index, you must use the name of the index instead. See the [Remove an Index Using a Name Field](#std-label-name%5Ffield) section for details. ### Remove an Index Using a Name Field Pass the `name` field of the index to the `dropIndex()` method to remove an index from a collection. If you need to find the name of your index, use the `listIndexes()`method to see the value of the `name` fields in your indexes. The following snippet retrieves and prints all the indexes in a collection: ```java collection.listIndexes().forEach(doc -> System.out.println(doc.toJson())); \n``` If you call `listIndex()` on a collection that contains a text index, the output might resemble the following: ``` { \"v\": 2, \"key\": {\"_id\": 1}, \"name\": \"_id_\" } { \"v\": 2, \"key\": {\"_fts\": \"text\", \"_ftsx\": 1}, \"name\": \"title_text\", \"weights\": {\"title\": 1}, \"default_language\": \"english\", \"language_override\": \"language\", \"textIndexVersion\": 3 } \n``` This output tells us the names of the existing indexes are \"\\_id\" and \"title\\_text\". The following snippet removes the \"title\\_text\" index from the collection: ```java collection.dropIndex(\"title_text\"); \n``` ## Note You cannot remove a single field from a compound text index. You must drop the entire index and create a new one to update the indexed fields. ### Remove an Index Using a Wildcard Character Starting with MongoDB 4.2, you can drop all indexes by calling the`dropIndexes()` method on your collection: ```java collection.dropIndexes(); \n```\n\n ```java collection.dropIndex(\"*\"); \n``` For more information on the methods in this section, see the following API Documentation: * [dropIndex()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync//com/mongodb/client/MongoCollection.html#dropIndex%28java.lang.String%29)\n* [dropIndexes()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync//com/mongodb/client/MongoCollection.html#dropIndexes%28%29) ← [Aggregation](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/aggregation/ \"Previous Section\")[Collations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/collations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/enterprise-auth/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Enterprise Authentication Mechanisms On this page * [Overview](#overview)\n* [Specify an Authentication Mechanism](#specify-an-authentication-mechanism)\n* [Mechanisms](#mechanisms)\n* [Kerberos (GSSAPI)](#kerberos--gssapi-)\n* [LDAP (PLAIN)](#ldap--plain-) ## Overview In this guide, you can learn how to authenticate with MongoDB using each**authentication mechanism** available exclusively in the MongoDB Enterprise Edition. You can use the following mechanisms with the latest version of MongoDB Enterprise Edition: * [Kerberos (GSSAPI)](#std-label-gssapi-auth-mechanism)\n* [LDAP (PLAIN)](#std-label-plain-auth-mechanism) To authenticate using another mechanism, see the[Authentication Mechanisms guide](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/auth/). For more information on establishing a connection to your MongoDB cluster, read our[Connection Guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/) ## Specify an Authentication Mechanism You can specify your authentication mechanism and credentials when connecting to MongoDB using either of the following: * A connection string\n* A `MongoCredential` factory method A **connection string** (also known as a **connection uri**) specifies how to connect and authenticate to your MongoDB cluster. To authenticate using a connection string, include your settings in your connection string and pass it to the `MongoClients.create()` method to instantiate your `MongoClient`. Select the Connection Stringtab to see the syntax for authenticating using a **connection string**. Alternatively, you can use the `MongoCredential` class to specify your authentication details. The `MongoCredential` class contains static factory methods that construct instances containing your authentication mechanism and credentials. When you use the `MongoCredential` helper class, you need to use the `MongoClientSettings.Builder` class to configure your connection settings when constructing your `MongoClient`. Select theMongoCredential tab to see the syntax for authenticating using a`MongoCredential`. For more information on these classes and methods, refer to the following API documentation: * [MongoClients.create()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClients.html#create%28%29)\n* [MongoClient](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClient.html)\n* [MongoClientSettings.Builder](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html)\n* [MongoCredential](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoCredential.html) ## Mechanisms ### Kerberos (GSSAPI) The Generic Security Services API (`GSSAPI`) authentication mechanism allows the user to authenticate to a Kerberos service using the user's principal name. ## Note The method refers to the `GSSAPI` authentication mechanism instead of `Kerberos` because the driver authenticates using the[GSSAPI RFC-4652](https://tools.ietf.org/html/rfc4752) SASL mechanism. The following code snippets show how to specify the authentication mechanism, using the following placeholders: * `username` \\- your URL-encoded principal name, e.g. \"username%40REALM.ME\"\n* `hostname` \\- network address of your MongoDB server, accessible by your client\n* `port` \\- port number of your MongoDB server Select the Connection String or the MongoCredentialtab below for instructions and sample code for specifying this authentication mechanism:\n\n `| java.security.krb5.realm=MYREALM.ME     |\n| --------------------------------------- |\n| java.security.krb5.kdc=mykdc.myrealm.me | ` You may need to specify one or more of the following additional`MongoCredential` mechanism properties depending on your Kerberos setup: * `SERVICE_NAME`\n* `CANONICALIZE_HOST_NAME`\n* `JAVA_SUBJECT`\n* `JAVA_SASL_CLIENT_PROPERTIES`\n* `JAVA_SUBJECT_PROVIDER` By default, the Java driver caches Kerberos tickets by `MongoClient` instance. If your deployment needs to frequently create and destroy `MongoClient` instances, you can change the default Kerberos ticket caching behavior to cache by process to improve performance. ## Note On Windows, Oracle’s JRE uses [LSA](https://docs.microsoft.com/en-us/windows/win32/secauthn/lsa-authentication)rather than [SSPI](https://docs.microsoft.com/en-us/windows/win32/secauthn/sspi)in its implementation of GSSAPI which limits interoperability with Windows Active Directory and implementations of single sign-on. See the following articles for more information: * [JDK-8054026](https://bugs.openjdk.java.net/browse/JDK-8054026)\n* [JDK-6722928](https://bugs.openjdk.java.net/browse/JDK-6722928)\n* [SO 23427343](https://stackoverflow.com/questions/23427343/cannot-retrieve-tgt-despite-allowtgtsessionkey-registry-entry) ### LDAP (PLAIN) _Available in MongoDB Enterprise Edition 3.4 and later._ You can authenticate to a Lightweight Directory Access Protocol (LDAP) server using your directory server username and password. ## Tip The authentication mechanism is named `PLAIN` instead of `LDAP` since it authenticates using the [PLAIN Simple Authentication and Security Layer (SASL) defined in RFC-4616](https://tools.ietf.org/html/rfc4616). You can specify this authentication mechanism by setting the `authMechanism`parameter to `PLAIN` and including your LDAP username and password in the[connection string.](https://www.mongodb.com/docs/manual/reference/connection-string/) The following code snippets show how to specify the authentication mechanism, using the following placeholders: * `username` \\- your LDAP username\n* `password` \\- your LDAP user's password\n* `hostname` \\- network address of your MongoDB server, accessible by your client\n* `port` \\- port number of your MongoDB server Select the Connection String or the MongoCredentialtab below for instructions and sample code for specifying this authentication mechanism: ← [Authentication Mechanisms](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/auth/ \"Previous Section\")[Stable API](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/stable-api/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/gridfs/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # GridFS On this page * [Overview](#overview)\n* [How GridFS Works](#how-gridfs-works)\n* [Create a GridFS Bucket](#create-a-gridfs-bucket)\n* [Store Files](#store-files)\n* [Upload a File Using an Input Stream](#upload-a-file-using-an-input-stream)\n* [Upload a File Using an Output Stream](#upload-a-file-using-an-output-stream)\n* [Retrieve File Information](#retrieve-file-information)\n* [Download Files](#download-files)\n* [File Revisions](#file-revisions)\n* [Download a File to an Output Stream](#download-a-file-to-an-output-stream)\n* [Download a File to an Input Stream](#download-a-file-to-an-input-stream)\n* [Rename Files](#rename-files)\n* [Delete Files](#delete-files)\n* [Delete a GridFS Bucket](#delete-a-gridfs-bucket)\n* [Additional Resources](#additional-resources) ## Overview In this guide, you can learn how to store and retrieve large files in MongoDB using **GridFS**. GridFS is a specification implemented by the driver that describes how to split files into chunks when storing them and reassemble them when retrieving them. The driver implementation of GridFS is an abstraction that manages the operations and organization of the file storage. You should use GridFS if the size of your files exceed the BSON document size limit of 16MB. For more detailed information on whether GridFS is suitable for your use case, see the [GridFS server manual page.](https://www.mongodb.com/docs/manual/core/gridfs/) See the following sections that describe GridFS operations and how to perform them: * [Create a GridFS bucket](#std-label-gridfs-create-bucket)\n* [Store Files](#std-label-gridfs-store-files)\n* [Retrieve File Information](#std-label-gridfs-retrieve-file-info)\n* [Download Files](#std-label-gridfs-download-files)\n* [Rename Files](#std-label-gridfs-rename-files)\n* [Delete Files](#std-label-gridfs-delete-files)\n* [Delete a GridFS bucket](#std-label-gridfs-delete-bucket) ## How GridFS Works GridFS organizes files in a **bucket**, a group of MongoDB collections that contain the chunks of files and information describing them. The bucket contains the following collections, named using the convention defined in the GridFS specification: * The `chunks` collection stores the binary file chunks.\n* The `files` collection stores the file metadata. When you create a new GridFS bucket, the driver creates the preceding collections, prefixed with the default bucket name `fs`, unless you specify a different name. The driver also creates an index on each collection to ensure efficient retrieval of the files and related metadata. The driver only creates the GridFS bucket on the first write operation if it does not already exist. The driver only creates indexes if they do not exist and when the bucket is empty. For more information on GridFS indexes, see the server manual page on [GridFS Indexes.](https://www.mongodb.com/docs/manual/core/gridfs/#gridfs-indexes) When storing files with GridFS, the driver splits the files into smaller chunks, each represented by a separate document in the `chunks` collection. It also creates a document in the `files` collection that contains a file id, file name, and other file metadata. You can upload the file from memory or from a stream. See the following diagram to see how GridFS splits the files when uploaded to a bucket. ![A diagram that shows how GridFS uploads a file to a bucket](https://mongodb.com/docs/drivers/java/sync/current/includes/figures/GridFS-upload.png) When retrieving files, GridFS fetches the metadata from the `files`collection in the specified bucket and uses the information to reconstruct the file from documents in the `chunks` collection. You can read the file into memory or output it to a stream. ## Create a GridFS Bucket\n\n `| MongoDatabase database = mongoClient.getDatabase(\"mydb\");   |\n| ----------------------------------------------------------- |\n| GridFSBucket gridFSBucket = GridFSBuckets.create(database); | ` To create or reference a bucket with a custom name other than the default name`fs`, pass your bucket name as the second parameter to the `create()`method as shown below: ```java GridFSBucket gridFSBucket = GridFSBuckets.create(database, \"myCustomBucket\"); \n``` ## Note When you call `create()`, MongoDB does not create the bucket if it does not exist. Instead, MongoDB creates the bucket as necessary such as when you upload your first file. For more information on the classes and methods mentioned in this section, see the following API Documentation: * [GridFSBuckets](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSBuckets.html)\n* [GridFSBucket](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSBucket.html) ## Store Files To store a file in a GridFS bucket, you can either upload it from an instance of `InputStream` or write its data to a `GridFSUploadStream`. For either upload process, you can specify configuration information such as file chunk size and other field/value pairs to store as metadata. Set this information on an instance of `GridFSUploadOptions` as shown in the following code snippet: ```java GridFSUploadOptions options = new GridFSUploadOptions()         .chunkSizeBytes(1048576) // 1MB chunk size         .metadata(new Document(\"myField\", \"myValue\")); \n``` See the [GridFSUploadOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/gridfs/model/GridFSUploadOptions.html)API Documentation for more information. ### Upload a File Using an Input Stream This section shows you how to upload a file to a GridFS bucket using an input stream. The following code example shows how you can use a `FileInputStream` to read data from a file in your filesystem and upload it to GridFS by performing the following operations: * Read from the filesystem using a `FileInputStream`.\n* Set the chunk size using `GridFSUploadOptions`.\n* Set a custom metadata field called `type` to the value \"zip archive\".\n* Upload a file called `project.zip`, specifying the GridFS file name as \"myProject.zip\". ```java String filePath = \"/path/to/project.zip\"; try (InputStream streamToUploadFrom = new FileInputStream(filePath) ) {     GridFSUploadOptions options = new GridFSUploadOptions()             .chunkSizeBytes(1048576)             .metadata(new Document(\"type\", \"zip archive\"));     ObjectId fileId = gridFSBucket.uploadFromStream(\"myProject.zip\", streamToUploadFrom, options);     System.out.println(\"The file id of the uploaded file is: \" + fileId.toHexString()); } \n``` This code example prints the file id of the uploaded file after it is successfully saved in GridFS. For more information, see the API Documentation on[uploadFromStream().](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSBucket.html#uploadFromStream%28java.lang.String,java.io.InputStream,com.mongodb.client.gridfs.model.GridFSUploadOptions%29) ### Upload a File Using an Output Stream This section shows you how to upload a file to a GridFS bucket by writing to an output stream. The following code example shows how you can write to a`GridFSUploadStream` to send data to GridFS by performing the following operations:\n\n ```java Path filePath = Paths.get(\"/path/to/project.zip\"); byte[] data = Files.readAllBytes(filePath); GridFSUploadOptions options = new GridFSUploadOptions()         .chunkSizeBytes(1048576)         .metadata(new Document(\"type\", \"zip archive\")); try (GridFSUploadStream uploadStream = gridFSBucket.openUploadStream(\"myProject.zip\", options)) {     uploadStream.write(data);     uploadStream.flush();     System.out.println(\"The file id of the uploaded file is: \" + uploadStream.getObjectId().toHexString()); } catch (Exception e) {     System.err.println(\"The file upload failed: \" + e); } \n``` This code example prints the file id of the uploaded file after it is successfully saved in GridFS. ## Note If your file upload is not successful, the operation throws an exception and any uploaded chunks become orphaned chunks. An **orphaned chunk** is a document in a GridFS `chunks` collection that does not reference any file id in the GridFS `files` collection. File chunks can become orphaned chunks when an upload or delete operation is interrupted. To remove orphaned chunks, you must identify them using read operations and remove them using write operations. For more information, see the API Documentation on[GridFSUploadStream.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSUploadStream.html) ## Retrieve File Information In this section, you can learn how to retrieve file metadata stored in the`files` collection of the GridFS bucket. The metadata contains information about the file it refers to, including: * The id of the file\n* The name of the file\n* The length/size of the file\n* The upload date and time\n* A `metadata` document in which you can store any other information To retrieve files from a GridFS bucket, call the `find()` method on the `GridFSBucket` instance. The method returns a `GridFSFindIterable`from which you can access the results. The following code example shows you how to retrieve and print file metadata from all your files in a GridFS bucket. Among the different ways that you can traverse the retrieved results from the `GridFSFindIterable`, the example uses a `Consumer` functional interface to print the following results: ```java gridFSBucket.find().forEach(new Consumer<GridFSFile>() {     @Override     public void accept(final GridFSFile gridFSFile) {         System.out.println(gridFSFile);     } }); \n``` The next code example shows you how to retrieve and print the file names for all files that match the fields specified in the query filter. The example also calls `sort()` and `limit()` on the returned `GridFSFindIterable`to specify the order and maximum number of results: ```java Bson query = Filters.eq(\"metadata.type\", \"zip archive\"); Bson sort = Sorts.ascending(\"filename\"); gridFSBucket.find(query)         .sort(sort)         .limit(5)         .forEach(new Consumer<GridFSFile>() {             @Override             public void accept(final GridFSFile gridFSFile) {                 System.out.println(gridFSFile);             }         }); \n``` Since `metadata` is an embedded document, the query filter specifies the`type` field within the document using dot notation. See the server manual guide on how to [Query on Embedded/Nested Documents](https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/)for more information. For more information on the classes and methods mentioned in this section, see the following resources:\n\n ## Download Files You can download a file from GridFS directly to a stream or you can save it to memory from a stream. You can specify the file to retrieve using either the file id or file name. ### File Revisions When your bucket contains multiple files that share the same file name, GridFS chooses the latest uploaded version of the file by default. To differentiate between each file that shares the same name, GridFS assigns files that share the same filename a revision number, ordered by upload time. The original file revision number is \"0\" and the next most recent file revision number is \"1\". You can also specify negative values which correspond to the recency of the revision. The revision value \"-1\" references the most recent revision and \"-2\" references the next most recent revision. The following code snippet shows how you can specify the second revision of a file in an instance of `GridFSDownloadOptions`: ```java GridFSDownloadOptions downloadOptions = new GridFSDownloadOptions().revision(1); \n``` For more information on the enumeration of revisions, see the API documentation for [GridFSDownloadOptions.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/gridfs/model/GridFSDownloadOptions.html) ### Download a File to an Output Stream You can download a file in a GridFS bucket to an output stream. The following code example shows you how you can call the `downloadToStream()` method to download the first revision of the file named \"myProject.zip\" to an`OutputStream`. ```java GridFSDownloadOptions downloadOptions = new GridFSDownloadOptions().revision(0); try (FileOutputStream streamToDownloadTo = new FileOutputStream(\"/tmp/myProject.zip\")) {     gridFSBucket.downloadToStream(\"myProject.zip\", streamToDownloadTo, downloadOptions);     streamToDownloadTo.flush(); } \n``` For more information on this method, see the[downloadToStream()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSBucket.html#downloadToStream%28java.lang.String,java.io.OutputStream,com.mongodb.client.gridfs.model.GridFSDownloadOptions%29)API Documentation. ### Download a File to an Input Stream You can download a file in a GridFS bucket to memory by using an input stream. You can call the `openDownloadStream()` method on the GridFS bucket to open a `GridFSDownloadStream`, an input stream from which you can read the file. The following code example shows you how to download a file referenced by the `fileId` variable into memory and print its contents as a string: ```java ObjectId fileId = new ObjectId(\"60345d38ebfcf47030e81cc9\"); try (GridFSDownloadStream downloadStream = gridFSBucket.openDownloadStream(fileId)) {     int fileLength = (int) downloadStream.getGridFSFile().getLength();     byte[] bytesToWriteTo = new byte[fileLength];     downloadStream.read(bytesToWriteTo);     System.out.println(new String(bytesToWriteTo, StandardCharsets.UTF_8)); } \n``` For more information on this method, see the[openDownloadStream()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSBucket.html#openDownloadStream%28java.lang.String,com.mongodb.client.gridfs.model.GridFSDownloadOptions%29). API Documentation. ## Rename Files You can update the name of a GridFS file in your bucket by calling the`rename()` method. You must specify the file to rename by its file id rather than its file name. ## Note The `rename()` method only supports updating the name of one file at a time. To rename multiple files, retrieve a list of files matching the file name from the bucket, extract the file id values from the files you want to rename, and pass each file id in separate calls to the `rename()`method.\n\n ```java ObjectId fileId = new ObjectId(\"60345d38ebfcf47030e81cc9\"); gridFSBucket.rename(fileId, \"mongodbTutorial.zip\"); \n``` For more information on this method, see the[rename()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSBucket.html#rename%28org.bson.types.ObjectId,java.lang.String%29)API Documentation. ## Delete Files You can remove a file from your GridFS bucket by calling the `delete()`method. You must specify the file by its file id rather than its file name. ## Note The `delete()` method only supports deleting one file at a time. To delete multiple files, retrieve the files from the bucket, extract the file id values from the files you want to delete, and pass each file id in separate calls to the `delete()` method. The following code example shows you how to delete the file referenced by the`fileId` variable: ```java ObjectId fileId = new ObjectId(\"60345d38ebfcf47030e81cc9\"); gridFSBucket.delete(fileId); \n``` For more information on this method, see the[delete()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSBucket.html#delete%28org.bson.types.ObjectId%29)API Documentation. ## Delete a GridFS Bucket The following code example shows you how to delete the default GridFS bucket on the database named \"mydb\". If you need to reference a custom named bucket, see the section of this guide on[how to create a custom bucket.](#std-label-gridfs-create-custom-bucket) ```java MongoDatabase database = mongoClient.getDatabase(\"mydb\"); GridFSBucket gridFSBucket = GridFSBuckets.create(database); gridFSBucket.drop(); \n``` For more information on this method, see the[drop()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/gridfs/GridFSBucket.html#drop%28%29)API Documentation. ## Additional Resources * [MongoDB GridFS specification](https://github.com/mongodb/specifications/blob/master/source/gridfs/gridfs-spec.rst)\n* Runnable example[GridFSTour.java](https://github.com/mongodb/mongo-java-driver/blob/master/driver-sync/src/examples/gridfs/GridFSTour.java)from the MongoDB Java Driver repository. ← [Monitoring](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/monitoring/ \"Previous Section\")[Client-Side Field Level Encryption](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/csfle/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/databases-collections/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Databases and Collections On this page * [Overview](#overview)\n* [Access a Database](#access-a-database)\n* [Access a Collection](#access-a-collection)\n* [Create a Collection](#create-a-collection)\n* [Document Validation](#document-validation)\n* [Get a List of Collections](#get-a-list-of-collections)\n* [Drop a Collection](#drop-a-collection)\n* [Specify Read Preferences, Read Concerns, and Write Concerns](#specify-read-preferences--read-concerns--and--write-concerns) ## Overview In this guide, you can learn how to use MongoDB databases and collections with the MongoDB Java driver. MongoDB organizes data into a hierachy of the following levels: * Databases\n* Collections\n* Documents Databases are the top level of data organization in a MongoDB instance. Databases are organized into collections which contain **documents**. Documents contain literal data such as strings, numbers, and dates as well as other (embedded) documents. For more information on document field types and structure, see the server documentation for[documents.](https://www.mongodb.com/docs/manual/core/document/) ## Access a Database Use the [getDatabase()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClient.html#getDatabase%28java.lang.String%29) method of a `MongoClient` instance to access a `MongoDatabase` in a MongoDB instance. The following example accesses a database named \"testDatabase\": `| MongoDatabase database = mongoClient.getDatabase(\"testDatabase\"); |\n| ----------------------------------------------------------------- | ` ## Access a Collection Use the [getCollection()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#getCollection%28java.lang.String%29)method of a `MongoDatabase` instance to access a`MongoCollection` in a database of your connected MongoDB instance. The following example accesses a collection named \"testCollection\" from a `MongoDatabase`: ```java MongoDatabase database = mongoClient.getDatabase(\"testDatabase\"); MongoCollection<Document> collection = database.getCollection(\"testCollection\"); \n``` ## Tip If the provided collection name does not already exist in the database, MongoDB implicitly creates the collection when you first insert data into that collection. ## Create a Collection Use the [createCollection()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#createCollection%28java.lang.String,com.mongodb.client.model.CreateCollectionOptions%29)method of a `MongoDatabase` instance to create a collection in a database of your connected MongoDB instance. The following example creates a collection called \"exampleCollection\": ```java database.createCollection(\"exampleCollection\"); \n``` You can specify collection options like maximum size and document validation rules using the [CreateCollectionOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/CreateCollectionOptions.html)class. The `createCollection()` method accepts an instance of`CreateCollectionOptions` as an optional second parameter. ### Document Validation\n\n ```java ValidationOptions collOptions = new ValidationOptions().validator(     Filters.or(Filters.exists(\"commander\"), Filters.exists(\"first officer\"))); database.createCollection(\"ships\",     new CreateCollectionOptions().validationOptions(collOptions)); \n``` For more information, see the server documentation for [document validation.](https://www.mongodb.com/docs/manual/core/document-validation/) ## Get a List of Collections You can query for a list of collections in a database using the[MongoDatabase.listCollectionNames()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#listCollectionNames%28%29) method: ```java for (String name : database.listCollectionNames()) {     System.out.println(name); } \n``` ## Drop a Collection You can remove a collection from the database using the[MongoCollection.drop()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#drop%28%29) method: ```java MongoCollection<Document> collection = database.getCollection(\"bass\"); collection.drop(); \n``` ## Warning ### Dropping a Collection Deletes All Data in the Collection Dropping a collection from your database also permanently deletes all documents within that collection and all indexes on that collection. Only drop collections that contain data that is no longer needed. ## Specify Read Preferences, Read Concerns, and Write Concerns **Read preferences**, **read concerns**, and **write concerns** control how the driver routes read operations and waits for acknowledgment for read and write operations when connected to a MongoDB replica set. Read preferences and read concerns apply to all read operations; write concerns apply to all write operations. `MongoDatabase` instances inherit their write concern, read concern, and write preference settings from the `MongoClient` used to create them. `MongoCollection` instances inherit their write concern, read concern, and write preference settings from the `MongoDatabase` used to create them. However, you can use the following methods to obtain an instance of a `MongoDatabase` or `MongoCollection` with a read preference, read concern, or write concern that differs from the setting they would normally inherit:\n\n ## Tip The `withReadConcern()`, `withReadPreference()`, and`withWriteConcern` methods create a new instance of a`MongoDatabase` or `MongoCollection` with the desired preference or concern. The `MongoDatabase` or `MongoCollection` upon which the method is called retains its original preference and concern settings. For more information, see the server documentation on[read preferences](https://www.mongodb.com/docs/manual/core/read-preference/),[read concerns](https://www.mongodb.com/docs/manual/reference/read-concern/), and[write concerns.](https://www.mongodb.com/docs/manual/reference/write-concern/) ← [Stable API](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/stable-api/ \"Previous Section\")[Data Formats](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/stable-api/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Stable API On this page * [Overview](#overview)\n* [Enable the Stable API on a MongoDB Client](#enable-the-stable-api-on-a-mongodb-client)\n* [Stable API Options](#stable-api-options) ## Note The Stable API feature requires MongoDB Server 5.0 or later. You should only use the Stable API feature if all the MongoDB servers you are connecting to support this feature. ## Overview In this guide, you can learn how to specify the **Stable API** when connecting to a MongoDB instance or replica set. You can use the Stable API feature to force the server to run operations with behavior compatible with the specified **API version**. An API version defines the expected behavior of the operations it covers and the format of server responses. If you change to a different API version, the operations are not guaranteed to be compatible and the server responses are not guaranteed to be similar. When you use the Stable API feature with an official MongoDB driver, you can update your driver or server without worrying about backward compatibility issues of the commands covered by the Stable API. See the MongoDB reference page on the [Stable API](https://www.mongodb.com/docs/manual/reference/stable-api/)for more information including a list of commands it covers. The following sections describe how you can enable the Stable API for your MongoDB client and the options that you can specify. ## Enable the Stable API on a MongoDB Client To enable the Stable API, you must specify an API version in the settings of your MongoDB client. Once you instantiate a `MongoClient` instance with a specified API version, all commands you run with that client use that version of the Stable API. ## Tip If you need to run commands using more than one version of the Stable API, instantiate a separate client with that version. If you need to run commands not covered by the Stable API, make sure the \"strict\" option is disabled. See the section on[Stable API Options](#std-label-stable-api-options) for more information. The following example shows how you can instantiate a `MongoClient` that sets the Stable API version and connects to a server by performing the following operations: * Construct a `ServerApi` instance using the `ServerApi.Builder`helper class.\n* Specify a Stable API version using a constant from the`ServerApiVersion` class.\n* Construct a `MongoClientSettings` instance using the`MongoClientSettings.Builder` class.\n* Specify a server to connect to using a `ServerAddress` instance.\n* Instantiate a `MongoClient` using the `MongoClients.create()` method and pass your `MongoClientSettings` instance as a parameter.\n\n ` ## Warning If you specify an API version and connect to a MongoDB server that does not support the Stable API, your application may raise an exception when executing a command on your MongoDB server. If you use a `MongoClient`that specifies the API version to query a server that does not support it, your query could fail with an exception message that includes the following text: ``` 'Unrecognized field 'apiVersion' on server... \n``` For more information on the methods and classes referenced in this section, see the following API Documentation: * [ServerApi](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/ServerApi.html)\n* [ServerApi.Builder](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/ServerApi.Builder.html)\n* [ServerApiVersion](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/ServerApiVersion.html)\n* [ServerAddress](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/ServerAddress.html)\n* [MongoClientSettings](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html)\n* [MongoClientSettings.Builder](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html)\n* [MongoClients.create()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClients.html#create%28com.mongodb.MongoClientSettings%29)\n* [MongoClient](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClient.html) ## Stable API Options You can enable or disable optional behavior related to the Stable API as described in the following table. | Option Name       | Description                                                                                                                                     |\n| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |\n| Strict            | **Optional**. When set, if you call a command that is not part of the declared API version, the driver raises an exception.Default: **false**   |\n| DeprecationErrors | **Optional**. When set, if you call a command that is deprecated in the declared API version, the driver raises an exception.Default: **false** | The following example shows how you can set the two options on an instance of `ServerApi` by chaining methods on the `ServerApi.Builder`: ```java ServerApi serverApi = ServerApi.builder()         .version(ServerApiVersion.V1)         .strict(true)         .deprecationErrors(true)         .build(); \n``` For more information on the options in this section, see the following API Documentation:\n\n ← [Enterprise Authentication Mechanisms](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/enterprise-auth/ \"Previous Section\")[Databases and Collections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/databases-collections/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/csfle/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Client-Side Field Level Encryption On this page * [Overview](#overview)\n* [Installation](#installation)\n* [mongodb-crypt](#mongodb-crypt)\n* [mongocryptd](#mongocryptd)\n* [Examples](#examples)\n* [Automatic Encryption and Decryption](#automatic-encryption-and-decryption)\n* [Explicit Encryption and Decryption](#explicit-encryption-and-decryption)\n* [Explicit Encryption and Auto Decryption](#explicit-encryption-and-auto-decryption) ## Overview In this guide, you can learn how to install and use **Client-Side Field Level Encryption (CSFLE)** in the MongoDB Java driver. CSFLE allows you to encrypt specific data fields within a document with your MongoDB client application before sending the data to the server. Starting in MongoDB 4.2 Enterprise, you can perform this client-side encryption automatically. With CSFLE, your client application encrypts fields client-side without requiring any server-side configuration or directives. CSFLE is useful for situations in which applications must guarantee that unauthorized parties, including server administrators, cannot read the encrypted data. This guide is a quick introduction to CSFLE using the Java driver. For in-depth information on how CSFLE works, see the [CSFLE reference](https://www.mongodb.com/docs/manual/core/security-client-side-encryption/) documentation. For a real-world scenario and implementation, see our [CSFLE Guide.](https://www.mongodb.com/docs/manual/core/csfle/quick-start/#std-label-csfle-guide-intro) ## Installation To get started with CSFLE in your client application, you need * the MongoDB Java driver\n* `mongodb-crypt`\n* `mongocryptd` if using automatic encryption (Enterprise or Atlas) ### `mongodb-crypt` The `mongodb-crypt` binding is available as a separate JAR. Add it to your project using your desired dependency management tool. ### `mongocryptd` `mongocryptd` is a binary run as a daemon / process that is used for automatic encryption.`mongodb-crypt` communicates with `mongocryptd` to automatically encrypt the information specified by a user-provided[JSON Schema.](https://www.mongodb.com/docs/manual/reference/security-client-side-automatic-json-schema/) For more detailed information on `mongocryptd`, see the[mongocryptd reference documentation](https://www.mongodb.com/docs/manual/reference/security-client-side-encryption-appendix/#mongocryptd) ## Examples The examples on this page use a local key, but you can also use integrated support for cloud-based key management services from AWS, Azure, and GCP. Each example program execution creates a new master key in memory and drops the`test.coll` collection. ## Tip In the examples, the in-memory master key is lost when the application finishes running. If you'd like to retain and decrypt documents from previous runs, you can save the local master key to a file for reuse and remove the logic to drop the collection. ## Warning MongoDB recommends using local key management only for testing purposes, and using a remote key management service for production. ### Automatic Encryption and Decryption The following example shows how to configure the `AutoEncryptionSettings` instance to create a new key and set the JSON schema map. The data in the `encryptedField` field is automatically encrypted before insertion, and decrypted when calling `find()`on the client side. Querying this collection from a client that isn't configured for CSFLE will return the document in encrypted form. The full source is available at[ClientSideEncryptionAutoEncryptionSettingsTour.java](https://github.com/mongodb/mongo-java-driver/blob/master/driver-sync/src/examples/tour/ClientSideEncryptionAutoEncryptionSettingsTour.java) ## Note Auto encryption requires MongoDB **Enterprise** or **Atlas**.\n\n ` ### Explicit Encryption and Decryption The prior example demonstrated the automatic CSFLE feature. If your version of MongoDB does not offer automatic CSFLE, you can perform manual client-side field level encryption, which we call _explicit_ encryption. This method does not require or use `mongocryptd`. The `ClientEncryption` class contains methods you can use to perform explicit encryption. This example prints out the document in encrypted form, and prints out the explicitly decrypted field value to demonstrate functionality. The full source is available from[ClientSideEncryptionExplicitEncryptionAndDecryptionTour.java](https://github.com/mongodb/mongo-java-driver/tree/master/driver-sync/src/examples/tour/ClientSideEncryptionExplicitEncryptionAndDecryptionTour.java) ```java // This would have to be the same master key as was used to create the encryption key final byte[] localMasterKey = new byte[96]; new SecureRandom().nextBytes(localMasterKey); Map<String, Map<String, Object>> kmsProviders = new HashMap<String, Map<String, Object>>() {{     put(\"local\", new HashMap<String, Object>() {{         put(\"key\", localMasterKey);     }}); }}; MongoClientSettings clientSettings = MongoClientSettings.builder().build(); MongoClient mongoClient = MongoClients.create(clientSettings); // Set up the key vault for this example MongoNamespace keyVaultNamespace = new MongoNamespace(\"encryption.testKeyVault\"); MongoCollection<Document> keyVaultCollection = mongoClient     .getDatabase(keyVaultNamespace.getDatabaseName())     .getCollection(keyVaultNamespace.getCollectionName()); keyVaultCollection.drop(); // Ensure that two data keys cannot share the same keyAltName. keyVaultCollection.createIndex(Indexes.ascending(\"keyAltNames\"),         new IndexOptions().unique(true)            .partialFilterExpression(Filters.exists(\"keyAltNames\"))); MongoCollection<Document> collection = mongoClient.getDatabase(\"test\").getCollection(\"coll\"); collection.drop(); // Clear old data // Create the ClientEncryption instance ClientEncryptionSettings clientEncryptionSettings = ClientEncryptionSettings.builder()         .keyVaultMongoClientSettings(MongoClientSettings.builder()                 .applyConnectionString(new ConnectionString(\"mongodb://localhost\"))                 .build())         .keyVaultNamespace(keyVaultNamespace.getFullName())         .kmsProviders(kmsProviders)         .build(); ClientEncryption clientEncryption = ClientEncryptions.create(clientEncryptionSettings); BsonBinary dataKeyId = clientEncryption.createDataKey(\"local\", new DataKeyOptions()); // Explicitly encrypt a field BsonBinary encryptedFieldValue = clientEncryption.encrypt(new BsonString(\"123456789\"),         new EncryptOptions(\"AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic\").keyId(dataKeyId)); collection.insertOne(new Document(\"encryptedField\", encryptedFieldValue)); Document doc = collection.find().first(); System.out.println(doc.toJson()); // Explicitly decrypt the field System.out.println(     clientEncryption.decrypt(new BsonBinary(doc.get(\"encryptedField\", Binary.class).getData())) ); \n``` ### Explicit Encryption and Auto Decryption Although automatic encryption requires MongoDB Enterprise or MongoDB Atlas, automatic decryption is available in all MongoDB versions greater than or equal to 4.2. To configure automatic decryption, set `bypassAutoEncryption(true)` in the `autoEncryptionSettings` builder. The following example prints the inserted document out in unencrypted form. The document is automatically decrypted because `autoEncryptionSettings` have been configured.\n\n ```java ... MongoClientSettings clientSettings = MongoClientSettings.builder()     .autoEncryptionSettings(AutoEncryptionSettings.builder()             .keyVaultNamespace(keyVaultNamespace.getFullName())             .kmsProviders(kmsProviders)             .bypassAutoEncryption(true)             .build())     .build(); MongoClient mongoClient = MongoClients.create(clientSettings); ... // Explicitly encrypt a field BsonBinary encryptedFieldValue = clientEncryption.encrypt(new BsonString(\"123456789\"),         new EncryptOptions(\"AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic\").keyId(dataKeyId)); collection.insertOne(new Document(\"encryptedField\", encryptedFieldValue)); // Automatically decrypts the encrypted field. System.out.println(collection.find().first().toJson()); \n``` ← [GridFS](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/gridfs/ \"Previous Section\")[Time Series Collections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/time-series/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/aggregation/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Aggregation On this page * [Overview](#overview)\n* [Aggregation and Find Operations Compared](#aggregation-and-find-operations-compared)\n* [Useful References](#useful-references)\n* [Runnable Examples](#runnable-examples)\n* [Base Setup](#base-setup)\n* [Basic Aggregation Example](#basic-aggregation-example)\n* [Explain Aggregation Example](#explain-aggregation-example)\n* [Aggregation Expression Example](#aggregation-expression-example) ## Overview In this guide, you can learn how to use **aggregation operations** in the MongoDB Java driver. Aggregation operations process data in your MongoDB collections and return computed results. MongoDB's Aggregation pipeline, part of the Query API, is modeled on the concept of data processing pipelines. Documents enter a multi-staged pipeline that transforms the documents into an aggregated result. Another way to think of aggregation is like a car factory. Within the car factory is an assembly line, along which are assembly stations with specialized tools to do a specific job, like drills and welders. Raw parts enter the factory, which are then transformed and assembled into a finished product. The **aggregation pipeline** is the assembly line, **aggregation stages** are the assembly stations, and**operator expressions** are the specialized tools. ### Aggregation and Find Operations Compared Using `find` operations, you can: * select _what_ documents to return\n* select _what_ fields to return\n* sort the results Using `aggregation` operations, you can: * perform all `find` operations\n* rename fields\n* calculate fields\n* summarize data\n* group values Aggregation operations have some [limitations](https://www.mongodb.com/docs/manual/core/aggregation-pipeline-limits/) you must keep in mind: * Returned documents must not violate the [BSON document size limit](https://www.mongodb.com/docs/manual/reference/limits/#mongodb-limit-BSON-Document-Size)of 16 megabytes.\n* Pipeline stages have a memory limit of 100 megabytes by default. If required, you may exceed this limit by using the [allowDiskUse](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/AggregateIterable.html#allowDiskUse%28java.lang.Boolean%29)method.  \n## Important  \n### $graphLookup exception  \nThe [$graphLookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/) stage has a strict memory limit of 100 megabytes and will ignore `allowDiskUse`. ### Useful References * [Aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/)\n* [Aggregation stages](https://www.mongodb.com/docs/manual/meta/aggregation-quick-reference/#stages)\n* [Operator expressions](https://www.mongodb.com/docs/manual/meta/aggregation-quick-reference/#operator-expressions)\n* [Aggregation Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/aggregates/#std-label-aggregates-builders) ## Runnable Examples ### Base Setup Create a new Java file called `AggTour.java` and include the following import statements:\n\n ` #### Connect to a MongoDB Deployment ```java public class AggTour {     public static void main(String[] args) {         // Replace the uri string with your MongoDB deployment's connection string         String uri = \"<connection string uri>\";         MongoClient mongoClient = MongoClients.create(uri);         MongoDatabase database = mongoClient.getDatabase(\"aggregation\");         MongoCollection<Document> collection = database.getCollection(\"restaurants\");         // aggregation here     } } \n``` ## Tip ### See also:  For information on connecting to MongoDB, see the [Connection Guide](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-mongoclient) #### Insert the Data ```java collection.insertMany(Arrays.asList(     new Document(\"name\", \"Sun Bakery Trattoria\").append(\"contact\", new Document().append(\"phone\", \"386-555-0189\").append(\"email\", \"SunBakeryTrattoria@example.org\").append(\"location\", Arrays.asList(-74.0056649, 40.7452371))).append(\"stars\", 4).append(\"categories\", Arrays.asList(\"Pizza\", \"Pasta\", \"Italian\", \"Coffee\", \"Sandwiches\")),     new Document(\"name\", \"Blue Bagels Grill\").append(\"contact\", new Document().append(\"phone\", \"786-555-0102\").append(\"email\", \"BlueBagelsGrill@example.com\").append(\"location\", Arrays.asList(-73.92506, 40.8275556))).append(\"stars\", 3).append(\"categories\", Arrays.asList(\"Bagels\", \"Cookies\", \"Sandwiches\")),     new Document(\"name\", \"XYZ Bagels Restaurant\").append(\"contact\", new Document().append(\"phone\", \"435-555-0190\").append(\"email\", \"XYZBagelsRestaurant@example.net\").append(\"location\", Arrays.asList(-74.0707363, 40.59321569999999))).append(\"stars\", 4).append(\"categories\", Arrays.asList(\"Bagels\", \"Sandwiches\", \"Coffee\")),     new Document(\"name\", \"Hot Bakery Cafe\").append(\"contact\", new Document().append(\"phone\", \"264-555-0171\").append(\"email\", \"HotBakeryCafe@example.net\").append(\"location\", Arrays.asList(-73.96485799999999, 40.761899))).append(\"stars\", 4).append(\"categories\", Arrays.asList(\"Bakery\", \"Cafe\", \"Coffee\", \"Dessert\")),     new Document(\"name\", \"Green Feast Pizzeria\").append(\"contact\", new Document().append(\"phone\", \"840-555-0102\").append(\"email\", \"GreenFeastPizzeria@example.com\").append(\"location\", Arrays.asList(-74.1220973, 40.6129407))).append(\"stars\", 2).append(\"categories\", Arrays.asList(\"Pizza\", \"Italian\")),     new Document(\"name\", \"ZZZ Pasta Buffet\").append(\"contact\", new Document().append(\"phone\", \"769-555-0152\").append(\"email\", \"ZZZPastaBuffet@example.com\").append(\"location\", Arrays.asList(-73.9446421, 40.7253944))).append(\"stars\", 0).append(\"categories\", Arrays.asList(\"Pasta\", \"Italian\", \"Buffet\", \"Cafeteria\")),     new Document(\"name\", \"XYZ Coffee Bar\").append(\"contact\", new Document().append(\"phone\", \"644-555-0193\").append(\"email\", \"XYZCoffeeBar@example.net\").append(\"location\", Arrays.asList(-74.0166091, 40.6284767))).append(\"stars\", 5).append(\"categories\", Arrays.asList(\"Coffee\", \"Cafe\", \"Bakery\", \"Chocolates\")),\n\n     new Document(\"name\", \"456 Cookies Shop\").append(\"contact\", new Document().append(\"phone\", \"604-555-0149\").append(\"email\", \"456CookiesShop@example.org\").append(\"location\", Arrays.asList(-73.8850023, 40.7494272))).append(\"stars\", 4).append(\"categories\", Arrays.asList(\"Bakery\", \"Cookies\", \"Cake\", \"Coffee\")),     new Document(\"name\", \"XYZ Steak Buffet\").append(\"contact\", new Document().append(\"phone\", \"229-555-0197\").append(\"email\", \"XYZSteakBuffet@example.org\").append(\"location\", Arrays.asList(-73.9799932, 40.7660886))).append(\"stars\", 3).append(\"categories\", Arrays.asList(\"Steak\", \"Salad\", \"Chinese\")) )); \n``` ### Basic Aggregation Example To perform an aggregation, pass a list of aggregation stages to the`MongoCollection.aggregate()` method. The Java driver provides the[Aggregates](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html)helper class that contains builders for aggregation stages. In the following example, the aggregation pipeline: * Uses a [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) stage to filter for documents whose`categories` array field contains the element `Bakery`. The example uses`Aggregates.match` to build the `$match` stage.\n* Uses a [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/) stage to group the matching documents by the `stars`field, accumulating a count of documents for each distinct value of `stars`. ## Tip ### See also:  You can build the expressions used in this example using the [aggregation builders.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/aggregates/#std-label-aggregates-builders) ```java collection.aggregate(     Arrays.asList(         Aggregates.match(Filters.eq(\"categories\", \"Bakery\")),         Aggregates.group(\"$stars\", Accumulators.sum(\"count\", 1))     ) ).forEach(doc -> System.out.println(doc.toJson())); \n``` The preceding aggregation should produce the following results: ``` {\"_id\": 4, \"count\": 2} {\"_id\": 5, \"count\": 1} \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [MongoCollection.aggregate()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#aggregate%28java.util.List%29)\n* [Aggregates.match](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html#match%28org.bson.conversions.Bson%29) ### Explain Aggregation Example To view information about how MongoDB executes your operation, use the`explain()` method of the `AggregateIterable` class. The `explain()`method returns **execution plans** and performance statistics. An execution plan is a potential way MongoDB can complete an operation. The `explain()` method provides both the winning plan (the plan MongoDB executed) and rejected plans. You can specify the level of detail of your explanation by passing a verbosity level to the `explain()` method. The following table shows all verbosity levels for explanations and their intended use cases:\n\n In the following example, we print the JSON representation of the winning plans for aggregation stages that produce execution plans: ```java Document explanation = collection.aggregate(     Arrays.asList(             Aggregates.match(Filters.eq(\"categories\", \"bakery\")),             Aggregates.group(\"$stars\", Accumulators.sum(\"count\", 1))     ) ).explain(ExplainVerbosity.EXECUTION_STATS); List<Document> stages = explanation.get(\"stages\", List.class); List<String> keys = Arrays.asList(\"queryPlanner\", \"winningPlan\"); for (Document stage : stages) {     Document cursorStage = stage.get(\"$cursor\", Document.class);     if (cursorStage != null) {         System.out.println(cursorStage.getEmbedded(keys, Document.class).toJson());     } } \n``` The preceding code snippet should produce the following output: ``` { \"stage\": \"PROJECTION_SIMPLE\",   \"transformBy\": {\"stars\": 1, \"_id\": 0},   \"inputStage\": {    \"stage\": \"COLLSCAN\",    \"filter\": {       \"categories\": {\"$eq\":\"bakery\"}},   \"direction\": \"forward\"}} \n``` For more information about the topics mentioned in this section, see the following resources: * [Explain Output](https://www.mongodb.com/docs/manual/reference/explain-results/) Server Manual Entry\n* [Query Plans](https://www.mongodb.com/docs/manual/core/query-plans/) Server Manual Entry\n* [ExplainVerbosity](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/ExplainVerbosity) API Documentation\n* [explain()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#explain%28%29) API Documentation\n* [AggregateIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/AggregateIterable.html) API Documentation ### Aggregation Expression Example The Java driver provides builders for accumulator expressions for use with`$group`. You must declare all other expressions in JSON format or compatible document format. ## Tip The syntax in either of the following examples will define an [$arrayElemAt](https://www.mongodb.com/docs/manual/reference/operator/aggregation/arrayElemAt/)expression. The `$` in front of \"categories\" tells MongoDB that this is a [field path](https://www.mongodb.com/docs/manual/meta/aggregation-quick-reference/#expressions), using the \"categories\" field from the input document. ```java new Document(\"$arrayElemAt\", Arrays.asList(\"$categories\", 0)) \n``` ```java Document.parse(\"{ $arrayElemAt: ['$categories', 0] }\") \n``` In the following example, the aggregation pipeline uses a`$project` stage and various `Projections` to return the `name`field and the calculated field `firstCategory` whose value is the first element in the `categories` field. ```java collection.aggregate(     Arrays.asList(         Aggregates.project(             Projections.fields(                 Projections.excludeId(),                 Projections.include(\"name\"),                 Projections.computed(                     \"firstCategory\",\n\n                 )             )         )     ) ).forEach(doc -> System.out.println(doc.toJson())); \n``` The preceding aggregation should produce the following results: ``` {\"name\": \"456 Cookies Shop\", \"firstCategory\": \"Bakery\"} {\"name\": \"Sun Bakery Trattoria\", \"firstCategory\": \"Pizza\"} {\"name\": \"456 Steak Restaurant\", \"firstCategory\": \"Steak\"} {\"name\": \"Blue Bagels Grill\", \"firstCategory\": \"Bagels\"} {\"name\": \"XYZ Steak Buffet\", \"firstCategory\": \"Steak\"} {\"name\": \"Hot Bakery Cafe\", \"firstCategory\": \"Bakery\"} {\"name\": \"Green Feast Pizzeria\", \"firstCategory\": \"Pizza\"} {\"name\": \"ZZZ Pasta Buffet\", \"firstCategory\": \"Pasta\"} {\"name\": \"XYZ Coffee Bar\", \"firstCategory\": \"Coffee\"} {\"name\": \"XYZ Bagels Restaurant\", \"firstCategory\": \"Bagels\"} \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [Accumulators](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html)\n* [$group](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html#group%28TExpression,java.util.List%29)\n* [$project](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html#project%28org.bson.conversions.Bson%29)\n* [Projections](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Projections.html) ← [Updates Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/ \"Previous Section\")[Indexes](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/indexes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/auth/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Authentication Mechanisms On this page * [Overview](#overview)\n* [Specify an Authentication Mechanism](#specify-an-authentication-mechanism)\n* [Mechanisms](#mechanisms)\n* [Default](#default)\n* [SCRAM-SHA-256](#scram-sha-256)\n* [SCRAM-SHA-1](#scram-sha-1)\n* [MONGODB-CR](#mongodb-cr)\n* [MONGODB-AWS](#mongodb-aws)\n* [X.509](#x.509) ## Overview In this guide, you can learn how to authenticate with MongoDB using each**authentication mechanism** available in the MongoDB Community Edition. Authentication mechanisms are processes by which the driver and server confirm identity and establish trust to ensure security. The mechanisms that you can use with the latest version of MongoDB Community Edition are as follows: * [Default](#std-label-default-auth-mechanism)\n* [SCRAM-SHA-256](#std-label-scram-sha-256-auth-mechanism)\n* [SCRAM-SHA-1](#std-label-scram-sha-1-auth-mechanism)\n* [MONGODB-CR](#std-label-mongodb-cr-auth-mechanism)\n* [MONGODB-AWS](#std-label-mongodb-aws-auth-mechanism)\n* [X.509](#std-label-x509-auth-mechanism) To authenticate using `Kerberos` or `LDAP`, see the[Enterprise Authentication Mechanisms guide](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/enterprise-auth/). For more information on establishing a connection to your MongoDB cluster, read our [Connection Guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/) ## Specify an Authentication Mechanism You can specify your authentication mechanism and credentials when connecting to MongoDB using either of the following: * A connection string\n* A `MongoCredential` factory method A **connection string** (also known as a **connection uri**) specifies how to connect and authenticate to your MongoDB cluster. To authenticate using a connection string, include your settings in your connection string and pass it to the `MongoClients.create()` method to instantiate your `MongoClient`. Select the Connection Stringtab to see the syntax for authenticating using a **connection string**. Alternatively, you can use the `MongoCredential` class to specify your authentication details. The `MongoCredential` class contains static factory methods that construct instances containing your authentication mechanism and credentials. When you use the `MongoCredential` helper class, you need to use the `MongoClientSettings.Builder` class to configure your connection settings when constructing your `MongoClient`. Select theMongoCredential tab to see the syntax for authenticating using a`MongoCredential`. For more information on these classes and methods, refer to the following API documentation: * [MongoClients.create()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClients.html#create%28%29)\n* [MongoClient](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClient.html)\n* [MongoClientSettings.Builder](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html)\n* [MongoCredential](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoCredential.html) ## Mechanisms ### Default The default authentication mechanism setting uses one of the following authentication mechanisms depending on what your MongoDB server supports:\n\n Server versions 3.6 and earlier use `MONGODB-CR` as the default mechanism. Newer versions of the server use one of the mechanisms for which they advertise support. The following code snippets show how to specify the authentication mechanism, using the following placeholders: * `username` \\- your MongoDB username\n* `password` \\- your MongoDB user's password\n* `hostname` \\- network address of your MongoDB server, accessible by your client\n* `port` \\- port number of your MongoDB server\n* `authenticationDb` \\- MongoDB database that contains your user's authentication data. If you omit this parameter, the driver uses the default value `admin`. Select the Connection String or the MongoCredentialtab below for instructions and sample code for specifying this authentication mechanism: For more information on the challenge-response (CR) and salted challenge-response authentication mechanisms (SCRAM) that MongoDB supports, see the [SCRAM](https://www.mongodb.com/docs/manual/core/security-scram/) section of the server manual. ### `SCRAM-SHA-256` ## Note `SCRAM-SHA-256` is the default authentication method for MongoDB starting in MongoDB 4.0. `SCRAM-SHA-256` is a salted challenge-response authentication mechanism (SCRAM) that uses your username and password, encrypted with the `SHA-256`algorithm, to authenticate your user. The following code snippets show how to specify the authentication mechanism, using the following placeholders: * `username` \\- your MongoDB username.\n* `password` \\- your MongoDB user's password.\n* `hostname` \\- network address of your MongoDB server, accessible by your client.\n* `port` \\- port number of your MongoDB server.\n* `authenticationDb` \\- MongoDB database that contains your user's authentication data. If you omit this parameter, the driver uses the default value `admin`. Select the Connection String or the MongoCredentialtab below for instructions and sample code for specifying this authentication mechanism: ### `SCRAM-SHA-1` ## Note `SCRAM-SHA-1` is the default authentication method for MongoDB versions 3.0, 3.2, 3.4, and 3.6. `SCRAM-SHA-1` is a salted challenge-response mechanism (SCRAM) that uses your username and password, encrypted with the `SHA-1` algorithm, to authenticate your user. The following code snippets show how to specify the authentication mechanism, using the following placeholders: * `username` \\- your MongoDB username.\n* `password` \\- your MongoDB user's password.\n* `hostname` \\- network address of your MongoDB server, accessible by your client.\n* `port` \\- port number of your MongoDB server.\n* `authenticationDb` \\- MongoDB database that contains your user's authentication data. If you omit this parameter, the driver uses the default value `admin`. Select the Connection String or the MongoCredentialtab below for instructions and sample code for specifying this authentication mechanism: ### `MONGODB-CR` `MONGODB-CR` is a challenge-response authentication mechanism that uses your username and password to authenticate your user. This authentication mechanism was deprecated starting in MongoDB 3.6 and is no longer supported as of MongoDB 4.0. You cannot specify this method explicitly; refer to the fallback provided by the [default authentication mechanism](#std-label-default-auth-mechanism) to connect using `MONGODB-CR`. ### `MONGODB-AWS` ## Note The MONGODB-AWS authentication mechanism is available for MongoDB deployments on MongoDB Atlas. The `MONGODB-AWS` authentication mechanism uses your Amazon Web Services Identity and Access Management (AWS IAM) credentials to authenticate your user. To learn more about configuring MongoDB Atlas, see the[Set Up Passwordless Authentication with AWS IAM Roles](https://www.mongodb.com/docs/atlas/security/passwordless-authentication/#set-up-passwordless-authentication-with-aws-iam-roles)guide. To instruct the driver to use this authentication mechanism, you can specify`MONGODB-AWS` either as a parameter in the connection string or by using the `MongoCredential.createAwsCredential()` factory method. Learn how to specify this authentication mechanism and the various ways to provide your AWS IAM credentials in the next sections.\n\n * `awsKeyId` \\- value of your AWS access key ID\n* `awsSecretKey` \\- value of your AWS secret access key\n* `atlasUri` \\- network address of your MongoDB Atlas deployment\n* `hostname` \\- hostname of your MongoDB Atlas deployment\n* `port` \\- port of your MongoDB Atlas deployment\n* `awsSessionToken` \\- value of your AWS session token #### AWS SDK for Java _New in version v4.8_. You can use one of the AWS SDK for Java v1 or v2 to specify your credentials. This method offers the following features: * Multiple options for obtaining credentials\n* Credential caching which helps your application avoid rate limiting\n* Credential provider management for use with the [Elastic Kubernetes Service.](https://docs.aws.amazon.com/eks/latest/userguide/what-is-eks.html) To use the AWS SDK for Java for `MONGODB-AWS` authentication, you must perform the following: 1. Specify the authentication mechanism\n2. Add the SDK as a dependency to your project\n3. Supply your credentials using one of the methods in the credential provider chain ## Important This method of providing `MONGODB-AWS` credentials is available only in the MongoDB Java Driver v4.8 and later. To specify the authentication mechanism by using a `MongoCredential`, use the `MongoCredential.createAwsCredential()` factory method and add the `MongoCredential` instance to your `MongoClient` as shown in the following example: `| MongoCredential credential = MongoCredential.createAwsCredential(null, null); |\n| ----------------------------------------------------------------------------- |\n| MongoClient mongoClient = MongoClients.create(                                |\n| MongoClientSettings.builder()                                                 |\n| .applyToClusterSettings(builder ->                                            |\n| builder.hosts(Arrays.asList(new ServerAddress(\"<atlasUri>\"))))                |\n| .credential(credential)                                                       |\n| .build());                                                                    | ` To specify the authentication mechanism in the connection string, add it as a parameter as shown in the following example: ```java MongoClient mongoClient = MongoClients.create(\"mongodb://<atlasUri>?authMechanism=MONGODB-AWS\"); \n``` To add the AWS SDK as a dependency to your project, see the following AWS documentation for the version you need: * For the **AWS SDK for Java v2**, see the [Setting Up](https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/setup.html)guide.\n* For the **AWS SDK for Java v1**, see the [Getting Started](https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/getting-started.html)guide. ## Note For the AWS SDK for Java v2, the Java driver currently tests using the`software.amazon.awssdk:auth:2.18.9` dependency. For the AWS SDK for Java v1, the Java driver currently tests using the`com.amazonaws:aws-java-sdk-core:1.12.337` dependency.\n\n * To learn more about the **AWS SDK for Java v2** class the driver uses to get the credentials, see the [DefaultCredentialsProvider](https://sdk.amazonaws.com/java/api/latest/software/amazon/awssdk/auth/credentials/DefaultCredentialsProvider.html)API documentation.  \nLearn how to supply your credentials to this class from the[Use the default credential provider chain](https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/credentials.html#credentials-chain)section.\n* To learn more about the **AWS SDK for Java v1** class the driver uses to get the credentials, see the [DefaultAWSCredentialsProviderChain](https://docs.aws.amazon.com/AWSJavaSDK/latest/javadoc/com/amazonaws/auth/DefaultAWSCredentialsProviderChain.html)API documentation.  \nLearn how to supply your credentials to this class from the[Using the Default Credential Provider Chain](https://docs.aws.amazon.com/sdk-for-java/v1/developer-guide/credentials.html#credentials-default)section. ## Note If you include both v1 and v2 of the AWS SDK for Java in your project, you must use the v2 methods to supply your credentials. #### Specify Your Credentials in the Environment You can provide your AWS IAM credentials by instructing the driver to use the `MONGODB-AWS` authentication mechanism and by setting the appropriate environment variables. To use the environment variables to supply your credentials, you must perform the following: 1. Specify the authentication mechanism\n2. Add the appropriate environment variables You can specify the authentication mechanism by using a `MongoCredential`or on the connection string. To specify the authentication mechanism by using a `MongoCredential`, use the `MongoCredential.createAwsCredential()` factory method and add the`MongoCredential` instance to your `MongoClient` as shown in the following example: ```java MongoCredential credential = MongoCredential.createAwsCredential(null, null); MongoClient mongoClient = MongoClients.create(         MongoClientSettings.builder()         .applyToClusterSettings(builder ->         builder.hosts(Arrays.asList(new ServerAddress(\"<atlasUri>\"))))         .credential(credential)         .build()); \n``` To specify the authentication mechanism in the connection string, add it as a parameter as shown in the following example: ```java MongoClient mongoClient = MongoClients.create(\"mongodb://<atlasUri>?authMechanism=MONGODB-AWS\"); \n``` The next examples show how to provide your credentials by setting environment variables for the following types of authentication: * Programmatic access keys\n* ECS container credentials\n* EC2 container credentials The following example shows how you can set your **programmatic access keys**in environment variables by using `bash` or a similar shell: ```bash export AWS_ACCESS_KEY_ID=<awsKeyId> export AWS_SECRET_ACCESS_KEY=<awsSecretKey> export AWS_SESSION_TOKEN=<awsSessionToken> \n``` Omit the line containing `AWS_SESSION_TOKEN` if you don't need an AWS session token for that role. To authenticate by using **ECS container credentials**, set the ECS endpoint relative URI in an environment variable by using `bash` or a similar shell as shown in the following example: ```bash export AWS_CONTAINER_CREDENTIALS_RELATIVE_URI=<your ECS endpoint> \n``` To authenticate using **EC2 container credentials**, make sure none of the aforementioned environment variables are set. The driver obtains the credentials from the default IPv4 EC2 instance metadata endpoint. #### Specify Your Credentials in a MongoCredential\n\n You can supply only programmatic access keys to the`MongoCredential.createAwsCredential()` method. If you need to supply ECS or EC2 container credentials, use the instructions in[Specify Your Credentials in the Environment](#std-label-java-mongodb-aws-env-variables) or [AWS SDK for Java.](#std-label-java-mongodb-aws-sdk) To use the `MongoCredential` for `MONGODB-AWS` authentication, you must perform the following: 1. Specify the authentication mechanism\n2. Supply the credentials To specify the authentication mechanism by using a `MongoCredential`, use the `MongoCredential.createAwsCredential()` factory method and add the `MongoCredential` instance to your `MongoClient` as shown in the following example: ```java MongoCredential credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray()); MongoClient mongoClient = MongoClients.create(         MongoClientSettings.builder()         .applyToClusterSettings(builder ->         builder.hosts(Arrays.asList(new ServerAddress(\"<atlasUri>\"))))         .credential(credential)         .build()); \n``` If you need to specify an AWS session token, pass it to the[withMechanismProperty()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoCredential.html#withMechanismProperty%28java.lang.String,T%29)method as shown in the following example: ```java MongoCredential credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray()).withMechanismProperty(\"AWS_SESSION_TOKEN\",  \"<awsSessionToken>\"); MongoClient mongoClient = MongoClients.create(         MongoClientSettings.builder()         .applyToClusterSettings(builder ->         builder.hosts(Arrays.asList(new ServerAddress(\"<atlasUri>\"))))         .credential(credential)         .build()); \n``` To refresh your credentials, you can declare a `Supplier` lambda expression that returns new credentials as shown in the following example: ```java Supplier<AwsCredential> awsFreshCredentialSupplier = () -> {     // Add your code here to fetch new credentials here     // Return the new credentials     return new AwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\", \"<awsSessionToken>\"); }; MongoCredential credential = MongoCredential.createAwsCredential(\"<awsKeyId>\", \"<awsSecretKey>\".toCharArray())         .withMechanismProperty(MongoCredential.AWS_CREDENTIAL_PROVIDER_KEY, awsFreshCredentialSupplier); MongoClient mongoClient = MongoClients.create(         MongoClientSettings.builder()         .applyToClusterSettings(builder ->             builder.hosts(Collections.singletonList(new ServerAddress(\"<hostname>\", <port>))))         .credential(credential)         .build()); \n``` ## Note If you must provide AWS IAM credentials in a connection string, refer to a previous release of the [MONGODB-AWS driver documentation.](https://www.mongodb.com/docs/drivers/java/sync/v4.7/fundamentals/auth/#mongodb-aws) ### `X.509`\n\n The following code snippets show how to specify the authentication mechanism, using the following placeholders: * `hostname` \\- network address of your MongoDB server, accessible by your client.\n* `port` \\- port number of your MongoDB server.\n* `authenticationDb` \\- MongoDB database that contains your user's authentication data. If you omit this parameter, the driver uses the default value `admin`. Select the Connection String or the MongoCredentialtab below for instructions and sample code for specifying this authentication mechanism: For additional information on configuring your application to use certificates as well as TLS/SSL options, see our[TLS/SSL guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/tls/) ← [Connect to MongoDB Using a JNDI Datasource](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/jndi/ \"Previous Section\")[Enterprise Authentication Mechanisms](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/enterprise-auth/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Connection Guide On this page * [Overview](#overview) ## Overview Learn how to set up a connection and specify connection behavior from your application to a MongoDB deployment using the driver in the following sections: * [Connect to MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connect-to-mongodb)\n* [View a List of Connection Options](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connection-options/#std-label-connection-options)\n* [Specify Connection Behavior with the MongoClient Class](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/mongoclientsettings/#std-label-specify-mongoclient-settings)\n* [Enable Network Compression](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/network-compression/#std-label-network-compression)\n* [Enable TLS/SSL on a Connection](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/tls/#std-label-tls-ssl)\n* [Connect to MongoDB Using a JNDI Datasource](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/jndi/#std-label-jndi)\n* [Connect to MongoDB Atlas from AWS Lambda](https://www.mongodb.com/docs/atlas/manage-connections-aws-lambda/) For information about authenticating with a MongoDB instance, see [Authentication Mechanisms](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/auth/#std-label-authentication-mechanisms) and [Enterprise Authentication Mechanisms.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/enterprise-auth/#std-label-enterprise-authentication-mechanisms) ← [Fundamentals](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/ \"Previous Section\")[Connect to MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/time-series/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Time Series Collections On this page * [Overview](#overview)\n* [Create a Time Series Collection](#create-a-time-series-collection)\n* [Query a Time Series Collection](#query-a-time-series-collection) ## Overview In this guide, you can learn about **time series collections** in MongoDB, and how to interact with them in the MongoDB Java driver. Time series collections efficiently store sequences of measurements over a period of time. Time series data consists of any data collected over time, metadata that describes the measurement, and the time of the measurement. | Example         | Measurement               | Metadata |\n| --------------- | ------------------------- | -------- |\n| Sales Data      | Revenue                   | Company  |\n| Infection Rates | Amount of People Infected | Location | ## Create a Time Series Collection To create a time series collection, pass the following parameters to the[createCollection()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#createCollection%28java.lang.String,com.mongodb.client.model.CreateCollectionOptions%29)method: * The name of the new collection to create\n* The [TimeSeriesOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/TimeSeriesOptions.html) for creating the collection in a [CreateCollectionOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/CreateCollectionOptions.html) object `| MongoDatabase database = mongoClient.getDatabase(\"fall_weather\");                                 |\n| ------------------------------------------------------------------------------------------------- |\n| TimeSeriesOptions tsOptions = new TimeSeriesOptions(\"temperature\");                               |\n| CreateCollectionOptions collOptions = new CreateCollectionOptions().timeSeriesOptions(tsOptions); |\n| database.createCollection(\"september2021\", collOptions);                                          | ` ## Important Versions prior to MongoDB 5.0 cannot create a time series collection. To check if you successfully created the collection, send the`\"listCollections\"` command to the [runCommand()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#runCommand%28org.bson.conversions.Bson%29) method. ```java Document commandResult = database.runCommand(new Document(\"listCollections\", new BsonInt64(1))); List<String> keys = Arrays.asList(\"cursor\"); System.out.println(\"listCollections: \" + commandResult.getEmbedded(keys, Document.class).toJson()); \n``` Your output should look similar to the following: ``` {  \"id\": <some number>,  \"ns\": \"<db name>.$cmd.listCollections\",  \"firstBatch\": [   {     \"name\": \"<time series collection name>\",     \"type\": \"timeseries\",     \"options\": {      \"expireAfterSeconds\": <some number>,       \"timeseries\": { ... }      },      ...    },    ...  ] } \n``` ## Query a Time Series Collection\n\n ## Note ### Window Functions MongoDB version 5.0 introduces window functions into the aggregation pipeline. You can use window functions to perform operations on a contiguous span of time series data. For more information, see our[Aggregates Builders guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/aggregates/#std-label-builders-aggregates-setWindowFields) ← [Client-Side Field Level Encryption](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/csfle/ \"Previous Section\")[API Documentation](https://mongodb.com/docs/drivers/java/sync/current/api-documentation/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/collations/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Collations On this page * [Overview](#overview)\n* [Collations in MongoDB](#collations-in-mongodb)\n* [How to Specify Collations](#how-to-specify-collations)\n* [Collection](#collection)\n* [Index](#index)\n* [Operation](#operation)\n* [Index Types That Do Not Support Collations](#index-types-that-do-not-support-collations)\n* [Collation Options](#collation-options)\n* [Collation Examples](#collation-examples)\n* [find() and sort() Example](#find---and-sort---example)\n* [findOneAndUpdate() Example](#findoneandupdate---example)\n* [findOneAndDelete() Example](#findoneanddelete---example)\n* [Aggregation Example](#aggregation-example) ## Overview In this guide, you can learn how to use **collations** with MongoDB to order your query or aggregation operation results by string values. A collation is a set of character ordering and matching rules that apply to a specific language and locale. You can learn more about collations in the following sections in this guide: * [Collations in MongoDB](#std-label-collations-mongodb)\n* [How to Specify Collations](#std-label-collations-specify)\n* [Collation Options](#std-label-collations-options)\n* [Collation Code Examples](#std-label-collations-examples) ## Collations in MongoDB MongoDB sorts strings using **binary collation** by default. The binary collation uses the [ASCII standard](https://en.wikipedia.org/wiki/ASCII) character values to compare and order strings. Certain languages and locales have specific character ordering conventions that differ from the ASCII character values. For example, in Canadian French, the right-most accented character (diacritic) determines the ordering for strings when all preceding characters are the same. Consider the following Canadian French words: * cote\n* coté\n* côte\n* côté When using binary collation, MongoDB sorts them in the following order: `| cote |\n| ---- |\n| coté |\n| côte |\n| côté | ` When using the Canadian French collation, MongoDB sorts them in a different order as shown below: ``` cote côte coté côté \n``` ## How to Specify Collations MongoDB supports collations on most [CRUD operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/)and aggregations. For a complete list of supported operations, see the[Operations that Support Collations](https://www.mongodb.com/docs/manual/reference/collation/#operations-that-support-collation)server manual page. You can specify the locale code and optional variant in the following string format: ``` \"<locale code>@collation=<variant code>\" \n``` The following example specifies the \"de\" locale code and \"phonebook\" variant code: ``` \"de@collation=phonebook\" \n``` If you do not need to specify a variant, omit everything after the locale code as follows: ``` \"de\" \n``` For a complete list of supported locales, see our server manual page on[Supported Languages and Locales.](https://www.mongodb.com/docs/manual/reference/collation-locales-defaults/#supported-languages-and-locales) The following sections show you different ways to apply collations in MongoDB: * [Collection](#std-label-collations-collection)\n* [Index](#std-label-collations-index)\n* [Operation](#std-label-collations-operation) ### Collection You can set a default collation when you create a collection. When you create a collection with a specified collation, all supported operations that scan that collection apply the rules of the collation. You can only assign a default collation to a collection when you create that collection. However, you can specify a collation in a new index on an existing collection. See the [Index](#std-label-collations-index) section of this guide for more information.\n\n ```java database.createCollection(         \"items\",         new CreateCollectionOptions().collation(                 Collation.builder().locale(\"en_US\").build())); \n``` To check whether you created the collation successfully, retrieve a list of the indexes on that collection as follows: ```java MongoCollection<Document> collection = database.getCollection(\"items\"); List<Document> indexes = new ArrayList<>(); collection.listIndexes().into(indexes); indexes.forEach(idx -> System.out.println(idx.toJson())); \n``` The output of your code should contain the following: ``` { ...   \"collation\": { \"locale\": \"en_US\", ... }   ... } \n``` ### Index You can specify a collation when you create a new index on a collection. The index stores an ordered representation of the documents in the collection so your operation does not need to perform the ordering in-memory. To use the index, your operation must meet the following criteria: * The operation uses the same collation as the one specified in the index.\n* The operation is covered by the index that contains the collation. The following code snippet shows how you can create an index on the \"name\" field with the \"en\\_US\" locale collation in ascending order: ```java MongoCollection<Document> collection = database.getCollection(\"items\"); IndexOptions idxOptions = new IndexOptions(); idxOptions.collation(Collation.builder().locale(\"en_US\").build()); collection.createIndex(Indexes.ascending(\"name\"), idxOptions); \n``` To check whether you created the collation successfully, retrieve a list of the indexes on that collection as follows: ```java MongoCollection<Document> collection = database.getCollection(\"items\"); List<Document> indexes = new ArrayList<>(); collection.listIndexes().into(indexes); indexes.forEach(idx -> System.out.println(idx.toJson())); \n``` The output of the preceding code should contain the following: ``` { ...   \"collation\": { \"locale\": \"en_US\", ... }   ... } \n``` The following code snippet shows an example operation that specifies the same collation and is covered by the index we created in the preceding code snippet: ```java FindIterable<Document> cursor = collection.find()         .collation(Collation.builder().locale(\"en_US\").build())         .sort(Sorts.ascending(\"name\")); \n``` ### Operation You can override the default collation on a collection by passing the new collation as a parameter to one of the supported operations. However, since the operation does not use an index, the operation may not perform as well as one that is covered by an index. For more information on the disadvantages of sorting operations not covered by an index, see the server manual page on [Use Indexes to Sort Query Results.](https://www.mongodb.com/docs/manual/tutorial/sort-results-with-indexes/) The following code snippet shows an example query operation with the following characteristics: * The referenced collection contains the default collation \"en\\_US\" similar to the one specified in the [Collection](#std-label-collations-collection) section.\n* The query specifies the Icelandic (\"is\") collation which is not covered by the collection's default collation index.\n* Since the specified collation is not covered by an index, the sort operation is performed in-memory. ```java FindIterable<Document> cursor = collection.find()         .collation(Collation.builder().locale(\"is\").build())         .sort(Sorts.ascending(\"name\")); \n``` ### Index Types That Do Not Support Collations While most MongoDB index types support collation, the following types support only binary comparison:\n\n ## Collation Options This section covers various collation options and how to specify them to further refine the ordering and matching behavior.\n\n You can use the `Collation.Builder` class to specify values for the preceding collation options. You can call the `build()` method to construct a`Collation` object as shown in the following code snippet: ```java Collation.builder() .caseLevel(true) .collationAlternate(CollationAlternate.SHIFTED) .collationCaseFirst(CollationCaseFirst.UPPER) .collationMaxVariable(CollationMaxVariable.SPACE) .collationStrength(CollationStrength.SECONDARY) .locale(\"en_US\") .normalization(false) .numericOrdering(true) .build(); \n``` For more information on the corresponding methods and parameters they take, see the API Documentation for [Collation.Builder.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Collation.Builder.html) ## Collation Examples This section contains examples that demonstrate how to use a selection of MongoDB operations that support collations. For each example, assume that you start with the following collection of documents: ``` { \"_id\" : 1, \"first_name\" : \"Klara\" } { \"_id\" : 2, \"first_name\" : \"Gunter\" } { \"_id\" : 3, \"first_name\" : \"Günter\" } { \"_id\" : 4, \"first_name\" : \"Jürgen\" } { \"_id\" : 5, \"first_name\" : \"Hannah\" } \n``` In the following examples, we specify the \"[de@collation=phonebook](mailto:de@collation=phonebook)\" locale and variant collation. The \"de\" part of the collation specifies the German locale and the \"collation=phonebook\" part specifies a variant. The \"de\" locale collation contains rules for prioritizing proper nouns, identified by capitalization of the first letter. In the \"collation=phonebook\" variant, characters with umlauts are ordered before the same characters without them in an ascending sort. ### find() and sort() Example The following example demonstrates how you can apply a collation when retrieving sorted results from a collection. To perform this operation, call `find()` on the example collection and chain the`collation()` and `sort()` methods to specify the order in which you want to receive the results. ## Note The following code example uses imports from the`import com.mongodb.client.model` package for convenience. ```java List<Document> results = new ArrayList<>(); collection.find()         .collation(Collation.builder().locale(\"de@collation=phonebook\").build())         .sort(Sorts.ascending(\"first_name\")).into(results); if (results != null) {     results.forEach(doc -> System.out.println(doc.toJson())); } \n``` When we perform this operation on our [example collection](#std-label-collation-example-collection), the output should resemble the following: ``` {\"_id\": 3, \"first_name\": \"Günter\"} {\"_id\": 2, \"first_name\": \"Gunter\"} {\"_id\": 5, \"first_name\": \"Hannah\"} {\"_id\": 4, \"first_name\": \"Jürgen\"} {\"_id\": 1, \"first_name\": \"Klara\"} \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [find()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#find%28%29)\n* [sort()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#sort%28org.bson.conversions.Bson%29)\n* [Sorts](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html) ### findOneAndUpdate() Example\n\n In this example, we demonstrate the following: * Retrieve the first document in our [example collection](#std-label-collation-example-collection)that precedes \"Gunter\" in an ascending order.\n* Set options for operation including the \"[de@collation=phonebook](mailto:de@collation=phonebook)\" collation.\n* Add a new field \"verified\" with the value \"true\".\n* Retrieve and print the updated document. ## Note The following code example uses imports from the`import com.mongodb.client.model` package for convenience. ```java Document result = collection.findOneAndUpdate(         Filters.gt(\"first_name\", \"Gunter\"),         Updates.set(\"verified\", true),         new FindOneAndUpdateOptions()                 .collation(Collation.builder().locale(\"de@collation=phonebook\").build())                 .sort(Sorts.ascending(\"first_name\"))                 .returnDocument(ReturnDocument.AFTER)); if (result != null) {     System.out.println(\"Updated document: \" + result.toJson()); } \n``` Since \"Günter\" is lexically before \"Gunter\" using the`de@collation=phonebook` collation in ascending order, the preceding operation returns the following update document: ``` {   lastErrorObject: { updatedExisting: true, n: 1 },   value: { _id: 3, first_name: 'Günter' },   ok: 1 } \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [findOneAndUpdate](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#findOneAndUpdate%28org.bson.conversions.Bson,java.util.List,com.mongodb.client.model.FindOneAndUpdateOptions%29)\n* [findOneAndUpdateOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/FindOneAndUpdateOptions.html)\n* [Filters](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html)\n* [Updates](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html)\n* [Sorts](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html) ### findOneAndDelete() Example This section demonstrates how you can specify a numerical ordering of strings in a collation in an operation that deletes the first match from your query. To specify the collation for this operation, instantiate a `FindOneAndDeleteOptions` object, set a numeric ordering collation on it, and pass it as a parameter to your call to the `findOneAndDelete()`method. This example calls the `findOneAndDelete()` operation on a collection that contains the following documents: ``` { \"_id\" : 1, \"a\" : \"16 apples\" } { \"_id\" : 2, \"a\" : \"84 oranges\" } { \"_id\" : 3, \"a\" : \"179 bananas\" } \n``` In the collation, we set the `locale` option to \"en\" and the`numericOrdering` option to \"true\" in order to sort strings based on their numerical order. ## Note The following code example uses imports from the`import com.mongodb.client.model` package for convenience. ```java Document result = collection.findOneAndDelete(         Filters.gt(\"a\", \"100\"),\n\n                 .collation(                         Collation.builder()                                 .locale(\"en\")                                 .numericOrdering(true)                                 .build())                 .sort(Sorts.ascending(\"a\"))); if (result != null) {     System.out.println(\"Deleted document: \" + result.toJson()); } \n``` After you run the preceding operation, your output should resemble the following: ``` Deleted document: {\"_id\": 3, \"a\": \"179 bananas\"} \n``` The numeric value of the string \"179\" is greater than the number 100, so the preceding document is the only match. If we perform the same operation without the numerical ordering collation on the original collection of three documents, the filter matches all of our documents since \"100\" comes before \"16\", \"84\", and \"179\" when ordering by binary collation. For more information about the methods and classes mentioned in this section, see the following API Documentation: * [findOneAndDelete](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#findOneAndDelete%28org.bson.conversions.Bson%29)\n* [FindOneAndDeleteOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/FindOneAndDeleteOptions.html)\n* [Filters](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html)\n* [Sorts](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html) ### Aggregation Example This section demonstrates how you can specify a collation in an aggregation operation. In an aggregation operation, you can specify a series of aggregation stages which is collectively called the aggregation pipeline. To perform an aggregation, call the `aggregate()` method on a`MongoCollection` object. To specify a collation for an aggregation operation, call the `collation()`method on the `AggregateIterable` returned by the aggregation operation. Make sure to specify a sort aggregation stage on which to apply the collation in your aggregation pipeline. The following example shows how we can construct an aggregation pipeline on the [example collection](#std-label-collation-example-collection) and apply a collation by specifying the following: * A group aggregation stage using the `Aggregates.group()` helper to identify each document by the `first_name` field and use that value as the `_id` of the result.\n* An accumulator in the group aggregation stage to sum the number of instances of matching values in the `first_name` field.\n* Apply an ascending sort to the `_id` field of the output documents of the prior aggregation stage.\n* Construct a collation object, specifying the German locale and a collation strength that ignores accents and umlauts. ```java Bson groupStage = Aggregates.group(\"$first_name\", Accumulators.sum(\"nameCount\", 1)); Bson sortStage = Aggregates.sort(Sorts.ascending(\"_id\")); AggregateIterable<Document> results = collection         .aggregate(Arrays.asList(groupStage, sortStage))         .collation(Collation.builder().locale(\"de\").collationStrength(CollationStrength.PRIMARY).build()); if (results != null) {\n\n } \n``` The preceding code outputs the following documents: ``` {\"_id\": \"Gunter\", \"nameCount\": 2} {\"_id\": \"Hannah\", \"nameCount\": 1} {\"_id\": \"Jürgen\", \"nameCount\": 1} {\"_id\": \"Klara\", \"nameCount\": 1} \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [aggregate()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#aggregate%28java.util.List%29)\n* [AggregateIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/AggregateIterable.html)\n* [CollationStrength](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/CollationStrength.html)\n* [Accumulators](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html)\n* [Aggregates](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html)\n* [Sorts](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html) ← [Indexes](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/indexes/ \"Previous Section\")[Logging](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/logging/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/monitoring/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Monitoring On this page * [Overview](#overview)\n* [Monitor Events](#monitor-events)\n* [Command Events](#command-events)\n* [Server Discovery and Monitoring Events](#server-discovery-and-monitoring-events)\n* [Connection Pool Events](#connection-pool-events)\n* [Monitor Connection Pool Events with JMX](#monitor-connection-pool-events-with-jmx)\n* [JMX Support](#jmx-support)\n* [JMX and JConsole Example](#jmx-and-jconsole-example)\n* [Include the Driver in Your Distributed Tracing System](#include-the-driver-in-your-distributed-tracing-system) ## Overview In this guide, you can learn how to set up and configure **monitoring** in the MongoDB Java driver. Monitoring is the process of getting information about the activities a running program performs for use in an application or an application performance management library. Monitoring the MongoDB Java driver lets you understand the driver's resource usage and performance, and can help you make informed decisions when designing and debugging your application. In this guide you will learn how to perform these tasks: * [Monitor different types of events in the MongoDB Java Driver](#std-label-monitoring-monitor-events)\n* [Monitor connection pool events with Java Management Extensions (JMX) and JConsole](#std-label-monitoring-jmx) This guide shows how to use information about the activity of the driver in code. If you would like to learn how to record events in the driver, consider reading our [guide on logging.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/logging/) ## Monitor Events To monitor an **event**, you must register a **listener** on your `MongoClient`instance. An event is any action that happens in a running program. The driver includes functionality for listening to a subset of the events that occur when the driver is running. A listener is a class that performs some action when certain events occur. A listener's API defines the events it can respond to. Each method of a listener class represents a response to a certain event. Each method receives one argument: an object representing the event the method responds to. The MongoDB Java driver organizes the events it defines into three categories: * Command Events\n* Server Discovery and Monitoring Events\n* Connection Pool Events The following sections show how to monitor each event category. For a full list of the events you can monitor,[see the event package of the MongoDB Java Driver.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/package-summary.html) ### Command Events A command event is an event related to a MongoDB database command. Some examples of database commands that produce command events are `find`,`insert`, `delete`, and `count`. To monitor command events, write a class that implements the`CommandListener` interface and register an instance of that class with your`MongoClient` instance. For more information on MongoDB database commands, see the[MongoDB manual entry on database commands.](https://www.mongodb.com/docs/manual/reference/command/) ## Note ### Internal Commands The driver does not publish events for commands it calls internally. This includes database commands the driver uses to monitor your cluster and commands related to connection establishment (such as the initial `hello`command). ## Important ### Redacted Output As a security measure, the driver redacts the contents of some command events. This protects the sensitive information contained in these command events. For a full list of redacted command events, see the[MongoDB command logging and monitoring specification.](https://github.com/mongodb/specifications/blob/master/source/command-logging-and-monitoring/command-logging-and-monitoring.rst#security) #### Example This example shows how to make a counter for database commands. The counter keeps track of the number of times the driver successfully executes each database command, and prints this information every time a database command finishes. To make a counter, do the following:\n\n The following code defines the `CommandCounter` class which implements the`CommandListener` interface: `| class CommandCounter implements CommandListener {                               |\n| ------------------------------------------------------------------------------- |\n| private Map<String, Integer> commands = new HashMap<String, Integer>();         |\n| @Override                                                                       |\n| public synchronized void commandSucceeded(final CommandSucceededEvent event) {  |\n| String commandName = event.getCommandName();                                    |\n| int count = commands.containsKey(commandName) ? commands.get(commandName) : 0;  |\n| commands.put(commandName, count + 1);                                           |\n| System.out.println(commands.toString());                                        |\n| }                                                                               |\n| @Override                                                                       |\n| public void commandFailed(final CommandFailedEvent event) {                     |\n| System.out.println(String.format(\"Failed execution of command '%s' with id %s\", |\n| event.getCommandName(),                                                         |\n| event.getRequestId()));                                                         |\n| }                                                                               |\n| }                                                                               | ` The following code adds an instance of the `CommandCounter` class to a`MongoClientSettings` object, and configures a `MongoClient` instance with the`MongoClientSettings` object. The code then runs some database commands to test the counter. ```java MongoClientSettings settings =         MongoClientSettings.builder()                 .applyConnectionString(URI)\n\n                 .build(); MongoClient mongoClient = MongoClients.create(settings); MongoDatabase database = mongoClient.getDatabase(DATABASE); MongoCollection<Document> collection = database.getCollection(COLLECTION); // Run some commands to test the timer collection.find().first(); collection.find().first(); mongoClient.close(); \n``` The preceding code snippet should produce output that looks like this: ``` {find=1} {find=2} {find=2, endSessions=1} \n``` For more information on the classes and methods mentioned in this section, see the following API Documentation: * [CommandListener](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/CommandListener.html)\n* [MongoClientSettings](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html)\n* [MongoClient](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClient.html)\n* [CommandStartedEvent](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/CommandStartedEvent.html)\n* [CommandSucceededEvent](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/CommandSucceededEvent.html)\n* [CommandFailedEvent](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/CommandFailedEvent.html) ### Server Discovery and Monitoring Events A server discovery and monitoring (SDAM) event is an event related to a change in the state of the MongoDB instance or cluster you have connected the driver to. The driver defines nine SDAM events. The driver divides these nine events between three separate listener interfaces which each listen for three of the nine events. Here are the three interfaces and the events they listen for: * `ClusterListener`: [topology](https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#topology)related events\n* `ServerListener`: events related to `mongod` or `mongos` processes\n* `ServerMonitorListener`: heartbeat related events To monitor a type of SDAM event, write a class that implements one of the three preceding interfaces and register an instance of that class with your `MongoClient` instance. For a detailed description of each SDAM event in the driver, see the[MongoDB SDAM monitoring specification.](https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring-monitoring.rst#events) #### Example This example shows how to make a listener class that prints a message that lets you know if the driver can write to your MongoDB instance. The following code defines the `IsWritable` class which implements the`ClusterListener` interface. ```java class IsWriteable implements ClusterListener {     private boolean isWritable;     @Override     public synchronized void clusterDescriptionChanged(final ClusterDescriptionChangedEvent event) {         if (!isWritable) {             if (event.getNewDescription().hasWritableServer()) {                 isWritable = true;                 System.out.println(\"Able to write to server\");             }         } else {             if (!event.getNewDescription().hasWritableServer()) {\n\n                 System.out.println(\"Unable to write to server\");             }         }     } } \n``` The following code adds an instance of the `IsWritable` class to a`MongoClient` object. The code then runs a find operation to test the`IsWritable` class. ```java IsWriteable clusterListener = new IsWriteable(); MongoClientSettings settings =         MongoClientSettings.builder()                 .applyConnectionString(URI)                 .applyToClusterSettings(builder ->                         builder.addClusterListener(clusterListener))                 .build(); MongoClient mongoClient = MongoClients.create(settings); MongoDatabase database = mongoClient.getDatabase(DATABASE); MongoCollection<Document> collection = database.getCollection(COLLECTION); // Run a command to trigger a ClusterDescriptionChangedEvent event collection.find().first(); \n``` The preceding code snippet should produce output that looks like this: ``` Able to write to server \n``` For more information on the classes and methods mentioned in this section, see the following API Documentation: * [ClusterListener](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/ClusterListener.html)\n* [ServerListener](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/ServerListener.html)\n* [ServerMonitorListener](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/ServerMonitorListener.html)\n* [MongoClientSettings](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html)\n* [MongoClient](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClient.html)\n* [ClusterDescriptionChangedEvent](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/ClusterDescriptionChangedEvent.html) ### Connection Pool Events A connection pool event is an event related to a **connection pool** held by the driver. A connection pool is a set of open TCP connections your driver maintains with a MongoDB instance. Connection pools help reduce the number of network handshakes your application needs to perform with a MongoDB instance, and can help your application run faster. To monitor connection pool events, write a class that implements the`ConnectionPoolListener` interface and register an instance of that class with your`MongoClient` instance. #### Example This example shows how to make a listener class that prints a message each time you check out a connection from your connection pool. The following code defines the `ConnectionPoolLibrarian` class which implements the`ConnectionPoolListener` interface. ```java class ConnectionPoolLibrarian implements ConnectionPoolListener {     @Override     public void connectionCheckedOut(final ConnectionCheckedOutEvent event) {         System.out.println(String.format(\"Let me get you the connection with id %s...\",                 event.getConnectionId().getLocalValue()));     }     @Override     public void connectionCheckOutFailed(final ConnectionCheckOutFailedEvent event) {         System.out.println(\"Something went wrong! Failed to checkout connection.\");     } } \n```\n\n ```java ConnectionPoolLibrarian cpListener = new ConnectionPoolLibrarian(); MongoClientSettings settings =         MongoClientSettings.builder()                 .applyConnectionString(URI)                 .applyToConnectionPoolSettings(builder ->                         builder.addConnectionPoolListener(cpListener))                 .build(); MongoClient mongoClient = MongoClients.create(settings); MongoDatabase database = mongoClient.getDatabase(DATABASE); MongoCollection<Document> collection = database.getCollection(COLLECTION); // Run a command to trigger connection pool events collection.find().first(); \n``` The preceding code snippet should produce output that looks like this: ``` Let me get you the connection with id 21... \n``` For more information on the classes and methods mentioned in this section, see the following API Documentation: * [ConnectionPoolListener](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/ConnectionPoolListener.html)\n* [MongoClientSettings](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html)\n* [MongoClient](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClient.html)\n* [ConnectionCheckedOutEvent](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/ConnectionCheckedOutEvent.html)\n* [ConnectionCheckOutFailedEvent](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/event/ConnectionCheckOutFailedEvent.html) ## Monitor Connection Pool Events with JMX You can monitor connection pool events using **Java Management Extensions (JMX)**. JMX provides tools to monitor applications and devices. For more information on JMX, see[the official Oracle JMX documentation.](https://docs.oracle.com/javase/tutorial/jmx/index.html) ### JMX Support To enable JMX connection pool monitoring, add an instance of the`JMXConnectionPoolListener` class to your `MongoClient` object. The `JMXConnectionPoolListener` class performs the following actions: 1. Creates MXBean instances for each `mongod` or `mongos` process the driver maintains a connection pool with.\n2. Registers these MXBean instances with the platform MBean server. MXBeans registered on the platform MBean server have the following properties:\n\n All MXBean instances created by the driver are under the domain`\"org.mongodb.driver\"`. For more information on the topics discussed in this subsection, see the following resources from Oracle: * [Platform MBean Server Reference Documentation](https://docs.oracle.com/en/java/javase/16/management/overview-java-se-monitoring-and-management.html#GUID-F7B9AB8A-F5A8-472A-AEC6-93B5B7FBE7CE)\n* [MXBean Documentation](https://docs.oracle.com/javase/tutorial/jmx/mbeans/mxbeans.html)\n* [MBean Documentation](https://docs.oracle.com/javase/tutorial/jmx/mbeans/standard.html) ### JMX and JConsole Example This example shows how you can monitor the driver's connection pools using JMX and **JConsole**. JConsole is a JMX compliant GUI monitoring tool that comes with the Java Platform. ## Tip ### Consult the Official JMX and JConsole Documentation The descriptions of JMX and JConsole in this example are illustrative rather than a source of truth. For guaranteed up to date information, consult the following official Oracle resources: * [JConsole documentation.](https://www.oracle.com/technical-resources/articles/java/jconsole.html)\n* [JMX documentation](https://docs.oracle.com/javase/tutorial/jmx/index.html) The following code snippet adds a `JMXConnectionPoolListener` to a`MongoClient` instance. The code then pauses execution so you can navigate to JConsole and inspect your connection pools. ```java JMXConnectionPoolListener connectionPoolListener = new JMXConnectionPoolListener(); MongoClientSettings settings =         MongoClientSettings.builder()                 .applyConnectionString(URI)                 .applyToConnectionPoolSettings(builder -> builder.addConnectionPoolListener(connectionPoolListener))                 .build(); MongoClient mongoClient = MongoClients.create(settings); try {     System.out.println(\"Navigate to JConsole to see your connection pools...\");     Thread.sleep(Long.MAX_VALUE); } catch (Exception e) {     e.printStackTrace(); } \n``` The preceding code snippet should produce output that looks like this: ``` Navigate to JConsole to see your connection pools... \n``` Once you have started your server, open JConsole in your terminal using the following command: ```shell jconsole \n``` Once JConsole is open, perform the following actions in the GUI: 1. Select the Java process running the preceding example code.\n2. Press Insecure Connection in the warning dialog box.\n3. Click on the MBeans tab.\n4. Inspect your connection pool events under the `\"org.mongodb.driver\"` domain. When you no longer want to inspect your connection pools in JConsole, do the following: * Exit JConsole by closing the JConsole window\n* Stop the Java program running the preceding code snippet For more information on JMX and JConsole, see the following resources from Oracle: * [JConsole Documentation.](https://www.oracle.com/technical-resources/articles/java/jconsole.html)\n* [Monitoring and Management Guide](https://docs.oracle.com/en/java/javase/16/management/monitoring-and-management-using-jmx-technology.html) For more information on the `JMXConnectionPoolListener` class, see the API Documentation for[JMXConnectionPoolListener.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/management/JMXConnectionPoolListener.html) ## Include the Driver in Your Distributed Tracing System If you use a **distributed tracing system**, you can include event data from the driver. A distributed tracing system is an application that tracks requests as they propagate throughout different services in a service-oriented architecture.\n\n If you do not use Spring Cloud or need to include driver event data in a distributed tracing system other than Zipkin, you must write a command event listener that manages [spans](https://docs.spring.io/spring-cloud-sleuth/docs/current-SNAPSHOT/reference/html/getting-started.html#getting-started-terminology)for your desired distributed tracing system. To see an implementation of such a listener, see the[TraceMongoCommandListener](https://github.com/spring-cloud/spring-cloud-sleuth/blob/eb01d5952b2e736970efbe3fc7e9784d119eeae9/spring-cloud-sleuth-instrumentation/src/main/java/org/springframework/cloud/sleuth/instrument/mongodb/TraceMongoCommandListener.java)class in the Spring Cloud Sleuth source code. To learn more about Spring Cloud Sleuth, see[Getting Started](https://docs.spring.io/spring-cloud-sleuth/docs/current-SNAPSHOT/reference/html/getting-started.html)in the Spring Cloud Sleuth documentation. To view a detailed description of a distributed tracing system, see[Dapper](https://research.google/pubs/pub36356/) from Google Research. ← [Logging](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/logging/ \"Previous Section\")[GridFS](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/gridfs/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Document Data Format: BSON On this page * [Overview](#overview)\n* [BSON Data Format](#bson-data-format)\n* [MongoDB and BSON](#mongodb-and-bson)\n* [Install the BSON Library](#install-the-bson-library) ## Overview In this guide, you can learn about the BSON data format, how MongoDB uses it, and how to install the BSON library independently of the MongoDB Java driver. ## BSON Data Format **BSON**, or Binary JSON, is the data format that MongoDB uses to organize and store data. This data format includes all JSON data structure types and adds support for types including dates, different size integers, ObjectIds, and binary data. For a complete list of supported types, see the[BSON Types](https://www.mongodb.com/docs/manual/reference/bson-types/) server manual page. The binary format is not human-readable, but you can use the[Java BSON library](#std-label-install-bson-library) to convert it to a JSON representation. You can read more about the relationship between these formats in our article on [JSON and BSON.](https://www.mongodb.com/json-and-bson?tck=docs) ## MongoDB and BSON The MongoDB Java Driver, which uses the BSON library, allows you to work with BSON data by using one of the object types that implements the[BSON interface](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/conversions/Bson.html), including: * [Document](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/Document.html) (BSON library package)\n* [BsonDocument](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/BsonDocument.html) (BSON library package)\n* [RawBsonDocument](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/RawBsonDocument.html) (BSON library package)\n* [JsonObject](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/JsonObject.html) (BSON library package)\n* [BasicDBObject](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/BasicDBObject.html) (Java Driver package) For more information on using these object types, see our[Documents guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/documents/) ## Install the BSON Library These instructions show you how to add the BSON library as a dependency to your project. If you added the MongoDB Java driver as a dependency to your project, you can skip this step since the BSON library is already included as a required dependency of the driver. For instructions on how to add the MongoDB Java driver as a dependency to your project, see the[driver installation](https://mongodb.com/docs/drivers/java/sync/current/quick-start/#std-label-add-mongodb-dependency) section of our Quick Start guide. We recommend that you use the [Maven](https://maven.apache.org/) or[Gradle](https://gradle.org/) build automation tool to manage your project's dependencies. Select from the following tabs to see the dependency declaration for that tool: If you are not using one of the preceding tools, you can include it in your project by downloading the JAR file directly from the[sonatype repository.](https://repo1.maven.org/maven2/org/mongodb/bson/)\n\n",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-record/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Document Data Format: Records On this page * [Overview](#overview)\n* [Serialize and Deserialize a Record](#serialize-and-deserialize-a-record)\n* [Example Record](#example-record)\n* [Insert a Record](#insert-a-record)\n* [Retrieve a Record](#retrieve-a-record)\n* [Specify Component Conversion Using Annotations](#specify-component-conversion-using-annotations)\n* [Example Annotated Record](#example-annotated-record)\n* [Insert an Annotated Record](#insert-an-annotated-record)\n* [Retrieve an Annotated Record](#retrieve-an-annotated-record)\n* [Operations with Recursive Types](#operations-with-recursive-types)\n* [Retrieve the Record Codec](#retrieve-the-record-codec) ## Overview In this guide, you can learn how to store and retrieve data in the MongoDB Java Driver using **Java records**. Java records are a type of Java class often used to model data and separate business logic from data representation. ## Tip You can declare Java records in Java 16 or later. Learn more about the functionality and restrictions of records from [Java 17 Language Updates: Record Classes.](https://docs.oracle.com/en/java/javase/17/language/records.html) If you are using an earlier version of Java, you can use plain old Java objects instead. See the [Document Data Format: POJOs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/#std-label-fundamentals-pojos) guide for implementation details. ## Note If you are using the driver in an OSGi container and your application uses the driver to encode or decode Java records, you must add an explicit dependency on the `org.bson.codecs.record` module. Learn more about defining dependencies for OSGi containers in the [IBM OSGi documentation.](https://www.ibm.com/docs/en/cics-ts/6.1?topic=server-guidance-using-osgi) ## Serialize and Deserialize a Record The driver natively supports encoding and decoding Java records for MongoDB read and write operations using the **default codec registry**. The default codec registry is a collection of classes called **codecs** that define how to convert encode and decode Java types. Learn more about codecs and the default codec registry in the guide on [Codecs.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/#std-label-fundamentals-codecs) ### Example Record The code examples in this section reference the following sample record, which describes a data storage device: `| public record DataStorageRecord( |\n| -------------------------------- |\n| String productName,              |\n| double capacity                  |\n| ) {}                             | ` ### Insert a Record You can insert a `DataStorageRecord` instance as shown in the following code: ```java MongoCollection<DataStorageRecord> collection = database.getCollection(\"data_storage_devices\", DataStorageRecord.class); // insert the record collection.insertOne(new DataStorageRecord(\"2TB SSD\", 1.71)); \n``` ### Retrieve a Record You can retrieve documents as `DataStorageRecord` instances and print them as shown in the following code: ```java MongoCollection<DataStorageRecord> collection = database.getCollection(\"data_storage_devices\", DataStorageRecord.class); // retrieve and print the records List<DataStorageRecord> records = new ArrayList<DataStorageRecord>(); collection.find().into(records); records.forEach(System.out::println); \n``` HIDE OUTPUT `| DataStorageRecord[productName=1TB SSD, capacity=1.71] |\n| ----------------------------------------------------- | ` ## Specify Component Conversion Using Annotations This section describes the annotations you can use to configure the serialization behavior of record components and provides an example to demonstrate the annotation behavior. ## Tip\n\n You can use the following annotations on record components: | Annotation Name    | Description                                                                                                                   |\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------------- |\n| BsonId             | Specifies the component to serialize as the \\_id property.                                                                    |\n| BsonProperty       | Specifies a custom document field name when converting the record component to BSON. Accepts the field name as the parameter. |\n| BsonRepresentation | Specifies a BSON type to store when different from the record component type. Accepts the BSON type as the parameter.         | ## Note The driver supports annotations for Java records, but only if you include them when you define the component as shown in the following example record. You cannot use the annotations inside the record constructor. ### Example Annotated Record The code examples in this section reference the following sample record, which describes a network device: ```java import org.bson.BsonType; import org.bson.codecs.pojo.annotations.BsonProperty; import org.bson.codecs.pojo.annotations.BsonId; import org.bson.codecs.pojo.annotations.BsonRepresentation; public record NetworkDeviceRecord(         @BsonId()         @BsonRepresentation(BsonType.OBJECT_ID)         String deviceId,         String name,         @BsonProperty(\"type\")         String deviceType         ) {} \n``` ### Insert an Annotated Record You can insert a `DataStorageRecord` instance as shown in the following code: ```java MongoCollection<NetworkDeviceRecord> collection = database.getCollection(\"network_devices\", NetworkDeviceRecord.class); // insert the record String deviceId = new ObjectId().toHexString(); collection.insertOne(new NetworkDeviceRecord(deviceId, \"Enterprise Wi-fi\", \"router\")); \n``` The inserted document in MongoDB should resemble the following: ``` {   _id: ObjectId(\"fedc...\"),   name: 'Enterprise Wi-fi',   type: 'router' } \n``` ### Retrieve an Annotated Record You can retrieve documents as `NetworkDeviceRecord` instances and print them as shown in the following code: ```java MongoCollection<NetworkDeviceRecord> collection = database.getCollection(\"network_devices\", NetworkDeviceRecord.class); // return all documents in the collection as records List<NetworkDeviceRecord> records = new ArrayList<NetworkDeviceRecord>(); collection.find().into(records); records.forEach(System.out::println); \n``` HIDE OUTPUT ``` NetworkDeviceRecord[deviceId=fedc..., name=Enterprise Wi-fi, deviceType=router] \n``` ## Operations with Recursive Types The driver natively supports encoding and decoding of recursively defined records without causing runtime recursion. This support extends to cycles of multiple record types in type definitions. The following code provides an example of a recursive record design: ```java public record RecordTree(         String content,         RecordTree left,         RecordTree right ) {} \n``` You can perform read and write operations on recursively defined records the same way you would for other records. The following code shows how you can execute a find operation on a collection of `RecordTree` types: ```java MongoDatabase database = mongoClient.getDatabase(\"myDB\");\n\n Bson filter = Filters.eq(\"left.left.right.content\", \"Ikatere\"); collection.find(filter).forEach(doc -> System.out.println(doc)); \n``` HIDE OUTPUT ```shell RecordTree[content=Ranginui, left=RecordTree[content=..., left=RecordTree[content=..., right=RecordTree[content=Ikatere...]] \n``` ## Retrieve the Record Codec You can use the `RecordCodecProvider` to retrieve the record codec. You should use this interface when you want to customize the codec to encode and decode Java record objects to and from corresponding BSON types while minimizing duplicate code. To learn more about codecs and their usage, see [Codecs.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/#std-label-fundamentals-codecs) You can't create a record codec directly, but you can use the`RecordCodecProvider` to implement the record codec in your code. Learn more about the `RecordCodecProvider`, see the[API documentation.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson-record-codec/org/bson/codecs/record/RecordCodecProvider.html) ← [Document Data Format: POJOs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/ \"Previous Section\")[POJO Customization](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Codecs On this page * [Overview](#overview)\n* [Codec](#codec)\n* [CodecRegistry](#codecregistry)\n* [CodecProvider](#codecprovider)\n* [Default Codec Registry](#default-codec-registry)\n* [BsonTypeClassMap](#bsontypeclassmap)\n* [Custom Codec Example](#custom-codec-example) ## Overview In this guide, you can learn about **Codecs** and the supporting classes that handle the encoding and decoding of Java objects to and from BSON data in the MongoDB Java driver. The `Codec` abstraction allows you to map any Java type to a corresponding BSON type. You can use this to map your domain objects directly to and from BSON instead of using an intermediate map-based object such as `Document` or `BsonDocument`. You can learn how to specify custom encoding and decoding logic using the `Codec` abstraction and view example implementations in the following sections: * [Codec](#std-label-codecs-codec)\n* [CodecRegistry](#std-label-codecs-codecregistry)\n* [CodecProvider](#std-label-codecs-codecprovider)\n* [Custom Codec Example](#std-label-codecs-custom-example) If you are customizing encoding and decoding logic for plain old Java objects (POJOs), read our guide on [POJO Customization.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/) ## Codec The `Codec` interface contains abstract methods for serializing and deserializing Java objects to BSON data. You can define your conversion logic between BSON and your Java object in your implementation of this interface. To implement the `Codec` interface, override the `encode()`, `decode()`, and `getEncoderClass()` abstract methods. The `encode()` method requires the following parameters:\n\n This method uses the `BsonWriter` instance to send the encoded value to MongoDB and does not return a value. The `decode()` method returns your Java object instance populated with the value from the BSON data. This method requires the following parameters: | Parameter Type | Description                                                                                                                                                                                                |\n| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| bsonReader     | An instance of a class that implements BsonReader, an interface type that exposes methods for reading a BSON document. For example, theBsonBinaryReader implementation reads from a binary stream of data. |\n| decoderContext | Contains information about the BSON data that it decodes to a Java object.                                                                                                                                 | The `getEncoderClass()` method returns a class instance of the Java class since Java cannot infer the type due to type erasure. See the following code examples that show how you can implement a custom`Codec`. The `PowerStatus` enum contains the values \"ON\" and \"OFF\" to represent the states of an electrical switch. `| public enum PowerStatus { |\n| ------------------------- |\n| ON,                       |\n| OFF                       |\n| }                         | ` The `PowerStatusCodec` class implements `Codec` in order to convert the Java `enum` values to corresponding BSON boolean values. The`encode()` method converts a `PowerStatus` to a BSON boolean and the`decode()` method performs the conversion in the opposite direction. ```java public class PowerStatusCodec implements Codec<PowerStatus> {     @Override     public void encode(BsonWriter writer, PowerStatus value, EncoderContext encoderContext) {         if (value != null) {             writer.writeBoolean(value.equals(PowerStatus.ON) ? Boolean.TRUE : Boolean.FALSE);         }     }     @Override     public PowerStatus decode(BsonReader reader, DecoderContext decoderContext) {         return reader.readBoolean() ? PowerStatus.ON : PowerStatus.OFF;     }     @Override     public Class<PowerStatus> getEncoderClass() {         return PowerStatus.class;     } } \n``` You can add an instance of the `PowerStatusCodec` to your `CodecRegistry`which contains a mapping between your `Codec` and the Java object type to which it applies. Continue to the [CodecRegistry](#std-label-codecs-codecregistry)section of this page to see how you can include your `Codec`. For more information about the classes and interfaces in this section, see the following API Documentation:\n\n ## CodecRegistry A `CodecRegistry` is an immutable collection of `Codec` instances that encode and decode the Java classes they specify. You can use any of the following `CodecRegistries` class static factory methods to construct a`CodecRegistry` from the `Codec` instances contained in the associated types: * `fromCodecs()`\n* `fromProviders()`\n* `fromRegistries()` The following code snippet shows how to construct a `CodecRegistry` using the `fromCodecs()` method: ```java CodecRegistry codecRegistry = CodecRegistries.fromCodecs(new IntegerCodec(), new PowerStatusCodec()); \n``` In the preceding example, we assign the `CodecRegistry` the following `Codec`implementations: * `IntegerCodec`, a `Codec` that converts `Integers` and is part of the BSON package.\n* [PowerStatusCodec](#std-label-codecs-powerstatus-codec), our sample `Codec`that converts certain Java strings to BSON booleans. You can retrieve the `Codec` instances from the `CodecRegistry` instance from the prior example using the following code: ```java Codec<String> powerStatusCodec = codecRegistry.get(String.class); Codec<Integer> integerCodec = codecRegistry.get(Integer.class); \n``` If you attempt to retrieve a `Codec` instance for a class that is not registered, the `get()` method throws a `CodecConfigurationException`exception. For more information about the classes and interfaces in this section, see the following API Documentation: * [CodecRegistries](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/configuration/CodecRegistries.html)\n* [IntegerCodec](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/IntegerCodec.html) ## CodecProvider A `CodecProvider` is an interface that contains abstract methods that create`Codec` instances and assign them to a `CodecRegistry` instance. Similar to the `CodecRegistry`, the BSON library uses the `Codec` instances retrieved by the `get()` method to convert between Java and BSON data types. However, in cases in which you add a class that contains fields that require corresponding `Codec` objects, you need to ensure that you instantiate the`Codec` objects for the class' fields before you instantiate the`Codec` for the class. You can use the `CodecRegistry` parameter in the `get()` method to pass any of the `Codec` instances that the`Codec` relies on. The following code example shows how you can implement `CodecProvider` to pass the `MonolightCodec` any `Codec` instances it needs in a`CodecRegistry` instance such as the `PowerStatusCodec` from our prior example: ```java public class MonolightCodecProvider implements CodecProvider {     public MonolightCodecProvider() {}     @Override     @SuppressWarnings(\"unchecked\")     public <T> Codec<T> get(Class<T> clazz, CodecRegistry registry) {         if (clazz == Monolight.class) {             return (Codec<T>) new MonolightCodec(registry);         }         // return null when not a provider for the requested class         return null;     } } \n``` To see a runnable example that demonstrates read and write operations using these `Codec` classes, see the [Custom Codec Example](#std-label-codecs-custom-example)section of this guide. When working with POJOs, consider using the `PojoCodecProvider` to minimize duplicate code to convert commonly-used data types and customize their behavior. See our[POJO Customization guide](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/)for more information. ### Default Codec Registry\n\n If you need to override the behavior of one or more `Codec` classes, but keep the behavior from the default codec registry for the other classes, you can specify all of the registries in order of precedence. For example, suppose you wanted to override the default provider behavior of a `Codec` for enum types with your custom `MyEnumCodec`, you must add it to the registry list prior to the default codec registry as shown in the example below: ```java CodecRegistry newRegistry = CodecRegistries.fromRegistries(     CodecRegistries.fromCodecs(new MyEnumCodec()),     MongoClientSettings.getDefaultCodecRegistry()); \n``` For more information about the classes and interfaces in this section, see the following API documentation sections: * [CodecProvider](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/configuration/CodecProvider.html)\n* [Default codec registry](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html#getDefaultCodecRegistry%28%29) ## BsonTypeClassMap The `BsonTypeClassMap` class contains a recommended mapping between BSON and Java types. You can use this class in your custom `Codec` or`CodecProvider` to help you manage which Java types to decode your BSON types to container classes that implement `Iterable` or `Map` such as the `Document` class. You can add or modify the `BsonTypeClassMap` default mapping by passing a`Map` containing new or replacement entries. The following code snippet shows how you can retrieve the Java class type that corresponds to the BSON type in the default `BsonTypeClassMap`instance: ```java BsonTypeClassMap bsonTypeClassMap = new BsonTypeClassMap(); Class<?> clazz = bsonTypeClassMap.get(BsonType.ARRAY); System.out.println(\"Java type: \" + clazz.getName()); \n``` This code outputs the following: ``` Java type: java.util.List \n``` You can modify these mappings in your instance by specifying replacements in the`BsonTypeClassMap` constructor. The following code snippet shows how you can replace the mapping for `ARRAY` in your `BsonTypeClassMap`instance with the `Set` class: ```java Map<BsonType, Class<?>> replacements = new HashMap<BsonType, Class<?>>(); replacements.put(BsonType.ARRAY, Set.class); BsonTypeClassMap bsonTypeClassMap = new BsonTypeClassMap(replacements); Class<?> clazz = bsonTypeClassMap.get(BsonType.ARRAY); System.out.println(\"Java type: \" + clazz.getName()); \n``` This code outputs the following: ``` Java type: java.util.Set \n``` For a complete list of the default mappings, refer to the[BsonTypeClassMap](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/BsonTypeClassMap.html) API Documentation. For an example of how the `Document` class uses `BsonTypeClassMap`, see the driver source code for the following classes: * [DocumentCodecProvider](https://github.com/mongodb/mongo-java-driver/blob/master/bson/src/main/org/bson/codecs/DocumentCodecProvider.java)\n* [DocumentCodec](https://github.com/mongodb/mongo-java-driver/blob/master/bson/src/main/org/bson/codecs/DocumentCodec.java) ## Custom Codec Example In this section, we show how you can implement `Codec` and `CodecProvider`to define the encoding and decoding logic for a custom Java class. We also show how you can specify and use your custom implementations to perform insert and retrieve operations. The following code snippet shows our example custom class called `Monolight`and its fields that we want to store and retrieve from a MongoDB collection: ```java public class Monolight {     private PowerStatus powerStatus = PowerStatus.OFF;\n\n     public Monolight() {}     // ... \n``` This class contains the following fields, each of which we need to assign a`Codec`: * `powerStatus` describes whether the light is switched \"on\" or \"off\" for which we use the [PowerStatusCodec](#std-label-codecs-powerstatus-codec) that converts specific enum values to BSON booleans.\n* `colorTemperature` describes the color of the light and contains an`Integer` value for which we use the `IntegerCodec` included in the BSON library. The following code example shows how we can implement a `Codec` for the`Monolight` class. Note that the constructor expects an instance of`CodecRegistry` from which it retrieves the `Codec` instances it needs to encode and decode its fields: ```java public class MonolightCodec implements Codec<Monolight>{     private Codec<PowerStatus> powerStatusCodec;     private Codec<Integer> integerCodec;     public MonolightCodec(CodecRegistry registry) {         this.powerStatusCodec = registry.get(PowerStatus.class);         this.integerCodec = registry.get(Integer.class);     }     @Override     public void encode(BsonWriter writer, Monolight value, EncoderContext encoderContext) {         writer.writeStartDocument();         writer.writeName(\"powerStatus\");         powerStatusCodec.encode(writer, value.getPowerStatus(), encoderContext);         writer.writeName(\"colorTemperature\");         integerCodec.encode(writer, value.getColorTemperature(), encoderContext);         writer.writeEndDocument();     }     @Override     public Monolight decode(BsonReader reader, DecoderContext decoderContext) {         Monolight monolight = new Monolight();         reader.readStartDocument();         while (reader.readBsonType() != BsonType.END_OF_DOCUMENT) {             String fieldName = reader.readName();             if (fieldName.equals(\"powerStatus\")) {                 monolight.setPowerStatus(powerStatusCodec.decode(reader, decoderContext));             } else if (fieldName.equals(\"colorTemperature\")) {                 monolight.setColorTemperature(integerCodec.decode(reader, decoderContext));             } else if (fieldName.equals(\"_id\")){                 reader.readObjectId();             }         }         reader.readEndDocument();         return monolight;     }     @Override     public Class<Monolight> getEncoderClass() {         return Monolight.class;     } } \n``` To ensure we make the `Codec` instances for the fields available for`Monolight`, we implement a custom `CodecProvider` shown in the following code example: ```java public class MonolightCodecProvider implements CodecProvider {     public MonolightCodecProvider() {}     @Override     @SuppressWarnings(\"unchecked\")     public <T> Codec<T> get(Class<T> clazz, CodecRegistry registry) {         if (clazz == Monolight.class) {             return (Codec<T>) new MonolightCodec(registry);         }         // return null when not a provider for the requested class         return null;     }\n\n \n``` After defining the conversion logic, we can perform the following: * Store data from instances of `Monolight` into MongoDB\n* Retrieve data from MongoDB into instances of `Monolight` The following example class contains code that assigns the`MonolightCodecProvider` to the `MongoCollection` instance by passing it to the `withCodecRegistry()` method. The example class also inserts and retrieves data using the `Monolight` class and associated codecs: ```java public class MonolightCodecExample {     public static void main(String[] args) {         String uri = \"<MongoDB connection URI>\";         try (MongoClient mongoClient = MongoClients.create(uri)) {             CodecRegistry codecRegistry = CodecRegistries.fromRegistries(                     CodecRegistries.fromCodecs(new IntegerCodec(), new PowerStatusCodec()),                     CodecRegistries.fromProviders(new MonolightCodecProvider()),                     MongoClientSettings.getDefaultCodecRegistry());             MongoDatabase database = mongoClient.getDatabase(\"codecs_example_products\");             MongoCollection<Monolight> collection = database.getCollection(\"monolights\", Monolight.class).withCodecRegistry(codecRegistry);             // construct and insert an instance of Monolight             Monolight myMonolight = new Monolight();             myMonolight.setPowerStatus(PowerStatus.ON);             myMonolight.setColorTemperature(5200);             collection.insertOne(myMonolight);             // retrieve one or more instances of Monolight             List<Monolight> lights = new ArrayList<>();             collection.find().into(lights);             System.out.println(lights);         }     } } \n``` If you run the preceding example, you should see the following output: ``` [Monolight [powerStatus=ON, colorTemperature=5200]] \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [withCodecRegistry()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#withCodecRegistry%28org.bson.codecs.configuration.CodecRegistry%29)\n* [MongoClientSettings.getDefaultCodecRegistry()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html#getDefaultCodecRegistry%28%29)\n* [Codec](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/Codec.html)\n* [CodecProvider](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/configuration/CodecProvider.html) ← [POJO Customization](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/ \"Previous Section\")[CRUD Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/documents/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Documents On this page * [Overview](#overview)\n* [Document](#document)\n* [BsonDocument](#bsondocument)\n* [JsonObject](#jsonobject)\n* [BasicDBObject](#basicdbobject)\n* [Summary](#summary) ## Overview In this guide, you can learn how to use **documents** in the MongoDB Java Driver. A MongoDB document is a data structure that contains key/value fields in binary JSON (BSON) format. You can use documents and the data they contain in their fields to store data as well as issue commands or queries in MongoDB. For more information on the terminology, structure, and limitations of documents, read our page on [Documents](https://www.mongodb.com/docs/manual/core/document/) in the MongoDB manual. The MongoDB Java driver and BSON library include the following classes that help you access and manipulate the BSON data in documents: | Name          | Package       | Implements Map                         | Recommended Usage                                                     |\n| ------------- | ------------- | -------------------------------------- | --------------------------------------------------------------------- |\n| Document      | org.bson      | Yes, implements Map<String, Object>    | When you want a flexible and concise data representation.             |\n| BsonDocument  | org.bson      | Yes, implements Map<String, BsonValue> | When you need a type-safe API.                                        |\n| JsonObject    | org.bson.json | No                                     | When you only want to work with JSON strings.                         |\n| BasicDBObject | com.mongodb   | No                                     | When you are migrating your application from a legacy driver version. | While you can use any of these classes in your application, we recommend that you use the `Document` class since it can concisely represent dynamically structured documents of any complexity. It implements the`Map<String, Object>` interface which enables it to use loosely-typed values. ## Document The `Document` class offers a flexible representation of a BSON document. You can access and manipulate fields using Java types from the standard library with this class. See the following table for mappings between frequently-used BSON and Java types:\n\n The preceding mapping table shows the default mapping when working with the`Document` class. You can customize the type mapping by specifying a custom codec. For more information on customizing mapped types, see our guide on using [Codecs.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/) In the following code snippet, we show how to instantiate and build a sample`Document` instance representing a document containing several different field types: `| Document author = new Document(\"_id\", new ObjectId())                                                         |\n| ------------------------------------------------------------------------------------------------------------- |\n| .append(\"name\", \"Gabriel García Márquez\")                                                                     |\n| .append(\"dateOfDeath\", Date.from(LocalDate.of(2014, 4, 17).atStartOfDay(ZoneId.systemDefault()).toInstant())) |\n| .append(\"novels\", Arrays.asList(                                                                              |\n| new Document(\"title\", \"One Hundred Years of Solitude\").append(\"yearPublished\", 1967),                         |\n| new Document(\"title\", \"Chronicle of a Death Foretold\").append(\"yearPublished\", 1981),                         |\n| new Document(\"title\", \"Love in the Time of Cholera\").append(\"yearPublished\", 1985)));                         | ` To insert this document into a collection, instantiate a collection using the `getCollection()` method and call the [insertOne](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertOne/) operation as follows: ```java // MongoClient mongoClient = <code to instantiate your client>; MongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\"); MongoCollection<Document> collection = database.getCollection(\"authors\"); InsertOneResult result = collection.insertOne(author); \n``` Once you perform a successful insert, you can retrieve the sample document data from the collection using the following code: ```java import com.mongodb.client.model.Filters; // <MongoCollection setup code here> Document doc = collection.find(Filters.eq(\"name\", \"Gabriel García Márquez\")).first(); if (doc != null) {     System.out.println(\"_id: \" + doc.getObjectId(\"_id\")         + \", name: \" + doc.getString(\"name\")         + \", dateOfDeath: \" + doc.getDate(\"dateOfDeath\"));     doc.getList(\"novels\", Document.class).forEach((novel) -> {         System.out.println(\"title: \" + novel.getString(\"title\")             + \", yearPublished: \" + novel.getInteger(\"yearPublished\"));         }); } \n``` ## Tip The preceding code sample uses helper methods that check the returned type and throw an exception if it is unable to cast the field value. You can call the `get()` method specified by the `Map` interface to retrieve field values as type `Object` and to skip type checking. The output should look something like this: ```\n\n title: One Hundred Years of Solitude, yearPublished: 1967 title: Chronicle of a Death Foretold, yearPublished: 1981 title: Love in the Time of Cholera, yearPublished: 1985 \n``` For more information on retrieving and manipulating MongoDB data, see our[CRUD guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/) For more information about the methods and classes mentioned in this section, see the following API Documentation: * [Document](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/Document.html)\n* [getCollection()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#getCollection%28java.lang.String%29)\n* [get()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/Document.html#get%28java.lang.Object%29) ## BsonDocument The `BsonDocument` class provides a type-safe API to access and manipulate a BSON document. You need to specify the BSON type from the Java BSON library for each field. See the following table for mappings between frequently-used BSON and Java BSON library types: | BSON type         | Java BSON library type |\n| ----------------- | ---------------------- |\n| Array             | org.bson.BsonArray     |\n| Binary            | org.bson.BsonBinary    |\n| Boolean           | org.bson.Boolean       |\n| Date (long value) | org.bson.BsonDateTime  |\n| Document          | org.bson.BsonDocument  |\n| Double            | org.bson.BsonDouble    |\n| Int32             | org.bson.BsonInt32     |\n| Int64             | org.bson.BsonInt64     |\n| Null              | org.bson.BsonNull      |\n| ObjectId          | org.bson.BsonObjectId  |\n| String            | org.bson.BsonString    | In the following code snippet, we show how to instantiate and build a sample`BsonDocument` instance representing a document containing several different field types: ```java BsonDocument author = new BsonDocument()     .append(\"_id\", new BsonObjectId())     .append(\"name\", new BsonString(\"Gabriel García Márquez\"))     .append(\"dateOfDeath\", new BsonDateTime(LocalDate.of(2014, 4, 17).atStartOfDay(ZoneId.systemDefault()).toInstant().toEpochMilli()))     .append(\"novels\", new BsonArray(Arrays.asList(         new BsonDocument().append(\"title\", new BsonString(\"One Hundred Years of Solitude\")).append(\"yearPublished\", new BsonInt32(1967)),         new BsonDocument().append(\"title\", new BsonString(\"Chronicle of a Death Foretold\")).append(\"yearPublished\", new BsonInt32(1981)),         new BsonDocument().append(\"title\", new BsonString(\"Love in the Time of Cholera\")).append(\"yearPublished\", new BsonInt32(1985))    ))); \n```\n\n ```java // MongoClient mongoClient = <code to instantiate your client>; MongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\"); MongoCollection<BsonDocument> collection = database.getCollection(\"authors\", BsonDocument.class); InsertOneResult result = collection.insertOne(author); \n``` Once you perform a successful insert, you can retrieve the sample document data from the collection using the following code: ```java import com.mongodb.client.model.Filters; // <MongoCollection setup code here> BsonDocument doc = collection.find(Filters.eq(\"name\", \"Gabriel García Márquez\")).first(); if (doc != null) {     System.out.println(\"_id: \" + doc.getObjectId(\"_id\").getValue()             + \", name: \" + doc.getString(\"name\").getValue()             + \", dateOfDeath: \" + new Date(doc.getDateTime(\"dateOfDeath\").getValue()));     doc.getArray(\"novels\").forEach((novel) -> {         System.out.println(\"title: \" + novel.asDocument().getString(\"title\").getValue()                 + \", yearPublished: \" + novel.asDocument().getInt32(\"yearPublished\").getValue());     }); } \n``` ## Tip The preceding code sample uses helper methods that check the returned type and throw a `BsonInvalidOperationException` if it is unable to cast the field value. You can call the `get()` method specified by the`Map` interface to retrieve field values as type `BsonValue` and to skip type checking. The output should look something like this: ``` _id: 5fb5fad05f734e3794741a35, name: Gabriel García Márquez, dateOfDeath: Thu Apr 17 00:00:00 EDT 2014 title: One Hundred Years of Solitude, yearPublished: 1967 title: Chronicle of a Death Foretold, yearPublished: 1981 title: Love in the Time of Cholera, yearPublished: 1985 \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [BsonDocument](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/BsonDocument.html)\n* [getCollection()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#getCollection%28java.lang.String%29)\n* [BsonInvalidOperationException](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/BsonInvalidOperationException.html)\n* [get()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/BsonDocument.html#get%28java.lang.Object%29)\n* [BsonValue](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/BsonValue.html) ## JsonObject The `JsonObject` class acts as a wrapper for JSON strings. If you only want to work with JSON data, you can use `JsonObject`to avoid unnecessary data conversion to a `Map` object.\n\n In the following code snippet, we show how to instantiate a sample `JsonObject`instance wrapping an Extended JSON string containing different types of key value pairs: ```java String ejsonStr = \"{\\\"_id\\\": {\\\"$oid\\\": \\\"6035210f35bd203721c3eab8\\\"},\"         + \"\\\"name\\\": \\\"Gabriel Garc\\\\u00eda M\\\\u00e1rquez\\\",\"         + \"\\\"dateOfDeath\\\": {\\\"$date\\\": \\\"2014-04-17T04:00:00Z\\\"},\"         + \"\\\"novels\\\": [\"         + \"{\\\"title\\\": \\\"One Hundred Years of Solitude\\\",\\\"yearPublished\\\": 1967},\"         + \"{\\\"title\\\": \\\"Chronicle of a Death Foretold\\\",\\\"yearPublished\\\": 1981},\"         + \"{\\\"title\\\": \\\"Love in the Time of Cholera\\\",\\\"yearPublished\\\": 1985}]}\"; JsonObject author = new JsonObject(ejsonStr); \n``` To insert this document into a collection, instantiate a collection using the `getCollection()` method specifying the `JsonObject` class as the `documentClass` parameter. Then, call the[insertOne](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertOne/) operation as follows: ```java // MongoClient mongoClient = <code to instantiate your client>; MongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\"); MongoCollection<JsonObject> collection = database.getCollection(\"authors\", JsonObject.class); InsertOneResult result = collection.insertOne(author); \n``` Once you perform a successful insert, you can retrieve the sample JSON data from the collection. While you can use any class that extends `Bson` to specify your query, here is how to query your data using a `JsonObject`: ```java // MongoClient mongoClient = <code to instantiate your client>; JsonObject query = new JsonObject(\"{\\\"name\\\": \\\"Gabriel Garc\\\\u00eda M\\\\u00e1rquez\\\"}\"); JsonObject jsonResult = collection.find(query).first(); if (jsonResult != null) {     System.out.println(\"query result in extended json format: \" + jsonResult.getJson()); } \n``` The output should look something like this: ``` query result in extended json format: {\"_id\": {\"$oid\": \"6035210f35bd203721c3eab8\"}, \"name\": \"Gabriel García Márquez\", \"dateOfDeath\": {\"$date\": \"2014-04-17T04:00:00Z\"}, \"novels\": [{\"title\": \"One Hundred Years of Solitude\", \"yearPublished\": 1967}, {\"title\": \"Chronicle of a Death Foretold\", \"yearPublished\": 1981}, {\"title\": \"Love in the Time of Cholera\", \"yearPublished\": 1985}]} \n``` ## Tip If you would like to work with other formats of JSON strings in your application, you can use the `JsonObjectCodec` class along with `JsonWriterSettings` to specify your desired JSON format. The following code example reads and writes to our MongoDB instance using[Relaxed mode JSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/)strings and outputs `ObjectId` instances as hex strings: ```java import static org.bson.codecs.configuration.CodecRegistries.fromCodecs; // MongoClient mongoClient = <code to instantiate your client>; MongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\"); MongoCollection<JsonObject> collection = database.getCollection(\"authors\", JsonObject.class)         .withCodecRegistry(                 fromCodecs(                         // define a JsonObjectCodec with a JsonWriterSettings in Relaxed mode                         new JsonObjectCodec(JsonWriterSettings\n\n                                 .outputMode(JsonMode.RELAXED)                                 .objectIdConverter((objectId, strictJsonWriter) -> {                                     strictJsonWriter.writeString(objectId.toHexString());                                 })                                 .build()))); JsonObject author = new JsonObject(\"{\\\"_id\\\": \\\"6035210f35bd203721c3eab8\\\", \"         + \"\\\"name\\\": \\\"Gabriel García Márquez\\\", \"         + \"\\\"dateOfDeath\\\": {\\\"$date\\\": \\\"2014-04-17T04:00:00Z\\\"}, \"         + \"\\\"novels\\\": [{\\\"title\\\": \\\"One Hundred Years of Solitude\\\", \\\"yearPublished\\\": 1967}, {\\\"title\\\": \\\"Chronicle of a Death Foretold\\\", \\\"yearPublished\\\": 1981}, \"         + \"{\\\"title\\\": \\\"Love in the Time of Cholera\\\", \\\"yearPublished\\\": 1985}]}\\n\"); collection.insertOne(author); JsonObject query = new JsonObject(\"{\\\"name\\\": \\\"Gabriel Garc\\\\u00eda M\\\\u00e1rquez\\\"}\"); JsonObject jsonResult = collection.find(query).first(); if (jsonResult != null) {     System.out.println(\"query result in relaxed json format: \" + jsonResult.getJson()); } \n``` The output of this code should look something like this: ``` query result in relaxed json format: {\"_id\": \"6035210f35bd203721c3eab8\", \"name\": \"Gabriel García Márquez\", \"dateOfDeath\": {\"$date\": \"2014-04-17T04:00:00Z\"}, \"novels\": [{\"title\": \"One Hundred Years of Solitude\", \"yearPublished\": 1967}, {\"title\": \"Chronicle of a Death Foretold\", \"yearPublished\": 1981}, {\"title\": \"Love in the Time of Cholera\", \"yearPublished\": 1985}]} \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [JsonObject](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/JsonObject.html)\n* [JsonObjectCodec](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/JsonObjectCodec.html)\n* [JsonWriterSettings](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/JsonWriterSettings.html)\n* [getCollection()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoDatabase.html#getCollection%28java.lang.String,java.lang.Class%29) ## BasicDBObject The `BasicDBObject` class allows you to access and manipulate document data using Java types. We recommend that you avoid using this class unless you are migrating an application from an older driver version because of the following limitations:\n\n In the following code snippet, we show how to instantiate and build a sample`BasicDBObject` instance representing a document containing several different field types: ```java BasicDBObject author = new BasicDBObject(\"_id\", new ObjectId())     .append(\"name\", \"Gabriel García Márquez\")     .append(\"dateOfDeath\", Date.from(LocalDate.of(2014, 4, 17).atStartOfDay(ZoneId.systemDefault()).toInstant()))     .append(\"novels\", Arrays.asList(         new BasicDBObject(\"title\", \"One Hundred Years of Solitude\").append(\"yearPublished\", 1967),         new BasicDBObject(\"title\", \"Chronicle of a Death Foretold\").append(\"yearPublished\", 1981),         new BasicDBObject(\"title\", \"Love in the Time of Cholera\").append(\"yearPublished\", 1985))); \n``` To insert this document into a collection, instantiate a collection using the `getCollection()` method specifying the `BasicDBObject` class as the `documentClass` parameter. Then, call the[insertOne](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertOne/) operation as follows: ```java // MongoClient mongoClient = <code to instantiate your client>; MongoDatabase database = mongoClient.getDatabase(\"fundamentals_data\"); MongoCollection<BasicDBObject> collection = database.getCollection(\"authors\", BasicDBObject.class); InsertOneResult result = collection.insertOne(author); \n``` Once you perform a successful insert, you can retrieve the sample document data from the collection using the following code: ```java import com.mongodb.client.model.Filters; // <MongoCollection setup code here> BasicDBObject doc = collection.find(Filters.eq(\"name\", \"Gabriel García Márquez\")).first(); if (doc != null) {     System.out.println(\"_id: \" + doc.getObjectId(\"_id\")         + \", name: \" + doc.getString(\"name\")         + \", dateOfDeath: \" + doc.getDate(\"dateOfDeath\"));     BasicDBList novels = (BasicDBList) doc.get(\"novels\");     if (novels != null) {         BasicDBObject[] novelArr = novels.toArray(new BasicDBObject[0]);         for (BasicDBObject novel : novelArr) {             System.out.println(\"title: \" + novel.getString(\"title\")             + \", yearPublished: \" + novel.getInt(\"yearPublished\"));         }     } } \n``` ## Tip The preceding code sample uses helper methods that check the returned type and throw an exception if it is unable to cast the field value. You can call the `get()` method to retrieve values as type`Object` and to skip type checking. The output should look something like this: ``` _id: 5fb5fad05f734e3794741a35, name: Gabriel García Márquez, dateOfDeath: Thu Apr 17 00:00:00 EDT 2014 title: One Hundred Years of Solitude, yearPublished: 1967 title: Chronicle of a Death Foretold, yearPublished: 1981 title: Love in the Time of Cholera, yearPublished: 1985 \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation:\n\n ## Summary In this guide, we covered the following topics on classes you can use to work with BSON data: * Described four Java classes you can use to work with MongoDB documents and why you might prefer one over the other.\n* Provided usage examples for each class on building documents containing multiple types, inserting them into a collection, and retrieving/accessing their typed fields. ← [Document Data Format: Extended JSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-extended-json/ \"Previous Section\")[Document Data Format: POJOs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Document Data Format: POJOs On this page * [Overview](#overview)\n* [Example POJO](#example-pojo)\n* [Configure the Driver for POJOs](#configure-the-driver-for-pojos)\n* [Summary](#summary) ## Overview In this guide, you can learn how to store and retrieve data in the MongoDB Java driver using plain old Java objects ([POJOs](https://en.wikipedia.org/wiki/Plain%5Fold%5FJava%5Fobject)). POJOs are often used for data encapsulation, separating business logic from data representation. The example in this guide shows how to perform the following: * Configure the driver to serialize and deserialize POJOs\n* How to read and write to documents using POJOs ## Example POJO To follow the steps in this guide, use the following sample POJO class which describes characteristics of a flower:\n\n ` If you are creating your own POJO for storing and retrieving data in MongoDB, make sure to follow these guidelines: * The POJO class should not implement interfaces or extend classes from a framework.\n* Include all the fields for which you want to store and retrieve data; make sure they are not `static` or `transient`.\n* If you include public getter or setter methods using the[JavaBean naming conventions](https://docs.oracle.com/javase/tutorial/javabeans/writing/properties.html)in your POJO, the driver calls them when serializing or deserializing data. If you omit the getter or setter methods for a public property field, the driver accesses or assigns them directly. ## Configure the Driver for POJOs To set up the driver to store and retrieve POJOs, we need to specify: * The `PojoCodecProvider`, a codec provider that includes[Codecs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/) that define how to encode/decode the data between the POJO and MongoDB document, and which POJO classes or packages that the codecs should apply to.\n* A `CodecRegistry` instance that contains the codecs and other related information.\n* A `MongoDatabase` or `MongoCollection` instance configured to use the`CodecRegistry`.\n* A `MongoCollection` instance created with the POJO document class bound to the `TDocument` generic type. Consult the following steps to see how to perform each of the configuration requirements:\n\n Once you have configured the preceding `MongoCollection` instance, you can perform the following [CRUD operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/#std-label-java-crud-operations)with the POJOs: * Create a document from a POJO\n* Retrieve data in a POJO instance The following code snippet shows how you can insert an instance of `Flower` into the collection and then retrieve it as a `List` of your POJO class objects: ```java Flower flower = new Flower(\"rose\", false, 25.4f, Arrays.asList(new String[] {\"red\", \"green\"})); // insert the instance collection.insertOne(flower); // return all documents in the collection List<Flower> flowers = new ArrayList<>(); collection.find().into(flowers); System.out.println(flowers); \n``` When you run this code, your output should look something like this: ``` [Flower [id=5f7f87659ed5b07cf3480a06, name=rose, colors=[green, red], isBlooming=false, height=25.4]] \n``` ## Note By default, the `PojoCodecProvider` omits fields in your POJO that are set to `null`. For more information on how to specify this behavior, see the guide on [POJO Customization.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/) For more information about the methods and classes mentioned in this section, see the following API documentation: * [CodecRegistry](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/configuration/CodecRegistry.html)\n* [TDocument](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html)\n* [PojoCodecProvider](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/PojoCodecProvider.html)\n* [automatic(true)](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/PojoCodecProvider.Builder.html#automatic%28boolean%29)\n* [PojoCodecProvider.Builder](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/PojoCodecProvider.Builder.html)\n* [fromRegistries()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/configuration/CodecRegistries.html#fromRegistries%28org.bson.codecs.configuration.CodecRegistry...%29)\n* [getDefaultCodecRegistry()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html?is-external=true#getDefaultCodecRegistry%28%29)\n* [fromProviders()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/configuration/CodecRegistries.html#fromProviders%28org.bson.codecs.configuration.CodecProvider...%29) ## Summary In this guide, we explained how to convert data between BSON and POJO fields by performing the following:\n\n ← [Documents](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/documents/ \"Previous Section\")[Document Data Format: Records](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-record/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-extended-json/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Document Data Format: Extended JSON On this page * [Overview](#overview)\n* [Extended JSON Formats](#extended-json-formats)\n* [Extended JSON Examples](#extended-json-examples)\n* [Read Extended JSON](#read-extended-json)\n* [Using the Document Classes](#using-the-document-classes)\n* [Using the BSON Library](#using-the-bson-library)\n* [Write Extended JSON](#write-extended-json)\n* [Using the Document Classes](#using-the-document-classes-1)\n* [Using the BSON Library](#using-the-bson-library-1)\n* [Custom BSON Type Conversion](#custom-bson-type-conversion) ## Overview In this guide, you can learn how to use the Extended JSON format in the MongoDB Java driver. JSON is a data format that represents the values of objects, arrays, numbers, strings, booleans, and nulls. The **Extended JSON** format defines a reserved set of keys prefixed with \"`$`\" to represent field type information that directly corresponds to each type in BSON, the format that MongoDB uses to store data. This guide explains the following topics: * The different MongoDB Extended JSON formats\n* How to use the BSON library to convert between Extended JSON and Java objects\n* How to create a custom conversion of BSON types For more information on the difference between these formats, see our[article on JSON and BSON.](https://www.mongodb.com/json-and-bson) ## Extended JSON Formats MongoDB Extended JSON features different string formats to represent BSON data. Each of the different formats conform to the JSON RFC and meet specific use cases. The **extended** format, also known as the**canonical** format, features specific representations for every BSON type for bidirectional conversion without loss of information. The **Relaxed mode**format is more concise and closer to ordinary JSON, but does not represent all the type information such as the specific byte size of number fields. See the following table to see a description of each format:\n\n ## Note The driver parses the `$uuid` Extended JSON type from a string to a`BsonBinary` object of binary subtype 4\\. For more information about `$uuid` field parsing, see the[special rules for parsing $uuid fields](https://github.com/mongodb/specifications/blob/master/source/extended-json.rst#special-rules-for-parsing-uuid-fields)section in the extended JSON specification. For more detailed information on these formats, see the following resources: * [JSON RFC](https://tools.ietf.org/html/rfc7159) Official Documentation\n* [MongoDB Extended JSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/) Server Manual Entry\n* [BsonBinary](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/BsonBinary.html) API Documentation\n* [Extended JSON specification](https://github.com/mongodb/specifications/blob/master/source/extended-json.rst) GitHub Documentation ### Extended JSON Examples The following examples show a document containing an ObjectId, date, and long number field represented in each Extended JSON format. Click the tab that corresponds to the format of the example you want to see: ## Read Extended JSON ### Using the Document Classes You can read an Extended JSON string into a Java document object by calling the `parse()` static method from either the `Document` or `BsonDocument`class, depending on which object type you need. This method parses the Extended JSON string in any of the formats and returns an instance of that class containing the data. The following example shows how you can use the `Document` class to read an example Extended JSON string into a `Document` object using the`parse()` method: `| String ejsonStr = \"{ \\\"_id\\\": { \\\"$oid\\\": \\\"507f1f77bcf86cd799439011\\\"},\" + |\n| --------------------------------------------------------------------------- |\n| \"\\\"myNumber\\\": {\\\"$numberLong\\\": \\\"4794261\\\" }}}\";                          |\n| Document doc = Document.parse(ejsonStr);                                    |\n| System.out.println(doc);                                                    | ` The output of the preceding code should look something like this: ``` Document{{_id=507f1f77bcf86cd799439011, myNumber=4794261}} \n``` For more information, see our Fundamentals page on [Documents.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/documents/) ### Using the BSON Library You can also read an Extended JSON string into Java objects without using the MongoDB Java driver's document classes by using the `JsonReader` class. This class contains methods to sequentially parse the fields and values in any format of the Extended JSON string, and returns them as Java objects. The driver's document classes also use this class to parse Extended JSON. The following code example shows how you can use the `JsonReader` class to convert an Extended JSON string into Java objects: ```java String ejsonStr = \"{ \\\"_id\\\": { \\\"$oid\\\": \\\"507f1f77bcf86cd799439011\\\"},\" +                   \"\\\"myNumber\\\": {\\\"$numberLong\\\": \\\"4794261\\\" }}}\"; JsonReader jsonReader = new JsonReader(ejsonStr); jsonReader.readStartDocument(); jsonReader.readName(\"_id\"); ObjectId id = jsonReader.readObjectId(); jsonReader.readName(\"myNumber\"); Long myNumber = jsonReader.readInt64(); jsonReader.readEndDocument(); System.out.println(id + \" is type: \" + id.getClass().getName()); System.out.println(myNumber + \" is type: \" + myNumber.getClass().getName());\n\n \n``` The output of this code example should look something like this: ``` 507f1f77bcf86cd799439011 is type: org.bson.types.ObjectId 4794261 is type: java.lang.Long \n``` For more information, see the [JsonReader](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/JsonReader.html) API Documentation. ## Write Extended JSON ### Using the Document Classes You can write an Extended JSON string from an instance of `Document` or`BsonDocument` by calling the `toJson()` method, optionally passing it an instance of `JsonWriterSettings` to specify the Extended JSON format. In this example, we output the Extended JSON in the Relaxed mode format. ```java Document myDoc = new Document(); myDoc.append(\"_id\", new ObjectId(\"507f1f77bcf86cd799439012\")).append(\"myNumber\", 11223344); JsonWriterSettings settings = JsonWriterSettings.builder().outputMode(JsonMode.RELAXED).build(); System.out.println(doc.toJson(settings)); \n``` The output of this code example should look something like this: ``` {\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"myNumber\": 11223344} \n``` ### Using the BSON Library You can also output an Extended JSON string from data in Java objects using the BSON library with the `JsonWriter` class. To construct an instance of `JsonWriter`, pass a subclass of a Java `Writer` to specify how you want to output the Extended JSON. You can optionally pass a `JsonWriterSettings`instance to specify options such as the Extended JSON format. By default, the`JsonWriter` uses the Relaxed mode format. The MongoDB Java driver's document classes also use this class to convert BSON to Extended JSON. The following code example shows how you can use `JsonWriter` to create an Extended JSON string and output it to `System.out`. We specify the format by passing the `outputMode()` builder method the `JsonMode.EXTENDED` constant: ```java JsonWriterSettings settings = JsonWriterSettings.builder().outputMode(JsonMode.EXTENDED).build(); try (JsonWriter jsonWriter = new JsonWriter(new BufferedWriter(new OutputStreamWriter(System.out)), settings)) {     jsonWriter.writeStartDocument();     jsonWriter.writeObjectId(\"_id\", new ObjectId(\"507f1f77bcf86cd799439012\"));     jsonWriter.writeInt64(\"myNumber\", 11223344);     jsonWriter.writeEndDocument();     jsonWriter.flush(); } \n``` The output of this code example should look something like this: ``` {\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"myNumber\": {\"$numberLong\": \"11223344\"}} \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [JsonWriter](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/JsonWriter.html)\n* [JsonWriterSettings](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/JsonWriterSettings.html)\n* [outputMode()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/JsonWriterSettings.Builder.html#outputMode%28org.bson.json.JsonMode%29) ## Custom BSON Type Conversion In addition to specifying the `outputMode()` to format the JSON output, you can further customize the output by adding converters to your`JsonWriterSettings.Builder`. These converter methods detect the Java types and execute the logic defined by the `Converter` passed to them. The following sample code shows how to append converters, defined as lambda expressions, to simplify the Relaxed mode JSON output. ```java JsonWriterSettings settings = JsonWriterSettings.builder().outputMode(JsonMode.RELAXED)\n\n         .dateTimeConverter(                 (value, writer) -> {                     ZonedDateTime zonedDateTime = Instant.ofEpochMilli(value).atZone(ZoneOffset.UTC);                     writer.writeString(DateTimeFormatter.ISO_DATE_TIME.format(zonedDateTime));                 })         .build(); Document doc = new Document()      .append(\"_id\", new ObjectId(\"507f1f77bcf86cd799439012\"))      .append(\"createdAt\", Date.from(Instant.ofEpochMilli(1601499609000L)))      .append(\"myNumber\", 4794261); System.out.println(doc.toJson(settings))); \n``` The output of this code should look something like this: ``` {\"_id\": \"507f1f77bcf86cd799439012\", \"createdAt\": \"2020-09-30T21:00:09Z\", \"myNumber\": 4794261} \n``` Without specifying the converters, the Relaxed mode JSON output should look something like this: ``` {\"_id\": {\"$oid\": \"507f1f77bcf86cd799439012\"}, \"createdAt\": {\"$date\": \"2020-09-30T21:00:09Z\"}, \"myNumber\": 4794261} \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [Converter](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/Converter.html)\n* [JsonWriterSettings.Builder](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/json/JsonWriterSettings.Builder.html) ← [Document Data Format: BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/ \"Previous Section\")[Documents](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/documents/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/network-compression/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Network Compression You can enable a driver option to compress messages which reduces the amount of data passed over the network between MongoDB and your application. The driver supports the following algorithms: 1. [Snappy](https://google.github.io/snappy/): available in MongoDB 3.4 and later.\n2. [Zlib](https://zlib.net/): available in MongoDB 3.6 and later.\n3. [Zstandard](https://github.com/facebook/zstd/): available in MongoDB 4.2 and later. The driver tests against the following versions of these libraries: * `org.xerial.snappy:snappy-java:1.1.8.4`\n* `com.github.luben:zstd-jni:1.5.2-3` If you specify multiple compression algorithms, the driver selects the first one in the list supported by the MongoDB instance to which it is connected. ## Note Applications that require Snappy or Zstandard compression must[add explicit dependencies](#std-label-compression-dependencies) for those algorithms. ## Specify Compression Algorithms You can enable compression for the connection to your MongoDB instance by specifying the algorithms in one of two ways: adding the parameter to your connection string using `ConnectionString` or by calling the method in the`MongoClientSettings.Builder` class. ## Compression Algorithm Dependencies The JDK supports [Zlib](https://zlib.net/) compression natively, but[Snappy](https://google.github.io/snappy/) and[Zstandard](https://github.com/facebook/zstd/) depend on open source implementations. See[snappy-java](https://github.com/xerial/snappy-java) and[zstd-java](https://github.com/luben/zstd-jni) for details. ← [Specify MongoClient Settings](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/mongoclientsettings/ \"Previous Section\")[Enable TLS/SSL on a Connection](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/tls/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/pojo-customization/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # POJO Customization On this page * [Overview](#overview)\n* [Customize a PojoCodecProvider](#customize-a-pojocodecprovider)\n* [ClassModel](#classmodel)\n* [PropertyModel](#propertymodel)\n* [Conventions](#conventions)\n* [Annotations](#annotations)\n* [BsonExtraElements Example](#bsonextraelements-example)\n* [Discriminators](#discriminators)\n* [Advanced Configuration](#advanced-configuration)\n* [Abstract or Interface Types in Properties](#abstract-or-interface-types-in-properties)\n* [POJOs without No-Argument Constructors](#pojos-without-no-argument-constructors)\n* [Serialization Customization](#serialization-customization) ## Overview In this guide, you can learn how to define custom data conversions between BSON and POJOs in the MongoDB Java driver. In our guide on [POJOs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/), we show how to specify a `PojoCodecProvider` which contains classes that provide instructions on how to convert data for one or more POJO classes and their properties. We show how to specify your data conversion using the [ClassModel](#std-label-classmodel)and [PropertyModel](#std-label-property-model) classes. You can also learn about more specific customization from the section on [Advanced Configuration.](#std-label-pojo-advanced-configuration) We also show how to use helpers such as [Conventions](#std-label-conventions)and [Annotations](#std-label-annotations) to specify common serialization actions. See the section on [Discriminators](#std-label-pojo-discriminators) if you want to serialize multiple POJO classes to documents in the same collection. If you need to implement conditional serialization, or if you need to use enums, generics, interface types, or abstract types, see the section on[Advanced Configuration.](#std-label-pojo-advanced-configuration) If you only need to use the predefined behavior to convert data between BSON and POJOs, you can use the **automatic** setting for the`PojoCodecProvider` shown in the [Document Data Formats: POJOs guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-pojo/) ## Customize a PojoCodecProvider This section shows you how to specify your data conversion logic and POJO classes with a `PojoCodecProvider`. The `PojoCodecProvider` is an implementation of the `CodecProvider` interface that specifies the Codecs to use in data conversion. Use this implementation when performing data conversion between BSON and POJOs. You can create a `PojoCodecProvider` instance using the`PojoCodecProvider.builder()` method. You can also chain methods to the builder to register any of the following: * Individual POJO classes\n* Package names that contain POJO classes\n* Instances of `ClassModel` that describe conversion logic for a specific POJO class The following example shows how you can specify the POJOs in a package named \"org.example.pojos\" and add the `PojoCodecProvider` to a `CodecRegistry`:\n\n ` For more information on this class, see the [PojoCodecProvider.Builder](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/PojoCodecProvider.Builder.html)API Documentation. ### ClassModel A `ClassModel` instance stores data conversion information about a specific POJO class. It contains a list of `PropertyModel` instances which describe the property fields of the POJO, whether to convert fields, and optionally,`Codecs` to convert the fields. A `ClassModel` contains the following fields:\n\n For more information on this class, see the [ClassModel](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/ClassModel.html)API Documentation. To instantiate a `ClassModel`, use the `ClassModel.builder()` method and specify your POJO class. The builder uses reflection to create the required metadata. ```java ClassModel<Flower> classModel = ClassModel.builder(Flower.class).build(); \n``` ### PropertyModel A `PropertyModel` stores information on how to serialize/deserialize a specific field in a document. The `PropertyModel` contains the following information:\n\n To create a `PropertyModel` use a `PropertyModelBuilder` which you can instantiate by calling the `PropertyModel.builder()` method. For more information on this class, see the[PropertyModel.Builder](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/PropertyModelBuilder.html) API Documentation. ## Conventions The `Convention` interface contains configuration options that modify the behavior of a `ClassModel` or `PropertyModel`. You can specify a`Convention` in a call to `PojoCodecProvider.Builder.conventions()` or to`ClassModelBuilder.conventions()`. ## Note The builders apply `Convention` instances in order which may override behavior defined in one applied earlier. You can access the `Convention` instances defined in the BSON library from the following static fields in the `Conventions` class:\n\n You can specify Conventions using one of the following methods: * [PojoCodecProvider.Builder.conventions()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/PojoCodecProvider.Builder.html)\n* [ClassModelBuilder.conventions()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/ClassModelBuilder.html#conventions%28java.util.List%29) To create a custom Convention, create a class that implements the`Convention` interface and override the `apply()` method from which you can access your `ClassModelBuilder` instance. ## Annotations You can apply annotations to the getter and setter methods of a POJO class. These annotations configure the `ClassModel` and `PropertyModel`behavior for a specific field, method, or class. The following annotations are available from the[org.bson.codecs.pojo.annotations](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/annotations/package-summary.html)package:\n\n The following code snippet shows a sample POJO called `Product` that uses several of the preceding annotations. ```java import org.bson.BsonType; import org.bson.codecs.pojo.annotations.BsonCreator; import org.bson.codecs.pojo.annotations.BsonDiscriminator; import org.bson.codecs.pojo.annotations.BsonId; import org.bson.codecs.pojo.annotations.BsonIgnore; import org.bson.codecs.pojo.annotations.BsonProperty; import org.bson.codecs.pojo.annotations.BsonRepresentation; @BsonDiscriminator(value=\"AnnotatedProduct\", key=\"_cls\") public class Product {     @BsonProperty(\"modelName\")     private String name;     @BsonId()     @BsonRepresentation(BsonType.OBJECT_ID)     private String serialNumber;     @BsonIgnore     private List<Product> relatedItems;     @BsonCreator     public Product(@BsonProperty(\"modelName\") String name) {         this.name = name;     }     // ... } \n``` ## Tip When using annotations, remember to specify the`Conventions.ANNOTATION_CONVENTION` in your `ClassModelBuilder`or `PojoCodecProvider.Builder`. For example: ```java ClassModel<Product> classModel = ClassModel.builder(Product.class).        conventions(Arrays.asList(Conventions.ANNOTATION_CONVENTION)).build(); \n``` The annotations in the example POJO specify the following behavior: * Reference the POJO with the specified discriminator key and value, adding the `cls` field with the value of \"AnnotatedProduct\" to the BSON document on write operations\n* Convert between the POJO `name` field and value and the BSON `modelName`field and value in the document\n* Convert between the POJO `serialNumber` field and value the BSON document`_id` field and value in the document\n* Omit the `relatedItems` field and value when converting data\n* Use the `Product(String name)` constructor when instantiating the POJO ### BsonExtraElements Example The `@BsonExtraElements` annotation allows you to specify a field to deserialize data from a MongoDB document that lacks a corresponding POJO field mapping. This is useful when your application needs to work with data in a partially-defined schema. You can use this annotation to access data from any fields that do not correspond to the fields on your POJO. Consider a situation in which you store and retrieve data for an online store using the [Product POJO](#std-label-bson-annotation-code-example) from the previous example. As you offer a greater variety of products for the store, you discover that you need additional fields to describe them. Instead of mapping each additional field to the POJO, you can access them from a single field annotated with `@BsonExtraElements` as shown in the following code example: ```java public class Product {     @BsonProperty(\"modelName\")     private String name;     @BsonId()     @BsonRepresentation(BsonType.OBJECT_ID)     private String serialNumber;     @BsonIgnore     private List<Product> relatedItems;     @BsonExtraElements     private Document additionalInfo;     // ... \n``` Suppose someone added additional fields for `dimensions` and `weight` to the product data such that the documents contained the following information: ``` {   \"name\": \"MDB0123\",   \"serialNumber\": \"62e2...\",   \"dimensions\": \"3x4x5\",   \"weight\": \"256g\" } \n``` The preceding document retrieved using the `Product` POJO contains the following data: ``` ProductWithBsonExtraElements [   name=MDB0123,   serialNumber=62eb...,   relatedItems=null,   additionalInfo=Document{{dimensions=3x4x5, weight=256g}} ] \n``` ## Discriminators\n\n Use discriminators to instruct the `CodecProvider` which object class to use when deserializing to different object classes from the same collection. When serializing the POJO to a MongoDB collection, the associated codec sets the discriminator key-value field, unless otherwise specified in the POJO property data. You can set and enable a discriminator in a POJO by performing one of the following: * Use the `@BsonDiscriminator` annotation to specify the discriminator for the POJO class\n* Call `enableDiscriminator(true)` on the `ClassModelBuilder`associated with the POJO class See the following example POJO classes that contain `@BsonDiscriminator`annotations and example documents that contain the discriminator fields: ```java @BsonDiscriminator(value=\"AnonymousUser\", key=\"_cls\") public class AnonymousUser {     // class code } @BsonDiscriminator(value=\"RegisteredUser\", key=\"_cls\") public class RegisteredUser {     // class code } \n``` The following shows sample documents created from the preceding POJOs in a single MongoDB collection: ``` { \"_cls\": \"AnonymousUser\", \"_id\": ObjectId(\"<Object ID>\"),  ... } { \"_cls\": \"RegisteredUser\", \"_id\": ObjectId(\"<Object ID>\"), ... } \n``` ## Advanced Configuration ### Abstract or Interface Types in Properties To serialize a POJO that includes abstract class or interface type properties, you must specify discriminators on the type and all its subtypes or implementations. Suppose you defined a POJO that referenced an abstract class `User` in one of its fields as follows: ```java public class UserRecordPojo {      private User user;      // ... } \n``` If the `User` abstract class has subclasses `FreeUser` and`SubscriberUser`, you can add your POJO and abstract classes to your`CodecRegistry` as follows: ```java ClassModel<UserRecordPojo> userRecordPojo = ClassModel.builder(UserRecordPojo.class).enableDiscriminator(true).build(); ClassModel<User> userModel = ClassModel.builder(User.class).enableDiscriminator(true).build(); ClassModel<FreeUser> freeUserModel = ClassModel.builder(FreeUser.class).enableDiscriminator(true).build(); ClassModel<SubscriberUser> subscriberUserModel = ClassModel.builder(SubscriberUser.class).enableDiscriminator(true).build(); PojoCodecProvider pojoCodecProvider = PojoCodecProvider.builder().register(userRecordPojo, userModel, freeUserModel, subscriberUserModel).build(); CodecRegistry pojoCodecRegistry = fromRegistries(getDefaultCodecRegistry(), fromProviders(pojoCodecProvider)); \n``` For more information on specifying discriminators, see the section of this guide on [Discriminators.](#std-label-pojo-discriminators) ### POJOs without No-Argument Constructors The POJO `Codecs` default to calling the empty, no-argument constructor. To specify a different constructor, you must perform the following in your POJO: * pass the `ANNOTATION_CONVENTION` setting to your `ClassModelBuilder`\n* identify the constructor using the `BsonCreator` annotation For an example of setting the `ANNOTATION_CONVENTION`, see the[ANNOTATION\\_CONVENTION example](#std-label-bson-annotation-convention). For an example of the `BsonCreator` annotation, see the[POJO with annotation code example.](#std-label-bson-annotation-code-example) ### Serialization Customization By default, `ClassModelBuilder` attempts to serialize all the non-null properties in your POJO. If a property value is `null`, the default`PropertySerialization` implementation skips that field. You can customize your POJO serialization behavior by performing one of the following: * Use the `@BsonIgnore` annotation for a property to always skip serialization. Make sure to enable annotations using the appropriate[Conventions.](#std-label-conventions)\n* Create a custom class that overrides the `shouldSerialize()` method of the`PropertySerialization` interface. Specify your custom implementation to the `PropertyModelBuilder` which is accessible from the`ClassModelBuilder`.\n\n The following sample code shows a custom class that implements the`PropertySerialization` interface to override the default conditions by which to determine whether to serialize a field: ```java public class CourteousAgeSerialization implements PropertySerialization<Integer> {     @Override     public boolean shouldSerialize(Integer value) {         return (value < 30);     } } \n``` The preceding class specifies that any integer greater than 29 is not serialized, and, therefore, not included in the MongoDB document. Suppose you applied this custom serialization behavior to the following sample POJO: ```java public class BirthdayInvitation {     private String name;     private Integer age;     private LocalDateTime eventDateTime;     // ... } \n``` You can specify the custom serialization by adding the`CourteousAgeSerialization` instance to the `PropertyModelBuilder` from the `ClassModel` property associated with the `age` field using the following code: ```java ClassModelBuilder<BirthdayInvitation> classModel = ClassModel.builder(BirthdayInvitation.class); ((PropertyModelBuilder<Integer>) classModel.getProperty(\"age\"))         .propertySerialization(new CourteousAgeSerialization()); PojoCodecProvider pojoCodecProvider = PojoCodecProvider.builder().register(classModel.build()).build(); CodecRegistry pojoCodecRegistry = fromRegistries(getDefaultCodecRegistry(), fromProviders(pojoCodecProvider)); \n``` If you insert a POJO that contains a value greater than 29 in the `age`field, the serialized document omits it. The POJO declaration and resulting document could look something like this: ```java // constructor with parameters for name, age, and eventDateTime, respectively BirthdayInvitation invitation = new BirthdayInvitation(         \"Galadriel\",         7582,         LocalDateTime.of(2021, Month.JANUARY, 18, 30, 0)     ); \n``` Since the `age` field value is greater than 29, the serialized document should look something like this: ``` { \"_id\" : ObjectId(\"...\"), \"eventDateTime\" : ..., \"name\" : \"Galadriel\" } \n``` #### Generics Support You can use the POJO `Codec` to serialize classes that contain generic properties if they meet the following criteria: * Contain only bounded concrete type parameters\n* If it or any of its fields are part of a class hierarchy, the top-level POJO does not contain any type parameters The `ClassModelBuilder` inspects and saves concrete type parameters to work around type erasure. It cannot serialize classes that contain generic properties without concrete type parameters since the JVM removes the type parameter information. To save type parameters, you can implement the `PropertyCodecProvider`interface to specify them for generic types defined in a POJO. The following code snippets show an example implementation of the `PropertyCodecProvider`that adds serialization compatibility to the Guava `Optional` class. Suppose you wanted to serialize the following POJO with `Optional` fields: ```java public class ApplicationUser {     private Optional<Address> optionalAddress;     private Optional<Subscription> optionalSubscription;     // ... } \n``` You can use the following implementation of `PropertyCodecProvider` to retrieve your custom Codec. This implementation uses the`TypeWithTypeParameters` interface to access the type information. ```java public class OptionalPropertyCodecProvider implements PropertyCodecProvider {     @Override     @SuppressWarnings({\"rawtypes\", \"unchecked\"})     public <T> Codec<T> get(final TypeWithTypeParameters<T> type, final PropertyCodecRegistry registry) {         // Check the main type and number of generic parameters         if (Optional.class.isAssignableFrom(type.getType()) && type.getTypeParameters().size() == 1) {             // Get the codec for the concrete type of the Optional, as its declared in the POJO.             Codec<?> valueCodec = registry.get(type.getTypeParameters().get(0));\n\n         } else {             return null;         }     }     private static final class OptionalCodec<T> implements Codec<Optional<T>> {         private final Class<Optional<T>> encoderClass;         private final Codec<T> codec;         private OptionalCodec(final Class<Optional<T>> encoderClass, final Codec<T> codec) {             this.encoderClass = encoderClass;             this.codec = codec;         }         @Override         public void encode(final BsonWriter writer, final Optional<T> optionalValue, final EncoderContext encoderContext) {             if (optionalValue != null && optionalValue.isPresent()) {                 codec.encode(writer, optionalValue.get(), encoderContext);             } else {                 writer.writeNull();             }         }         @Override         public Optional<T> decode(final BsonReader reader, final DecoderContext context) {             return Optional.of(codec.decode(reader, context));         }         @Override         public Class<Optional<T>> getEncoderClass() {             return encoderClass;         }     } } \n``` Register your `OptionalPropertyCodecProvider` in your `PojoCodecProvider`and the package that contains your POJO as follows: ```java CodecProvider pojoCodecProvider = PojoCodecProvider.builder()         .register(\"org.example.pojos\")         .register(new OptionalPropertyCodecProvider())         .build(); \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [PropertyCodecProvider](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/PropertyCodecProvider.html)\n* [TypeWithTypeParameters](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/codecs/pojo/TypeWithTypeParameters.html) For more information on generics and type parameters, see the[Java language guide on Invoking and Instantiating a Generic Type.](https://docs.oracle.com/javase/tutorial/java/generics/types.html#instantiation) #### Enum Type Support In driver versions 4.5 and later, the `PojoCodecProvider` no longer includes a codec to convert `enum` types. Ensure that you register a codec for `enum` types if you need one, such as the one in the default codec registry. See the documentation on the [default codec registry](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/#std-label-codecs-default-codec-registry)for more information on how to register the codecs it includes. ← [Document Data Format: Records](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-record/ \"Previous Section\")[Codecs](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/tls/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Enable TLS/SSL on a Connection On this page * [Overview](#overview)\n* [Enable TLS/SSL](#enable-tls-ssl)\n* [Configure Certificates](#configure-certificates)\n* [Configure the JVM Trust Store](#configure-the-jvm-trust-store)\n* [Configure the JVM Key Store](#configure-the-jvm-key-store)\n* [Configure a Client-Specific Trust Store and Key Store](#configure-a-client-specific-trust-store-and-key-store)\n* [Disable Hostname Verification](#disable-hostname-verification)\n* [Restrict Connections to TLS 1.2 Only](#restrict-connections-to-tls-1.2-only)\n* [Customize TLS/SSL Configuration through the Java SE SSLContext](#customize-tls-ssl-configuration-through-the-java-se-sslcontext)\n* [Customize TLS/SSL Configuration through the Netty SslContext](#customize-tls-ssl-configuration-through-the-netty-sslcontext)\n* [Online Certificate Status Protocol (OCSP)](#online-certificate-status-protocol--ocsp-)\n* [Client-Driven OCSP](#client-driven-ocsp)\n* [OCSP Stapling](#ocsp-stapling) ## Overview In this guide, you can learn how to connect to MongoDB instances with the[TLS/SSL](https://en.wikipedia.org/wiki/Transport%5FLayer%5FSecurity)security protocol using the underlying TLS/SSL support in the JDK. To configure your connection to use TLS/SSL, enable the TLS/SSL settings in either the [ConnectionString](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/ConnectionString.html)or [MongoClientSettings.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html) ## Note ### Debugging TLS/SSL If you experience trouble setting up your TLS/SSL connection, you can use the `-Djavax.net.debug=all` system property to view additional log statements. See [the Oracle guide to debugging TLS/SSL connections](https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/ReadDebug.html)for more information. ## Enable TLS/SSL You can enable TLS/SSL for the connection to your MongoDB instance in two different ways: through a parameter in your connection string, or using a method in the `MongoClientSettings.Builder` class. ## Configure Certificates Java applications that initiate TLS/SSL requests require access to cryptographic certificates that prove identity for the application itself as well as other applications with which the application interacts. You can configure access to these certificates in your application with the following mechanisms: * The JVM Trust Store and JVM Key Store\n* A Client-Specific Trust Store and Key Store ## Note The following sections are based on the documentation for Oracle JDK, so some parts may be inapplicable to your JDK or to the custom TLS/SSL implementation you use. ### Configure the JVM Trust Store ## Note By default, the JRE includes many commonly used public certificates from signing authorities like [Let's Encrypt](https://letsencrypt.org/). As a result, you can connect to instances of [MongoDB Atlas](https://www.mongodb.com/docs/atlas/?jmp=docs%5Fdriver%5Fjava) (or any other server whose certificate is signed by an authority in the JRE's default certificate store) with TLS/SSL without configuring the trust store. The JVM trust store saves certificates that securely identify other applications with which your Java application interacts. Using these certificates, your application can prove that the connection to another application is genuine and secure from tampering by third parties.\n\n * `javax.net.ssl.trustStore`: the path to a trust store containing the certificate of the signing authority\n* `javax.net.ssl.trustStorePassword`: the password to access the trust store defined in `javax.net.ssl.trustStore` You can create a trust store with the [keytool](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html)command line tool provided as part of the JDK: `| keytool -importcert -trustcacerts -file <path to certificate authority file> |\n| ---------------------------------------------------------------------------- |\n| -keystore <path to trust store> -storepass <password>                        | ` ### Configure the JVM Key Store ## Note By default, MongoDB instances do not perform client certificate validation. You only need to configure the key store if you explicitly configured your MongoDB instance to validate client certificates. The JVM key store saves certificates that securely identify your Java application to other applications. Using these certificates, other applications can prove that the connection to your application is genuine and secure from tampering by third parties. An application that initiates TLS/SSL requests needs to set two JVM system properties to ensure that the client presents a TLS/SSL certificate to the MongoDB server: * `javax.net.ssl.keyStore`: the path to a key store containing the client's TLS/SSL certificates\n* `javax.net.ssl.keyStorePassword`: the password to access the key store defined in `javax.net.ssl.keyStore` You can create a key store with the [keytool](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/keytool.html)or [openssl](https://www.openssl.org/docs/apps/openssl.html) command line tools. For more information on configuring a Java application to use TLS/SSL, please refer to the [JSSE Reference Guide.](https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html) ### Configure a Client-Specific Trust Store and Key Store You can configure a client-specific trust store and key store using the`init()` method of the `SSLContext` class. You can find an example showing how to configure a client with an `SSLContext`instance in the[Customize TLS/SSL Configuration with an SSLContext section of this guide.](#std-label-tls-custom-sslContext) For more information on the `SSLContext` class, see the API documentation for [SSL Context.](https://docs.oracle.com/en/java/javase/16/docs/api/java.base/javax/net/ssl/SSLContext.html) ## Disable Hostname Verification By default, the driver ensures that the hostname included in the server's TLS/SSL certificates matches the hostnames provided when constructing a `MongoClient`. If you need to disable hostname verification for your application, you can explicitly disable this by setting the`invalidHostNameAllowed` property of the builder to `true` in the`applytoSslSettings()` builder lambda: ```java MongoClientSettings settings = MongoClientSettings.builder()      .applyToSslSettings(builder -> {                  builder.enabled(true);                  builder.invalidHostNameAllowed(true);              })      .build(); \n``` ## Warning Disabling hostname verification can make your configuration[insecure](https://tlseminar.github.io/docs/mostdangerous.pdf). You should only disable hostname verification for testing purposes or when there is no other alternative. ## Restrict Connections to TLS 1.2 Only To restrict your application to use only the TLS 1.2 protocol, set the`jdk.tls.client.protocols` system property to \"TLSv1.2\". ## Note\n\n ## Customize TLS/SSL Configuration through the Java SE SSLContext If your TLS/SSL configuration requires additional customization, you can set the `sslContext` property of your `MongoClient` by passing an [SSLContext](https://docs.oracle.com/javase/8/docs/api/javax/net/ssl/SSLContext.html)object to the builder in the `applyToSslSettings()` lambda: ```java SSLContext sslContext = ... MongoClientSettings settings = MongoClientSettings.builder()      .applyToSslSettings(builder -> {                  builder.enabled(true);                  builder.context(sslContext);              })      .build(); MongoClient client = MongoClients.create(settings); \n``` ## Customize TLS/SSL Configuration through the Netty SslContext If you use the driver with [Netty](https://netty.io/) for network IO, you have an option to plug an alternative TLS/SSL protocol implementation provided by Netty. ```java import com.mongodb.MongoClientSettings; import com.mongodb.client.MongoClients; import com.mongodb.client.MongoClient; import com.mongodb.connection.netty.NettyStreamFactoryFactory; import io.netty.handler.ssl.SslContext; import io.netty.handler.ssl.SslContextBuilder; import io.netty.handler.ssl.SslProvider; \n``` ## Note The driver tests with Netty version `io.netty:netty-all:4.1.79.Final` To instruct the driver to use [io.netty.handler.ssl.SslContext](https://netty.io/4.1/api/io/netty/handler/ssl/SslContext.html), use the [NettyStreamFactoryFactory.Builder.sslContext](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/connection/netty/NettyStreamFactoryFactory.Builder.html#sslContext%28io.netty.handler.ssl.SslContext%29)method. See the method documentation for details about the different [io.netty.handler.ssl.SslProvider](https://netty.io/4.1/api/io/netty/handler/ssl/SslProvider.html)variants the driver supports and the implications of using them. ```java SslContext sslContext = SslContextBuilder.forClient()         .sslProvider(SslProvider.OPENSSL)         .build(); MongoClientSettings settings = MongoClientSettings.builder()         .applyToSslSettings(builder -> builder.enabled(true))         .streamFactoryFactory(NettyStreamFactoryFactory.builder()                 .sslContext(sslContext)                 .build())         .build(); MongoClient client = MongoClients.create(settings); \n``` ## Online Certificate Status Protocol (OCSP) OCSP is a standard used to check whether X.509 certificates have been revoked. A certificate authority can add an X.509 certificate to the Certificate Revocation List (CRL) prior to the expiry time to invalidate the certificate. When a client sends an X.509 certificate during the TLS handshake, the CA's revocation server checks the CRL and returns a status of \"good\", \"revoked\", or \"unknown\". The driver supports the following variations of OCSP: * **Client-Driven OCSP**\n* **OCSP Stapling** The following sections describe the differences between them and how to enable them for your application. ## Note The Java driver uses the JVM arguments configured for the application and cannot be overridden for a specific `MongoClient` instance. ### Client-Driven OCSP\n\n To enable client-driven OCSP for your application, set the following JVM system properties: | Property                        | Value                                                    |\n| ------------------------------- | -------------------------------------------------------- |\n| com.sun.net.ssl.checkRevocation | Set this property to true to enable revocation checking. |\n| ocsp.enable                     | Set this property to true to enable client-driven OCSP.  | ## Warning If the OCSP responder is unavailable, the TLS support provided by the JDK reports a \"hard fail\". This differs from the \"soft fail\" behavior of the MongoDB Shell and some other drivers. ### OCSP Stapling OCSP stapling is a mechanism in which the server must obtain the signed certificate from the certificate authority (CA) and include it in a time-stamped OCSP response to the client. To enable OCSP stapling for your application, set the following JVM system properties: | Property                                    | Description                                                                                                                                                                         |\n| ------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| com.sun.net.ssl.checkRevocation             | Set this property to true to enable revocation checking.                                                                                                                            |\n| jdk.tls.client.enableStatusRequestExtension | Set this property to true to enable OCSP stapling.If unset or set to false, the connection can proceed regardless of the presence or status of the certificate revocation response. | For additional information about OCSP, check out the following resources: * Oracle JDK 8 Documentation on [how to enable OCSP for an application](https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/ocsp.html)\n* [Official IETF specification for OCSP (RFC 6960)](https://tools.ietf.org/html/6960) ← [Network Compression](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/network-compression/ \"Previous Section\")[Connect to MongoDB Using a JNDI Datasource](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/jndi/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Connect to MongoDB In this guide, you can learn how to connect to a MongoDB instance or replica set using the Java driver. You can view sample code to [connect to an Atlas cluster](#std-label-connect-atlas-java-driver)or continue reading to learn more about the `MongoClient` class and connection URIs. ## MongoClient You can connect to and communicate with MongoDB using the `MongoClient`class. Use the `MongoClients.create()` method to construct a `MongoClient`. As each `MongoClient` represents a thread-safe pool of connections to the database, most applications only require a single instance of a`MongoClient`, even across multiple threads. All resource usage limits, such as max connections, apply to individual `MongoClient` instances. To learn about the different settings you can use to control the behavior of your `MongoClient`, see the guide on[MongoClient Settings.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/mongoclientsettings/#std-label-specify-mongoclient-settings) ## Tip Always call `MongoClient.close()` to clean up resources when an instance is no longer needed. ## Connection URI The **connection URI** provides a set of instructions that the driver uses to connect to a MongoDB deployment. It instructs the driver on how it should connect to MongoDB and how it should behave while connected. The following figure explains each part of a sample connection URI: ![Connection String parts figure](https://mongodb.com/docs/drivers/java/sync/current/includes/figures/connection_uri_parts.png) This figure uses the [Standard Connection String Format](https://www.mongodb.com/docs/manual/reference/connection-string/#std-label-connections-standard-connection-string-format),`mongodb` for the protocol. You can also use the [DNS Seed List Connection Format](https://www.mongodb.com/docs/manual/reference/connection-string/#dns-seed-list-connection-format),`mongodb+srv`, if you want more flexibility of deployment and the ability to change the servers in rotation without reconfiguring clients. ## Note If your deployment is on MongoDB Atlas, see the[Atlas driver connection guide](https://www.mongodb.com/docs/atlas/driver-connection/?jmp=docs%5Fdriver%5Fjava)and select Java from the language dropdown to retrieve your connection string. The next part of the connection URI contains your credentials if you are using a password-based authentication mechanism. Replace the value of `user`with your username and `pass` with your password. If your authentication mechanism does not require credentials, omit this part of the connection URI. The next part of the connection URI specifies the hostname or IP address, followed by the port of your MongoDB instance. In the example,`sample.host` represents the hostname and `27017` is the port number. Replace these values to refer to your MongoDB instance. The last part of the connection URI contains connection options as parameters. In the example, we set two connection options: `maxPoolSize=20` and`w=majority`. For more information on connection options, skip to the[Connection Options](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connection-options/#std-label-connection-options) section of this guide. ## Atlas Connection Example To connect to a MongoDB deployment on Atlas, create a client. You can create a client that uses your connection string and other client options by passing a `MongoClientSettings` object to the`MongoClients.create()` method. To instantiate a `MongoClientSettings` object, use the builder method to specify your connection string and any other client options, and then call the `build()`method. Chain the `applyConnectionString()` method to the builder to specify your connection URI. You can set the Stable API version client option to avoid breaking changes when you upgrade to a new server version. To learn more about the Stable API feature, see the [Stable API page.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/stable-api/#std-label-stable-api-java) The following code shows how you can specify the connection string and the Stable API client option when connecting to a MongoDB deployment on Atlas and verify that the connection is successful:\n\n ` ## Other Ways to Connect to MongoDB If you are connecting to a single MongoDB server instance or replica set that is not hosted on Atlas, see the following sections to find out how to connect. ### Connect to a MongoDB Server on Your Local Machine If you need to run a MongoDB server on your local machine for development purposes instead of using an Atlas cluster, you need to complete the following: 1. Download the [Community](https://www.mongodb.com/try/download/community)or [Enterprise](https://www.mongodb.com/try/download/enterprise) version of MongoDB Server.\n2. [Install and configure](https://www.mongodb.com/docs/manual/installation/#std-label-tutorials-installation)MongoDB Server.\n3. Start the server. ## Important Always secure your MongoDB server from malicious attacks. See our[Security Checklist](https://www.mongodb.com/docs/manual/administration/security-checklist/) for a list of security recommendations. After you successfully start your MongoDB server, specify your connection string in your driver connection code. If your MongoDB Server is running locally, you can use the connection string`\"mongodb://localhost:<port>\"` where `<port>` is the port number you configured your server to listen for incoming connections. If you need to specify a different hostname or IP address, see our Server Manual entry on [Connection Strings.](https://www.mongodb.com/docs/manual/reference/connection-string/) To test whether you can connect to your server, replace the connection string in the [Connect to MongoDB Atlas](#std-label-connect-atlas-java-driver) code example and run it. ### Connect to a Replica Set A MongoDB replica set deployment is a group of connected instances that store the same set of data. This configuration of instances provides data redundancy and high data availability. To connect to a replica set deployment, specify the hostnames (or IP addresses) and port numbers of the members of the replica set. If you are not able to provide a full list of hosts in the replica set, you can specify a single or subset of the hosts in the replica and instruct the driver to perform automatic discovery in one of the following ways: * Specify the name of the replica set as the value of the `replicaSet`parameter\n* Specify `false` as the value of the `directConnection` parameter\n* Specify more than one host in the replica set ## Tip Although you can specify a subset of the hosts in a replica set, include all the hosts in the replica set to ensure the driver is able to establish the connection if one of the hosts are unreachable. The following examples show how to specify multiple hosts to a `MongoClient`instance using either the `ConnectionString` or `MongoClientSettings`class. Select the tab that corresponds to your preferred class. ← [Connection Guide](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/ \"Previous Section\")[Connection Options](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connection-options/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connection-options/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Connection Options This section explains MongoDB connection and authentication options supported by the driver. You can pass the connection options as parameters of the connection URI to specify the behavior of the client.\n\n For a complete list of options, see the[ConnectionString](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/ConnectionString.html)API reference page. ← [Connect to MongoDB](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/ \"Previous Section\")[Specify MongoClient Settings](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/mongoclientsettings/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/jndi/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Connect to MongoDB Using a JNDI Datasource On this page * [Overview](#overview) ## Overview In this guide, you can learn how to connect the MongoDB Java driver to your MongoDB instance using a Java Naming and Directory Interface (JNDI) Datasource. MongoClientFactory includes a [JNDI](https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.html) `ObjectFactory` implementation that returns `MongoClient` instances based on a [connection URI](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connect/#std-label-connection-uri). Consult the following guides to learn how to configure your application to connect using a JNDI Datasource. ## Tip ### See also:  For JNDI implementations other than those listed here, you can create your own `Factory` wrapper based on the driver's built-in[MongoClientFactory](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClientFactory.html)implementation. ← [Enable TLS/SSL on a Connection](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/tls/ \"Previous Section\")[Authentication Mechanisms](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/auth/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/indexes/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Indexes Builders On this page * [Overview](#overview)\n* [Ascending Indexes](#ascending-indexes)\n* [Descending Indexes](#descending-indexes)\n* [Compound Indexes](#compound-indexes)\n* [Text Indexes](#text-indexes)\n* [Hashed Indexes](#hashed-indexes)\n* [Geospatial Indexes](#geospatial-indexes) ## Overview In this guide, you can learn how to specify **indexes** using[builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/) in the MongoDB Java driver. The `Indexes` builder provides helper methods for constructing the following types of indexes: * [Ascending Indexes](#std-label-ascending-indexes)\n* [Descending Indexes](#std-label-descending-indexes)\n* [Compound Indexes](#std-label-index-compound-indexes)\n* [Text Indexes](#std-label-index-text-indexes)\n* [Hashed Indexes](#std-label-index-hashed-indexes)\n* [Geospatial Indexes](#std-label-index-geospatial-indexes) Indexes store a subset of the collection’s data set. The index stores the value of a specific field or set of fields, ordered by the value of the field. See our guide on [Indexes](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/indexes/) for examples of queries covered by indexes. The `Indexes` class provides static factory methods for all the MongoDB index types. Each method returns a [BSON](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/conversions/Bson.html)instance, which you can pass to[createIndex().](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#createIndex%28org.bson.conversions.Bson,com.mongodb.client.model.IndexOptions%29) ## Tip For brevity, you may choose to import all methods of the[Indexes](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Indexes.html)class statically: `| import static com.mongodb.client.model.Indexes.*; |\n| ------------------------------------------------- | ` The following examples assume this static import. ## Ascending Indexes An ascending index enables you to sort query results by the value of the indexed fields from smallest to largest. In order to create an ascending index, first call the[ascending()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Indexes.html#ascending%28java.lang.String...%29)builder method to create a `Bson` instance that represents the index document, passing the name or names of the fields you want to index. Then, call the `createIndex()` method on the collection, passing the `Bson`instance that contains the index document. ## Note If you have an ascending or a descending index on a single field, MongoDB can sort using the index in either direction. The following example specifies an ascending index on the `name` field: ```java Bson ascendingIndex = ascending(\"name\"); collection.createIndex(ascendingIndex); \n``` ## Descending Indexes A descending index enables you to sort query results by the value of the indexed fields from largest to smallest.\n\n The following example specifies a descending index on the `capacity` field: ```java Bson descendingIndex = descending(\"capacity\"); collection.createIndex(descendingIndex); \n``` ## Compound Indexes In order to create a compound index, first call the[compoundIndex()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Indexes.html#compoundIndex%28org.bson.conversions.Bson...%29)builder method to create a `Bson` instance that represents the index document, passing the names of the fields you want to index. Then, call the `createIndex()` method on the collection, passing the `Bson`instance that contains the index document. The following example specifies a compound index composed of descending index on the `capacity` and `year` field, followed by an ascending index on the `name` field: ```java Bson compoundIndexExample = compoundIndex(descending(\"capacity\", \"year\"), ascending(\"name\")); collection.createIndex(compoundIndexExample); \n``` ## Text Indexes A text index groups documents by the text in the indexed field. In order to create a text index, first call the[text()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Indexes.html#text%28java.lang.String%29)builder method to create a `Bson` instance that represents the index document, passing the name of the fields you want to index. Then, call the `createIndex()` method on the collection, passing the `Bson`instance that contains the index document. The following example specifies a text index key on the \"theaters\" field: ```java Bson textIndex = text(\"theaters\"); collection.createIndex(textIndex); \n``` ## Hashed Indexes A hashed index groups documents by the hash value in the indexed field. In order to create a hashed index, first call the[hashed()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Indexes.html#hashed%28java.lang.String%29)builder method to create a `Bson` instance that represents the index document, passing the name of the fields you want to index. Then, call the `createIndex()` method on the collection, passing the `Bson`instance that contains the index document. The following example specifies a hashed index on the `capacity`field: ```java Bson hashedIndex = hashed(\"capacity\"); collection.createIndex(hashedIndex); \n``` ## Geospatial Indexes A `2dsphere` index groups documents by the coordinates in the indexed field. In order to create a `2dsphere` index, first call the[geo2dsphere()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Indexes.html#geo2dsphere%28java.lang.String...%29)builder method to create a `Bson` instance that represents the index document, passing the name or names of the fields you want to index. Then, call the `createIndex()` method on the collection, passing the `Bson`instance that contains the index document. The following example specifies a `2dsphere` index on the `location` field: ```java Bson geo2dsphereIndex = geo2dsphere(\"location\"); collection.createIndex(geo2dsphereIndex); \n``` ← [Filters Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/ \"Previous Section\")[Projections Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/projections/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/sort/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Sorts Builders On this page * [Overview](#overview)\n* [The Sorts Class](#the-sorts-class)\n* [Ascending](#ascending)\n* [Descending](#descending)\n* [Combining Sort Criteria](#combining-sort-criteria)\n* [Text Score](#text-score) ## Overview In this guide, you can learn how to specify **sort criteria** for your queries using **builders** in the MongoDB Java driver. Sort criteria are the rules MongoDB uses to sort your data. Some examples of sort criteria are: * Smallest number to largest number\n* Earliest time of day to latest time of day\n* Alphabetical order by first name Builders are classes provided by the MongoDB Java driver that help you construct [BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/#std-label-bson) objects. To learn more, see our [guide on builders.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/) You should read this guide if you would like to use builders to specify sort criteria for your queries. If you want to learn the fundamentals of sorting in the MongoDB Java driver, consider reading our[guide on sorting.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/) The examples on this page use a sample collection that contains the following documents: `| {\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}  |\n| ------------------------------------------------------ |\n| {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}       |\n| {\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"} |\n| {\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}  |\n| {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} |\n| {\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}       | ` ## The Sorts Class The `Sorts` class is a builder that provides static factory methods for all sort criteria operators supported by MongoDB. These methods return a `Bson` object that you can pass to the `sort()` method of a `FindIterable` instance or to`Aggregates.sort()`. If you want to learn more about the `Aggregates`class, see our[guide on the Aggregates builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/aggregates/) For more information about the classes and interfaces in this section, see the following API Documentation: * [Sorts](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html)\n* [BSON](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/conversions/Bson.html)\n* [FindIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html)\n* [Aggregates](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html) ## Ascending To specify an ascending sort, use the `Sorts.ascending()` static factory method. Pass `Sorts.ascending()`the name of the field you need to sort on. The following example sorts the documents in the[sample collection](#std-label-sorts-builders-sort-sample) by ascending order on the `_id` field: ```java import static com.mongodb.client.model.Sorts.ascending; // <MongoCollection setup code here> collection.find().sort(ascending(\"_id\"));\n\n The output of the preceding example should look something like this: ``` {\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"} {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"} ... \n``` ## Descending To specify a descending sort, use the `Sorts.descending()` static factory method. Pass `Sorts.descending()` the name of the field you need to sort on. The following example sorts the documents in the[sample collection](#std-label-sorts-builders-sort-sample) in descending order on the `_id` field: ```java import static com.mongodb.client.model.Sorts.descending; // <MongoCollection setup code here> collection.find().sort(descending(\"_id\")); \n``` The preceding example should output something like this: ``` {\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"} {\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"} {\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"} ... \n``` ## Combining Sort Criteria To combine sort criteria, use the `Sorts.orderBy()` static factory method. This method constructs an object containing an ordered list of sort criteria. When performing the sort, if the leftmost sort criteria results in a tie, the sort uses the next sort criteria in the list to determine the order. The following example sorts the documents in the[sample collection](#std-label-sorts-builders-sort-sample) in descending order on the `letter` field, and in the event of a tie, ascending order on the`_id` field: ```java import static com.mongodb.client.model.Sorts.orderBy; import static com.mongodb.client.model.Sorts.ascending; import static com.mongodb.client.model.Sorts.descending; // <MongoCollection setup code here> Bson orderBySort = orderBy(descending(\"letter\"), ascending(\"_id\")); collection.find().sort(orderBySort); \n``` The output of the preceding example should look something like this: ``` {\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"} {\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"} {\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"} {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"} {\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"} \n``` ## Text Score You can sort text search results by their text score, a value that indicates how closely a search result matches your search string. To specify a sort by the text score of a text search, use the `Sorts.metaTextScore()` static factory method. For a detailed example showing how to specify sort criteria using the `Sorts.metaTextScore()` method, see[the text search section of our sorting fundamentals guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/#std-label-sorts-crud-text-search) For more information, see the [Sorts class](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html)API Documentation. ← [Projections Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/projections/ \"Previous Section\")[Updates Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/projections/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Projections Builders On this page * [Overview](#overview)\n* [Sample Documents and Examples](#sample-documents-and-examples)\n* [Projection Operations](#projection-operations)\n* [Inclusion](#inclusion)\n* [Exclusion](#exclusion)\n* [Combining Projections](#combining-projections)\n* [Exclusion of \\_id](#exclusion-of-%5Fid)\n* [Project an Array Element Match](#project-an-array-element-match)\n* [Project an Array Slice](#project-an-array-slice)\n* [Project a Text Score](#project-a-text-score) ## Overview In this guide, you can learn how to specify **projections** using[builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/) in the MongoDB Java driver. MongoDB supports **field projection**, specifying which fields to include and exclude when returning results from a query. Projection in MongoDB follows some basic rules: * The `_id` field is **always** included unless explicitly excluded\n* Specifying a field for inclusion implicitly excludes all other fields **except** the `_id` field\n* Specifying a field for exclusion removes **only** that field in a query result Find more information about projection mechanics [here.](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/) The `Projections` class provides static factory methods for all the MongoDB projection operators. Each method returns an instance of the [BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/#std-label-bson) type which you can pass to any method that expects a projection. ## Tip For brevity, you may choose to import the methods of the[Projections](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Projections.html)class statically: `| import static com.mongodb.client.model.Projections.*; |\n| ----------------------------------------------------- | ` The following examples assume this static import. ### Sample Documents and Examples The following sections feature examples that run query and projection operations on a sample collection called `projection_builders`. Each section uses a variable named `collection` to refer to the `MongoCollection` instance of the `projection_builders` collection. The collection contains the following documents, representing the monthly average temperatures in Celsius for the years 2018 and 2019: ``` {   \"year\" : 2018,   \"type\" : \"even number but not a leap year\",   \"temperatures\" : [     { \"month\" : \"January\", \"avg\" : 9.765 },     { \"month\" : \"February\", \"avg\" : 9.675 },     { \"month\" : \"March\", \"avg\" : 10.004 },     { \"month\" : \"April\", \"avg\" : 9.983 },     { \"month\" : \"May\", \"avg\" : 9.747 },     { \"month\" : \"June\", \"avg\" : 9.65 },     { \"month\" : \"July\", \"avg\" : 9.786 },     { \"month\" : \"August\", \"avg\" : 9.617 },     { \"month\" : \"September\", \"avg\" : 9.51 },     { \"month\" : \"October\", \"avg\" : 10.042 },     { \"month\" : \"November\", \"avg\" : 9.452 },     { \"month\" : \"December\", \"avg\" : 9.86 }   ] }, {   \"year\" : 2019,   \"type\" : \"odd number, can't be a leap year\",   \"temperatures\" : [     { \"month\" : \"January\", \"avg\" : 10.023 },     { \"month\" : \"February\", \"avg\" : 9.808 },     { \"month\" : \"March\", \"avg\" : 10.43 },\n\n     { \"month\" : \"May\", \"avg\" : 9.648 },     { \"month\" : \"June\", \"avg\" : 9.686 },     { \"month\" : \"July\", \"avg\" : 9.794 },     { \"month\" : \"August\", \"avg\" : 9.741 },     { \"month\" : \"September\", \"avg\" : 9.84 },     { \"month\" : \"October\", \"avg\" : 10.15 },     { \"month\" : \"November\", \"avg\" : 9.84 },     { \"month\" : \"December\", \"avg\" : 10.366 }   ] } \n``` ## Projection Operations The following sections contain information on the available projection operations and how to construct them using the `Projections` class. ### Inclusion Use the `include()` method to specify the inclusion of one or more fields. The following example includes the `year` field and (implicitly) the `_id` field: ```java Bson filter = Filters.empty(); Bson projection = include(\"year\"); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection: ``` {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018} {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019} \n``` The following example includes the `year` and `type` fields and (implicitly) the `_id` field: ```java Bson filter = Filters.empty(); Bson projection = include(\"year\", \"type\"); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection: ``` {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018, \"type\": \"even number but not a leap year\"} {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019, \"type\": \"odd number, can't be a leap year\"} \n``` ### Exclusion Use the `exclude()` method to specify the exclusion of one or more fields. The following example excludes the `temperatures` field: ```java Bson filter = Filters.empty(); Bson projection = exclude(\"temperatures\"); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection: ``` {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018, \"type\": \"even number but not a leap year\"} {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019, \"type\": \"odd number, can't be a leap year\"} \n``` The following example excludes the `type` and `temperatures` fields: ```java Bson filter = Filters.empty(); Bson projection = exclude(\"temperatures\", \"type\"); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection: ``` {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018} {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019} \n``` ### Combining Projections Use the `fields()` method to combine multiple projections. The following example includes the `year` and `type` fields and excludes the`_id` field: ```java Bson filter = Filters.empty(); Bson projection = fields(include(\"year\", \"type\"), exclude(\"_id\")); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection:\n\n {\"year\": 2018, \"type\": \"even number but not a leap year\"} {\"year\": 2019, \"type\": \"odd number, can't be a leap year\"} \n``` ### Exclusion of `_id` Use the `excludeId()` convenience method to specify the exclusion of the `_id` field: ```java Bson filter = Filters.empty(); Bson projection = fields(include(\"year\", \"type\"), excludeId()); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection: ``` {\"year\": 2018, \"type\": \"even number but not a leap year\"} {\"year\": 2019, \"type\": \"odd number, can't be a leap year\"} \n``` ### Project an Array Element Match Use the `elemMatch(String, Bson)` method variant to specify an array projection that will include the first element of an array that matches a supplied query filter. This filtering occurs **after** all documents matching the query filter (if supplied) are retrieved. ## Note Only the first element that matches the specified query filter will be included, regardless of how many matches there may be. The following example projects the first element of the `temperatures` array where the `avg` field is greater that `10.1`: ```java Bson filter = Filters.empty(); Bson projection = fields(include(\"year\"), elemMatch(\"temperatures\", Filters.gt(\"avg\", 10.1))); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection: ``` {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0790\"}, \"year\": 2018} {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019, \"temperatures\": [{\"month\": \"March\", \"avg\": 10.43}]} \n``` When you've specified matching criteria in the **query** portion of your operation, use the `elemMatch(String)` method variant to specify a [positional projection](https://www.mongodb.com/docs/manual/reference/operator/projection/positional/#sorts-and-the-positional-operator) to include the first element of an array. Only documents that match the query filter will be retrieved. ## Important In MongoDB versions < 4.4, the specified array field must appear in the query filter. Beginning in MongoDB 4.4, you can use a positional project on an array field that does not appear in the query filter. The following example projects the first element of the `temperatures` array: ```java Bson filter = Filters.gt(\"temperatures.avg\", 10.1); Bson projection = fields(include(\"year\"), elemMatch(\"temperatures\")); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection: ``` {\"_id\": {\"$oid\": \"6042edc9f2b56342164e0791\"}, \"year\": 2019, \"temperatures\": [{\"month\": \"March\", \"avg\": 10.43}]} \n``` ### Project an Array Slice Use the `slice()` method to project a [slice](https://www.mongodb.com/docs/manual/reference/operator/projection/slice/) of an array. The following example projects the first **6** elements of the `temperatures` array: ```java Bson filter = Filters.empty(); // first half of the year Bson projection = slice(\"temperatures\", 6); collection.find(filter).projection(projection)         .forEach(doc -> System.out.println(doc.toJson(JsonWriterSettings.builder().indent(true).build()))); \n``` The following code shows the output from this projection: ``` {   \"_id\": {     \"$oid\": \"6042f1bc8ee6fa2a84d2be69\"   },   \"year\": 2018,   \"type\": \"even number but not a leap year\",   \"temperatures\": [\n\n   ] } {   \"_id\": {     \"$oid\": \"6042f1bc8ee6fa2a84d2be6a\"   },   \"year\": 2019,   \"type\": \"odd number, can't be a leap year\",   \"temperatures\": [       ... <January-June temperature nested documents>   ] } \n``` The following example skips the first **6** elements of the `temperatures` array and projects the next **6**: ```java Bson filter = Filters.empty(); // second half of the year Bson projection = slice(\"temperatures\", 6, 6); collection.find(filter).projection(projection)         .forEach(doc -> System.out.println(doc.toJson(JsonWriterSettings.builder().indent(true).build()))); \n``` The following code shows the output from this projection: ``` {   \"_id\": {     \"$oid\": \"6042f1bc8ee6fa2a84d2be69\"   },   \"year\": 2018,   \"type\": \"even number but not a leap year\",   \"temperatures\": [       ... <July-December temperature nested documents>   ] } {   \"_id\": {     \"$oid\": \"6042f1bc8ee6fa2a84d2be6a\"   },   \"year\": 2019,   \"type\": \"odd number, can't be a leap year\",   \"temperatures\": [       ... <July-December temperature nested documents>   ] } \n``` ### Project a Text Score Use the `metaTextScore()` method to specify a projection of the[score of a text query](https://www.mongodb.com/docs/manual/reference/operator/query/text/#text-score) The following example projects the text score as the value of the `score` field: ```java Bson filter = Filters.text(\"even number\"); Bson projection = fields(include(\"year\"), metaTextScore(\"score\")); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc.toJson())); \n``` The following code shows the output from this projection: ``` {\"_id\": {\"$oid\": \"6042f1bc8ee6fa2a84d2be69\"}, \"year\": 2018, \"score\": 1.25} {\"_id\": {\"$oid\": \"6042f1bc8ee6fa2a84d2be6a\"}, \"year\": 2019, \"score\": 0.625} \n``` ← [Indexes Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/indexes/ \"Previous Section\")[Sorts Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/sort/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Filters Builders On this page * [Overview](#overview)\n* [Comparison](#comparison)\n* [Logical](#logical)\n* [Arrays](#arrays)\n* [Elements](#elements)\n* [Evaluation](#evaluation)\n* [Bitwise](#bitwise)\n* [Geospatial](#geospatial) ## Overview In this guide, you can learn how to use **builders** to specify**filters** for your queries in the MongoDB Java driver. Builders are classes provided by the MongoDB Java driver that help you construct [BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/#std-label-bson) objects. To learn more, see our [guide on builders.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/) Filters are the operations MongoDB uses to limit your results to what you want to see. Some places we use filters are: * `find()`\n* match stage of aggregation\n* `deleteOne()`/`deleteMany()`\n* `updateOne()`/`updateMany()` Some examples of results from queries with filters are: * Items that cost $0 to $25\n* A hotel with amenities that include an indoor swimming pool and free parking\n* A food critic review that mentions \"spicy\" This guide shows you how to use builders with examples of the following types of operators: * [Comparison](#std-label-comparison)\n* [Logical](#std-label-logical)\n* [Arrays](#std-label-arrays)\n* [Elements](#std-label-elements)\n* [Evaluation](#std-label-evaluation)\n* [Bitwise](#std-label-bitwise)\n* [Geospatial](#std-label-geospatial) The `Filters` class provides static factory methods for all the MongoDB query operators. Each method returns an instance of the [BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/#std-label-bson)type, which you can pass to any method that expects a query filter. ## Tip For brevity, you may choose to import all methods of the[Filters](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html)class statically: `| import static com.mongodb.client.model.Filters.*; |\n| ------------------------------------------------- | ` The following examples assume this static import. The Filter examples in this guide use the following sample collections: Collection: `paint_purchases` ``` { \"_id\": 1, \"color\": \"red\", \"qty\": 5, \"vendor\": [\"A\"] } { \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] } { \"_id\": 3, \"color\": \"blue\", \"qty\": 8, \"vendor\": [\"B\", \"A\"] } { \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"] } { \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] } { \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] } { \"_id\": 7, \"color\": \"green\", \"qty\": 8,\"vendor\": [\"B\", \"C\"] } { \"_id\": 8, \"color\": \"orange\", \"qty\": 7, \"vendor\": [\"A\", \"D\"] } \n``` Collection: `binary_numbers` ``` { \"_id\": 9, \"a\": 54, \"binaryValue\": \"00110110\" } { \"_id\": 10, \"a\": 20, \"binaryValue\": \"00010100\" } { \"_id\": 11, \"a\": 68, \"binaryValue\": \"1000100\" } { \"_id\": 12, \"a\": 102, \"binaryValue\": \"01100110\" } \n```\n\n ``` { \"_id\": 13, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [2.0, 2.0] } } { \"_id\": 14, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [5.0, 6.0] } } { \"_id\": 15, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [1.0, 3.0] } } { \"_id\": 16, \"coordinates\": { \"type\": \"Point\", \"coordinates\": [4.0, 7.0] } } \n``` ## Comparison The comparison filters include all operators that compare the value in a document to a specified value. The comparison operator methods include:\n\n The following example creates a filter that matches all documents where the value of the `qty` field equals \"5\" in the `paint_purchases` collection: ```java Bson equalComparison = eq(\"qty\", 5); collection.find(equalComparison).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ``` { \"_id\": 1, \"color\": \"red\", \"qty\": 5, \"vendor\": [\"A\"] } { \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] } \n``` The following example creates a filter that matches all documents where the value of the `qty` field is greater than or equal to \"10\" in the`paint_purchases` collection: ```java Bson gteComparison = gte(\"qty\", 10); collection.find(gteComparison).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ``` { \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] } { \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] } \n``` The following example creates a filter that matches all documents in the `paint_purchases` collection because the predicate is empty: ```java Bson emptyComparison = empty(); collection.find(emptyComparison).forEach(doc -> System.out.println(doc.toJson())); \n``` The output of the preceding query consists of all the documents in the collection. ``` { \"_id\": 1, \"color\": \"red\", \"qty\": 5, \"vendor\": [\"A\"] } { \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] } { \"_id\": 3, \"color\": \"blue\", \"qty\": 8, \"vendor\": [\"B\", \"A\"] } ... \n``` ## Logical The logical operators perform logical operations based on the conditions of the specified method. The logical operator methods include:\n\n The following example creates a filter that matches documents where the value of the `qty` field is greater than \"8\" or the value of the `color` field equals \"pink\" in the `paint_purchases` collection: ```java Bson orComparison = or(gt(\"qty\", 8), eq(\"color\", \"pink\")); collection.find(orComparison).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ``` { \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] } { \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] } { \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] } \n``` ## Arrays The array operators evaluate the array field in a document. The array operator methods include: | Array Method                                                                                                                                                                               | Matches                                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------- |\n| [all()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#all%28java.lang.String,java.lang.Iterable%29)                    | documents if the array field contains every element specified in the query.      |\n| [elemMatch()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#elemMatch%28java.lang.String,org.bson.conversions.Bson%29) | documents if an element in the array field matches all the specified conditions. |\n| [size()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#size%28java.lang.String,int%29)                                 | documents if the array field is a specified number of elements.                  | The following example matches documents with a `vendors` array containing both \"A\" and \"D\" in the `paint_purchases` collection: ```java List<String> search = Arrays.asList(\"A\", \"D\"); Bson allComparison = all(\"vendor\", search); collection.find(allComparison).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ``` { \"_id\": 8, \"color\": \"orange\", \"qty\": 7, \"vendor\": [\"A\", \"D\"] } \n``` ## Elements The elements operators evaluate the nature of a specified field. The elements operator methods include:\n\n The following example matches documents that have a `qty` field and its value does not equal \"5\" or \"8\" in the `paint_purchases` collection: ```java Bson existsComparison = and(exists(\"qty\"), nin(\"qty\", 5, 8)); collection.find(existsComparison).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ``` { \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] } { \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"]} { \"_id\": 5, \"color\": \"yellow\", \"qty\": 11, \"vendor\": [\"A\", \"B\"] } { \"_id\": 8, \"color\": \"orange\", \"qty\": 7, \"vendor\": [\"A\", \"D\"] } \n``` ## Evaluation The evaluation operators evaluate the value of any field in a document. The evaluation operator methods include: | Evaluation Method                                                                                                                                                         | Matches                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- |\n| [mod()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#mod%28java.lang.String,long,long%29)            | documents where a modulo operation on the value of a field contain a specified result. |\n| [regex()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#regex%28java.lang.String,java.lang.String%29) | documents where values contain a specified regular expression.                         |\n| [text()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#text%28java.lang.String%29)                    | documents which contain a specified full-text search expression.                       |\n| [where()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#where%28java.lang.String%29)                  | documents which contain a specified JavaScript expression.                             | The following example matches documents that have a `color` field starting with the letter \"p\" in the `paint_purchases` collection: ```java Bson regexComparison = regex(\"color\", \"^p\");\n\n \n``` The following shows the output of the preceding query: ``` { \"_id\": 2, \"color\": \"purple\", \"qty\": 10, \"vendor\": [\"C\", \"D\"] } { \"_id\": 6, \"color\": \"pink\", \"qty\": 5, \"vendor\": [\"C\"] } \n``` ## Bitwise The bitwise operators convert a number into its binary value to evaluate its bits. The bitwise operator methods include: | Bitwise Method                                                                                                                                                              | Matches                                                                             |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------- |\n| [bitsAllSet()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#bitsAllSet%28java.lang.String,long%29)     | documents where the specified bits of a field are set (i.e. \"1\").                   |\n| [bitsAllClear()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#bitsAllClear%28java.lang.String,long%29) | documents where the specified bits of a field are clear (i.e. \"0\").                 |\n| [bitsAnySet()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#bitsAnySet%28java.lang.String,long%29)     | documents where at least one of the specified bits of a field are set (i.e. \"1\").   |\n| [bitsAnyClear()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#bitsAnyClear%28java.lang.String,long%29) | documents where at least one of the specified bits of a field are clear (i.e. \"0\"). | The following example matches documents that have a `bitField` field with bits set at positions of the corresponding bitmask \"34\" (i.e. \"00100010\") in the `binary_numbers` collection: ```java Bson bitsComparison = bitsAllSet(\"a\", 34); collection.find(bitsComparison).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ``` { \"_id\": 9, \"a\": 54, \"binaryValue\": \"00110110\" } { \"_id\": 12, \"a\": 102, \"binaryValue\": \"01100110\" } \n``` ## Geospatial The geospatial operators evaluate a specified coordinate and its relation to a shape or location. The geospatial operator methods include:\n\n The following example creates a filter that matches documents in which the `point` field contains a GeoJSON geometry that falls within the given [Polygon](https://www.mongodb.com/docs/manual/reference/geojson/#polygon)in the `geo_points` collection: ```java Polygon square = new Polygon(Arrays.asList(new Position(0, 0),                                      new Position(4, 0),                                      new Position(4, 4),                                      new Position(0, 4),                                     new Position(0, 0))); Bson geoWithinComparison = geoWithin(\"coordinates\", square); collection.find(geoWithinComparison).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ``` { \"_id\": 13, \"coordinates\": {\"type\": \"Point\", \"coordinates\": [2.0, 2.0]} } { \"_id\": 15, \"coordinates\": {\"type\": \"Point\", \"coordinates\": [1.0, 3.0]} } \n``` ← [Aggregates Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/aggregates/ \"Previous Section\")[Indexes Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/indexes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/mongoclientsettings/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Specify MongoClient Settings On this page * [Overview](#overview)\n* [MongoClient Settings](#mongoclient-settings)\n* [Cluster Settings](#cluster-settings)\n* [Socket Settings](#socket-settings)\n* [Connection Pool Settings](#connection-pool-settings)\n* [Server Settings](#server-settings)\n* [TLS/SSL Settings](#tls-ssl-settings) ## Overview In this guide, you can learn about the different settings to control the behavior of your `MongoClient`. The following sections describe commonly used settings: * [MongoClient Settings](#std-label-mcs-settings)\n* [Cluster Settings](#std-label-mcs-cluster-settings)\n* [Socket Settings](#std-label-mcs-socket-settings)\n* [Connection Pool Settings](#std-label-mcs-connectionpool-settings)\n* [Server Settings](#std-label-mcs-server-settings)\n* [TLS/SSL Settings](#std-label-mcs-ssl-settings) ## MongoClient Settings You can control the behavior of your `MongoClient` by creating and passing in a [MongoClientSettings](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.html)object to the [MongoClients.create()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoClients.html#create%28com.mongodb.MongoClientSettings%29)method. To create a `MongoClientSettings` object, use the`MongoClientSettings.builder()` method and chain methods to specify your settings. After chaining them, use the `build()` method to create the`MongoClientSettings` object. The following table describes all the methods you can chain to modify your connection behavior:\n\n ### Example This example demonstrates specifying a `ConnectionString`: `| MongoClient mongoClient = MongoClients.create(                           |\n| ------------------------------------------------------------------------ |\n| MongoClientSettings.builder()                                            |\n| .applyConnectionString(new ConnectionString(\"<your connection string>\")) |\n| .build());                                                               | ` ## Tip Each setting has an `applyConnectionString()` method. They are rarely needed within the settings, so you should use this method as shown in [the preceding example.](#std-label-connection-string-example) ## Note ### Chain Order Some options in the settings map to a connection string option. If you specify the same options in your settings and connection string, the order you chain them determines which option the driver uses. The driver uses the **last** setting it reads. For example, this snippet contains settings with the following times for the driver to connect to an available socket: * The connection string specifies within `2 SECONDS`\n* The [socket settings](#std-label-mcs-socket-settings) specifies within`5 SECONDS` ```java MongoClient mongoClient = MongoClients.create(    MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"mongodb+srv:/<username>:<password>@<hostname>:<port>?connectTimeoutMS(2000)\"))       .applyToSocketSettings(builder ->       builder.connectTimeout(5, SECONDS))       .build()); \n``` Since the driver reads the socket settings options last, the driver expects to connect to an available socket within `5 SECONDS` before timing out. ## Tip ### Log Your Settings To log the `MongoClient` instance settings, set the `org.mongodb.driver.client` named logger to the `INFO` level. To learn more about logging with the MongoDB Java Driver, see the[Logging](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/logging/#std-label-java-fundamentals-logging) guide. ## Cluster Settings Chain the [applyToClusterSettings()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html#applyToClusterSettings%28com.mongodb.Block%29)method to modify the driver's behavior when interacting with your MongoDB cluster. The following table describes all the methods you can chain to your settings to modify the driver's behavior:\n\n ### Example This example specifies for the driver to connect directly to a server, regardless of the type of MongoDB cluster its' a part of: ```java MongoClient mongoClient = MongoClients.create(     MongoClientSettings.builder()     .applyToClusterSettings(builder ->         builder.mode(ClusterConnectionMode.SINGLE)     .build()); \n``` ## Tip This is analogous to the `directConnection` parameter you can specify in your connection URI. See [Connection Options](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connection-options/#std-label-connection-options) for more information. ## Socket Settings Chain the [applyToSocketSettings()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html#applyToSocketSettings%28com.mongodb.Block%29)method to modify the driver's behavior when connecting and communicating with your MongoDB server. The following table describes all the methods you can chain to your settings to modify the driver's behavior: | Method                  | Description                                                                                  |\n| ----------------------- | -------------------------------------------------------------------------------------------- |\n| applyConnectionString() | Uses the settings from a ConnectionString object.                                            |\n| applySettings()         | Uses the socket settings specified in a SocketSettings object.                               |\n| connectTimeout()        | Sets the maximum time to connect to an available socket before throwing a timeout exception. |\n| readTimeout()           | Sets the maximum time to read to an available socket before throwing a timeout exception.    |\n| receiveBufferSize()     | Sets the socket's buffer size when receiving.                                                |\n| sendBufferSize()        | Sets the socket's buffer size when sending.                                                  | ### Example This example specifies the following driver behavior in a MongoDB socket: * To connect to an available socket within `10 SECONDS`\n* To read from an available socket within `15 SECONDS` ```java MongoClient mongoClient = MongoClients.create(     MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"<your connection string>\"))     .applyToSocketSettings(builder ->         builder.connectTimeout(10, SECONDS)         .readTimeout(15, SECONDS))     .build()); \n``` ## Connection Pool Settings Chain the [applyToConnectionPoolSettings()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html#applyToConnectionPoolSettings%28com.mongodb.Block%29)method to modify the way the driver manages its connection pool. The following table describes all the methods you can chain to your settings to modify the driver's behavior:\n\n ## Note This `maxSize` and `minSize` settings apply to each server in the cluster you connect the driver to. For example, assume you connect the driver to a cluster with three`mongos` servers. This means that there can be at most `maxSize`connections and at least `minSize` connections to each `mongos` server. ### Example This example specifies the following driver behavior in a pool of`Connection` types: * The thread to wait at most `10 SECONDS` for an available connection\n* To have at most `200` connections associated with the pool ```java MongoClient mongoClient = MongoClients.create(     MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"<your connection string>\"))     .applyToConnectionPoolSettings(builder ->         builder.maxWaitTime(10, SECONDS)         .maxSize(200)     .build()); \n``` ## Server Settings Chain the [applyToServerSettings()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html#applyToServerSettings%28com.mongodb.Block%29)method to modify the driver's behavior when monitoring each MongoDB server. The following table describes all the methods you can chain to your settings to modify the driver's behavior: | Method                     | Description                                                           |\n| -------------------------- | --------------------------------------------------------------------- |\n| addServerListener()        | Adds a listener for server-related events.                            |\n| addServerMonitorListener() | Adds a listener for server monitor-related events.                    |\n| applyConnectionString()    | Uses the settings from a ConnectionString object.                     |\n| applySettings()            | Uses the server settings specified in a ServerSettings object.        |\n| heartbeatFrequency()       | Sets the interval for a cluster monitor to attempt reaching a server. |\n| minHeartbeatFrequency()    | Sets the minimum interval for server monitoring checks.               | ### Example This example specifies the following driver behavior in a MongoDB server: * The minimum interval for server monitoring checks to be at least`700 MILLISECONDS`\n* The cluster monitor to attempt reaching a server every `15 SECONDS` ```java MongoClient mongoClient = MongoClients.create(     MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"<your connection string>\"))     .applyToServerSettings(builder ->         builder.minHeartbeatFrequency(700, MILLISECONDS)         .heartbeatFrequency(15, SECONDS))     .build()); \n``` ## TLS/SSL Settings Chain the [applyToSslSettings()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoClientSettings.Builder.html#applyToSslSettings%28com.mongodb.Block%29)method to modify the driver's behavior when using TLS/SSL to secure a connection between your application and MongoDB. The following table describes all the methods you can chain to your settings to modify the driver's behavior:\n\n ### Example This example specifies for the driver to enable TLS/SSL when connecting to MongoDB: ```java MongoClient mongoClient = MongoClients.create(     MongoClientSettings.builder().applyConnectionString(new ConnectionString(\"<your connection string>\"))     .applyToSslSettings(builder ->         builder.enabled(true))     .build()); \n``` ← [Connection Options](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/connection-options/ \"Previous Section\")[Network Compression](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/connection/network-compression/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Updates Builders On this page * [Overview](#overview)\n* [Field Updates](#field-updates)\n* [Set](#set)\n* [Unset](#unset)\n* [Set On Insert](#set-on-insert)\n* [Increment](#increment)\n* [Multiply](#multiply)\n* [Rename](#rename)\n* [Min](#min)\n* [Max](#max)\n* [Current Date](#current-date)\n* [Current Timestamp](#current-timestamp)\n* [Bit](#bit)\n* [Array Updates](#array-updates)\n* [Add to Set](#add-to-set)\n* [Pop](#pop)\n* [Pull All](#pull-all)\n* [Pull](#pull)\n* [Push](#push)\n* [Combining Multiple Update Operators](#combining-multiple-update-operators) ## Overview In this guide, you can learn how to specify **updates** using[builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/) in the MongoDB Java driver. The `Updates` builder provides helper methods for the following types of updates: * [Field Updates](#std-label-field%5Fupdates)\n* [Array Updates](#std-label-array%5Fupdates)\n* [Combining Multiple Update Operators](#std-label-multiple%5Fupdates) Some methods that expect updates are: * `updateOne()`\n* `updateMany()`\n* `bulkWrite()` The `Updates` class provides static factory methods for all the MongoDB update operators. Each method returns an instance of the [BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/#std-label-bson)type, which you can pass to any method that expects an update argument. ## Tip For brevity, you may choose to import the methods of the [Updates](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html) class statically: `| import static com.mongodb.client.model.Updates.*; |\n| ------------------------------------------------- | ` The following examples assume this static import. The examples in this guide use the following document: ``` {     \"_id\": 1,     \"color\": \"red\",     \"qty\": 5,     \"vendor\": [ \"A\", \"D\", \"M\" ],     \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ## Field Updates ### Set Use the [set()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#set%28java.lang.String,TItem%29)method to assign the value of a field in an update operation. The following example sets the value of the `qty` field to \"11\": ```java Bson filter = eq(\"_id\", 1); Bson update = set(\"qty\", 11); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 11,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Unset Use the [unset()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#unset%28java.lang.String%29) method to delete the value of a field in an update operation. The following example deletes the `qty` field: ```java\n\n Bson update = unset(\"qty\"); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Set On Insert Use the [setOnInsert()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#setOnInsert%28java.lang.String,TItem%29)method to assign the value of a field in an update operation on an insert of a document. The following example sets the value of the `qty` field to \"5\" if an upsert resulted in the insert of a document: ```java Bson filter = eq(\"_id\", 1); Bson update = setOnInsert(\"qty\", 7); collection.updateOne(filter, update, new UpdateOptions().upsert(true)); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 5,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ## Note If the document is not inserted, no change will occur. ### Increment Use the [inc()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#inc%28java.lang.String,java.lang.Number%29)method to increment the value of a numeric field in an update operation. The following example increments the value of the `qty` field by \"3\": ```java Bson filter = eq(\"_id\", 1); Bson update = inc(\"qty\", 3); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 8,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Multiply Use the [mul()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#mul%28java.lang.String,java.lang.Number%29)method to multiply the value of a numeric field in an update operation. The following example multiplies the value of the `qty` field by \"2\": ```java Bson filter = eq(\"_id\", 1); Bson update = mul(\"qty\", 2); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 10,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Rename Use the [rename()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#rename%28java.lang.String,java.lang.String%29)method to rename the value of a field in an update operation. The following example renames the `qty` field to \"quantity\": ```java Bson filter = eq(\"_id\", 1); Bson update = rename(\"qty\", \"quantity\"); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {\n\n    \"color\": \"red\",    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" },    \"quantity\": 5 } \n``` ### Min Use the [min()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#min%28java.lang.String,TItem%29)method to update the value of a field with the smaller number of the two specified in an update operation. ```java Bson filter = eq(\"_id\", 1); Bson update = min(\"qty\", 2); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 2,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Max Use the [max()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#max%28java.lang.String,TItem%29)method to update the value of a field with the larger number of the two specified in an update operation. The following example sets the value of the `qty` field to the maximum of its current value and \"8\": ```java Bson filter = eq(\"_id\", 1); Bson update = max(\"qty\", 8); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 8,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Current Date Use the [currentDate()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#currentDate%28java.lang.String%29)method to assign the value of a field in an update operation to the current date as a [BSON date.](https://www.mongodb.com/docs/manual/reference/bson-types/#date) The following example sets the value of the `lastModified` field to the current date as a BSON date: ```java Bson filter = eq(\"_id\", 1); Bson update = currentDate(\"lastModified\"); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 5,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-22T21:01:20.027Z\" } } \n``` ### Current Timestamp Use the [currentTimestamp()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#currentTimestamp%28java.lang.String%29)method to assign the value of a field in an update operation to the current date as a [timestamp.](https://www.mongodb.com/docs/manual/reference/bson-types/#timestamps) The following example sets the value of the `lastModified` field to the current date as a BSON timestamp: ```java Bson filter = eq(\"_id\", 1); Bson update = currentTimestamp(\"lastModified\"); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,\n\n    \"qty\": 5,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$timestamp\": { \"t\": 1616446880, \"i\": 5 } } } \n``` ### Bit Use the [bitwiseOr()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#bitwiseOr%28java.lang.String,int%29),[bitwiseAnd()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#bitwiseAnd%28java.lang.String,int%29), and [bitwiseXor()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#bitwiseXor%28java.lang.String,int%29)methods to perform a bitwise update of the integer value of a field in an update operation. The following example performs a bitwise `AND` between the number \"10\" and the integer value of the `qty` field: ```java Bson filter = eq(\"_id\", 1); Bson update = bitwiseOr(\"qty\", 10); collection.updateOne(filter, update); \n``` The bitwise operation results in 15: ``` 0101 1010 ---- 1111 \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 15,    \"vendor\": [ \"A\", \"D\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ## Array Updates ### Add to Set Use the [addToSet()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#addToSet%28java.lang.String,TItem%29)method to append a value to an array if the value is not already present in an update operation. The following example adds the value \"C\" to the array value of the `vendor` field: ```java Bson filter = eq(\"_id\", 1); Bson update = addToSet(\"vendor\", \"C\"); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 5,    \"vendor\": [ \"A\", \"D\", \"M\", \"C\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Pop Use the [popFirst()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#popFirst%28java.lang.String%29)method to remove the first element of an array and the[popLast()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#popLast%28java.lang.String%29)method to remove the last element of an array in an update operation. The following example pops the first element off of the array value of the `vendor` field: ```java Bson filter = eq(\"_id\", 1); Bson update = popFirst(\"vendor\"); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 5,    \"vendor\": [ \"D\", \"M\" ],\n\n } \n``` ### Pull All Use the [pullAll()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#pullAll%28java.lang.String,java.util.List%29)method to remove all instances of values from an existing array in an update operation. The following example removes vendor \"A\" and \"M\" from the `vendor` array: ```java Bson filter = eq(\"_id\", 1); Bson update = pullAll(\"vendor\", Arrays.asList(\"A\", \"M\")); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 5,    \"vendor\": [ \"D\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Pull Use the [pull()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#pull%28java.lang.String,TItem%29)method to remove all instances of a value from an existing array in an update operation. The following example removes the value \"D\" from the `vendor`array: ```java Bson filter = eq(\"_id\", 1); Bson update = pull(\"vendor\", \"D\"); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 5,    \"vendor\": [ \"A\", \"M\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ### Push Use the [push()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#push%28java.lang.String,TItem%29)method to append a value to an array in an update operation. The following examples pushes \"C\" to the `vendor` array: ```java Bson filter = eq(\"_id\", 1); Bson update = push(\"vendor\", \"C\"); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"red\",    \"qty\": 5,    \"vendor\": [ \"A\", \"D\", \"M\", \"C\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ## Combining Multiple Update Operators An application can update multiple fields of a single document by combining two or more of the update operators described in the preceding sections. The following example increments the value of the `qty` field by \"6\", sets the value of the `color` field to \"purple\", and pushes \"R\" to the `vendor` field: ```java Bson filter = eq(\"_id\", 1); Bson update = combine(set(\"color\", \"purple\"), inc(\"qty\", 6), push(\"vendor\", \"R\")); collection.updateOne(filter, update); \n``` The preceding example updates the original document to the following state: ``` {    \"_id\": 1,    \"color\": \"purple\",    \"qty\": 11,    \"vendor\": [ \"A\", \"D\", \"M\", \"R\" ],    \"lastModified\": { \"$date\": \"2021-03-05T05:00:00Z\" } } \n``` ← [Sorts Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/sort/ \"Previous Section\")[Aggregation](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/aggregation/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/query-document/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Specify a Query On this page * [Overview](#overview)\n* [Comparison Operators](#comparison-operators)\n* [Logical Operators](#logical-operators)\n* [Array Operators](#array-operators)\n* [Element Operators](#element-operators)\n* [Evaluation Operators](#evaluation-operators) ## Overview In this guide, you can learn how to specify a query in the MongoDB Java driver. Most CRUD operations allow you to narrow the set of matched documents by specifying matching criteria in a **query filter**. Query filters contain one or more query operators that apply to specific fields which determine which documents to include in the result set. In this page, we cover the following query operators with examples on how to use them: * [Comparison Operators](#std-label-query-comparison)\n* [Logical Operators](#std-label-query-logical)\n* [Array Operators](#std-label-query-arrays)\n* [Element Operators](#std-label-query-elements)\n* [Evaluation Operators](#std-label-query-evaluation) The examples in this guide use the following documents in the`paint_purchases` collection: `| { \"_id\": 1, \"color\": \"red\", \"qty\": 9, \"vendor\": [\"A\", \"E\"] }                      |\n| --------------------------------------------------------------------------------- |\n| { \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 } |\n| { \"_id\": 3, \"color\": \"blue\", \"qty\": 5, \"vendor\": [\"A\", \"E\"] }                     |\n| { \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"], \"rating\": 9 }            |\n| { \"_id\": 5, \"color\": \"yellow\", \"qty\": 4, \"vendor\": [\"A\", \"B\"] }                   |\n| { \"_id\": 6, \"color\": \"pink\", \"qty\": 3, \"vendor\": [\"C\"] }                          |\n| { \"_id\": 7, \"color\": \"green\", \"qty\": 8, \"vendor\": [\"C\", \"E\"], \"rating\": 7 }       |\n| { \"_id\": 8, \"color\": \"black\", \"qty\": 7, \"vendor\": [\"A\", \"C\", \"D\"] }               | ` ## Comparison Operators Comparison operators query data based on comparisons with values in a collection. Common comparison operators include `gt()` for \"greater than\" comparisons, `lte()` for \"less than or equal to\" comparisons, and `ne()` for \"not equal to \" comparisons. The following example uses the `Filters.gt()` method to match all documents where the value of `qty` is greater than `7` in the`paint_purchases` collection: ```java Bson filter = Filters.gt(\"qty\", 7); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ```  { \"_id\": 1, \"color\": \"red\", \"qty\": 9, \"vendor\": [\"A\", \"E\"] }  { \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 }  { \"_id\": 7, \"color\": \"green\", \"qty\": 8, \"vendor\": [\"C\", \"E\"], \"rating\": 7 } \n``` ## Logical Operators\n\n The following example uses the `Filters.and()` method to match documents where the value of `qty` is less than or equal to `5` and the value of `color` is not `\"pink\"` in the `paint_purchases`collection: ```java Bson filter = Filters.and(Filters.lte(\"qty\", 5), Filters.ne(\"color\", \"pink\")); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ```  { \"_id\": 3, \"color\": \"blue\", \"qty\": 5, \"vendor\": [\"A\", \"E\"] }  { \"_id\": 5, \"color\": \"yellow\", \"qty\": 4, \"vendor\": [\"A\", \"B\"] } \n``` ## Array Operators Array operators query data based on the value or quantity of elements in an array field. The following example uses the `Filters.size()` method to match documents where the size of the `vendor` list is `3` in the`paint_purchases` collection: ```java Bson filter = Filters.size(\"vendor\", 3); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ```  { \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 }  { \"_id\": 8, \"color\": \"black\", \"qty\": 7, \"vendor\": [\"A\", \"C\", \"D\"] } \n``` ## Element Operators Element operators query data based on the presence or type of a field. The following example uses the `Filters.exists()` method to match documents that have a `rating` in the `paint_purchases` collection: ```java Bson filter = Filters.exists(\"rating\"); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ```  { \"_id\": 2, \"color\": \"purple\", \"qty\": 8, \"vendor\": [\"B\", \"D\", \"F\"], \"rating\": 5 }  { \"_id\": 4, \"color\": \"white\", \"qty\": 6, \"vendor\": [\"D\"], \"rating\": 9 }  { \"_id\": 7, \"color\": \"green\", \"qty\": 8, \"vendor\": [\"C\", \"E\"], \"rating\": 7 } \n``` ## Evaluation Operators Evaluation operators query data on higher level logic, like regex and text searches. The following example uses the `Filters.regex()` method to match documents that have a `color` ending with the letter `\"k\"` in the`paint_purchases` collection: ```java Bson filter = Filters.regex(\"color\", \"k$\"); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding query: ```  { \"_id\": 6, \"color\": \"pink\", \"qty\": 3, \"vendor\": [\"C\"] }  { \"_id\": 8, \"color\": \"black\", \"qty\": 7, \"vendor\": [\"A\", \"C\", \"D\"] } \n``` For more information about the operators mentioned in this guide, see the following Server Manual Entries: * [Query Operators](https://www.mongodb.com/docs/manual/reference/operator/query/)\n* [Comparison Operators](https://www.mongodb.com/docs/manual/reference/operator/query-comparison/)\n* [Logical Operators](https://www.mongodb.com/docs/manual/reference/operator/query-logical/)\n* [Array Operators](https://www.mongodb.com/docs/manual/reference/operator/query-array/)\n* [Element Operators](https://www.mongodb.com/docs/manual/reference/operator/query-element/)\n* [Evaluation Operators](https://www.mongodb.com/docs/manual/reference/operator/query-evaluation/)\n\n",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Read Operations * [Retrieve Data](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/retrieve/)\n* [Access Data From a Cursor](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/cursor/)\n* [Open Change Streams](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/change-streams/)\n* [Sort Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/)\n* [Skip Returned Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/skip/)\n* [Limit the Number of Returned Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/limit/)\n* [Specify Which Fields to Return](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/project/)\n* [Search Geospatially](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/geo/)\n* [Search Text](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/text/) ← [CRUD Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/ \"Previous Section\")[Retrieve Data](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/retrieve/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Write Operations * [Insert Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/insert/)\n* [Delete a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/delete/)\n* [Change a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/change-a-document/)\n* [Update Arrays in a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/embedded-arrays/)\n* [Insert or Update in a Single Operation](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/upsert/)\n* [Bulk Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/bulk/) ← [Search Text](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/text/ \"Previous Section\")[Insert Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/insert/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/compound-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Compound Operations On this page * [Overview](#overview)\n* [How to Use Compound Operations](#how-to-use-compound-operations)\n* [Find and Update](#find-and-update)\n* [Find and Replace](#find-and-replace)\n* [Find and Delete](#find-and-delete)\n* [Avoiding a Race Condition](#avoiding-a-race-condition)\n* [Example With Race Condition](#example-with-race-condition)\n* [Example Without Race Condition](#example-without-race-condition) ## Overview In this guide, you can learn how to perform **compound operations** with the MongoDB Java driver. Compound operations consist of a read and write operation performed as one**atomic operation**. An atomic operation is an operation which either completes entirely, or does not complete at all. Atomic operations cannot partially complete. Atomic operations can help you avoid **race conditions** in your code. A race condition occurs when your code's behavior is dependent on the order of uncontrollable events. MongoDB supports the following compound operations: * Find and update one document\n* Find and replace one document\n* Find and delete one document If you need to perform more complex tasks atomically, such as reading and writing to more than one document, use **transactions**. Transactions are a feature of MongoDB and other databases that lets you define an arbitrary sequence of database commands as an atomic operation. For more information on atomic operations and atomicity, see[the MongoDB manual entry for atomicity and transactions.](https://www.mongodb.com/docs/manual/core/write-operations-atomicity/) For more information on transactions,[see the MongoDB manual entry for transactions.](https://www.mongodb.com/docs/manual/core/transactions/) ## How to Use Compound Operations This section shows how to use each compound operation with the MongoDB Java Driver. The following examples use a collection containing these two sample documents. `| {\"_id\": 1, \"food\": \"donut\", \"color\": \"green\"} |\n| --------------------------------------------- |\n| {\"_id\": 2, \"food\": \"pear\", \"color\": \"yellow\"} | ` [The full code for the following examples is available on Github here.](https://github.com/mongodb/docs-java/blob/master/source/includes/fundamentals/code-snippets/CompoundOperatorsIndividualExamples.java) ## Note ### Before or After the Write? By default, each compound operation returns your found document in the state before your write operation. You can retrieve your found document in the state after your write operation by using the options class corresponding to your compound operation. You can see an example of this configuration in the[Find and Replace example below.](#std-label-java-find-and-replace-example) ### Find and Update To find and update one document, use the `findOneAndUpdate()` method of the`MongoCollection` class. The `findOneAndUpdate()` method returns your found document or `null` if no documents match your query. #### Example The following example uses the `findOneAndUpdate()` method to find a document with the `color` field set to `\"green\"` and update the`food` field in that document to `\"pizza\"`. The example also uses a `FindOneAndUpdateOptions` instance to specify the following options: * Exclude the `_id` field from the found document with a projection.\n* Specify an upsert, which inserts the document specified by the query filter if no documents match the query.\n* Set a maximum execution time of 5 seconds for this operation on the MongoDB instance. If the operation takes longer, the `findOneAndUpdate()` method will throw a `MongoExecutionTimeoutException`. ```java // <MongoCollection set up code here> Bson projection = Projections.excludeId(); Bson filter = Filters.eq(\"color\", \"green\"); Bson update = Updates.set(\"food\", \"pizza\"); FindOneAndUpdateOptions options = new FindOneAndUpdateOptions().         projection(projection).         upsert(true).         maxTime(5, TimeUnit.SECONDS); /* The result variable contains your document in the    state before your update operation is performed. */\n\n System.out.println(result.toJson()); \n``` The output of the preceding code should look like this: ``` {\"food\": \"donut\", \"color\": \"green\"} \n``` For more information on the `Projections` class, see our[guide on the Projections builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/projections/) For more information on the upsert operation, see our[guide on upserts.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/upsert/) For more information about the methods and classes mentioned in this section, see the following API Documentation: * [findOneAndUpdate()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#findOneAndUpdate%28org.bson.conversions.Bson,java.util.List,com.mongodb.client.model.FindOneAndUpdateOptions%29)\n* [FindOneAndUpdateOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/FindOneAndUpdateOptions.html)\n* [MongoExecutionTimeoutException](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/MongoExecutionTimeoutException.html) ### Find and Replace To find and replace one document, use the `findOneAndReplace()` method of the`MongoCollection` class. The `findOneAndReplace()` method returns your found document or `null` if no documents match your query. #### Example The following example uses the `findOneAndReplace()` method to find a document with the `color` field set to `\"green\"` and replace it with the following document: ``` {\"music\": \"classical\", \"color\": \"green\"} \n``` The example also uses a `FindOneAndReplaceOptions` instance to specify that the returned document should be in the state after our replace operation. ```java // <MongoCollection set up code here> Bson filter = Filters.eq(\"color\", \"green\"); Document replace = new Document(\"music\", \"classical\").append(\"color\", \"green\"); FindOneAndReplaceOptions options = new FindOneAndReplaceOptions().         returnDocument(ReturnDocument.AFTER); Document result = collection.findOneAndReplace(filter, replace, options); System.out.println(result.toJson()); \n``` The output of the preceding code should look like this: ``` {\"_id\": 1, \"music\": \"classical\", \"color\": \"green\"} \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [findOneAndReplace()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#findOneAndReplace%28org.bson.conversions.Bson,TDocument,com.mongodb.client.model.FindOneAndReplaceOptions%29)\n* [FindOneAndReplaceOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/FindOneAndReplaceOptions.html) ### Find and Delete To find and delete one document, use the `findOneAndDelete()` method of the`MongoCollection` class. The `findOneAndDelete()` method returns your found document or `null` if no documents match your query. #### Example The following example uses the `findOneAndDelete()` method to find and delete the document with the largest value in the `_id` field. The example uses a `FindOneAndDeleteOptions` instance to specify a descending sort on the `_id` field. ```java // <MongoCollection set up code here> Bson sort = Sorts.descending(\"_id\"); Bson filter = Filters.empty(); FindOneAndDeleteOptions options = new FindOneAndDeleteOptions().\n\n Document result = collection.findOneAndDelete(filter, options); System.out.println(result.toJson()); \n``` The output of the preceding code should look like this: ``` {\"_id\": 2, \"food\": \"pear\", \"color\": \"yellow\"} \n``` For more information on the `Sorts` class, see our[guide on the Sorts builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/sort/) For more information about the methods and classes mentioned in this section, see the following API Documentation: * [findOneAndDelete()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#findOneAndDelete%28org.bson.conversions.Bson,com.mongodb.client.model.FindOneAndDeleteOptions%29)\n* [FindOneAndDeleteOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/FindOneAndDeleteOptions.html) ## Avoiding a Race Condition In this section we explore two examples. The first example contains a race condition, the second example uses a compound operation to avoid the race condition present in the first example. For both examples, let's imagine that we run a hotel with one room and that we have a small Java program to help us checkout this room to a guest. The following document in MongoDB represents the room: ```  {\"_id\": 1, \"guest\": null, \"room\": \"Blue Room\", \"reserved\": false} \n``` [The full code for this example is available on Github here.](https://github.com/mongodb/docs-java/blob/master/source/includes/fundamentals/code-snippets/CompoundOperators.java) ### Example With Race Condition Let's say our app uses this `bookARoom` method to checkout our room to a guest: ```java public void bookARoom() {     Bson filter = Filters.eq(\"reserved\", false);     Document myRoom = this.collection.find(filter).first();     if (myRoom == null){         System.out.println(\"Sorry, we are booked \" + this.guest);         return;     }     String myRoomName = myRoom.getString(\"room\");     System.out.println(\"You got the \" + myRoomName + \" \" + this.guest);     Bson update = Updates.combine(Updates.set(\"reserved\", true), Updates.set(\"guest\", guest));     Bson roomFilter = Filters.eq(\"_id\", myRoom.get(\"_id\", Integer.class));     this.collection.updateOne(roomFilter, update); } \n``` Imagine two separate guests, Jan and Pat, try to book the room with this method at the same time. Jan sees this output: ``` You got the Blue Room Jan \n``` And Pat sees this output: ``` You got the Blue Room Pat \n``` When we look at our database, we see the following: ```  {\"_id\": 1, \"guest\": \"Jan\", \"room\": \"Blue Room\", \"reserved\": true} \n``` Pat will be unhappy. When Pat shows up to our hotel, Jan will be occupying her room. What went wrong? Here is the sequence of events that happened from the perspective of our MongoDB instance: * Find and return an empty room for Jan\n* Find and return an empty room for Pat\n* Update the room to booked for Pat\n* Update the room to booked for Jan Notice that for a brief moment Pat had reserved the room, but as Jan's update operation was the last to execute our document has `\"Jan\"` as the guest. ### Example Without Race Condition Let's use a compound operation to avoid the race condition and always give our users the correct message. ```java public void bookARoom(){     Bson update = Updates.combine(Updates.set(\"reserved\", true), Updates.set(\"guest\", guest));     Bson filter = Filters.eq(\"reserved\", false);     Document myRoom = this.collection.findOneAndUpdate(filter, update);\n\n         System.out.println(\"Sorry, we are booked \" + this.guest);         return;     }     String myRoomName = myRoom.getString(\"room\");     System.out.println(\"You got the \" + myRoomName + \" \" + this.guest); } \n``` Imagine two separate guests, Jan and Pat, try to book the room with this method at the same time. Jan sees this output: ``` You got the Blue Room Jan \n``` And Pat sees this output: ``` Sorry, we are booked Pat \n``` When we look at our database, we see the following: ```  {\"_id\":1, \"guest\":\"Jan\", \"room\":\"Blue Room\", \"reserved\":true} \n``` Pat got the correct message. While she might be sad she didn't get the reservation, at least she knows not to travel to our hotel. Here is the sequence of events that happened from the perspective of our MongoDB instance: * Find an empty room for Jan and reserve it.\n* Try to find an empty room for Pat and reserve it. As there are not any rooms left, return `null`. ## Important ### Write Lock Your MongoDB instance places a write lock on the document you are modifying for the duration of your compound operation. For information on the `Updates` class, see our[guide on the Updates builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/) For more information of the `Filters` class, see our[guide on the Filters builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/) For more information on the `findOneAndUpdate()` method, see the API Documentation for the [MongoCollection class.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#findOneAndUpdate%28org.bson.conversions.Bson,java.util.List,com.mongodb.client.model.FindOneAndUpdateOptions%29) ← [Specify a Query](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/query-document/ \"Previous Section\")[Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/skip/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Skip Returned Results On this page * [Overview](#overview)\n* [Examples](#examples)\n* [Using a FindIterable](#using-a-finditerable)\n* [Using Aggregation](#using-aggregation) ## Overview In this guide, you can learn how to skip a specified number of returned results from read operations with the MongoDB Java driver. You can skip results on the returned results of a query by using the`skip()` method. You can also skip documents at a specific stage in an aggregation pipeline by specifying a `$skip` aggregation stage. The `skip()` method takes an integer that specifies the number of documents to omit from the beginning of the list of documents returned by the[FindIterable.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#skip%28int%29) You can use the `skip()` method to skip the first two documents as follows: `| collection.find().skip(2); |\n| -------------------------- | ` [Aggregates.skip()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html#skip%28int%29)is an optional stage in the aggregation pipeline that specifies how many documents to omit from the beginning of the results of the prior stage. You can use the `Aggregates.skip()` method to skip the first two documents as follows: ```java import com.mongodb.client.model.Aggregates; collection.aggregate(Arrays.asList(Aggregates.match(), Aggregates.skip(2))); \n``` ## Examples The following example is about a paint store that sells eight different colors of paint. The best colors sell quicker than the other colors. One day, a customer asks what the three best-selling (lowest inventory) colors are. The paint store keeps track of inventory in the `qty`field in their `paint_inventory` collection: ``` { \"_id\": 1, \"color\": \"red\", \"qty\": 5 } { \"_id\": 2, \"color\": \"purple\", \"qty\": 10 } { \"_id\": 3, \"color\": \"blue\", \"qty\": 9 } { \"_id\": 4, \"color\": \"white\", \"qty\": 6 } { \"_id\": 5, \"color\": \"yellow\", \"qty\": 11 } { \"_id\": 6, \"color\": \"pink\", \"qty\": 3 } { \"_id\": 7, \"color\": \"green\", \"qty\": 8 } { \"_id\": 8, \"color\": \"orange\", \"qty\": 7 } \n``` To address the scenario, the paint store needs to query the`paint_inventory` collection with an empty filter, sort the documents by `qty` field and omit the first five results. ### Using a FindIterable ```java import com.mongodb.client.model.Filters; import com.mongodb.client.model.Sorts; // <MongoCollection setup code here> Bson filter = Filters.empty(); collection.find(filter)                  .sort(Sorts.descending(\"qty\"))             .skip(5)                            .forEach(doc -> System.out.println(doc.toJson())); \n``` * The `find()` method returns all documents.\n* The `sort()` method specifies documents to display from highest to lowest based on the `qty` field.\n* The `skip()` method specifies to omit the first five documents. ### Using Aggregation ```java import com.mongodb.client.model.Filters; import com.mongodb.client.model.Sorts; import com.mongodb.client.model.Aggregates; // <MongoCollection setup code here> Bson filter = Filters.empty(); collection.aggregate(Arrays.asList(\n\n     Aggregates.sort(Sorts.descending(\"qty\")),      Aggregates.skip(5)))     .forEach(doc -> System.out.println(doc.toJson()));  \n``` * The `match()` stage returns all documents.\n* The `sort()` stage specifies documents to display from highest to lowest based on the `qty` field.\n* The `skip()` stage specifies to omit the first five documents. The following shows the output of both preceding queries: ``` { \"_id\": 4, \"color\": \"white\", \"qty\": 6 } { \"_id\": 1, \"color\": \"red\", \"qty\": 5 } { \"_id\": 6, \"color\": \"pink\", \"qty\": 3 } \n``` After the paint store runs the query, they find the three best-selling colors are pink, red, and white. ## Note If the value of skip is greater than or equal to the number of matched documents for a query, that query returns no documents. If the `skip()` method from the preceding example skips the first nine documents, no results would return since the specified quantity exceeds the number of matched documents. ```java Bson filter = Filters.empty(); collection.find(filter)                  .sort(Sorts.descending(\"qty\"))             .skip(9)                            .forEach(doc -> System.out.println(doc.toJson())); \n``` ← [Sort Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/ \"Previous Section\")[Limit the Number of Returned Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/limit/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/limit/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Limit the Number of Returned Results On this page * [Overview](#overview)\n* [Specify a Limit](#specify-a-limit)\n* [Combining Skip and Limit](#combining-skip-and-limit) ## Overview In this guide, you can learn how to limit the number of results returned from read operations with the MongoDB Java driver. Use `limit()` to cap the number of documents that a read operation returns. This instance method designates the maximum number of documents that a read operation can return. If there are not enough documents to reach the specified limit, it can return a smaller number. If you use `limit()` with the `skip()` instance method, the skip applies first and the limit only applies to the documents left over after the skip. For more information on the `skip()` method, see our[guide on Skipping Returned Documents.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/skip/) The following examples demonstrate, respectively, how to insert data into a collection, how to use `limit()` to restrict the number of returned documents, and how to combine `limit()` with `skip()` to further narrow the results returned from a query. ### Sample Documents The following operation inserts documents representing books into a collection:\n\n ` ## Specify a Limit The next example queries the collection to return the top three longest books. It first matches all the documents with the query, then sorts on the`length` field to return books with longer lengths before books with shorter lengths. Lastly, it limits the return value to `3` documents: ```java import com.mongodb.client.model.Sorts; // define a cursor that will return the first 3 sorted items MongoCursor<Document> cursor = collection.find()     .sort(descending(\"length\"))     .limit(3)     .iterator(); // print out items try {     while (cursor.hasNext()) {         System.out.println(cursor.next());     } } // close the cursor finally {     cursor.close(); } \n``` The preceding code example prints out the following three documents, sorted by length: ```java  Document{{_id=2, title=Les Misérables, author=Hugo, length=1462}}  Document{{_id=6, title=A Dance with Dragons, author=Martin, length=1104}}  Document{{_id=4, title=Infinite Jest, author=Wallace, length=1104}} \n``` ## Tip The order in which you call `limit()` and `sort()` does not matter because the driver reorders the calls to apply the sort first and the limit after it. The following two calls are equivalent: ```java collection.find().sort(descending(\"length\")).limit(3); collection.find().limit(3).sort(descending(\"length\")); \n``` ## Combining Skip and Limit To see the next three longest books, append the `skip()` method to your`find()` call. The integer argument passed to `skip()` will determine how many documents the find operation returns: ```java MongoCursor<Document> cursor = collection.find()     .sort(ascending(\"length\"))     .limit(3)     .skip(3)     .iterator(); \n``` This operation returns the documents that describe the fourth through sixth longest books: ```java Document{{_id=3, title=Atlas Shrugged, author=Rand, length=1088}} Document{{_id=5, title=Cryptonomicon, author=Stephenson, length=918}} Document{{_id=1, title=The Brothers Karamazov, author=Dostoyevsky, length=824}} \n``` You can combine `skip()` and `limit()` in this way to implement paging for your collection, returning only small subsets of the collection at one time. ## Note In order to ensure stable sorts across multiple queries, you must sort using a unique key (such as `_id`). Otherwise, a call to `skip()`and `limit()` may produce unpredictable results when combined with`sort()`. For example, consider the following data: ```java { type: \"computer\", data: \"1\", serial_no: 235235 } { type: \"computer\", data: \"2\", serial_no: 235237 } { type: \"computer\", data: \"3\", serial_no: 235239 } { type: \"computer\", data: \"4\", serial_no: 235241 } \n``` If you sorted by `type` alone, `sort()` does not guarantee the same order upon return. Appending `skip()` and `limit()` to the `sort()`could return different documents for different queries. In this case, sorting by `data` or `serial_no` would guarantee a stable sort, as both are unique keys. For more information about the methods and classes mentioned in this guide, see the following API Documentation:\n\n ← [Skip Returned Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/skip/ \"Previous Section\")[Specify Which Fields to Return](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/project/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/retrieve/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Retrieve Data On this page * [Overview](#overview)\n* [Find Operation](#find-operation)\n* [Aggregate Operation](#aggregate-operation) ## Overview In this guide, you can learn how to retrieve data from your MongoDB database. To retrieve data, use read operations. Read operations allow you to do the following: * Retrieve a subset of documents from your collection using a [find operation](#std-label-retrieve-find)\n* Perform transformations on retrieved documents from your collection using an [aggregate operation](#std-label-retrieve-aggregate)\n* Monitor real-time changes to your database using [change streams](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/change-streams/#std-label-retrieve-watch) ### Sample Data for Examples The following sections feature examples of how the owner of a paint store manages their customers' orders. For each order, the owner keeps track of the color and quantity, which corresponds to the `color` and`qty` fields in their `paint_order` collection: `| { \"_id\": 1, \"color\": \"purple\", \"qty\": 10 } |\n| ------------------------------------------ |\n| { \"_id\": 2, \"color\": \"green\", \"qty\": 8 }   |\n| { \"_id\": 3, \"color\": \"purple\", \"qty\": 4 }  |\n| { \"_id\": 4, \"color\": \"green\", \"qty\": 11 }  | ` ## Find Operation Use the find operation to retrieve a subset of your existing data in MongoDB. You can specify what data to return including which documents to retrieve, in what order to retrieve them, and how many to retrieve. To perform a find operation, call the `find()` method on an instance of a `MongoCollection`. This method searches a collection for documents that match the query filter you provide. For more information on how to specify a query, see our [Specify a Query](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/query-document/) guide. ### Example The owner would like to know which orders contain greater than three, but less than nine cans of paint from their [paint\\_order collection.](#std-label-retrieve-paint-order-collection) To address this scenario, the owner finds orders to match the criteria: ```java Bson filter = Filters.and(Filters.gt(\"qty\", 3), Filters.lt(\"qty\", 9)); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` For more information on how to build filters, see our [Filters Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/) guide. The following shows the output of the preceding query: ``` { \"_id\": 2, \"color\": \"green\", \"qty\": 8 } { \"_id\": 3, \"color\": \"purple\", \"qty\": 4 } \n``` After the owner runs this query, they find two orders that matched the criteria. For a runnable `find()` example, see our [Find Multiple Documents](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/find/) page. ## Aggregate Operation Use the aggregate operation to perform the stages in an aggregation pipeline. An aggregation pipeline is a multi-staged transformation that produces an aggregated result. To perform an aggregate operation, call the `aggregate()` method on an instance of a `MongoCollection`. This method accepts aggregation expressions to run in sequence. To perform aggregations, you can define aggregation stages that specify how to match documents, rename fields, and group values. For more information, see our[Aggregation](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/aggregation/) guide. ### Example The owner would like to know which paint color is the most purchased (highest quantity sold) from their [paint\\_order collection.](#std-label-retrieve-paint-order-collection) To address the scenario, the owner creates an aggregation pipeline that: * Matches all the documents in the `paint_order` collection\n* Groups orders by colors\n* Sums up the quantity field by color\n* Orders the results by highest-to-lowest quantity ```java Bson filter = Filters.empty();\n\n     Aggregates.match(filter),      Aggregates.group(\"$color\", Accumulators.sum(\"qty\", \"$qty\")),     Aggregates.sort(Sorts.descending(\"qty\"))))     .forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding aggregation: ``` { \"_id\": \"green\", \"qty\": 19 } { \"_id\": \"purple\", \"qty\": 14 } \n``` After the owner runs the aggregation, they find that \"green\" is the most purchased color. For more information on how to construct an aggregation pipeline, see the MongoDB server manual page on [Aggregation.](https://www.mongodb.com/docs/manual/aggregation/) For additional information on the methods mentioned on this page, see the following API Documentation: * [MongoCollection.find()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#find%28%29)\n* [MongoCollection.aggregate()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#aggregate%28java.util.List%29) ← [Read Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/ \"Previous Section\")[Access Data From a Cursor](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/cursor/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/text/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Search Text On this page * [Overview](#overview)\n* [Sample Documents](#sample-documents)\n* [Text Index](#text-index)\n* [Text Search](#text-search)\n* [Specify Options](#specify-options)\n* [Search Text by a Term](#search-text-by-a-term)\n* [Search Text by a Phrase](#search-text-by-a-phrase)\n* [Search Text with Terms Excluded](#search-text-with-terms-excluded) ## Overview In this guide, you can learn how to run a **text search** in the MongoDB Java driver. You can use a text search to retrieve documents that contain a **term**or a **phrase** in a specified field. A term is a sequence of characters that excludes whitespace characters. A phrase is a sequence of terms with any number of whitespace characters. The following sections show you how to perform the following types of text searches: * Search Text by a Term\n* Search Text by a Phrase\n* Search Text with Terms Excluded If you want to sort your text search results, see the [Text Search](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/#std-label-sorts-crud-text-search) section of our Sort Results guide. ### Sample Documents The following sections feature examples of text searches on the`fast_and_furious_movies` collection. Each section uses a variable named `collection` to refer to the `MongoCollection` instance of the`fast_and_furious_movies` collection. The `fast_and_furious_movies` collection contains documents that describe one of the several movies that are part of the Fast and Furious movie franchise. Each document contains a title field and a tags field. `| { \"_id\": 1, \"title\": \"2 Fast 2 Furious \", \"tags\": [\"undercover\", \"drug dealer\"] } |\n| --------------------------------------------------------------------------------- |\n| { \"_id\": 2, \"title\": \"Fast 5\", \"tags\": [\"bank robbery\", \"full team\"] }            |\n| { \"_id\": 3, \"title\": \"Furious 7\", \"tags\": [\"emotional\"] }                         |\n| { \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] }            | ` ### Text Index You must create a **text index** before running a text search. A text index specifies the string or string array field on which to run a text search. In the following examples, you run text searches on the `title`field in the `fast_and_furious_movies` collection. To enable text searches on the `title` field, create a text index using the[Indexes](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/indexes/#std-label-index-text-indexes) builder with the following snippet: ```java collection.createIndex(Indexes.text(\"title\")); \n``` For more information, see the following resources: * [Text Indexes](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/indexes/#std-label-text-indexes) section of our Indexes guide\n* [Text Indexes](https://www.mongodb.com/docs/manual/core/index-text/) Server Manual Entry ## Text Search Use the `Filters.text()` method to specify a text search. The `Filters.text()` method uses the [Filters builder](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/) to define a query filter specifying what to search for during the text search. The query filter is represented by a [BSON](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/document-data-format-bson/#std-label-bson) instance. Pass the query filter to the`find()` method to run a text search.\n\n ### Specify Options You can include `TextSearchOptions` as the second parameter of the`Filters.text()` method to specify text search options such as case sensitivity. By default, text searches run without case sensitivity which means the search matches lowercase and uppercase values. To specify a case sensitive search, use the following snippet: ```java TextSearchOptions options = new TextSearchOptions().caseSensitive(true); Bson filter = Filters.text(\"SomeText\", options); \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [Filters.text()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Filters.html#text%28java.lang.String%29)\n* [TextSearchOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/TextSearchOptions.html) ### Search Text by a Term Pass a term as a string to the `Filters.text()` method to specify the term in your text search. #### Example The following example runs a text search on the documents in the`fast_and_furious_movies` collection for titles that contain the term \"fast\": ```java Bson filter = Filters.text(\"fast\"); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding code: ``` { \"_id\": 1, \"title\": \"2 Fast 2 Furious \", \"tags\": [\"undercover\", \"drug dealer\"] } { \"_id\": 2, \"title\": \"Fast 5\", \"tags\": [\"bank robbery\", \"full team\"] } \n``` To match multiple terms in your text search, separate each term with spaces in the `Filters.text()` builder method. The builder method returns the text search query as a `Bson` instance. When you pass this to the `find()` method, it returns documents that match any of the terms. #### Example The following example runs a text search on the documents in the`fast_and_furious_movies` collection for titles that contain the terms \"fate\" or \"7\": ```java Bson filter = Filters.text(\"fate 7\"); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding code: ``` { \"_id\": 3, \"title\": \"Furious 7\", \"tags\": [\"emotional\"] } { \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] } \n``` ### Search Text by a Phrase Pass a phrase with **escaped quotes** to the `Filters.text()` method to specify the phrase in your text search. Escaped quotes are double quote characters preceded by a backslash character. If you don't add escaped quotes around the phrase, the `find()` method runs a [term search.](#std-label-term%5Fsearch) #### Example The following example runs a text search on the documents in the`fast_and_furious_movies` collection for titles that contain the phrase \"fate of the furious\": ```java Bson filter = Filters.text(\"\\\"fate of the furious\\\"\"); collection.find(filter).forEach(doc -> System.out.println(doc.toJson())); \n``` The following shows the output of the preceding code: ``` { \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] } \n``` ### Search Text with Terms Excluded For each term you want to exclude from your text search, prefix the term with a minus sign in the string that you pass to the `Filters.text()`builder method. None of the documents returned from the search contain the excluded term in your text index field. ## Important You must have at least one text search term if you want to exclude terms from your search. #### Example The following example runs a text search on the documents in the`fast_and_furious_movies` collection for titles that contain the term \"furious\", but do not contain the term \"fast\": ```java Bson filter = Filters.text(\"furious -fast\");\n\n \n``` The following shows the output of the preceding code: ``` { \"_id\": 3, \"title\": \"Furious 7\", \"tags\": [\"emotional\"] } { \"_id\": 4, \"title\": \"The Fate of the Furious\", \"tags\": [\"betrayal\"] } \n``` ← [Search Geospatially](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/geo/ \"Previous Section\")[Write Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Sort Results On this page * [Overview](#overview)\n* [Methods For Sorting](#methods-for-sorting)\n* [Sorting Direction](#sorting-direction)\n* [Ascending](#ascending)\n* [Descending](#descending)\n* [Handling Ties](#handling-ties)\n* [Combining Sort Criteria](#combining-sort-criteria)\n* [Text Search](#text-search) ## Overview In this guide, you can learn how to use the **sort** operation to order your results from read operations with the MongoDB Java driver. The sort operation orders the documents returned from your query by your specified**sort criteria**. Sort criteria are the rules you pass to MongoDB that describe how you would like your data to be ordered. Some examples of sort criteria are: * Smallest number to largest number\n* Earliest time of day to latest time of day\n* Alphabetical order by first name You should read this guide if you would like to: * Perform ascending sorts and descending sorts.\n* Combine sort criteria.\n* Sort on the text score of a[text search.](https://www.mongodb.com/docs/manual/core/text-search-operators/) The examples in this guide use a sample collection that contains the following documents: `| {\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"}  |\n| ------------------------------------------------------ |\n| {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"}       |\n| {\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"} |\n| {\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"}  |\n| {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} |\n| {\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}       | ` ## Methods For Sorting You can sort results retrieved by a query and you can sort results within an aggregation pipeline. To sort your query results, use the`sort()` method of a `FindIterable` instance. To sort your results within an aggregation pipeline, use the `Aggregates.sort()` static factory method. Both of these methods receive objects that implement the `Bson` interface as arguments. For more information, see our API Documentation for the[BSON interface.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/conversions/Bson.html) You can use the `sort()` method of a `FindIterable` instance as follows: ```java import static com.mongodb.client.model.Sorts.ascending; // <MongoCollection setup code here> collection.find().sort(ascending(\"_id\")); \n``` You can use the `Aggregates.sort()` method within an aggregation pipeline as follows: ```java import com.mongodb.client.model.Aggregates; import static com.mongodb.client.model.Sorts.ascending; // <MongoCollection setup code here> collection.aggregate(Arrays.asList(Aggregates.sort(ascending(\"_id\")))); \n``` The preceding code snippets sort the documents in the[sample collection](#std-label-sorts-crud-sort-sample) from smallest to largest value of the `_id` field: ``` {\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"} {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"} ... \n``` In the preceding code snippets, we specify our sort criteria using the `Sorts`builder class. While it is possible to specify sort criteria using any class that implements the `Bson` interface, we recommend that you specify sort criteria through the `Sorts` builder. For more information on the `Sorts`builder class, see our[guide on the Sorts builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/sort/)\n\n * [FindIterable](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html)\n* [Aggregates](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates.html)\n* [Sorts](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html)\n* [BSON](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/conversions/Bson.html)\n* [Document](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/bson/org/bson/Document.html) ## Sorting Direction The direction of your sort can either be **ascending** or **descending**. An ascending sort orders your results from smallest to largest. A descending sort orders your results from largest to smallest. Here are some examples of data sorted in ascending order: * Numbers: 1, 2, 3, 43, 43, 55, 120\n* Dates: 1990-03-10, 1995-01-01, 2005-10-30, 2005-12-21\n* Words (ASCII): Banana, Dill, carrot, cucumber, hummus Here are some examples of data sorted in descending order: * Numbers: 100, 30, 12, 12, 9, 3, 1\n* Dates: 2020-01-01, 1998-12-11, 1998-12-10, 1975-07-22\n* Words (reverse ASCII): pear, grapes, apple, Cheese The following subsections show how to specify these sort criteria. ### Ascending To specify an ascending sort, use the `Sorts.ascending()` static factory method. Pass the `Sorts.ascending()` method the name of the field you need to sort in ascending order. You can pass the `sort()` method the output of the `Sorts.ascending()`method to specify an ascending sort on a field as follows: ```java import static com.mongodb.client.model.Sorts.ascending; // <MongoCollection setup code here> collection.find().sort(ascending(\"<field name>\")); \n``` The preceding `sort()` method returns a `FindIterable` object that can iterate over the documents in your collection, sorted from smallest to largest on the specified field name. In the following code example, we use the `ascending()` method to sort the[sample collection](#std-label-sorts-crud-sort-sample)by the `_id` field: ```java import static com.mongodb.client.model.Sorts.ascending; // <MongoCollection setup code here> List<Document> results = new ArrayList<>(); collection.find().sort(ascending(\"_id\")).into(results); for (Document result : results) {       System.out.println(result.toJson()); } \n``` The output of the preceding code example should look something like this: ``` {\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"} {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"} ... \n``` ### Descending To specify a descending sort, use the `Sorts.descending()` static factory method. Pass the `Sorts.descending()` method the name of the field you need to sort in descending order. The following code snippet shows how to specify a descending sort on the`_id` field: ```java import static com.mongodb.client.model.Sorts.descending; // <MongoCollection setup code here> collection.find().sort(descending(\"_id\")); \n``` The preceding code snippet returns the documents in the[sample collection](#std-label-sorts-crud-sort-sample)in descending order: ``` {\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"}\n\n {\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"} ... \n``` ### Handling Ties A tie occurs when two or more documents have identical values in the field you are using to order your results. MongoDB does not guarantee sort order in the event of ties. For example, suppose we encounter a tie when applying a sort to the [sample collection](#std-label-sorts-crud-sort-sample) using the following code: ```java import static com.mongodb.client.model.Sorts.ascending; // <MongoCollection setup code here> collection.find().sort(ascending(\"letter\")); \n``` Since multiple documents that matched our query contain the value \"a\" for the field on which we perform the sort, the following documents could be returned in any order: ``` {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"} {\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"} {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} \n``` If you need to guarantee a specific sort order for documents that have fields with identical values, you can specify additional fields to sort on in the event of a tie. We can specify an ascending sort on the `letter` field followed by the`_id` field as follows: ```java import static com.mongodb.client.model.Sorts.ascending; // <MongoCollection setup code here> collection.find().sort(ascending(\"letter\", \"_id\")); \n``` The preceding code snippet returns the documents in the[sample collection](#std-label-sorts-crud-sort-sample)in the following order: ``` {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"} {\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"} {\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"} {\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"} {\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"} \n``` ### Combining Sort Criteria To combine sort criteria, use the `Sorts.orderBy()` static factory method. This method constructs an object containing an ordered list of sort criteria. When performing the sort, if the leftmost sort criteria results in a tie, the sort uses the next sort criteria in the list to determine the order. In the following code snippet, we use the `orderBy()` method to order our data by performing a descending sort on the `letter` field, and in the event of a tie, by performing an ascending sort on the `_id` field. ```java import static com.mongodb.client.model.Sorts.orderBy; import static com.mongodb.client.model.Sorts.ascending; import static com.mongodb.client.model.Sorts.descending; // <MongoCollection setup code here> Bson orderBySort = orderBy(descending(\"letter\"), ascending(\"_id\")); collection.find().sort(orderBySort); \n``` The preceding code snippet returns the documents in the[sample collection](#std-label-sorts-crud-sort-sample)in the following order: ``` {\"_id\": 1, \"letter\": \"c\", \"food\": \"coffee with milk\"} {\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\"} {\"_id\": 4, \"letter\": \"b\", \"food\": \"coffee with sugar\"} {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\"} {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\"} {\"_id\": 5, \"letter\": \"a\", \"food\": \"milk and cookies\"} \n``` ## Text Search\n\n ## Important ### Make Sure to Create a Text Index You need a [text index](https://www.mongodb.com/docs/manual/core/index-text/) on your collection to perform a text search. See the server manual documentation for more information on how to[create a text index.](https://www.mongodb.com/docs/manual/core/index-text/#create-text-index) In the following code example, we show how you can use the`Sorts.metaTextScore()` method to sort the results of a text search on the [sample collection](#std-label-sorts-crud-sort-sample). The code example uses the [Filters](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/),[Indexes](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/indexes/), and[Projections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/projections/) builders. The code example performs the following actions: 1. Creates a text index for your[sample collection](#std-label-sorts-crud-sort-sample)on the `food` field. If you call `createIndex()` specifying an index that already exists on the collection, the operation does not create a new index.\n2. Runs your text search for the phrase \"maple donut\".\n3. Projects text scores into your query results as the`score` field.\n4. Sorts your results by text score (best match first). ```java import com.mongodb.client.model.Sorts; import com.mongodb.client.model.Projections; import com.mongodb.client.model.Filters; import com.mongodb.client.model.Indexes; // <MongoCollection setup code here> collection.createIndex(Indexes.text(\"food\")); Bson metaTextScoreSort = Sorts.metaTextScore(\"score\"); Bson metaTextScoreProj = Projections.metaTextScore(\"score\"); String searchTerm = \"maple donut\"; Bson searchQuery = Filters.text(searchTerm); collection.find(searchQuery)          .projection(metaTextScoreProj)          .sort(metaTextScoreSort)          .into(results); for (Document result : results) {       System.out.println(result.toJson()); } \n``` The output of the preceding code example should look something like this: ``` {\"_id\": 6, \"letter\": \"c\", \"food\": \"maple donut\", \"score\": 1.5} {\"_id\": 2, \"letter\": \"a\", \"food\": \"donuts and coffee\", \"score\": 0.75} {\"_id\": 3, \"letter\": \"a\", \"food\": \"maple syrup\", \"score\": 0.75} \n``` ## Note ### Text Search Behavior in MongoDB 4.4 or Later The structure of text search has changed for MongoDB 4.4 or later. You no longer need to project `Projections.metaTextScore()` into your`FindIterable` instance in order to sort on the text score. In addition, the field name you specify in a `$meta` text score aggregation operation used in a sort is ignored. This means that the field name argument you pass to `Sorts.metaTextScore()` is disregarded. For more information about the classes in this section, see the following API Documentation:\n\n For more information, see the[Sorts class](https://mongodb.com/docs/drivers/java/sync/current/apidocs/mongodb-driver-core/com/mongodb/client/model/Sorts.html/) API Documentation. See the server manual documentation for more information on the [$text](https://www.mongodb.com/docs/manual/reference/operator/query/text/)query operator and the[$meta](https://www.mongodb.com/docs/manual/reference/operator/aggregation/meta/)aggregation pipeline operator. ← [Open Change Streams](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/change-streams/ \"Previous Section\")[Skip Returned Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/skip/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/geo/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Search Geospatially On this page * [Overview](#overview)\n* [Coordinates on Earth](#coordinates-on-earth)\n* [GeoJSON Positions](#geojson-positions)\n* [GeoJSON Types](#geojson-types)\n* [Index](#index)\n* [Coordinates on a 2D Plane](#coordinates-on-a-2d-plane)\n* [Index](#index-1)\n* [Geospatial Queries](#geospatial-queries)\n* [Query Operators](#query-operators)\n* [Query Parameters](#query-parameters)\n* [Examples](#examples)\n* [Query by Proximity](#query-by-proximity)\n* [Query Within a Range](#query-within-a-range) ## Overview In this guide, you can learn how to search **geospatial data** with the MongoDB Java Driver, and the different geospatial data formats supported by MongoDB. Geospatial data is data that represents a geographical location on the surface of the Earth. Examples of geospatial data include: * Locations of movie theaters\n* Borders of countries\n* Routes of bicycle rides\n* Dog exercise areas in New York City ## Coordinates on Earth To store and query your geospatial data in MongoDB, use **GeoJSON**. GeoJSON is a data format created by the Internet Engineering Task Force (IETF). Here is the location of MongoDB headquarters in GeoJSON: `| \"MongoDB Headquarters\" : {              |\n| --------------------------------------- |\n| \"type\": \"point\",                        |\n| \"coordinates\": [-73.986805, 40.7620853] |\n| }                                       | ` For definitive information on GeoJSON, see the[official IETF specification.](https://datatracker.ietf.org/doc/html/rfc7946) ### GeoJSON Positions A position represents a single place on Earth, and exists in code as an array containing two or three number values: * Longitude in the first position (required)\n* Latitude in the second position (required)\n* Elevation in the third position (optional) ## Important ### Longitude then Latitude GeoJSON orders coordinates as longitude first and latitude second. This may be surprising as geographic coordinate system conventions generally list latitude first and longitude second. Make sure to check what format any other tools you are working with use. Popular tools such as OpenStreetMap and Google Maps list coordinates as latitude first and longitude second. ### GeoJSON Types Your GeoJSON object's type determines its geometric shape. Geometric shapes are made up of positions. Here are some common GeoJSON types and how you can specify them with positions: * `Point`: a single position. This could represent the location of a[sculpture.](https://en.wikipedia.org/wiki/Chicago%5FPicasso)\n* `LineString`: an array of two or more positions, thus forming a series of line segments. This could represent[the route of the Great Wall of China.](https://commons.wikimedia.org/wiki/File:GreatWallChina4.png)\n* `Polygon`: an array of positions in which the first and last position are the same, thus enclosing some space. This could represent[the land within Vatican City.](https://commons.wikimedia.org/wiki/File:Vatican%5FCity%5Fmap%5FEN.png) To learn more about the shapes you can use in MongoDB, see the[GeoJSON manual entry.](https://www.mongodb.com/docs/manual/reference/geojson/) ### Index To query data stored in the GeoJSON format, add the field containing GeoJSON data to a `2dsphere` index. The following snippet creates a`2dsphere` index on the `location.geo` field using the `Indexes` builder: ```java // <MongoCollection setup code here>\n\n \n``` For more information on the `Indexes` builder, see our[guide on the Indexes builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/indexes/) ## Coordinates on a 2D Plane You can store geospatial data using `x` and `y` coordinates on a two-dimensional Euclidean plane. We refer to coordinates on a two-dimensional plane as \"legacy coordinate pairs\". Legacy coordinate pairs have the following structure: ``` \"<field name>\" : [ x, y ] \n``` Your field should contain an array of two values in which the first represents the `x` axis value and the second represents the `y` axis value. ### Index To query data stored as legacy coordinate pairs, you must add the field containing legacy coordinate pairs to a `2d` index. The following snippet creates a`2d` index on the `coordinates` field using the `Indexes` builder: ```java // <MongoCollection setup code here> collection.createIndex(Indexes.geo2d(\"coordinates\")); \n``` For more information on the `Indexes` builder, see our[guide on the Indexes builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/indexes/) For more information on legacy coordinate pairs, see the[MongoDB server manual page on legacy coordinate pairs.](https://www.mongodb.com/docs/manual/geospatial-queries/#legacy-coordinate-pairs) ## Tip ### Supported Operators Spherical (`2dsphere`) and flat (`2d`) indexes support some, but not all, of the same query operators. For a full list of operators and their index compatibility, see the[manual entry for geospatial queries.](https://www.mongodb.com/docs/manual/geospatial-queries/#geospatial-query-operators) ## Geospatial Queries Geospatial queries consist of a query operator and GeoJSON shapes as query parameters. ### Query Operators To query your geospatial data, use one of the following query operators: * `$near`\n* `$geoWithin`\n* `$nearSphere`\n* `$geoIntersects` _requires a 2dsphere index_ You can specify these query operators in the MongoDB Java driver with the`near()`, `geoWithin()`, `nearSphere()`, and `geoIntersects()` utility methods of the `Filters` builder class. For more information on geospatial query operators, see the[manual entry for geospatial queries.](https://www.mongodb.com/docs/manual/geospatial-queries/#geospatial-query-operators) For more information on `Filters`, see our[guide on the Filters builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/) ### Query Parameters To specify a shape to use in a geospatial query, use the`Position`, `Point`, `LineString`, and `Polygon` classes of the MongoDB Java driver. For a full list of the GeoJSON shapes available in the MongoDB Java driver, see the[GeoJSON package](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/geojson/package-summary.html)API Documentation. ## Examples The following examples use the MongoDB Atlas sample dataset. You can learn how to set up your own free-tier Atlas cluster and how to load the sample dataset in our [quick start guide.](https://mongodb.com/docs/drivers/java/sync/current/quick-start/) The examples use the `theaters` collection in the `sample_mflix` database from the sample dataset. The `theaters` collection contains a `2dsphere` index on the `location.geo` field. The examples require the following imports: ```java import java.util.Arrays; import org.bson.conversions.Bson; import com.mongodb.client.model.geojson.Point; import com.mongodb.client.model.geojson.Polygon; import com.mongodb.client.model.geojson.Position; import static com.mongodb.client.model.Filters.near; import static com.mongodb.client.model.Filters.geoWithin;\n\n import static com.mongodb.client.model.Projections.include; import static com.mongodb.client.model.Projections.excludeId; \n``` You can find the[source code for the examples on Github here.](https://github.com/mongodb/docs-java/blob/master/source/includes/fundamentals/code-snippets/Geo.java) ### Query by Proximity To search for and return documents from nearest to farthest from a point, use the `near()` static utility method of the `Filters` builder class. The`near()` method constructs a query with the `$near` query operator. The following example queries for theaters between `10,000` and `5,000`meters from the[Great Lawn of Central Park.](https://en.wikipedia.org/wiki/Great%5FLawn%5Fand%5FTurtle%5FPond) ```java // code to set up your mongo client ... MongoDatabase database = mongoClient.getDatabase(\"sample_mflix\"); MongoCollection<Document> collection = database.getCollection(\"theaters\"); Point centralPark = new Point(new Position(-73.9667, 40.78)); Bson query = near(\"location.geo\", centralPark, 10000.0, 5000.0); Bson projection = fields(include(\"location.address.city\"), excludeId()); collection.find(query)         .projection(projection)         .forEach(doc -> System.out.println(doc.toJson())); \n``` The output of the code snippet should look something like this: ``` {\"location\": {\"address\": {\"city\": \"Bronx\"}}} {\"location\": {\"address\": {\"city\": \"New York\"}}} {\"location\": {\"address\": {\"city\": \"New York\"}}} {\"location\": {\"address\": {\"city\": \"Long Island City\"}}} {\"location\": {\"address\": {\"city\": \"New York\"}}} {\"location\": {\"address\": {\"city\": \"Secaucus\"}}} {\"location\": {\"address\": {\"city\": \"Jersey City\"}}} {\"location\": {\"address\": {\"city\": \"Elmhurst\"}}} {\"location\": {\"address\": {\"city\": \"Flushing\"}}} {\"location\": {\"address\": {\"city\": \"Flushing\"}}} {\"location\": {\"address\": {\"city\": \"Flushing\"}}} {\"location\": {\"address\": {\"city\": \"Elmhurst\"}}} \n``` ## Tip ### Fun Fact MongoDB uses the[same reference system](https://www.mongodb.com/docs/manual/reference/glossary/#std-term-WGS84)as GPS satellites to calculate geometries over the Earth. For more information on the `$near` operator, see[the reference documentation for $near.](https://www.mongodb.com/docs/manual/reference/operator/query/near/#mongodb-query-op.-near) For more information on `Filters`,[see our guide on the Filters builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/) ### Query Within a Range To search for geospatial data within a specified shape use the `geoWithin()`static utility method of the `Filters` builder class. The `geoWithin()`method constructs a query with the `$geoWithin` query operator. The following example searches for movie theaters in a section of Long Island. ```java // code to set up your mongo collection ... Polygon longIslandTriangle = new Polygon(Arrays.asList(new Position(-72, 40),         new Position(-74, 41),         new Position(-72, 39),         new Position(-72, 40))); Bson projection = fields(include(\"location.address.city\"), excludeId()); Bson geoWithinComparison = geoWithin(\"location.geo\", longIslandTriangle); collection.find(geoWithinComparison)         .projection(projection)         .forEach(doc -> System.out.println(doc.toJson())); \n``` The output of the code snippet should look something like this: ``` {\"location\": {\"address\": {\"city\": \"Baldwin\"}}} {\"location\": {\"address\": {\"city\": \"Levittown\"}}}\n\n {\"location\": {\"address\": {\"city\": \"Mount Vernon\"}}} {\"location\": {\"address\": {\"city\": \"Massapequa\"}}} \n``` The following figure shows the polygon defined by the`longIslandTriangle` variable and dots representing the locations of the movie theaters returned by our query. ![Area of Long Island we are searching for movie theaters](https://mongodb.com/docs/drivers/java/sync/current/includes/figures/geo_geometry.png) For more information on the `$geoWithin` operator, see the[reference documentation for $geoWithin](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) For more information on the operators you can use in your query, see the[MongoDB server manual page on geospatial query operators](https://www.mongodb.com/docs/manual/geospatial-queries/index.html) ← [Specify Which Fields to Return](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/project/ \"Previous Section\")[Search Text](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/text/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/aggregates/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Aggregates Builders On this page * [Overview](#overview)\n* [Match](#match)\n* [Project](#project)\n* [Projecting Computed Fields](#projecting-computed-fields)\n* [Documents](#documents)\n* [Sample](#sample)\n* [Sort](#sort)\n* [Skip](#skip)\n* [Limit](#limit)\n* [Lookup](#lookup)\n* [Left Outer Join](#left-outer-join)\n* [Full Join and Uncorrelated Subqueries](#full-join-and-uncorrelated-subqueries)\n* [Group](#group)\n* [Pick-N Accumulators](#pick-n-accumulators)\n* [MinN](#minn)\n* [MaxN](#maxn)\n* [FirstN](#firstn)\n* [LastN](#lastn)\n* [Top](#top)\n* [TopN](#topn)\n* [Bottom](#bottom)\n* [BottomN](#bottomn)\n* [Unwind](#unwind)\n* [Out](#out)\n* [Merge](#merge)\n* [GraphLookup](#graphlookup)\n* [SortByCount](#sortbycount)\n* [ReplaceRoot](#replaceroot)\n* [AddFields](#addfields)\n* [Count](#count)\n* [Bucket](#bucket)\n* [BucketAuto](#bucketauto)\n* [Facet](#facet)\n* [SetWindowFields](#setwindowfields)\n* [Densify](#densify)\n* [Fill](#fill)\n* [Atlas Full-Text Search](#atlas-full-text-search)\n* [Atlas Search Metadata](#atlas-search-metadata) ## Overview In this guide, you can learn how to use the [Aggregates](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Aggregates)class which provides static factory methods that build [aggregation pipeline stages](https://www.mongodb.com/docs/manual/meta/aggregation-quick-reference/#stages) in the MongoDB Java driver. For a more thorough introduction to Aggregation, see our [Aggregation guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/aggregation/#std-label-java-aggregation) ## Tip For brevity, you may choose to import the methods of the following classes statically to make your queries more succinct: * `Aggregates`\n* `Filters`\n* `Projections`\n* `Sorts`\n* `Accumulators` `| import static com.mongodb.client.model.Aggregates.*;   |\n| ------------------------------------------------------ |\n| import static com.mongodb.client.model.Filters.*;      |\n| import static com.mongodb.client.model.Projections.*;  |\n| import static com.mongodb.client.model.Sorts.*;        |\n| import static com.mongodb.client.model.Accumulators.*; |\n| import static java.util.Arrays.asList;                 | ` The examples on this page assume these static imports, in addition to statically importing the `asList()` method. Use these methods to construct pipeline stages and specify them in your aggregation as a list: ```java Bson matchStage = match(eq(\"some_field\", \"some_criteria\")); Bson sortByCountStage = sortByCount(\"some_field\"); collection.aggregate(asList(matchStage, sortByCountStage)).forEach(doc -> System.out.println(doc)); \n``` ## Match\n\n ## Tip The filter can be an instance of any class that implements `Bson`, but it's convenient to combine with use of the [Filters](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/#std-label-filters-builders) class. The following example creates a pipeline stage that matches all documents where the`title` field is equal to \"The Shawshank Redemption\": ```java match(eq(\"title\", \"The Shawshank Redemption\")); \n``` ## Project Use the `project()` method to create a [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/)pipeline stage that project specified document fields. Field projection in aggregation follows the same rules as [field projection in queries.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/project/) ## Tip Though the projection can be an instance of any class that implements `Bson`, it's convenient to combine with use of [Projections.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/projections/#std-label-projections-builders) The following example creates a pipeline stage that excludes the `_id` field but includes the `title` and `plot` fields: ```java project(fields(include(\"title\", \"plot\"), excludeId())); \n``` ### Projecting Computed Fields The `$project` stage can project computed fields as well. The following example creates a pipeline stage that projects the `rated` field into a new field called `rating`, effectively renaming the field. ```java project(fields(computed(\"rating\", \"$rated\"), excludeId())); \n``` ## Documents Use the `documents()` method to create a[$documents](https://www.mongodb.com/docs/manual/reference/operator/aggregation/documents/)pipeline stage that returns literal documents from input values. ## Important If you use a `$documents` stage in an aggregation pipeline, it must be the first stage in the pipeline. The following example creates a pipeline stage that creates sample documents with a `title` field: ```java documents(asList(         new Document(\"title\", \"The Shawshank Redemption\"),         new Document(\"title\", \"Back to the Future\"),         new Document(\"title\", \"Jurassic Park\"))); \n``` ## Important If you use the `documents()` method to provide the input to an aggregation pipeline, you must call the `aggregate()` method on a database instead of on a collection. ## Sample Use the `sample()` method to create a [$sample](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sample/)pipeline stage to randomly select documents from input. The following example creates a pipeline stage that randomly selects 5 documents: ```java sample(5); \n``` ## Sort Use the `sort()` method to create a [$sort](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sort/)pipeline stage to sort by the specified criteria. ## Tip Though the sort criteria can be an instance of any class that implements `Bson`, it's convenient to combine with use of [Sorts.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/sort/#std-label-sorts-builders) The following example creates a pipeline stage that sorts in descending order according to the value of the `year` field and then in ascending order according to the value of the `title` field: ```java sort(orderBy(descending(\"year\"), ascending(\"title\"))); \n``` ## Skip Use the `skip()` method to create a [$skip](https://www.mongodb.com/docs/manual/reference/operator/aggregation/skip/)pipeline stage to skip over the specified number of documents before passing documents into the next stage. The following example creates a pipeline stage that skips the first `5` documents: ```java skip(5); \n``` ## Limit Use the [$limit](https://www.mongodb.com/docs/manual/reference/operator/aggregation/limit/) pipeline stage to limit the number of documents passed to the next stage. The following example creates a pipeline stage that limits the number of documents to `10`: ```java limit(10); \n``` ## Lookup\n\n ### Left Outer Join The following example creates a pipeline stage that performs a left outer join between the `movies` and `comments` collections: * It joins the `_id` field from `movies` to the `movie_id` field in `comments`\n* It outputs the results in the `joined_comments` field: ```java lookup(\"comments\", \"_id\", \"movie_id\", \"joined_comments\"); \n``` ### Full Join and Uncorrelated Subqueries The following example creates a pipeline stage that joins two collections, `orders`and `warehouses`, by the item and whether the available quantity is enough to fulfill the ordered quantity: ```java List<Variable<String>> variables = asList(new Variable<>(\"order_item\", \"$item\"),         new Variable<>(\"order_qty\", \"$ordered\")); List<Bson> pipeline = asList(         match(expr(new Document(\"$and\",                 asList(new Document(\"$eq\", asList(\"$$order_item\", \"$stock_item\")),                         new Document(\"$gte\", asList(\"$instock\", \"$$order_qty\")))))),         project(fields(exclude(\"stock_item\"), excludeId()))); List<Bson> innerJoinLookup = lookup(\"warehouses\", variables, pipeline, \"stockdata\"); \n``` ## Group Use the `group()` method to create a [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/)pipeline stage to group documents by a specified expression and output a document for each distinct grouping. ## Tip The driver includes the [Accumulators](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html)class with static factory methods for each of the supported accumulators. The following example creates a pipeline stage that groups documents by the value of the `customerId` field. Each group accumulates the sum and average of the values of the `quantity` field into the `totalQuantity` and`averageQuantity` fields. ```java group(\"$customerId\", sum(\"totalQuantity\", \"$quantity\"), avg(\"averageQuantity\", \"$quantity\")); \n``` Learn more about accumulator operators from the Server manual section on [Accumulators.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/#std-label-agg-operators-group-accumulators) ## Pick-N Accumulators The pick-n accumulators are aggregation accumulation operators that return the top and bottom elements given a specific ordering. Use one of the following builders to create an aggregation accumulation operator: * [minN()](#std-label-java%5Faggregates%5Fmin%5Fn)\n* [maxN()](#std-label-java%5Faggregates%5Fmax%5Fn)\n* [firstN()](#std-label-java%5Faggregates%5Ffirst%5Fn)\n* [lastN()](#std-label-java%5Faggregates%5Flast%5Fn)\n* [top()](#std-label-java%5Faggregates%5Ftop)\n* [topN()](#std-label-java%5Faggregates%5Ftop%5Fn)\n* [bottom()](#std-label-java%5Faggregates%5Fbottom)\n* [bottomN()](#std-label-java%5Faggregates%5Fbottom%5Fn) ## Tip You can only perform aggregation operations with these pick-n accumulators when running MongoDB v5.2 or later. Learn which aggregation pipeline stages you can use accumulator operators with from the Server manual section on[Accumulators.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/#std-label-agg-operators-group-accumulators) ### MinN\n\n ## Tip The `$minN` and `$bottomN` accumulators can perform similar tasks. See[Comparison of $minN and $bottomN Accumulators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/minN/#comparison-of--minn-and--bottomn-accumulators)for recommended usage of each. The following example demonstrates how to use the `minN()` method to return the lowest three `imdb.rating` values for movies, grouped by `year`: ```java group(         \"$year\",         minN(                 \"lowest_three_ratings\",                 new BsonString(\"$imdb.rating\"),                 3                 )); \n``` See the [minN() API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html#minN%28java.lang.String,InExpression,NExpression%29)for more information. ### MaxN The `maxN()` accumulator returns data from documents that contain the `n`highest values of a grouping. The following example demonstrates how to use the `maxN()` method to return the highest two `imdb.rating` values for movies, grouped by `year`: ```java group(         \"$year\",         maxN(                 \"highest_two_ratings\",                 new BsonString(\"$imdb.rating\"),                 2                 )); \n``` See the [maxN() API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html#maxN%28java.lang.String,InExpression,NExpression%29)for more information. ### FirstN The `firstN()` accumulator returns data from the first `n` documents in each grouping for the specified sort order. ## Tip The `$firstN` and `$topN` accumulators can perform similar tasks. See[Comparison of $firstN and $topN Accumulators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/firstN/#comparison-of--firstn-and--topn-accumulators)for recommended usage of each. The following example demonstrates how to use the `firstN()` method to return the first four movie `title` values, based on the order they came into the stage, grouped by `year`: ```java group(         \"$year\",         firstN(                 \"first_four_movies\",                 new BsonString(\"$title\"),                 4                 )); \n``` See the [firstN() API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html#firstN%28java.lang.String,InExpression,NExpression%29)for more information. ### LastN The `lastN()` accumulator returns data from the last `n` documents in each grouping for the specified sort order. The following example demonstrates how to use the `lastN()` method to show the last three movie `title` values, based on the the order they came into the stage, grouped by `year`: ```java group(         \"$year\",\n\n                 \"last_three_movies\",                 new BsonString(\"$title\"),                 3                 )); \n``` See the [lastN() API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html#lastN%28java.lang.String,InExpression,NExpression%29)for more information. ### Top The `top()` accumulator returns data from the first document in a group based on the specified sort order. The following example demonstrates how to use the `top()` method to return the `title` and `imdb.rating` values for the top rated movies based on the`imdb.rating`, grouped by `year`. ```java group(         \"$year\",          top(                 \"top_rated_movie\",                 descending(\"imdb.rating\"),                 asList(new BsonString(\"$title\"), new BsonString(\"$imdb.rating\"))                 )); \n``` See the [top() API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html#top%28java.lang.String,org.bson.conversions.Bson,OutExpression%29)for more information. ### TopN The `topN()` accumulator returns data from documents that contain the highest `n` values for the specified field. ## Tip The `$firstN` and `$topN` accumulators can perform similar tasks. See[Comparison of $firstN and $topN Accumulators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/firstN/#comparison-of--firstn-and--topn-accumulators)for recommended usage of each. The following example demonstrates how to use the `topN()` method to return the `title` and `runtime` values of the three longest movies based on the`runtime` values, grouped by `year`. ```java group(         \"$year\",          topN(                 \"longest_three_movies\",                 descending(\"runtime\"),                 asList(new BsonString(\"$title\"), new BsonString(\"$runtime\")),                 3                 )); \n``` See the [topN() API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html#topN%28java.lang.String,org.bson.conversions.Bson,OutExpression,NExpression%29)for more information. ### Bottom The `bottom()` accumulator returns data from the last document in a group based on the specified sort order. The following example demonstrates how to use the `bottom()` method to return the `title` and `runtime` values of the shortest movie based on the`runtime` value, grouped by `year`. ```java group(         \"$year\",          bottom(                 \"shortest_movies\",                 descending(\"runtime\"),\n\n                 )); \n``` See the [bottom() API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html#bottom%28java.lang.String,org.bson.conversions.Bson,OutExpression%29)for more information. ### BottomN The `bottomN()` accumulator returns data from documents that contain the lowest `n` values for the specified field. ## Tip The `$minN` and `$bottomN` accumulators can perform similar tasks. See [Comparison of $minN and $bottomN Accumulators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/minN/#comparison-of--minn-and--bottomn-accumulators)for recommended usage of each. The following example demonstrates how to use the `bottomN()` method to return the `title` and `imdb.rating` values of the two lowest rated movies based on the `imdb.rating` value, grouped by `year`: ```java group(         \"$year\",          bottomN(                 \"lowest_rated_two_movies\",                 descending(\"imdb.rating\"),                 asList(new BsonString(\"$title\"), new BsonString(\"$imdb.rating\")),                 2                 )); \n``` See the [bottomN() API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html#bottomN%28java.lang.String,org.bson.conversions.Bson,OutExpression,NExpression%29)for more information. ## Unwind Use the `unwind()` method to create an [$unwind](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/)pipeline stage to deconstruct an array field from input documents, creating an output document for each array element. The following example creates a document for each element in the `sizes` array: ```java unwind(\"$sizes\"); \n``` To preserve documents that have missing or `null`values for the array field, or where array is empty: ```java unwind(\"$sizes\", new UnwindOptions().preserveNullAndEmptyArrays(true)); \n``` To include the array index, in this example in a field called `\"position\"`: ```java unwind(\"$sizes\", new UnwindOptions().includeArrayIndex(\"position\")); \n``` ## Out Use the `out()` method to create an [$out](https://www.mongodb.com/docs/manual/reference/operator/aggregation/out/)pipeline stage that writes all documents to the specified collection in the same database. ## Important The `$out` stage must be the last stage in any aggregation pipeline. The following example writes the results of the pipeline to the `authors`collection: ```java out(\"authors\"); \n``` ## Merge Use the `merge()` method to create a [$merge](https://www.mongodb.com/docs/manual/reference/operator/aggregation/merge/)pipeline stage that merges all documents into the specified collection. ## Important The `$merge` stage must be the last stage in any aggregation pipeline. The following example merges the pipeline into the `authors` collection using the default options: ```java merge(\"authors\"); \n``` The following example merges the pipeline into the `customers` collection in the`reporting` database using some non-default options that specify to replace the document if both `date` and `customerId` match, otherwise insert the document: ```java merge(new MongoNamespace(\"reporting\", \"customers\"),\n\n                 .whenMatched(MergeOptions.WhenMatched.REPLACE)                 .whenNotMatched(MergeOptions.WhenNotMatched.INSERT)); \n``` ## GraphLookup Use the `graphLookup()` method to create a [$graphLookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/)pipeline stage that performs a recursive search on a specified collection to match a specified field in one document to a specified field of another document. The following example computes the social network graph for users in the`contacts` collection, recursively matching the value in the `friends` field to the `name` field: ```java graphLookup(\"contacts\", \"$friends\", \"friends\", \"name\", \"socialNetwork\"); \n``` Using `GraphLookupOptions`, you can specify the depth to recurse as well as the name of the depth field, if desired. In this example, `$graphLookup` will recurse up to two times, and create a field called `degrees` with the recursion depth information for every document. ```java graphLookup(\"contacts\", \"$friends\", \"friends\", \"name\", \"socialNetwork\",         new GraphLookupOptions().maxDepth(2).depthField(\"degrees\")); \n``` Using `GraphLookupOptions`, you can specify a filter that documents must match in order for MongoDB to include them in your search. In this example, only links with \"golf\" in their `hobbies` field will be included. ```java graphLookup(\"contacts\", \"$friends\", \"friends\", \"name\", \"socialNetwork\",         new GraphLookupOptions().maxDepth(1).restrictSearchWithMatch(eq(\"hobbies\", \"golf\"))); \n``` ## SortByCount Use the `sortByCount()` method to create a [$sortByCount](https://www.mongodb.com/docs/manual/reference/operator/aggregation/sortByCount/)pipeline stage that groups documents by a given expression and then sorts these groups by count in descending order. ## Tip The `$sortByCount` stage is identical to a `$group` stage with a`$sum` accumulator followed by a `$sort` stage. ``` [     { \"$group\": { \"_id\": <expression to group on>, \"count\": { \"$sum\": 1 } } },     { \"$sort\": { \"count\": -1 } } ] \n``` The following example groups documents by the truncated value of the field `x`and computes the count for each distinct value: ```java sortByCount(new Document(\"$floor\", \"$x\")); \n``` ## ReplaceRoot Use the `replaceRoot()` method to create a [$replaceRoot](https://www.mongodb.com/docs/manual/reference/operator/aggregation/replaceRoot/)pipeline stage that replaces each input document with the specified document. The following example replaces each input document with the nested document in the `spanish_translation` field: ```java replaceRoot(\"$spanish_translation\"); \n``` ## AddFields Use the `addFields()` method to create an [$addFields](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/)pipeline stage that adds new fields to documents. ## Tip Use `$addFields` when you do not want to project field inclusion or exclusion. The following example adds two new fields, `a` and `b` to the input documents: ```java addFields(new Field(\"a\", 1), new Field(\"b\", 2)); \n``` ## Count Use the `count()` method to create a [$count](https://www.mongodb.com/docs/manual/reference/operator/aggregation/count/)pipeline stage that counts the number of documents that enter the stage, and assigns that value to a specified field name. If you do not specify a field,`count()` defaults the field name to \"count\". ## Tip The `$count` stage is syntactic sugar for: ``` { \"$group\":{ \"_id\": 0, \"count\": { \"$sum\" : 1 } } } \n```\n\n ```java count(\"total\"); \n``` ## Bucket Use the `bucket()` method to create a [$bucket](https://www.mongodb.com/docs/manual/reference/operator/aggregation/bucket/)pipeline stage that automates the bucketing of data around predefined boundary values. The following example creates a pipeline stage that groups incoming documents based on the value of their `screenSize` field, inclusive of the lower boundary and exclusive of the upper boundary. ```java bucket(\"$screenSize\", asList(0, 24, 32, 50, 70, 200)); \n``` Use the `BucketOptions` class to specify a default bucket for values outside of the specified boundaries, and to specify additional accumulators. The following example creates a pipeline stage that groups incoming documents based on the value of their `screenSize` field, counting the number of documents that fall within each bucket, pushing the value of `screenSize` into a field called `matches`, and capturing any screen sizes greater than \"70\" into a bucket called \"monster\" for monstrously large screen sizes: ## Tip The driver includes the [Accumulators](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html)class with static factory methods for each of the supported accumulators. ```java bucket(\"$screenSize\", asList(0, 24, 32, 50, 70),         new BucketOptions().defaultBucket(\"monster\").output(sum(\"count\", 1), push(\"matches\", \"$screenSize\"))); \n``` ## BucketAuto Use the `bucketAuto()` method to create a [$bucketAuto](https://www.mongodb.com/docs/manual/reference/operator/aggregation/bucketAuto/)pipeline stage that automatically determines the boundaries of each bucket in its attempt to distribute the documents evenly into a specified number of buckets. The following example creates a pipeline stage that will attempt to create and evenly distribute documents into _10_ buckets using the value of their `price` field: ```java bucketAuto(\"$price\", 10); \n``` Use the `BucketAutoOptions` class to specify a [preferred number](https://en.wikipedia.org/wiki/Preferred%5Fnumber)based scheme to set boundary values, and specify additional accumulators. The following example creates a pipeline stage that will attempt to create and evenly distribute documents into _10_ buckets using the value of their `price` field, setting the bucket boundaries at powers of 2 (2, 4, 8, 16, ...). It also counts the number of documents in each bucket, and calculates their average `price`in a new field called `avgPrice`: ## Tip The driver includes the [Accumulators](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Accumulators.html)class with static factory methods for each of the supported accumulators. ```java bucketAuto(\"$price\", 10, new BucketAutoOptions().granularity(BucketGranularity.POWERSOF2)         .output(sum(\"count\", 1), avg(\"avgPrice\", \"$price\"))); \n``` ## Facet Use the `facet()` method to create a [$facet](https://www.mongodb.com/docs/manual/reference/operator/aggregation/facet/)pipeline stage that allows for the definition of parallel pipelines. The following example creates a pipeline stage that executes two parallel aggregations: * The first aggregation distributes incoming documents into 5 groups according to their `attributes.screen_size` field.\n* The second aggregation counts all _manufacturers_ and returns their count, limited to the top **5**. ```java facet(new Facet(\"Screen Sizes\",         bucketAuto(\"$attributes.screen_size\", 5, new BucketAutoOptions().output(sum(\"count\", 1)))),         new Facet(\"Manufacturer\", sortByCount(\"$attributes.manufacturer\"), limit(5))); \n``` ## SetWindowFields\n\n ## Tip ### Window Functions The driver includes the [Windows](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Windows.html)class with static factory methods for building windowed computations. The following example creates a pipeline stage that computes the accumulated rainfall and the average temperature over the past month for each locality from more fine-grained measurements presented in the `rainfall`and `temperature` fields: ```java Window pastMonth = Windows.timeRange(-1, MongoTimeUnit.MONTH, Windows.Bound.CURRENT); setWindowFields(\"$localityId\", Sorts.ascending(\"measurementDateTime\"),         WindowedComputations.sum(\"monthlyRainfall\", \"$rainfall\", pastMonth),         WindowedComputations.avg(\"monthlyAvgTemp\", \"$temperature\", pastMonth)); \n``` ## Densify Use the `densify()` method to create a[$densify](https://www.mongodb.com/docs/rapid/reference/operator/aggregation/densify/)pipeline stage that generates a sequence of documents to span a specified interval. ## Tip You can use the `$densify()` aggregation stage only when running MongoDB v5.1 or later. Consider the following documents retrieved from the [Atlas sample weather dataset](https://www.mongodb.com/docs/atlas/sample-data/sample-weather/)that contain measurements for a similar `position` field, spaced one hour apart: ``` Document{{ _id=5553a..., position=Document{{type=Point, coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:00:00 EST 1984, ... }} Document{{ _id=5553b..., position=Document{{type=Point, coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 09:00:00 EST 1984, ... }} \n``` Suppose you needed to create a pipeline stage that performs the following actions on these documents: * Add a document at every 15-minute interval for which a `ts` value does not already exist.\n* Group the documents by the `position` field. The call to the `densify()` aggregation stage builder that accomplishes these actions should resemble the following: ```java densify(         \"ts\",          DensifyRange.partitionRangeWithStep(15, MongoTimeUnit.MINUTE),         DensifyOptions.densifyOptions().partitionByFields(\"position.coordinates\")); \n``` The following output highlights the documents generated by the aggregate stage which contain `ts` values every 15 minutes between the existing documents: ``` Document{{ _id=5553a..., position=Document{{type=Point, coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:00:00 EST 1984, ... }} Document{{ position=Document{{coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:15:00 EST 1984 }} Document{{ position=Document{{coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:30:00 EST 1984 }} Document{{ position=Document{{coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 08:45:00 EST 1984 }} Document{{ _id=5553b..., position=Document{{type=Point, coordinates=[-47.9, 47.6]}}, ts=Mon Mar 05 09:00:00 EST 1984, ... }} \n``` See the [densify package API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/densify/package-summary.html)for more information. ## Fill Use the `fill()` method to create a[$fill](https://www.mongodb.com/docs/upcoming/reference/operator/aggregation/fill/)pipeline stage that populates `null` and missing field values. ## Tip You can use the `$fill()` aggregation stage only when running MongoDB v5.3 or later. Consider the following documents that contain temperature and air pressure measurements at an hourly interval: ```\n\n Document{{_id=6308b..., hour=2, temperature=23.5C}} Document{{_id=6308c..., hour=3, temperature=null, air_pressure=29.76}} \n``` Suppose you needed to populate missing temperature and air pressure data points in the documents as follows: * Populate the `air_pressure` field for hour \"2\" using linear interpolation to calculate the value.\n* Set the missing `temperature` value to \"23.6C\" for hour \"3\". The call to the `fill()` aggregation stage builder that accomplishes these actions resembles the following: ```java fill(         FillOptions.fillOptions().sortBy(ascending(\"hour\")),         FillOutputField.value(\"temperature\", \"23.6C\"),         FillOutputField.linear(\"air_pressure\")         ); \n``` The following output highlights the documents that contain fields populated by the aggregate stage: ``` Document{{_id=6308a..., hour=1, temperature=23C, air_pressure=29.74}} Document{{_id=6308b..., hour=2, temperature=23.5C, air_pressure=29.75}} Document{{_id=6308c..., hour=3, temperature=23.6C, air_pressure=29.76}} \n``` See the [fill package API documentation](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/fill/package-summary.html)for more information. ## Atlas Full-Text Search Use the `search()` method to create a [$search](https://www.mongodb.com/docs/manual/reference/operator/aggregation/search/)pipeline stage that specifies a full-text search of one or more fields. ## Tip ### Only Available on Atlas for MongoDB v4.2 and later This aggregation pipeline operator is only available for collections hosted on [MongoDB Atlas](https://www.mongodb.com/docs/atlas/) clusters running v4.2 or later that are covered by an [Atlas search index](https://www.mongodb.com/docs/atlas/reference/atlas-search/index-definitions/). Learn more about the required setup and the functionality of this operator from the [Atlas Search](https://www.mongodb.com/docs/atlas/atlas-search/#std-label-fts-top-ref) documentation. The following example creates a pipeline stage that searches the `title`field for text that contains the word \"Future\": ```java Bson textSearch = Aggregates.search(         SearchOperator.text(                 SearchPath.fieldPath(\"title\"), \"Future\")); \n``` Learn more about the builders from the[search package API documentation.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/search/package-summary.html) ## Atlas Search Metadata Use the `searchMeta()` method to create a[$searchMeta](https://www.mongodb.com/docs/manual/reference/operator/aggregation/searchMeta/)pipeline stage which returns only the metadata part of the results from Atlas full-text search queries. ## Tip ### Only Available on Atlas for MongoDB v4.4.11 and later This aggregation pipeline operator is only available on [MongoDB Atlas](https://www.mongodb.com/docs/atlas/) clusters running v4.4.11 and later. For a detailed list of version availability, see the MongoDB Atlas documentation on [$searchMeta.](https://www.mongodb.com/docs/atlas/atlas-search/query-syntax/#-searchmeta) The following example shows the `count` metadata for an Atlas search aggregation stage: ```java Aggregates.searchMeta(         SearchOperator.near(2010, 1, SearchPath.fieldPath(\"year\"))); \n```\n\n ← [Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/ \"Previous Section\")[Filters Builders](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/filters/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/cursor/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Access Data From a Cursor On this page * [Overview](#overview)\n* [Terminal Methods](#terminal-methods)\n* [First](#first)\n* [Number of Results](#number-of-results)\n* [Into](#into)\n* [Cursor](#cursor)\n* [Explain](#explain)\n* [Usage Patterns](#usage-patterns)\n* [Functional Iteration](#functional-iteration)\n* [Conditional Iteration](#conditional-iteration)\n* [Cursor Cleanup](#cursor-cleanup)\n* [Close](#close)\n* [Try with Resources Statement](#try-with-resources-statement) ## Overview In this guide, you can learn how to access data using a **cursor** with the MongoDB Java driver. A cursor is a mechanism that allows an application to iterate over database results while only holding a subset of them in memory at a given time. The driver uses cursors in read operations that match multiple documents to return matched documents in batches as opposed to returning them all at once. This page uses an initiating method, `find()` to show how to access data from a [FindIterable.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html) ## Note The following ways to access and store data apply to other iterables such as an [AggregateIterable.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/AggregateIterable.html) The `find()` method creates and returns an instance of a`FindIterable`. A `FindIterable` allows you to browse the documents matched by your search criteria and to further specify which documents to see by setting parameters through methods. ## Terminal Methods Terminal methods execute an operation on the MongoDB server after configuring all parameters of an `Iterable` instance controlling the operation. ### First Use the `first()` method to retrieve the first document in your query results: `| FindIterable<Document> iterable = collection.find(); |\n| ---------------------------------------------------- |\n| System.out.println(iterable.first());                | ` This method is often used when your query filter will match one document, such as when filtering by a unique index. ### Number of Results Use the `available()` method to retrieve the number of results locally present without blocking: ```java MongoCursor<Document> cursor = collection.find().cursor(); System.out.println(cursor.available()); \n``` The method returns `0` if the application has already iterated though all the documents in the cursor or if the cursor is closed. ### Into Use the `into()` method to store your query results in a `List`: ```java List<Document> results = new ArrayList<>(); FindIterable<Document> iterable = collection.find(); iterable.into(results); System.out.println(results); \n``` This method is often used when your query filter returns a small number of documents that can fit into available memory. ### Cursor Use the `cursor()` method to iterate through fetched documents and ensure that the cursor closes if there is an early termination: ```java MongoCursor<Document> cursor = collection.find().cursor(); \n``` For more information on how to ensure a cursor closes, see the [cursor cleanup section.](#std-label-cursor%5Fcleanup) ### Explain Use the `explain()` method to view information about how MongoDB executes your operation. The `explain()` method returns **execution plans** and performance statistics. An execution plan is a potential way MongoDB can complete an operation. The `explain()` method provides both the winning plan (the plan MongoDB executed) and rejected plans. You can specify the level of detail of your explanation by passing a verbosity level to the `explain()` method. The following table shows all verbosity levels for explanations and their intended use cases:\n\n The following example prints the JSON representation of the winning plan for aggregation stages that produce execution plans: ```java Document explanation = collection.find().explain(ExplainVerbosity.EXECUTION_STATS); List<String> keys = Arrays.asList(\"queryPlanner\", \"winningPlan\"); System.out.println(explanation.getEmbedded(keys, Document.class).toJson()); \n``` The preceding code snippet should produce the following output: ``` { \"stage\": \"COLLSCAN\", \"direction\": \"forward\" } \n``` For more information on the explain operation, see the following Server Manual Entries: * [Explain Output](https://www.mongodb.com/docs/manual/reference/explain-results/)\n* [Query Plans](https://www.mongodb.com/docs/manual/core/query-plans/) For more information about the methods and classes mentioned in this section, see the following API Documentation: * [first()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoIterable.html#first%28%29)\n* [available()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCursor.html#available%28%29)\n* [into()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoIterable.html#into%28A%29)\n* [cursor()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoIterable.html#cursor%28%29)\n* [explain()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/FindIterable.html#explain%28%29)\n* [ExplainVerbosity](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/ExplainVerbosity) ## Usage Patterns A `MongoCursor` and `FindIterable` allow you to access query results one document at a time, abstracting away network and caching logic. ### Functional Iteration Pass a function to the `forEach()` method of a `FindIterable` to iterate through results in a functional style: ```java FindIterable<Document> iterable = collection.find(); iterable.forEach(doc -> System.out.println(doc.toJson())); \n``` ## Important Initiating methods return objects that implement the `Iterable` interface which allows you to iterate through them using iterator methods. Sometimes, we use an enhanced for-each loop to iterate through results: ```java for (Document cur : collection.find()) {    ... } \n``` Iterating this way is not preferable because if an exception is thrown before the loop completes, the cursor will not close. Using a`MongoCursor` allows us to ensure the cursor closes as shown in the[cursor cleanup section.](#std-label-cursor%5Fcleanup) ### Conditional Iteration Use the `hasNext()` method to check if there are any documents available in the cursor, and then use the `next()` method to retrieve the next available document from the cursor: ```java MongoCursor<Document> cursor = collection.find().cursor(); while (cursor.hasNext()){     System.out.println(cursor.next().toJson()); } \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation:\n\n ## Cursor Cleanup ### Close Use the `close()` method in a finally block to free up a cursor's consumption of resources in both the client application and the MongoDB server: ```java MongoCursor<Document> cursor = collection.find().cursor(); try {     while (cursor.hasNext()){         System.out.println(cursor.next().toJson());     } } finally {     cursor.close(); } \n``` ### Try with Resources Statement Use a try-with-resources statement to automatically free up a cursor's consumption of resources in both the client application and the MongoDB server: ```java try(MongoCursor<Document> cursor = collection.find().cursor()) {     while (cursor.hasNext()){         System.out.println(cursor.next().toJson());     } } \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [close()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCursor.html#close%28%29)\n* [try-with-resources statement](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html) ← [Retrieve Data](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/retrieve/ \"Previous Section\")[Open Change Streams](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/change-streams/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/change-streams/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Open Change Streams On this page * [Overview](#overview)\n* [Open a Change Stream](#open-a-change-stream)\n* [Apply Aggregation Operators to your Change Stream](#apply-aggregation-operators-to-your-change-stream)\n* [Include Pre-images and Post-images](#include-pre-images-and-post-images) ## Overview In this guide, you can learn how to use a **change stream** to monitor real-time changes to your database. A change stream is a MongoDB server feature that allows your application to subscribe to data changes on a single collection, database, or deployment. You can specify a set of aggregation operators to filter and transform the data your application receives. When connecting to a MongoDB deployment v6.0 or later, you can configure the events to include the document data before and after the change. Learn how to open and configure your change streams in the following sections: * [Open a Change Stream](#std-label-java-change-stream-open)\n* [Apply Aggregation Operators to your Change Stream](#std-label-java-change-stream-aggregation)\n* [Include Pre-images and Post-images](#std-label-java-change-stream-configure-pre-post) ## Open a Change Stream You can open a change stream to subscribe to specific types of data changes and produce change events in your application. To open a change stream, call the `watch()` method on an instance of a`MongoCollection`, `MongoDatabase`, or `MongoClient`. ## Important Standalone MongoDB deployments don't support change streams because the feature requires a replica set oplog. To learn more about the oplog, see the [Replica Set Oplog](https://www.mongodb.com/docs/manual/core/replica-set-oplog/#std-label-replica-set-oplog) server manual page. The object on which you call the `watch()` method on determines the scope of events that the change stream listens for. If you call `watch()` on a `MongoCollection`, the change stream monitors a collection. If you call `watch()` on a `MongoDatabase`, the change stream monitors all collections in that database. If you call `watch()` on a `MongoClient`, the change stream monitors all changes in the connected MongoDB deployment. ### Example The following code example shows how to open a change stream and print change stream events whenever the data in the collection changes: `| // The collection variable references a MongoCollection instance  |\n| ----------------------------------------------------------------- |\n| ChangeStreamIterable<Document> changeStream = collection.watch(); |\n| changeStream.forEach(event ->                                     |\n| System.out.println(\"Received a change: \" + event));               | ` An insert operation on the collection should produce output similar to the following text: ``` Received a change: ChangeStreamDocument{    operationType='insert',    resumeToken={\"_data\": \"825EC...\"},    namespace=myDb.myChangeStreamCollection,    ... } \n``` For a runnable example, see the [Watch for Changes](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/watch/#std-label-java-usage-watch) usage example page. To learn more about the `watch()` method, see the following API documentation:\n\n ## Apply Aggregation Operators to your Change Stream You can pass an aggregation pipeline as a parameter to the `watch()` method to specify which change events the change stream receives. To learn which aggregation operators your MongoDB server version supports, see[Modify Change Stream Output.](https://www.mongodb.com/docs/manual/changeStreams/#std-label-change-stream-modify-output) ### Example The following code example shows how you can apply an aggregation pipeline to configure your change stream to receive change events for only insert and update operations: ```java List<Bson> pipeline = Arrays.asList(         Aggregates.match(Filters.in(\"operationType\", Arrays.asList(\"insert\", \"update\")))); // collection references a MongoCollection instance ChangeStreamIterable<Document> changeStream = collection.watch(pipeline); changeStream.forEach(event ->         System.out.println(\"Received a change to the collection: \" + event)); \n``` When the change stream receives an update change event, the preceding code example outputs the following text: ``` Received a change to the collection: ChangeStreamDocument{ operationType=update, resumeToken={...}, ... \n``` ## Include Pre-images and Post-images You can configure the change event to contain or omit the following data: * The **pre-image** which is a document that represents the version of the document before the operation if it exists\n* The **post-image** which is a document that represents the version of the document after the operation if it exists To receive change stream events that include a pre-image or post-image, you must connect to a MongoDB v6.0 or later deployment and set up the following: * Enable pre-images and post-images for the collection on your MongoDB deployment.  \n## Tip  \nTo learn how to enable these on your deployment, see the[Change Streams with Document Pre- and Post-Images](https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre--and-post-images)MongoDB server manual page.  \nTo learn how to instruct the driver to create a collection with pre-images and post-images enabled, see the [Create a Collection with Pre-Image and Post-Images Enabled](#std-label-java-change-stream-pre-post-collection)section.\n* Configure your change stream to retrieve either or both the pre-images and post-images.  \n## Tip  \nTo configure your change stream to include the pre-image, see the [Pre-image Configuration Example.](#std-label-java-pre-image-example)  \nTo configure your change stream to include the post-image, see the[Post-image Configuration Example.](#std-label-java-post-image-example) ### Create a Collection with Pre-Image and Post-Images Enabled To create a collection with the pre-image and post-image option using the driver, specify an instance of `ChangeStreamPreAndPostImagesOptions`and call the `createCollection()` method as shown in the following example: ```java CreateCollectionOptions collectionOptions = new CreateCollectionOptions(); collectionOptions.changeStreamPreAndPostImagesOptions(new ChangeStreamPreAndPostImagesOptions(true)); database.createCollection(\"myChangeStreamCollection\", collectionOptions); \n``` You can change the pre-image and post-image option in an existing collection by running the `collMod` command from the MongoDB Shell. To learn how to perform this operation, see the [collMod](https://www.mongodb.com/docs/manual/reference/command/collMod/#change-streams-with-document-pre--and-post-images)server manual documentation. ## Warning When you modify this option on a collection, any change streams open on that collection in your application may fail if configured to require receiving the pre-image or post-image. ### Pre-image Configuration Example The following code example shows how you can configure a change stream to include the pre-image and output the results: ```java ChangeStreamIterable<Document> changeStream = collection.watch()         .fullDocumentBeforeChange(FullDocumentBeforeChange.REQUIRED); changeStream.forEach(event ->         System.out.println(\"Received a change: \" + event)); \n```\n\n Suppose an application updated the `latestVersion` field of a document in a collection of software library dependencies from the value of `2.0.0` to`2.1.0`. The corresponding change event output by the preceding code example should resemble the following text: ``` Received a change: ChangeStreamDocument{ operationType=update, resumeToken={...} namespace=software.libraries, destinationNamespace=null, fullDocument=null, fullDocumentBeforeChange=Document{{_id=6388..., latestVersion=2.0.0, ...}}, ... \n``` For a list of options, see the [FullDocumentBeforeChange](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/changestream/FullDocumentBeforeChange.html)API documentation. ### Post-image Configuration Example The following code example shows how you can configure a change stream to include the post-image and output the results: ```java ChangeStreamIterable<Document> changeStream = collection.watch()         .fullDocument(FullDocument.UPDATE_LOOKUP); changeStream.forEach(event ->         System.out.println(\"Received a change: \" + event)); \n``` The preceding example configures the change stream to use the`FullDocument.UPDATE_LOOKUP` option. This configures the change stream to return both the deltas between the original and changed document and a copy of the document at some point in time after the change occurred. Suppose an application updated the `population` field of a document from the value of `800` to `950` in a collection of city census data. The corresponding change event output by the preceding code example should resemble the following text: ``` Received a change: ChangeStreamDocument{ operationType=update, resumeToken={...}, namespace=censusData.cities, destinationNamespace=null, fullDocument=Document{{_id=6388..., city=Springfield, population=950, ...}}, updatedFields={\"population\": 950}, ... ... \n``` For a list of options, see the [FullDocument](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/changestream/FullDocument.html)API documentation. ← [Access Data From a Cursor](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/cursor/ \"Previous Section\")[Sort Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/sort/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/project/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Specify Which Fields to Return On this page * [Overview](#overview)\n* [Behavior](#behavior)\n* [Explanation](#explanation) ## Overview In this guide, you can learn how to control which fields appear in documents returned from read operations with the MongoDB Java driver. Many read requests require only a subset of fields in a document. For example, when logging a user in you may only need their username, and not all of their profile information. By default, queries in MongoDB return all fields in matching documents. You can use a **projection** to return only the data you need. A projection is a document that instructs MongoDB which fields of a document to return. Use the [Projections](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/projections/#std-label-projections-builders) class to construct a projection document. ## Behavior Projections work in two ways: * Explicitly including fields. This has the side-effect of implicitly excluding all unspecified fields.\n* Implicitly excluding fields. This has the side-effect of implicitly including all unspecified fields. These two methods of projection are mutually exclusive: if you explicitly include fields, you cannot explicitly exclude fields, and vice versa. ## Important The `_id` field is **not** subject to these mechanics. You must explicitly exclude the `_id` field if you do not want it returned. You can exclude the `_id` field even if you have specified certain fields to include. ## Explanation Consider the following collection containing documents that describe varieties of fruit: `| { \"_id\": 1, \"name\": \"apples\", \"qty\": 5, \"rating\": 3 },   |\n| -------------------------------------------------------- |\n| { \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1 },  |\n| { \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 },  |\n| { \"_id\": 4, \"name\": \"avocados\", \"qty\": 3, \"rating\": 5 }, | ` In the following query, pass the projection to return the `name`field of each document: ```java // return all documents with *only* the name field Bson filter = Filters.empty(); Bson projection = Projections.fields(Projections.include(\"name\")); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc)); \n``` The projection document specifies that the read operation result should_include_ the `name` field of each returned document. As a result, this projection implicitly excludes the `qty` and `rating` fields. Chaining this projection to `find()` with an empty query filter yields the following results: ``` { \"_id\": 1, \"name\": \"apples\" } { \"_id\": 2, \"name\": \"bananas\" } { \"_id\": 3, \"name\": \"oranges\" } { \"_id\": 4, \"name\": \"avocados\" } \n``` Despite the fact that this projection only explicitly included the`name` field, the query returned the `_id` field as well. The `_id` field is a special case: it is always included in every query result unless explicitly excluded. That's because the `_id` field is a unique identifier for each document, a property that can be useful when constructing queries. A `movies` collection is a good example of why this property is useful: because remakes and even separate works sometimes reuse movie titles, you need a unique `_id` value to refer to any specific movie. The `_id` is the only exception to the mutually exclusive include-exclude behavior in projections: you _can_ explicitly exclude the `_id` field even when explicitly including other fields if you do not want `_id`to be present in returned documents. ```java // return all documents with only the name field Bson filter = Filters.empty(); Bson projection = Projections.fields(Projections.include(\"name\"), Projections.excludeId()); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc)); \n```\n\n ```javascript { \"name\": \"apples\" } { \"name\": \"bananas\" } { \"name\": \"oranges\" } { \"name\": \"avocados\" } \n``` You can also specify multiple fields to include in your projection. ## Tip The order in which you specify the fields in the projection does not alter the order in which they are returned. ```java Bson filter = Filters.empty(); Bson projection = Projections.fields(Projections.include(\"name\", \"rating\"), Projections.excludeId()); collection.find(filter).projection(projection).forEach(doc -> System.out.println(doc)); \n``` This example that identifies two fields to include in the projection yields the following results: ```   { \"name\": \"apples\", \"rating\": 3 }   { \"name\": \"bananas\", \"rating\": 1 }   { \"name\": \"oranges\", \"rating\": 2 }   { \"name\": \"avocados\", \"rating\": 5 } \n``` For additional projection examples, see the[MongoDB Manual page on Project Fields to Return from Query.](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/) ← [Limit the Number of Returned Results](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/limit/ \"Previous Section\")[Search Geospatially](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/read-operations/geo/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/bulk/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Bulk Operations On this page * [Overview](#overview)\n* [Performing Bulk Operations](#performing-bulk-operations)\n* [Insert Operation](#insert-operation)\n* [Replace Operation](#replace-operation)\n* [Update Operation](#update-operation)\n* [Delete Operation](#delete-operation)\n* [Order of Execution](#order-of-execution)\n* [Ordered Execution](#ordered-execution)\n* [Unordered Execution](#unordered-execution)\n* [Summary](#summary) ## Overview In this guide, you can learn how to use bulk operations in the MongoDB Java Driver. To perform a create, replace, update, or delete operation, use its corresponding method. For example, to insert one document, update multiple documents, and delete one document in your collection, use the `insertOne()`, `updateMany()` and `deleteOne()` methods. The `MongoClient` performs these operations by making a call for each operation to the database. You can reduce the number of calls to the database to one by using bulk operations. ## Performing Bulk Operations Bulk operations consist of a large number of write operations. To perform a bulk operation, pass a `List` of `WriteModel` documents to the`bulkWrite()` method. A `WriteModel` is a model that represents any of the write operations. The following sections show how to create and use each `WriteModel`document. The examples in each section contain the following documents in a collection: `| { \"_id\": 1 } |\n| ------------ |\n| { \"_id\": 2 } | ` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [bulkWrite()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#bulkWrite%28java.util.List,com.mongodb.client.model.BulkWriteOptions%29)\n* [WriteModel](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/WriteModel.html)\n* [BulkWriteOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/BulkWriteOptions.html) ### Insert Operation To perform an insert operation, create an `InsertOneModel` specifying the document you want to insert. To insert multiple documents, you must create an `InsertOneModel` for each document you want to insert. #### Example The following example creates an `InsertOneModel` for two documents where the `_id` values are \"3\" and \"4\": ```java InsertOneModel<Document> doc1 = new InsertOneModel<>(new Document(\"_id\", 3)); InsertOneModel<Document> doc2 = new InsertOneModel<>(new Document(\"_id\", 4)); \n``` ## Important When performing a `bulkWrite()`, the `InsertOneModel` cannot insert a document with an `_id` that already exists in the collection. Instead, the method throws a `MongoBulkWriteException`. The following example tries to insert two documents where the `_id` is \"1\" and \"3\": ```java try {     List<WriteModel<Document>> bulkOperations = new ArrayList<>();         InsertOneModel<Document> doc3 = new InsertOneModel<>(new Document(\"_id\", 1));     InsertOneModel<Document> doc4 = new InsertOneModel<>(new Document(\"_id\", 3));         bulkOperations.add(doc3);     bulkOperations.add(doc4);         collection.bulkWrite(bulkOperations);  } catch (MongoBulkWriteException e){     System.out.println(\"A MongoBulkWriteException occured with the following message: \" + e.getMessage()); } \n``` The following shows the output of the preceding code: ```shell A MongoBulkWriteException occurred with the following message:\n\n Write errors: [BulkWriteError{index=0, code=11000, message='E11000 duplicate key error collection: crudOps.bulkWrite index: _id_ dup key: { _id: 1 }', details={}}]. \n``` To see why the document with the `_id` of \"3\" didn't insert, see the [Order of Execution](#std-label-orderOfExecution) section. For more information about the methods and classes mentioned in this section, see the [InsertOneModel](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/InsertOneModel.html)API Documentation. ### Replace Operation To perform a replace operation, create a `ReplaceOneModel` specifying a query filter for the document you want to replace with the replacement document. ## Important When performing a `bulkWrite()`, the `ReplaceOneModel` cannot make changes to a document that violate unique index constraints on the collection, and the model does not replace a document if there are no matches to your query filter. #### Example The following example creates a `ReplaceOneModel` to replace a document where the `_id` is \"1\" with a document that contains an additional field: ```java ReplaceOneModel<Document> doc3 = new ReplaceOneModel<>(                                     Filters.eq(\"_id\", 1),                                      new Document(\"_id\", 1).append(\"x\", 4)); \n``` For more information about the methods and classes mentioned in this section, see the following resources: * [ReplaceOneModel](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/ReplaceOneModel.html) API Documentation\n* [Unique indexes](https://www.mongodb.com/docs/manual/core/index-unique/) Server Manual Explanation ### Update Operation To perform an update operation, create an `UpdateOneModel` or an`UpdateManyModel` specifying a query filter for documents you want to update with what the updates are. The `UpdateOneModel` updates the first document that matches your query filter and the `UpdateManyModel` updates all the documents that match your query filter. ## Important When performing a `bulkWrite()`, the `UpdateOneModel` and`UpdateManyModel` cannot make changes to a document that violate unique index constraints on the collection, and the models do not update any documents if there are no matches to your query filter. #### Example The following example creates an `UpdateOneModel` to update a document where the `_id` is \"2\" to a document that contains an additional field: ```java UpdateOneModel<Document> doc3 = new UpdateOneModel<>(                                     Filters.eq(\"_id\", 2),                                      Updates.set(\"x\", 8)); \n``` For more information about the methods and classes mentioned in this section, see the following resources: * [UpdateOneModel](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/UpdateOneModel.html) API Documentation\n* [UpdateManyModel](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/UpdateManyModel.html) API Documentation\n* [unique indexes](https://www.mongodb.com/docs/manual/core/index-unique/) Server Manual Explanation ### Delete Operation To perform a delete operation, create a `DeleteOneModel` or a`DeleteManyModel` specifying a query filter for documents you want to delete.\n\n ## Important When performing a `bulkWrite()`, the `DeleteOneModel` and`DeleteManyModel` do not delete any documents if there are no matches to your query filter. #### Example The following example creates a `DeleteOneModel` to delete a document where the `_id` is \"1\": ```java DeleteOneModel<Document> doc3 = new DeleteOneModel<>(Filters.eq(\"_id\", 1)); \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [DeleteOneModel](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/DeleteOneModel.html)\n* [DeleteManyModel](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/DeleteManyModel.html) ## Order of Execution The `bulkWrite()` method accepts an optional `BulkWriteOptions` as a second parameter to specify if you want to execute the bulk operations as ordered or unordered. ### Ordered Execution By default, the `bulkWrite()` method executes bulk operations in order. This means that the bulk operations execute in the order you added them to the list until an error occurs, if any. #### Example The following example performs these bulk operations: * An insert operation for a document where the `_id` is \"3\"\n* A replace operation for a document where the `_id` is \"1\" with a document that contains an additional field\n* An update operation for a document where the `_id` is \"3\" to a document that contains an additional field\n* A delete operation for all documents that contain the field `x` with the value \"2\" ```java List<WriteModel<Document>> bulkOperations = new ArrayList<>(); InsertOneModel<Document> doc1 = new InsertOneModel<>(new Document(\"_id\", 3)); ReplaceOneModel<Document> doc2 = new ReplaceOneModel<>(Filters.eq(\"_id\", 1),                                      new Document(\"_id\", 1).append(\"x\", 2));                             UpdateOneModel<Document> doc3 = new UpdateOneModel<>(Filters.eq(\"_id\", 3), Updates.set(\"x\", 2)); DeleteManyModel<Document> doc4 = new DeleteManyModel<>(Filters.eq(\"x\", 2)); bulkOperations.add(doc1); bulkOperations.add(doc2); bulkOperations.add(doc3); bulkOperations.add(doc4); collection.bulkWrite(bulkOperations);                \n``` After running this example, your collection contains the following document: ``` { \"_id\": 2 } \n``` ### Unordered Execution You can also execute bulk operations in any order by specifying \"false\" to the `order()` method on `BulkWriteOptions`. This means that all the write operations execute regardless of errors and if any errors occur the bulk operation reports them at the end. Adding to the preceding example, including the following specifies the bulk operations to execute in any order: ```java BulkWriteOptions options = new BulkWriteOptions().ordered(false); collection.bulkWrite(bulkOperations, options);  \n``` ## Note Unordered bulk operations do not guarantee order of execution. The order may differ from the way you list them to optimize the runtime. In the preceding example, if the `bulkWrite()` method decided to perform the insert operation after the update operation, nothing changes with the update operation because the document does not exist at that point in time. Your collection then contains the following documents: ``` { \"_id\": 2 } { \"_id\": 3 } \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation:\n\n ## Summary To perform a bulk operation, you create and pass a list of`WriteModel` documents to the `bulkWrite()` method. There are 6 different `WriteModel` documents: `InsertOneModel`,`ReplaceOneModel`, `UpdateOneModel`, `UpdateManyModel`,`DeleteOneModel` and `DeleteManyModel`. There are two ways to execute the `bulkWrite()` method: * Ordered, which performs the bulk operations in order until an error occurs, if any\n* Unordered, which performs all the bulk operations in any order and reports errors at the end, if any ← [Insert or Update in a Single Operation](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/upsert/ \"Previous Section\")[Specify a Query](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/query-document/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/embedded-arrays/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Update Arrays in a Document On this page * [Overview](#overview)\n* [Sample Document](#sample-document)\n* [Specifying an Update](#specifying-an-update)\n* [Specifying Array Elements](#specifying-array-elements)\n* [The First Matching Array Element](#the-first-matching-array-element)\n* [Matching All Array Elements](#matching-all-array-elements)\n* [Matching Multiple Array Elements](#matching-multiple-array-elements) ## Overview In this guide, you can learn how to update arrays in a document with the MongoDB Java driver. To update an array, you must do the following: * Specify the update you want to perform\n* Specify what array elements to apply your update to\n* Perform an update operation using these specifications ### Sample Document The following sections feature examples that update this sample document: `| { \"_id\": 1, \"color\": \"green\", \"qty\": [8, 12, 18] } |\n| -------------------------------------------------- | ` The examples on this page use the `findOneAndUpdate()` method of the`MongoCollection` class to retrieve and update the document. Each example uses an instance of the `FindOneAndUpdateOptions` class to have MongoDB retrieve the document after the update occurs. For more information on the `findOneAndUpdate()` method, see our[Compound Operations guide.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/compound-operations/) ## Specifying an Update To specify an update, use the `Updates` builder. The `Updates`builder provides static utility methods to construct update specifications. For more information on using the `Updates` builder with arrays, see our [guide on the Updates builder.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/#std-label-array%5Fupdates) The following example performs these actions: * Query for the sample document\n* Append \"17\" to the `qty` array in the document that matches the query filter ```java Bson filter = Filters.eq(\"_id\", 1); Bson update = Updates.push(\"qty\", 17); FindOneAndUpdateOptions options = new FindOneAndUpdateOptions()                                     .returnDocument(ReturnDocument.AFTER); Document result = collection.findOneAndUpdate(filter, update, options); System.out.println(result.toJson()); \n``` The preceding example updates the original document to the following state: ``` { \"_id\": 1, \"color\": \"green\", \"qty\": [8, 12, 18, 17] } \n``` ## Specifying Array Elements You can specify which array elements to update using a positional operator. Positional operators can specify the first, all, or certain array elements to update. To specify elements in an array with positional operators, use **dot notation**. Dot notation is a property access syntax for navigating BSON objects. For additional information, see the Server Manual Entry on[dot notation.](https://www.mongodb.com/docs/manual/core/document/#std-label-document-dot-notation) ### The First Matching Array Element To update the first array element that matches your query filter, use the positional `$` operator. The array field must appear as part of your query filter to use the positional `$` operator. #### Example The following example performs these actions: * Query for a document with a `qty` field containing the value \"18\"\n* Decrement the first array value in the document that matches the query filter by \"3\" ```java Bson filter = Filters.eq(\"qty\", 18); Bson update = Updates.inc(\"qty.$\", -3); FindOneAndUpdateOptions options = new FindOneAndUpdateOptions()                                     .returnDocument(ReturnDocument.AFTER); Document result = collection.findOneAndUpdate(filter, update, options); System.out.println(result.toJson()); \n``` The preceding example updates the original document to the following state: ```\n\n \n``` For more information about the methods and operators mentioned in this section, see the following resources: * [Positional $ Operator](https://www.mongodb.com/docs/manual/reference/operator/update/positional/) Server Manual Entry\n* [inc()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#inc%28java.lang.String,java.lang.Number%29) API Documentation ### Matching All Array Elements To update all elements in an array, use the all positional `$[]` operator. #### Example The following example performs these actions: * Query for the sample document\n* Multiply array elements matching the query filter by \"2\" ```java Bson filter = Filters.eq(\"_id\", 1); Bson update = Updates.mul(\"qty.$[]\", 2); FindOneAndUpdateOptions options = new FindOneAndUpdateOptions()                                     .returnDocument(ReturnDocument.AFTER); Document result = collection.findOneAndUpdate(filter, update, options); System.out.println(result.toJson()); \n``` The preceding example updates the original document to the following state: ``` { \"_id\": 1, \"color\": \"green\", \"qty\": [16, 24, 36] } \n``` For more information about the methods and operators mentioned in this section, see the following resources: * [All Positional $\\[\\] Operator](https://www.mongodb.com/docs/manual/reference/operator/update/positional-all/) Server Manual Entry\n* [mul()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#mul%28java.lang.String,java.lang.Number%29) API Documentation ### Matching Multiple Array Elements To update array elements that match a filter, use the filtered positional `$[<identifier>]` operator. You must include an array filter in your update operation to specify which array elements to update. The `<identifier>` is the name you give your array filter. This value must begin with a lowercase letter and contain only alphanumeric characters. #### Example The following example performs these actions: * Query for the sample document\n* Set an array filter to search for values less than \"15\"\n* Increment array elements matching the query filter by \"5\" ```java Bson filter = Filters.eq(\"_id\", 1); Bson smallerFilter = Filters.lt(\"smaller\", 15); FindOneAndUpdateOptions options = new FindOneAndUpdateOptions()                                     .returnDocument(ReturnDocument.AFTER)                                     .arrayFilters(Arrays.asList(smallerFilter)); Bson update = Updates.inc(\"qty.$[smaller]\", 5); Document result = collection.findOneAndUpdate(filter, update, options); System.out.println(result.toJson()); \n``` The preceding example updates the original document to the following state: ``` { \"_id\": 1, \"color\": \"green\", \"qty\": [13, 17, 18] } \n``` For more information about the methods and operators mentioned in this section, see the following resources: * [Filtered Positional $\\[<identifier>\\] Operator](https://www.mongodb.com/docs/manual/reference/operator/update/positional-filtered/) Server Manual Entry\n* [inc()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html#inc%28java.lang.String,java.lang.Number%29) API Documentation\n\n",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/insert/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Insert Operations On this page * [Overview](#overview)\n* [A Note About \\_id](#a-note-about-%5Fid)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Summary](#summary) ## Overview In this guide, you can learn how to insert documents with the MongoDB Java driver. You can use MongoDB to retrieve, update, and delete information. To perform any of those operations, that information, such as user profiles and orders, needs to exist in MongoDB. For that information to exist, you need to first perform an insert operation. An insert operation inserts a single or multiple documents into MongoDB using the `insertOne()`, `insertMany()`, and `bulkWrite()`methods. The following sections focus on `insertOne()` and`insertMany()`. For information on how to use the `bulkWrite()`method, see our[guide on Bulk Operations.](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/bulk/) ## A Note About `_id` When inserting a document, MongoDB enforces one constraint on your documents by default: each document _must_ contain a unique `_id`field. There are two ways to manage this field: * You can manage this field yourself, ensuring each value you use is unique.\n* You can let the driver automatically generate unique ObjectId values. Unless you have provided strong guarantees for uniqueness, we recommend you let the driver automatically generate `_id` values. ## Note Duplicate `_id` values violate unique index constraints, resulting in a `WriteError`. For additional information on unique indexes, see the manual entry on[Unique Indexes.](https://www.mongodb.com/docs/manual/core/index-unique/) ## Insert a Single Document Use the `insertOne()` method when you want to insert a single document. On successful insertion, the method returns an `InsertOneResult`instance representing the `_id` of the new document. ### Example The following example creates and inserts a document using the`insertOne()` method: `| Document doc1 = new Document(\"color\", \"red\").append(\"qty\", 5);   |\n| ---------------------------------------------------------------- |\n| InsertOneResult result = collection.insertOne(doc1);             |\n| System.out.println(\"Inserted a document with the following id: \" |\n| + result.getInsertedId().asObjectId().getValue());               | ` Your output should look something like this: ``` Inserted a document with the following id: 60930c39a982931c20ef6cd6 \n``` For more information about the methods and classes mentioned in this section, see the following resources: * [insertOne()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#insertOne%28TDocument%29) API Documentation\n* [InsertOneResult](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/result/InsertOneResult.html) API Documentation\n* Manual Explanation on [insertOne()](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertOne/)\n* Runnable [Insert a Document Example](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertOne/) ## Insert Multiple Documents Use the `insertMany()` method when you want to insert multiple documents. This method inserts documents in the order specified until an exception occurs, if any. For example, assume you want to insert the following documents: ``` { \"_id\": 3, \"color\": \"red\", \"qty\": 5 } { \"_id\": 4, \"color\": \"purple\", \"qty\": 10 } { \"_id\": 3, \"color\": \"yellow\", \"qty\": 3 } { \"_id\": 6, \"color\": \"blue\", \"qty\": 8 } \n```\n\n ## Tip Use a try-catch block to get an acknowledgment for successfully processed documents before the error occurs: ```java List<Integer> insertedIds = new ArrayList<>(); try {     InsertManyResult result = collection.insertMany(documents);       result.getInsertedIds().values()         .forEach(doc -> insertedIds.add(doc.asInt32().getValue()));     System.out.println(\"Inserted documents with the following ids: \" + insertedIds); } catch(MongoBulkWriteException exception) {     exception.getWriteResult().getInserts()         .forEach(doc -> insertedIds.add(doc.getId().asInt32().getValue()));     System.out.println(\"A MongoBulkWriteException occurred, but there are \" +          \"successfully processed documents with the following ids: \" + insertedIds); } \n``` The output consists of documents MongoDB can process and should look something like this: ``` A MongoBulkWriteException occurred, but there are successfully processed documents with the following ids: [3, 4, 6] \n``` If you look inside your collection, you should see the following documents: ``` { \"_id\": 3, \"color\": \"red\", \"qty\": 5 } { \"_id\": 4, \"color\": \"purple\", \"qty\": 10 } \n``` On successful insertion, the method returns an `InsertManyResult`instance representing the `_id` of each new document. ### Example The following example creates and adds two documents to a `List`, and inserts the `List` using the `insertMany()` method: ```java List<Document> documents = new ArrayList<>(); Document doc1 = new Document(\"color\", \"red\").append(\"qty\", 5); Document doc2 = new Document(\"color\", \"purple\").append(\"qty\", 10); documents.add(doc1); documents.add(doc2); InsertManyResult result = collection.insertMany(documents); List<ObjectId> insertedIds = new ArrayList<>(); result.getInsertedIds().values()     .forEach(doc -> insertedIds.add(doc.asObjectId().getValue())); System.out.println(\"Inserted documents with the following ids: \" + insertedIds); \n``` Your output should look something like this: ``` Inserted documents with the following ids: [60930c3aa982931c20ef6cd7, 60930c3aa982931c20ef6cd8] \n``` For more information about the methods and classes mentioned in this section, see the following resources: * [insertMany()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#insertMany%28java.util.List%29) API Documentation\n* [InsertManyResult](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/result/InsertManyResult.html) API Documentation\n* Manual Explanation on [insertMany()](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/)\n* Runnable [Insert Multiple Documents Example](https://mongodb.com/docs/drivers/java/sync/current/usage-examples/insertMany/) ## Summary There are three ways to perform an insert operation, but we focused on two: * The `insertOne()` method inserts a single document.\n* The `insertMany()` method inserts multiple documents. Both methods automatically generate an `_id` if you omit the field in your document. If the insertion is successful, both methods return an instance representing the `_id` of each new document. ← [Write Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/ \"Previous Section\")[Delete a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/change-a-document/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Change a Document On this page * [Overview](#overview)\n* [Update](#update)\n* [Update Operation Parameters](#update-operation-parameters)\n* [Replace](#replace)\n* [Replace Operation Parameters](#replace-operation-parameters) ## Overview In this guide, you can learn how to change documents in a MongoDB collection using two distinct operation types: * [Update](#std-label-update-operation)\n* [Replace](#std-label-replace-operation) Update operations specify the fields and values to change in one or more documents. A replace operation specifies the fields and values to replace a single document from your collection. In the following examples, a paint store sells five different colors of paint. The `paint_inventory` collection represents their current inventory: `| { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }    |\n| ----------------------------------------- |\n| { \"_id\": 2, \"color\": \"purple\", \"qty\": 8 } |\n| { \"_id\": 3, \"color\": \"yellow\", \"qty\": 0 } |\n| { \"_id\": 4, \"color\": \"green\", \"qty\": 6 }  |\n| { \"_id\": 5, \"color\": \"pink\", \"qty\": 0 }   | ` ## Update Update operations can change fields and values. They apply changes specified in an update document to one or more documents that match your query filter. The [updateOne()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#updateOne%28org.bson.conversions.Bson,org.bson.conversions.Bson%29)method changes the first document your query filter matches and the[updateMany()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#updateMany%28org.bson.conversions.Bson,org.bson.conversions.Bson%29)method changes all the documents your query filter matches. You can call the `updateOne()` and `updateMany()` methods on a`MongoCollection` instance as follows: ```java collection.updateOne(query, updateDocument); collection.updateMany(query, updateDocument); \n``` ### Update Operation Parameters The `updateOne()` and `updateMany()` methods both have the following parameters: * `query` specifies a query filter with the criteria to match documents to update in your collection\n* `updateDocument` specifies the fields and values to change in the matching document or documents. For this example, we use the [Updates builder](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/builders/updates/) to create the update document. You can create the `updateDocument` using an `Updates` builder as follows: ```java Bson updateDocument = Updates.operator(field, value); \n``` See the MongoDB API documentation for a [complete list of Updates builders and their usage.](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/Updates.html) #### Example The paint store receives a fresh shipment and needs to update their inventory. The shipment contains 20 cans of each paint color. To update the inventory, call the `updateMany()` method specifying the following: * A query filter that matches all the colors\n* An update document that contains instructions to increment the `qty` field by \"20\" ```java Bson filter = Filters.empty(); Bson update = Updates.inc(\"qty\", 20); UpdateResult result = collection.updateMany(filter, update); System.out.println(\"Matched document count: \" + result.getMatchedCount()); System.out.println(\"Modified document count: \" + result.getModifiedCount()); \n``` Your output should look something like this: ```  Matched document count: 5  Modified document count: 5 \n``` The following shows the updated documents in the `paint_inventory` collection: ```\n\n  { \"_id\": 2, \"color\": \"purple\", \"qty\": 28 }  { \"_id\": 3, \"color\": \"yellow\", \"qty\": 20 }  { \"_id\": 4, \"color\": \"green\", \"qty\": 26 }  { \"_id\": 5, \"color\": \"pink\", \"qty\": 20 } \n``` If zero documents match the query filter in the update operation,`updateMany()` makes no changes to documents in the collection. See our [upsert guide](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/upsert/) to learn how to insert a new document instead of updating one if no documents match. ## Important The `updateOne()` and `updateMany()` methods cannot make changes to a document that violate unique index constraints on the collection. See the MongoDB server manual for more information on[unique indexes.](https://www.mongodb.com/docs/manual/core/index-unique/) ## Replace A replace operation substitutes one document from your collection. The substitution occurs between a document your query filter matches and a replacement document. The [replaceOne()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#replaceOne%28org.bson.conversions.Bson,TDocument%29)method removes all the existing fields and values in the matching document (except the `_id` field) and substitutes it with the replacement document. You can call the `replaceOne()` method on a `MongoCollection`instance as follows: ```java collection.replaceOne(query, replacementDocument); \n``` ### Replace Operation Parameters The `replaceOne()` method has the following parameters: * `query` specifies a query filter with the criteria to match a document to replace in your collection\n* `replacementDocument` specifies fields and values of a new `Document` object to replace in the matched document #### Example The paint store realizes they need to update their inventory again. What they thought was 20 cans of pink paint is actually 25 cans of orange paint. To update the inventory, call the `replaceOne()` method specifying the following: * A query filter that matches documents where the `color` is \"pink\"\n* A replacement document where the `color` is \"orange\" and the `qty` is \"25\" ```java Bson filter = Filters.eq(\"color\", \"pink\"); Document document = new Document(\"color\", \"orange\").append(\"qty\", 25); UpdateResult result = collection.replaceOne(filter, document); System.out.println(\"Matched document count: \" + result.getMatchedCount()); System.out.println(\"Modified document count: \" + result.getModifiedCount()); \n``` Your output should look something like this: ```  Matched document count: 1  Modified document count: 1 \n``` The following shows the updated document: ```  { \"_id\": 5, \"color\": \"orange\", \"qty\": 25 } \n``` If zero documents match the query filter in the replace operation,`replaceOne()` makes no changes to documents in the collection. See our [upsert guide](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/upsert/) to learn how to insert a new document instead of replacing one if no documents match. If multiple documents match the query filter specified in the `replaceOne()` method, it replaces the first result. ## Important The `replaceOne()` method cannot make changes to a document that violate unique index constraints on the collection. See the MongoDB server manual for more information on [unique indexes.](https://www.mongodb.com/docs/manual/core/index-unique/) ← [Delete a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/delete/ \"Previous Section\")[Update Arrays in a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/embedded-arrays/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Delete a Document On this page * [Overview](#overview)\n* [Sample Documents](#sample-documents)\n* [Delete Many Documents](#delete-many-documents)\n* [Delete a Document](#delete-a-document-1)\n* [Find and Delete a Document](#find-and-delete-a-document) ## Overview In this guide, you can learn how to remove documents with the MongoDB Java driver. You can remove documents by passing a query filter to the`deleteOne()`, `deleteMany()` or `findOneAndDelete()` methods. The `deleteOne()` method deletes a single document. If the query filter matches more than one document, the method will remove the first occurrence of a match in the collection. The `deleteMany()` method deletes all documents that match the query filter. The `findOneAndDelete()` method atomically finds and deletes the first occurrence of a match in the collection. To specify a collation or hint an index, use `DeleteOptions`as a second parameter to the `deleteOne()` and `deleteMany()` methods. To specify a collation, hint an index, specify sort order, or specify a projection on the returned document, use `FindOneAndDeleteOptions`as the second parameter to the `findOneAndDelete()` method. ### Sample Documents The following examples are about a paint store that sells eight different colors of paint. The store had their annual online sale resulting in the following documents in their `paint_inventory` collection: `| { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }    |\n| ----------------------------------------- |\n| { \"_id\": 2, \"color\": \"purple\", \"qty\": 8 } |\n| { \"_id\": 3, \"color\": \"blue\", \"qty\": 0 }   |\n| { \"_id\": 4, \"color\": \"white\", \"qty\": 0 }  |\n| { \"_id\": 5, \"color\": \"yellow\", \"qty\": 6 } |\n| { \"_id\": 6, \"color\": \"pink\", \"qty\": 0 }   |\n| { \"_id\": 7, \"color\": \"green\", \"qty\": 0 }  |\n| { \"_id\": 8, \"color\": \"black\", \"qty\": 8 }  | ` ## Delete Many Documents The paint store website displays all documents in the`paint_inventory` collection. To reduce customer confusion, the store wants to remove the colors that are out of stock. To remove the out of stock colors, query the `paint_inventory`collection where the `qty` is `0` and pass the query to the`deleteMany()` method: ```java Bson filter = Filters.eq(\"qty\", 0); collection.deleteMany(filter); \n``` The following shows the documents remaining in the `paint_inventory`collection: ```  { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }  { \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }  { \"_id\": 5, \"color\": \"yellow\", \"qty\": 6 }  { \"_id\": 8, \"color\": \"black\", \"qty\": 8 } \n``` ## Delete a Document The store is donating the remaining quantity of their yellow paint. This means that the `qty` for yellow is now `0` and we need to remove yellow from the collection. To remove yellow, query the `paint_inventory` collection where the`color` is `\"yellow\"` and pass the query to the `deleteOne()`method: ```java Bson filter = Filters.eq(\"color\", \"yellow\"); collection.deleteOne(filter); \n``` The following shows the documents remaining in the `paint_inventory`collection: ```  { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }  { \"_id\": 2, \"color\": \"purple\", \"qty\": 8 }  { \"_id\": 8, \"color\": \"black\", \"qty\": 8 } \n``` ## Find and Delete a Document The store would like to raffle the remaining quantity of purple paint and remove purple from the `paint_inventory` collection.\n\n ```java Bson filter = Filters.eq(\"qty\", 8); System.out.println(collection.findOneAndDelete(filter).toJson()); \n``` Unlike the other delete methods, `findOneAndDelete()` returns the deleted document: ```  { \"_id\": 2, \"color\": \"purple\", \"qty\": 8 } \n``` ## Note If there are no matches to your query filter, no document gets deleted and the method returns `null`. The following shows the documents remaining in the `paint_inventory`collection: ```  { \"_id\": 1, \"color\": \"red\", \"qty\": 5 }  { \"_id\": 8, \"color\": \"black\", \"qty\": 8 } \n``` For more information about the methods and classes mentioned in this guide, see the following resources: * [deleteOne()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#deleteOne%28org.bson.conversions.Bson%29) API Documentation\n* [deleteMany()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#deleteMany%28org.bson.conversions.Bson%29) API Documentation\n* [findOneAndDelete()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-sync/com/mongodb/client/MongoCollection.html#findOneAndDelete%28org.bson.conversions.Bson%29) API Documentation\n* [DeleteOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/DeleteOptions.html) API Documentation\n* [FindOneAndDeleteOptions](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/FindOneAndDeleteOptions.html) API Documentation\n* [db.collection.deleteOne()](https://www.mongodb.com/docs/manual/reference/method/db.collection.deleteMany/) Server Manual Entry\n* [db.collection.deleteMany()](https://www.mongodb.com/docs/manual/reference/method/db.collection.deleteOne/) Server Manual Entry\n* [db.collection.findOneAndDelete()](https://www.mongodb.com/docs/manual/reference/method/db.collection.findOneAndDelete/) Server Manual Entry ← [Insert Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/insert/ \"Previous Section\")[Change a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/change-a-document/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/upsert/": " [Docs Home](https://www.mongodb.com/docs/) → [Java Sync](https://mongodb.com/docs/drivers/java/sync/current/) # Insert or Update in a Single Operation On this page * [Overview](#overview)\n* [Specify an Upsert](#specify-an-upsert) ## Overview In this guide, you can learn how to perform an **upsert** with the MongoDB Java driver. Applications use insert and update operations to store and modify data. Sometimes, you need to choose between an insert and update depending on whether the document exists. MongoDB simplifies this decision for us with an `upsert` option. An `upsert`: * Updates documents that match your query filter\n* Inserts a document if there are no matches to your query filter ## Specify an Upsert To specify an upsert with the `updateOne()` or `updateMany()`methods, pass `true` to `UpdateOptions.upsert()`. To specify an upsert with the `replaceOne()` method, pass `true` to`ReplaceOptions.upsert()`. In the following example, a paint store sells eight different colors of paint. The store had their annual online sale. Their`paint_inventory` collection now shows the following documents: `| { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958da\" }, \"color\": \"red\", \"qty\": 5 }    |\n| ------------------------------------------------------------------------------ |\n| { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958db\" }, \"color\": \"purple\", \"qty\": 8 } |\n| { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dc\" }, \"color\": \"blue\", \"qty\": 0 }   |\n| { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dd\" }, \"color\": \"white\", \"qty\": 0 }  |\n| { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958de\" }, \"color\": \"yellow\", \"qty\": 6 } |\n| { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958df\" }, \"color\": \"pink\", \"qty\": 0 }   |\n| { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e0\" }, \"color\": \"green\", \"qty\": 0 }  |\n| { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e1\" }, \"color\": \"black\", \"qty\": 8 }  | ` The store received a fresh shipment and needs to update their inventory. The first item in the shipment is ten cans of orange paint. To update the inventory, query the `paint_inventory` collection where the `color` is `\"orange\"`, specify an update to `increment` the`qty` field by `10`, and specify `true` to`UpdateOptions.upsert()`: ```java Bson filter = Filters.eq(\"color\", \"orange\"); Bson update = Updates.inc(\"qty\", 10); UpdateOptions options = new UpdateOptions().upsert(true); System.out.println(collection.updateOne(filter, update, options)); \n``` The method returns: ```  AcknowledgedUpdateResult{ matchedCount=0, modifiedCount=0, upsertedId=BsonObjectId{ value=606b4cfc1601f9443b5d6978 }} \n``` This `AcknowledgedUpdateResult` tells us: * Zero documents matched our query filter\n* Zero documents in our collection got modified\n* A document with an `_id` of `606b4cfc1601f9443b5d6978` got upserted The following shows the documents in the `paint_inventory` collection: ```  { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958da\" }, \"color\": \"red\", \"qty\": 5 }  { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958db\" }, \"color\": \"purple\", \"qty\": 8 }\n\n  { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958dd\" }, \"color\": \"white\", \"qty\": 0 }  { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958de\" }, \"color\": \"yellow\", \"qty\": 6 }  { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958df\" }, \"color\": \"pink\", \"qty\": 0 }  { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e0\" }, \"color\": \"green\", \"qty\": 0 }  { \"_id\": { \"$oid\": \"606b4cfbcd83be7518b958e1\" }, \"color\": \"black\", \"qty\": 8 }  { \"_id\": { \"$oid\": \"606b4cfc1601f9443b5d6978\" }, \"color\": \"orange\", \"qty\": 10 }] \n``` ## Note Not including `UpdateOptions` results in no change to the collection. ```java Bson filter = Filters.eq(\"color\", \"orange\"); Bson update = Updates.inc(\"qty\", 10); System.out.println(collection.updateOne(filter, update)); \n``` The method returns: ```  AcknowledgedUpdateResult{ matchedCount=0, modifiedCount=0, upsertedId=null } \n``` For more information about the methods and classes mentioned in this section, see the following API Documentation: * [UpdateOptions.upsert()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/UpdateOptions.html#upsert%28boolean%29)\n* [ReplaceOptions.upsert()](https://mongodb.github.io/mongo-java-driver/4.9/apidocs/mongodb-driver-core/com/mongodb/client/model/ReplaceOptions.html#upsert%28boolean%29) ← [Update Arrays in a Document](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/embedded-arrays/ \"Previous Section\")[Bulk Operations](https://mongodb.com/docs/drivers/java/sync/current/fundamentals/crud/write-operations/bulk/ \"Next Section\") →"
}