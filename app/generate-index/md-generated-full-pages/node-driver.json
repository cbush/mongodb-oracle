{
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Fundamentals Learn how to perform the following tasks using the Node.js driver in the Fundamentals section: * [Connect to MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/)\n* [Use the Stable API](https://mongodb.com/docs/drivers/node/current/fundamentals/stable-api/)\n* [Authenticate with MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/)\n* [Read from and Write to MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/)\n* [Access Return Values](https://mongodb.com/docs/drivers/node/current/fundamentals/promises/)\n* [Transform your Data](https://mongodb.com/docs/drivers/node/current/fundamentals/aggregation/)\n* [Create and Manage Transactions](https://mongodb.com/docs/drivers/node/current/fundamentals/transactions/)\n* [Create Indexes to Speed Up Queries](https://mongodb.com/docs/drivers/node/current/fundamentals/indexes/)\n* [Sort Using Collations](https://mongodb.com/docs/drivers/node/current/fundamentals/collations/)\n* [Log Events in the Driver](https://mongodb.com/docs/drivers/node/current/fundamentals/logging/)\n* [Monitor Driver Events](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/)\n* [Store and Retrieve Large Files in MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/gridfs/)\n* [Encrypt Fields from the Client](https://mongodb.com/docs/drivers/node/current/fundamentals/encrypt-fields/)\n* [Create and Query Time Series Collection](https://mongodb.com/docs/drivers/node/current/fundamentals/time-series/)\n* [Specify Type Parameters with TypeScript](https://mongodb.com/docs/drivers/node/current/fundamentals/typescript/)\n* [Specify UTF-8 Validation Settings](https://mongodb.com/docs/drivers/node/current/fundamentals/utf8-validation/) ← [Perform Bulk Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/bulkWrite/ \"Previous Section\")[Connection](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Usage Examples On this page * [Overview](#overview)\n* [How to Use the Usage Examples](#how-to-use-the-usage-examples)\n* [Available Usage Examples](#available-usage-examples) ## Overview Usage examples provide convenient starting points for popular MongoDB operations. Each example provides: * an explanation of the operation in the example showing the purpose and a sample use case for the method\n* an explanation of how to use the operation, including parameters, return values, and common exceptions you might encounter\n* a full Node.js program that you can copy and paste to run the example in your own environment ## How to Use the Usage Examples These examples use the[MongoDB Atlas sample data](https://www.mongodb.com/docs/atlas/sample-data/?tck=docs%5Fdriver%5Fnodejs)database. You can use this sample data on the free tier of MongoDB Atlas by following the [Get Started with Atlas](https://www.mongodb.com/docs/atlas/getting-started/#atlas-getting-started?tck=docs%5Fdriver%5Fnodejs) guide or you can [import the sample dataset into a local MongoDB instance.](https://www.mongodb.com/docs/guides/server/import/) Once you have imported the dataset, you can copy and paste a usage example into your development environment of choice. You can follow the[quick start guide](https://mongodb.com/docs/drivers/node/current/quick-start/) to learn more about getting started with Node.js, npm, and the Node.js driver. Once you've copied a usage example, you'll have to edit one line to get the example running with your instance of MongoDB: `| // Replace the following with your MongoDB deployment's connection string.              |\n| --------------------------------------------------------------------------------------- |\n| const uri =                                                                             |\n| \"mongodb+srv://<user>:<password>@<cluster-url>?retryWrites=true&writeConcern=majority\"; | ` All examples use ES module imports. You can[enable ES module imports](https://nodejs.org/api/esm.html#esm%5Fenabling)by adding the following key-value pair to your package.json file: ``` \"type\": \"module\" \n``` ## Note ### CommonJS You can use any usage example with CommonJS `require`. To use CommonJS `require`, you must swap out the ES module `import` statement for your CommonJS `require`statement. Click on the tabs to see the syntax for importing the driver with ES module`import` and CommonJS `require`: You can use the [Atlas Connectivity Guide](https://www.mongodb.com/docs/guides/cloud/connectionstring/) to enable connectivity to your instance of Atlas and find the [connection string](https://www.mongodb.com/docs/manual/reference/connection-string/) to replace the `uri` variable in the usage example. If your instance uses [SCRAM authentication](https://www.mongodb.com/docs/manual/core/security-scram/), you can replace `<user>` with your username,`<password>` with your password, and `<cluster-url>` with the IP address or URL of your instance. Consult the[Connection Guide](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/) for more information about getting connected to your MongoDB instance. ## Available Usage Examples\n\n ← [Quick Reference](https://mongodb.com/docs/drivers/node/current/quick-reference/ \"Previous Section\")[Find Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/find-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Quick Start On this page * [Overview](#overview) ## Overview This guide shows you how to create an application that uses the MongoDB Node.js driver to connect to a MongoDB cluster hosted on MongoDB Atlas. If you prefer to connect to MongoDB using a different driver or programming language, see our [list of official drivers.](https://www.mongodb.com/docs/drivers/) The Node.js driver is a library of functions that you can use to connect to and communicate with MongoDB. MongoDB Atlas is a fully managed cloud database service that hosts your MongoDB deployments. You can create your own free (no credit card required) MongoDB Atlas deployment by following the steps in this guide. Follow the steps in this guide to connect a sample Node.js application to a MongoDB Atlas deployment. [Next: Download and Install](https://mongodb.com/docs/drivers/node/current/quick-start/download-and-install/) ← [MongoDB Node Driver](https://mongodb.com/docs/drivers/node/current/ \"Previous Section\")[Download and Install](https://mongodb.com/docs/drivers/node/current/quick-start/download-and-install/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/issues-and-help/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Issues & Help Our developer community is vibrant and highly engaged, with extensive experience using Node.js with MongoDB. Often, the quickest way to get support for general questions is through the[MongoDB Community Forums.](https://www.mongodb.com/community/forums) Refer to our [support channels](https://www.mongodb.com/docs/manual/support/) documentation for more information. ## Bugs / Feature Requests To report a bug or to request a new feature in the Node.js driver, please open a case in our issue management tool, JIRA: * [Create an account and login](https://jira.mongodb.org).\n* Navigate to [the NODE project](https://jira.mongodb.org/browse/NODE).\n* Click **Create Issue**. Please provide as much information as possible about the issue and the steps to reproduce it. Bug reports in JIRA for the Node.js driver and the Core Server (i.e. SERVER) project are **public**. If you’ve identified a security vulnerability in a driver or any other MongoDB project, please report it according to the instructions found in the [Create a Vulnerability Report.](https://www.mongodb.com/docs/manual/tutorial/create-a-vulnerability-report/) ## Pull Requests We are happy to accept contributions to help improve the driver. We will review user contributions to ensure they meet the standards of the codebase. Pull requests must pass the `travis.ci` checks as well as include documentation and tests. To get started check out the source and work on a branch: `| git clone https://github.com/mongodb/node-mongodb-native.git |\n| ------------------------------------------------------------ |\n| cd node-mongodb-native                                       |\n| npm install                                                  |\n| git checkout -b myNewFeature                                 | ` To run the test suite, you must have a server topology running and provide the URI to the command. For example, if you have a single server running at `\"mongodb://localhost:27017\"`, you can run the following: ```bash MONGODB_URI=\"mongodb://localhost:27017\" npm test \n``` Note that, depending on the type of topology that you are running (standalone, replicaset, etc.), different tests will be run. ## Note There are many tools that can help you with setting up different topologies for local testing. Some examples are [mtools](https://pypi.org/project/mtools/) and [mongo-orchestration](https://pypi.org/project/mongo-orchestration/). ← [FAQ](https://mongodb.com/docs/drivers/node/current/faq/ \"Previous Section\")[Compatibility](https://mongodb.com/docs/drivers/node/current/compatibility/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # MongoDB Node Driver ## Introduction Welcome to the documentation site for the official MongoDB Node.js driver. You can add the driver to your application to work with MongoDB in JavaScript. Download it using [npm](https://www.npmjs.com/)or set up a runnable project by following our Quick Start guide. ## Quick Start Learn how to establish a connection to MongoDB Atlas and begin working with data in the step-by-step [Quick Start.](https://mongodb.com/docs/drivers/node/current/quick-start/) ## Quick Reference See driver syntax examples for common MongoDB commands in the[Quick Reference](https://mongodb.com/docs/drivers/node/current/quick-reference/#std-label-node-quick-reference) section. ## Usage Examples For fully runnable code snippets and explanations for common methods, see the [Usage Examples](https://mongodb.com/docs/drivers/node/current/usage-examples/) section. ## Fundamentals Learn how to perform the following tasks using the Node.js driver in the Fundamentals section: * [Connect to MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/)\n* [Use the Stable API](https://mongodb.com/docs/drivers/node/current/fundamentals/stable-api/)\n* [Authenticate with MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/)\n* [Read from and Write to MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/)\n* [Access Return Values](https://mongodb.com/docs/drivers/node/current/fundamentals/promises/)\n* [Transform your Data](https://mongodb.com/docs/drivers/node/current/fundamentals/aggregation/)\n* [Create and Manage Transactions](https://mongodb.com/docs/drivers/node/current/fundamentals/transactions/)\n* [Create Indexes to Speed Up Queries](https://mongodb.com/docs/drivers/node/current/fundamentals/indexes/)\n* [Sort Using Collations](https://mongodb.com/docs/drivers/node/current/fundamentals/collations/)\n* [Log Events in the Driver](https://mongodb.com/docs/drivers/node/current/fundamentals/logging/)\n* [Monitor Driver Events](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/)\n* [Store and Retrieve Large Files in MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/gridfs/)\n* [Encrypt Fields from the Client](https://mongodb.com/docs/drivers/node/current/fundamentals/encrypt-fields/)\n* [Create and Query Time Series Collection](https://mongodb.com/docs/drivers/node/current/fundamentals/time-series/)\n* [Specify Type Parameters with TypeScript](https://mongodb.com/docs/drivers/node/current/fundamentals/typescript/)\n* [Specify UTF-8 Validation Settings](https://mongodb.com/docs/drivers/node/current/fundamentals/utf8-validation/) ## API For detailed information about classes and methods in the MongoDB Node.js driver, see the [MongoDB Node.js driver API documentation.](https://mongodb.github.io/node-mongodb-native/5.1) ## FAQ For answers to commonly asked questions about the MongoDB Node.js Driver, see the [Frequently Asked Questions (FAQ)](https://mongodb.com/docs/drivers/node/current/faq/)section. ## Issues & Help Learn how to report bugs, contribute to the driver, and to find help in the[Issues & Help](https://mongodb.com/docs/drivers/node/current/issues-and-help/) section. ## Compatibility For the compatibility tables that show the recommended Node.js driver version for each MongoDB Server version, see the[Compatibility](https://mongodb.com/docs/drivers/node/current/compatibility/) section. ## What's New For a list of new features and changes in each version, see the[What's New](https://mongodb.com/docs/drivers/node/current/whats-new/) section. ## Learn Visit the Developer Hub and MongoDB University to learn more about the Node.js driver. ### Developer Hub The Developer Hub provides tutorials and social engagement for developers. To learn how to use MongoDB features with the Node.js driver, see the[How To's and Articles page.](https://www.mongodb.com/developer/search/?s=Node.js)\n\n ### MongoDB University MongoDB University provides free courses to teach everyone how to use MongoDB. #### Take the free online course taught by MongoDB instructors | ![Banner for the MongoDB University Node.js Course](https://mongodb.com/docs/drivers/node/current/includes/figures/M220JS_hero.jpg) | [Using MongoDB with Node.js](https://learn.mongodb.com/learning-paths/using-mongodb-with-nodejs-y13d)Learn the essentials of Node.js application development with MongoDB. |\n| ---------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | [Quick Start](https://mongodb.com/docs/drivers/node/current/quick-start/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/faq/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # FAQ On this page * [How to fix a \"MongoServerSelectionError: connect ECONNREFUSED ::1:27017\" error?](#how-to-fix-a--mongoserverselectionerror--connect-econnrefused---1-27017--error-)\n* [What Is the Difference Between \"connectTimeoutMS\", \"socketTimeoutMS\" and \"maxTimeMS\"?](#what-is-the-difference-between--connecttimeoutms----sockettimeoutms--and--maxtimems--)\n* [How Can I Prevent the Driver From Hanging During Connection or From Spending Too Long Trying to Reach Unreachable Replica Sets?](#how-can-i-prevent-the-driver-from-hanging-during-connection-or-from-spending-too-long-trying-to-reach-unreachable-replica-sets-)\n* [Should I Use \"socketTimeoutMS\" as a Way of Preventing Long-Running Operations From Slowing Down the Server?](#should-i-use--sockettimeoutms--as-a-way-of-preventing-long-running-operations-from-slowing-down-the-server-)\n* [How Can I Prevent Sockets From Timing out Before They Become Active?](#how-can-i-prevent-sockets-from-timing-out-before-they-become-active-)\n* [What Does a Value of \"0\" mean for \"connectTimeoutMS\" and \"socketTimeoutMS\"?](#what-does-a-value-of--0--mean-for--connecttimeoutms--and--sockettimeoutms--)\n* [How Can I Prevent Long-Running Operations From Slowing Down the Server?](#how-can-i-prevent-long-running-operations-from-slowing-down-the-server-)\n* [What Does the \"keepAlive\" Setting Do?](#what-does-the--keepalive--setting-do-)\n* [What Can I Do If I'm Experiencing Unexpected Network Behavior?](#what-can-i-do-if-i-m-experiencing-unexpected-network-behavior-)\n* [What Can I Do If I'm Getting \"ECONNRESET\" When Calling \"client.connect()\"?](#what-can-i-do-if-i-m-getting--econnreset--when-calling--client.connect----)\n* [How Can I Prevent a Slow Operation From Delaying Other Operations?](#how-can-i-prevent-a-slow-operation-from-delaying-other-operations-)\n* [How Can I Ensure My Connection String Is Valid for a Replica Set?](#how-can-i-ensure-my-connection-string-is-valid-for-a-replica-set-) Frequently Asked Questions ## How to fix a \"MongoServerSelectionError: connect ECONNREFUSED ::1:27017\" error? Beginning with version 17, Node.js defaults to using `IPV6`. You have a few options to resolve this error:\n\n ## What Is the Difference Between \"connectTimeoutMS\", \"socketTimeoutMS\" and \"maxTimeMS\"?\n\n To specify the optional settings for your `MongoClient`, declare one or more available settings in the `options` object of the constructor as follows: ```javascript const client = new MongoClient(uri, {   connectTimeoutMS: <integer value>,   socketTimeoutMS: <integer value> }); \n``` To see all the available settings, see the[MongoClientOptions](https://mongodb.github.io/node-mongodb-native/5.1/interfaces/MongoClientOptions.html)API Documentation. To specify `maxTimeMS`, chain the `maxTimeMS()` method with a timeout specification to an operation that returns a `Cursor`: ```javascript const cursor = myColl.find({}).maxTimeMS(50); \n``` ## How Can I Prevent the Driver From Hanging During Connection or From Spending Too Long Trying to Reach Unreachable Replica Sets? To prevent the driver from hanging during connection or to prevent the driver from spending too long trying to reach unreachable replica sets, you can set the `connectTimeoutMS` option of your[connection options](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/#std-label-node-connection-options). Generally, you should ensure that the`connectTimeoutMS` setting is not lower than the longest network latency you have to a member of the set. If one of the secondary members is on the other side of the planet and has a latency of 10000 milliseconds, setting the `connectTimeoutMS` to anything lower will prevent the driver from ever connecting to that member. ## Should I Use \"socketTimeoutMS\" as a Way of Preventing Long-Running Operations From Slowing Down the Server? No, you should **not** use `socketTimeoutMS` to end operations that may run for too long and slow down the application. Attempting to do so may not achieve the intended result. Closing the socket causes a reconnect of the driver's connection pool, introducing latency to any other queued up operations. Chronically slow operations will, therefore, cause a large number of reconnect requests, negatively impacting throughput and performance. Also, closing the socket does not terminate the operation; it will continue to run on the MongoDB server, which could cause data inconsistencies if the application retries the operation on failure. However, there are important use cases for `socketTimeoutMS` \\- consider the following cases: * A MongoDB process erroring out\n* A misconfigured firewall causing a socket connection without sending a `FIN` packet In those cases, there is no way to detect that the connection has died. Setting the `socketTimeoutMS` is essential to ensure that the sockets are closed correctly. A good rule of thumb is to set `socketTimeoutMS`to two to three times the length of the slowest operation that runs through the driver. ## How Can I Prevent Sockets From Timing out Before They Become Active? Having a large connection pool does not always reduce reconnection requests. Consider the following example: An application has a connection pool size of 5 sockets and has the`socketTimeoutMS` option set to 5000 milliseconds. Operations occur, on average, every 3000 milliseconds, and reconnection requests are frequent. Each socket times out after 5000 milliseconds, which means that all sockets must do something during those 5000 milliseconds to avoid closing. One message every 3000 milliseconds is not enough to keep the sockets active, so several of the sockets will time out after 5000 milliseconds. Reduce the `poolSize` in the connection settings to fix the problem. To specify the optional `poolSize` setting for your `MongoClient`, declare it in the `options` object of the constructor as follows: ```javascript const client = new MongoClient(uri, {   poolSize: <integer value>, }); \n``` ## What Does a Value of \"0\" mean for \"connectTimeoutMS\" and \"socketTimeoutMS\"? If you set the value of `connectTimeoutMS` or `socketTimeoutMS` to`0`, your application will use the operating system's default socket timeout value. ## How Can I Prevent Long-Running Operations From Slowing Down the Server? You can prevent long-running operations from slowing down the server by specifying a timeout value. You can chain the `maxTimeMS()` method to an operation that returns a `Cursor` to set a timeout on a specific action. The following example shows how you can chain the `maxTimeMS()` method to an operation that returns a `Cursor`: ```javascript // Execute a find command await collection   .find({ $where: \"sleep(100) || true\" })   .maxTimeMS(50); \n``` ## What Does the \"keepAlive\" Setting Do?\n\n ## Warning ### If a firewall ignores or drops the keepAlive packets this may not work ## What Can I Do If I'm Experiencing Unexpected Network Behavior? Internal firewalls that exist between application servers and MongoDB are often misconfigured and are overly aggressive in their removal of socket connections. If you experience unexpected network behavior, here are some things to check: 1. The firewall should send a `FIN packet` when closing a socket,allowing the driver to detect that the socket is closed.\n2. The firewall should allow `keepAlive` probes. ## What Can I Do If I'm Getting \"ECONNRESET\" When Calling \"client.connect()\"? In most operating systems, each connection is associated with a [file descriptor](https://www.computerhope.com/jargon/f/file-descriptor.htm). There is typically a limit set by the operating system on the number of file descriptors used by a single process. An `ECONNRESET` error can occur if the connection pool size surpasses the limit of `file descriptors`. Consider the following operation: ```javascript 1 const uri = \"mongodb://localhost:27017/test?maxPoolSize=5000\"; 2 // create a new MongoClient 3 const client = new MongoClient(uri); 4 5 await client.connect(err => { 6   // connection 7 }); \n``` If this operation causes an `ECONNRESET` error, you may have run into the `file descriptor` limit for your Node.js process. In that case you must increase the number of `file descriptors` for the Node.js process. On MacOS and Linux you do this with the [ulimit](https://ss64.com/bash/ulimit.html) shell command. ```shell ulimit -n 6000 \n``` This sets the maximum number of `file descriptors` for the process to 6000, allowing Node.js to connect with a pool size of 5000 sockets. ## How Can I Prevent a Slow Operation From Delaying Other Operations? A slow operation may delay your other operations that occur after it, if the `poolSize` has not been set in the[connection options](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/#std-label-node-connection-options). MongoDB is synchronous and uses a single execution thread per socket, meaning that MongoDB will execute one single operation per socket at any point in time. Any other operation sent to that socket will have to wait until the current operation is finished. If you have a slow-running operation that holds up other operations, the best solution is to create a separate connection pool for the slow operation, isolating it from other, faster operations. ## Note If the number of operations is greater than the set `poolSize` and a slow operation occurs, subsequent operations will be delayed. To create a separate connection pool, instantiate another `MongoClient`call the `connect()` method on it. See the following example for the syntax you can use to create two clients, each with its own connection pool: ```javascript const clientA = new MongoClient(uri, options); clientA.connect(); // any method calls on clientA use clientA's connection pool const clientB = new MongoClient(uri, options); clientB.connect(); // any method calls on clientB use clientB's connection pool \n``` ## How Can I Ensure My Connection String Is Valid for a Replica Set? The connection string passed to the driver must use exact hostnames for the servers as set in the [Replica Set Config](https://www.mongodb.com/docs/manual/reference/replica-configuration/). Given the following configuration settings for your Replica Set, in order for the Replica Set discovery and [failover](https://www.mongodb.com/docs/manual/reference/glossary/#term-failover) to work the driver should be able to reach `server1`, `server2`, and `server3`. ``` {   \"_id\": \"testSet\",   \"version\": 1,   \"protocolVersion\": 1,   \"members\": [     {       \"_id\": 1,       \"host\": \"server1:31000\"     },     {       \"_id\": 2,       \"host\": \"server2:31001\"     },     {       \"_id\": 3,       \"host\": \"server3:31002\"     }   ] } \n```\n\n ← [Encrypt Fields](https://mongodb.com/docs/drivers/node/current/fundamentals/encrypt-fields/ \"Previous Section\")[Issues & Help](https://mongodb.com/docs/drivers/node/current/issues-and-help/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/compatibility/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Compatibility On this page * [MongoDB Compatibility](#mongodb-compatibility)\n* [Compatibility Table Legend](#compatibility-table-legend)\n* [Language Compatibility](#language-compatibility) ## MongoDB Compatibility The following compatibility table specifies the recommended versions of the MongoDB Node.js driver for use with MongoDB. The first column lists the driver version. ### Compatibility Table Legend | Icon    | Explanation                                                                                            |\n| ------- | ------------------------------------------------------------------------------------------------------ |\n| ✓       | All features are supported.                                                                            |\n| ⊛       | The Driver version will work with the MongoDB version, but not all new MongoDB features are supported. |\n| No mark | The Driver version is not tested with the MongoDB version.                                             |\n\n | \\[[1](#ref-unified-topology-id1)\\] | When using Node.js Driver version 3.7, you must set the useUnifiedTopology flag to true for certain features. |\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------------- | ## Language Compatibility The following compatibility table specifies the recommended versions of the MongoDB Node.js driver for use with a specific version of Node.js. The first column lists the driver version.\n\n For more information on how to read the compatibility tables, see our guide on[MongoDB Compatibility Tables.](https://www.mongodb.com/docs/drivers/about-compatibility/#std-label-about-driver-compatibility) ← [Issues & Help](https://mongodb.com/docs/drivers/node/current/issues-and-help/ \"Previous Section\")[What's New](https://mongodb.com/docs/drivers/node/current/whats-new/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/whats-new/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # What's New On this page * [What's New in 5.1](#what-s-new-in-5.1)\n* [What's New in 5.0](#what-s-new-in-5.0)\n* [What's New in 4.14](#what-s-new-in-4.14)\n* [What's New in 4.13](#what-s-new-in-4.13)\n* [What's New in 4.12](#what-s-new-in-4.12)\n* [What's New in 4.11](#what-s-new-in-4.11)\n* [What's New in 4.10](#what-s-new-in-4.10)\n* [What's New in 4.9](#what-s-new-in-4.9)\n* [What's New in 4.8](#what-s-new-in-4.8)\n* [What's New in 4.7](#what-s-new-in-4.7)\n* [What's New in 4.6](#what-s-new-in-4.6)\n* [What's New in 4.5](#what-s-new-in-4.5)\n* [What's New in 4.4](#what-s-new-in-4.4)\n* [What's New in 4.3](#what-s-new-in-4.3)\n* [What's New in 4.2](#what-s-new-in-4.2)\n* [What's New in 4.1](#what-s-new-in-4.1)\n* [What's New in 4.0](#what-s-new-in-4.0)\n* [What's New in 3.7](#what-s-new-in-3.7)\n* [What's New in 3.6](#what-s-new-in-3.6) Learn what's new in: * [Version 5.1](#std-label-version-5.1)\n* [Version 5.0](#std-label-version-5.0)\n* [Version 4.14](#std-label-version-4.14)\n* [Version 4.13](#std-label-version-4.13)\n* [Version 4.12](#std-label-version-4.12)\n* [Version 4.11](#std-label-version-4.11)\n* [Version 4.10](#std-label-version-4.10)\n* [Version 4.9](#std-label-version-4.9)\n* [Version 4.8](#std-label-version-4.8)\n* [Version 4.7](#std-label-version-4.7)\n* [Version 4.6](#std-label-version-4.6)\n* [Version 4.5](#std-label-version-4.5)\n* [Version 4.4](#std-label-version-4.4)\n* [Version 4.3](#std-label-version-4.3)\n* [Version 4.2](#std-label-version-4.2)\n* [Version 4.1](#std-label-version-4.1)\n* [Version 4.0](#std-label-version-4.0)\n* [Version 3.7](#std-label-version-3.7)\n* [Version 3.6](#std-label-version-3.6) ## What's New in 5.1 New features of the 5.1 Node.js driver release include: * The driver now supports automatic serialization of JavaScript `bigint` to`BSON.Long`. It also supports the deserialization of `BSON.Long` values returned from the server to `bigint` values when the `useBigInt64` flag is passed as true. To learn more, see the [v5.1.0 Release Highlights.](https://github.com/mongodb/node-mongodb-native/releases/tag/v5.1.0) ## What's New in 5.0 ## Important\n\n * Version 5.0 of the Node.js driver is not compatible with Node.js v12 or earlier. If you want to use this version of the driver, You must use Node.js v14.20.1 or greater.\n* This release removes support for callbacks in favor of a promise-based API. The following list provides some strategies for callback users to adopt this version:  \n   * Migrate to the promise-based API (recommended)  \n   * Use the promise-based API and `util.callbackify`  \n   * Add `mongodb-legacy` to continue using callbacks  \nFor more information about these strategies, see[Changes in the MongoDB Node.js Driver v5.](https://github.com/mongodb/node-mongodb-native/blob/main/etc/notes/CHANGES%5F5.0.0.md)\n* This release removes support for the `Collection.insert()`,`Collection.update()`, and `Collection.remove()` helper methods. The following list provides instructions on how to replace the functionality of the removed methods:  \n   * Migrate from `Collection.insert()` to `insertOne()` or `insertMany()`  \n   * Migrate from `Collection.update()` to `updateOne()` or `updateMany()`  \n   * Migrate from `Collection.remove()` to `deleteOne()` or `deleteMany()` New features of the 5.0 Node.js driver release include: * By default, the driver no longer checks types referenced in dot notation unless the `StrictFilter` type annotation is explicitly used. To learn more about this change, see the [Typescript fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/typescript/#std-label-node-ts-type-safety)  \n## Note  \nThis change is for Typescript only, and does not affect queries or operations at runtime.\n* Optional installation of `@aws-sdk/credential-providers` as a dependency.  \n   * The driver no longer includes AWS SDK modules by default. Use the following `npm` command to install the SDK:  \n   `| npm install --save \"@aws-sdk/credential-providers@^3.201.0\" |  \n   | ----------------------------------------------------------- |  \n   `  \n   If you install the SDK, `npm` notifies you if the version of the SDK you installed is incompatible with the driver. Once you install the dependency successfully, the driver uses the AWS SDK itself to manage credentials from the environment. ## What's New in 4.14 ## Important ### Upgrade from v4.13 to v4.14 This version includes a fix to a memory leak introduced in v4.13\\. We recommend upgrading to v4.14. New features of the 4.14 Node.js driver release include: * Fixed a memory leak introduced in v4.13.\n* Deprecated methods and options that reference the legacy Logger. ## What's New in 4.13 New features of the 4.13 Node.js driver release include: * Automatic cancellation of in-flight operations in the connection pool when the driver encounters network timeout errors.\n* Disabled causal consistency in implicit sessions to prevent conflicting with the `linearizable` and `available` read concern settings.\n* Fixed a potential memory leak by ensuring that the driver destroys`MessageStream` instances whenever their connections are destroyed. ## What's New in 4.12 ## Important ### Upgrade Driver to Version 4.12.1 The 4.12.1 Node.js driver includes a fix to a regression in monitoring logic that could cause processes to crash. New features of the 4.12 Node.js driver release include:\n\n To learn more, see the [v4.12.0 Release Highlights.](https://github.com/mongodb/node-mongodb-native/releases/tag/v4.12.0) ## What's New in 4.11 When connecting to MongoDB Server version 6.0 or later, the driver prioritizes`electionId` settings before `setVersion` settings during Server Discovery and Monitoring events. In previous versions, the prioritization order was reversed. This release also includes added support for **mutually recursive** collection schema types. The driver also provides type safety for dot-notation queries up to a depth of eight in this release. At a depth greater than or equal to eight, Typescript successfully compiles your code but does not provide type safety. This depth limit on recursive types is a current limitation of TypeScript. ### Mutually Recursive Schema Type Checking Example Suppose we have a collection of type `Collection<Author>` that contains the following mutually recursive types: ```js interface Author {     name: string;     bestBook: Book; } interface Book {     title: string;     author: Author;  } \n``` TypeScript enforces type checking up to a depth of eight. The following code causes a TypeScript compilation error because the `name` property value must be a `string` type: ```js myColl.findOne({ 'bestBook.author.bestBook.title': 25 }); \n``` At a depth greater than or equal to eight, TypeScript compiles your code but no longer type checks it. For example, the following code assigns a `number` to a`string` property but does not cause a compilation error because the referenced property is at a depth of 10: ```js myColl.findOne({     'bestBook.author.bestBook.author.bestBook.author.bestBook.author.bestBook.author.name': 25 }); \n``` To learn more, see the [v4.11.0 Release Highlights.](https://github.com/mongodb/node-mongodb-native/releases/tag/v4.11.0) ## What's New in 4.10 New features of the 4.10 Node.js driver release include: * Callback Deprecation  \n   * Callbacks are now deprecated in favor of Promises. Callbacks will be removed in the next major release. The Node driver team recommends migrating to promises where possible:  \n         * Use `async/await` syntax.  \n         * Use the Node.js [callbackify utility:](https://nodejs.org/api/util.html#utilcallbackifyoriginal)  \n         ```js  \n         require('util').callbackify(() => myColl.findOne())(callback)  \n         ```  \n         * Use [then](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/then) syntax:  \n         ```js  \n         myColl.findOne().then(res => callback(null, res), err => callback(err))  \n         ```  \n   * If you are unable to migrate to Promises in a large codebase, you can use the [MongoDB Node.js driver with optional callback support](https://www.npmjs.com/package/mongodb-legacy) package. To learn more, see [v4.10.0 Release Highlights.](https://github.com/mongodb/node-mongodb-native/releases/tag/v4.10.0) ## What's New in 4.9 New features of the 4.9 Node.js driver release include: * Fixed an inconsistency with `writeConcern` options in the type definitions.\n* Included the latest BSON release, which adds automatic UUID support. See the BSON release notes [here.](https://github.com/mongodb/js-bson/releases/tag/v4.7.0)\n\n ## What's New in 4.8 New features of the 4.8 Node.js driver release include: * Added auto-completion and type safety for nested keys in an update filter\n* `client.startSession()` can now be called before connecting to MongoDB\n* `estimatedDocumentCount()` method can now accept a comment To learn more, see [v4.8.0 Release Highlights.](https://github.com/mongodb/node-mongodb-native/releases/tag/v4.8.0) ## What's New in 4.7 New features of the 4.7 Node.js driver release include: * The `MongoClient.connect()` method is now optional when connecting to your MongoDB instance\n* Ability to compress messages with the `Zstandard` [compression algorithm](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/network-compression/#std-label-node-network-compression)\n* Added support for the `maxConnecting` connection option\n* Ability for change stream documents to show your documents before and after an update\n* Added support for new change stream fields related to Cluster to Cluster Replication\n* The `estimatedDocumentCount()` method now uses the `$count` database command\n* Improved connecting to MongoDB in the AWS Lambda Init phase ## Important ### Deprecation Notice The `ResumeOptions` interface is deprecated. Use the`ChangeStreamCursorOptions` interface instead. ## What's New in 4.6 New features of the 4.6 Node.js driver release include: * Improved the `ChangeStreamDocument` in TypeScript.\n* Even distribution of server selection based on load across servers. To learn more, see [v4.6.0 Release Highlights.](https://github.com/mongodb/node-mongodb-native/releases/tag/v4.6.0) ## What's New in 4.5 See [v4.5.0 Release Highlights](https://github.com/mongodb/node-mongodb-native/releases/tag/v4.5.0)on GitHub. ## What's New in 4.4 New features of the 4.4 Node.js driver release include: * KMIP provider support when using CSFLE.\n* TLS support when using CSFLE.\n* Hostname canonicalization now accepts \"none\", \"forward\", and \"forwardAndReverse\" as `authMechanismProperties` when using GSSAPI.\n* In the 4.0.0 release of the driver, the deprecated `collection.count()` method was inadvertently changed to behave like `collection.countDocuments()`. In this release, the `collection.count()` method is updated to match legacy behavior:  \n   * If a query is provided, `collection.count()` behaves the same as `collection.countDocuments()` and performs a collection scan.  \n   * If no query is provided, `collection.count()` behaves the same as `collection.estimatedDocumentCount()` and relies on collection metadata.  \n## Important  \n### Deprecation Notice  \nThe `cursor.count()` method is deprecated and will be removed in the next major version, along with `collection.count()`. Use the `collection.estimatedDocumentCount()` or `collection.countDocuments()`methods instead. ## What's New in 4.3 New features of the 4.3 Node.js driver release include: * SOCKS5 support\n* Option to [disable UTF-8 validation](https://mongodb.com/docs/drivers/node/current/fundamentals/utf8-validation/#std-label-nodejs-utf-8-validation)\n* Type inference for nested documents ## What's New in 4.2 New features of the 4.2 Node.js driver release include: * `srvMaxHosts` and `srvServiceName` DNS seedlist [connection options](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/#std-label-node-connection-options) ## What's New in 4.1 New features of the 4.1 Node.js driver release include: * Added load balanced connection support for all cluster types including the beta [Serverless platform.](https://www.mongodb.com/docs/atlas/create-database-deployment/#std-label-create-new-database-deployment)\n* Added support for the `advanceClusterTime()` method to determine if the `ClientSession` should update its cluster time.\n\n ## Important In this release of the driver, the deprecated `collection.count()` method was inadvertently changed to behave like `collection.countDocuments()`. This behavior is corrected in [version 4.4.](#std-label-version-4.4) New features of the 4.0 Node.js driver release include: ### TypeScript * We've migrated the driver to TypeScript. You can now harness the type hinting and intellisense features in editors that support it to develop your MongoDB applications. Enjoy the benefits of this work in pure JavaScript projects as well.\n* The underlying BSON library used by this version is now migrated to TypeScript.\n* Inline documentation is now consistently formatted to improve display in editors.\n* If you are a user of the community types `@types/mongodb`, there will**likely be issues** adopting the types from our codebase. We could not achieve a one to one match in types due to the details of writing the codebase in TypeScript. We'd love to hear your TypeScript related feature requests. Please submit ideas on our [JIRA project here.](https://jira.mongodb.org/projects/NODE) ### Key Changes #### Node.js Version The minimum supported version of Node.js is now v12.9 or greater for version 4 of the driver. Support for our 3.x branches will continue until summer 2022 to allow time to upgrade. ## Note 3.x supports back to Node.js v4. #### Cursor Improvements Our Cursor implementation is now updated to make it clear what is possible before and after execution of an operation. ## Example ```js const fc = myColl.find({a: 2.3}).skip(1) for await (const doc of fc) {   console.log(doc)   fc.limit(1) // incorrect usage, cursor already executing } \n``` There was inconsistency surrounding how the cursor would error if a setting was applied after cursor execution began. Now, the cursor will throw an error when attempting to apply operations in an invalid state, similar to the following: `MongoError: Cursor is already initialized` * Affected classes:  \n   * `AbstractCursor`  \n   * `FindCursor`  \n   * `AggregationCursor`  \n   * `ChangeStreamCursor` (This is the underlying cursor for `ChangeStream`)  \n   * `ListCollectionsCursor` ##### Cursor Stream API Our Cursor types no longer extend `Readable` directly. They must be transformed into a stream by calling `cursor.stream()`. ## Example ```js const cursor = myColl.find({}); const stream = cursor.stream(); stream.on(\"data\", data => console.log); stream.on(\"error\", () => client.close()); \n``` Use `hasNext()` and `next()` for manual iteration. Use `for await of` syntax or any `Promise` helpers for asynchronous iteration. #### `MongoClientOptions` Interface With type hinting, you should find that options passed to a `MongoClient`are enumerated and discoverable. We've made a large effort to process all options in the driver to give early warnings about incompatible settings to get your app up and running in a correct state quickly. * `checkServerIdentity` is no longer checked before being passed to the underlying Node API. Previously, accepted values were `false`, or a function. Now, the argument must be a function. Specifying a boolean will result in an error being thrown.\n* It is no longer required to specify `useUnifiedTopology` or `useNewUrlParser`. #### `createCollection()` This method no longer supports a `strict` option, which returned an error if the collection did not exist. To assert the existence of a collection, use the `listCollections()` method instead. ## Example ```js const collections = (await db.listCollections({}, { nameOnly: true })   .toArray()).map(     ({name}) => name   ); if (!collections.includes(myNewCollectionName)) {   throw new Error(`${myNewCollectionName} doesn't exist`); } \n``` #### `BulkWriteError` → `MongoBulkWriteError` `BulkWriteError` is now renamed to `MongoBulkWriteError`. When running bulk operations that make writes you can encounter errors depending on your settings. Import the new class name `MongoBulkWriteError`when testing for errors in bulk operations. #### `DB`\n\n #### `Collection.group()` The `Collection.group()` helper, deprecated since MongoDB 3.4, is now removed. Use the aggregation pipeline [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/#pipe.%5FS%5Fgroup)operator instead. #### Authentication * `gssapiServiceName` is now removed. Use [authMechanismProperties.SERVICE\\_NAME](https://mongodb.github.io/node-mongodb-native/5.1/interfaces/MongoClientOptions.html#authMechanismProperties) in the URI or as an option on `MongoClientOptions`.  \n## Example  \n```js  \n?authMechanismProperties.SERVICE_NAME  \n// or  \nnew MongoClient(url, { SERVICE_NAME: \"alternateServiceName\" })  \n```\n* Specifying username and password as options is only supported in the URI or as an option on `MongoClientOptions`.  \n## Example  \n```js  \nnew MongoClient(\"mongodb://username:password@<host><port>\")  \n// or  \nnew MongoClient(url, { auth: { username: \"<>\", password: \"<>\" } })  \n``` #### `GridStore` Removal The GridStore API (already deprecated in 3.x) is now replaced with `GridFSBucket`. For more information on `GridFS`, see the [mongodb manual.](https://www.mongodb.com/docs/manual/core/gridfs/) Below are some snippets that represent equivalent operations. ##### Construction ## Example ```javascript // old way const gs = new GridStore(db, filename, mode[, options]) // new way const bucket = new GridFSBucket(client.db('test')[,options]) \n``` ##### File Seeking GridFSBucket uses the Node.js Stream API. You can replicate file seeking by using the `start` and `end` options, creating a download stream from your `GridFSBucket`. ## Example ```js bucket.openDownloadStreamByName(filename, { start: 0, end: 100 }) \n``` ##### File Upload & Download ## Example ```javascript await client.connect(); const filename = 'test.txt'; // whatever local file name you want const db = client.db(); const bucket = new GridFSBucket(db); fs.createReadStream(filename)   .pipe(bucket.openUploadStream(filename))   .on('error', console.error)   .on('finish', () => {     console.log('done writing to db!');     bucket       .find()       .toArray()       .then(files => {         console.log(files);         bucket           .openDownloadStreamByName(filename)           .pipe(fs.createWriteStream('downloaded_' + filename))           .on('error', console.error)           .on('finish', () => {             console.log('done downloading!');             client.close();           });       });   }); \n``` ## Note `GridFSBucket` does not need to be closed like `GridStore`. ##### File Deletion ## Example ```js // old way GridStore.unlink(db, name, callback); // new way bucket.delete(file_id); \n``` ##### Finding File Metadata File metadata that used to be accessible on the `GridStore` instance can be found by querying the bucket. ## Example ```js const fileMetaDataList: GridFSFile[] = bucket.find({}).toArray(); \n``` #### Unified Topology\n\n #### Explain Support is now added for fine-grained verbosity modes. You can learn more about each mode [here.](https://www.mongodb.com/docs/manual/reference/method/cursor.explain/#behavior/) #### Command Monitoring The `instrument()` method is now removed. Use command monitoring instead. See our guide on [command monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/command-monitoring/)for more information. ### Detailed List For a detailed list of breaking changes, removals, and associated JIRA tickets, see the detailed [list here.](https://github.com/mongodb/node-mongodb-native/blob/4.0/docs/CHANGES%5F4.0.0.md) ## What's New in 3.7 New features of the 3.7 Node.js driver release include: * Added support for load balancer mode while enabling the `useUnifiedTopology` option\n* Added support for [Stable API](https://mongodb.com/docs/drivers/node/current/fundamentals/stable-api/#std-label-nodejs-stable-api) while enabling the `useUnifiedTopology` option ## What's New in 3.6 New features of the 3.6 Node.js driver release include: * Added support for the [MONGODB-AWS](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/mechanisms/#std-label-mongodb-aws) authentication mechanism using Amazon Web Services (AWS) Identity and Access Management (IAM) credentials\n* The [find()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#find) method supports `allowDiskUse()` for sorts that require too much memory to execute in RAM\n* The [update()](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/change-a-document/#std-label-updateDocuments) and [replaceOne()](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/change-a-document/#std-label-replacementDocument) methods support index hints\n* A reduction in recovery time for topology changes and failover events\n* Improvements in validation testing for the default [writeConcern](https://www.mongodb.com/docs/manual/reference/write-concern/)\n* Authentication requires fewer round trips to the server, resulting in faster connection setup\n* Shorter Salted Challenge Response Authentication Mechanism ([SCRAM](https://www.mongodb.com/docs/manual/core/security-scram/)) conversations\n* Ability to create collections and indexes for multiple document transactions\n* Running validation for a collection in the background ← [Compatibility](https://mongodb.com/docs/drivers/node/current/compatibility/ \"Previous Section\")",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/find-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Find Operations * [Find a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/findOne/)\n* [Find Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/find/) ← [Usage Examples](https://mongodb.com/docs/drivers/node/current/usage-examples/ \"Previous Section\")[Find a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/findOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/deleteMany/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Delete Multiple Documents You can delete multiple documents in a collection at once using the[collection.deleteMany()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#deleteMany) method. Pass a query document to the `deleteMany()` method to specify a subset of documents in the collection to delete. If you do not provide a query document (or if you provide an empty document), MongoDB matches all documents in the collection and deletes them. While you can use `deleteMany()`to delete all documents in a collection, consider using[drop()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#drop) instead for better performance and clearer code. You can specify additional options in the `options` object passed in the second parameter of the `deleteMany()` method. For more detailed information, see the[deleteMany() API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#deleteMany) ## Example The following snippet deletes multiple documents from the `movies`collection. It uses a **query document** that configures the query to match and delete movies with the title \"Santa Claus\". ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) The first time you run the preceding example, you should see the following output: `| Deleted 19 documents |\n| -------------------- | ` On subsequent runs of the example, as you already deleted all relevant documents, you should see the following output: ``` Deleted 0 documents \n``` ← [Delete a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/deleteOne/ \"Previous Section\")[Count Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/count/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/update-and-replace-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Update & Replace Operations * [Update a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/updateOne/)\n* [Update Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/updateMany/)\n* [Replace a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/replaceOne/) ← [Insert Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/insertMany/ \"Previous Section\")[Update a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/updateOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/insert-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Insert Operations * [Insert a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/insertOne/)\n* [Insert Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/insertMany/) ← [Find Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/find/ \"Previous Section\")[Insert a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/insertOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/quick-reference/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Quick Reference This page shows the driver syntax for several MongoDB commands and links to their related reference and API documentation.\n\n ← [Next Steps](https://mongodb.com/docs/drivers/node/current/quick-start/next-steps/ \"Previous Section\")[Usage Examples](https://mongodb.com/docs/drivers/node/current/usage-examples/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/findOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Find a Document You can query for a single document in a collection with the`collection.findOne()` method. The `findOne()` method uses a query document that you provide to match only the subset of the documents in the collection that match the query. If you don't provide a query document or if you provide an empty document, MongoDB matches all documents in the collection. The `findOne()` operation only returns the first matched document. For more information on querying MongoDB, see our[documentation on query documents.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/query-document/) You can also define additional query options such as[sort](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/)and [projection](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/)to configure the returned document. You can specify the additional options in the `options` object passed as the second parameter of the`findOne` method. For detailed reference documentation, see[collection.findOne().](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#findOne) ## Example The following snippet finds a single document from the `movies`collection. It uses the following parameters: * A **query document** that configures the query to return only movies with the title of exactly the text `'The Room'`.\n* A **sort** that organizes matched documents in descending order by rating, so if our query matches multiple documents the returned document will be the document with the highest rating.\n* A **projection** that explicitly excludes the `_id` field from returned documents and explicitly includes only the `title` and`imdb` object (and its embedded fields). ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) If you run the preceding example, you should see the following output: `| { title: 'The Room', imdb: { rating: 3.5, votes: 25673, id: 368226 } } |\n| ---------------------------------------------------------------------- | ` ← [Find Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/find-operations/ \"Previous Section\")[Find Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/find/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/count/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Count Documents The Node.js driver provides two methods for counting documents in a collection: * [collection.countDocuments()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#countDocuments) returns the number of documents in the collection that match the specified query. If you specify an empty query document, `countDocuments()` returns the total number of documents in the collection.\n* [collection.estimatedDocumentCount()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#estimatedDocumentCount) returns an**estimation** of the number of documents in the collection based on collection metadata. `estimatedDocumentCount()` is faster than `countDocuments()` because the estimation uses the collection's metadata rather than scanning the collection. In contrast, `countDocuments()` takes longer to return, but provides an **accurate** count of the number of documents and supports specifying a filter. Choose the appropriate method for your workload. To specify which documents you wish to count, `countDocuments()`accepts a [query](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/query-document/) parameter.`countDocuments()` counts the documents that match the specified query. `countDocuments()` and `estimatedDocumentCount()` support optional settings that affect the method's execution. Refer to the reference documentation for each method for more information. ## Important If you require an exact document count in your collection, use a query to take advantage of the built-in index on the `_id` field. `| myColl.countDocuments({ \"_id\": { \"$exists\": true } }); |\n| ------------------------------------------------------ | ` ## Example The following example estimates the number of documents in the`movies` collection in the `sample_mflix` database, and then returns an accurate count of the number of documents in the `movies`collection with `Canada` in the `countries` field. ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) ## Note ### Identical Code Snippets The JavaScript and TypeScript code snippets above are identical. There are no TypeScript specific features of the driver relevant to this use case. If you run the preceding sample code, you should see the following output: ``` Estimated number of documents in the movies collection: 23541 Number of movies from Canada: 1349 \n``` ← [Delete Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/deleteMany/ \"Previous Section\")[Retrieve Distinct Values of a Field](https://mongodb.com/docs/drivers/node/current/usage-examples/distinct/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/insertMany/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Insert Multiple Documents You can insert multiple documents using the[collection.insertMany()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#insertMany) method. The `insertMany()` takes an array of documents to insert into the specified collection. You can specify additional options in the `options` object passed as the second parameter of the `insertMany()` method. Specify `ordered:true`to prevent inserting the remaining documents if the insertion failed for a previous document in the array. Specifying incorrect parameters for your `insertMany()` operation can cause problems. Attempting to insert a field to a value that would violate unique index rules will throw a `duplicate key error`. ## Example ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) If you run the preceding example, you should see the following output: `| 3 documents were inserted |\n| ------------------------- | ` ← [Insert a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/insertOne/ \"Previous Section\")[Update & Replace Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/update-and-replace-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/updateOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Update a Document You can update a single document using the[collection.updateOne()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#updateOne)method. The `updateOne()` method accepts a filter document and an update document. If the query matches documents in the collection, the method applies the updates from the update document to fields and values of them. The update document contains [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/#update-operators) that instruct the method on the changes to make to the matches. You can specify additional query options using the `options` object passed as the second parameter of the `updateOne()` method. Set the `upsert` option to `true` to create a new document if no documents match the filter. For additional information, see the[updateOne() API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#updateOne) `updateOne()` throws an exception if an error occurs during execution. If you specify a value in your update document for the immutable field`_id`, the method throws an exception. If your update document contains a value that violates unique index rules, the method throws a `duplicate key error` exception. ## Note If your application requires the document after updating, consider using the[collection.findOneAndUpdate()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#findOneAndUpdate). method, which has a similar interface to `updateOne()` but also returns the original or updated document. ## Example The following example uses the `$set` update operator which specifies update values for document fields. For more information on update operators, see the [MongoDB update operator reference documentation.](https://www.mongodb.com/docs/manual/reference/operator/update/#update-operators) ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) If you run the example above, you should see the following output: `| 1 document(s) matched the filter, updated 1 document(s) |\n| ------------------------------------------------------- | ` ← [Update & Replace Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/update-and-replace-operations/ \"Previous Section\")[Update Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/updateMany/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/delete-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Delete Operations * [Delete a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/deleteOne/)\n* [Delete Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/deleteMany/) ← [Replace a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/replaceOne/ \"Previous Section\")[Delete a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/deleteOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/bulkWrite/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Perform Bulk Operations The `bulkWrite()` method performs batch write operations against a_single_ collection. This method reduces the number of network round trips from your application to the server which therefore increases the throughput and performance. Bulk writes return a collection of results for all operations only after _all_ operations passed to the method complete. You can specify one or more of the following write operations in`bulkWrite()`: * `insertOne`\n* `updateOne`\n* `updateMany`\n* `deleteOne`\n* `deleteMany`\n* `replaceOne` The `bulkWrite()` method accepts the following parameters: * `operations`: specifies the bulk write operations to perform. Pass each operation to `bulkWrite()` as an object in an array. For examples that show the syntax for each write operation, see the [bulkWrite API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#bulkWrite)\n* `options`: _optional_ settings that affect the execution of the operation, such as whether the write operations should execute in sequential order and the write concern.  \nBy default, MongoDB executes bulk write operations one-by-one in the specified order (i.e. serially). During an ordered bulk write, if an error occurs during the processing of an operation, MongoDB returns without processing the remaining operations in the list. In contrast, when `ordered` is `false`, MongoDB continues to process remaining write operations in the list. Unordered operations are theoretically faster since MongoDB can execute them in parallel, but should only be used if the writes do not depend on order. If you create an index with a [unique index](https://www.mongodb.com/docs/manual/core/index-unique/)constraint, you might encounter a duplicate key write error during an operation in the following format: `| Error during bulkWrite, BulkWriteError: E11000 duplicate key error collection: ... |\n| ---------------------------------------------------------------------------------- | ` Similarly, if you attempt to perform a bulk write against a collection that uses [schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/), you may encounter warnings or errors related to the formatting of inserted or modified documents. ## Example The following code sample performs a bulk write operation on the`theaters` collection in the `sample_mflix` database. The example call to `bulkWrite()` includes examples of `insertOne`, `updateMany`, and`deleteOne` write operations: ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) When you run the preceding example, you should see the following output: ```javascript BulkWriteResult {   result: {     ok: 1,     writeErrors: [],     writeConcernErrors: [],     insertedIds: [ [Object], [Object] ],     nInserted: 2,     nUpserted: 0,     nMatched: 1,     nModified: 1,     nRemoved: 0,     upserted: [],     lastOp: { ts: [Timestamp], t: 17 }   },   insertedCount: 2,   matchedCount: 1,   modifiedCount: 1,   deletedCount: 0,   upsertedCount: 0,   upsertedIds: {},   insertedIds: { '0': 5ec4..., '1': 5ec4... },   n: 2 } \n``` ← [Watch for Changes](https://mongodb.com/docs/drivers/node/current/usage-examples/changeStream/ \"Previous Section\")[Fundamentals](https://mongodb.com/docs/drivers/node/current/fundamentals/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/replaceOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Replace a Document You can replace a single document using the[collection.replaceOne()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#replaceOne) method.`replaceOne()` accepts a query document and a replacement document. If the query matches a document in the collection, it replaces the first document that matches the query with the provided replacement document. This operation removes all fields and values in the original document and replaces them with the fields and values in the replacement document. The value of the `_id` field remains the same unless you explicitly specify a new value for `_id` in the replacement document. You can specify additional options, such as `upsert`, using the optional `options` parameter. If you set the `upsert` option field to`true` the method inserts a new document if no document matches the query. The `replaceOne()` method throws an exception if an error occurs during execution. For example, if you specify a value that violates a unique index rule, `replaceOne()` throws a `duplicate key error`. ## Note If your application requires the document after updating, use the [collection.findOneAndReplace()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#findOneAndReplace)method which has a similar interface to `replaceOne()`. You can configure `findOneAndReplace()` to return either the original matched document or the replacement document. ## Example ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) If you run the preceding example, you should see the following output: `| Modified 1 document(s) |\n| ---------------------- | ` ← [Update Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/updateMany/ \"Previous Section\")[Delete Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/delete-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/command/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Run a Command You can run all raw database operations using the[db.command()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Db.html#command) method. Call the `command()` method with your command object on an instance of a database for diagnostic and administrative tasks such as fetching server stats or initializing a replica set. ## Note Use the [MongoDB Shell](https://www.mongodb.com/docs/mongodb-shell/) for administrative tasks instead of the Node.js driver whenever possible. You can specify additional options in the `options` object passed in the second parameter of the `command()` method. For more information on the options you can pass, see the[db.command() API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Db.html#command) ## Example ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) ## Note ### Identical Code Snippets The JavaScript and TypeScript code snippets above are identical. There are no TypeScript specific features of the driver relevant to this use case. When you run the preceding command, you should see the following output: `| {                   |\n| ------------------- |\n| db: 'sample_mflix', |\n| collections: 6,     |\n| views: 0,           |\n| objects: 75620,     |\n| ...                 |\n| }                   | ` ← [Retrieve Distinct Values of a Field](https://mongodb.com/docs/drivers/node/current/usage-examples/distinct/ \"Previous Section\")[Watch for Changes](https://mongodb.com/docs/drivers/node/current/usage-examples/changeStream/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/insertOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Insert a Document You can insert a document into a collection using the[collection.insertOne()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#insertOne) method. To insert a document, define an object that contains the fields and values that you want to store. If the specified collection does not exist, the`insertOne()` method creates the collection. You can specify additional query options using the `options` parameter. For more information on the method parameters, see the[insertOne() API documentation](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#insertOne). For more information on this method, see the[insertOne() API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#insertOne) If the operation successfully inserts a document, it appends an`insertedId` field to the object passed in the method call, and sets the value of the field to the `_id` of the inserted document. ## Example ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) If you run the preceding example, you should see the following output: `| A document was inserted with the _id: <your _id value> |\n| ------------------------------------------------------ | ` ← [Insert Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/insert-operations/ \"Previous Section\")[Insert Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/insertMany/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/updateMany/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Update Multiple Documents You can update multiple documents using the[collection.updateMany()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#updateMany) method. The `updateMany()` method accepts a filter document and an update document. If the query matches documents in the collection, the method applies the updates from the update document to fields and values of the matching documents. The update document requires an [update operator](https://www.mongodb.com/docs/manual/reference/operator/update/) to modify a field in a document. You can specify additional options in the `options` object passed in the third parameter of the `updateMany()` method. For more detailed information, see[the updateMany() API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#updateMany) ## Example ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) If you run the preceding example, you should see the following output: `| Updated 477 documents |\n| --------------------- | ` ← [Update a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/updateOne/ \"Previous Section\")[Replace a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/replaceOne/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/deleteOne/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Delete a Document You can delete a single document in a collection with`collection.deleteOne()`. The `deleteOne()` method uses a query document that you provide to match the subset of the documents in the collection that match the query. If you do not provide a query document (or if you provide an empty document), MongoDB matches all documents in the collection and deletes the first match. You can specify additional query options using the`options` object passed as the second parameter of the`deleteOne` method. For more information on this method, see the[deleteOne() API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#deleteOne) ## Note If your application requires the deleted document after deletion, consider using the[collection.findOneAndDelete()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#findOneAndDelete). method, which has a similar interface to `deleteOne()` but also returns the deleted document. ## Example The following snippet deletes a single document from the `movies`collection. It uses a **query document** that configures the query to match movies with a `title` value of \"Annie Hall\". ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) ## Note ### Identical Code Snippets The JavaScript and TypeScript code snippets above are identical. There are no TypeScript specific features of the driver relevant to this use case. If you run the preceding example, you should see the following output: `| Successfully deleted one document. |\n| ---------------------------------- | ` On subsequent runs of the preceding example, as you already deleted the document that matched your query, you should see the following output: ``` No documents matched the query. Deleted 0 documents. \n``` ← [Delete Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/delete-operations/ \"Previous Section\")[Delete Multiple Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/deleteMany/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/distinct/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Retrieve Distinct Values of a Field You can retrieve a list of distinct values for a field across a collection by using the [collection.distinct()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#distinct)method. Call the `distinct()` method on a `Collection` object with a document field name parameter as a `String` to produce a list that contains one of each of the different values found in the specified document field as shown below: `| const distinctValues = myColl.distinct(\"countries\", query); |\n| ----------------------------------------------------------- | ` You can specify a document field within an _embedded document_ using[dot notation](https://www.mongodb.com/docs/manual/core/document/#embedded-documents). If you call`distinct()` on an document field that contains an array, the method treats each element as a separate value. See the following example of a method call to the `wins` field in the `awards` subdocument: ```javascript const distinctValues = myColl.distinct(\"awards.wins\", query); \n``` You can specify additional query options using the `options` object passed as the third parameter to the `distinct()` method. For details on the query parameters, see the[distinct() method in the API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#distinct) If you specify a value for the document field name that is not of type`String` such as a `Document`, `Array`, `Number`, or `null`, the method does not execute and returns a `TypeMismatch` error with a message that resembles the following: > \"key\" had the wrong type. Expected string, found <non-string type> Visit [Retrieve Distinct Values](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/distinct/#std-label-node-fundamentals-distinct) for more information about the `distinct()`method. ## Example The following snippet retrieves a list of distinct values for the `year`document field from the `movies` collection. It uses a query document to match movies that include \"Barbara Streisand\" as a `director`. ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) If you run the preceding example, you should see the following output: ``` [ 1983, 1991, 1996 ] \n``` ← [Count Documents](https://mongodb.com/docs/drivers/node/current/usage-examples/count/ \"Previous Section\")[Run a Command](https://mongodb.com/docs/drivers/node/current/usage-examples/command/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/find/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Find Multiple Documents You can query for multiple documents in a collection with`collection.find()`. The `find()` method uses a query document that you provide to match the subset of the documents in the collection that match the query. If you don't provide a query document (or if you provide an empty document), MongoDB returns all documents in the collection. For more information on querying MongoDB, see our[documentation on query documents.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/query-document/) You can also define additional query options such as[sort](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/)and[projection](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/)to configure the result set. You can specify these in the options parameter in your `find()` method call in `sort` and `projection`objects. See [collection.find()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#find) for more information on the parameters you can pass to the method. The `find()` method returns a [FindCursor](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html) that manages the results of your query. You can iterate through the matching documents using one of the following [cursor methods:](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/#std-label-cursor-methods) * `next()`\n* `toArray()`\n* `forEach()` If no documents match the query, `find()` returns an empty cursor. ## Example The following snippet finds documents from the `movies` collection. It uses the following parameters: * A **query document** that configures the query to return only movies with a runtime of less than 15 minutes.\n* A **sort** that organizes returned documents in ascending order by title (alphabetical order in which \"A\" comes before \"Z\" and \"1\" before \"9\").\n* A **projection** that explicitly excludes the `_id` field from returned documents and explicitly includes only the `title` and`imdb` object (and its embedded fields). ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) If you run the preceding example, you should see the following output: `| { title: '10 Minutes', imdb: { rating: 7.9, votes: 743, id: 339976 } }           |\n| -------------------------------------------------------------------------------- |\n| { title: '3x3', imdb: { rating: 6.9, votes: 206, id: 1654725 } }                 |\n| { title: '7:35 in the Morning', imdb: { rating: 7.3, votes: 1555, id: 406501 } } |\n| { title: '8', imdb: { rating: 7.8, votes: 883, id: 1592502 } }                   |\n| ...                                                                              | ` The `sort` and `projection` options can also be specified as methods (`sort()` and `project()`, respectively) chained to the `findOne` method. The following two commands are equivalent: ```javascript movies.find({ runtime: { $lt: 15 } }, { sort: { title: 1 }, projection: { _id: 0, title: 1, imdb: 1 }});\n\n \n``` ← [Find a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/findOne/ \"Previous Section\")[Insert Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/insert-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/quick-start/next-steps/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Next Steps Congratulations on completing the quick start tutorial! In this tutorial, you created a Node.js application that connects to a MongoDB deployment hosted on MongoDB Atlas and retrieves a document that matches a query. Learn more about the MongoDB Node.js driver from the following resources: * Discover how to perform read and write operations in the[CRUD Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/#std-label-node-crud-landing) section.\n* See examples of frequently-used operations in the[Usage Examples](https://mongodb.com/docs/drivers/node/current/usage-examples/#std-label-node-usage-examples) section. ← [Connect to MongoDB](https://mongodb.com/docs/drivers/node/current/quick-start/connect-to-mongodb/ \"Previous Section\")[Quick Reference](https://mongodb.com/docs/drivers/node/current/quick-reference/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/quick-start/create-a-deployment/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Create a MongoDB Deployment You can create a free tier MongoDB deployment on MongoDB Atlas to store and manage your data. MongoDB Atlas hosts and manages your MongoDB database in the cloud. 1 ## Create a Free MongoDB deployment on Atlas Complete the [Get Started with Atlas](https://www.mongodb.com/docs/atlas/getting-started/?tck=docs%5Fdriver%5Fnodejs)guide to set up a new Atlas account and load sample data into a new free tier MongoDB deployment. 2 ## Save your Credentials After you create your database user, save that user's username and password to a safe location for use in an upcoming step. After you complete these steps, you should have a new free tier MongoDB deployment on Atlas, database user credentials, and sample data loaded in your database. ## Note If you run into issues on this step, ask for help in the[MongoDB Community Forums](https://www.mongodb.com/community/forums/tag/node-js/)or submit feedback using the Share Feedbacktab on the right or bottom right side of this page. [Next: Create a Connection String](https://mongodb.com/docs/drivers/node/current/quick-start/create-a-connection-string/) ← [Download and Install](https://mongodb.com/docs/drivers/node/current/quick-start/download-and-install/ \"Previous Section\")[Create a Connection String](https://mongodb.com/docs/drivers/node/current/quick-start/create-a-connection-string/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/quick-start/connect-to-mongodb/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Connect to MongoDB 1 ## Create your Node.js Application Create a file to contain your application called `index.js` in your`node_quickstart` project directory. Copy and paste the following code into the `index.js` file: `| const { MongoClient } = require(\"mongodb\");                  |\n| ------------------------------------------------------------ |\n| // Replace the uri string with your connection string.       |\n| const uri = \"<connection string uri>\";                       |\n| const client = new MongoClient(uri);                         |\n| async function run() {                                       |\n| try {                                                        |\n| const database = client.db('sample_mflix');                  |\n| const movies = database.collection('movies');                |\n| // Query for a movie that has the title 'Back to the Future' |\n| const query = { title: 'Back to the Future' };               |\n| const movie = await movies.findOne(query);                   |\n| console.log(movie);                                          |\n| } finally {                                                  |\n| // Ensures that the client will close when you finish/error  |\n| await client.close();                                        |\n| }                                                            |\n| }                                                            |\n| run().catch(console.dir);                                    | ` 2 ## Assign the Connection String Replace the `<connection string uri>` placeholder with the connection string that you copied from the [Create a Connection String](https://mongodb.com/docs/drivers/node/current/quick-start/create-a-connection-string/#std-label-node-quick-start-connection-string)step of this guide. 3 ## Run your Node.js Application In your shell, run the following command to start this application: ``` node index.js \n``` You should see the details of the retrieved movie document in the command line output: ``` {   _id: ...,   plot: 'A young man is accidentally sent 30 years into the past...',   genres: [ 'Adventure', 'Comedy', 'Sci-Fi' ],   ...   title: 'Back to the Future',   ... } \n```\n\n After you complete these steps, you should have a working application that uses the driver to connect to your MongoDB deployment, runs a query on the sample data, and prints out the result. ## Note If you run into issues on this step, ask for help in the[MongoDB Community Forums](https://www.mongodb.com/community/forums/tag/node-js/)or submit feedback using the Share Feedbacktab on the right or bottom right side of this page. [Next Steps](https://mongodb.com/docs/drivers/node/current/quick-start/next-steps/) ← [Create a Connection String](https://mongodb.com/docs/drivers/node/current/quick-start/create-a-connection-string/ \"Previous Section\")[Next Steps](https://mongodb.com/docs/drivers/node/current/quick-start/next-steps/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/usage-examples/changeStream/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Watch for Changes ## Open a Change Stream You can watch for changes in MongoDB using the `watch()` method on the following objects: * [Collection](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#watch)\n* [Database](https://mongodb.github.io/node-mongodb-native/5.1/classes/Db.html#watch)\n* [MongoClient](https://mongodb.github.io/node-mongodb-native/5.1/classes/MongoClient.html#watch) For each object, the `watch()` method opens a **change stream** to emit **change event** documents when they occur. The `watch()` method optionally takes an **aggregation pipeline** which consists of an array of **aggregation stages**as the first parameter. The aggregation stages filter and transform the change events. In the following snippet, the `$match` stage matches all change event documents with a `runtime` value of less than 15, filtering all others out. `| const pipeline = [ { $match: { runtime: { $lt: 15 } } } ]; |\n| ---------------------------------------------------------- |\n| const changeStream = myColl.watch(pipeline);               | ` The `watch()` method accepts an `options` object as the second parameter. Refer to the links at the end of this section for more information on the settings you can configure with this object. The `watch()` method returns an instance of a [ChangeStream](https://mongodb.github.io/node-mongodb-native/5.1/classes/ChangeStream.html). You can read events from change streams by iterating over them or listening for events. Select the tab that corresponds to the way you want to read events from the change stream: ## Warning Using a `ChangeStream` in `EventEmitter` and `Iterator` mode concurrently is not supported by the driver and causes an error. This is to prevent undefined behavior, where the driver cannot guarantee which consumer receives documents first. ## Examples ### Iteration The following example opens a change stream on the `haikus` collection in the `insertDB` database and prints change events as they occur: ## Note You can use this example to connect to an instance of MongoDB and interact with a database that contains sample data. To learn more about connecting to your MongoDB instance and loading a sample dataset, see the [Usage Examples guide.](https://mongodb.com/docs/drivers/node/current/usage-examples/) ## Note ### Identical Code Snippets The JavaScript and TypeScript code snippets above are identical. There are no TypeScript specific features of the driver relevant to this use case. When you run this code and then make a change to the `haikus`collection, such as performing an insert or delete operation, you can see the change event document printed in your terminal. For example, if you insert a document to the collection, the code prints the following output: ``` Received change: {   _id: {     _data: '...'   },   operationType: 'insert',   clusterTime: new Timestamp({ t: 1675800603, i: 31 }),   fullDocument: {     _id: new ObjectId(\"...\"),     ...   },   ns: { db: 'insertDB', coll: 'haikus' },   documentKey: { _id: new ObjectId(\"...\") } } \n``` ## Note ### Receive Full Documents From Updates Change events that contain information on update operations only return the modified fields by default rather than the full updated document. You can configure your change stream to also return the most current version of the document by setting the `fullDocument` field of the options object to`\"updateLookup\"` as follows: ```javascript const options = { fullDocument: \"updateLookup\" }; // This could be any pipeline. const pipeline = []; const changeStream = myColl.watch(pipeline, options); \n``` ### Listener Function The following example opens a change stream on the `haikus` collection in the `insertDB` database. Let's create a listener function to receive and print change events that occur on the collection.\n\n To generate the change event on the collection, let's use the `insertOne()`method to add a new document. Since `insertOne()` may run before the listener function can register, we use a timer, defined as`simulateAsyncPause` to wait 1 second before executing the insert. We also use `simulateAsyncPause` after the insertion of the document. This provides ample time for the listener function to receive the change event and for the listener to complete its execution before closing the `ChangeStream` instance using the `close()` method. ## Note ### Reason to include timers The timers used in this example are only for demonstration purposes. They make sure that there is enough time to register the listener and have the listener process the change event before exiting. ## Note ### Identical Code Snippets The JavaScript and TypeScript code snippets above are identical. There are no TypeScript specific features of the driver relevant to this use case. Visit the following resources for additional material on the classes and methods mentioned on this page: * [Change streams](https://www.mongodb.com/docs/manual/changeStreams/)\n* [Change events](https://www.mongodb.com/docs/manual/reference/change-events/)\n* [Aggregation pipeline](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/)\n* [Aggregation stages](https://www.mongodb.com/docs/manual/changeStreams/#modify-change-stream-output)\n* [ChangeStream class API documentation](https://mongodb.github.io/node-mongodb-native/5.1/classes/ChangeStream.html)\n* [Collection.watch(),](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#watch)\n* [Db.watch(),](https://mongodb.github.io/node-mongodb-native/5.1/classes/Db.html#watch)\n* [MongoClient.watch() API documentation](https://mongodb.github.io/node-mongodb-native/5.1/classes/MongoClient.html#watch) ← [Run a Command](https://mongodb.com/docs/drivers/node/current/usage-examples/command/ \"Previous Section\")[Perform Bulk Operations](https://mongodb.com/docs/drivers/node/current/usage-examples/bulkWrite/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/logging/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Logging On this page * [Temporary Alternative](#temporary-alternative) ## Important The driver doesn't use the logger in versions 4.0 and later. Attempting to use prior logger settings in this version won't print anything in the log. Instead, see our monitoring guides: * [Command Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/command-monitoring/#std-label-node-command-monitoring)\n* [Cluster Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/cluster-monitoring/#std-label-node-cluster-monitoring)\n* [Connection Pool Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/connection-monitoring/#std-label-node-connection-pool-monitoring) ## Temporary Alternative The Node.js team is currently working on rewriting the logger. In the meantime, you can output monitor events using the following snippet: `| const uri = \"mongodb+srv://<user>:<password>@<cluster-url>?writeConcern=majority\"; |\n| ---------------------------------------------------------------------------------- |\n| const client = new MongoClient(uri, { monitorCommands:true });                     |\n| client.on('commandStarted', (event) => console.debug(event));                      |\n| client.on('commandSucceeded', (event) => console.debug(event));                    |\n| client.on('commandFailed', (event) => console.debug(event));                       | ` ← [Collations](https://mongodb.com/docs/drivers/node/current/fundamentals/collations/ \"Previous Section\")[Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/quick-start/download-and-install/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Download and Install 1 ## Install Node and npm Ensure you have Node.js v12 or later and npm (Node Package Manager) installed in your development environment. For information on how to install Node.js and npm, see[downloading and installing Node.js and npm.](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm) 2 ## Create a Project Directory In your shell, run the following command to create a directory called `node_quickstart` for this project: `| mkdir node_quickstart |\n| --------------------- | ` Run the following command to navigate into the project directory: ```bash cd node_quickstart \n``` Run the following command to initialize your Node.js project: ```bash npm init -y \n``` When this command successfully completes, you should have a `package.json`file in your `node_quickstart` directory. 3 ## Install the Node.js Driver Run the following command in your shell to install the driver in your project directory: ```bash npm install mongodb@5.1 \n``` This command performs the following actions: * Downloads the `mongodb` package and the dependencies it requires\n* Saves the package in the `node_modules` directory\n* Records the dependency information in the `package.json` file After you complete these steps, you should have Node.js and npm installed and a new project directory with the driver dependencies installed. ## Note If you run into issues on this step, ask for help in the[MongoDB Community Forums](https://www.mongodb.com/community/forums/tag/node-js/)or submit feedback using the Share Feedbacktab on the right or bottom right side of this page. [Next: Create a MongoDB Deployment](https://mongodb.com/docs/drivers/node/current/quick-start/create-a-deployment/) ← [Quick Start](https://mongodb.com/docs/drivers/node/current/quick-start/ \"Previous Section\")[Create a MongoDB Deployment](https://mongodb.com/docs/drivers/node/current/quick-start/create-a-deployment/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/quick-start/create-a-connection-string/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Create a Connection String You can connect to your MongoDB deployment by providing a**connection URI**, also called a _connection string_, which instructs the driver on how to connect to a MongoDB deployment and how to behave while connected. The connection string includes the hostname or IP address and port of your deployment, the authentication mechanism, user credentials when applicable, and connection options. To connect to an instance or deployment not hosted on Atlas, see[Other Ways to Connect to MongoDB.](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connect/#std-label-node-other-ways-to-connect) 1 ## Find your MongoDB Atlas Connection String To retrieve your connection string for the deployment that you created in the [previous step](https://mongodb.com/docs/drivers/node/current/quick-start/create-a-deployment/#std-label-node-quick-start-create-deployment), log into your Atlas account and navigate to theDatabase section and click the Connect button for your new deployment. ![The connect button in the clusters section of the Atlas UI](https://mongodb.com/docs/drivers/node/current/includes/figures/atlas_connection_select_cluster.png) Proceed to the Connect your application section and select \"Node.js\" from the Driver selection menu and the version that best matches the version you installed from the Versionselection menu. Select the Password (SCRAM) authentication mechanism. Deselect the Include full driver code example to view the connection string. 2 ## Copy your Connection String Click the button on the right of the connection string to copy it to your clipboard as shown in the following screenshot: ![The connection string copy button in the Atlas UI](https://mongodb.com/docs/drivers/node/current/includes/figures/atlas_connection_copy_string_node.png) 3 ## Update the Placeholders Paste this connection string into a a file in your preferred text editor and replace the \"<username>\" and \"<password>\" placeholders with your database user's username and password. Save this file to a safe location for use in the next step. After completing these steps, you should have a connection string that contains your database username and password. ## Note If you run into issues on this step, ask for help in the[MongoDB Community Forums](https://www.mongodb.com/community/forums/tag/node-js/)or submit feedback using the Share Feedbacktab on the right or bottom right side of this page. [Next: Connect to MongoDB](https://mongodb.com/docs/drivers/node/current/quick-start/connect-to-mongodb/) ← [Create a MongoDB Deployment](https://mongodb.com/docs/drivers/node/current/quick-start/create-a-deployment/ \"Previous Section\")[Connect to MongoDB](https://mongodb.com/docs/drivers/node/current/quick-start/connect-to-mongodb/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/authentication/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Authentication ## Overview These guides show you how to authenticate to a MongoDB instance using the Node.js driver. The [Authentication Mechanisms](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/mechanisms/) guide contains sample connection code using each authentication mechanism supported in the MongoDB Community Edition which includes: * `DEFAULT`\n* `SCRAM-SHA-256`\n* `SCRAM-SHA-1`\n* `MONGODB-CR`\n* `MONGODB-AWS`\n* `X.509` The [Enterprise Authentication Mechanisms](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/enterprise-mechanisms/) guide contains sample connection code using authentication mechanisms available only in MongoDB Enterprise Edition which includes: * `Kerberos (GSSAPI/SSPI)`\n* `LDAP (PLAIN)` ## Note For instructions on MongoDB driver installation and deployment setup, see our [Connect to MongoDB guide](https://www.mongodb.com/docs/guides/server/drivers/). Select your MongoDB deployment type and the Node.js client. ← [Stable API](https://mongodb.com/docs/drivers/node/current/fundamentals/stable-api/ \"Previous Section\")[Authentication Mechanisms](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/mechanisms/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # CRUD Operations CRUD (Create, Read, Update, Delete) operations allow you to work with the data stored in MongoDB. The CRUD operation documentation is categorized in two sections: * [Read Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/) find and return documents stored within your MongoDB database.\n* [Write Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/) insert, modify, or delete documents in your MongoDB database. Some operations combine aspects of read and write operations. See our guide on [compound operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/compound-operations/)to learn more about these hybrid methods. ## Note If you are looking for additional resources for learning topics related to CRUD, check out the following posts on the [MongoDB Developer Hub:](https://developer.mongodb.com) * Learn how to apply [CRUD Operations](https://developer.mongodb.com/quickstart/node-crud-tutorial)with an example scenario.\n* Analyze data in MongoDB Atlas using the [Aggregation Pipeline.](https://developer.mongodb.com/quickstart/node-aggregation-framework) ← [Enterprise Authentication Mechanisms](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/enterprise-mechanisms/ \"Previous Section\")[Read Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/encrypt-fields/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Encrypt Fields On this page * [Overview](#overview)\n* [Queryable Encryption](#queryable-encryption)\n* [Client-side Field Level Encryption (CSFLE)](#client-side-field-level-encryption--csfle-) ## Overview You can encrypt fields in a document using a set of features called**in-use encryption**. In-use encryption enables your client applications to encrypt data_before_ sending it to MongoDB, and to query documents with encrypted fields. Because the driver encrypts the data before sending it to MongoDB, only your configured client applications can decrypt the data. Only applications using the driver with access to your encryption keys can access the decrypted, plaintext data. Should you have unauthorized access to your database, an attacker could only see the encrypted, ciphertext data. In-use encryption can help prevent exposure of the following sensitive types of data: * Credit card numbers\n* Addresses\n* Health information\n* Financial information\n* Any other sensitive or personally identifiable information (PII) MongoDB offers the following ways to encrypt fields: ### Queryable Encryption Queryable Encryption is the next-generation in-use encryption feature, introduced in MongoDB 6.0 and available as a public preview. Queryable Encryption supports searching encrypted fields for equality and encrypts each value uniquely. The MongoDB manual contains detailed information on the following Queryable Encryption topics: * To get started, see the [Queryable Encryption Quick Start.](https://www.mongodb.com/docs/manual/core/queryable-encryption/quick-start/#std-label-qe-quick-start)\n* To learn how to use Queryable Encryption, see the [Queryable Encryption Fundamentals.](https://www.mongodb.com/docs/manual/core/queryable-encryption/fundamentals/#std-label-qe-fundamentals)\n* To learn how to integrate your implementation with a KMS, see the [Queryable Encryption Tutorials.](https://www.mongodb.com/docs/manual/core/queryable-encryption/tutorials/#std-label-qe-tutorials)\n* To learn Queryable Encryption concepts, see the [Queryable Encryption Reference.](https://www.mongodb.com/docs/manual/core/queryable-encryption/reference/#std-label-qe-reference) ### Client-side Field Level Encryption (CSFLE) Client-side Field Level Encryption (CSFLE) was introduced in MongoDB v4.2 and supports searching encrypted fields for equality. CSFLE differs from Queryable Encryption in that it requires that the encrypted fields you want to search must be determinstically encrypted. When you deterministically encrypt a value, the same input value produces the same output value. While deterministic encryption provides greater support for read operations, encrypted data with low [cardinality](https://en.wikipedia.org/wiki/Cardinality)is susceptible to recovery using [frequency analysis.](https://en.wikipedia.org/wiki/Frequency%5Fanalysis) The MongoDB manual contains detailed information on the following CSFLE topics: * To get started, see the [CSFLE Quick Start.](https://www.mongodb.com/docs/manual/core/csfle/quick-start/#std-label-csfle-quick-start)\n* To learn how to use CSFLE, see the [CSFLE Fundamentals.](https://www.mongodb.com/docs/manual/core/csfle/fundamentals/#std-label-csfle-fundamentals)\n* To learn how to integrate your CSFLE implementation with a KMS, see the [CSFLE Tutorials.](https://www.mongodb.com/docs/manual/core/csfle/tutorials/#std-label-csfle-tutorials)\n* To learn CSFLE concepts, see the [CSFLE Reference.](https://www.mongodb.com/docs/manual/core/csfle/reference/#std-label-csfle-reference)\n\n",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/indexes/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Indexes On this page * [Overview](#overview)\n* [Query Coverage and Performance](#query-coverage-and-performance)\n* [Operational Considerations](#operational-considerations)\n* [Index Types](#index-types)\n* [Single Field Indexes](#single-field-indexes)\n* [Compound Indexes](#compound-indexes)\n* [Multikey Indexes (Indexes on Array Fields)](#multikey-indexes--indexes-on-array-fields-)\n* [Clustered Indexes](#clustered-indexes)\n* [Text Indexes](#text-indexes)\n* [Geospatial Indexes](#geospatial-indexes)\n* [Unique Indexes](#unique-indexes) ## Overview Indexes are data structures that support the efficient execution of queries in MongoDB. They contain copies of parts of the data in documents to make queries more efficient. Without indexes, MongoDB must scan _every_ document in a collection to find the documents that match each query. These collection scans are slow and can negatively affect the performance of your application. By using an index to limit the number of documents MongoDB scans, queries can be more efficient and therefore return faster. ### Query Coverage and Performance When you execute a query against MongoDB, your query can include three parts: * query criteria that specify field(s) and value(s) you are looking for\n* options that affect the query's execution, such as read concern\n* projection criteria to specify the fields MongoDB should return (optional) When all the fields specified in the query criteria and projection of a query are indexed, MongoDB returns results directly from the index without scanning any documents in the collection or loading them into memory. For additional information on how to ensure your index covers your query criteria and projection, see the MongoDB manual articles on[query coverage](https://www.mongodb.com/docs/manual/core/query-optimization/#read-operations-covered-query)and [index intersection.](https://www.mongodb.com/docs/manual/core/index-intersection/) ### Operational Considerations To improve query performance, build indexes on fields that appear often in your application's queries and operations that return sorted results. Each index that you add consumes disk space and memory when active so you should track index memory and disk usage for capacity planning. In addition, when a write operation updates an indexed field, MongoDB also has to update the related index. For more information on designing your data model and choosing indexes appropriate for your application, see the MongoDB server documentation on[Indexing Strategies](https://www.mongodb.com/docs/manual/applications/indexes/) and[Data Modeling and Indexes.](https://www.mongodb.com/docs/manual/core/data-model-operations/#data-model-indexes) ## Index Types MongoDB supports a number of different index types to support querying your data. The following sections describe the most common index types and provide sample code for creating each index type. ### Single Field Indexes **Single field indexes** are indexes that improve performance for queries that specify ascending or descending sort order on a single field of a document. The following example uses the `createIndex()` method to create an ascending order index on the `title` field in the `movies` collection in the `sample_mflix` database. `` | const database = client.db(\"sample_mflix\");              |\n| -------------------------------------------------------- |\n| const movies = database.collection(\"movies\");            |\n| // Create an ascending index on the \"title\" field in the |\n| // \"movies\" collection.                                  |\n| const result = await movies.createIndex({ title: 1 });   |\n| console.log(`Index created: ${result}`);                 |  `` The following is an example of a query that would be covered by the index created above. ```js const query = { title: \"Batman\" } const sort = { title: 1 }; const projection = { _id: 0, title: 1 };\n\n   .find(query)   .sort(sort)   .project(projection); \n``` To learn more, see [Single Field Indexes.](https://www.mongodb.com/docs/manual/core/index-single/) ### Compound Indexes **Compound indexes** are indexes that improve performance for queries that specify ascending or descending sort order for _multiple_ fields of a document. You must specify the direction (ascending or descending) for each field in the index. The following example uses the `createIndex()` method to create a compound index on the `type` and `genre` fields in the `movies` collection in the`sample_mflix` database. ```js const database = client.db(\"sample_mflix\"); const movies = database.collection(\"movies\"); // Create an ascending index on the \"type\" and \"genre\" fields // in the \"movies\" collection. const result = await movies.createIndex({ type: 1, genre: 1 }); console.log(`Index created: ${result}`); \n``` The following is an example of a query that would be covered by the index created above. ```js const query = { type: \"movie\", genre: \"Drama\" }; const sort = { type: 1, genre: 1 }; const projection = { _id: 0, type: 1, genre: 1 }; const cursor = movies   .find(query)   .sort(sort)   .project(projection); \n``` To learn more, see [Compound Indexes.](https://www.mongodb.com/docs/manual/core/index-compound/) ### Multikey Indexes (Indexes on Array Fields) **Multikey indexes** are indexes that improve the performance of queries on fields that contain array values. You can create a multikey index on a field with an array value by calling the `createIndex()` method. The following code creates an ascending index on the `cast` field in the `movies` collection of the`sample_mflix` database: ```js const database = client.db(\"sample_mflix\"); const movies = database.collection(\"movies\"); // Create a multikey index on the \"cast\" field const result = await movies.createIndex({ cast: 1 }); \n``` The following code queries the multikey index to find documents with a `cast` field value that contains \"Viola Davis\": ```js const query = { cast: \"Viola Davis\" }; const projection = { _id: 0, cast: 1 , title: 1 }; const cursor = movies   .find(query)   .project(projection); \n``` Multikey indexes behave differently from non-multikey indexes in terms of query coverage, index bound computation, and sort behavior. For a full explanation of multikey indexes, including a discussion of their behavior and limitations, refer to the [Multikey Indexes page](https://www.mongodb.com/docs/manual/core/index-multikey/) in the MongoDB Server manual. ### Clustered Indexes **Clustered indexes** are indexes that improve the performance of insert, update, and delete operations on **clustered collections**. Clustered collections store documents ordered by the clustered index key value. To create a clustered index, specify the `clusteredIndex` option in the `CollectionOption`. The `clusteredIndex` option must specify the`_id` field as the key and the unique field as `true`. The following example uses the `createCollection()` method to create a clustered index on the `_id` field in the `vendors` collection of the`tea` database. ```javascript const db = client.db('tea'); await db.createCollection('ratings', {   clusteredIndex: {     key: { _id: 1 },     unique: true   } }); \n``` To learn more, see[Clustered Indexes](https://www.mongodb.com/docs/v6.0/reference/method/db.createCollection/#std-label-db.createCollection.clusteredIndex) and[Clustered Collections.](https://www.mongodb.com/docs/v6.0/core/clustered-collections/) ### Text Indexes\n\n The following example uses the `createIndex()` method to create a`text` index on the `fullplot` field in the `movies` collection in the `sample_mflix` database and specifies `english` as the default language. ```js const database = client.db(\"sample_mflix\"); const movies = database.collection(\"movies\"); // Create a text index on the \"fullplot\" field in the // \"movies\" collection. const result = await movies.createIndex({ fullplot: \"text\" }, { default_language: \"english\" }); console.log(`Index created: ${result}`); \n``` The following is an example of a query that would be covered by the index created above. Note that the `sort` is omitted because text indexes do not contain sort order. ```js const query = { $text: { $search: \"java coffee shop\" } }; const projection = { _id: 0, fullplot: 1 }; const cursor = movies   .find(query)   .project(projection); \n``` To learn more, see [Text Indexes.](https://www.mongodb.com/docs/manual/core/index-text/) ### Geospatial Indexes MongoDB supports queries of geospatial coordinate data using **2dsphere indexes**. With a 2dsphere index, you can query the geospatial data for inclusion, intersection, and proximity. For more information on querying geospatial data with the MongoDB Node.js driver, read our[Search Geospatial](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/geo/) guide. To create a 2dsphere index, you must specify a field that contains only **GeoJSON objects**. For more details on this type, see the MongoDB server manual page on [GeoJSON objects.](https://www.mongodb.com/docs/manual/reference/geojson/) The `location.geo` field in following sample document from the`theaters` collection in the `sample_mflix` database is a GeoJSON Point object that describes the coordinates of the theater: ``` {    \"_id\" : ObjectId(\"59a47286cfa9a3a73e51e75c\"),    \"theaterId\" : 104,    \"location\" : {       \"address\" : {          \"street1\" : \"5000 W 147th St\",          \"city\" : \"Hawthorne\",          \"state\" : \"CA\",          \"zipcode\" : \"90250\"       },       \"geo\" : {          \"type\" : \"Point\",          \"coordinates\" : [             -118.36559,             33.897167          ]       }    } } \n``` The following example uses the `createIndexes()` method to create a`2dsphere` index on the `location.geo` field in the `theaters`collection in the `sample_mflix` database to enable geospatial searches. ```js const database = client.db(\"sample_mflix\"); const movies = database.collection(\"movies\"); // Create a 2dsphere index on the \"location.geo\" field in the \"theaters\" collection. const result = await movies.createIndex({ \"location.geo\": \"2dsphere\" }); console.log(`Index created: ${result}`); \n``` MongoDB also supports `2d` indexes for calculating distances on a Euclidean plane and for working with the \"legacy coordinate pairs\" syntax used in MongoDB 2.2 and earlier. To learn more, see[Geospatial Queries.](https://www.mongodb.com/docs/manual/geospatial-queries/) ### Unique Indexes **Unique indexes** ensure that the indexed fields do not store duplicate values. By default, MongoDB creates a unique index on the `_id` field during the creation of a collection. To create a unique index, specify the field or combination of fields that you want to prevent duplication on and set the `unique` option to `true`.\n\n ```js const database = client.db(\"sample_mflix\"); const movies = database.collection(\"movies\"); // Create a unique index on the \"theaterId\" field in the \"theaters\" collection. const result = await movies.createIndex({ theaterId: 1 }, { unique: true }); console.log(`Index created: ${result}`); \n``` If you attempt to perform a write operation that stores a duplicate value that violates the unique index, MongoDB will throw an error that resembles the following: ``` E11000 duplicate key error index \n``` To learn more, see [Unique Indexes.](https://www.mongodb.com/docs/manual/core/index-unique/) ← [Transactions](https://mongodb.com/docs/drivers/node/current/fundamentals/transactions/ \"Previous Section\")[Collations](https://mongodb.com/docs/drivers/node/current/fundamentals/collations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/stable-api/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Stable API On this page * [Overview](#overview)\n* [Enable the Stable API on a MongoDB Client](#enable-the-stable-api-on-a-mongodb-client)\n* [Stable API Options](#stable-api-options) ## Note The Stable API feature requires MongoDB Server 5.0 or later. You should only use the Stable API feature if all the MongoDB servers you are connecting to support this feature. ## Overview In this guide, you can learn how to specify the **Stable API** when connecting to a MongoDB instance or replica set. You can use the Stable API feature to force the server to run operations with behavior compatible with the specified **API version**. An API version defines the expected behavior of the operations it covers and the format of server responses. If you change to a different API version, the operations are not guaranteed to be compatible and the server responses are not guaranteed to be similar. When you use the Stable API feature with an official MongoDB driver, you can update your driver or server without worrying about backward compatibility issues of the commands covered by the Stable API. See the MongoDB reference page on the [Stable API](https://www.mongodb.com/docs/manual/reference/stable-api/)for more information including a list of commands it covers. The following sections describe how you can enable the Stable API for your MongoDB client and the options that you can specify. ## Enable the Stable API on a MongoDB Client To enable the Stable API, you must specify an API version in the `MongoClientOptions`passed to your `MongoClient`. Once you instantiate a `MongoClient` instance with a specified API version, all commands you run with that client use that version of the Stable API. ## Tip If you need to run commands using more than one version of the Stable API, instantiate a separate client with that version. If you need to run commands not covered by the Stable API, make sure the \"strict\" option is disabled. See the section on[Stable API Options](#std-label-nodejs-stable-api-options) for more information. The example below shows how you can instantiate a `MongoClient` that sets the Stable API version and connects to a server by performing the following operations: * Specify a server URI to connect to.\n* Specify a Stable API version in the `MongoClientOptions` object, using a constant from the `ServerApiVersion` object.\n* Instantiate a `MongoClient`, passing the URI and the `MongoClientOptions`to the constructor. `| const { MongoClient, ServerApiVersion } = require(\"mongodb\");                            |\n| ---------------------------------------------------------------------------------------- |\n| const uri = \"mongodb+srv://<user>:<password>@<cluster-url>?retryWrites=true&w=majority\"; |\n| const client = new MongoClient(uri, { serverApi: ServerApiVersion.v1 });                 | ` ## Warning If you specify an API version and connect to a MongoDB server that does not support the Stable API, your application may throw an error when connecting to your MongoDB server with the following text: ``` MongoParseError: Invalid server API version=... \n``` For more information on the methods and classes referenced in this section, see the following API Documentation: * [ServerApiVersion](https://mongodb.github.io/node-mongodb-native/5.1/modules.html#ServerApiVersion)\n* [MongoClientOptions](https://mongodb.github.io/node-mongodb-native/5.1/interfaces/MongoClientOptions.html)\n* [MongoClient](https://mongodb.github.io/node-mongodb-native/5.1/classes/MongoClient.html) ## Stable API Options You can enable or disable optional behavior related to the Stable API as described in the following table.\n\n The following example shows how you can set the options of the `ServerApi`interface. ```javascript const { MongoClient, ServerApiVersion } = require(\"mongodb\"); const uri = \"mongodb+srv://<user>:<password>@<cluster-url>?retryWrites=true&w=majority\"; const client = new MongoClient(uri,     {         serverApi: {             version: ServerApiVersion.v1,             strict: true,             deprecationErrors: true,         }     }); \n``` For more information on the options in this section, see the following API Documentation: * [ServerApi](https://mongodb.github.io/node-mongodb-native/5.1/interfaces/ServerApi.html) ← [Network Compression](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/network-compression/ \"Previous Section\")[Authentication](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/promises/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Promises On this page * [Overview](#overview)\n* [Promises](#promises-1)\n* [Await](#await)\n* [Operational Considerations](#operational-considerations) ## Overview The Node.js driver uses the asynchronous Javascript API to communicate with your MongoDB cluster. Asynchronous Javascript allows you to execute operations without waiting for the processing thread to become free. This helps prevent your application from becoming unresponsive when executing long-running operations. For more information about asynchronous Javascript, see the MDN web documentation on[Asynchronous Javascript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous). This section describes `Promises` that you can use with the Node.js driver to access the results of your method calls to your MongoDB cluster. ## Promises A Promise is an object returned by the asynchronous method call that allows you to access information on the eventual success or failure of the operation that they wrap. The Promise is in the **Pending** state if the operation is still running, **Fulfilled** if the operation completed successfully, and**Rejected** if the operation threw an exception. For more information on Promises and related terminology, see the MDN documentation on[Promises.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) Most driver methods that communicate with your MongoDB cluster, such as`findOneAndUpdate()` and `countDocuments()`, return Promise objects and already contain logic to handle the success or failure of the operation. You can define your own logic that executes once the Promise reaches the**Fulfilled** or **Rejected** state by appending the `then()` method. The first parameter of `then()` is the method that gets called when the Promise reaches the **Fulfilled** state and the optional second parameter is the method that gets called when it reaches the **Rejected** state. The`then()` method returns a Promise to which you can append additional`then()` methods. When you append one or more `then()` methods to a Promise, each call passes its execution result to the next one. This pattern is called**Promise chaining**. The following code snippet shows an example of Promise chaining by appending a single `then()` method. `` | collection                                                         |\n| ------------------------------------------------------------------ |\n| .updateOne({ name: \"Mount McKinley\" }, { $set: { meters: 6190 } }) |\n| .then(                                                             |\n| res => console.log(`Updated ${res.result.n} documents`),           |\n| err => console.error(`Something went wrong: ${err}`),              |\n| );                                                                 |  `` If you only need to handle Promise transitions to the **Rejected** state, rather than passing a `null` first parameter to `then()`, you can instead use the `catch()` method which accepts a single callback, executed when the Promise transitions to the **Rejected** state. The `catch()` method is often appended at the end of a Promise chain to handle any exceptions thrown. The following code snippet demonstrates appending a `catch()` method to the end of a Promise chain. ```js deleteOne({ name: \"Mount Doom\" })   .then(result => {     if (result.deletedCount !== 1) {       throw \"Could not find Mount Doom!\";     }\n\n       ...     });   })   .then(result => console.log(`Vanquished ${result.quantity} Nazgul`))   .catch(err => console.error(`Fatal error occurred: ${err}`)); \n``` ## Note Certain methods in the driver such as `find()` return a `Cursor`instead of a Promise. To determine what type each method returns, refer to the [Node.js API documentation.](https://mongodb.github.io/node-mongodb-native/5.1) ### Await If you are using `async` functions, you can use the `await` operator on a Promise to pause further execution until the Promise reaches either the**Fulfilled** or **Rejected** state and returns. Since the `await` operator waits for the resolution of the Promise, you can use it in place of Promise chaining to sequentially execute your logic. The following code snippet uses `await` to execute the same logic as the first Promise chaining example. ```js async function run() {   ...   try {     res = await myColl.updateOne(       { name: \"Mount McKinley\" },       { $set: { meters: 6190 } },     );     console.log(`Updated ${res.result.n} documents`);   } catch (err) {     console.error(`Something went wrong: ${err}`);   } } \n``` For additional information, see the MDN documentation on[await.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) ## Operational Considerations One common mistake when using `async` methods is to forget to use `await`operator on Promises to get the value of the result rather than the Promise object. Consider the following example in which we iterate over a cursor using `hasNext()`, which returns a Promise that resolves to a boolean that indicates whether additional results exist, and `next()` which returns a Promise that resolves to the next entry the cursor is pointing to. ```js async function run() {   ...   // WARNING: this snippet may cause an infinite loop   const cursor = myColl.find();   while (cursor.hasNext()) {     console.log(cursor.next());   } } \n``` Since the call to `hasNext()` returns a `Promise`, the conditional statement returns `true` regardless of the value that it resolves to. If we alter the code to `await` the call to `next()` only, as demonstrated in the following code snippet, it throws the following error:`MongoError: Cursor is closed`. ```js async function run() {   ...   // WARNING: this snippet throws a MongoError   const cursor = myColl.find();   while (cursor.hasNext()) {     console.log(await cursor.next());   } } \n``` While `hasNext()` is not called until after the result of `next()` returns, the call to `hasNext()` returns a Promise which evaluates to `true` rather than the value it resolves to, similar to the prior example. The code attempts to call `next()` on a Cursor that has already returned its results and closed as a result. If we alter the code to only `await` the call to `hasNext()` as shown in the following example, the console prints Promise objects rather than the document objects. ```js async function run() {   ...   // WARNING: this snippet prints Promises instead of the objects they resolve to   const cursor = myColl.find();   while (await cursor.hasNext()) {     console.log(cursor.next());   } } \n``` Use `await` before both the `hasNext()` and `next()` method calls to ensure that you are operating on the correct return values as demonstrated in the following code: ```js async function run() {   ...   const cursor = myColl.find();   while (await cursor.hasNext()) {     console.log(await cursor.next());   } } \n``` ← [Compound Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/compound-operations/ \"Previous Section\")[Aggregation](https://mongodb.com/docs/drivers/node/current/fundamentals/aggregation/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/gridfs/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # GridFS On this page * [Overview](#overview)\n* [How GridFS Works](#how-gridfs-works)\n* [Create a GridFS Bucket](#create-a-gridfs-bucket)\n* [Upload Files](#upload-files)\n* [Retrieve File Information](#retrieve-file-information)\n* [Download Files](#download-files)\n* [Rename Files](#rename-files)\n* [Delete Files](#delete-files)\n* [Delete a GridFS Bucket](#delete-a-gridfs-bucket)\n* [Additional Resources](#additional-resources) ## Overview In this guide, you can learn how to store and retrieve large files in MongoDB using **GridFS**. GridFS is a specification that describes how to split files into chunks during storage and reassemble them during retrieval. The driver implementation of GridFS manages the operations and organization of the file storage. You should use GridFS if the size of your file exceeds the BSON-document size limit of 16 megabytes. For more detailed information on whether GridFS is suitable for your use case, see the [GridFS server manual page.](https://www.mongodb.com/docs/manual/core/gridfs/) Navigate the following sections to learn more about GridFS operations and implementation: * [Create a GridFS Bucket](#std-label-gridfs-create-bucket)\n* [Upload Files](#std-label-gridfs-upload-files)\n* [Retrieve File Information](#std-label-gridfs-retrieve-file-info)\n* [Download Files](#std-label-gridfs-download-files)\n* [Rename Files](#std-label-gridfs-rename-files)\n* [Delete Files](#std-label-gridfs-delete-files)\n* [Delete a GridFS Bucket](#std-label-gridfs-delete-bucket) ## How GridFS Works GridFS organizes files in a **bucket**, a group of MongoDB collections that contain the chunks of files and descriptive information. Buckets contain the following collections, named using the convention defined in the GridFS specification: * The `chunks` collection stores the binary file chunks.\n* The `files` collection stores the file metadata. When you create a new GridFS bucket, the driver creates the `chunks`and `files` collections, prefixed with the default bucket name `fs`, unless you specify a different name. The driver also creates an index on each collection to ensure efficient retrieval of files and related metadata. The driver only creates the GridFS bucket on the first write operation if it does not already exist. The driver only creates indexes if they do not exist and when the bucket is empty. For more information on GridFS indexes, see the server manual page on [GridFS Indexes.](https://www.mongodb.com/docs/manual/core/gridfs/#gridfs-indexes) When storing files with GridFS, the driver splits the files into smaller pieces, each represented by a separate document in the `chunks` collection. It also creates a document in the `files` collection that contains a unique file id, file name, and other file metadata. You can upload the file from memory or from a stream. The following diagram describes how GridFS splits files when uploading to a bucket: ![A diagram that shows how GridFS uploads a file to a bucket](https://mongodb.com/docs/drivers/node/current/includes/figures/GridFS-upload.png) When retrieving files, GridFS fetches the metadata from the `files`collection in the specified bucket and uses the information to reconstruct the file from documents in the `chunks` collection. You can read the file into memory or output it to a stream. ## Create a GridFS Bucket Create a bucket or get a reference to an existing one to begin storing or retrieving files from GridFS. Create a `GridFSBucket`instance, passing a database as the parameter. You can then use the`GridFSBucket` instance to call read and write operations on the files in your bucket: `| const db = client.db(dbName);                |\n| -------------------------------------------- |\n| const bucket = new mongodb.GridFSBucket(db); | `\n\n ```javascript const bucket = new mongodb.GridFSBucket(db, { bucketName: 'myCustomBucket' }); \n``` For more information, see the [GridFSBucket API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/GridFSBucket.html) ## Upload Files Use the `openUploadStream()` method from `GridFSBucket` to create an upload stream for a given file name. You can use the `pipe()` method to connect a Node.js `fs` read stream to the upload stream. The`openUploadStream()` method allows you to specify configuration information such as file chunk size and other field/value pairs to store as metadata. Set these options as parameters of `openUploadStream()` as shown in the following code snippet: ```javascript fs.createReadStream('./myFile').      pipe(bucket.openUploadStream('myFile', {          chunkSizeBytes: 1048576,          metadata: { field: 'myField', value: 'myValue' }      }); \n``` See the [openUploadStream() API documentation](https://mongodb.github.io/node-mongodb-native/5.1/classes/GridFSBucket.html#openUploadStream) for more information. ## Retrieve File Information In this section, you can learn how to retrieve file metadata stored in the`files` collection of the GridFS bucket. The metadata contains information about the file it refers to, including: * The `_id` of the file\n* The name of the file\n* The length/size of the file\n* The upload date and time\n* A `metadata` document in which you can store any other information Call the `find()` method on the `GridFSBucket` instance to retrieve files from a GridFS bucket. The method returns a `FindCursor` instance from which you can access the results. The following code example shows you how to retrieve and print file metadata from all your files in a GridFS bucket. Among the different ways that you can traverse the retrieved results from the `FindCursor` iterable, the following example uses the `forEach()` method to display the results: ```javascript const cursor = bucket.find({}); cursor.forEach(doc => console.log(doc)); \n``` The `find()` method accepts various query specifications and can be combined with other methods such as `sort()`, `limit()`, and `project()`. For more information on the classes and methods mentioned in this section, see the following resources: * [find() API documentation](https://mongodb.github.io/node-mongodb-native/5.1/classes/GridFSBucket.html#find)\n* [FindCursor API documentation](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html)\n* [Cursor Fundamentals page](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/)\n* [Read Operations page](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/) ## Download Files You can download files from your MongoDB database by using the`openDownloadStreamByName()` method from `GridFSBucket` to create a download stream. The following example shows you how to download a file referenced by the file name, stored in the `filename` field, into your working directory: ```javascript bucket.openDownloadStreamByName('myFile').      pipe(fs.createWriteStream('./outputFile')); \n``` ## Note If there are multiple documents with the same `filename` value, GridFS will stream the most recent file with the given name (as determined by the `uploadDate` field). Alternatively, you can use the `openDownloadStream()`method, which takes the `_id` field of a file as a parameter: ```javascript bucket.openDownloadStream(ObjectId(\"60edece5e06275bf0463aaf3\")).      pipe(fs.createWriteStream('./outputFile')); \n``` ## Note The GridFS streaming API cannot load partial chunks. When a download stream needs to pull a chunk from MongoDB, it pulls the entire chunk into memory. The 255 kilobyte default chunk size is usually sufficient, but you can reduce the chunk size to reduce memory overhead.\n\n ## Rename Files Use the `rename()` method to update the name of a GridFS file in your bucket. You must specify the file to rename by its `_id` field rather than its file name. ## Note The `rename()` method only supports updating the name of one file at a time. To rename multiple files, retrieve a list of files matching the file name from the bucket, extract the `_id` field from the files you want to rename, and pass each value in separate calls to the `rename()`method. The following example shows how to update the `filename` field to \"newFileName\" by referencing a document's `_id` field: ```javascript bucket.rename(ObjectId(\"60edece5e06275bf0463aaf3\"), \"newFileName\"); \n``` For more information on this method, see the [rename()](https://mongodb.github.io/node-mongodb-native/5.1/classes/GridFSBucket.html#rename)API documentation. ## Delete Files Use the `delete()` method to remove a file from your bucket. You must specify the file by its `_id` field rather than its file name. ## Note The `delete()` method only supports deleting one file at a time. To delete multiple files, retrieve the files from the bucket, extract the `_id` field from the files you want to delete, and pass each value in separate calls to the `delete()` method. The following example shows you how to delete a file by referencing its `_id` field: ```javascript bucket.delete(ObjectId(\"60edece5e06275bf0463aaf3\")); \n``` For more information on this method, see the [delete()](https://mongodb.github.io/node-mongodb-native/5.1/classes/GridFSBucket.html#delete)API documentation. ## Delete a GridFS Bucket Use the `drop()` method to remove a bucket's `files` and `chunks`collections, which effectively deletes the bucket. The following code example shows you how to delete a GridFS bucket: ```javascript bucket.drop(); \n``` For more information on this method, see the [drop()](https://mongodb.github.io/node-mongodb-native/5.1/classes/GridFSBucket.html#drop)API documentation. ## Additional Resources * [MongoDB GridFS specification](https://github.com/mongodb/specifications/blob/master/source/gridfs/gridfs-spec.rst) ← [Connection Pool Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/connection-monitoring/ \"Previous Section\")[Time Series](https://mongodb.com/docs/drivers/node/current/fundamentals/time-series/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/utf8-validation/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # UTF-8 Validation On this page * [Overview](#overview)\n* [Specify the UTF-8 Validation Setting](#specify-the-utf-8-validation-setting)\n* [Set the Validation Scope](#set-the-validation-scope) ## Overview In this guide, you can learn how to enable or disable the Node.js driver's**UTF-8** validation feature. UTF-8 is a character encoding specification that ensures compatibility and consistent presentation across most operating systems, applications, and language character sets. If you _enable_ validation, the driver throws an error when it attempts to convert data that contains invalid UTF-8 characters. The validation adds processing overhead since it needs to check the data. If you _disable_ validation, your application avoids the validation processing overhead, but cannot guarantee consistent presentation of invalid UTF-8 data. The driver enables UTF-8 validation by default. It checks documents for any characters that are not encoded in a valid UTF-8 format when it transfers data between your application and MongoDB. ## Note The current version of the Node.js driver automatically substitutes invalid UTF-8 characters with alternate valid UTF-8 ones prior to validation when you send data to MongoDB. Therefore, the validation only throws an error when the setting is enabled and the driver receives invalid UTF-8 document data from MongoDB. Read the sections below to learn how to set UTF-8 validation using the Node.js driver. ## Specify the UTF-8 Validation Setting You can specify whether the driver should perform UTF-8 validation by defining the `enableUtf8Validation` setting in the options parameter when you create a client, reference a database or collection, or call a CRUD operation. If you omit the setting, the driver enables UTF-8 validation. See the following for code examples that demonstrate how to disable UTF-8 validation on the client, database, collection, or CRUD operation: `| // disable UTF-8 validation on the client                                      |\n| ------------------------------------------------------------------------------ |\n| new MongoClient('<connection uri>', { enableUtf8Validation: false });          |\n| // disable UTF-8 validation on the database                                    |\n| client.db('<database name>', { enableUtf8Validation: false });                 |\n| // disable UTF-8 validation on the collection                                  |\n| db.collection('<collection name>', { enableUtf8Validation: false });           |\n| // disable UTF-8 validation on a specific operation call                       |\n| await myColl.findOne({ title: 'Cam Jansen'}, { enableUtf8Validation: false }); | ` If your application reads invalid UTF-8 from MongoDB while the`enableUtf8Validation` option is enabled, it throws a `BSONError` that contains the following message: ``` Invalid UTF-8 string in BSON document \n``` ### Set the Validation Scope The `enableUtf8Validation` setting automatically applies to the scope of the object instance on which you included it, and any other objects created by calls on that instance. For example, if you include the option on the call to instantiate a database object, any collection instance you construct from that object inherits the setting. Any operations you call on that collection instance also inherit the setting. ```javascript const database = client.db('books', { enableUtf8Validation: false }); // The collection inherits the UTF-8 validation disabled setting from the database const myColl = database.collection('mystery'); // CRUD operation runs with UTF-8 validation disabled await myColl.findOne({ title: 'Encyclopedia Brown' }); \n``` You can override the setting at any level of scope by including it when constructing the object instance or when calling an operation.\n\n ```javascript const collection = database.collection('mystery', { enableUtf8Validation: false }); // CRUD operation runs with UTF-8 validation enabled await myColl.findOne({ title: 'Trixie Belden' }, { enableUtf8Validation: true }); // CRUD operation runs with UTF-8 validation disabled await myColl.findOne({ title: 'Enola Holmes' }); \n``` ← [TypeScript](https://mongodb.com/docs/drivers/node/current/fundamentals/typescript/ \"Previous Section\")[Encrypt Fields](https://mongodb.com/docs/drivers/node/current/fundamentals/encrypt-fields/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/aggregation/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Aggregation On this page * [Overview](#overview)\n* [Aggregation vs. Query Operations](#aggregation-vs.-query-operations)\n* [Useful References](#useful-references)\n* [Runnable Examples](#runnable-examples)\n* [Aggregation Example](#aggregation-example)\n* [Additional Aggregation Examples](#additional-aggregation-examples) ## Overview In this guide, you can learn how to use **aggregation operations** in the MongoDB Node.js driver. Aggregation operations are expressions you can use to produce reduced and summarized results in MongoDB. MongoDB's aggregation pipeline, part of the Query API, allows you to create a pipeline that consists of one or more stages, each of which performs a specific operation on your data. You can think of the aggregation pipeline as similar to an automobile factory. Automobile manufacturing requires the use of assembly stations organized into assembly lines. Each station has specialized tools, such as drills and welders. The factory transforms and assembles the initial parts and materials into finished products. The **aggregation pipeline** is the assembly line, **aggregation stages** are the assembly stations, and**operator expressions** are the specialized tools. ### Aggregation vs. Query Operations Using query operations, such as the `find()` method, you can perform the following actions: * Select _which documents_ to return.\n* Select _which fields_ to return.\n* Sort the results. Using aggregation operations, you can perform the following actions: * Perform all query operations.\n* Rename fields.\n* Calculate fields.\n* Summarize data.\n* Group values. Aggregation operations have some [limitations:](https://www.mongodb.com/docs/manual/core/aggregation-pipeline-limits/) * Returned documents must not violate the [BSON-document size limit](https://www.mongodb.com/docs/manual/reference/limits/#mongodb-limit-BSON-Document-Size)of 16 megabytes.\n* Pipeline stages have a memory limit of 100 megabytes by default. If necessary, you may exceed this limit by setting the `allowDiskUse`property of `AggregateOptions` to `true`. See the[AggregateOptions API documentation](https://mongodb.github.io/node-mongodb-native/5.1/interfaces/AggregateOptions.html)for more details. ## Important ### $graphLookup exception The [$graphLookup](https://www.mongodb.com/docs/manual/reference/operator/aggregation/graphLookup/) stage has a strict memory limit of 100 megabytes and will ignore `allowDiskUse`. ### Useful References * [Expression operators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/)\n* [Aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/)\n* [Aggregation stages](https://www.mongodb.com/docs/manual/meta/aggregation-quick-reference/#stages)\n* [Operator expressions](https://www.mongodb.com/docs/manual/meta/aggregation-quick-reference/#operator-expressions) ## Runnable Examples The example uses sample data about restaurants. The following code inserts data into the `restaurants` collection of the `aggregation`database:\n\n ` ## Tip For more information on connecting to your MongoDB deployment, see the [Connection Guide.](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/) ### Aggregation Example To perform an aggregation, pass a list of aggregation stages to the`collection.aggregate()` method. In the example, the aggregation pipeline uses the following aggregation stages: * A [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) stage to filter for documents whose`categories` array field contains the element `Bakery`.\n* A [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/) stage to group the matching documents by the `stars`field, accumulating a count of documents for each distinct value of `stars`. ```javascript const pipeline = [     { $match: { categories: \"Bakery\" } },     { $group: { _id: \"$stars\", count: { $sum: 1 } } } ]; const aggCursor = coll.aggregate(pipeline); for await (const doc of aggCursor) {     console.log(doc); } \n``` This example should produce the following output: ``` { _id: 4, count: 2 } { _id: 3, count: 1 } { _id: 5, count: 1 } \n``` For more information, see the [aggregate() API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#aggregate) ### Additional Aggregation Examples You can find another aggregation pipeline example [in this MongoDB Blog post](https://www.mongodb.com/blog/post/quick-start-nodejs--mongodb--how-to-analyze-data-using-the-aggregation-framework). ← [Promises](https://mongodb.com/docs/drivers/node/current/fundamentals/promises/ \"Previous Section\")[Transactions](https://mongodb.com/docs/drivers/node/current/fundamentals/transactions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/monitoring/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Monitoring * [Cluster Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/cluster-monitoring/): monitoring changes in a cluster\n* [Command Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/command-monitoring/): monitoring the execution status of commands\n* [Connection Pool Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/connection-monitoring/): monitoring the driver's connection pool ← [Logging](https://mongodb.com/docs/drivers/node/current/fundamentals/logging/ \"Previous Section\")[Cluster Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/cluster-monitoring/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/typescript/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # TypeScript On this page * [Overview](#overview)\n* [Features](#features)\n* [Type Parameters that Extend Document](#type-parameters-that-extend-document)\n* [Type Parameters of Any Type](#type-parameters-of-any-type)\n* [Type Safety and Dot Notation](#type-safety-and-dot-notation)\n* [Working with the \\_id Field](#working-with-the-%5Fid-field)\n* [Insert Operations and the \\_id Field](#insert-operations-and-the-%5Fid-field)\n* [Find Methods and the \\_id Field](#find-methods-and-the-%5Fid-field)\n* [Known Limitations](#known-limitations)\n* [Recursive Types and Dot Notation](#recursive-types-and-dot-notation)\n* [Mutual Recursion](#mutual-recursion) ## Overview In this guide, you can learn about the **TypeScript** features and limitations of the MongoDB Node.js driver. TypeScript is a strongly typed programming language that compiles to JavaScript. All TypeScript features of the driver are optional. All valid JavaScript code written with the driver is also valid TypeScript code. For more information, see the[TypeScript website.](https://www.typescriptlang.org/) ## Features If you use TypeScript, you can specify a type for some classes in the driver. All classes that accept a type parameter in the driver have the default type`Document`. The `Document` interface has the following definition: `| interface Document { |\n| -------------------- |\n| [key: string]: any;  |\n| }                    | ` All object types extend the `Document` interface. For more information on object types, see the[TypeScript handbook.](https://www.typescriptlang.org/docs/handbook/2/objects.html) ### Type Parameters that Extend Document The following classes accept all types that extend the `Document` interface: * [Collection](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html)\n* [ChangeStream](https://mongodb.github.io/node-mongodb-native/5.1/classes/ChangeStream.html) You can pass a type parameter that extends the `Document` interface like this: ``` 1 interface Pet { 2   name: string; 3   age: number; 4 } 5 6 const database = client.db(\"<your database>\"); 7 const collection = database.collection<Pet>(\"<your collection>\"); \n``` ## Important ### Keys Not in Type Parameter Receive any Type Keys not listed in your specified type parameter receive the `any` type. The following code snippet demonstrates this behavior: ``` 1 interface User { 2   email: string; 3 } 4 5 const database = client.db(\"<your database>\"); 6 const myColl = db.collection<User>(\"<your collection>\"); 7 myColl.find({ age: \"Accepts any type!\" }); \n``` ### Type Parameters of Any Type The following classes accept all type parameters: * [FindCursor](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html)\n* [AggregationCursor](https://mongodb.github.io/node-mongodb-native/5.1/classes/AggregationCursor.html) You can find a code snippet that shows how to specify a type for the `FindCursor`class in the[Find Multiple Documents Usage Example.](https://mongodb.com/docs/drivers/node/current/usage-examples/find/#std-label-node-driver-find-usage-example-code-snippet) ### Type Safety and Dot Notation Starting in version 5.0, by default, the Node.js driver does not provide type safety for operations that search on fields expressed in **dot notation**. Dot notation is a syntax you can use to navigate nested JSON objects. When you construct a filter to pass to a query, the driver will not raise a type error even if you specify an incorrectly typed value for a field expressed in dot notation.\n\n ``` interface ClassificationPet {   name: string;   age: number;   classification: { genus: \"Canis\" | \"Felis\"; color: string }; } \n``` The driver does not raise a type error for the following code sample, even though the value of `classification.color` is a boolean instead of a string: ``` await myColl.findOneAndDelete({ \"classification.color\": false }); \n``` You can enable type-checking by constructing filters as `StrictFilter` or`StrictUpdateFilter` types. ## Warning The `StrictFilter` and `StrictUpdateFilter` types are experimental and may show type errors in valid queries where there should be none. In the following code sample, the filter is assigned a`StrictFilter` type. Given this filter type, the Node.js driver reports a type error because the value of `classification.color` is a boolean instead of a string. ``` const filterPredicate: StrictFilter<ClassificationPet> = { \"classification.color\": false }; await myColl.findOneAndDelete(filterPredicate); \n``` The following example assigns a `StrictUpdateFilter` type to an update filter. The Node.js driver reports a type error because the value of`classification.color` is a boolean instead of a string. ``` const updateFilter: StrictUpdateFilter<ClassificationPet> = { $set: { \"classification.color\": false } } await pets.updateOne({}, updateFilter); \n``` #### Referencing Keys that Incorporate Variables If you need to query a collection or perform another operation with a key that incorporates variables, you must use an `as const`assertion when specifying the key. This mechanism allows your code to compile successfully as long as the input types are correct. The following code snippet defines the `ClassificationPet` interface and the `Mealtime` interface. `ClassificationPet` includes a`mealtimes` field that contains an array of `Mealtime` interfaces, each of which includes a `time` field: ``` interface ClassificationPet {   name: string;   mealtimes: Mealtime[]; } interface Mealtime{   time: string;   amount: number; } \n``` The following code snippet performs a find-and-update operation on a collection of `ClassificationPet` documents. The operation updates the nested `time` field of the `Mealtime` instance at index`1`. The index position is specified by the variable `mealCounter`: ``` const mealCounter = 1; await myColl.findOneAndUpdate(   { name: \"Lassie\" },   { $set: { [`mealtimes.${mealCounter}.time` as const]: '4:00 PM' } }, ); \n``` To learn more about dot notation, see[Dot Notation](https://www.mongodb.com/docs/manual/core/document/#dot-notation)in the MongoDB manual. To learn more about the limitations of dot notation in the Node.js driver, see the[Recursive Types and Dot Notation](#std-label-node-driver-recursive-types-dot-notation)section. ## Working with the \\_id Field MongoDB does not recommend specifying the `_id` as a part of your model. Omitting the `_id` field makes the model more generic and reusable and more accurately models the data important to an application. The Node driver’s TypeScript integration takes care of adding the `_id` field to the return types for relevant methods. If you need to work with the `_id` field in your models, see the below sections for information on write and read operations. ### Insert Operations and the \\_id Field How you specify the `_id` field in type parameters passed to your`Collection` instance affects the behavior of insert operations. The following table describes how different`_id` field specifications affect insert operations:\n\n If you must specify the `_id` field as required in the type you define to represent documents in your collection but you do not want to specify values for the`_id` field in insert operations, use the `OptionalId` helper type when you create your collection. The `OptionalId` type accepts a type parameter as an argument and returns that type with an optional `_id` field. The following code snippet defines the `IdPet` interface, which includes a type for the `_id` field: ``` interface IdPet {   _id: ObjectId;   name: string;   age: number; } \n``` The following code uses the preceding interface along with the`OptionalId` type to insert a document without specifying a value for the`_id` field: ``` const database = client.db(\"<your database>\"); const collection = db.collection<OptionalId<IdPet>>(\"<your collection>\"); myColl.insertOne({   name: \"Spot\",   age: 2 }); \n``` To learn more about the `_id` field, see[The \\_id Field](https://www.mongodb.com/docs/manual/core/document/#the-%5Fid-field) in the MongoDB manual. To learn more about the types, interfaces, and classes discussed in this section, see the following resources: * [OptionalId](https://mongodb.github.io/node-mongodb-native/5.1/modules.html#OptionalId) API documentation\n* [PkFactory](https://mongodb.github.io/node-mongodb-native/5.1/interfaces/PkFactory.html) API documentation\n* [ObjectId](https://github.com/mongodb/js-bson/blob/master/src/objectid.ts) source code ### Find Methods and the \\_id Field The `find` and `findOne` methods of the `Collection` class include the `_id` field in their return type. If the type parameter you passed to your `Collection` instance includes the`_id` field, the type of the `_id` field in the values returned from the find methods is the same as the type of the `_id`field in your type parameter. If the type parameter you passed to your `Collection` instance does not include the `_id`field, the driver gives the `_id` field in the values returned from the find methods the type `ObjectId`. The following code uses the [Pet](#std-label-mongodb-node-typescript-pet-interface) interface to return a document with an `_id` of type `ObjectId`: ``` const database = client.db(\"<your database>\"); const collection = db.collection<Pet>(\"<your collection>\"); const document = await myColl.findOne({   name: \"Spot\", }); const id : ObjectId = document._id; \n``` The following code uses the `IdNumberPet` interface to return a document with an `_id` field of type `number`: ``` interface IdNumberPet {   _id: number;   name: string;   age: number; } const database = client.db(\"<your database>\"); const collection = db.collection<IdNumberPet>(\"<your collection>\"); const document = await myColl.findOne({   name: \"Spot\", }); const id : number = document._id; \n``` ## Important ### Projection If you specify a [projection](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/#std-label-mongodb-node-projection) in a find method, you should pass a type parameter to your find method that reflects the structure of your projected documents. Without a type parameter, TypeScript cannot check at compile time that you are using your projected documents safely. To show this behavior, the following code snippet passes type checking but raises an error at runtime: ``` const doc = await myColl.findOne(   {},   { projection: { _id: 0, name: 1 } } ); console.log(doc._id.generationTime); \n``` To catch this error at compile time, pass a type parameter that does not include the `_id` field to your find method: ``` interface ProjectedDocument {    name: string } const doc = await myColl.findOne<ProjectedDocument>(   {},   { projection: { _id: 0, name: 1 } } );\n\n console.log(doc._id.generationTime); \n``` To view a runnable TypeScript example that includes a find method applying a projection, see the[Find a Document](https://mongodb.com/docs/drivers/node/current/usage-examples/findOne/#std-label-node-driver-findone-usage-example-code-snippet) page. To learn more about the classes and methods discussed in this section, see the following API documentation: * [Collection](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html)\n* [find](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#find)\n* [findOne](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#findOne) ## Known Limitations Learn about the following TypeScript specific limitations of the Node.js driver: * [No type safety for dot notation references to nested instances of recursive types](#std-label-node-driver-recursive-types-dot-notation)\n* [Depth limitations on type safety for mutually recursive types](#std-label-node-driver-limitations-mutual-recursion) ### Recursive Types and Dot Notation The Node.js driver cannot provide type safety within nested instances of**recursive types** referenced through dot notation. A recursive type is a type that references itself. You can update the [Pet](#std-label-mongodb-node-typescript-pet-interface) interface to be recursive by allowing a pet to have its own pet. The following is the recursive `Pet` interface: ``` interface RecursivePet {    pet?: RecursivePet;    name: string;    age: number; } \n``` ## Note ### Depth Limit The Node.js driver does not traverse nested recursive types when type checking dot notation keys to avoid hitting TypeScript's recursive depth limit. The following code snippet references a nested instance of the[RecursivePet](#std-label-node-driver-limitations-recursive-pet) interface with an incorrect type using dot notation, but the TypeScript compiler does not raise a type error: ``` database    .collection<RecursivePet>(\"<your collection>\")    .findOne({ \"pet.age\": \"Spot\" }); \n``` The following code snippet references a top-level instance of the`RecursivePet` interface with an incorrect type and raises a type error: ``` database    .collection<RecursivePet>(\"<your collection>\")    .findOne({ pet: \"Spot\" }); \n``` The error raised by the preceding code snippet is as follows: ``` index.ts(19,59): error TS2769: No overload matches this call. The last overload gave the following error. Type 'string' is not assignable to type 'Condition<Pet>'. \n``` If you must have type safety within nested instances of recursive types, you must write your query or update without dot notation. To learn more about dot notation, see[Dot Notation](https://www.mongodb.com/docs/manual/core/document/#dot-notation)in the MongoDB manual. ### Mutual Recursion A **mutually recursive** type exists when two types contain a property that is of the other's type. You can update the [Pet](#std-label-mongodb-node-typescript-pet-interface)interface to be mutually recursive by allowing a pet to have a handler, and defining a handler to have a pet. The following examples reference the mutually recursive `Pet` and `Handler` interfaces: ``` interface Pet {    handler?: Handler;    name: string;    age: number; } interface Handler {    pet: Pet;    name: string; } \n``` The Node.js driver provides type safety for mutually recursive types referenced through dot notation up to a depth of eight. The following code snippet assigns a `string` to a `number` and raises a type error because the referenced property is at a depth of four: ``` database    .collection<Pet>(\"<your collection>\")    .findOne({'handler.pet.handler.pet.age': \"four\"}); \n``` The error raised by the preceding code snippet is as follows: ``` index.ts(19,59): error TS2769: No overload matches this call. The last overload gave the following error.\n\n \n``` At a depth greater than or equal to eight, TypeScript compiles your code but no longer type checks it. The following code assigns a `string` to a `number`property but does not cause a compilation error because the referenced property is at a depth of 10: ``` database    .collection<Pet>(\"<your collection>\")    .findOne({'handler.pet.handler.pet.handler.pet.handler.pet.handler.pet.age': \"four\"}); \n``` ← [Time Series](https://mongodb.com/docs/drivers/node/current/fundamentals/time-series/ \"Previous Section\")[UTF-8 Validation](https://mongodb.com/docs/drivers/node/current/fundamentals/utf8-validation/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/collations/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Collations On this page * [Overview](#overview)\n* [Usage](#usage)\n* [Collation Parameters](#collation-parameters)\n* [Collation Examples](#collation-examples)\n* [Set a Default Collation on a Collection](#set-a-default-collation-on-a-collection)\n* [Assign a Collation to an Index](#assign-a-collation-to-an-index)\n* [Collation Query Examples](#collation-query-examples) _Collations are available in MongoDB 3.4 and later._ ## Overview This guide shows you how to use **collations**, a set of sorting rules, to run operations using string ordering for specific languages and locales (a community or region that shares common language idioms). MongoDB sorts strings using _binary collation_ by default. This collation method uses the [ASCII standard](https://en.wikipedia.org/wiki/ASCII)character values to compare and order strings. Languages and locales have specific character ordering conventions that differ from the ASCII standard. For example, in Canadian French, the right-most accented character determines the ordering for strings when the other characters are the same. Consider the following French words: **cote**, **coté**, **côte**, and **côté**. MongoDB sorts them in the following order using the default binary collation: `| cote |\n| ---- |\n| coté |\n| côte |\n| côté | ` MongoDB sorts them in the following order using the Canadian French collation: ``` cote côte coté côté \n``` ## Usage You can specify a collation when you create a new collection or new index. You can also specify a collation for [CRUD operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/)and aggregations. When you create a new collection with a collation, you define the default collation for any of the [operations that support collation](https://www.mongodb.com/docs/manual/reference/collation/#operations-that-support-collation) called on that collection. You can override the collation for an operation by specifying a different one. ## Note Currently, you cannot create a collation on an existing collection. To use collations with an existing collection, create an index with the collation and specify the same collation in your operations on it. When you create an index with a collation, you specify the sort order for operations that use that index. To use the collation in the index, you must provide a matching collation in the operation, and the operation must use the index. While most index types support collation, the following types support only binary comparison: * [text](https://www.mongodb.com/docs/manual/reference/method/db.collection.createIndex/#options-for-text-indexes)\n* [2d](https://www.mongodb.com/docs/manual/reference/method/db.collection.createIndex/#options-for-2dsphere-indexes)\n* [geoHaystack](https://www.mongodb.com/docs/manual/reference/method/db.collection.createIndex/#options-for-geohaystack-indexes) ### Collation Parameters The collation object contains the following parameters: ```javascript collation: {   locale: <string>,   caseLevel: <bool>,   caseFirst: <string>,   strength: <int>,   numericOrdering: <bool>,   alternate: <string>,   maxVariable: <string>,   backwards: <bool> } \n``` You must specify the `locale` field in the collation; all other fields are optional. For a complete list of supported locales and the default values for the `locale` fields, see [Supported Languages and Locales](https://www.mongodb.com/docs/manual/reference/collation-locales-defaults/#supported-languages-and-locales). For descriptions of each field, see the [Collation Document MongoDB manual entry.](https://www.mongodb.com/docs/manual/reference/collation/#collation-document) ## Collation Examples ### Set a Default Collation on a Collection\n\n ```javascript // Create the collection with a collation db.createCollection(\"souvenirs\", {   collation: { locale: \"fr_CA\" }, }); \n``` Any of the operations that support collations automatically apply the collation defined on the collection. The query below searches the `souvenirs`collection and applies the \"`fr_CA`\" locale collation: ```javascript myColl.find({type: \"photograph\"}); \n``` You can specify a different collation as a parameter in an operation that supports collations. The following query specifies the \"`is`\" Iceland locale and `caseFirst` optional parameter with the value \"`upper`\": ```javascript  myColl.find({type: \"photograph\"},    { collation: { locale: \"is\", caseFirst: \"upper\" } }  ); \n``` ### Assign a Collation to an Index In the following example, we create a new index on the `title` field of a collection with a collation set to the \"`en_US`\" locale. ```javascript myColl.createIndex(   { 'title' : 1 },   { 'collation' : { 'locale' : 'en_US' } }); \n``` The following query uses the index we created: ```javascript myColl.find({\"year\": 1980}, {\"collation\" : {\"locale\" : \"en_US\" }})   .sort({\"title\": -1}); \n``` The following queries **do not** use the index that we created. The first query does not include a collation and the second contains a different strength value than the collation on the index. ```javascript // no collation specified myColl.find({\"year\": 1980})   .sort({\"title\": -1}); // collation differs from the one on the index myColl.find({\"year\": 1980}, {\"collation\" : {\"locale\" : \"en_US\", \"strength\": 2 }})   .sort({\"title\": -1}); \n``` ### Collation Query Examples Operations that read, update, and delete documents from a collection can use collations. This section includes examples of a selection of these. See the MongoDB manual for a full list of [operations that support collation.](https://www.mongodb.com/docs/manual/reference/collation/#operations-that-support-collation) #### find() and sort() Example The following example calls both `find()` and `sort()` on a collection that uses the default binary collation. We use the German collation by setting the value of the `locale` parameter to `de`. ```javascript myColl.find({ city: \"New York\" }, { collation: { locale: \"de\" } })   .sort({ name: 1 }); \n``` #### findOneAndUpdate() Example The following example calls the `findOneAndUpdate()` operation on a collection that uses the default binary collation. The collection contains the following documents: ``` { \"_id\" : 1, \"first_name\" : \"Hans\" } { \"_id\" : 2, \"first_name\" : \"Gunter\" } { \"_id\" : 3, \"first_name\" : \"Günter\" } { \"_id\" : 4, \"first_name\" : \"Jürgen\" } \n``` Consider the following `findOneAndUpdate()` operation on this collection which **does not** specify a collation: ```javascript myColl.findOneAndUpdate(   { first_name : { $lt: \"Gunter\" } },   { $set: { verified: true } } ); \n``` Since \"Gunter\" is the first sorted result when using a binary collation, none of the documents come lexically before and match the `$lt` comparison operator in the query document. As a result, the operation does not update any documents. Consider the same operation with a collation specified with the locale set to`de@collation=phonebook`. This locale specifies the `collation=phonebook`option which contains rules for prioritizing proper nouns, identified by capitalization of the first letter. The `de@collation=phonebook` locale and option sorts characters with umlauts before the same characters without umlauts. ```javascript myColl.findOneAndUpdate(   { first_name: { $lt: \"Gunter\" } },   { $set: { verified: true } },   { collation: { locale: \"de@collation=phonebook\" } }, ); \n```\n\n ``` { lastErrorObject: { updatedExisting: true, n: 1 },   value: { _id: 3, first_name: 'Günter' },   ok: 1 } \n``` #### findOneAndDelete() Example The following example calls the `findOneAndDelete()` operation on a collection that uses the default binary collation and contains the following documents: ``` { \"_id\" : 1, \"a\" : \"16\" } { \"_id\" : 2, \"a\" : \"84\" } { \"_id\" : 3, \"a\" : \"179\" } \n``` In this example, we set the `numericOrdering` collation parameter to `true`to sort numeric strings based on their numerical order instead of their lexical order. ```javascript myColl.findOneAndDelete(   { a: { $gt: \"100\" } },   { collation: { locale: \"en\", numericOrdering: true } }, ); \n``` After you run the operation above, the collection contains the following documents: ``` { \"_id\" : 1, \"a\" : \"16\" } { \"_id\" : 2, \"a\" : \"84\" } \n``` If you perform the same operation without collation on the original collection of three documents, it matches documents based on the lexical value of the strings (\"`16`\", \"`84`\", and \"`179`\"), and deletes the first document it finds that matches the query criteria. ```javascript await myColl.findOneAndDelete({ a: { $gt: \"100\" } }); \n``` Since all the documents contain lexical values in the `a` field that match the criteria (greater than the lexical value of \"`100`\"), the operation removes the first result. After you run the operation above, the collection contains the following documents: ``` { \"_id\" : 2, \"a\" : \"84\" } { \"_id\" : 3, \"a\" : \"179\" } \n``` #### Aggregation Example To use collation with the [aggregate](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#aggregate)operation, pass the collation document in the options field, after the array of pipeline stages. The following example shows an aggregation pipeline on a collection that uses the default binary collation. The aggregation groups the `first_name` field, counts the total number of results in each group, and sorts the results by the German phonebook (`de@collation=phonebook` locale) order. ## Note You can specify only one collation on an aggregation. ```javascript myColl.aggregate(   [     { $group: { \"_id\": \"$first_name\", \"nameCount\": { \"$sum\": 1 } } },     { $sort: { \"_id\": 1 } },   ],   { collation: { locale: \"de@collation=phonebook\" } }, ); \n``` ← [Indexes](https://mongodb.com/docs/drivers/node/current/fundamentals/indexes/ \"Previous Section\")[Logging](https://mongodb.com/docs/drivers/node/current/fundamentals/logging/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/connection/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Connection On this page * [Overview](#overview) ## Overview Learn how to configure your application's connection to a MongoDB deployment using the Node.js driver. In the following sections, you will learn: * [How to Connect to MongoDB](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connect/#std-label-node-connect-to-mongodb)\n* [The Available Connection Options](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/#std-label-node-connection-options)\n* [How to Enable Network Compression](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/network-compression/#std-label-node-network-compression)\n* [How to Connect to MongoDB Atlas from AWS Lambda](https://www.mongodb.com/docs/atlas/manage-connections-aws-lambda/) For information about authenticating to MongoDB, see [Authentication](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/#std-label-node-authentication-mechanisms) and[Enterprise Authentication Mechanisms.](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/enterprise-mechanisms/#std-label-node-enterprise-authentication-mechanisms) ← [Fundamentals](https://mongodb.com/docs/drivers/node/current/fundamentals/ \"Previous Section\")[Connection Guide](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connect/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/time-series/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Time Series On this page * [Overview](#overview)\n* [Create a Time Series Collection](#create-a-time-series-collection)\n* [Query a Time Series Collection](#query-a-time-series-collection) ## Overview In this guide, you can learn about time series collections in the MongoDB Node.js driver. ## Create a Time Series Collection We recommend that you create a time series collection using the MongoDB Shell (`mongosh`). For detailed instructions on creating a time series collection using the MongoDB Shell, see our[MongoDB Manual entry on time series collections.](https://www.mongodb.com/docs/manual/core/timeseries-collections/#create-a-time-series-collection) ## Query a Time Series Collection Since you query a time series collection in the same way you query other collection types in MongoDB, the Node.js driver has no features specifically for querying time series data. For more information on querying data in the MongoDB Node.js driver, see the following resources: * [Guide On Read Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/#std-label-nodejs-driver-retrieve-data-overview)\n* [Guide On Aggregation](https://mongodb.com/docs/drivers/node/current/fundamentals/aggregation/#std-label-nodejs-aggregation-overview) ## Note ### Window Functions MongoDB version 5.0 introduces window functions into the MongoDB aggregation pipeline. You can use window functions to perform operations on a contiguous span of time series data. For more information, see[the reference documentation for the $setWindowFields aggregation stage.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/setWindowFields/#-setwindowfields--aggregation-) ← [GridFS](https://mongodb.com/docs/drivers/node/current/fundamentals/gridfs/ \"Previous Section\")[TypeScript](https://mongodb.com/docs/drivers/node/current/fundamentals/typescript/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/transactions/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Transactions On this page * [Overview](#overview)\n* [Transaction APIs](#transaction-apis)\n* [Core API](#core-api)\n* [Transaction Settings](#transaction-settings)\n* [Examples](#examples)\n* [Sample Data](#sample-data)\n* [Core API Implementation](#core-api-implementation)\n* [Payment Transaction Result](#payment-transaction-result) ## Overview Read this guide to learn how to perform **transactions** in MongoDB using the Node.js driver. A transaction is a unit of work, composed of a series of operations that you want either to succeed together, or fail together when one or more of the operations fail. This behavior is called **atomicity**. Atomicity is a property in which transactions composed of one or more operations occur all at once, such that no other client can observe them as separate operations, and that it leaves no changes if one of the operations fails. Since all write operations on a single document in MongoDB are atomic, you may benefit most from transactions when you must make an atomic change that modifies multiple documents, which is called a multi-document transaction. Similar to write operations on a single document, multi-document transactions are **ACID compliant**, which means MongoDB guarantees the data involved in your transaction operations remains consistent, even if it encounters unexpected errors. Learn more from this MongoDB article on[ACID transactions.](https://www.mongodb.com/basics/acid-transactions) You can use the driver to perform multi-document transactions. ## Note To run multi-document transactions, you must use MongoDB version 4.0 or later. For a detailed list of limitations, see the [Transactions and Operations](https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations) section in the server manual. In MongoDB, multi-document transactions run within a **client session**. A client session is a grouping of related read or write operations that you want to ensure run sequentially. When combined with majority read and write concerns, the driver can guarantee causal consistency between the operations. See the server manual guide on[Client Sessions and Causal Consistency Guarantees](https://www.mongodb.com/docs/manual/core/read-isolation-consistency-recency/#std-label-sessions)for more information. Learn more about how to use the driver to run multi-document transactions on MongoDB in the following sections of this guide: * [Transaction APIs](#std-label-nodejs-transaction-apis)\n* [Transaction Settings](#std-label-nodejs-transaction-settings)\n* [Core API Examples](#std-label-nodejs-transaction-examples) ## Transaction APIs Use the **Core API** to implement a transaction with the driver. To use the Core API, you declare the start and commit points of the transaction. ### Core API The Core API features methods to start, cancel, or commit a transaction. When you commit the transaction, you send a request to the server to make the changes from your operations atomically. When using this API, you must handle certain transaction errors returned by the server manually. See[TransientTransactionError](https://www.mongodb.com/docs/manual/core/transactions-in-applications/#std-label-transient-transaction-error)and[UnknownTransactionCommitResult](https://www.mongodb.com/docs/manual/core/transactions-in-applications/#-unknowntransactioncommitresult-)for more information on these errors. To start, cancel, or commit your transaction, you can call the corresponding method on the `Session` object: * `startTransaction()`\n* `commitTransaction()`\n* `abortTransaction()` See the [Core API example](#std-label-nodejs-transaction-core-api-example) for a sample transaction implementation. ## Transaction Settings When you instantiate a transaction, you can specify the following options to set the default behavior for that transaction:\n\n If you do not provide values, the driver uses the client settings. You can specify the transaction options in the Core API using code that resembles the following: `| const transactionOptions = {                  |\n| --------------------------------------------- |\n| readPreference: 'primary',                    |\n| readConcern: { level: 'local' },              |\n| writeConcern: { w: 'majority' },              |\n| maxCommitTimeMS: 1000                         |\n| };                                            |\n| session.startTransaction(transactionOptions); | ` ## Examples Consider a scenario in which a customer purchases items from your online store. To record the purchase, your application needs to update information related to inventory, the customer's orders, and register the order details. Suppose you organize the data updates as follows: | Collection | Operation | Description of the Change                             |\n| ---------- | --------- | ----------------------------------------------------- |\n| orders     | insert    | Record the purchase information                       |\n| customers  | update    | Append the order id to associate it with the customer |\n| inventory  | update    | Subtract quantity of ordered items                    | A purchase can fail several ways such as if there's insufficient quantity of the item in inventory, if the order couldn't be completed, or if your payment system is offline. If the payment fails, you can use a transaction to make sure that you avoid exposing any partial updates that might cause data consistency issues for other operations that depend on that data. ### Sample Data The code examples require the following sample data in the `testdb`database to run the multi-document payment transaction: * A document in the `customers` collection that describes a customer and their orders.\n* Documents in the `inventory` collection that each track quantity and description of an item. The document in the `customers` collection in this example contains the following: ``` { _id: 98765, orders: [] } \n``` The documents in the `inventory` collection in this example contain the following: ``` [  { name: \"sunblock\", sku: 5432, qty: 85 },  { name: \"beach towel\", sku: 7865, qty: 41 } ] \n``` The code examples also perform operations on the `orders` collection, but do not require any prior sample documents. The code examples use the `cart` and `payment` variables to represent a sample list of items purchased and the order payment details as follows: ```javascript const cart = [   { name: 'sunblock', sku: 5432, qty: 1, price: 5.19 },   { name: 'beach towel', sku: 7865, qty: 2, price: 15.99 } ]; const payment = { customer: 98765, total: 37.17 }; \n``` ## Important The examples in the following sections require that you create the collections outside of the transaction or that you are using MongoDB 4.4 or later. For more information on creating collections inside a transaction, see the[Create Collections and Indexes in a Transaction](https://www.mongodb.com/docs/manual/core/transactions/#std-label-transactions-create-collections-indexes)server guide. ### Core API Implementation The code example in this section demonstrates how you can use the Core API to run the multi-document payment transaction in a session. This function shows how you can perform the following: 1. Start a session\n2. Start a transaction, specifying transaction options\n3. Perform data operations in the same session\n4. Commit a transaction, or cancel it if the driver encounters an error\n5. End a session ```javascript 1 async function placeOrder(client, cart, payment) { 2   const transactionOptions = { 3\n\n 4     writeConcern: { w: 'majority' }, 5     readPreference: 'primary' 6   }; 7 8   const session = client.startSession(); 9   try { 10     session.startTransaction(transactionOptions); 11 12     const ordersCollection = client.db('testdb').collection('orders'); 13     const orderResult = await ordersCollection.insertOne( 14       { 15         customer: payment.customer, 16         items: cart, 17         total: payment.total, 18       }, 19       { session } 20     ); 21 22     const inventoryCollection = client.db('testdb').collection('inventory'); 23     for (let i=0; i<cart.length; i++) { 24       const item = cart[i]; 25 26       // Cancel the transaction when you have insufficient inventory 27       const checkInventory = await inventoryCollection.findOne( 28         { 29           sku: item.sku, 30           qty: { $gte: item.qty } 31         }, 32         { session } 33       ) 34       if (checkInventory === null) { 35         throw new Error('Insufficient quantity or SKU not found.'); 36       } 37 38       await inventoryCollection.updateOne( 39         { sku: item.sku }, 40         { $inc: { 'qty': -item.qty }}, 41         { session } 42       ); 43     } 44 45     const customerCollection = client.db('testdb').collection('customers'); 46     await customerCollection.updateOne( 47       { _id: payment.customer }, 48       { $push:  { orders: orderResult.insertedId }}, 49       { session } 50     ); 51     await session.commitTransaction(); 52     console.log('Transaction successfully committed.'); 53 54   } catch (error) { 55     if (error instanceof MongoError && error.hasErrorLabel('UnknownTransactionCommitResult')) { 56       // add your logic to retry or handle the error 57     } 58     else if (error instanceof MongoError && error.hasErrorLabel('TransientTransactionError')) { 59       // add your logic to retry or handle the error 60     } else { 61       console.log('An error occured in the transaction, performing a data rollback:' + error); 62     } 63     await session.abortTransaction(); 64   } finally { 65     await session.endSession(); 66   } 67 } \n``` Note that you must pass the session object to each CRUD operation that you want to run on that session. The code and comments in the `catch` block demonstrate how you can identify the server transaction errors and where you can place your logic to handle them. Make sure to include the `MongoError` type from the driver in your code as shown in the following sample import statement: ```javascript const { MongoError, MongoClient } = require('mongodb'); \n``` See the [Payment Transaction Result](#std-label-nodejs-transaction-example-payment-result)section to see what your collections should contain after you run the transaction. ### Payment Transaction Result If your application completes the payment transaction, your database should contain all the updates, and if an exception interrupted your transaction, none of the changes should exist in your database. The `customers` collection should contain the customer document with an order id appended to the orders field: ``` {   \"_id\": 98765,   \"orders\": [     \"61dc...\"   ] } \n``` The `inventory` collection should contain updated quantities for the items \"sunblock\" and \"beach towel\": ``` [   {     \"_id\": ...,     \"name\": \"sunblock\",\n\n     \"qty\": 84   },   {     \"_id\": ...,     \"name\": \"beach towel\",     \"sku\": 7865,     \"qty\": 39   } ] \n``` The `orders` collection should contain the order and payment information: ``` [   {     \"_id\": \"...\",     \"customer\": 98765,     \"items\": [       {         \"name\": \"sunblock\",         \"sku\": 5432,         \"qty\": 1,         \"price\": 5.19       },       {         \"name\": \"beach towel\",         \"sku\": 7865,         \"qty\": 2,         \"price\": 15.99       }     ],     \"total\": 37.17   } ] \n``` ← [Aggregation](https://mongodb.com/docs/drivers/node/current/fundamentals/aggregation/ \"Previous Section\")[Indexes](https://mongodb.com/docs/drivers/node/current/fundamentals/indexes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/authentication/enterprise-mechanisms/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Enterprise Authentication Mechanisms On this page * [Kerberos (GSSAPI/SSPI)](#kerberos--gssapi-sspi-)\n* [LDAP (PLAIN)](#ldap--plain-) In this guide, you can find sample code for connection to MongoDB with each authentication mechanism available in the MongoDB Enterprise Edition:`Kerberos (GSSAPI/SSPI)` and `LDAP (PLAIN)`. ## `Kerberos (GSSAPI/SSPI)` ## Note The Node.js driver supports Kerberos on UNIX using the MIT Kerberos library and on Windows using the SSPI API. The `GSSAPI` authentication mechanism uses your user principal to authenticate to a Kerberos service. You can specify this authentication mechanism by setting the following parameters of the[connection string:](https://www.mongodb.com/docs/manual/reference/connection-string/) * Set the `authMechanism` parameter to `GSSAPI`\n* Set the `SERVICE_NAME` value in the `authMechanismProperties`parameter if using a value other than `mongodb`\n* Specify a `SERVICE_REALM` value in the `authMechanismProperties`parameter if a custom service realm is required. ## Important The `gssapiServiceName` parameter is deprecated and may be removed in future versions of the driver. Use`authMechanismProperties=SERVICE_NAME:<your service name>` in the connection URI instead. See the[authMechanismProperties](https://www.mongodb.com/docs/manual/reference/connection-string/#urioption.authMechanismProperties)parameter documentation for more information. The following code sample authenticates to Kerberos for UNIX using `GSSAPI`. ## Important Always **URI encode** the principal using the `encodeURIComponent` method to ensure it is correctly parsed.\n\n  `` ## Note The method refers to the `GSSAPI` authentication mechanism instead of `Kerberos` because the driver authenticates via[GSSAPI RFC-4652](https://tools.ietf.org/html/rfc4752) the SASL mechanism. ## `LDAP (PLAIN)` The `PLAIN` authentication mechanism uses your username and password to authenticate to a Lightweight Directory Access Protocol (LDAP) server. You can specify this authentication mechanism by setting the `authMechanism`parameter to `PLAIN` and including your LDAP username and password in the[connection string](https://www.mongodb.com/docs/manual/reference/connection-string/) as shown in the following sample code. ```js const { MongoClient } = require(\"mongodb\"); // specify the placeholder values for your environment in the following lines const clusterUrl = \"<MongoDB cluster URL>\"; const ldapUsername = \"<LDAP username>\"; const ldapPassword = \"<LDAP password>\"; const authMechanism = \"PLAIN\"; // Connection URI const uri = `mongodb+srv://${ldapUsername}:${ldapPassword}@${clusterUrl}/?authMechanism=${authMechanism}`; const client = new MongoClient(uri); // Function to connect to the server async function run() {   try {     // Establish and verify connection     await client.db(\"admin\").command({ ping: 1 });     console.log(\"Connected successfully to server\");   } finally {     // Ensures that the client will close when you finish/error     await client.close();   } } run().catch(console.dir); \n``` ## Note The authentication mechanism is named `PLAIN` instead of `LDAP` since it authenticates using the [PLAIN Simple Authentication and Security Layer (SASL) defined in RFC-4616](https://tools.ietf.org/html/rfc4616). ← [Authentication Mechanisms](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/mechanisms/ \"Previous Section\")[CRUD Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/connection/connect/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Connection Guide On this page * [Connection URI](#connection-uri)\n* [Other Ways to Connect to MongoDB](#other-ways-to-connect-to-mongodb)\n* [Connect to a MongoDB Server on Your Local Machine](#connect-to-a-mongodb-server-on-your-local-machine)\n* [Connect to a Replica Set](#connect-to-a-replica-set)\n* [Direct Connection](#direct-connection) This guide shows you how to connect to a MongoDB instance or replica set using the Node.js driver. ## Connection URI The **connection URI** is the set of instructions that the driver uses to connect to a MongoDB deployment. It instructs the driver on how it should connect to MongoDB and how it should behave while connected. The following example shows each part of the connection URI: ![Each part of the connection string](https://mongodb.com/docs/drivers/node/current/includes/figures/connection-string-parts.png) In this example, we use `mongodb` for the protocol, which specifies the [Standard Connection String Format.](https://www.mongodb.com/docs/manual/reference/connection-string/#std-label-connections-standard-connection-string-format) If your instance or deployment has a DNS SRV record, you can use the[DNS Seed List Connection Format](https://www.mongodb.com/docs/manual/reference/connection-string/#dns-seed-list-connection-format) for your connection string. This format offers more flexibility of deployment and the ability to change the servers in rotation without reconfiguring clients. ## Note To learn how to retrieve your connection string in Atlas, see the[Atlas driver connection guide.](https://www.mongodb.com/docs/atlas/driver-connection/) The next part of the connection string contains your username and password if you are using password-based authentication. Replace the value of `user`with your username and `pass` with your password. If you are using an authentication mechanism that does not require a username and password, omit this part of the connection URI. The next part of the connection string specifies the hostname or IP address and port of your MongoDB instance. In the example above, we use `sample.host`as the hostname and `27017` as the port. Replace these values to point to your MongoDB instance. The last part of the connection string contains connection and authentication options as parameters. In the example above, we set two connection options:`maxPoolSize=20` and `w=majority`. For more information on connection options, skip to the [Connection Options](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/#std-label-node-connection-options) section. The code below shows how you can use a connection URI in a client to connect to MongoDB.\n\n ` ## Other Ways to Connect to MongoDB If you are connecting to a single MongoDB server instance or replica set that is not hosted on Atlas, see the following sections to find out how to connect. ### Connect to a MongoDB Server on Your Local Machine If you need to run a MongoDB server on your local machine for development purposes instead of using an Atlas cluster, you need to complete the following: 1. Download the [Community](https://www.mongodb.com/try/download/community)or [Enterprise](https://www.mongodb.com/try/download/enterprise) version of MongoDB Server.\n2. [Install and configure](https://www.mongodb.com/docs/manual/installation/) MongoDB Server.\n3. Start the server. ## Important Always secure your MongoDB server from malicious attacks. See our[Security Checklist](https://www.mongodb.com/docs/manual/administration/security-checklist/) for a list of security recommendations. After you successfully start your MongoDB server, specify your connection string in your driver connection code. If your MongoDB Server is running locally, you can use the following connection string: ``` mongodb://localhost:<port> \n``` In this connection string, `<port>` is the port number on which you configured your server to listen for incoming connections. If you need to specify a different hostname or IP address, see our Server Manual entry on [Connection Strings.](https://www.mongodb.com/docs/manual/reference/connection-string/) To test whether you can connect to your server, replace the connection string in the [Connect to MongoDB](#std-label-connect-sample-node-driver) code example and run it. ### Connect to a Replica Set A MongoDB replica set deployment is a group of connected instances that store the same set of data. This configuration of instances provides data redundancy and high data availability. To connect to a replica set deployment, specify the hostname and port numbers of each instance, separated by a comma, and the replica set name as the value of the `replicaSet` parameter in the connection string. ``` mongodb://host1:27017,host2:27017,host3:27017/?replicaSet=myRs \n``` When making a connection, the driver takes the following actions by default: * Discovers all replica set members when given the address of any one member.\n* Dispatches operations to the appropriate member, such as write against the **primary**. ## Tip ### Specify all hosts To ensure connectivity if one host is unavailable, provide the full list of hosts when connecting to a replica set. ### Direct Connection To force your operations to run on the host specified in your connection URI, you can specify the `directConnection` connection option. If you specify this option, you must use the standard connection URI format. The driver does not accept the DNS seedlist connection format (SRV) when you specify this option. When you specify `directConnection` and connect to a secondary member of the replica set, your write operations fail because the client isn't connected to the primary member. To perform read operations, you must enable secondary reads. See the [read preference options](https://www.mongodb.com/docs/manual/reference/connection-string/#read-preference-options)for more information. ← [Connection](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/ \"Previous Section\")[Connection Options](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/connection/network-compression/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Network Compression You can enable a driver option to compress messages, which reduces the amount of data passed over the network between MongoDB and your application. The driver supports the following compression algorithms: 1. [Snappy](https://google.github.io/snappy/): available in MongoDB 3.6 and later.\n2. [Zlib](https://zlib.net/): available in MongoDB 3.6 and later.\n3. [Zstandard](https://github.com/facebook/zstd/): available in MongoDB 4.2 and later. If you specify multiple compression algorithms, the driver selects the first one in the list supported by your MongoDB instance. ## Note When using the Snappy or Zstandard compression algorithm, you must[add explicit dependencies.](#std-label-compression-dependencies) ## Specify Compression Algorithms You can enable compression for the connection to your MongoDB instance by specifying the algorithms in one of two ways: 1. Adding the parameter to your connection string.\n2. Specifying the `compressors` option in your `MongoClientOptions`. Specify compression algorithms using the following strings: * \"snappy\" for [Snappy](https://google.github.io/snappy/) compression\n* \"zlib\" for [Zlib](https://zlib.net/) compression\n* \"zstd\" for [Zstandard](https://github.com/facebook/zstd/) compression ## Compression Algorithm Dependencies To add the Snappy compression algorithm to your application, run the following code: `| npm install --save snappy |\n| ------------------------- | ` To add the Zstandard compression algorithm to your application, run the following code: ```javascript npm install --save @mongodb-js/zstd \n``` ← [Connection Options](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/ \"Previous Section\")[Stable API](https://mongodb.com/docs/drivers/node/current/fundamentals/stable-api/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/monitoring/command-monitoring/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Command Monitoring On this page * [Overview](#overview)\n* [Event Subscription Example](#event-subscription-example)\n* [Event Descriptions](#event-descriptions)\n* [Example Event Documents](#example-event-documents) ## Overview This guide shows you how to monitor the success or failure of commands sent by the driver to your MongoDB deployment. Read this guide if you need to record command status in your application or want to explore the information provided in these events. ## Event Subscription Example You can access one or more command monitoring events using the driver by subscribing to them in your application. The following example demonstrates connecting to a replica set and subscribing to one of the command monitoring events created by the MongoDB deployment:\n\n  `` ## Note Command monitoring is disabled by default. To enable command monitoring, pass the `monitorCommands` option as `true` to your `MongoClient` constructor. ## Event Descriptions You can subscribe to any of the following command monitoring events: | Event Name       | Description                        |\n| ---------------- | ---------------------------------- |\n| commandStarted   | Created when a command is started. |\n| commandSucceeded | Created when a command succeeded.  |\n| commandFailed    | Created when a command failed.     | ## Example Event Documents The following sections show sample output for each type of command monitoring event. ### commandStarted ```javascript CommandStartedEvent {   requestId: 1534,   databaseName: \"app\",   commandName: \"find\",   address: 'localhost:27017',   connectionId: 812613,   command: {     find: { firstName: \"Jane\", lastName: \"Doe\" }   } } \n``` ### commandSucceeded ```javascript CommandSucceededEvent {   requestId: 1534,   commandName: \"find\",   address: 'localhost:27017',   connectionId: 812613,   duration: 1586380205,   reply: {     cursor: {       firstBatch: [         {           _id: ObjectId(\"5e8e2ca217b5324fa9847435\"),           firstName: \"Jane\",           lastName: \"Doe\"         }       ],       _id: 0,       ns: \"app.users\"     },     ok: 1,     operationTime: 1586380205   } } \n``` ### commandFailed ```javascript CommandFailedEvent {   requestId: 1534,   commandName: \"find\",   address: 'localhost:27017',   connectionId: 812613,   failure: Error(\"something failed\"),   duration: 1586380205 } \n``` ← [Cluster Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/cluster-monitoring/ \"Previous Section\")[Connection Pool Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/connection-monitoring/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/connection/connection-options/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Connection Options This section explains the MongoDB connection and authentication options supported by the driver. You can pass the connection options as parameters of the connection URI to specify the behavior of the client.\n\n ← [Connection Guide](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/connect/ \"Previous Section\")[Network Compression](https://mongodb.com/docs/drivers/node/current/fundamentals/connection/network-compression/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/monitoring/cluster-monitoring/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Cluster Monitoring On this page * [Overview](#overview)\n* [Event Subscription Example](#event-subscription-example)\n* [Event Descriptions](#event-descriptions)\n* [Example Event Documents](#example-event-documents)\n* [serverDescriptionChanged](#serverdescriptionchanged)\n* [serverHeartbeatStarted](#serverheartbeatstarted)\n* [serverHeartbeatSucceeded](#serverheartbeatsucceeded)\n* [serverHeartbeatFailed](#serverheartbeatfailed)\n* [serverOpening](#serveropening)\n* [serverClosed](#serverclosed)\n* [topologyOpening](#topologyopening)\n* [topologyClosed](#topologyclosed)\n* [topologyDescriptionChanged](#topologydescriptionchanged) ## Overview This guide shows you how to monitor topology events in a MongoDB instance, replica set, or sharded cluster. The driver creates topology events, also known as Server Discovery and Monitoring (SDAM) events, when there is a change in the state of the instance or cluster that you connected to. For example, the driver creates an event when you establish a new connection or if the cluster elects a new primary. Read this guide if you need to record topology changes in your application or want to explore the information provided in these events. ## Event Subscription Example You can access one or more SDAM events using the driver by subscribing to them in your application. The following example demonstrates connecting to a replica set and subscribing to one of the SDAM events created by the MongoDB deployment:\n\n  `` ## Event Descriptions You can subscribe to any of the following SDAM events: | Event Name                 | Description                                                                                                  |\n| -------------------------- | ------------------------------------------------------------------------------------------------------------ |\n| serverOpening              | Created when a connection to an instance opens.                                                              |\n| serverClosed               | Created when a connection to an instance closes.                                                             |\n| serverDescriptionChanged   | Created when an instance state changes (such as from secondary to primary).                                  |\n| topologyOpening            | Created prior to attempting a connection to an instance.                                                     |\n| topologyClosed             | Created after all instance connections in the topology close.                                                |\n| topologyDescriptionChanged | Created when the topology changes, such as an election of a new primary or a **mongos** proxy disconnecting. |\n| serverHeartbeatStarted     | Created prior to issuing a hello command to a MongoDB instance.                                              |\n| serverHeartbeatSucceeded   | Created when the hello command returns successfully from a MongoDB instance.                                 |\n| serverHeartbeatFailed      | Created when a hello command issued to a specific MongoDB instance fails to return a successful response.    | ## Example Event Documents The following sections show sample output for each type of SDAM event. ### serverDescriptionChanged ```javascript ServerDescriptionChangedEvent {   topologyId: 0,   address: 'localhost:27017',   previousDescription: ServerDescription {     address: 'localhost:27017',     error: null,     roundTripTime: 0,     lastUpdateTime: 1571251089030,     lastWriteDate: null,     opTime: null,     type: 'Unknown',     minWireVersion: 0,     maxWireVersion: 0,     hosts: [],     passives: [],     arbiters: [],     tags: []   },   newDescription: ServerDescription {     address: 'localhost:27017',     error: null,     roundTripTime: 0,     lastUpdateTime: 1571251089051,     lastWriteDate: 2019-10-16T18:38:07.000Z,     opTime: { ts: Timestamp, t: 18 },\n\n     minWireVersion: 0,     maxWireVersion: 7,     maxBsonObjectSize: 16777216,     maxMessageSizeBytes: 48000000,     maxWriteBatchSize: 100000,     me: 'localhost:27017',     hosts: [ 'localhost:27017' ],     passives: [],     arbiters: [],     tags: [],     setName: 'rs',     setVersion: 1,     electionId: ObjectID,     primary: 'localhost:27017',     logicalSessionTimeoutMinutes: 30,     '$clusterTime': ClusterTime   } } \n``` The `type` field of the `ServerDescription` object in this event contains one of the following possible values:\n\n ### serverHeartbeatStarted ```javascript ServerHeartbeatStartedEvent {   connectionId: 'localhost:27017' } \n``` ### serverHeartbeatSucceeded ```javascript ServerHeartbeatSucceededEvent {   duration: 1.939997,   reply:{     hosts: [ 'localhost:27017' ],     setName: 'rs',     setVersion: 1,     isWritablePrimary: true,     secondary: false,     primary: 'localhost:27017',     me: 'localhost:27017',     electionId: ObjectID,     lastWrite: {       opTime: { ts: [Timestamp], t: 18 },       lastWriteDate: 2019-10-16T18:38:17.000Z,       majorityOpTime: { ts: [Timestamp], t: 18 },       majorityWriteDate: 2019-10-16T18:38:17.000Z     },     maxBsonObjectSize: 16777216,     maxMessageSizeBytes: 48000000,     maxWriteBatchSize: 100000,     localTime: 2019-10-16T18:38:19.589Z,     logicalSessionTimeoutMinutes: 30,     minWireVersion: 0,     maxWireVersion: 7,     readOnly: false,     ok: 1,     operationTime: Timestamp,     '$clusterTime': ClusterTime   },   connectionId: 'localhost:27017' } \n``` ### serverHeartbeatFailed ```javascript ServerHeartbeatFailed {   duration: 20,   failure: MongoError('some error'),   connectionId: 'localhost:27017' } \n``` ### serverOpening ```javascript ServerOpeningEvent {   topologyId: 0,   address: 'localhost:27017' } \n``` ### serverClosed ```javascript ServerClosedEvent {   topologyId: 0,   address: 'localhost:27017' } \n``` ### topologyOpening ```javascript TopologyOpeningEvent {   topologyId: 0 } \n``` ### topologyClosed ```javascript TopologyClosedEvent {   topologyId: 0 } \n``` ### topologyDescriptionChanged ```javascript TopologyDescriptionChangedEvent {   topologyId: 0,   previousDescription: TopologyDescription {     type: 'ReplicaSetNoPrimary',     setName: null,     maxSetVersion: null,     maxElectionId: null,     servers: Map {       'localhost:27017' => ServerDescription     },     stale: false,     compatible: true,     compatibilityError: null,     logicalSessionTimeoutMinutes: null,     heartbeatFrequencyMS: 10000,     localThresholdMS: 15,     options: Object,     error: undefined,     commonWireVersion: null   },   newDescription: TopologyDescription {     type: 'ReplicaSetWithPrimary',     setName: 'rs',     maxSetVersion: 1,     maxElectionId: null,     servers: Map {       'localhost:27017' => ServerDescription     },     stale: false,     compatible: true,     compatibilityError: null,     logicalSessionTimeoutMinutes: 30,     heartbeatFrequencyMS: 10000,     localThresholdMS: 15,     options: Object,     error: undefined,     commonWireVersion: 7   } } \n``` The `type` field of the `TopologyDescription` object in this event contains one of the following possible values:\n\n ← [Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/ \"Previous Section\")[Command Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/command-monitoring/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/authentication/mechanisms/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Authentication Mechanisms On this page * [DEFAULT](#default)\n* [SCRAM-SHA-256](#scram-sha-256)\n* [SCRAM-SHA-1](#scram-sha-1)\n* [MONGODB-CR](#mongodb-cr)\n* [MONGODB-AWS](#mongodb-aws)\n* [X.509](#x.509)\n* [TLS/SSL Options](#tls-ssl-options) In this guide, you can find sample code for connection to MongoDB with each authentication mechanism available in the MongoDB Community Edition:`DEFAULT`, `SCRAM-SHA-256`, `SCRAM-SHA-1`, `MONGODB-CR`,`MONGODB-AWS`, and `X.509`. ## `DEFAULT` The `DEFAULT` authentication mechanism is a fallback setting that instructs the driver to negotiate the first authentication mechanism supported by the server in the following order of preference: 1. `SCRAM-SHA-256`\n2. `SCRAM-SHA-1`\n3. `MONGODB-CR` If the `DEFAULT` option is specified, the driver first attempts to authenticate using `SCRAM-SHA-256`. If the version of the MongoDB instance does not support that mechanism, the driver attempts to authenticate using`SCRAM-SHA-1`. If the instance does not support that mechanism either, the driver attempts to authenticate using `MONGODB-CR`. You can specify this authentication mechanism by setting the `authMechanism`parameter to `DEFAULT` in the[connection string](https://www.mongodb.com/docs/manual/reference/connection-string/), or by omitting the parameter since it is the default value. Also include your username and password as shown in the code below. ## Important Always **URI encode** the username and password using the`encodeURIComponent` method to ensure they are correctly parsed.\n\n  `` For more information on the challenge-response (CR) and salted challenge-response authentication mechanisms (SCRAM) that MongoDB supports, see the [SCRAM](https://www.mongodb.com/docs/manual/core/security-scram/) section of the manual. ## `SCRAM-SHA-256` ## Note `SCRAM-SHA-256` is the default authentication method for MongoDB starting in version 4.0 `SCRAM-SHA-256` is a salted challenge-response authentication mechanism (SCRAM) that uses your username and password, encrypted with the `SHA-256`algorithm to authenticate your user. You can specify this authentication mechanism by setting the `authMechanism`to the value `SCRAM-SHA-256` in the[connection string](https://www.mongodb.com/docs/manual/reference/connection-string/) as shown in the following sample code. ## Important Always **URI encode** the username and password using the`encodeURIComponent` method to ensure they are correctly parsed. ```javascript const { MongoClient } = require(\"mongodb\"); // Replace the following with values for your environment. const username = encodeURIComponent(\"<username>\"); const password = encodeURIComponent(\"<password>\"); const clusterUrl = \"<MongoDB cluster url>\"; const authMechanism = \"SCRAM-SHA-256\"; // Replace the following with your MongoDB deployment's connection string. const uri =   `mongodb+srv://${username}:${password}@${clusterUrl}/?authMechanism=${authMechanism}`; // Create a new MongoClient const client = new MongoClient(uri); // Function to connect to the server async function run() {   try {     // Establish and verify connection     await client.db(\"admin\").command({ ping: 1 });     console.log(\"Connected successfully to server\");   } finally {     // Ensures that the client will close when you finish/error     await client.close();   } } run().catch(console.dir); \n``` ## `SCRAM-SHA-1` ## Note `SCRAM-SHA-1` is the default authentication method for MongoDB versions 3.0, 3.2, 3.4, and 3.6. `SCRAM-SHA-1` is a salted challenge-response mechanism (SCRAM) that uses your username and password, encrypted with the `SHA-1` algorithm to authenticate your user. You can specify this authentication mechanism by setting the `authMechanism`parameter to the value `SCRAM-SHA-1` in the[connection string](https://www.mongodb.com/docs/manual/reference/connection-string/) as shown in the following sample code. ## Important Always **URI encode** the username and password using the`encodeURIComponent` method to ensure they are correctly parsed. ```javascript const { MongoClient } = require(\"mongodb\"); // Replace the following with values for your environment. const username = encodeURIComponent(\"<username>\"); const password = encodeURIComponent(\"<password>\"); const clusterUrl = \"<MongoDB cluster url>\"; const authMechanism = \"SCRAM-SHA-1\"; // Replace the following with your MongoDB deployment's connection string. const uri =   `mongodb+srv://${username}:${password}@${clusterUrl}/?authMechanism=${authMechanism}`; // Create a new MongoClient const client = new MongoClient(uri); // Function to connect to the server async function run() {   try {     // Establish and verify connection     await client.db(\"admin\").command({ ping: 1 });     console.log(\"Connected successfully to server\");   } finally {     // Ensures that the client will close when you finish/error     await client.close();   } } run().catch(console.dir); \n``` ## `MONGODB-CR` ## Warning ### MONGODB-CR was deprecated starting in MongoDB 3.6, and is no longer supported as of MongoDB 4.0 `MONGODB-CR` is a challenge-response authentication mechanism that uses your username and password to authenticate your user.\n\n ## Important Always **URI encode** the username and password using the`encodeURIComponent` method to ensure they are correctly parsed. ```javascript const { MongoClient } = require(\"mongodb\"); // Replace the following with values for your environment. const username = encodeURIComponent(\"<username>\"); const password = encodeURIComponent(\"<password>\"); const clusterUrl = \"<MongoDB cluster url>\"; // Replace the following with your MongoDB deployment's connection string. const uri =   `mongodb+srv://${username}:${password}@${clusterUrl}/?authMechanism=${authMechanism}&tls=true&tlsCertificateKeyFile=${clientPEMFile}`; // Create a new MongoClient const client = new MongoClient(uri); // Function to connect to the server async function run() {   try {     // Establish and verify connection     await client.db(\"admin\").command({ ping: 1 });     console.log(\"Connected successfully to server\");   } finally {     // Ensures that the client will close when you finish/error     await client.close();   } } run().catch(console.dir); \n``` ## Important If you have [upgraded the authentication schema from MONGODB-CR to SCRAM](https://www.mongodb.com/docs/manual/release-notes/3.0-scram/), any `MONGODB-CR` user authentication requests fail. ## `MONGODB-AWS` ## Note The MONGODB-AWS authentication mechanism is only available in MongoDB versions 4.4 and later. The `MONGODB-AWS` authentication mechanism uses your Amazon Web Services Identity and Access Management (AWS IAM) credentials to authenticate your user. If you do not already have the [AWS signature library](https://www.npmjs.com/package/aws4), install it using the following`npm` command: ```bash npm install aws4 \n``` To connect to a MongoDB instance with `MONGODB-AWS` authentication enabled, specify the `MONGODB-AWS` authentication mechanism. The driver checks for your credentials in the following sources in order: 1. Connection string\n2. Environment variables\n3. AWS ECS endpoint specified in `AWS_CONTAINER_CREDENTIALS_RELATIVE_URI`\n4. AWS EC2 endpoint. For more information, see [IAM Roles for Tasks](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-iam-roles.html). ## Important The driver only reads the credentials from the first method that it detects in the order as given by the preceding list. For example, if you specify your AWS credentials in the connection string, the driver ignores any credentials that you specified in environment variables. ## `X.509` ## Note The X.509 authentication mechanism is only available in MongoDB versions 2.6 and later. The `X.509` authentication mechanism uses[TLS](https://en.wikipedia.org/wiki/Transport%5FLayer%5FSecurity) with X.509 certificates to authenticate your user, identified by the distinguished name (DN) of your client certificate. For more information on determining the _subject_ name from the X.509 certificate, see the MongoDB manual [X.509 tutorial.](https://www.mongodb.com/docs/manual/tutorial/configure-x509-client-authentication/#add-x-509-certificate-subject-as-a-user) You can specify this authentication mechanism by setting the following parameters of your[connection string:](https://www.mongodb.com/docs/manual/reference/connection-string/) * Set the `authMechanism` parameter to the value `MONGODB-X509`\n* Set the `tls` parameter to the value `true` Pass the location of your client certificate file as the value of`tlsCertificateKeyFile` as a parameter of the connection URI. ## Important Always **URI encode** the username and certificate file path using the`encodeURIComponent` method to ensure they are correctly parsed. ```javascript const { MongoClient } = require(\"mongodb\"); // Replace the following with values for your environment. const username = encodeURIComponent(\"<client certificate distinguished name>\"); const clusterUrl = \"<MongoDB cluster url>\";\n\n const authMechanism = \"MONGODB-X509\"; // Replace the following with your MongoDB deployment's connection string. const uri =   `mongodb+srv://${username}@${clusterUrl}/?authMechanism=${authMechanism}&tls=true&tlsCertificateKeyFile=${clientPEMFile}`; // Create a new MongoClient const client = new MongoClient(uri); // Function to connect to the server async function run() {   try {     // Establish and verify connection     await client.db(\"admin\").command({ ping: 1 });     console.log(\"Connected successfully to server\");   } finally {     // Ensures that the client will close when you finish/error     await client.close();   } } run().catch(console.dir); \n``` ### TLS/SSL Options The following table describes each of the TLS/SSL options that can be passed as a parameter in the connection URI.\n\n ← [Authentication](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/ \"Previous Section\")[Enterprise Authentication Mechanisms](https://mongodb.com/docs/drivers/node/current/fundamentals/authentication/enterprise-mechanisms/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/compound-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Compound Operations On this page * [Overview](#overview)\n* [Built-in Methods](#built-in-methods) ## Overview Most database requests only need to read data out of a database or write data into a database. However, client applications sometimes need to read and write data in a single interaction with the database. Compound operations combine read and write operations in a single atomic statement, so there's no chance of data changing in between a read and a subsequent write; in fact, both operations take place in the same line of code from the perspective of your client application. This property can be useful in cases where you want to write to a specific document, but you haven't found it yet. If you just perform a read for the document's `_id` and then try to alter the document you just found, it's possible that someone else can alter the document in between your read and write operations. This doesn't stop you from doing this work, but it can make error handling much more difficult. Compound operations help keep your logic straightforward by handling that logic entirely inside the database behind a layer of abstraction, so you don't have to worry about it. While you can accomplish this task using separate reads and writes, doing so requires the client application to gracefully handle potential errors at any stage of the process and in multiple potential error states. This increases the complexity of your code and can make your client application brittle and difficult to test. ## Built-in Methods There are three major compound operations: * [findOneAndDelete()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#findOneAndDelete)matches multiple documents to a supplied query and removes the first of those matched documents.\n* [findOneAndUpdate()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#findOneAndUpdate)matches multiple documents to a supplied query and updates the first of those matched documents using the provided update document.\n* [findOneAndReplace()](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#findOneAndReplace)matches multiple documents to a supplied query and replaces the first of those matched documents using the provided replacement document. All three methods accept an optional `options` object with configurable [sort](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/) and[projection](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/) options that work just like their read operation equivalents.`findOneAndUpdate()` and `findOneAndDelete()` allow the client to configure the `returnDocument` option, a boolean that determines if the method returns the pre-update or post-update version of the modified document. ← [Specify a Query](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/query-document/ \"Previous Section\")[Promises](https://mongodb.com/docs/drivers/node/current/fundamentals/promises/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/monitoring/connection-monitoring/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Connection Pool Monitoring On this page * [Overview](#overview)\n* [Event Subscription Example](#event-subscription-example)\n* [Event Descriptions](#event-descriptions)\n* [Example Event Documents](#example-event-documents)\n* [connectionPoolCreated](#connectionpoolcreated)\n* [connectionPoolReady](#connectionpoolready)\n* [connectionPoolClosed](#connectionpoolclosed)\n* [connectionCreated](#connectioncreated)\n* [connectionReady](#connectionready)\n* [connectionClosed](#connectionclosed)\n* [connectionCheckOutStarted](#connectioncheckoutstarted)\n* [connectionCheckOutFailed](#connectioncheckoutfailed)\n* [connectionCheckedOut](#connectioncheckedout)\n* [connectionCheckedIn](#connectioncheckedin)\n* [connectionPoolCleared](#connectionpoolcleared) ## Overview This guide shows you how to monitor the driver's **connection pool**. A connection pool is a set of open TCP connections your driver maintains with a MongoDB instance. Connection pools help reduce the number of network handshakes your application needs to perform and can help your application run faster. Read this guide if you need to record connection pool events in your application or want to explore the information provided in these events. ## Event Subscription Example You can access one or more connection pool events using the driver by subscribing to them in your application. The following example demonstrates connecting to a replica set and subscribing to one of the connection pool monitoring events created by the MongoDB deployment:\n\n ` ## Event Descriptions You can subscribe to any of the following connection pool monitoring events: | Event Name                | Description                                                                                               |\n| ------------------------- | --------------------------------------------------------------------------------------------------------- |\n| connectionPoolCreated     | Created when a connection pool is created.                                                                |\n| connectionPoolReady       | Created when a connection pool is ready.                                                                  |\n| connectionPoolClosed      | Created when a connection pool is closed, prior to server instance destruction.                           |\n| connectionCreated         | Created when a connection is created, but not necessarily when it is used for an operation.               |\n| connectionReady           | Created after a connection has successfully completed a handshake and is ready to be used for operations. |\n| connectionClosed          | Created when a connection is closed.                                                                      |\n| connectionCheckOutStarted | Created when an operation attempts to acquire a connection for execution.                                 |\n| connectionCheckOutFailed  | Created when an operation fails to acquire a connection for execution.                                    |\n| connectionCheckedOut      | Created when an operation successfully acquires a connection for execution.                               |\n| connectionCheckedIn       | Created when a connection is checked back into the pool after an operation is executed.                   |\n| connectionPoolCleared     | Created when a connection pool is cleared.                                                                | ## Example Event Documents The following sections show sample output for each type of connection pool monitoring event. ### connectionPoolCreated ``` ConnectionPoolCreatedEvent {   time: 2023-02-13T15:54:06.944Z,   address: '...',   options: {...} } \n``` ### connectionPoolReady ``` ConnectionPoolReadyEvent {   time: 2023-02-13T15:56:38.440Z,   address: '...' } \n``` ### connectionPoolClosed ``` ConnectionPoolClosedEvent {   time: 2023-02-13T15:56:38.440Z,   address: '...' } \n``` ### connectionCreated ``` ConnectionCreatedEvent {\n\n   address: '...',   connectionId: 1 } \n``` ### connectionReady ``` ConnectionReadyEvent {   time: 2023-02-13T15:56:38.291Z,   address: '...',   connectionId: 1 } \n``` ### connectionClosed ``` ConnectionClosedEvent {   time: 2023-02-13T15:56:38.439Z,   address: '...',   connectionId: 1,   reason: 'poolClosed',   serviceId: undefined } \n``` ### connectionCheckOutStarted ``` ConnectionCheckOutStartedEvent {   time: 2023-02-13T15:56:38.291Z,   address: '...', } \n``` ### connectionCheckOutFailed ``` ConnectionCheckOutFailedEvent {   time: 2023-02-13T15:56:38.291Z,   address: '...',   reason: ... } \n``` ### connectionCheckedOut ``` ConnectionCheckedOutEvent {   time: 2023-02-13T15:54:07.188Z,   address: '...',   connectionId: 1 } \n``` ### connectionCheckedIn ``` ConnectionCheckedInEvent {   time: 2023-02-13T15:54:07.189Z,   address: '...',   connectionId: 1 } \n``` ### connectionPoolCleared ``` ConnectionPoolClearedEvent {   time: 2023-02-13T15:56:38.439Z,   address: '...',   serviceId: undefined,   interruptInUseConnections: true, } \n``` ← [Command Monitoring](https://mongodb.com/docs/drivers/node/current/fundamentals/monitoring/command-monitoring/ \"Previous Section\")[GridFS](https://mongodb.com/docs/drivers/node/current/fundamentals/gridfs/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/query-document/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Specify a Query On this page * [Overview](#overview)\n* [Literal Value Queries](#literal-value-queries)\n* [Comparison Operators](#comparison-operators)\n* [Logical Operators](#logical-operators)\n* [Element Operators](#element-operators)\n* [Evaluation Operators](#evaluation-operators) ## Overview Most CRUD operations allow you to narrow the set of matched documents by specifying matching criteria in a **query document**. Query documents contain one or more query operators that apply to specific fields which determine which documents to include in the result set. In a query document, you can match fields against literal values, such as`{ title: 'The Room' }`, or you can compose[query operators](https://www.mongodb.com/docs/manual/reference/operator/query/) to express more complex matching criteria. In this guide, we cover the following categories of query operators in MongoDB and show examples on how to use them: * [Comparison Operators](https://www.mongodb.com/docs/manual/reference/operator/query-comparison/)\n* [Logical Operators](https://www.mongodb.com/docs/manual/reference/operator/query-logical/)\n* [Element Operators](https://www.mongodb.com/docs/manual/reference/operator/query-element/)\n* [Evaluation Operators](https://www.mongodb.com/docs/manual/reference/operator/query-evaluation/) To follow along with the examples in this guide, use the following code snippet to insert documents that describe fruits into the `myDB.fruits` collection: `| const myDB = client.db(\"myDB\");                                               |\n| ----------------------------------------------------------------------------- |\n| const myColl = myDB.collection(\"fruits\");                                     |\n| await myColl.insertMany([                                                     |\n| { \"_id\": 1, \"name\": \"apples\", \"qty\": 5, \"rating\": 3 },                        |\n| { \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1, \"microsieverts\": 0.1 }, |\n| { \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 },                       |\n| { \"_id\": 4, \"name\": \"avocados\", \"qty\": 3, \"rating\": 5 },                      |\n| ]);                                                                           | ` ## Note Your query operation may return a reference to a cursor that contains matching documents. To learn how to examine data stored in the cursor, see the[Cursor Fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/) ## Literal Value Queries\n\n ```javascript const query = { \"name\": \"apples\" }; const cursor = myColl.find(query); await cursor.forEach(console.dir); \n``` This code snippet returns the following results: ```javascript { \"_id\": 1, \"name\": \"apples\", \"qty\": 5, \"rating\": 3 } \n``` ## Note Literal value queries are equivalent to the `$eq` comparison operator. As a result, the following two queries are equivalent: ```javascript myColl.find({    rating: { $eq: 5 } }); \n``` ```javascript myColl.find({    rating: 5 }); \n``` ## Comparison Operators Comparison operators allow you to query for data based on comparisons with values in a collection. Common comparison operators include`$gt` for \"greater than\" comparisons, `$lt` for \"less than\" comparisons, and `$ne` for \"not equal to\" comparisons. The following operation uses the comparison operator `$gt` to search for documents with a quantity value greater than 5 and prints them out: ```javascript // $gt means \"greater than\" const query = { qty: { $gt : 5 } }; const cursor = myColl.find(query); await cursor.forEach(console.dir); \n``` This code snippet returns the following results: ```javascript { \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1 } { \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 } \n``` ## Logical Operators Logical operators allow you to query for data using logic applied to the results of field-level operators. For instance, you can use the `$or`method to query for documents that match either a `$gt` comparison operator or a literal value query. The following operation uses the logical operator `$not` to search for documents with a quantity value that is not greater than 5 and prints them out: ```javascript const query = { qty: { $not: { $gt: 5 }}}; const cursor = myColl.find(query); await cursor.forEach(console.dir); \n``` This code snippet returns the following results: ```javascript { \"_id\": 4, \"name\": \"avocados\", \"qty\": 3, \"rating\": 5 } { \"_id\": 1, \"name\": \"apples\", \"qty\": 5, \"rating\": 3 } \n``` ## Note Whenever a query document contains multiple elements, those elements are combined together with an implicit `$and` logical operator to figure out which documents match the query. As a result, the following two queries are equivalent: ```javascript myColl.find({   rating: { $eq: 5 },   qty: { $gt: 4 } }); \n``` ```javascript myColl.find({   $and: [      { rating: { $eq: 5 }},      { qty: { $gt: 4 }}   ] }); \n``` For more information on comparison operators, see the reference manual entry for [Comparison Query Operators.](https://www.mongodb.com/docs/manual/reference/operator/query-comparison/) ## Element Operators Element operators allow you to query based on the presence, absence, or type of a field. The following operation uses the element operator`$exists` to search for documents containing the `microsieverts`field: ```javascript const query = { microsieverts: { $exists: true } }; const cursor = myColl.find(query); await cursor.forEach(console.dir); \n``` This code snippet returns the following results: ```javascript { \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1, \"microsieverts\": 0.1 } \n``` For more information on this operator, see the reference manual entry for the [$exists operator.](https://www.mongodb.com/docs/manual/reference/operator/query/exists/) ## Evaluation Operators Evaluation operators allow you to execute higher level logic, like regex and text searches, when querying for documents in a collection. Common evaluation operators include `$regex` and `$text`. The following operation uses the evaluation operator `$mod` to search for documents with a quantity value that is divisible by 3 with a remainder of 0: ```javascript // $mod means \"modulo\" and returns the remainder after division\n\n const cursor = myColl.find(query); await cursor.forEach(console.dir); \n``` This code snippet returns the following results: ```javascript { \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 } { \"_id\": 4, \"name\": \"avocados\", \"qty\": 3, \"rating\": 5 } \n``` For more information on this operator, see the reference manual entry for the [$mod operator.](https://www.mongodb.com/docs/manual/reference/operator/query/mod/) ← [Insert or Update in a Single Operation](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/upsert/ \"Previous Section\")[Compound Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/compound-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Read Operations * [Retrieve Data](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/)\n* [Access Data From a Cursor](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/)\n* [Retrieve Distinct Values](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/distinct/)\n* [Sort Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/)\n* [Skip Returned Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/skip/)\n* [Limit the Number of Returned Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/limit/)\n* [Specify Which Fields to Return](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/)\n* [Search Geospatially](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/geo/)\n* [Search Text](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/text/) ← [CRUD Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/ \"Previous Section\")[Retrieve Data](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Write Operations * [Insert a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/insert/)\n* [Generate Custom Values for \\_id](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/pkFactory/)\n* [Delete a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/delete/)\n* [Change a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/change-a-document/)\n* [Update Arrays in a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/embedded-arrays/)\n* [Insert or Update in a Single Operation](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/upsert/) ← [Search Text](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/text/ \"Previous Section\")[Insert a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/insert/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/skip/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Skip Returned Results On this page * [Overview](#overview)\n* [Sample Documents](#sample-documents)\n* [Example](#example) ## Overview Use `skip` to omit documents from the beginning of the list of returned documents for a read operation. You can combine `skip` with[sort](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/) to omit the top (for descending order) or bottom (for ascending order) results for a given query. Since the [order of documents returned](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/#result-ordering) is not guaranteed in the absence of a sort, using `skip` without using `sort` omits arbitrary documents. If the value of `skip` exceeds the number of matched documents for a query, that query returns no documents. ### Sample Documents To follow along with the examples in this guide, use the following code snippet to insert documents that describe fruits into the`myDB.fruits` collection: `| const myDB = client.db(\"myDB\");                          |\n| -------------------------------------------------------- |\n| const myColl = myDB.collection(\"fruits\");                |\n| await myColl.insertMany([                                |\n| { \"_id\": 1, \"name\": \"apples\", \"qty\": 5, \"rating\": 3 },   |\n| { \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1 },  |\n| { \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 },  |\n| { \"_id\": 4, \"name\": \"avocados\", \"qty\": 3, \"rating\": 5 }, |\n| ]);                                                      | ` ## Note Your query operation may return a reference to a cursor that contains matching documents. To learn how to examine data stored in the cursor, see the[Cursor Fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/) ## Example In the following example, we query the collection with a filter that matches all the documents and pass options that specifies `sort` and`skip` commands as query options. The sort option specifies that fruit documents with higher ratings should be returned before ones with lower ratings. The skip option specifies that the first 2 documents should be omitted from the result: ```javascript // define an empty query document const query = {}; const options = {    // sort in descending (-1) order by rating    sort : { rating: -1 },    // omit the first two documents    skip : 2, } const cursor = myColl.find(query, options); await cursor.forEach(console.dir); \n``` Since we specified that the first `2` documents should be skipped, the third and fourth highest rating documents are printed by the code snippet above: ``` { \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 } { \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1 } \n``` The `sort` and `skip` options can also be specified as methods chained to the `find` method. The following two commands are equivalent: ```javascript myColl.find(query, { sort: { rating: -1}, skip: 2}); myColl.find(query).sort({rating: -1}).skip(2); \n``` ← [Sort Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/ \"Previous Section\")[Limit the Number of Returned Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/limit/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/limit/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Limit the Number of Returned Results On this page * [Overview](#overview)\n* [Sample Documents](#sample-documents)\n* [Limit](#limit)\n* [Skip](#skip) ## Overview Use `limit` to cap the number of documents that can be returned from a read operation. `limit` functions as a cap on the maximum number of documents that the operation can return, but the operation can return a smaller number of documents if there are not enough documents present to reach the limit. If `limit` is used with the[skip](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/skip/) method, the skip applies first and the limit only applies to the documents left over after the skip. ### Sample Documents To follow along with the examples in this guide, use the following code snippet to insert documents that describe books into the`myDB.books` collection: `| const myDB = client.db(\"myDB\");                                                         |\n| --------------------------------------------------------------------------------------- |\n| const myColl = myDB.collection(\"books\");                                                |\n| await myColl.insertMany([                                                               |\n| { \"_id\": 1, \"name\": \"The Brothers Karamazov\", \"author\": \"Dostoyevsky\", \"length\": 824 }, |\n| { \"_id\": 2, \"name\": \"Les Misérables\", \"author\": \"Hugo\", \"length\": 1462 },               |\n| { \"_id\": 3, \"name\": \"Atlas Shrugged\", \"author\": \"Rand\", \"length\": 1088 },               |\n| { \"_id\": 4, \"name\": \"Infinite Jest\", \"author\": \"Wallace\", \"length\": 1104 },             |\n| { \"_id\": 5, \"name\": \"Cryptonomicon\", \"author\": \"Stephenson\", \"length\": 918 },           |\n| { \"_id\": 6, \"name\": \"A Dance With Dragons\", \"author\": \"Tolkein\", \"length\": 1104 },      |\n| ]);                                                                                     | ` ## Note Your query operation may return a reference to a cursor that contains matching documents. To learn how to examine data stored in the cursor, see the[Cursor Fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/) ## Limit The following example queries the collection to return the top three longest books. It matches all the documents with the query, applies a `sort` on the `length` field to return books with longer lengths before books, and applies a `limit` to return only `3` results: ```javascript // define an empty query document const query = {}; // sort in descending (-1) order by length const sort = { length: -1 }; const limit = 3; const cursor = myColl.find(query).sort(sort).limit(limit); await cursor.forEach(console.dir); \n``` The code example above outputs the following three documents, sorted by length: ```\n\n { \"_id\": 6, \"title\": \"A Dance With Dragons\", \"author\": \"Martin\", \"length\": 1104 } { \"_id\": 4, \"title\": \"Infinite Jest\", \"author\": \"Wallace\", \"length\": 1104 } \n``` ## Note The order in which you call `limit` and `sort` does not matter because the driver reorders the calls to apply the sort first and the limit after it. The following two calls are equivalent: ```javascript myColl.find(query).sort({ length: -1 }).limit(3); myColl.find(query).limit(3).sort({ length: -1 }); \n``` You can also apply `sort` and `limit` by specifying them in an`options` object in your call to the `find()` method. The following two calls are equivalent: ```javascript myColl.find(query).sort({ length: -1 }).limit(3); myColl.find(query, { sort: { length: -1 }, limit: 3 }); \n``` For more information on the `options` settings for the `find()`method, see the[API documentation on find().](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#find) ## Skip To see the next three books in the results, append the `skip()` method, passing the number of documents to bypass as shown below: ```javascript // define an empty query document const query = {}; // sort in descending (-1) order by length const sort = { length: -1 }; const limit = 3; const skip = 3; const cursor = myColl.find(query).sort(sort).limit(limit).skip(skip); await cursor.forEach(console.dir); \n``` This operation returns the documents that describe the fourth through sixth books in order of longest-to-shortest length: ``` { \"_id\": 3, \"title\": \"Atlas Shrugged\", \"author\": \"Rand\", \"length\": 1088 } { \"_id\": 5, \"title\": \"Cryptonomicon\", \"author\": \"Stephenson\", \"length\": 918 } { \"_id\": 1, \"title\": \"The Brothers Karamazov\", \"author\": \"Dostoyevsky\", \"length\": 824 } \n``` You can combine skip and limit in this way to implement paging for your collection, returning only small \"slices\" of the collection at once. ← [Skip Returned Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/skip/ \"Previous Section\")[Specify Which Fields to Return](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Sort Results On this page * [Overview](#overview)\n* [Sample Documents](#sample-documents)\n* [Example](#example) ## Overview Use `sort` to change the order in which read operations return documents. `Sort` tells MongoDB to order returned documents by the values of one or more fields in a certain direction. To sort returned documents by a field in ascending (lowest first) order, use a value of`1`. To sort in descending (greatest first) order instead, use `-1`. If you do not specify a sort, MongoDB does not guarantee the order of query results. ### Sample Documents Follow the instructions in the examples below to insert data into the `myDB.books` collection and perform a sort on the results of a query. Consider a collection containing documents that describe books. To insert this data into a collection, run the following operation: `| const myDB = client.db(\"myDB\");                                                         |\n| --------------------------------------------------------------------------------------- |\n| const myColl = myDB.collection(\"books\");                                                |\n| await myColl.insertMany([                                                               |\n| { \"_id\": 1, \"name\": \"The Brothers Karamazov\", \"author\": \"Dostoyevsky\", \"length\": 824 }, |\n| { \"_id\": 2, \"name\": \"Les Misérables\", \"author\": \"Hugo\", \"length\": 1462 },               |\n| { \"_id\": 3, \"name\": \"Atlas Shrugged\", \"author\": \"Rand\", \"length\": 1088 },               |\n| { \"_id\": 4, \"name\": \"Infinite Jest\", \"author\": \"Wallace\", \"length\": 1104 },             |\n| { \"_id\": 5, \"name\": \"Cryptonomicon\", \"author\": \"Stephenson\", \"length\": 918 },           |\n| { \"_id\": 6, \"name\": \"A Dance with Dragons\", \"author\": \"Martin\", \"length\": 1104 },       |\n| ]);                                                                                     | ` ## Note Your query operation may return a reference to a cursor that contains matching documents. To learn how to examine data stored in the cursor, see the[Cursor Fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/) ## Example Pass the following sort document to a read operation to ensure that the operation returns books with longer lengths before books with shorter lengths: ```javascript // define an empty query document const query = {}; // sort in descending (-1) order by length const sort = { length: -1 }; const cursor = myColl.find(query).sort(sort); await cursor.forEach(console.dir); \n``` In this case, the number `-1` tells the read operation to sort the books in descending order by length. `find()` returns the following documents when this sort is used with an empty query: ``` { \"_id\": 2, \"title\": \"Les Misérables\", \"author\": \"Hugo\", \"length\": 1462 }\n\n { \"_id\": 6, \"title\": \"A Dance with Dragons\", \"author\": \"Martin\", \"length\": 1104 } { \"_id\": 3, \"title\": \"Atlas Shrugged\", \"author\": \"Rand\", \"length\": 1088 } { \"_id\": 5, \"title\": \"Cryptonomicon\", \"author\": \"Stephenson\", \"length\": 918 } { \"_id\": 1, \"title\": \"The Brothers Karamazov\", \"author\": \"Dostoyevsky\", \"length\": 824 } \n``` Sometimes, the order of two or more documents is ambiguous using a specified sort. In the above case, both \"A Dance with Dragons\" and \"Infinite Jest\" have `1104` pages, so the order in which they are returned is not guaranteed. To resolve ties in your sorted results in a repeatable way, add additional fields to the sort document: ```javascript // define an empty query document const query = {}; // sort in ascending (1) order by length const sort = { length: 1, author: 1 }; const cursor = myColl.find(query).sort(sort); await cursor.forEach(console.dir); \n``` With the addition of the `author` field to the sort document, the read operation sorts matching documents first by `length` and, in the event of a tie, then by `author`. Matched document fields are compared in the same order as fields are specified in the sort document. `find()`returns the following ordering of documents when this sort is used on the documents matching the query, sorting \"Martin\" before \"Wallace\" for the two books with the same length: ``` { \"_id\": 1, \"title\": \"The Brothers Karamazov\", \"author\": \"Dostoyevsky\", \"length\": 824 } { \"_id\": 5, \"title\": \"Cryptonomicon\", \"author\": \"Stephenson\", \"length\": 918 } { \"_id\": 3, \"title\": \"Atlas Shrugged\", \"author\": \"Rand\", \"length\": 1088 } { \"_id\": 6, \"title\": \"A Dance with Dragons\", \"author\": \"Martin\", \"length\": 1104 } { \"_id\": 4, \"title\": \"Infinite Jest\", \"author\": \"Wallace\", \"length\": 1104 } { \"_id\": 2, \"title\": \"Les Misérables\", \"author\": \"Hugo\", \"length\": 1462 } \n``` ← [Retrieve Distinct Values](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/distinct/ \"Previous Section\")[Skip Returned Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/skip/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Retrieve Data On this page * [Overview](#overview)\n* [Find](#find)\n* [Aggregate](#aggregate)\n* [Watch / Subscribe](#watch---subscribe) ## Overview You can use read operations to retrieve data from your MongoDB database. There are multiple types of read operations that access the data in different ways. If you want to request results based on a set of criteria from the existing set of data, you can use a find operation such as the`find()` or `findOne()` methods. You can also further specify the information you are requesting by including additional parameters or by chaining other methods such as: * [Sort Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/)\n* [Skip Returned Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/skip/)\n* [Limit the Number of Returned Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/limit/)\n* [Specify Which Fields to Return](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/) You can also use an aggregation operation to retrieve data. This type of operation allows you to apply an ordered pipeline of transformations to the matched data. If you want to monitor the database for incoming data that matches a set of criteria, you can use the watch operation to be notified in real-time when matching data is inserted. ## Note Your query operation may return a reference to a cursor that contains matching documents. To learn how to examine data stored in the cursor, see the[Cursor Fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/) ## Find The `find()` method is called on the `Collection` object that references the collection you want to query. The method accepts a query document that describes the documents you want to retrieve. For more information on how to specify your query document, see our guide on how to [Specify a Query.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/query-document/) If you resolve the `Promise` returned by `find()`, you receive a reference to a `Cursor` with which you can navigate matched documents. If you resolve the `Promise` returned by `findOne()`, you receive the matching document or `null` if there are no matches. ## Example A pizza restaurant wants to find all pizzas ordered by Lemony Snicket yesterday. They run the following `find()` query on the`orders` collection: `| const findResult = await orders.find({           |\n| ------------------------------------------------ |\n| name: \"Lemony Snicket\",                          |\n| date: {                                          |\n| $gte: new Date(new Date().setHours(00, 00, 00)), |\n| $lt: new Date(new Date().setHours(23, 59, 59)),  |\n| },                                               |\n| });                                              | ` Once the operation returns, the `findResult` variable references a`Cursor`. You can print the documents retrieved using the `forEach()`method as shown below: ```javascript await cursor.forEach(console.dir); \n``` The output might resemble the following: ```javascript [   { name: \"Lemony Snicket\", type: \"horseradish pizza\", qty: 1, status: \"delivered\", date: ... },   { name: \"Lemony Snicket\", type: \"coal-fired oven pizza\", qty: 3, status: \"canceled\", date: ...},   ... ]\n\n See the [find()](https://mongodb.com/docs/drivers/node/current/usage-examples/find/) and [findOne()](https://mongodb.com/docs/drivers/node/current/usage-examples/findOne/) for fully-runnable examples. ## Aggregate If you want to run a custom processing pipeline to retrieve data from your database, you can use the `aggregate()` method. This method accepts aggregation expressions to run in sequence. These expressions let you filter, group, and arrange the result data from a collection. ## Example A pizza restaurant wants to run a status report on-demand to summarize pizza orders over the past week. They run the following`aggregate()` query on the `orders` collection to fetch the totals for each distinct \"status\" field: ```javascript     const aggregateResult = await orders.aggregate([       {         $match: {           date: {             $gte: new Date(new Date().getTime() - 1000 * 3600 * 24 * 7),             $lt: new Date(),           },         },       },       {         $group: {           _id: \"$status\",           count: {             $sum: 1,           },         },       },     ]); \n``` Once the operation returns, the `aggregateResult` variable references a`Cursor`. You can print the documents retrieved using the `forEach()`method as shown below: ```javascript await cursor.forEach(console.dir); \n``` The output might resemble the following: ```javascript [   { _id: 'delivering', count: 5 },   { _id: 'delivered', count: 37 },   { _id: 'created', count: 9 } ] \n``` See the MongoDB server manual pages on [aggregation](https://www.mongodb.com/docs/manual/aggregation/)for more information on how to construct an aggregation pipeline. ## Watch / Subscribe You can use the `watch()` method to monitor a collection for changes to a collection that match certain criteria. These changes include inserted, updated, replaced, and deleted documents. You can pass this method a pipeline of aggregation comands that sequentially runs on the changed data whenever write operations are executed on the collection. ## Example A pizza restaurant wants to receive a notification whenever a new pizza order comes in. To accomplish this, they create an aggregation pipeline to filter on insert operations and return specific fields. They pass this pipeline to the `watch()` method called on the `orders`collection as shown below: ```javascript     const changeStream = orders.watch([       { $match: { operationType: \"insert\" } },       {         $project: {           \"fullDocument.name\": 1,           \"fullDocument.address\": 1,         },       },     ]);     changeStream.on(\"change\", change => {       const { name, address } = change.fullDocument;       console.log(`New order for ${name} at ${address}.`);     }); \n``` For a runnable example of the `watch()` method using the NodeJS driver, see the [change streams](https://mongodb.com/docs/drivers/node/current/usage-examples/changeStream/) usage example. ← [Read Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/ \"Previous Section\")[Access Data From a Cursor](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/text/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Search Text On this page * [Overview](#overview)\n* [Examples](#examples)\n* [Query for Words](#query-for-words)\n* [Query By Phrase](#query-by-phrase)\n* [Query with Negations](#query-with-negations)\n* [Sort by Relevance](#sort-by-relevance) ## Overview Text search, using the `$text` query operator, lets you search string type fields in your collection for words or phrases. This operator performs a logical `OR` on each term separated by a space in the search string. You can also specify additional options to the operator to handle case sensitivity, stop words, and word stemming (such as plural forms or other tenses) for a supported language. This is particularly useful for unstructured text such as transcripts, essays, or web pages. The `$text` query operator requires that you specify the search field in a **text index** on your collection. See the examples below for sample code for creating a text index and using the `$text` query operator. ## Note [Atlas Search](https://www.mongodb.com/docs/atlas/atlas-search/?tck=docs%5Fdriver%5Fnodejs) makes it easy to build fast, relevance-based search capabilities on top of your MongoDB data. Try it today on[MongoDB Atlas](https://www.mongodb.com/cloud/atlas?tck=docs%5Fdriver%5Fnodejs), our fully managed database as a service. ## Examples The following examples use the `movies` collection in the `sample_mflix`database. In order to enable text searches on the `title` field, create the **text index** using the following command: `| db.movies.createIndex({ title: \"text\" }); |\n| ----------------------------------------- | ` We use this text index for the examples, but you can create a compound text index that broadens your text queries to multiple fields as follows: ```javascript db.movies.createIndex({ title: \"text\", fullplot: \"text\" }); \n``` You can only create _one_ text index per collection. Every text search queries all the fields specified in that index for matches. See the MongoDB server manual for more information on creating[text indexes.](https://www.mongodb.com/docs/manual/core/index-text/) ### Query for Words This example queries for Star Trek movies by searching for titles containing the word \"trek\". If you want to query using multiple words, separate your words with spaces to query for documents that match any of the search terms (logical `OR`). ```javascript   const query = { $text: { $search: \"trek\" } };   // Return only the `title` of each matched document   const projection = {     _id: 0,     title: 1,   };   // find documents based on our query and projection   const cursor = movies.find(query).project(projection); \n``` This operation returns the following documents: ```javascript { title: 'Trek Nation' } { title: 'Star Trek' } { title: 'Star Trek Into Darkness' } { title: 'Star Trek: Nemesis' } { title: 'Star Trek: Insurrection' } { title: 'Star Trek: Generations' } { title: 'Star Trek: First Contact' } { title: 'Star Trek: The Motion Picture' } { title: 'Star Trek VI: The Undiscovered Country' } { title: 'Star Trek V: The Final Frontier' } { title: 'Star Trek IV: The Voyage Home' } { title: 'Star Trek III: The Search for Spock' } { title: 'Star Trek II: The Wrath of Khan' } \n``` Success! The query found every document in the `movies` collection with a title including the word \"trek\". Unfortunately, the search included one unintended item: \"Trek Nation,\" which is a movie about Star Trek and not part of the Star Trek movie series. To solve this, we can query with a more specific **phrase**. ### Query By Phrase To make your query more specific, try using the phrase \"star trek\" instead of just the word \"trek\". To search by phrase, surround your multi-word phrase with escaped quotes (`\\\"<term>\\\"`): ```javascript\n\n   // Return only the `title` of each matched document   const projection = {     _id: 0,     title: 1,   };   // find documents based on our query and projection   const cursor = movies.find(query).project(projection); \n``` Querying by the phrase \"star trek\" instead of just the term \"trek\" matches the following documents: ```javascript { title: 'Star Trek' } { title: 'Star Trek Into Darkness' } { title: 'Star Trek: Nemesis' } { title: 'Star Trek: Insurrection' } { title: 'Star Trek: Generations' } { title: 'Star Trek: First Contact' } { title: 'Star Trek: The Motion Picture' } { title: 'Star Trek VI: The Undiscovered Country' } { title: 'Star Trek V: The Final Frontier' } { title: 'Star Trek IV: The Voyage Home' } { title: 'Star Trek III: The Search for Spock' } { title: 'Star Trek II: The Wrath of Khan' } \n``` These results include all movies in the database that contain the phrase \"star trek\", which in this case results in only fictional Star Trek movies. Unfortunately, though, this query returned \"Star Trek Into Darkness\", a movie that was not part of the original series of movies. To resolve this issue, we can omit that document with a **negation**. ### Query with Negations To use a negated term, place a negative sign (`-`) in front of the term you would like to omit from the result set. The query operation omits any documents that contain this term from the search result. Since this query includes two distinct terms, separate them with a space. ```javascript   const query = { $text: { $search: \"\\\"star trek\\\"  -\\\"into darkness\\\"\" } };   // Include only the `title` field of each matched document   const projection = {     _id: 0,     title: 1,   };   // find documents based on our query and projection   const cursor = movies.find(query).project(projection); \n``` Querying with the negated term yields the following documents: ```javascript { title: 'Star Trek' } { title: 'Star Trek: Nemesis' } { title: 'Star Trek: Insurrection' } { title: 'Star Trek: Generations' } { title: 'Star Trek: First Contact' } { title: 'Star Trek: The Motion Picture' } { title: 'Star Trek VI: The Undiscovered Country' } { title: 'Star Trek V: The Final Frontier' } { title: 'Star Trek IV: The Voyage Home' } { title: 'Star Trek III: The Search for Spock' } { title: 'Star Trek II: The Wrath of Khan' } \n``` ## Note Your query operation may return a reference to a cursor that contains matching documents. To learn how to examine data stored in the cursor, see the[Cursor Fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/) ### Sort by Relevance Now that the result set reflects the desired results, you can use the text search `textScore`, accessed using the [$meta](https://www.mongodb.com/docs/manual/reference/operator/projection/meta/) operator in the query projection, to order the results by relevance: ```javascript   const query = { $text: { $search: \"\\\"star trek\\\"  -\\\"into darkness\\\"\" } };   // sort returned documents by descending text relevance score   const sort = { score: { $meta: \"textScore\" } };   // Include only the `title` and `score` fields in each returned document   const projection = {     _id: 0,     title: 1,     score: { $meta: \"textScore\" },   };   // find documents based on our query, sort, and projection   const cursor = movies     .find(query)     .sort(sort)     .project(projection); \n``` Querying in this way returns the following documents in the following order. In general, text relevance increases as a string matches more terms and decreases as the unmatched portion of the string lengthens. ```javascript { title: 'Star Trek', score: 1.5 } { title: 'Star Trek: Generations', score: 1.3333333333333333 } { title: 'Star Trek: Insurrection', score: 1.3333333333333333 }\n\n { title: 'Star Trek: The Motion Picture', score: 1.25 } { title: 'Star Trek: First Contact', score: 1.25 } { title: 'Star Trek II: The Wrath of Khan', score: 1.2 } { title: 'Star Trek III: The Search for Spock', score: 1.2 } { title: 'Star Trek IV: The Voyage Home', score: 1.2 } { title: 'Star Trek V: The Final Frontier', score: 1.2 } { title: 'Star Trek VI: The Undiscovered Country', score: 1.2 } \n``` For more information about the $text operator and its options, see the[manual entry.](https://www.mongodb.com/docs/manual/reference/operator/query/text/) ← [Search Geospatially](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/geo/ \"Previous Section\")[Write Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Access Data From a Cursor On this page * [Overview](#overview)\n* [Cursor Paradigms](#cursor-paradigms)\n* [For Each Functional Iteration](#for-each-functional-iteration)\n* [Return an Array of All Documents](#return-an-array-of-all-documents)\n* [Asynchronous Iteration](#asynchronous-iteration)\n* [Manual Iteration](#manual-iteration)\n* [Stream API](#stream-api)\n* [Event API](#event-api)\n* [Cursor Utility Methods](#cursor-utility-methods)\n* [Rewind](#rewind)\n* [Close](#close) ## Overview Read operations that return multiple documents do not immediately return all values matching the query. Because a query can potentially match very large sets of documents, these operations rely upon an object called a cursor. A cursor fetches documents in batches to reduce both memory consumption and network bandwidth usage. Cursors are highly configurable and offer multiple interaction paradigms for different use cases. The following functions directly return cursors: * `Collection.find()`\n* `Collection.aggregate()`\n* `Collection.listIndexes()`\n* `Db.aggregate()`\n* `Db.listCollections()` Other methods such as [Collection.findOne()](https://mongodb.com/docs/drivers/node/current/usage-examples/findOne/)and [Collection.watch()](https://mongodb.com/docs/drivers/node/current/usage-examples/changeStream/) use cursors internally, and return the results of the operations instead of a cursor. ## Cursor Paradigms You can work with cursors using a number of **cursor paradigms**. Most cursor paradigms allow you to access query results one document at a time, abstracting away network and caching logic. However, since use cases differ, other paradigms offer different access patterns, like pulling all matching documents into a collection in process memory. ## Warning Do not combine different cursor paradigms on a single cursor. Operations such as `hasNext()`, `forEach()`, and `toArray()`each predictably modify the original cursor. If you mix these calls on a single cursor, you may receive unexpected results. ## Warning Because asynchronous calls directly modify the cursor, executing asynchronous calls on a single cursor simultaneously can also cause undefined behaviour. Always wait for the previous asynchronous operation to complete before running another. ## Note When you reach the last result through iteration or through an at-once fetch, the cursor is exhausted which means it ceases to respond to methods that access the results. ### For Each Functional Iteration You can pass a function to the [forEach()](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html#forEach) method of any cursor to iterate through results in a functional style: `| const cursor = myColl.find({});                |\n| ---------------------------------------------- |\n| await cursor.forEach(doc => console.log(doc)); | ` ### Return an Array of All Documents For use cases that require all documents matched by a query to be held in memory at the same time, use [toArray()](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html#toArray). Note that large numbers of matched documents can cause performance issues or failures if the operation exceeds memory constraints. Consider using[forEach()](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html#forEach) to iterate through results unless you want to return all documents at once. ```javascript   const cursor = myColl.find({});   const allValues = await cursor.toArray(); \n``` ### Asynchronous Iteration Cursors implement the [AsyncIterator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of) interface, which allows you to use cursors in `for`...\\`\\`await\\`\\` loops: ```javascript   const cursor = myColl.find({});   console.log(\"async\");   for await (const doc of cursor) {\n\n   } \n``` ### Manual Iteration You can use the [hasNext()](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html#hasNext)method to check if a cursor can provide additional data, and then use the [next()](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html#next)method to retrieve the subsequent element of the cursor: ```javascript   const cursor = myColl.find({});   while (await cursor.hasNext()) {     console.log(await cursor.next());   } \n``` ### Stream API Cursors expose the `stream()` method to convert them to Node Readable Streams. These streams operate in **Object Mode**, which passes JavaScript objects rather than Buffers or Strings through the pipeline. ```javascript   const cursor = myColl.find({});   cursor.stream().on(\"data\", doc => console.log(doc)); \n``` ### Event API As Readable Streams, cursors also support the Event API's`close`, `data`, `end` and `readable` events: ```javascript   const cursor = myColl.find({});   // the \"data\" event is fired once per document   cursor.on(\"data\", data => console.log(data)); \n``` ## Cursor Utility Methods ### Rewind To reset a cursor to its initial position in the set of returned documents, use [rewind().](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html#rewind) ```javascript   const cursor = myColl.find({});   const firstResult = await cursor.toArray();   console.log(\"First count: \" + firstResult.length);   await cursor.rewind();   const secondResult = await cursor.toArray();   console.log(\"Second count: \" + secondResult.length); \n``` ### Close Cursors consume memory and network resources both in the client application and in the connected instance of MongoDB. Use[close()](https://mongodb.github.io/node-mongodb-native/5.1/classes/FindCursor.html#close)to free up a cursor's resources in both the client application and the MongoDB server: ```javascript   await cursor.close(); \n``` ← [Retrieve Data](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/ \"Previous Section\")[Retrieve Distinct Values](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/distinct/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Specify Which Fields to Return On this page * [Overview](#overview)\n* [Sample Documents](#sample-documents)\n* [Single Field](#single-field)\n* [Multiple Fields](#multiple-fields) ## Overview Use a projection to control which fields appear in the documents returned by read operations. Many requests only require certain fields, so projections can help you limit unnecessary network bandwidth usage. Projections work in two ways: * Explicitly include fields with a value of `1`. This has the side-effect of implicitly excluding all unspecified fields.\n* Implicitly exclude fields with a value of `0`. This has the side-effect of implicitly including all unspecified fields. These two methods of projection are mutually exclusive: if you explicitly include fields, you cannot explicitly exclude fields, and vice versa. ### Sample Documents To follow along with the examples in this guide, use the following code snippet to insert documents that describe fruits into the`myDB.fruits` collection: `| const myDB = client.db(\"myDB\");                          |\n| -------------------------------------------------------- |\n| const myColl = myDB.collection(\"fruits\");                |\n| await myColl.insertMany([                                |\n| { \"_id\": 1, \"name\": \"apples\", \"qty\": 5, \"rating\": 3 },   |\n| { \"_id\": 2, \"name\": \"bananas\", \"qty\": 7, \"rating\": 1 },  |\n| { \"_id\": 3, \"name\": \"oranges\", \"qty\": 6, \"rating\": 2 },  |\n| { \"_id\": 4, \"name\": \"avocados\", \"qty\": 3, \"rating\": 5 }, |\n| ]);                                                      | ` ## Note Your query operation may return a reference to a cursor that contains matching documents. To learn how to examine data stored in the cursor, see the[Cursor Fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/) ## Single Field In the following query, pass the projection to only return the `name`field of each document: ```javascript // return only* the name field const projection = { name: 1 }; const cursor = myColl.find().project(projection); await cursor.forEach(console.dir); \n``` The projection document specifies a value of `1` for `name` to indicate that the read operation result should _include_ the `name`field of each returned document. As a result, this projection implicitly excludes the `qty` and `rating` fields. Passing this projection to`find()` with an empty query document and no sort document yields the following results: ``` { \"_id\": 1, \"name\": \"apples\" } { \"_id\": 2, \"name\": \"bananas\" } { \"_id\": 3, \"name\": \"oranges\" } { \"_id\": 4, \"name\": \"avocados\" } \n``` Despite the fact that this projection only explicitly included the`name` field, the query returned the `_id` field as well! This happens because the `_id` field is a special case: it is always included in every query unless explicitly specified otherwise. That's because `_id` is a unique identifier for each document, a property that can be very useful when constructing queries. The `movies`collection is a good example of why this property is useful: because remakes and even separate works can sometimes reuse movie titles, you need a unique `_id` value to refer to any specific movie. `_id` is the only exception to the mutually exclusive include-exclude behavior in projections: you _can_ explicitly exclude `_id` even when explicitly including other fields if you do not want `_id` to be present in returned documents. ```javascript // return only the name field const projection = { _id: 0, name: 1 };\n\n await cursor.forEach(console.dir); \n``` The projection document specifies a value of `1` for `name` to indicate that the read operation result should _include_ the `name`field of each returned document. As a result, this projection implicitly excludes the `qty` and `rating` fields. Passing this projection to`find()` with an empty query document and no sort document yields the following results: ``` { \"name\": \"apples\" } { \"name\": \"bananas\" } { \"name\": \"oranges\" } { \"name\": \"avocados\" } \n``` ## Multiple Fields You can also specify multiple fields to include in your projection. Note: the order in which you specify the fields in the projection does not alter the order in which they are returned. ```javascript const projection = { _id: 0, rating: 1, name: 1 }; const cursor = myColl.find().project(projection); await cursor.forEach(console.dir); \n``` This example that identifies two fields to include in the projection yields the following results: ```   { \"name\": \"apples\", \"rating\": 3 }   { \"name\": \"bananas\", \"rating\": 1 }   { \"name\": \"oranges\", \"rating\": 2 }   { \"name\": \"avocados\", \"rating\": 5 } \n``` For additional projection examples, see the[MongoDB Manual page on Project Fields to Return from Query.](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/) ← [Limit the Number of Returned Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/limit/ \"Previous Section\")[Search Geospatially](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/geo/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/pkFactory/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Generate Custom Values for `_id` On this page * [Overview](#overview)\n* [Specify a Primary Key Factory](#specify-a-primary-key-factory)\n* [Additional Information](#additional-information) ## Overview In this guide, you can learn how to use the MongoDB Node.js driver to generate your own `_id` values using the **primary key factory**. The primary key factory allows you to create unique identifiers in your documents when you choose not to specify an `_id` during an[insert operation](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/insert/#std-label-node-fundamentals-insert-data). The default primary key factory generates `ObjectId` values. ## Note ### Upsert Operations The driver doesn't use the primary key factory for[upsert operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/upsert/#std-label-node-fundamentals-upsert) because it's unable to determine whether to apply the primary key factory. If you specified the primary key factory in an upsert operation and it performs an insert operation, the server autogenerates an`ObjectId` for that document. If you want to use your specified primary key factory, perform a[find operation](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/retrieve/#std-label-node-fundamentals-retrieve-data), then an[update](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/change-a-document/#std-label-node-fundamentals-change-a-document) or[insert](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/insert/#std-label-node-fundamentals-insert-data) operation. ## Specify a Primary Key Factory To specify a primary key factory, apply the `pkFactory` option to your`MongoClient` instance. The following code snippet applies the `pkFactory` option to generate `_id` values of type `uuid`: `| const { UUID } = require('bson');                     |\n| ----------------------------------------------------- |\n| ...                                                   |\n| const client = new MongoClient(uri, {                 |\n| pkFactory: { createPk: () =>  new UUID().toBinary() } |\n| });                                                   | ` ## Note ### Data Consistency If you insert a document with an `_id` field with a different type than the type specified by the primary key factory, then you will have inconsistent data. For example, if you run the following insert operation on a primary key factory that generates `uuid` types, your `_id` values will contain both the `uuid` and `string` types: ```javascript myColl.insertOne({ _id: \"user1388\", ... }); \n``` ## Additional Information To learn more about the types, interfaces, and classes discussed in this section, see the following resources:\n\n ← [Insert a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/insert/ \"Previous Section\")[Delete a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/geo/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Search Geospatially On this page * [Overview](#overview)\n* [Coordinates on an Earth-like Sphere](#coordinates-on-an-earth-like-sphere)\n* [Coordinates on a 2D Plane](#coordinates-on-a-2d-plane)\n* [Examples](#examples)\n* [Query by Proximity](#query-by-proximity)\n* [Query Within a Range](#query-within-a-range) ## Overview You can query data based on geographical location using geospatial query operators. You can format geospatial queries using one of the following coordinate systems: * [Coordinates on an Earth-like Sphere](#std-label-sphere)\n* [Coordinates on a 2D Plane](#std-label-plane) This section contains examples of geospatial queries using different query operators that you can run against your Atlas sample dataset. ### Coordinates on an Earth-like Sphere For geospatial queries using longitude and latitude coordinates on an Earth-like sphere, use the [GeoJSON](https://www.mongodb.com/docs/manual/geospatial-queries/#geojson-objects)query format. While GeoJSON has [multiple types](https://www.mongodb.com/docs/manual/reference/geojson/), all GeoJSON data types use some form of the following structure: `| <field> : {                |\n| -------------------------- |\n| type: <GeoJSON type>,      |\n| coordinates: [             |\n| [longitude_1, latitude_1], |\n| ...                        |\n| [longitude_n, latitude_n]  |\n| ]                          |\n| }                          | ` The object type determines the number of coordinates. For instance, a`Point` requires only one coordinate: a longitude and a latitude. A `Line` uses two coordinates: a longitude and a latitude for each end. A `Polygon` consists of a list of coordinates in which the first and last coordinate are the same, effectively closing the polygon. To learn more about the GeoJSON shapes you can use in MongoDB, consult the[GeoJSON manual entry.](https://www.mongodb.com/docs/manual/reference/geojson/) To enable querying GeoJSON data, you must add the field to a `2dsphere`index. The following snippet creates an index on the `location.geo` field in the `theaters` collection using the `createIndex()` method: ```javascript db.theaters.createIndex({location.geo: \"2dsphere\"}); \n``` ### Coordinates on a 2D Plane You can also express geospatial queries using `x` and `y` coordinates in a two-dimentional Euclidian plane. Until MongoDB, this was the only format compatible with geospatial queries, and are now referred to as \"legacy coordinate pairs\". Legacy coordinate pairs use the following structure: ```javascript <field> : [ x, y ] \n``` The field should contain an array of two values in which the first represents the `x` axis value and the second represents the `y` axis value. To enable querying using legacy coordinate pairs, create a `2d` index on the field on the collection. The following snippet creates an index on the`coordinates` field in the `shipwrecks` collection using the`createIndex()` method: ```javascript db.shipwrecks({coordinates: \"2d\"}); \n``` See the[MongoDB server manual page on legacy coordinate pairs](https://www.mongodb.com/docs/manual/geospatial-queries/#legacy-coordinate-pairs)for more information. ## Note\n\n ## Examples The following examples use the MongoDB Atlas sample dataset. You can learn how to set up your own free-tier Atlas cluster and how to load the sample dataset in our[quick start guide.](https://mongodb.com/docs/drivers/node/current/quick-start/) The examples use the `theaters` collection in the `sample_mflix` database from the sample dataset. The `theaters` collection contains a `2dsphere` index on the `location.geo` field. ### Query by Proximity The [$near](https://www.mongodb.com/docs/manual/reference/operator/query/near/#mongodb-query-op.-near)operator accepts a set of longitude-latitude coordinates and returns documents ordered from nearest to farthest. To limit the results to a maximum distance in meters, use the `$maxDistance` option. For a complete list of options, see the reference documentation for `$near`. The following example queries for theaters within `10,000` meters of`[ -73.9667, 40.78 ]`. ```javascript   const query = {     \"location.geo\": {       $near: {         $geometry: { type: \"Point\", coordinates: [-73.9667, 40.78] },         $maxDistance: 10000,       },     },   };   // find documents based on our query   const cursor = theaters.find(query); \n``` ### Query Within a Range The [$geoWithin](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) operator selects documents with geospatial data that exist within a specified shape. The following example searches for movie theaters in the New England area: ```javascript   const query = {     \"location.geo\": {       $geoWithin: {         $geometry: {           type: \"Polygon\",           coordinates: [             [               [-72, 40],               [-74, 41],               [-72, 39],               [-72, 40],             ],           ],         },       },     },   };   // find documents based on our query   const cursor = theaters.find(query); \n``` See the [MongoDB server manual page on geospatial query operators](https://www.mongodb.com/docs/manual/geospatial-queries/index.html)for more information on the operators you can use in your query. ← [Specify Which Fields to Return](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/project/ \"Previous Section\")[Search Text](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/text/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/change-a-document/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Change a Document On this page * [Overview](#overview)\n* [Update](#update)\n* [Replace](#replace) ## Overview You can change documents in a MongoDB collection using either **update**or **replace** operations. Update operations mutate specified fields in one or more documents and leave other fields and values unchanged. Replace operations remove all existing fields in one or more documents and substitute them with specified fields and values. ## Update To perform an update to one or more documents, create an **update document** that specifies the **update operator** (the type of update to perform) and the fields and values that describe the change. Update documents use the following format: `| {                    |\n| -------------------- |\n| <update operator>: { |\n| <field> : {          |\n| ...                  |\n| },                   |\n| <field> : {          |\n| }                    |\n| },                   |\n| <update operator>: { |\n| ...                  |\n| }                    |\n| }                    | ` The top level of an update document contains one or more of the following update operators: * `$set`: replaces the value of a field with a specified one\n* `$inc`: increments or decrements field values\n* `$rename`: renames fields\n* `$unset`: removes fields\n* `$mul`: multiplies a field value by a specified number See the MongoDB Server manual for a [complete list of update operators and their usage.](https://www.mongodb.com/docs/manual/reference/operator/update-field/) The update operators apply only to the fields associated with them in your update document. ## Note ### Aggregation Pipelines in Update Operations If you are using MongoDB Version 4.2 or later, you can use aggregation pipelines made up of a subset of aggregation stages in update operations. For more information on the aggregation stages MongoDB supports in aggregation pipelines used in update operations, see our tutorial on building[updates with aggregation pipelines.](https://www.mongodb.com/docs/manual/tutorial/update-documents-with-aggregation-pipeline/) ### Example Consider a document in the `myDB.items` collection with fields describing an item for sale, its price, and the quantity available: ```javascript {    _id: 465,    item: \"Hand-thrown ceramic plate\",    price: 32.50,    quantity: 7, } \n``` If you apply the `$set` update operator with a new value for`quantity`, you can use the following update document: ```javascript const myDB = client.db(\"myDB\"); const myColl = myDB.collection(\"items\"); const filter = { _id: 465 }; // update the value of the 'quantity' field to 5 const updateDocument = {    $set: {       quantity: 5,    }, }; const result = await myColl.updateOne(filter, updateDocument); \n``` The updated document resembles the following, with an updated value in the `quantity` field and all other values unchanged: ```javascript {    _id: 465,    item: \"Hand-thrown ceramic plate\",    price: 32.50,    quantity: 5, } \n``` If an update operation fails to match any documents in a collection, it does not make any changes. Update operations can be configured to perform an [upsert](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/upsert/) which attempts to perform an update, but if no documents are matched, inserts a new document with the specified fields and values.\n\n ## Replace To perform a replacement operation, create a **replacement document** that consists of the fields and values that you would like to use in your**replace** operation. Replacement documents use the following format: ```javascript {    <field>: {       <value>    },    <field>: {       ...    } } \n``` Replacement documents are the documents that you want to take the place of existing documents that match the query filters. ### Example Consider a document in the `myDB.items` collection with fields describing an item for sale, its price, and the quantity available: ```javascript {    _id: 501,    item: \"3-wick beeswax candle\",    price: 18.99,    quantity: 10, } \n``` Suppose you wanted to replace this document with one that contains a description for an entirely different item. Your replacement operation might resemble the following: ```javascript const myDB = client.db(\"myDB\"); const myColl = myDB.collection(\"items\"); const filter = { _id: 501 }; // replace the matched document with the replacement document const replacementDocument = {    item: \"Vintage silver flatware set\",    price: 79.15,    quantity: 1, }; const result = await myColl.replaceOne(filter, replacementDocument); \n``` The replaced document contains the contents of the replacement document and the immutable `_id` field as follows: ```javascript {    _id: 501,    item: \"Vintage silver flatware set\",    price: 79.15,    quantity: 1, } \n``` If a replace operation fails to match any documents in a collection, it does not make any changes. Replace operations can be configured to perform an [upsert](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/upsert/) which attempts to perform the replacement, but if no documents are matched, it inserts a new document with the specified fields and values. You cannot modify the `_id` field of a document nor change a field to a value that violates a unique index constraint. See the MongoDB Server manual for more information on [unique indexes.](https://www.mongodb.com/docs/manual/core/index-unique/) ← [Delete a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/delete/ \"Previous Section\")[Update Arrays in a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/embedded-arrays/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/insert/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Insert a Document On this page * [Overview](#overview)\n* [A Note About \\_id](#a-note-about-%5Fid)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents) ## Overview In this guide, you can learn how to insert documents into MongoDB. You can use MongoDB to retrieve, update and delete information. To perform any of those operations, that information, such as user profiles and orders, needs to exist in MongoDB. For that information to exist, you need to first perform an **insert operation**. An insert operation inserts a single or multiple documents in MongoDB using the `insertOne()`, `insertMany()` and `bulkWrite()` methods. The following sections focus on `insertOne()` and `insertMany()`. For an example on how to use the `bulkWrite()` method, see our runnable [Bulk Operations Example.](https://mongodb.com/docs/drivers/node/current/usage-examples/bulkWrite/) ## A Note About `_id` When inserting a document, MongoDB enforces one constraint on your documents by default. Each document _must_ contain a unique `_id`field. There are two ways to manage this field: * You can manage this field yourself, ensuring each value you use is unique.\n* You can let the driver automatically generate unique `ObjectId` values with the [primary key factory.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/pkFactory/#std-label-node-pkfactory) Unless you have provided strong guarantees for uniqueness, we recommend you let the driver automatically generate `_id` values. ## Note Duplicate `_id` values violate unique index constraints, resulting in a `WriteError`. For additional information about `_id`, see the Server Manual Entry on[Unique Indexes.](https://www.mongodb.com/docs/manual/core/index-unique/) ## Insert a Single Document Use the `insertOne()` method when you want to insert a single document. On successful insertion, the method returns an`InsertOneResult` instance representing the `_id` of the new document. ### Example The following example uses the `insertOne()` method to insert a new document into the `myDB.pizzaMenu` collection: `` | const myDB = client.db(\"myDB\");                               |\n| ------------------------------------------------------------- |\n| const myColl = myDB.collection(\"pizzaMenu\");                  |\n| const doc = { name: \"Neapolitan pizza\", shape: \"round\" };     |\n| const result = await myColl.insertOne(doc);                   |\n| console.log(                                                  |\n| `A document was inserted with the _id: ${result.insertedId}`, |\n| );                                                            |  `` Your output should look something like this: ``` A document was inserted with the _id: 60c79c0f4cc72b6bb31e3836 \n``` For additional information on the classes and methods mentioned in this section, see the following resources:\n\n ## Insert Multiple Documents Use the `insertMany()` method when you want to insert multiple documents. This method inserts documents in the order specified until an exception occurs, if any. For example, assume you want to insert the following documents: ``` { \"_id\": 1, \"color\": \"red\" } { \"_id\": 2, \"color\": \"purple\" } { \"_id\": 1, \"color\": \"yellow\" } { \"_id\": 3, \"color\": \"blue\" } \n``` If you attempt to insert these documents, a `WriteError` occurs at the third document and the documents prior to the error get inserted into your collection. ## Note Use a try-catch block to get an acknowledgment for successfully processed documents before the error occurs: ```javascript const myDB = client.db(\"myDB\"); const myColl = myDB.collection(\"colors\"); try {    const docs = [       { \"_id\": 1, \"color\": \"red\"},       { \"_id\": 2, \"color\": \"purple\"},       { \"_id\": 1, \"color\": \"yellow\"},       { \"_id\": 3, \"color\": \"blue\"}    ];    const insertManyresult = await myColl.insertMany(docs);    let ids = insertManyresult.insertedIds;    console.log(`${insertManyresult.insertedCount} documents were inserted.`);    for (let id of Object.values(ids)) {       console.log(`Inserted a document with id ${id}`);    } } catch(e) {    console.log(`A MongoBulkWriteException occurred, but there are successfully processed documents.`);    let ids = e.result.result.insertedIds;    for (let id of Object.values(ids)) {       console.log(`Processed a document with id ${id._id}`);    }    console.log(`Number of documents inserted: ${e.result.result.nInserted}`); } \n``` The output consists of documents MongoDB can process and should look something like this: ``` A MongoBulkWriteException occurred, but there are successfully processed documents. Processed a document with id 1 Processed a document with id 2 Processed a document with id 1 Processed a document with id 3 Number of documents inserted: 2 \n``` If you look inside your collection, you see the following documents: ``` { \"_id\": 1, \"color\": \"red\" } { \"_id\": 2, \"color\": \"purple\" } \n``` On successful insertion, the method returns an`InsertManyResult` instance representing the number of documents inserted and the `_id` of the new document. ### Example The following example uses the `insertMany()` method to insert three new documents into the `myDB.pizzaMenu` collection: ```javascript const myDB = client.db(\"myDB\"); const myColl = myDB.collection(\"pizzaMenu\"); const docs = [    { name: \"Sicilian pizza\", shape: \"square\" },    { name: \"New York pizza\", shape: \"round\" },    { name: \"Grandma pizza\", shape: \"square\" } ]; const insertManyresult = await myColl.insertMany(docs); let ids = insertManyresult.insertedIds; console.log(`${insertManyresult.insertedCount} documents were inserted.`); for (let id of Object.values(ids)) {    console.log(`Inserted a document with id ${id}`); } \n``` Your output should look something like this: ``` 3 documents were inserted. Inserted a document with id 60ca09f4a40cf1d1afcd93a2 Inserted a document with id 60ca09f4a40cf1d1afcd93a3 Inserted a document with id 60ca09f4a40cf1d1afcd93a4 \n``` For additional information on the classes and methods mentioned in this section, see the following resources:\n\n ← [Write Operations](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/ \"Previous Section\")[Generate Custom Values for \\_id](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/pkFactory/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/distinct/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Retrieve Distinct Values On this page * [Overview](#overview)\n* [Sample Documents](#sample-documents)\n* [Distinct](#distinct)\n* [Document Field Parameter](#document-field-parameter)\n* [Example](#example)\n* [Query Parameter](#query-parameter)\n* [Options Parameter](#options-parameter)\n* [Additional Information](#additional-information)\n* [API Documentation](#api-documentation) ## Overview Use the `distinct()` method to retrieve all distinct values for a specified field across a collection. ### Sample Documents To follow along with the examples in this guide, use the following code snippet to insert documents that describe restaurants into the`myDB.restaurants` collection: `| const myDB = client.db(\"myDB\");                                                              |\n| -------------------------------------------------------------------------------------------- |\n| const myColl = myDB.collection(\"restaurants\");                                               |\n| await myColl.insertMany([                                                                    |\n| { \"_id\": 1, \"restaurant\": \"White Bear\", \"borough\": \"Queens\", \"cuisine\": \"Chinese\" },         |\n| { \"_id\": 2, \"restaurant\": \"Via Carota\", \"borough\": \"Manhattan\", \"cuisine\": \"Italian\" },      |\n| { \"_id\": 3, \"restaurant\": \"Borgatti's\", \"borough\": \"Bronx\", \"cuisine\": \"Italian\" },          |\n| { \"_id\": 4, \"restaurant\": \"Tanoreen\", \"borough\": \"Brooklyn\", \"cuisine\": \"Middle Eastern\" },  |\n| { \"_id\": 5, \"restaurant\": \"Äpfel\", \"borough\": \"Queens\", \"cuisine\": \"German\" },               |\n| { \"_id\": 6, \"restaurant\": \"Samba Kitchen\", \"borough\": \"Manhattan\", \"cuisine\": \"Brazilian\" }, |\n| ]);                                                                                          | ` ## Note Your query operation may return a reference to a cursor that contains matching documents. To learn how to examine data stored in the cursor, see the[Cursor Fundamentals page.](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/) ## Distinct The `distinct()` method requires a document field as a parameter. You can specify the following optional parameters to adjust the method output: * A `query` parameter to refine your results\n* An `options` parameter to set collation rules ### Document Field Parameter Pass the name of the document field to return a list of the field's unique values. ### Example The \"`Queens`\" and \"`Manhattan`\" borough values each appear more than once in the sample documents. However, the following example retrieves the unique values of the `borough` field: ```javascript // specify \"borough\" as the field to return values for const cursor = myColl.distinct(\"borough\"); await cursor.forEach(console.dir); \n``` This code outputs the following `borough` values:\n\n [ \"Bronx\", \"Brooklyn\", \"Manhattan\", \"Queens\" ] \n``` ### Query Parameter You can specify a query parameter to return unique values for documents that match your query. Visit [Specify a Query](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/query-document/#std-label-node-fundamentals-query-document) for more information on constructing a query filter. #### Example The following example outputs the distinct values of the `cuisine` field but excludes restaurants in \"`Brooklyn`\": ```javascript // exclude Brooklyn restaurants from the output const query = { borough: { $ne: \"Brooklyn\" }}; // find the filtered distinct values of \"cuisine\" const cursor = myColl.distinct(\"cuisine\", query); await cursor.forEach(console.dir); \n``` In this case, the query filter matches every borough value except for \"`Brooklyn`\". This prevents `distinct()` from outputting one `cuisine` value, \"`Middle Eastern`\". The code outputs the following values: ``` [ \"Brazilian\", \"Chinese\", \"German\", \"Italian\" ] \n``` ### Options Parameter You can specify the collation to the `distinct()` method by defining a`collation` field as an `options` parameter. This field allows you to set regional rules for string ordering and comparisons. See [Collations](https://mongodb.com/docs/drivers/node/current/fundamentals/collations/#std-label-node-fundamentals-collations) for instructions on applying collations. ## Note When using the `options` parameter, you must also specify a `query` parameter. If you don't want to use a query filter, define the query as `{}`. #### Example The following example uses a `collation` field to specify German language ordering conventions when outputting the distinct `restaurant` values: ```javascript // define an empty query document const query = {}; // specify German string ordering conventions const options = { collation: { locale: \"de\" }}; const cursor = myColl.distinct(\"restaurant\", query, options); await cursor.forEach(console.dir); \n``` In this case, German string ordering conventions place words beginning with \"Ä\" before those beginning with \"B\". The code outputs the following: ``` [ \"Äpfel\", \"Borgatti's\", \"Samba Kitchen\", \"Tanoreen\", \"Via Carota\", \"White Bear\" ] \n``` Without specifying a `collation` field, the output order would follow default binary collation rules. These rules place words beginning with \"Ä\" after the those with unaccented first letters: ``` [ \"Borgatti's\", \"Samba Kitchen\", \"Tanoreen\", \"Via Carota\", \"White Bear\", \"Äpfel\" ] \n``` ## Additional Information For a runnable example of retrieving distinct values, see [Retrieve Distinct Values of a Field.](https://mongodb.com/docs/drivers/node/current/usage-examples/distinct/#std-label-node-usage-distinct) ### API Documentation To learn more about the `distinct()` method and its parameters, you can visit the[API documentation.](https://mongodb.github.io/node-mongodb-native/5.1/classes/Collection.html#distinct) ← [Access Data From a Cursor](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/cursor/ \"Previous Section\")[Sort Results](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/read-operations/sort/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/upsert/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Insert or Update in a Single Operation On this page * [Overview](#overview)\n* [Performing an Update](#performing-an-update)\n* [Performing an Upsert](#performing-an-upsert) ## Overview If your application stores and modifies data in MongoDB, you probably use insert and update operations. In certain workflows, you may need to choose between an insert and update depending on whether the document exists. In these cases, you can streamline your application logic by using the`upsert` option available in the following methods: * [updateOne()](https://mongodb.com/docs/drivers/node/current/usage-examples/updateOne/)\n* [replaceOne()](https://mongodb.com/docs/drivers/node/current/usage-examples/replaceOne/)\n* [updateMany()](https://mongodb.com/docs/drivers/node/current/usage-examples/updateMany/) If the query filter passed to these methods does not find any matches and you set the `upsert` option to `true`, MongoDB inserts the update document. Let's go through an example. ## Performing an Update Suppose your application tracks the current location of food trucks, storing the nearest address data in the `myDB.foodTrucks` collection, which resembles the following: `| [                                                       |\n| ------------------------------------------------------- |\n| { name: \"Haute Skillet\", address: \"42 Avenue B\" },      |\n| { name: \"Lady of the Latke\", address: \"35 Fulton Rd\" }, |\n| ...                                                     |\n| ]                                                       | ` As an application user, you read about a food truck changing its regular location and want to apply the update. This update might resemble the following: ```javascript const myDB = client.db(\"myDB\"); const myColl = myDB.collection(\"foodTrucks\"); const query = { name: \"Deli Llama\" }; const update = { $set: { name: \"Deli Llama\", address: \"3 Nassau St\" }}; const options = {}; myColl.updateOne(query, update, options); \n``` If a food truck named \"Deli Llama\" exists, the method call above updates the document in the collection. However, if there are no food trucks named \"Deli Llama\" in your collection, no changes are made. ## Performing an Upsert Consider the case in which you want to add information about the food truck even if it does not currently exist in your collection. Rather than first querying whether it exists to determine whether we need to insert or update the document, we can set `upsert` to `true` in our call to`updateOne()` as follows: ```javascript const query = { name: \"Deli Llama\" }; const update = { $set: { name: \"Deli Llama\", address: \"3 Nassau St\" }}; const options = { upsert: true }; myColl.updateOne(query, update, options); \n``` After you run the operation above, your collection should resemble the following, whether the \"Deli Llama\" document existed in your collection beforehand: ```javascript [   { name: \"Haute Skillet\", address: \"42 Avenue B\" },   { name: \"Lady of the Latke\", address: \"35 Fulton Rd\" },   { name: \"Deli Llama\", address: \"3 Nassau St\" },   ... ] \n``` ← [Update Arrays in a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/embedded-arrays/ \"Previous Section\")[Specify a Query](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/query-document/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Delete a Document On this page * [Overview](#overview)\n* [Delete](#delete) ## Overview In this section, we show you how to call the write operations to **remove**documents from a collection in your MongoDB database. ## Delete If you want to remove existing documents from a collection, you can use `deleteOne()` to remove one document or `deleteMany()` for one or more documents. These methods accept a query document that matches the documents you want to delete. You can specify the document or documents to be deleted by the`deleteOne()` or `deleteMany()` write operations in a JSON object as follows: `| const doc = { |\n| ------------- |\n| pageViews: {  |\n| $gt: 10,      |\n| $lt: 32768    |\n| }             |\n| };            | ` To delete the first matching document using the `deleteOne()` method or to delete all matching documents using the `deleteMany()` method, pass the document as the method parameter: ```javascript const deleteResult = await myColl.deleteOne(doc); const deleteManyResult = await myColl.deleteMany(doc); \n``` You can print the number of documents deleted by the operation by accessing the `deletedCount` field of the result for each of the method calls above as follows: ```javascript console.dir(deleteResult.deletedCount); console.dir(deleteManyResult.deletedCount); \n``` Upon successful delete, these statements should print the number of documents deleted by the associated operation. For fully runnable examples and additional information on the available options, see our usage examples for[deleteOne()](https://mongodb.com/docs/drivers/node/current/usage-examples/deleteOne/) and[deleteMany().](https://mongodb.com/docs/drivers/node/current/usage-examples/deleteMany/) ← [Generate Custom Values for \\_id](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/pkFactory/ \"Previous Section\")[Change a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/change-a-document/ \"Next Section\") →",
  "https://www.mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/embedded-arrays/": " [Docs Home](https://www.mongodb.com/docs/) → [Node.js](https://mongodb.com/docs/drivers/node/current/) # Update Arrays in a Document On this page * [Overview](#overview)\n* [Sample Documents](#sample-documents)\n* [Specifying Array Elements](#specifying-array-elements)\n* [The First Matching Array Element](#the-first-matching-array-element)\n* [Matching All Array Elements](#matching-all-array-elements)\n* [Matching Multiple Array Elements](#matching-multiple-array-elements) ## Overview In this guide, you can learn how to use the following array update operators to modify an array embedded within a document: * [Positional Operator](#std-label-first-match-operator): `$`\n* [All Positional Operator](#std-label-all-match-operator): `$[]`\n* [Filtered Positional Operator](#std-label-filtered-positional-operator): `$[<identifier>]` See the MongoDB server guide on[Update Operators](https://www.mongodb.com/docs/manual/reference/operator/update-array/#update-operators)for a complete list. ### Sample Documents The examples in this guide use the following sample documents from the`test.pizza` collection. The collection contains documents that describe the customers and their pizza orders as array elements in field called `items`.\n\n ` ## Specifying Array Elements You can specify which array elements to update using a positional operator. Positional operators can specify the first, all, or certain array elements to update. To specify elements in an array with positional operators, use **dot notation**. Dot notation is a property access syntax for navigating BSON objects. To learn more, see [dot notation.](https://www.mongodb.com/docs/manual/core/document/#std-label-document-dot-notation) ### The First Matching Array Element To update the first array element of each document that matches your query, use the positional operator `$`. The positional operator `$` references the array matched by the query. You cannot use this operator to reference a nested array. For cases in which you want to access a nested array, use the[filtered positional operator.](#std-label-filtered-positional-operator) ## Important Do not use the `$` operator in an `upsert` call because the driver treats `$` as a field name in the insert document. #### Example The following code snippet shows how to update the size of the first pizza order item to \"extra large\" for the customer named Steve Lobsters. ```javascript     const query = { name: \"Steve Lobsters\", \"items.type\": \"pizza\" };     const updateDocument = {       $set: { \"items.$.size\": \"extra large\" }     };     const result = await pizza.updateOne(query, updateDocument); \n``` The query matches all documents that contain an element embedded in the`items` array that contain a value of `pizza` in the `type` field. The `updateDocument` specifies the update operation to set the first array element match in `items` to \"extra large\". After you run the update method, your customer document for Steve Lobsters resembles the following: ```javascript {   name: \"Steve Lobsters\",   address: \"731 Yexington Avenue\",   items: [     { type: \"pizza\", size: \"extra large\", ... },     ...   ] } \n``` Note that we included both `name` and `items.type` fields in the query in order to match the array in which we apply the `$` operator. If we omit the `items.type` field from the query and specify the `$` operator in our update, we encounter the following error: ``` The positional operator did not find the match needed from the query. \n``` ### Matching All Array Elements To perform the update on all of the array elements of each document that matches your query, use the all positional operator `$[]`. #### Example The following code snippet adds \"fresh mozzarella\" to the toppings of all of Popeye's order items. ```javascript     const query = { \"name\": \"Popeye\" };     const updateDocument = {       $push: { \"items.$[].toppings\": \"fresh mozzarella\" }     };     const result = await pizza.updateOne(query, updateDocument); \n``` After you run the update method, your customer document for Popeye resembles the following: ``` {   name:\"Popeye\",   address: \"1 Sweethaven\",   items: [     { type: \"pizza\", ... , toppings: [\"garlic\", \"spinach\", \"fresh mozzarella\"], },     { type: \"calzone\", ... , toppings: [\"ham\", \"fresh mozzarella\"], },   ] } \n``` ### Matching Multiple Array Elements To perform an update on all embedded array elements of each document that matches your query, use the filtered positional operator`$[<identifier>]`. The filtered positional operator `$[<identifier>]` specifies the matching array elements in the update document. To identify which array elements to match, pair this operator with `<identifier>` in an`options.arrayFilters` object. The `<identifier>` term is a placeholder value you assign that represents an element of the array field name that prefixes it. This value must start with a lowercase letter and contain only alphanumeric characters. #### Example To add a \"garlic\" topping to certain order items, format your update document as follows: ```javascript { $push: { items.$[orderItem].toppings: \"garlic\" } } \n``` This update document specifies the following:\n\n Next, add the matching criteria in your `arrayFilters` object in your update operation's `options` parameter. This object is an array of queries that specify which array elements to include in the update. To add the \"garlic\" topping to order items of type \"pizza\" and \"large size\", pass the following `arrayFilters`: ```javascript arrayFilters: [   { orderItem.type: \"pizza\" },   { orderItem.size: \"large\" } ] \n``` The following snippet shows the complete update method: ```javascript     const query = { name: \"Steve Lobsters\" };     const updateDocument = {       $push: { \"items.$[orderItem].toppings\": \"garlic\" }     };     const options = {       arrayFilters: [{         \"orderItem.type\": \"pizza\",         \"orderItem.size\": \"large\",       }]     };     const result = await pizza.updateMany(query, updateDocument, options); \n``` After you run the method, your customer document for Steve Lobsters resembles the following: ```javascript {   name: \"Steve Lobsters\",   address: \"731 Yexington Avenue\",   items: [     { type: \"pizza\", size: \"large\", toppings: [\"pepperoni\", \"garlic\"] },     { type: \"pizza\", size: \"large\", toppings: [\"pineapple\", \"ham\", \"garlic\"], ...},     ...   ] } \n``` #### Example Suppose Steve Lobsters wants to adjust their order to add \"salami\" as a topping to all pizzas that have pepperoni. To perform the update, use the filtered positional operator as follows: ```javascript     const query = { name: \"Steve Lobsters\" };     const updateDocument = {       $push: { \"items.$[item].toppings\": \"salami\" },     };     const options = {       arrayFilters: [         {           \"item.type\": \"pizza\",           \"item.toppings\": \"pepperoni\",         },       ],     };     const result = await pizza.updateOne(query, updateDocument, options); \n``` After you run the update method, your customer document for Steve Lobsters resembles the following: ```javascript {   name: \"Steve Lobsters\",   address: \"731 Yexington Avenue\",   items: [     { type: \"pizza\", size: \"large\", toppings: [\"pepperoni\", \"salami\"], },     { type: \"pizza\", size: \"medium\", toppings: [\"mushrooms\", \"sausage\", \"green peppers\"], comment: \"Extra green peppers please!\", },     { type: \"pizza\", size: \"large\", toppings: [\"pineapple, ham\"], comment: \"red pepper flakes on top\", },     { type: \"calzone\", fillings: [\"canadian bacon\", \"sausage\", \"onion\"], },     { type: \"beverage\", name: \"Diet Pepsi\", size: \"16oz\", },   ], } \n``` ← [Change a Document](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/change-a-document/ \"Previous Section\")[Insert or Update in a Single Operation](https://mongodb.com/docs/drivers/node/current/fundamentals/crud/write-operations/upsert/ \"Next Section\") →"
}