{
  "https://www.mongodb.com/docs/realm/migrate/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Migrate Your App from Stitch to Realm On this page * [Overview](#overview)\n* [Updating Your Existing Application](#updating-your-existing-application) ## Overview If you have an existing app built with the Stitch SDKs, you should migrate your app to use the new Realm SDKs. While much of the logic and flow of information hasn't changed, there are a few important changes in the way your app connects to Atlas App Services. ## Updating Your Existing Application The changes in the Realm SDKs are best described by how they have been implemented in each platform. Select the tab for the platform you are using to see specific details about migrating your existing Stitch app to the Realm SDKs. ## Note If you are developing apps in C# or Objective-C, there is no migration guidance, since we did not provide Stitch SDKs for those languages. To get started with these languages, refer to the SDK documentation sections above. [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm SDKs Realm has open-source SDKs available for most popular languages, frameworks, and platforms. Each SDK is language-idiomatic and includes: * The core database APIs for creating and working with on-device databases.\n* The APIs you need for connecting to the Atlas App Services backend so you can make use of server-side features like [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync),[Authentication](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication), [Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions),[Triggers](https://www.mongodb.com/docs/atlas/app-services/triggers/#std-label-trigger-types), and more. ![Java SDK icon](https://mongodb.com/docs/realm/images/icons/android_sdk.svg) Java SDK Build Android applications in Java or Kotlin. Realm data maps directly to the classes in your app. ![Swift SDK icon](https://mongodb.com/docs/realm/images/icons/swift_sdk.svg) Swift SDK Build applications in Swift or Objective-C for Apple platforms, including iOS, macOS, watchOS, and tvOS. ![.NET SDK icon](https://mongodb.com/docs/realm/images/icons/dot_net_sdk.svg) .NET SDK Build applications that use C# and the .NET platform, including MAUI, Xamarin, native Windows applications, and Unity projects. ![Node.JS SDK icon](https://mongodb.com/docs/realm/images/icons/node_js_sdk.svg) Node.js SDK Use the Node.js SDK to build server and IoT applications in JavaScript or TypeScript. ![React SDK icon](https://mongodb.com/docs/realm/images/icons/react_native_sdk.svg) React Native SDK Use the React Native SDK to build cross-platform applications in JavaScript or TypeScript. ![Kotlin SDK icon](https://mongodb.com/docs/realm/images/icons/kotlin_sdk.svg) Kotlin SDK Build cross-platform applications for Android, iOS, and macOS with Kotlin Multiplatform Mobile. Realm data maps directly to the classes in your app. ![Web SDK icon](https://mongodb.com/docs/realm/images/icons/web_sdk.svg) Web SDK Build web applications in JavaScript or TypeScript. Access data with GraphQL and MongoDB queries. ![Futter icon](https://mongodb.com/docs/realm/images/icons/flutter.svg) Flutter SDK Build Flutter applications with Dart. For legacy (pre-v10) Realm Database Documentation, see [https://www.mongodb.com/docs/realm-legacy/docs/.](https://www.mongodb.com/docs/realm-legacy/docs/) [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/studio/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Studio ## Get Started with Realm Studio Realm Studio is a visual tool to view, edit, and design Realm Database files. With Realm Studio, developers can: * Query objects in the database\n* View live objects in realtime while running an app\n* Create, modify, and delete objects\n* Add classes and properties to the schema\n* Export the schema as class definitions in C#, Java, JavaScript, Kotlin, Swift, and TypeScript\n* Save and import changes into a client app or production database\n![A screenshot of Realm Studio](https://mongodb.com/docs/realm/images/realm-studio.png) ## View Realm Studio Releases You can see a list of all releases at [Realm Studio Releases](https://studio-releases.realm.io/). Click a version number to view a page listing enhancements, fixes, and file downloads for that version. Alternately, you can view [Releases on GitHub](https://github.com/realm/realm-studio/releases/latest), as well as track and file issues for Realm Studio. ← [Upgrade from Stitch to Realm - Web SDK](https://mongodb.com/docs/realm/web/migrate/ \"Previous Section\")[Install Realm Studio](https://mongodb.com/docs/realm/studio/install/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/": " # Realm Web SDK The Realm Web SDK lets browser-based applications access data stored in Atlas and interact with App Services services like Functions and authentication. The Web SDK supports both JavaScript and TypeScript. Web apps built with Realm use the [Atlas GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api)or query data stored in Atlas directly from the browser. Unlike the other Realm SDKs, the Web SDK does not support creating a local database or using [Atlas Device Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) Learning Paths ## Get Started with Realm Web ![Functions Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_ATLAS_Functions3x.png) Quick Start Minimal-explanation code examples of how to work with the Realm Web SDK. [See Code Examples](https://www.mongodb.com/docs/realm/web/quickstart/) ![Realm Mobile Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_Mobile3x.png) Working Example App Learn by example through dissecting a working React app that uses the Realm Web SDK and Atlas GraphQL API. [Explore an Example App](https://www.mongodb.com/docs/atlas/app-services/template-apps/) What You Can Do ## Develop Apps with Realm Web Use the Realm Web SDK with Atlas App Services to query MongoDB directly, query a GraphQL API, invoke serverless functions, manage user authentication, and more. Essential Documentation ## Recommended Reading ![Reference Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Realm JavaScript Reference Explore reference docs for the Realm JavaScript SDKs. [Realm JavaScript Reference](https://www.mongodb.com/docs/realm/web/api-reference/) ![React Logo Icon](https://mongodb.com/docs/realm/images/icons/react-logo-icon.png) Quick Start with React Learn how to add the Realm Web SDK to your React application. [Add Realm to React project](https://www.mongodb.com/docs/realm/web/react-web-quickstart/) ![Next.js Logo Icon](https://mongodb.com/docs/realm/images/icons/nextjs-logo-icon.png) Next.js Integration Guide Learn all the ways that you can use the Realm Web SDK with your Next.js application. [Integrate with Next.js](https://www.mongodb.com/docs/realm/web/nextjs)",
  "https://www.mongodb.com/docs/realm/introduction/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Introduction to Realm On this page * [What Problem Does Realm Solve?](#what-problem-does-realm-solve-)\n* [Realm Database](#realm-database)\n* [Sync Data with MongoDB Atlas](#sync-data-with-mongodb-atlas)\n* [Use Atlas App Services](#use-atlas-app-services)\n* [Get Started with Realm](#get-started-with-realm)\n* [Summary](#summary) This introduction explains Realm for mobile application developers. After reading, you should understand: * What Realm Database is and what problems it solves.\n* Reasons to use Atlas Device Sync to synchronize application data with MongoDB.\n* Ways to use the Realm SDKs with Atlas App Services to work with your application data. ## What Problem Does Realm Solve? Mobile developers face a number of unique challenges. You must: * Handle the unpredictable environment of mobile apps. Connections can be lost, devices can shut down at any time, and clients often update long after release.\n* Maintain common data schemas and APIs between mobile clients, backend APIs, and databases.\n* Stay aware of security vulnerabilities across all components in an ecosystem.\n* Consistently serialize objects between networks, database storage, and application memory.\n* Program in the languages and frameworks for one or more mobile operating systems. All of these challenges present different obstacles. You can solve each in isolation with a wide variety of libraries and frameworks. Deciding the right solution for each problem with the right tradeoffs is a challenge mobile developers know all too well. The combination of multiple environments creates even more challenges. For instance, you can use a Java library on your Android client to serialize objects, but that library likely wouldn't work on iOS. And this doesn't even take into account consistency across backend services. ## Realm Database Many of these challenges arise due to particularities of the mobile environment. These challenges include network reliability, local storage, and keeping UIs[reactive](https://en.wikipedia.org/wiki/Reactive%5Fuser%5Finterface). Realm Database solves many common mobile programming headaches: * **Local storage**: Realm Database runs right on client devices. Access objects using the native query language for each platform. Storing, accessing, and updating your data is simple and lightweight.\n* **Network reliability**: Realm Database is offline-first. You always read from and write to the local database, not over the network. When Device Sync is enabled, Realm Database synchronizes data with App Services over the network in a background thread. The sync protocol resolves conflicts consistently on each client and in the linked Atlas cluster.\n* **Reactive UI**: Live objects always reflect the latest data stored in Realm Database. You can subscribe to changes, letting you keep your UI consistently up to date. The Realm SDKs connect to local realms for Android, iOS, Node.js, React Native, Flutter, and UWP development. ## Sync Data with MongoDB Atlas Client applications generate a lot of data. Whether it's uploaded reviews and ratings, posts and comments on a blog, or inventory in a kitchen, you need to store that data somewhere. The Realm SDKs use Atlas Device Sync to synchronize app data between clients and MongoDB Atlas. Atlas Device Sync handles network access and conflict resolution in a background thread of your application, so your application logic stays the same regardless of network conditions. Once your client data is in Atlas, you can leverage the full Atlas developer data platform. Perform aggregations and other complex workloads with the full capabilities of MongoDB. Or connect your Atlas instance to [Charts](https://www.mongodb.com/products/charts?tck=docs%5Frealm) to visualize your data in real time. Storing your data in Atlas makes it easy to share data across users and platforms. ## Use Atlas App Services The Realm SDKs integrate with App Services to easily and securely work with data from your app:\n\n ## Get Started with Realm Learn more about the Realm SDKs: * [C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/#std-label-cpp-intro)\n* [Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/#std-label-flutter-intro)\n* [Java SDK](https://mongodb.com/docs/realm/sdk/java/#std-label-java-intro)\n* [Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/#std-label-kotlin-intro)\n* [.NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/#std-label-dotnet-intro)\n* [Node.js SDK](https://mongodb.com/docs/realm/sdk/node/#std-label-node-intro)\n* [React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/#std-label-react-native-intro)\n* [Swift SDK](https://mongodb.com/docs/realm/sdk/swift/#std-label-ios-intro)\n* [Web SDK](https://mongodb.com/docs/realm/web/#std-label-web-intro) ## Summary * Realm Database is an offline-first mobile object database in which you can directly access and store live objects without an[ORM.](https://en.wikipedia.org/wiki/Object-relational%5Fmapping)\n* Live Objects always reflect the latest state of data in the database, which simplifies keeping your UI in sync with changes to your data.\n* Atlas Device Sync synchronizes data between client-side realms and the server-side MongoDB Atlas cluster linked to your app. Realm Database synchronizes data in a background thread, abstracting away network usage so you don't have to worry about latency or dropped connections.\n* The Realm SDKs integrate with App Services to easily and securely work with your data in Atlas. ← [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Previous Section\")[C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/": " # Welcome to the Realm Docs Realm is a mobile-first database designed for modern, data-driven applications. You can use Realm to build mobile, web, desktop, and IoT apps. [Get started with a tutorial](https://mongodb.com/docs/atlas/app-services/get-started/) [Read the 5 Minute Introduction](https://mongodb.com/docs/realm/introduction/) ![Realm landing page hero image](https://mongodb.com/docs/realm/images/hero.png) Realm is an embedded, object-oriented database that lets you build real-time, always-on applications. Its SDKs also provide access to Atlas App Services, a secure backend that can sync data between devices, authenticate and manage users, and run serverless JavaScript functions. Realm has open-source SDKs available for most popular languages, frameworks, and platforms. Each SDK is language-idiomatic and includes: * The core database APIs for creating and working with on-device databases.\n* The APIs you need for connecting to the App Services backend so you can make use of server-side features like [Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync),[Authentication](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication), [Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions),[Triggers](https://www.mongodb.com/docs/atlas/app-services/triggers/#std-label-trigger-types), and more. ![Swift SDK icon](https://mongodb.com/docs/realm/images/icons/swift_sdk.svg) Swift SDK Build applications in Swift or Objective-C for Apple platforms, including iOS, macOS, watchOS, and tvOS. ![Kotlin SDK icon](https://mongodb.com/docs/realm/images/icons/kotlin_sdk.svg) Kotlin SDK Build cross-platform applications for Android, iOS, and macOS with Kotlin Multiplatform Mobile. Realm data maps directly to the classes in your app. ![.NET SDK icon](https://mongodb.com/docs/realm/images/icons/dot_net_sdk.svg) .NET SDK Build applications that use C# and the .NET platform, including MAUI, Xamarin, native Windows applications, and Unity projects. ![Node.JS SDK icon](https://mongodb.com/docs/realm/images/icons/node_js_sdk.svg) Node.js SDK Use the Node.js SDK to build server and IoT applications in JavaScript or TypeScript. ![React SDK icon](https://mongodb.com/docs/realm/images/icons/react_native_sdk.svg) React Native SDK Use the React Native SDK to build cross-platform applications in JavaScript or TypeScript. ![Java SDK icon](https://mongodb.com/docs/realm/images/icons/android_sdk.svg) Java SDK Build Android applications in Java or Kotlin. Realm data maps directly to the classes in your app. ![Web SDK icon](https://mongodb.com/docs/realm/images/icons/web_sdk.svg) Web SDK Build web applications in JavaScript or TypeScript. Access data with GraphQL and MongoDB queries. ![Flutter SDK icon](https://mongodb.com/docs/realm/images/icons/flutter.svg) Flutter SDK Build Flutter applications with Dart. ![C++ SDK icon](https://mongodb.com/docs/realm/images/icons/cpp_sdk.svg) C++ SDK Build applications in C++. Access data stored in realms and sync data with Atlas. ![](https://mongodb.com/docs/realm/images/icons/realm.svg) Atlas App Services Discover how to sync data, define permissions, and connect to other services, including MongoDB Atlas. [Learn more about Atlas App Services](https://www.mongodb.com/docs/atlas/app-services/) For legacy (pre-v10) Realm Database Documentation, see [https://www.mongodb.com/docs/realm-legacy/docs/.](https://www.mongodb.com/docs/realm-legacy/docs/)",
  "https://www.mongodb.com/docs/realm/help/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Get Help On this page * [Overview](#overview)\n* [Professional Support](#professional-support)\n* [Community Forums](#community-forums)\n* [Stack Overflow](#stack-overflow)\n* [Feature Requests](#feature-requests)\n* [Bug Reporting, and Changelogs](#bug-reporting--and-changelogs) ## Overview MongoDB provides various resources for getting help with Atlas App Services. ## Professional Support MongoDB offers professional support for App Services and Atlas. Paid support includes help with training, upgrades, and general technical support for issues in your database or app. We strongly recommend MongoDB's professional support for production apps and mission-critical use cases. To learn more about professional support, see [Atlas Support & Subscriptions.](https://www.mongodb.com/cloud/atlas/pricing/support-subscriptions?tck=docs%5Frealm) To contact support, visit the [MongoDB Help Center](https://support.mongodb.com/welcome?tck=docs%5Frealm). ## Community Forums The official [MongoDB Community Forums](https://www.mongodb.com/community/forums/c/realm/9) are a great place to meet other developers, ask and answer questions, and stay up-to-date with the latest Realm and App Services features and releases. You can also interact with MongoDB employees, like our community team, engineers, and product managers, who are active forum contributors. ## Stack Overflow MongoDB monitors & answers questions with the `realm` tag on Stack Overflow, a forum to ask programming questions and get help with specific errors. [Ask a Realm related question](https://stackoverflow.com/questions/ask?tags=realm) or read through the [existing questions](https://stackoverflow.com/questions/tagged/realm?sort=Newest&edited=true). ## Feature Requests To request a feature, check the status of your feedback, or see top feature requests from other users, check out the [MongoDB Feedback Engine for Realm](https://feedback.mongodb.com/forums/923521-realm). ## Bug Reporting, and Changelogs ← [Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/ \"Previous Section\")",
  "https://www.mongodb.com/docs/realm/studio/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm Studio On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Select a version](#select-a-version)\n* [Download the binary](#download-the-binary)\n* [Run the executable file](#run-the-executable-file) ## Overview Realm Studio is available for Linux, MacOS, and Windows. Installing it is as easy as selecting a version, and downloading and running the installer. ## Tip If you want a file type that isn't listed here, such as a `.zip`file, view [the release page](https://studio-releases.realm.io/)for the version you want. You'll find a complete list of installers for each version. ## Procedure 1 ### Select a version The binaries listed on this page are always the latest version of Realm Studio. If you open an older version of a realm file in a newer Realm Studio version, you may see a prompt to upgrade your realm file. Once upgraded, you cannot revert to the older file version. You may also need to upgrade your SDK to a version that supports the newer file format. If you don't want to upgrade Realm Database, download an older version of Realm Studio. You can see a list of all releases at[Realm Studio Releases](https://studio-releases.realm.io/). Click a version number to view a page listing enhancements, fixes, and file downloads. 2 ### Download the binary Download and extract the correct binary for your operating system. | Operating System | Download                                                                     |\n| ---------------- | ---------------------------------------------------------------------------- |\n| Linux            | [.AppImage](https://studio-releases.realm.io/latest/download/linux-appimage) |\n| MacOS            | [.dmg](https://studio-releases.realm.io/latest/download/mac-dmg)             |\n| Windows          | [.exe](https://studio-releases.realm.io/latest/download/win-setup)           | 3 ### Run the executable file Run the executable file. Follow installer instructions. ← [Realm Studio](https://mongodb.com/docs/realm/studio/ \"Previous Section\")[Open a Realm File](https://mongodb.com/docs/realm/studio/open-realm-file/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/studio/explore-realm-file/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Explore a Realm File On this page * [Overview](#overview)\n* [View Live Objects in Realtime](#view-live-objects-in-realtime)\n* [Query Objects in the Realm](#query-objects-in-the-realm)\n* [Export SDK Model Definitions](#export-sdk-model-definitions) ## Overview When you open a realm file in Realm Studio, you can: * View live objects in realtime\n* Query objects in the realm\n* Export SDK model definitions This makes it a valuable tool for developing and debugging applications backed by Realm Database. ## View Live Objects in Realtime Realm Studio gives you the ability to view live objects while you're running a client app in an emulator. You can see how functions in your app are transforming objects in realtime. This is a powerful debugging and development tool. To view live objects in Realm Studio, you'll need to [find your realm file](https://mongodb.com/docs/realm/studio/open-realm-file/#std-label-realm-studio-find-a-realm-file). Once you know your realm file path, you can open it in Realm Studio while your app is running. ## Note Unfortunately, Android emulators do not support viewing live objects in Realm Studio. If you're developing for Android, you must download the file from the emulator before you can access it. ## Query Objects in the Realm Realm Studio enables you to query the objects in the realm file. The ability to do this in the realm via Realm Studio gives you a visual tool to: * Quickly view query results\n* Experiment with query syntax\n* Validate the data in the realm file The Realm Studio query bar at the top of the main pane accepts the [Realm Database JavaScript query syntax](https://mongodb.com/docs/realm/sdk/node/examples/query-data/#std-label-node-client-query-engine). You can query using: * Comparison operators\n* Logical operators\n* String operators You can also view a reference document that details the query options from within Realm Studio. Press the ? button next to the query bar. ## Export SDK Model Definitions Realm Studio enables you to export model definitions, streamlining cross-platform development. For example, you may be an iOS developer who has already created a schema in an existing app. You now need to declare the same schema for your Android app. Recreating that schema in another programming language can be time-consuming and error-prone. Instead, you can open your realm file in Realm Studio, and export the model definition in Java. To export updated class definitions: * Go to File \\> Save model definitions, and select your preferred language. Supported languages include: Swift, JavaScript, TypeScript, Java, Kotlin, and C#.\n* Specify a name and destination for your new class definitions. Press the Save button. If your destination directory does not already exist, Realm Studio creates it. Inside, you'll find a file that contains a complete list of classes and properties, including new additions. ← [Open a Realm File](https://mongodb.com/docs/realm/studio/open-realm-file/ \"Previous Section\")[Modify Objects in a Realm File](https://mongodb.com/docs/realm/studio/modify-objects/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/studio/modify-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Modify Schema in a Realm Studio On this page * [Overview](#overview)\n* [Add a Class to the Schema](#add-a-class-to-the-schema)\n* [Add a Property to the Class](#add-a-property-to-the-class)\n* [Save Model Definitions](#save-model-definitions)\n* [Perform a Migration](#perform-a-migration) ## Overview Realm Studio gives you tools to make non-breaking changes to your schema. You can: * [Add classes to the schema](#std-label-realm-studio-add-class-to-schema)\n* [Add properties to classes](#std-label-realm-studio-add-property-to-class) ## Important If you make changes to your schema in Realm Studio, you must migrate the realm file when you use it in your client app. After you make schema changes, you can [add values](https://mongodb.com/docs/realm/studio/modify-objects/#std-label-realm-studio-modify-an-object)to the new properties and classes from within Realm Studio. You can also[create new objects](https://mongodb.com/docs/realm/studio/modify-objects/#std-label-realm-studio-create-an-object) based on your new classes and properties. This gives you a graphical user interface (GUI) tool to experiment with changes to your schema until you get the object model you need. When you've completed your changes, you can [export your model definitions](#std-label-realm-studio-export-model-definitions) from Realm Studio. This gives you new class definitions in your language of choice, which you can drop into your code. You can also [save an updated version of the realm file](https://mongodb.com/docs/realm/studio/modify-objects/#std-label-realm-studio-save-data) to use in your app. When you save a realm file with an updated schema, you must [perform a migration](#std-label-realm-studio-perform-migration) to use it in your app. ## Add a Class to the Schema To add a new class to your schema: * Press the + button next to the Classes header in the upper-left hand corner of the Realm Studio window\n* Name your new class\n* Designate a primary key (Optional)\n* Press the Add class button You'll now see a new class in the class list displayed in the left-hand sidebar. ## Add a Property to the Class To add properties to a class: * Select the class where you want to add properties in the left-hand sidebar\n* Press the + button under the Create {Class Name}button in the upper-right hand corner of the Realm Studio window\n* Name your new property\n* Select a type for your new property from the drop-down selector\n* Click the checkboxes to select Make this a list of stringsand Optional: Allow a null value if needed\n* Press the Add property button You'll see your new property displayed alongside the other class properties. If you already have objects in your class, you can add values for this property by clicking into the property's field for each value. If this is a new class with no objects, you can create new objects in the class. ## Tip ### See also:  [Modify Objects in a Realm File](https://mongodb.com/docs/realm/studio/modify-objects/#std-label-realm-studio-modify-objects) ## Save Model Definitions After you've made changes to your schema, you can export your new schema as class definitions. To export updated class definitions: * Go to File \\> Save model definitions, and select your preferred language. Supported languages include: Swift, JavaScript, TypeScript, Java, Kotlin, and C#.\n* Specify a name and destination for your new class definitions. Press the Save button. If your destination directory does not already exist, Realm Studio creates it. Inside, you'll find a file that contains a complete list of classes and properties, including new additions. This is a great tool to iterate on your schema. You can also export class definitions in multiple languages for cross-platform development. ## Perform a Migration\n\n Realm Database requires you to increment the version monotonically when you change the schema. If you try to open a realm with an updated object schema without migrating, your client will throw an error. For instructions on how to complete this migration, consult your SDK's migration guide. ← [Modify Objects in a Realm File](https://mongodb.com/docs/realm/studio/modify-objects/ \"Previous Section\")[Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/studio/open-realm-file/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Open a Realm File On this page * [Overview](#overview)\n* [Open a Local Realm File](#open-a-local-realm-file)\n* [Find a Realm File](#find-a-realm-file)\n* [Create from a CSV](#create-from-a-csv)\n* [Browse to the Create Realm from CSV option](#browse-to-the-create-realm-from-csv-option)\n* [Open your CSV](#open-your-csv)\n* [Choose where to store the imported data](#choose-where-to-store-the-imported-data)\n* [Add more data to the realm](#add-more-data-to-the-realm)\n* [Download an Example](#download-an-example)\n* [Error Opening Realm File](#error-opening-realm-file) ## Overview If you have a local realm file that you've created by running a client application, you can open it in Realm Studio. If you don't already have a realm file, you can create one by importing a CSV, or you can download a demo file. ## Open a Local Realm File You can use Realm Studio to open and explore a local realm file. This could be a file generated from running an emulator on your local machine, or a file from another source. Some development tools even allow you to view and edit the realm file while the emulator is running. This workflow supports fast, simple iteration for changes to objects and schemas. ### Find a Realm File Realm Database stores a binary-encoded version of every object and type in a single realm file. The file is located at a specific path that you define when you open the realm. To find your default realm file path: Once you know the location of your local realm file, you can browse to that location from the Open Realm file dialog. ## Note ### Files at hidden paths On MacOS, the default location for Xcode emulator files is under the`~/Library` folder. By default, this is a hidden directory. You may not be able to browse to this location from the Open Realm file dialog. Use another technique to view the file, such as `Go to Folder` in Finder, and open the realm from there. ## Create from a CSV If you don't have a local realm file, you can create one from a CSV in Realm Studio. When you create a realm from CSV, Realm Studio infers these details: * The name of your CSV becomes the class name in the realm file\n* The first row of your CSV becomes the class property names in the realm\n* The values of each column shape the class property types. A column of 'true' and 'false' values becomes a boolean property type. A column of whole numbers becomes an integer property type, and so on. If Realm Studio can't determine the property type, it becomes a string. For example, a CSV named `data.csv` with this formatting: `| 1 | device,number,flag |\n| - | ------------------ |\n| 2 | gizmo,1,TRUE       |\n| 3 | widget,2,FALSE     | ` Becomes a class model named `data` that has three properties: * `device`, with a type `string`\n* `number`, with a type `int`\n* `flag`, with a type `bool` 1 ### Browse to the Create Realm from CSV option In Realm Studio, go to: File \\> Create Realm from \\> CSV 2 ### Open your CSV Browse to the location of your CSV file, and select it. Press the Open button. 3 ### Choose where to store the imported data Enter a name for the realm file that will be created from your CSV. Browse to the location where you want to save it. Press the Save button. 4 ### Add more data to the realm When you create a new realm file from a CSV, you may get this message: \"Failed to import data: Class name (name-of-file.csv) missing from schema\" If this happens, press OK. You'll see that creating a realm from your CSV has created a class definition, but there are no objects in your realm. From here, you can [Import from a CSV](https://mongodb.com/docs/realm/studio/modify-objects/#std-label-realm-studio-import-from-a-csv)to populate your realm with object that map to the class definition you just created. ## Download an Example\n\n When you open Realm Studio, you'll see an option to Download a demo Realm file. When you click the link to download the demo file in Realm Studio, you can specify a name and location to save a realm file containing demo data. Once you have downloaded the file, you can use theOpen Realm file dialog to open it. ## Error Opening Realm File If you get an error when you try to open a realm file, this may be due to a version mismatch between the Realm file format supported in Realm Studio and the Realm file format produced by the SDK. To verify compatibility, check the release notes for your SDK version or your [Realm Studio version](https://github.com/realm/realm-studio/releases/). You may need to upgrade or downgrade Realm Studio or the Realm SDK version. These error messages may resemble: ``` Realm file is currently open in another process which cannot share access with this process. All processes sharing a single file must be the same architecture. \n``` ``` The file is already opened by another process, with an incompatible lock file format. Try up- or downgrading Realm Studio or SDK to match their versions of Realm Core. \n``` ← [Install Realm Studio](https://mongodb.com/docs/realm/studio/install/ \"Previous Section\")[Explore a Realm File](https://mongodb.com/docs/realm/studio/explore-realm-file/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/studio/modify-objects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Modify Objects in a Realm File On this page * [Overview](#overview)\n* [Import from a CSV](#import-from-a-csv)\n* [Browse to the Import from CSV option](#browse-to-the-import-from-csv-option)\n* [Select a CSV to import](#select-a-csv-to-import)\n* [Choose the destination class for your objects](#choose-the-destination-class-for-your-objects)\n* [Create an Object](#create-an-object)\n* [Consider Object Relationships](#consider-object-relationships)\n* [Create the Object](#create-the-object)\n* [Modify an Object](#modify-an-object)\n* [Change a Field Value](#change-a-field-value)\n* [Change an Object's Relationships](#change-an-object-s-relationships)\n* [Delete an Object](#delete-an-object)\n* [Save the Data](#save-the-data)\n* [Use the JSON File](#use-the-json-file)\n* [Use the Realm File](#use-the-realm-file) ## Overview Realm Studio gives you the ability to view and modify objects in your realm file. You can: * Import data from a CSV\n* Create new objects\n* Modify and delete existing objects You can then save the data as JSON or a realm file, and import it into your client app or production database. ## Import from a CSV ## Note If you want to use a new class when importing data, you must create the class before starting the import. 1 ### Browse to the Import from CSV option In Realm Studio, go to: File \\> Import data from \\> CSV 2 ### Select a CSV to import Browse to the location of your CSV file, and select it. Press the Open button. 3 ### Choose the destination class for your objects You'll see a drop-down selector containing the available classes in your realm file. Select the class where the imported data should become objects. Press the Import data button. Now you'll see newly-created objects created from the data you imported. Each object's properties map to the properties of the class you selected during import. ## Create an Object ### Consider Object Relationships When you create a new object, think about the relationships between the objects. For example, a to-do app, might have categories and tasks. The categories have a to-many relationship to the tasks; one category may have many tasks. The tasks have an inverse relationship to the category. In Realm Database, a to-many relationship is represented as a`list` property linking the two objects. In the example of a to-do app, the `Category` class has a `list` property whose value is all of the related `Task` objects. In the Realm Studio UI, you would select the `Category` class. Click into the `[list-of-task]` property for the category where you want to add the task - for example, \"Work\". ![Realm Studio screenshot showing the Category class selected and the \"list of task\" for category view.](https://mongodb.com/docs/realm/images/realm-studio-click-into-list-of-tasks.png) You'll see all the task objects that have an inverse relationship with the Work category. When you create the new task object from within the Work list, Realm Studio sets the inverse relationship with the Work parent category. ![Realm Studio screenshot showing the task objects belonging to the \"Work\" category, and the \"Create task\" button.](https://mongodb.com/docs/realm/images/realm-studio-create-task-from-category-work.png) From here, you might create a new task object to \"Review PR 1013.\" The new task will be linked to the \"Work\" category through an inverse relationship. ![Realm Studio screenshot showing a user entering properties for a new task object, and the \"Create\" button.](https://mongodb.com/docs/realm/images/realm-studio-task-creation-ui.png) If you select the `Task` class directly, you could create a new task object. But that task object would not have an inverse relationship with any parent category. You would then have to [manually add the orphaned task object](#std-label-realm-studio-change-object-relationship) to the category where it belongs. ### Create the Object 1\n\n The left sidebar of Realm Studio displays the classes that comprise the schema. Select the class for the type of object you want to create. 2 #### Create the new object Once you've decided where to create your new object, you can do this in two ways: * Click the Create {Class name} button in the upper right corner of the app\n* Right click (or control click) anywhere in the main window to bring up the contextual menu, and select Create new {Class name} Either option will open a dialog where you can set the properties for the object. When you've specified the required properties, press theCreate button. If you create an orphaned object that is not associated with a parent object via a linking property, you'll need to add it manually to the linked object. See: [Modify an Object.](#std-label-realm-studio-modify-an-object) ## Modify an Object There are a few ways you can modify a realm object in Realm Studio: * Change a field value\n* Change an object relationship ### Change a Field Value You can manually change an object's field values: * Click into the field of an object\n* Enter a different value Realm Studio provides simple type validation, such as providing a list of acceptable boolean options: Use \"true\", \"false\", \"0\", or \"1\", or automatically converting a date into a valid datetime. However, this validation may lead to unexpected behavior. For example, typing \"123abc\" into an `int` field simply discards the non-numeric characters without providing user feedback or errors. Therefore, it is up to you to ensure the data you enter into a field value is of the correct type. ### Change an Object's Relationships You can change an object's relationship with other objects using Realm Studio. To add a new object relationship: * Click into the property that defines the relationship\n* Right-click (or control-click) anywhere in the main pane, and selectAdd existing {linked class name}\n* Select the object you want to link, and press the Select button ## Important Adding an object relationship does not remove an existing object relationship. If you want to change an object relationship; for example, move a task from one category to another; you must also remove the relationship that linked the task to the old category. To remove an object relationship: * Click into the property that defines the relationship.\n* Right-click (or control-click) the object whose relationship you want to remove, and select Remove selected row from the listor Delete selected object depending on the type of relationship.\n* You'll see a dialog asking you to confirm the action. Press the button to confirm you want to remove or delete the object. ## Delete an Object To delete an object from a realm: * Right-click (or control-click) the object you want to delete, and select Delete selected object.\n* You'll see a dialog asking you to confirm the action. Press theDelete selected object button to confirm. ## Tip If you don't see the Delete selected object option, you may be viewing it in a linking relationship list view. Go directly to the class where the object is stored. If you're in the class where the object is stored, and still don't see the Delete selected objects option, it may be because you have another object selected. Click to select the object you want to delete, and then right-click (or control-click) to get the delete option. ## Save the Data Because realm objects are live objects, you can make changes to a realm file and see them reflected in a client app in realtime. Realm Studio gives you a few save options if you want to do other things with the data. To save the file, follow these steps: 1. Go to File \\> Save data and select JSONor Local Realm.\n2. Select the filename and destination where you want to save the file.\n3. Press the Save button. ### Use the JSON File If you have saved the data as JSON, you can import it back into your app. Use your preferred method to import the JSON into your app. ## Important ### \"Flatted\" files When exporting to a JSON file, Realm Studio uses the[Flatted](https://www.npmjs.com/package/flatted) package. If you want to open the file in another application, you will need to use `Flatted.parse()`. ### Use the Realm File\n\n Alternately, you could save a copy of the realm, open the copy, and make schema changes on the copy. This would preserve your intact original realm file, but still enable you to iterate on schema. You would then be able to continue to use your existing realm file in your client app without performing a migration. You could test migrations for your new schema with the second realm file at your leisure. ← [Explore a Realm File](https://mongodb.com/docs/realm/studio/explore-realm-file/ \"Previous Section\")[Modify Schema in a Realm Studio](https://mongodb.com/docs/realm/studio/modify-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/realm-query-language/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Query Language On this page * [Query with Realm SDKs](#query-with-realm-sdks)\n* [Examples on This Page](#examples-on-this-page)\n* [Expressions](#expressions)\n* [Parameterized Queries](#parameterized-queries)\n* [Dot Notation](#dot-notation)\n* [Nil Type](#nil-type)\n* [Comparison Operators](#comparison-operators)\n* [Logical Operators](#logical-operators)\n* [String Operators](#string-operators)\n* [ObjectId and UUID Operators](#objectid-and-uuid-operators)\n* [Arithmetic Operators](#arithmetic-operators)\n* [Type Operator](#type-operator)\n* [Dictionary Operators](#dictionary-operators)\n* [Date Operators](#date-operators)\n* [Aggregate Operators](#aggregate-operators)\n* [Collection Operators](#collection-operators)\n* [List Comparisons](#list-comparisons)\n* [Backlink Queries](#backlink-queries)\n* [Subqueries](#subqueries)\n* [Sort, Distinct & Limit](#sort--distinct---limit)\n* [Flexible Sync RQL Limitations](#flexible-sync-rql-limitations)\n* [Unsupported Query Operators in Flexible Sync](#unsupported-query-operators-in-flexible-sync)\n* [List Queries](#list-queries)\n* [Embedded or Linked Objects](#embedded-or-linked-objects) Realm Query Language (RQL) is a string-based query language to constrain searches when retrieving objects from a realm. SDK-specific methods pass queries to the Realm query engine, which retrieves matching objects from the realm. Realm Query Language syntax is based on [NSPredicate.](https://developer.apple.com/documentation/foundation/nspredicate) Queries evaluate a predicate for every object in the collection being queried. If the predicate resolves to `true`, the results collection includes the object. You can use Realm Query Language in most Realm SDKs with your SDK's filter or query methods. The Swift SDK is the exception, as it uses the[NSPredicate query API](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-nspredicate-query). Some SDKs also support idiomatic APIs for querying realms in their language. ## Query with Realm SDKs For further reading on SDK-specific methods for querying realms, select the tab below for your SDK. You can also use Realm Query Language to browse for data in[Realm Studio](https://mongodb.com/docs/realm/studio/#std-label-realm-studio). Realm Studio is a visual tool to view, edit, and design Realm Database files. ## Examples on This Page Many of the examples in this page use a simple data set for a task list app. The two Realm object types are `Project` and `Task`. * A `Task` has a name, assignee's name, and completed flag. There is also an arbitrary number for priority (higher is more important) and a count of minutes spent working on it.\n* A `Project` has zero or more `Tasks` and an optional quota for minimum number of tasks expected to be completed. See the schema for these two classes, `Project` and `Task`, below: ## Expressions Filters consist of **expressions** in a predicate. An expression consists of one of the following: * The name of a property of the object currently being evaluated.\n* An operator and up to two argument expression(s). For example, in the expression `A + B`, the entirety of `A + B` is an expression, but `A`and `B` are also argument expressions to the operator `+`.\n* A value, such as a string (`'hello'`) or a number (`5`). `| \"progressMinutes > 1 AND assignee == $0\", \"Ali\" |\n| ----------------------------------------------- | ` ## Parameterized Queries\n\n Include just one parameter with `$0`. ```js \"progressMinutes > 1 AND assignee == $0\", \"Ali\" \n``` Include multiple parameters with ascending integers starting at `$0`. ```js \"progressMinutes > $0 AND assignee == $1\", 1, \"Alex\" \n``` ## Dot Notation When referring to an object property, you can use **dot notation** to refer to child properties of that object. You can even refer to the properties of embedded objects and relationships with dot notation. For example, consider a query on an object with a `workplace` property that refers to a Workplace object. The Workplace object has an embedded object property, `address`. You can chain dot notations to refer to the zipcode property of that address: ```js \"workplace.address.zipcode == 10019\" \n``` ## Nil Type Realm Query Language include the `nil` type to represent a null pointer. You can either reference `nil` directly in your queries or with a parameterized query. If you're using a parameterized query, each SDK maps its respective null pointer to `nil`. ```js \"assignee == nil\" \n``` ```js // comparison to language null pointer \"assignee == $0\", null \n``` ## Comparison Operators The most straightforward operation in a search is to compare values. ## Important ### Types Must Match The type on both sides of the operator must be equivalent. For example, comparing an ObjectId with string will result in a precondition failure with a message like: ``` \"Expected object of type object id for property 'id' on object of type 'User', but received: 11223344556677889900aabb (Invalid value)\" \n``` You can compare any numeric type with any other numeric type, including decimal, float, and Decimal128.\n\n ## Example The following example uses Realm Query Language's comparison operators to: * Find high priority tasks by comparing the value of the `priority`property value with a threshold number, above which priority can be considered high.\n* Find long-running tasks by seeing if the `progressMinutes` property is at or above a certain value.\n* Find unassigned tasks by finding tasks where the `assignee` property is equal to `null`.\n* Find tasks within a certain time range by finding tasks where the`progressMinutes` property is between two numbers. ```javascript   \"priority > 5\"   \"progressMinutes > 120\"   \"assignee == nil\"   \"progressMinutes BETWEEN { 30,60 }\"   \"progressMinutes IN { 10, 20, 30, 40, 50, 60 }\" \n``` ## Logical Operators Make compound predicates using logical operators. | Operator | Description                                                              |\n| -------- | ------------------------------------------------------------------------ |\n| AND&&    | Evaluates to true if both left-hand and right-hand expressions are true. |\n| NOT!     | Negates the result of the given expression.                              |\n| OR\\||    | Evaluates to true if either expression returns true.                     | ## Example We can use the query language's logical operators to find all of Ali's completed tasks. That is, we find all tasks where the `assignee` property value is equal to 'Ali' AND the `isComplete` property value is `true`: ```javascript \"assignee == 'Ali' AND isComplete == true\" \n``` ## String Operators Compare string values using these string operators. Regex-like wildcards allow more flexibility in search. ## Note You can use the following modifiers with the string operators: * `[c]` for case insensitivity.  \n```javascript  \n\"name CONTAINS[c] 'a'\"  \n```\n\n ## Example We use the query engine's string operators to find: * Projects with a name starting with the letter 'e'\n* Projects with names that contain 'ie' ```javascript   \"name BEGINSWITH[c] 'e'\"   \"name CONTAINS 'ie'\" \n``` ## ObjectId and UUID Operators Query [BSON ObjectIds](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) and[UUIDs](https://www.mongodb.com/docs/manual/reference/method/UUID/). These data types are often used as primary keys. To query with ObjectIds, use a parameterized query. Pass the ObjectId or UUID you're querying against as the argument. ```js \"_id == $0\", oidValue \n``` You can also put a string representation of the ObjectId you're evaluating in `oid(<ObjectId String>)`. ```js \"_id == oid(6001c033600510df3bbfd864)\" \n``` To query with UUIDs, put a string representation of the UUID you're evaluating in `uuid(<UUID String>)`. ```js \"id == uuid(d1b186e1-e9e0-4768-a1a7-c492519d47ee)\" \n``` | Operator | Description                                                                    |\n| -------- | ------------------------------------------------------------------------------ |\n| \\==, \\=  | Evaluates to true if the left-hand value is equal to the right-hand value.     |\n| !=, <>   | Evaluates to true if the left-hand value is not equal to the right-hand value. | ## Arithmetic Operators Perform basic arithmetic in one side of a RQL expression when evaluating numeric data types. ```js   \"2 * priority > 6\"   // Is equivalent to   \"priority >= 2 * (2 - 1) + 2\" \n``` You can also use multiple object properties together in a mathematic operation. ```js \"progressMinutes * priority == 90\" \n``` | Operator | Description                 |\n| -------- | --------------------------- |\n| \\*       | Multiplication.             |\n| /        | Division.                   |\n| +        | Addition.                   |\n| \\-       | Subtraction.                |\n| ()       | Group expressions together. | ## Type Operator Check the type of a property using the `@type` operator. You can only use the type operator with mixed types and dictionaries. Evaluate the property against a string representation of the data type name. Refer to SDK documentation on the mapping from the SDK language's data types to Realm data types. | Operator | Description                                                                                       |\n| -------- | ------------------------------------------------------------------------------------------------- |\n| @type    | Check if type of a property is the property name as a string. Use \\== and != to compare equality. | ```js   \"mixedType.@type == 'string'\"   \"mixedType.@type == 'bool'\" \n``` ## Dictionary Operators Compare dictionary values using these dictionary operators.\n\n You can also use dictionary operators in combination with[comparison operators](#std-label-rql-comparison-operators) to filter objects based on dictionary keys and values. The following examples show some ways to use dictionary operators with comparison operators. All examples query a collection of Realm objects with a dictionary property named `dict`. ## Example The following examples use various dictionary operators. ```js   // Evaluates if there is a dictionary key with the name 'foo'   \"ANY dict.@keys == 'foo'\"   // Evaluates if there is a dictionary key with key 'foo' and value 'bar   \"dict['foo'] == 'bar'\"   // Evaluates if there is a dictionary key with key 'foo' and value 'bar   \"dict.@count > 1\"   // Evaluates if dictionary has property of type 'string'   \"ANY dict.@type == 'string'\"   // Evaluates if all the dictionary's values are integers   \"ALL dict.@type == 'bool'\"   // Evaluates if dictionary does not have any values of type int   \"NONE dict.@type == 'double'\"   // ANY is implied.   \"dict.@type == 'string'\" \n``` ## Date Operators Query date types in a realm. Generally, you should use a parameterized query to pass a date data type from the SDK language you are using to a query. ```js \"timeCompleted < $0\", someDate \n``` You can also represent dates the following ways: * `YYYY-MM-DD@HH:mm:ss:nnnnnnnnnn` ([year-month-day@hours](mailto:year-month-day@hours):minutes:seconds:nanoseconds), UTC. You can also use `T` instead of `@` to separate the date from the time.\n* `Ts:n`, where `s` is the number of seconds and n the number of nanoseconds since [unix epoch.](https://en.wikipedia.org/wiki/Unix%5Ftime) Date supports [comparison operators.](#std-label-rql-comparison-operators) ## Example The following example shows how to compare dates with their different representations. ```js   \"timeCompleted > 2021-02-20@17:30:15:0\"   \"timeCompleted > 2021-02-20@17:30:15:0\" \n``` ## Aggregate Operators Apply an aggregate operator to a collection property of a Realm object. Aggregate operators traverse a collection and reduce it to a single value.\n\n ## Example These examples all query for projects containing tasks that meet this criteria: * Projects with average task priority above 5.\n* Projects with a task whose priority is less than 5.\n* Projects with a task whose priority is greater than 5.\n* Projects with more than 5 tasks.\n* Projects with long-running tasks. ```javascript   \"tasks.@avg.priority > 5\"   \"tasks.@max.priority < 5\"   \"tasks.@min.priority > 5\"   \"tasks.@count > 5\"   \"tasks.@sum.progressMinutes > 100\" \n``` ## Collection Operators A **collection operator** lets you query list properties within a collection of objects. Collection operators filter a collection by applying a predicate to every element of a given list property of the object. If the predicate returns true, the object is included in the output collection. | Operator  | Description                                                                               |\n| --------- | ----------------------------------------------------------------------------------------- |\n| ALL       | Returns objects where the predicate evaluates to true for all objects in the collection.  |\n| ANY, SOME | Returns objects where the predicate evaluates to true for any objects in the collection.  |\n| NONE      | Returns objects where the predicate evaluates to false for all objects in the collection. | ## Example This example uses collection operators to find projects that contain tasks matching certain criteria: ```js   // Projects with no complete tasks.   \"NONE tasks.isComplete == true\"   // Projects that contain a task with priority 10   \"ANY tasks.priority == 10\"   // Projects that only contain completed tasks   \"ALL tasks.isComplete == true\"   // Projects with at least one task assigned to either Alex or Ali   \"ANY tasks.assignee IN { 'Alex', 'Ali' }\"   // Projects with no tasks assigned to either Alex or Ali   \"NONE tasks.assignee IN { 'Alex', 'Ali' }\" \n``` ## List Comparisons You can use [comparison operators](#std-label-rql-comparison-operators) and[collection operators](#std-label-rql-collection-operators) to filter based on lists of data. You can compare any type of valid list. This includes: * collections of Realm objects, which let you filter against other data in the realm.  \n```js  \n\"oid(631a072f75120729dc9223d9) IN tasks.id\"  \n```\n* lists defined directly in the query, which let you filter against static data. You define static lists as a comma-separated list of literal values enclosed in opening (`{`) and closing (`}`) braces.  \n```js  \n\"priority IN {0, 1, 2}\"  \n```\n* native list objects passed in a [parameterized expression](#std-label-rql-parameterized-queries), which let you pass application data directly to your queries.  \n```js  \nconst ids = [  \n  new BSON.ObjectId(\"631a072f75120729dc9223d9\"),  \n  new BSON.ObjectId(\"631a0737c98f89f5b81cd24d\"),  \n  new BSON.ObjectId(\"631a073c833a34ade21db2b2\"),  \n];  \nconst parameterizedQuery = realm.objects(\"Task\").filtered(\"id IN $0\", ids);  \n``` If you do not define a collection operator, a list expression defaults to the `ANY` operator. ## Example These two list queries are equivalent: * `age == ANY {18, 21}`\n* `age == {18, 21}` Both of these queries return objects with an age property equal to either 18 or 21\\. You could also do the opposite by returning objects only if the age is not equal to either 18 or 21: * `age == NONE {18, 21}` The following table includes examples that illustrate how collection operators interact with lists and comparison operators:\n\n ## Backlink Queries A backlink is an inverse relationship link that lets you look up objects that reference another object. Backlinks use the to-one and to-many relationships defined in your object schemas but reverse the direction. Every relationship that you define in your schema implicitly has a corresponding backlink. You can access backlinks in queries using the`@links.<ObjectType>.<PropertyName>` syntax, where `<ObjectType>`and `<PropertyName>` refer to a specific property on an object type that references the queried object type. ```js // Find tasks that belong to a project with a quota greater than 10 (@links) \"@links.Project.tasks.quota > 10\" \n``` You can also define a `linkingObjects` property to explicitly include the backlink in your data model. This lets you reference the backlink through an assigned property name using standard [dot notation.](#std-label-rql-dot-notation) ```js // Find tasks that belong to a project with a quota greater than 10 (LinkingObjects) \"projects.quota > 10\" \n``` The result of a backlink is treated like a collection and supports[collection operators.](#std-label-rql-collection-operators) ```js   // Find tasks where any project that references the task has a quota greater than 0   \"ANY @links.Project.tasks.quota > 0\"   // Find tasks where all projects that reference the task have a quota greater than 0   \"ALL @links.Project.tasks.quota > 0\" \n``` You can use [aggregate operators](#std-label-rql-aggregate-operators) on the backlink collection. ```js   // Find tasks that are referenced by multiple projects   \"projects.@count > 1\"   // Find tasks that are not referenced by any project   \"@links.Project.tasks.@count == 0\"   // Find tasks that belong to a project where the average task has   // been worked on for at least 5 minutes   \"@links.Project.tasks.tasks.@avg.progressMinutes > 10\" \n``` You can query the count of all relationships that point to an object by using the `@count` operator directly on `@links`. ```js // Find tasks that are not referenced by another object of any type \"@links.@count == 0\" \n``` ## Subqueries Iterate through list properties with another query using the`SUBQUERY()` predicate function. Subqueries are useful for the following scenarios: * Matching each object in a list property on multiple conditions\n* Counting the number of objects that match a subquery `SUBQUERY()` has the following structure: ```js SUBQUERY(<collection>, <variableName>, <predicate>) \n``` * `collection`: The name of the property to iterate through\n* `variableName`: A variable name of the element to use in the subquery\n* `predicate`: The subquery predicate. Use the variable specified by `variableName` to refer to the currently-iterated element. A subquery iterates through the given collection and checks the given predicate against each object in the collection. The predicate can refer to the current iterated object with the variable name passed to `SUBQUERY()`. A subquery expression resolves to a list of objects. Realm Database only supports the `@count` aggregate operator on the result of a subquery. This allows you to count how many objects in the subquery input collection matched the predicate. You can use the count of the subquery result as you would any other number in a valid expression. In particular, you can compare the count with the number `0` to return all matching objects. ## Example The following example shows two subquery filters on a collection of projects. ```js   // Returns projects with tasks that have not been completed   // by a user named Alex.   \"SUBQUERY(tasks, $task, $task.isComplete == false AND $task.assignee == 'Alex').@count > 0\"   // Returns the projects where the number of completed tasks is   // greater than or equal to the value of a project's `quota` property.   \"SUBQUERY(tasks, $task, $task.isComplete == true).@count >= quota\" \n``` ## Sort, Distinct & Limit Sort and limit the results collection of your query using additional operators.\n\n ## Example Use the query engine's sort, distinct, and limit operators to find tasks where the assignee is Ali: * Sorted by priority in descending order\n* Enforcing uniqueness by name\n* Limiting the results to 5 tasks ```javascript \"assignee == 'Ali' SORT(priority DESC) DISTINCT(name) LIMIT(5)\" \n``` ## Flexible Sync RQL Limitations Flexible Sync has some limitations when using RQL operators. When you write the [query subscription](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-flexible-sync-query-subscription)that determines which data to sync, the server does not support these query operators. However, you can still use the full range of RQL features to query the synced data set in the client application. ### Unsupported Query Operators in Flexible Sync | Operator Type       | Unsupported Operators          |\n| ------------------- | ------------------------------ |\n| Aggregate Operators | @avg, @count, @max, @min, @sum |\n| Query Suffixes      | DISTINCT, SORT, LIMIT          | Case insensitive queries (`[c]`) cannot use indexes effectively. As a result, case insensitive queries are not recommended, since they could lead to performance problems. Flexible Sync only supports `@count` for array fields. ### List Queries Flexible Sync supports querying lists using the `IN` operator. You can query a list of constants to see if it contains the value of a queryable field: ```javascript // Query a constant list for a queryable field value \"priority IN { 1, 2, 3 }\" \n``` If a queryable field has an array value, you can query to see if it contains a constant value: ```javascript // Query an array-valued queryable field for a constant value \"'comedy' IN genres\" \n``` ## Warning You **cannot** compare two lists with each other in a Flexible Sync query. Note that this is valid Realm Query Language syntax outside of Flexible Sync queries. ```javascript // Invalid Flexible Sync query. Do not do this! \"{'comedy', 'horror', 'suspense'} IN genres\" // Another invalid Flexible Sync query. Do not do this! \"ANY {'comedy', 'horror', 'suspense'} != ANY genres\" \n``` ### Embedded or Linked Objects Flexible Sync does not support querying on properties in Embedded Objects or links. For example, `obj1.field == \"foo\"`. ← [Modify Schema in a Realm Studio](https://mongodb.com/docs/realm/studio/modify-schema/ \"Previous Section\")[Get Help](https://mongodb.com/docs/realm/help/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - Web SDK MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Next.js Integration Guide - Web SDK](https://mongodb.com/docs/realm/web/nextjs/ \"Previous Section\")[API Reference - Web SDK](https://mongodb.com/docs/realm/web/api-reference/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/create-delete-user/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create and Delete a User - Web SDK On this page * [Create a User](#create-a-user)\n* [Delete a User](#delete-a-user) ## Create a User For most [authentication methods](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), Atlas App Services automatically creates a [user account](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) the first time a user authenticates. The only exception is email/password authentication. When you use email/password authentication, you must [register](https://mongodb.com/docs/realm/web/manage-email-password-users/#std-label-web-email-password-register-new-user) and [confirm](https://mongodb.com/docs/realm/web/manage-email-password-users/#std-label-web-email-password-complete-confirmation) a user before the user can authenticate to an App. ## Delete a User _New in version 1.7.0_. Call the `App.deleteUser()` on a user object to delete the user's account from your Realm application. This deletes the account from the server in addition to clearing local data. `| await app.deleteUser(app.currentUser); |\n| -------------------------------------- | ` To use your app in the future, the user must sign up for a new account. They can use the same credentials (depending on the authentication provider), but will not have the same User ID as their deleted account. ## Important ### Deleting All User Data Deleting a user only deletes the [user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects), which may contain associated metadata from the associated auth provider. This does not delete [custom user data](https://mongodb.com/docs/realm/web/access-custom-user-data/#std-label-web-access-custom-user-data)or other user data that your app stores in a linked collection or external services. Use the [Authentication Trigger DELETE event](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-event-operation-types)to programmatically clean up other data when you delete a user. For example, you can delete the user's data from your custom user data collection or another service. ← [Manage Users - Web SDK](https://mongodb.com/docs/realm/web/users/ \"Previous Section\")[Authenticate a User - Web SDK](https://mongodb.com/docs/realm/web/authenticate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/link-identities/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Link User Identities - Web SDK ## Overview Atlas App Services provides [multiple ways](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) for users to log into your application. Because each method of authentication corresponds to a unique user identity, App Services lets you merge multiple identities belonging to a single user into one user identity. ## Example Consider an application that enables users to authenticate via[anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication). When that user decides to create a full account with an SSO provider or email/password authentication, you need some way of persisting the user's original anonymous identity with their new permanent identity. You can link identities using the `linkCredentials()` method of the `User` object of a logged-in User. `| async function linkAccounts(user, email, password) {                  |\n| --------------------------------------------------------------------- |\n| const emailPasswordUserCredentials = Realm.Credentials.emailPassword( |\n| email,                                                                |\n| password                                                              |\n| );                                                                    |\n| await user.linkCredentials(emailPasswordUserCredentials);             |\n| return user;                                                          |\n| }                                                                     | ` ← [Access Custom User Data - Web SDK](https://mongodb.com/docs/realm/web/access-custom-user-data/ \"Previous Section\")[Create & Manage User API Keys - Web SDK](https://mongodb.com/docs/realm/web/create-manage-api-keys/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/atlas-app-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Atlas App Services - Web SDK On this page * [The App Client](#the-app-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Query MongoDB](#query-mongodb)\n* [GraphQL API](#graphql-api)\n* [Call Functions](#call-functions) Realm SDKs let you connect your client apps to the App Services backend. The SDKs provide the functionality needed to authenticate users with any of the built-in [authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), call backend [functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), and directly access a linked [MongoDB data source.](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) ## The App Client When using the SDK to access the Atlas App Services backend, you start with a App object. This object provides all other functionality related to App Services. For further information, see [Initialize the App Client.](https://mongodb.com/docs/realm/web/init-app-client/#std-label-web-init-appclient) ## Authentication & User Management With the Realm Web SDK, you can manage users with minimal backend setup or client-side code using [App Services Authentication](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication). Integrate with 3rd-part OAuth providers, JWT authentication services, or use App Service's built-in user management system. To learn how to use App Services Authentication with the Realm Web SDK, see [User Management.](https://mongodb.com/docs/realm/web/users/#std-label-web-manage-users) ## Query MongoDB The Realm SDKs includes MongoDB Data Access for performing CRUD and aggregation operations directly from the browser. For security, configure server-side [data access rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules)to dynamically determine read & write permissions for every object that a user accesses. To learn how to use the MongoDB APIs, see [Query MongoDB.](https://mongodb.com/docs/realm/web/mongodb/#std-label-web-mongodb-data-access) ## GraphQL API Use the [Atlas GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) with the Realm Web SDK to query data in MongoDB Atlas. The Atlas GraphQL API generates a schema from your data in Atlas, which you can extend with custom resolvers. Configure server-side[data access rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) to dynamically determine read and write permissions for every query. To get started using the GraphQL API in a React web app, see the [Apollo GraphQL Client (React) integration guide.](https://mongodb.com/docs/realm/web/graphql-apollo-react/#std-label-graphql-apollo-react) ## Call Functions [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) let you define and execute server-side logic for your application. Call these Functions from client applications with the Realm Web SDK. These server-side functions can run under the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your data. By using Functions, you provide a secure way for multiple client applications to share complex functionality without having to reproduce that logic client-side. To learn how to use Functions, see [Call a Function.](https://mongodb.com/docs/realm/web/call-a-function/#std-label-web-call-a-function)\n\n",
  "https://www.mongodb.com/docs/realm/web/migrate/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Upgrade from Stitch to Realm - Web SDK On this page * [Overview](#overview)\n* [Changes](#changes) ## Overview If you have an existing app built with the Stitch SDK, you should migrate your app to use the new Realm SDK. While much of the application logic and flow of information hasn't changed, there are a few changes to how the new SDK connects to the Atlas App Services backend. ## Note This page presents how to migrate from the MongoDB Stitch Browser SDK to the Realm Web SDK. If you are looking to use the Realm JS SDK to build Node.js applications, check out the [Upgrade from Stitch to Realm Node](https://mongodb.com/docs/realm/sdk/node/migrate/#std-label-node-migrating-from-stitch-to-realm) page. If you are looking to develop React Native apps, consider our [Upgrade from Stitch to Realm for React Native](https://mongodb.com/docs/realm/sdk/react-native/migrate/#std-label-react-native-migrating-from-stitch-to-realm) page. ## Changes\n\n ← [API Reference - Web SDK](https://mongodb.com/docs/realm/web/api-reference/ \"Previous Section\")[Realm Studio](https://mongodb.com/docs/realm/studio/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/nextjs/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Next.js Integration Guide - Web SDK On this page * [Before You Begin](#before-you-begin)\n* [Add Authentication](#add-authentication)\n* [Client-Side Rendering](#client-side-rendering)\n* [Server-Side Rendering](#server-side-rendering)\n* [Static Rendering](#static-rendering)\n* [Alternate Ways to Query MongoDB from Next.js](#alternate-ways-to-query-mongodb-from-next.js) The following guide explains how to integrate the Realm Web SDK into a[Next.js](https://nextjs.org) application. You can use the Realm Web SDK to access data in MongoDB Atlas from web apps, such as those made with Next.js. The Realm Web SDK interfaces with your data in MongoDB Atlas via Atlas App Services. Next.js is a React-based web framework that handles app configuration and structure, and supports client-side, server-side, and static rendering. The Realm Web SDK supports all of these rendering modes in Next.js: * **Client-side rendering**: Query MongoDB directly from the browser using the Atlas GraphQL API or MongoDB Data Access.\n* **Server-side rendering**: Authenticate users with App Services from the browser and query using the GraphQL API on the server\n* **Static rendering**: Fetch data from MondoDB Atlas to generate pages at build time. ## Before You Begin Before using this integration guide, you should: * Be familiar with Next.js. Consider referring to the[Next.js documentation.](https://nextjs.org/docs/getting-started)\n* [Create an Atlas App Services backend application.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* Create a Next.js app. If creating a Next.js application for the first time, consider referring to the [Next.js Tutorial.](https://nextjs.org/learn/basics/create-nextjs-app)\n* Add the Realm Web SDK in your Next.js app. For more information, refer to[Realm Web Installation](https://mongodb.com/docs/realm/web/install/#std-label-web-install) documentation. ## Tip ### MongoDB Atlas Vercel Integration If you're using Vercel to host your Next.js app, add the MongoDB Atlas integration to easily connect your Next.js app to Atlas. [Learn more about the Vercel MongoDB Atlas integration.](https://vercel.com/integrations/mongodbatlas) ## Add Authentication Before you can query MongoDB from your app, you must initialize the App Services client and authenticate a user. You can follow the steps below to connect the Realm Web SDK to client-side Next.js. In this example, we're going to expose an authenticated `Realm.App` instance throughout the app using [Realm.getApp()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#getApp)in a custom React Hook. ## Tip ### See also:  For additional ways to expose Realm authentication throughout your application, refer to the [Next.js authentication documentation.](https://nextjs.org/docs/authentication) 1 ### Add an App ID environment variable Use the **App ID** to connect the Next.js app to Atlas App Services. Expose the App ID throughout the app as an environment variable by doing the following: 1. [Find Your App ID.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id)\n2. Create the file `.env.local` in the project's root directory.\n3. Add an environment variable for the App ID. To make the App ID accessible from the browser in addition to the server, preface its name with `NEXT_PUBLIC_`. .env.local `| NEXT_PUBLIC_APP_ID=<YOUR App Services App ID> |\n| --------------------------------------------- | ` ## Tip ### See also: \n\n 2 ### Create a React Hook to get the App The client uses a React Hook to instantiate and access the[Realm.App](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html), which you use to connect to App Services using the App ID. You will use this hook throughout the pages you create in this guide. 1. Create the file `components/useApp.js`.\n2. Add the following code to instantiate and access the `App` instance: components/useApp.js ```js import { useEffect, useState } from \"react\"; import * as Realm from \"realm-web\"; export function useApp() {   const [app, setApp] = useState(null);   // Run in useEffect so that App is not created in server-side environment   useEffect(() => {     setApp(Realm.getApp(process.env.NEXT_PUBLIC_APP_ID));   }, []);   return app; } \n``` 3 ### Log the user in Now you can access the `app` instance with the `useApp()` hook, and use it to log a user in. Authenticate anonymously in `pages/index.js` when a user arrives to the app home page. ```javascript import { useEffect } from \"react\"; import * as Realm from \"realm-web\"; import Link from \"next/link\"; import { useApp } from \"../components/useApp\"; export default function Home() {   const app = useApp();   // note: useEffect runs in the browser but does not run during server-side rendering   useEffect(() => {     // If no logged in user, log in     if (app && !app.currentUser) {       const anonymousUser = Realm.Credentials.anonymous();       app.logIn(anonymousUser);     }   }, [app, app?.currentUser, app?.currentUser?.id]);   return (     //Your app   ); } \n``` In a real application, you would want to have a more complex authentication flow. For more information, refer to the[Next.js authentication documentation.](https://nextjs.org/docs/authentication) ## Tip ### See also:  [Quick Start (React).](https://mongodb.com/docs/realm/web/react-web-quickstart/#std-label-realm-react-quick-start) ## Client-Side Rendering This section shows how you can integrate Next.js client-side rendering with the Realm Web SDK. Following these steps, you can directly query MongoDB and interact with an Atlas App Services serverless backend through client-side JavaScript in your Next.js application. You can query MongoDB using either [MongoDB Data Access](https://mongodb.com/docs/realm/web/mongodb/#std-label-web-query-mongodb) or the[Atlas GraphQL API.](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) ### MongoDB Data Access Once the `App` client is initialized and a user is authenticated, you can use MongoDB Data Access to query MongoDB directly from client code in your application. Access the MongoDB Data Access interface from the `app` object with [App.User.mongoClient()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm-MongoDB.html), and then use it to query MongoDB. ```javascript import { useEffect, useState } from \"react\"; import { useApp } from \"../components/useApp\"; function MongoDbDataAccess({ name }) {   const [plant, setPlant] = useState();   const app = useApp();   useEffect(() => {     if (app?.currentUser) {       const mongo = app?.currentUser?.mongoClient(\"mongodb-atlas\");       const plants = mongo.db(\"example\").collection(\"plants\");       plants.findOne({ name }).then((foundPlant) => {         setPlant(foundPlant);       });     }   }, [app, app?.currentUser, app?.currentUser?.id, name]);   return (     <div>\n\n       {plant ? (         <div>           <p>{plant.name}</p>           <p>{plant.color}</p>         </div>       ) : (         \"no plant\"       )}     </div>   ); } export default function DaffodilInformation() {   return <MongoDbDataAccess name=\"daffodil\" />; } \n``` ### Atlas GraphQL API Alternatively, you can use the Atlas GraphQL API to query MongoDB via GraphQL from Next.js client-side code. This example uses the [Apollo GraphQL client](https://www.apollographql.com//docs/react/) to execute GraphQL queries. Install the Apollo client with its npm package[@apollo/client](https://www.npmjs.com/package/@apollo/client) and its peer dependency [graphql.](https://www.npmjs.com/package/graphql) ```shell npm install @apollo/client graphql \n``` Now you can add a page to perform GraphQL queries. The code in the page does the following: 1. Imports the necessary dependencies\n2. Creates the GraphQL client in a provider component.\n3. Defines the GraphQL query.\n4. Creates a component that consumes the GraphQL provider and runs the query.\n5. Exports the provider component wrapping the consumer component. All together, the GraphQL page should look as follows: ```javascript // 1. Import dependencies import {   ApolloClient,   ApolloProvider,   HttpLink,   InMemoryCache,   useQuery,   gql, } from \"@apollo/client\"; import { useApp } from \"../components/useApp\"; // 2. Add GraphQL client provider function GraphQLProvider({ children }) {   const app = useApp();   const client = new ApolloClient({     link: new HttpLink({       uri: process.env.NEXT_PUBLIC_GRAPHQL_API_ENDPOINT,       // We get the latest access token on each request       fetch: async (uri, options) => {         const accessToken = app?.currentUser?.accessToken;         options.headers.Authorization = `Bearer ${accessToken}`;         return fetch(uri, options);       },     }),     cache: new InMemoryCache(),   });   return <ApolloProvider client={client}>{children}</ApolloProvider>; } // 3. GraphQL query const GET_PLANT = gql`   query Plant($name: String!) {     plant(query: { name: $name }) {       _id       sunlight       name       color       type       _partition     }   } `; // 4. Consumer of provider and query function PlantInformation({ name }) {   const { loading, error, data } = useQuery(GET_PLANT, {     variables: { name },   });   if (loading || !data) return <p>Loading ...</p>;   if (error) console.error(\"Failed with error:\", error);   return (     <div>       {data.plant ? (         <div>           <p>{data.plant.name}</p>           <p>{data.plant.color}</p>         </div>       ) : (         \"no plant\"       )}     </div>   ); } // 5. Export page with the GraphQL query export default function FullGraphQLPage() {   return (     <GraphQLProvider>       <PlantInformation name=\"daffodil\" />     </GraphQLProvider>   ); } \n``` ## Tip\n\n ## Server-Side Rendering This section shows how you can integrate Next.js server-side rendering with the Realm Web SDK. Using the Realm Web SDK with server-side rendering allows you to access data as a specific user. In doing so, you apply[App Services Rules and Permissions](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) to those user queries. To query MongoDB Atlas directly from the Next.js server, you must set up two different components: Atlas GraphQL API on the Next.js server and the Realm Web SDK in the browser.This section explains the setup of both. You may want to integrate the Web SDK and Next.js because it allows you to: * Access data stored in Atlas directly on page load.\n* Apply Atlas App Services rules and permissions to requests to reduce server-side code.\n* Reduce use of client-side JavaScript.\n* Perform server-side data manipulation. On a high level, the process for using the Realm Web SDK with Next.js server-side rendering is as follows: 1. In the browser, create a instance of your App Services client and log in a user. Save the user's accessToken as a cookie. This examples uses the package[nookies](https://www.npmjs.com//package/nookies), which simplifies cookie management in a Next.js app.\n2. On the server, parse the accessToken cookie and use it to fetch data from MongoDB using the Atlas GraphQL API.\n3. On the server, pre-render the data from MongoDB in your webpage before sending it to the browser. ## Note ### Do Not Use MongoDB Data Access with Server-side Rendering While possible to use the MongoDB Data Access in server-side environments to query MongoDB, it is not generally advisable. You would need to persist user credentials in the browser to pass to the server on every request, which is a security vulnerability. Plus, MongoDB Data Access makes requests from a user object, which would need to be re-instantiated and re-authenticated on every request. The following steps outline using the Realm Web SDK with Next.js server-side rendering. 1 ### Install dependencies Install the following npm packages: ```shell npm install nookies npm install @apollo/client graphql \n``` 2 ### Create a custom app wrapper to add accessToken to cookies Create a custom `App` page wrapper. Create the file `pages/_app.js`, and get the `Realm.App` instance with the `useApp()` hook. If there is a user currently authenticated, save their accessToken as a cookie. This transfers the accessToken from the browser to the server on every request. Set your cookie in a `useEffect` hook that runs every time there's a change in the user object, as shown below. The `setInterval` also resets the credential in cookies before the token expires. ```javascript import { useApp } from \"../components/useApp\"; import { setCookie } from \"nookies\"; // Import the useEffect hook import { useEffect } from \"react\"; function MyApp({ Component, pageProps }) {   const app = useApp();   // Reset the user access token in cookies on a regular interval   useEffect(() => {     const user = app?.currentUser;     if (user) {       setCookie(null, \"accessToken\", user.accessToken);       // Refresh token before session expires       const TWENTY_MIN_MS = 1200000;       const resetAccessToken = setInterval(async () => {         await app?.currentUser?.refreshCustomData();         setCookie(null, \"accessToken\", user.accessToken);       }, TWENTY_MIN_MS);       // Clear interval setting access token whenever component unmounts or       // there's a change in user.       return () => clearInterval(resetAccessToken);     }   }, [app, app?.currentUser]);   return (     <>         <Component {...pageProps} app={app} />     </>   ); } export default MyApp; \n``` 3 ### Server-side render the data Create a new page file to perform the server-side rendering. On the page, add code to perform the following:\n\n All together, the server-side rendering page looks as follows: ```javascript // 1. import dependencies import nookies from \"nookies\"; import { ApolloClient, InMemoryCache, HttpLink, gql } from \"@apollo/client\"; // 2. Function to create GraphQL client const createClient = (token) =>   new ApolloClient({     link: new HttpLink({       ssrMode: true,       uri: process.env.NEXT_PUBLIC_GRAPHQL_API_ENDPOINT,       headers: {         Authorization: `Bearer ${token}`,       },     }),     cache: new InMemoryCache(),   }); // 3. GraphQL Query used in SSR const GET_PLANT = gql`   query Plant($name: String!) {     plant(query: { name: $name }) {       _id       sunlight       name       color       type       _partition     }   } `; // 4. Server-side logic to parse cookie and run query export async function getServerSideProps(context) {   const { accessToken } = nookies.get(context);   const client = createClient(accessToken);   const {     data: { plant: lily },   } = await client.query({     query: GET_PLANT,     variables: { name: \"daffodil\" },   });   return {     props: { lily },   }; } // Full page exported that gets the data from SSR export default function Ssr({ lily }) {   return (     <div>       <h1>Data from Server-Side Rendering</h1>       {lily ? (         <div>           <p>{lily.name}</p>           <p>{lily.color}</p>         </div>       ) : (         \"no plant\"       )}     </div>   ); } \n``` ## Tip ### See also:  [Alternative ways to Query MongoDB from Next.js section](#std-label-nextjs-mongodb-alternate-ways) ## Static Rendering You can use Next.js static rendering with the Realm Web SDK to pull data from MondoDB Atlas and generate page HTML at build time. You might want to use the Realm Web SDK with static rendering for the following use cases: * Pull in content management system data\n* Add configuration information\n* Create internationalized content 1 ### Creating and guarding your API key You need to create a Server API key for authentication. Follow the steps on the API Key Configuration page to complete this step. Then, in your Next.js app, add the API key to your `.env.local` file. The variable stored is not accessible from the browser, as long as you **do not** prefix it with `PUBLIC_NEXT_`. .env.local ``` REALM_API_KEY=secret_api_key \n``` Now you can access the variable in your app, except for in client-side rendering. ```javascript const { REALM_API_KEY } = process.env; \n``` 2 ### Perform static rendering with `getStaticProps()`. You can use the Next.js function [getStaticProps()](https://nextjs.org/docs/basic-features/data-fetching/get-static-props)to query MongoDB during static generation. In order to pre-render your page using `getStaticProps()`, connect your Next.js app to the Realm Web SDK. Then, you can use `getStaticProps()` to fetch data from MongoDB. The following example shows how to query MongoDB with static rendering. ```javascript import * as Realm from \"realm-web\"; export async function getStaticProps() {   const apiKey = process.env.REALM_API_KEY;   const app = new Realm.App({ id: process.env.NEXT_PUBLIC_APP_ID });   // Log in user using realm API key   const credentials = Realm.Credentials.apiKey(apiKey);\n\n   // Connect to database   const mongo = user.mongoClient(\"mongodb-atlas\");   const plants = mongo.db(\"example\").collection(\"plants\");   // Use plants.findOne to query the database   const data = await plants.findOne({ name: \"daffodil\" });   // You must parse data as JSON to use it as a prop   const json = JSON.parse(JSON.stringify(data));   return {     props: {       plant: json,     },   }; } export default function Static({ plant }) {   return (     <div>       <h1>Data from Static Rendering</h1>       <div>         <div>           <p>{plant.name}</p>           <p>{plant.color}</p>         </div>       </div>     </div>   ); } \n``` ## Alternate Ways to Query MongoDB from Next.js In addition to the Realm Web SDK, you can query MongoDB from Next.js in several ways: * Integrate MongoDB with your Next.js application, then execute your MongoDB queries using the MongoDB Node Driver. For more information, see the blog post[How to Integrate MongoDB Into Your Next.js App](https://www.mongodb.com/developer/languages/javascript/nextjs-with-mongodb/). Using MongoDB drivers is not compatible with App Services[user-based Rules and Permissions.](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules)\n* Use the MongoDB Data API to query MongoDB Atlas from the Next.js server. For more information, see [Data API Endpoints.](https://www.mongodb.com/docs/atlas/app-services/data-api/#std-label-data-api) ← [Apollo Client (React) - Web SDK](https://mongodb.com/docs/realm/web/graphql-apollo-react/ \"Previous Section\")[Telemetry - Web SDK](https://mongodb.com/docs/realm/web/telemetry/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/react-web-quickstart/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start with React - Web SDK This guide shows you how to set up a basic React web application that connects to your Atlas App Services backend and authenticates an anonymous user. We put together a finished version of this quick start on CodeSandbox. All you have to do is paste in your Realm App ID to connect to your app. * [JavaScript CodeSandbox](https://codesandbox.io/s/realm-web-react-quickstart-rd8j2?file=/src/App.js)\n* [TypeScript CodeSandbox](https://codesandbox.io/s/realm-web-react-ts-quickstart-wb0f4?file=/src/App.tsx) ## Prerequisites * This guide assumes that you have already [created an Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app) and [enabled anonymous authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)\n* To create and run this application you will need [npm](https://www.npmjs.com/) installed on your machine.\n* The [create-react-app](https://create-react-app.dev/docs/getting-started/)documentation recommends that you install [npx](https://www.npmjs.com/package/npx) to run`create-react-app` rather than using a version that's installed on your machine. ## Procedure 1 ### Set up a New React App Generate a new application template using [create-react-app:](https://create-react-app.dev/) Navigate into the new app and install the `realm-web` package: `| cd realm-web-react-quickstart |\n| ----------------------------- |\n| npm install --save realm-web  | ` 2 ### Import Dependencies & Connect to Your Realm App The Realm Web SDK contains everything you need to connect to a MongoDB Realm application from a browser application. In `/src/App.js`, add the following code to import the Web SDK. ```javascript import * as Realm from \"realm-web\"; \n``` Now uses the imported package to instantiate a new `Realm.App`. The `app` object represents your Realm app. You'll use it to authenticate and manage the users that interact with your app. ```javascript // Add your App ID const app = new Realm.App({ id: APP_ID }); \n``` 3 ### Create React Components In `/src/App.js`, add the following components that display details about a given user and allow users to log in. 4 ### Create and Export the App Component In `/src/App.js`, overwrite the existing `App` component with the following component that stores the current user in local state and conditionally renders either details about the current user or a login screen if no user is currently authenticated. 5 ### Run the App You're now ready to connect to your Realm app and log in! Make sure you've saved your changes to `/src/App.js` and then run the following command from the project root: ```shell yarn start \n``` This starts a local web server that serves your application. If successful, you should see the following output in your shell: ```shell Compiled successfully! You can now view realm-quickstart-web in the browser.   Local:  http://localhost:3000 \n``` Open <http://localhost:3000> in your browser and test that you can successfully log in as an anonymous user. ## Summary If you have successfully completed this guide, you have created a React application that can connect to an App Services backend and authenticates an anonymous user. ← [Quick Start - Web SDK](https://mongodb.com/docs/realm/web/quickstart/ \"Previous Section\")[Atlas App Services - Web SDK](https://mongodb.com/docs/realm/web/atlas-app-services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/manage-email-password-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Email/Password Users - Web SDK On this page * [Overview](#overview)\n* [Register a New User Account](#register-a-new-user-account)\n* [Confirm a New User's Email Address](#confirm-a-new-user-s-email-address)\n* [Complete a User Confirmation](#complete-a-user-confirmation)\n* [Retry User Confirmation Methods](#retry-user-confirmation-methods)\n* [Resend a Confirmation Email](#resend-a-confirmation-email)\n* [Retry a User Confirmation Function](#retry-a-user-confirmation-function)\n* [Reset a User's Password](#reset-a-user-s-password)\n* [Send a Password Reset Email](#send-a-password-reset-email)\n* [Call a Password Reset Function](#call-a-password-reset-function)\n* [Complete a Password Reset](#complete-a-password-reset) ## Overview The Web SDK includes a client object that allows you to manage users associated with the [Email/Password authentication provider.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) ## Register a New User Account To register a new email/password user, call the `registerUser()` method with the user's email address and desired password. The email address must not be associated with another email/password user and the password must be between 6 and 128 characters. `| const email = \"someone@example.com\";                           |\n| -------------------------------------------------------------- |\n| const password = \"Pa55w0rd\";                                   |\n| await app.emailPasswordAuth.registerUser({ email, password }); | ` ## Note ### Confirm New Users You must [confirm a new user's email address](#std-label-web-email-password-confirm-user) before they can log in to your app. ## Confirm a New User's Email Address New users must confirm that they own their email address before they can log in to your app unless the provider is configured to [automatically confirm new users.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-automatically-confirm-users) If the provider is configured to [send a confirmation email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-confirmation-email), Atlas App Services automatically sends a confirmation email when a user registers. The email contains a link to the configured Email Confirmation URL with a token that is valid for 30 minutes after the email is sent. If a user did not receive the initial email or didn't click the confirmation link in time, you can use the SDK to [resend a confirmation email.](#std-label-web-email-password-resend-confirmation-email) Alternatively, if the provider is configured to [run a confirmation function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-confirmation-function), App Services automatically runs your custom [Atlas Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) when a user registers. If the call to the custom confirmation function fails, you can use the SDK to[retry a user confirmation function.](#std-label-web-email-password-resend-confirmation-function) ### Complete a User Confirmation You need a valid `token` and `tokenId` for a registered user in order to confirm them and allow them to log in. These values are available in different places depending on the provider configuration:\n\n To confirm a registered user, call the `confirmUser()` method with the user's valid `token` and `tokenId`: ```javascript await app.emailPasswordAuth.confirmUser({ token, tokenId }); \n``` ## Retry User Confirmation Methods The SDK provides methods to resend user confirmation emails or retry custom confirmation methods. ### Resend a Confirmation Email To resend the confirmation email to a user, call the `resendConfirmationEmail()`method with the user's email address: ```javascript const email = \"someone@example.com\"; // The user's email address await app.emailPasswordAuth.resendConfirmationEmail({ email }); \n``` ### Retry a User Confirmation Function _New in version Realm_: Web v1.4.0 To re-run your [custom confirmation function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-confirmation-function), call the `retryCustomConfirmation()` method with the user's email address: ```javascript const email = \"someone@example.com\"; // The user's email address await app.emailPasswordAuth.retryCustomConfirmation({ email }); \n``` ## Reset a User's Password ### Send a Password Reset Email If the provider is configured to [send a password reset email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-password-reset-email), you can use the SDK to send a password reset email to a user. The email contains a link to the configuredPassword Reset URL. ```javascript // The user's email address const email = \"joe.jasper@example.com\"; await app.emailPasswordAuth.sendResetPasswordEmail({ email }); \n``` ### Call a Password Reset Function If the provider is configured to [run a password reset function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function), you can use the SDK to run the function. Pass an object with the user's email and new password. You can also include additional arguments to use in the password reset function in the App Services backend. ```javascript // The user's email address const email = \"joe.jasper@example.com\"; // The new password to use const password = \"newPassw0rd\"; // Additional arguments for the reset function const args = []; await app.emailPasswordAuth.callResetPasswordFunction(   { email, password },   ...args ); \n``` ### Complete a Password Reset Once a user requests a password reset, either by [sending a password reset email](#std-label-web-send-password-reset-email) or [calling a password reset function](#std-label-web-call-password-reset-function), Realm generates a pair of unique`token` and `tokenId` values that they can use to complete the password reset within 30 minutes of the initial request. ```javascript await app.emailPasswordAuth.resetPassword({   password: \"newPassw0rd\",   token,   tokenId, }); \n``` ## Example ### Get the Token and TokenID If the provider uses the built-in password reset email, the `token` and`tokenId` are included as query parameters in the password reset URL. You can access them like so: ```javascript const params = new URLSearchParams(window.location.search); const token = params.get(\"token\"); const tokenId = params.get(\"tokenId\"); if (!token || !tokenId) {   throw new Error(     \"You can only call resetPassword() if the user followed a confirmation email link\"   ); } \n``` ← [Authenticate a User - Web SDK](https://mongodb.com/docs/realm/web/authenticate/ \"Previous Section\")[Work with Multiple Users - Web SDK](https://mongodb.com/docs/realm/web/work-with-multiple-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/graphql-apollo-react/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Apollo Client (React) - Web SDK On this page * [Overview](#overview)\n* [Set Up Apollo Client](#set-up-apollo-client)\n* [Install Dependencies](#install-dependencies)\n* [Import dependencies](#import-dependencies)\n* [Create an Apollo GraphQL Client](#create-an-apollo-graphql-client)\n* [Set Up User Authentication](#set-up-user-authentication)\n* [Add the Apollo Client to Your App](#add-the-apollo-client-to-your-app)\n* [Run Queries and Mutations](#run-queries-and-mutations)\n* [Run a Query](#run-a-query)\n* [Run a Mutation](#run-a-mutation)\n* [Refresh Access Tokens](#refresh-access-tokens) ## Overview You can use [Apollo Client](https://www.apollographql.com/docs/react) to connect to your Realm app's[exposed GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/expose-data/#std-label-graphql-expose-data) from a React application. Apollo Client runs queries and mutations, maintains a client-side data cache, and integrates into your app with idiomatic React components and hooks. ## Note ### See a Working Demo Application Check out the [Realm GraphQL - Apollo (React)](https://github.com/mongodb-university/realm-graphql-apollo-react) repository on GitHub to see a fully set-up React & Apollo application that's ready to connect to your own Atlas App Services backend. It uses the `sample_mflix.movies` collection that's included in the MongoDB Atlas [sample data sets.](https://www.mongodb.com/docs/atlas/sample-data/) If you don't want to clone the repository, the demo application is also available in-browser in the [Realm GraphQL CodeSandbox.](https://codesandbox.io/s/github/mongodb-university/realm-graphql-apollo-react?file=/src/index.js) ## Set Up Apollo Client 1 ### Install Dependencies As in any Realm project, you'll need to install the [Realm Web SDK](https://www.npmjs.com/realm-web) to authenticate users and requests. `| npm install realm-web |\n| --------------------- | ` Apollo bundles the core components that you need to create a client in a package called [@apollo/client](https://www.npmjs.com/package/@apollo/client). It also requires the [graphql](https://www.npmjs.com/package/graphql) package to parse GraphQL queries. ```shell npm install @apollo/client graphql \n``` 2 ### Import dependencies Import the necessary dependencies from `realm-web` and `@apollo/client` to create your Apollo GraphQL client and add authentication with Realm. ```javascript import * as Realm from \"realm-web\"; import {   ApolloClient,   ApolloProvider,   HttpLink,   InMemoryCache, } from \"@apollo/client\"; \n``` 3 ### Create an Apollo GraphQL Client Create a new [ApolloClient](https://www.apollographql.com/docs/react/api/core/ApolloClient) object that points to your Realm app's GraphQL API endpoint. You generate the endpoint URL based on your Realm App ID or find it on the GraphQL page of the Realm UI. ```javascript // Add your Realm App ID const graphqlUri = `https://realm.mongodb.com/api/client/v2.0/app/${APP_ID}/graphql`; // Local apps should use a local URI! // const graphqlUri = `https://us-east-1.aws.stitch.mongodb.com/api/client/v2.0/app/${APP_ID}/graphql` // const graphqlUri = `https://eu-west-1.aws.stitch.mongodb.com/api/client/v2.0/app/${APP_ID}/graphql`\n\n const client = new ApolloClient({   link: new HttpLink({     uri: graphqlUri,   }),   cache: new InMemoryCache(), }); \n``` 4 ### Set Up User Authentication The `ApolloClient` is configured to send requests to your app. However, all Realm GraphQL requests must include a valid user access token to authenticate requests, so right now any operations sent from Apollo will fail. Access tokens expire after 30 minutes and need to be refreshed. To authenticate requests, you need to add an [Authorization header](https://www.mongodb.com/docs/atlas/app-services/graphql/authenticate/#std-label-graphql-authentication) with a valid Realm user access token to each GraphQL request. You can authenticate a user and get their access token with the [Realm Web SDK](https://mongodb.com/docs/realm/web/#std-label-web-intro). The Apollo `HttpLink` object allows you to add custom headers to every request by defining a custom `fetch` function. ```javascript // Connect to your MongoDB Realm app const app = new Realm.App(APP_ID); // Gets a valid Realm user access token to authenticate requests async function getValidAccessToken() {   // Guarantee that there's a logged in user with a valid access token   if (!app.currentUser) {     // If no user is logged in, log in an anonymous user. The logged in user will have a valid     // access token.     await app.logIn(Realm.Credentials.anonymous());   } else {     // An already logged in user's access token might be stale. Tokens must be refreshed after      // 30 minutes. To guarantee that the token is valid, we refresh the user's access token.     await app.currentUser.refreshAccessToken();   }   return app.currentUser.accessToken; } // Configure the ApolloClient to connect to your app's GraphQL endpoint const client = new ApolloClient({   link: new HttpLink({     uri: `https://realm.mongodb.com/api/client/v2.0/app/${APP_ID}/graphql`,     // We define a custom fetch handler for the Apollo client that lets us authenticate GraphQL requests.     // The function intercepts every Apollo HTTP request and adds an Authorization header with a valid     // access token before sending the request.     fetch: async (uri, options) => {       const accessToken = await getValidAccessToken();       options.headers.Authorization = `Bearer ${accessToken}`;       return fetch(uri, options);     },   }),   cache: new InMemoryCache(), }); \n``` 5 ### Add the Apollo Client to Your App The Apollo `client` object is now configured to send authenticated GraphQL requests to your App Services backend. All that's left to do is make it available to the rest of your React application. The `@apollo/client` package exports an `ApolloProvider` component that makes the `client` available to any Apollo hooks that you call from child components. Wrap your app in an `ApolloProvider` and pass the `client`object to the provider. ```javascript // ... code to create the GraphQL client const AppWithApollo = () => (   <ApolloProvider client={client}>     <App />   </ApolloProvider> ); \n``` ## Run Queries and Mutations The `@apollo/client` package includes a set of declarative React hooks that connect your components to the GraphQL API and handle query and mutation execution. To define queries and mutations that you can pass to the hooks, install[graphql-tag:](https://www.npmjs.com/package/graphql-tag) ```shell npm install graphql-tag \n``` Import the relevant hooks and the GraphQL query constructor at the top of the file where you're using them. ```javascript // import whichever Apollo hooks you're using import { useQuery, useMutation } from \"@apollo/client\"; import gql from \"graphql-tag\"; \n``` ## Note ### Apollo Hooks Must Have An ApolloProvider\n\n ### Run a Query Apollo Client includes two hooks for executing queries. The hooks accept identical parameters but differ in when they execute the query: * [useQuery()](https://www.apollographql.com/docs/react/api/react/hooks/#usequery) runs automatically when its component mounts. It also returns a callback that re-runs the query whenever you call it.\n* [useLazyQuery()](https://www.apollographql.com/docs/react/api/react/hooks/#uselazyquery) returns a callback function that executes the query whenever you call it. It does not run the query on component mount. Both hooks accept a query definition and additional options, including`variables` that Apollo passes to the query. They also both return information about the query's current execution status and data returned from the most recent execution. ```javascript const ALL_MOVIES = gql`   query AllMovies {     movies {       _id       title       year       runtime     }   } `; // Must be rendered inside of an ApolloProvider function Movies() {   const { loading, error, data } = useQuery(ALL_MOVIES);   if (loading) {     return <div>loading</div>;   }   if (error) {     return <div>encountered an error: {error}</div>;   }   return <MovieList movies={data.movies} />; } \n``` ### Run a Mutation The [useMutation()](https://www.apollographql.com/docs/react/api/react/hooks/#usemutation) hook accepts a mutation definition and an optional configuration object. The most common option you'll need to pass is a `variables` object that maps to[GraphQL variables](https://graphql.org/learn/queries/#variables) in the mutation definition. The hook returns several objects in an array: * a callback function that executes the mutation\n* an object that includes information on the mutation's execution status and data returned from the most recent execution. ```javascript const UPDATE_MOVIE_TITLE = gql`   mutation UpdateMovieTitle($oldTitle: String!, $newTitle: String!) {     updateOneMovie(query: { title: $oldTitle }, set: { title: $newTitle }) {       title       year     }   } `; // Must be rendered inside of an ApolloProvider function MovieList({ movies }) {   const [updateMovieTitle] = useMutation(UPDATE_MOVIE_TITLE);   return (     <ul>       {movies.map((movie) => (         <li key={movie._id}>           <div>{movie.title}</div>           <button             onClick={() => {               updateMovieTitle({                 variables: {                   oldTitle: movie.title,                   newTitle: \"Some New Title\",                 },               });             }}           >             Update Title           </button>         </li>       ))}     </ul>   ); } \n``` ## Refresh Access Tokens When using Realm GraphQL and an Apollo Client, access tokens expire 30 minutes after they're granted. You can refresh user access tokens with the Realm Web SDK's `refreshAccessToken()` method. ```javascript // Connect to your MongoDB Realm app const app = new Realm.App(APP_ID); // Gets a valid Realm user access token to authenticate requests async function getValidAccessToken() {   // Guarantee that there's a logged in user with a valid access token   if (!app.currentUser) {\n\n     // access token.     await app.logIn(Realm.Credentials.anonymous());   } else {     // An already logged in user's access token might be stale. Tokens must be refreshed after      // 30 minutes. To guarantee that the token is valid, we refresh the user's access token.     await app.currentUser.refreshAccessToken();   }   return app.currentUser.accessToken; } // Configure the ApolloClient to connect to your app's GraphQL endpoint const client = new ApolloClient({   link: new HttpLink({     uri: `https://realm.mongodb.com/api/client/v2.0/app/${APP_ID}/graphql`,     // We define a custom fetch handler for the Apollo client that lets us authenticate GraphQL requests.     // The function intercepts every Apollo HTTP request and adds an Authorization header with a valid     // access token before sending the request.     fetch: async (uri, options) => {       const accessToken = await getValidAccessToken();       options.headers.Authorization = `Bearer ${accessToken}`;       return fetch(uri, options);     },   }),   cache: new InMemoryCache(), }); \n``` ← [Query MongoDB - Web SDK](https://mongodb.com/docs/realm/web/mongodb/ \"Previous Section\")[Next.js Integration Guide - Web SDK](https://mongodb.com/docs/realm/web/nextjs/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/access-custom-user-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Access Custom User Data - Web SDK On this page * [Overview](#overview)\n* [Example User Object](#example-user-object)\n* [Read Custom User Data](#read-custom-user-data)\n* [Output](#output)\n* [Modify a User's Custom Data](#modify-a-user-s-custom-data)\n* [Output](#output-1)\n* [Summary](#summary) ## Overview You can read arbitrary data about your application users, known as custom user data, directly within your web application. For example, you might store a user's preferred language, date of birth, or local timezone. Realm references a MongoDB collection in your linked cluster to find the custom data for a given user but does not add or update any custom user data documents. You are responsible for managing and updating user data in the collection. For details on how to enable and configure custom user data, see [Enable Custom User Data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ### Example User Object The code examples in this page use the following [user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) on which the `custom_data` field has not yet been set.\n\n ` ## Important To use custom user data, you must first [Enable Custom User Data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-enable-custom-user-data-procedure) ## Read Custom User Data ## Warning ### Custom Data May Be Stale App Services does not dynamically update a user's custom data if the underlying document changes. Instead, App Services fetches a new copy of the data whenever a user refreshes their access token, such as when they log in. This may mean that the custom data won't immediately reflect changes, e.g. updates from an authentication Trigger. If the token is not refreshed, the SDK waits 30 minutes and then refreshes it on the next call to the backend, so custom user data could be stale for up to 30 minutes plus the time until the next SDK call to the backend occurs. You can access a read-only copy of a logged in user's custom data directly from the [Realm.User.customData](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#customData) property. ```javascript // Access a logged in user's read-only custom data const customData = app.currentUser.customData; \n``` To manually fetch the latest version of a user's custom data, call[User.refreshCustomData().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#refreshCustomData) ```javascript // Refresh a user's custom data to make sure we have the latest version await app.currentUser.refreshCustomData(); \n``` ### Output ``` {   \"_id\": \"5f233a3ac49aca916792de1d\",   \"description\": \"a test document for user test@example.com\",   \"userID\": \"5f1f298f757611faec901d0f\",   \"favoriteColor\": \"pink\" } \n``` ## Modify a User's Custom Data ## Note To modify the custom data field from a client or user function, write permission to the collection in which custom data is stored must be configured. If you prefer to restrict client write access to custom data from your application, you can still modify the object from a[system function.](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) You can modify a user's custom data by updating the underlying document in your app's custom data collection. The following example updates the user's custom data to set the`favoriteColor` property to `\"purple\"`: ```javascript // Get a client object for your app's custom user data collection const mongo = app.currentUser.mongoClient(CLUSTER_NAME); const collection = mongo.db(DATABASE_NAME).collection(COLLECTION_NAME); // Log the user's favorite color before we change it console.log(   \"old favoriteColor: \",   app.currentUser.customData.favoriteColor ); // Update the user's custom data document await collection.updateOne(   { userId: app.currentUser.id }, // Query for the user object of the logged in user   { $set: { favoriteColor: \"purple\" } } // Set the logged in user's favorite color to purple ); // Refresh the user's local customData property await app.currentUser.refreshCustomData(); // Log the user's new favorite color console.log(   \"new favoriteColor: \",   app.currentUser.customData.favoriteColor ); \n``` ### Output ``` old favoriteColor: pink new favoriteColor: purple \n``` ## Summary * You can use custom user data to store information about your application users.\n* The custom user data field of the user object is read-only, and can only be modified to by performing CRUD operations through the Atlas service. ← [Work with Multiple Users - Web SDK](https://mongodb.com/docs/realm/web/work-with-multiple-users/ \"Previous Section\")[Link User Identities - Web SDK](https://mongodb.com/docs/realm/web/link-identities/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Users - Web SDK On this page * [Create and Delete Users](#create-and-delete-users)\n* [Log Users In and Out](#log-users-in-and-out)\n* [User Sessions](#user-sessions)\n* [Read and Update Custom User Data](#read-and-update-custom-user-data) You must use App Services in the context of a user. Users are associated with one or more authentication providers. You can also assign data access rules to users to constrain what data they access. Use Realm Web SDK to perform the following authentication and user management actions: * Creation of new user accounts\n* User log-in and log-out\n* Multiple users logged on at the same time on the same device\n* Linking user accounts from different providers\n* Providing custom user data When you have a logged-in user, SDK methods enable you to: * [Query MongoDB Atlas](https://mongodb.com/docs/realm/web/mongodb/#std-label-web-query-mongodb)\n* [Use the Atlas GraphQL API](https://mongodb.com/docs/realm/web/graphql-apollo-react/#std-label-graphql-apollo-react)\n* [Run a backend function](https://mongodb.com/docs/realm/web/call-a-function/#std-label-web-call-a-function) as the logged-in user ## Create and Delete Users For all authentication providers other than email/password authentication, App Services automatically [creates a user](https://mongodb.com/docs/realm/web/create-delete-user/#std-label-web-create-user)the first time a user authenticates. If a user authenticates via more than one method, you can [link these user identities](https://mongodb.com/docs/realm/web/link-identities/#std-label-web-link-user-identities)to a single user. You can [delete users](https://mongodb.com/docs/realm/web/create-delete-user/#std-label-web-delete-user). Deleting a user deletes metadata attached to the user, but does not delete user-created data from the backend. ## Log Users In and Out Use one or more [authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-auth-providers) to log users in and out of your client app. You can: * Log users in with an existing social account, such as Apple, Facebook, or Google.\n* Create new user accounts with App Services email/password management, your own custom function, or custom JWT user management.\n* Enable anonymous users to let users access your App Services App without persisting user data. For further information, see [Authenticate Users.](https://mongodb.com/docs/realm/web/authenticate/#std-label-web-authenticate) ### User Sessions Atlas App Services manages sessions with access tokens and refresh tokens. Client SDKs supply the logic to manage tokens, and provide them with requests. The Web SDK stores these tokens in the browser storage. ## Tip ### See also:  [User Sessions](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) ## Read and Update Custom User Data You can [associate custom data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) with a user, such as a preferred language or local timezone, and read it from your client application. A user has a `customData` property that you can use to [access custom user data.](https://mongodb.com/docs/realm/web/access-custom-user-data/#std-label-web-read-custom-user-data) To [create and update](https://mongodb.com/docs/realm/web/access-custom-user-data/#std-label-web-modify-custom-user-data) custom user data, you must access your MongoDB data source directly. ← [Call a Function - Web SDK](https://mongodb.com/docs/realm/web/call-a-function/ \"Previous Section\")[Create and Delete a User - Web SDK](https://mongodb.com/docs/realm/web/create-delete-user/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/quickstart/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - Web SDK On this page * [Overview](#overview)\n* [Install the Web SDK](#install-the-web-sdk)\n* [Import the Web SDK](#import-the-web-sdk)\n* [Initialize the App](#initialize-the-app)\n* [Authenticate a User](#authenticate-a-user)\n* [Call a Function](#call-a-function)\n* [Use the GraphQL API](#use-the-graphql-api) ## Overview This page shows you how to connect the Realm Web SDK to an Atlas App Services backend, authenticate a user, and work with data. Before you begin, you'll need to [create an App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app) for your web app to use. ## Install the Web SDK ## Import the Web SDK Near the top of any JavaScript or TypeScript file that uses Realm, add the following import statement: `| import * as Realm from \"realm-web\"; |\n| ----------------------------------- | ` ## Note If you loaded the SDK using a `<script>` tag then you don't need to import the SDK to use it. Instead, you can access it using the global `Realm`variable. ## Initialize the App To use App Services features such as authentication and sync, access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) in the App Services UI. ```javascript // Add your App ID const app = new Realm.App({ id: APP_ID }); \n``` ## Authenticate a User When [anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) is enabled, users can log into your app without providing any identifying information: ```javascript // Create an anonymous credential const credentials = Realm.Credentials.anonymous(); // Authenticate the user const user = await app.logIn(credentials); // `App.currentUser` updates to match the logged in user console.assert(user.id === app.currentUser.id); \n``` App Services provides many additional ways to authenticate, register, and link users. ## Tip ### See also:  [Authenticate a User](https://mongodb.com/docs/realm/web/authenticate/#std-label-web-authenticate) ## Call a Function To call a [function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), use the `Realm.User.functions`interface to [call your serverless functions](https://mongodb.com/docs/realm/web/call-a-function/#std-label-web-call-a-function) as if they were regular JavaScript functions defined on the object. ```javascript const summed = await user.functions.sum(2, 3); console.assert(summed === 5); \n``` ## Use the GraphQL API To execute CRUD operations and call custom resolvers through the [GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api), we recommend that you use a third-party GraphQL library such as [Apollo Client](https://mongodb.com/docs/realm/web/graphql-apollo-react/#std-label-graphql-apollo-react). To authenticate your GraphQL request, include a valid user token in the Authorization header of the request. ## Tip ### See also:  * [Apollo Client (React)](https://mongodb.com/docs/realm/web/graphql-apollo-react/)\n* [Run GraphQL Operations from a CLI](https://www.mongodb.com/docs/atlas/app-services/graphql/cli/#std-label-graphql-cli) ← [Install Realm - Web SDK](https://mongodb.com/docs/realm/web/install/ \"Previous Section\")[Quick Start with React - Web SDK](https://mongodb.com/docs/realm/web/react-web-quickstart/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm - Web SDK On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Install the Web SDK](#install-the-web-sdk)\n* [Install for Node.js](#install-for-node.js) ## Overview This page shows you how to install the Realm Web SDK to use with your application. ## Before You Begin Before you begin installation, you need to [create an App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)for your web app to use. ## Note ### React Native & Node.js SDKs There are Realm SDKs built for React Native and Node.js. Generally, you should use these when creating apps in these environments. Alternatively, you can use the Web SDK for React Native or Node.js apps. Further reading: * [React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/#std-label-react-native-intro)\n* [Node.js](https://mongodb.com/docs/realm/sdk/node/#std-label-node-intro)\n* [Install Web SDK for Node.js](#std-label-web-install-node) ## Install the Web SDK ## Install for Node.js In order to use Realm Web for Node.js environments, you must install two additional peer dependencies: `| npm install realm-web node-fetch abort-controller |\n| ------------------------------------------------- | ` ← [Realm Web SDK](https://mongodb.com/docs/realm/web/ \"Previous Section\")[Quick Start - Web SDK](https://mongodb.com/docs/realm/web/quickstart/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/api-reference/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # API Reference - Web SDK On this page * [Supported Classes & Namespaces](#supported-classes---namespaces) The Web SDK shares API reference documentation with the two other Realm JavaScript SDKs, the [Node.Js SDK](https://mongodb.com/docs/realm/sdk/node/#std-label-node-intro) and the [React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/#std-label-react-native-intro) However, the reference documentation doesn't differentiate between the subset of classes and namespaces supported by the Web SDK versus those only supported by Node.Js and React Native. The Web SDK doesn't support creating a local Realm database or using [sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync). Instead, web apps built with the Wek SDK use [GraphQL](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api)and the [Query API](https://mongodb.com/docs/realm/web/mongodb/#std-label-web-query-mongodb) to query data stored in Atlas. Read the [Realm JavaScript API reference.](https://www.mongodb.com/docs/realm-sdks/js/latest/index.html) ## Supported Classes & Namespaces The Realm Web SDK supports the following classes and namespaces documented in the API reference: * [Realm.BSON](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.BSON)\n* [Realm.App](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html)\n* [Realm.Auth](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.html)\n* [Realm.Credentials](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Credentials.html)\n* [Realm.MongoDBCollection](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html)\n* [Realm.User](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html)\n* [Realm\\~MongoDB](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm-MongoDB.html)\n* [Realm\\~MongoDBDatabase](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm-MongoDBDatabase.html) ← [Telemetry - Web SDK](https://mongodb.com/docs/realm/web/telemetry/ \"Previous Section\")[Upgrade from Stitch to Realm - Web SDK](https://mongodb.com/docs/realm/web/migrate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/init-app-client/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Initialize the App Client - Web SDK ## Overview The App client is the interface to the Atlas App Services backend. It provides access to the [authentication functionality](https://mongodb.com/docs/realm/web/authenticate/#std-label-web-authenticate) and [functions.](https://mongodb.com/docs/realm/web/call-a-function/#std-label-web-call-a-function) ## Access the App Client Pass the App Services App ID for your App, which you can [find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) `| const id = APP_ID; // replace this with your App ID |\n| --------------------------------------------------- | ` ## Configuration To set up your App client, pass a configuration object to an instance of `Realm.App`. ```javascript const config = {   id, }; const app = new Realm.App(config); \n``` ## Note `id` is a required field of the application configuration object. To see the full list of fields for the configuration object that `Realm.App` accepts as a parameter, view the [App Configuration Type Definitions.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#~AppConfiguration) ## Retrieve an Instance of the App Client To retrieve an instance of the App Client from anywhere in your application, call [Realm.App.getApp()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#getApp) and pass in your `App ID`. ```javascript const app = Realm.App.getApp(APP_ID); // replace this with your App ID \n``` ← [Atlas App Services - Web SDK](https://mongodb.com/docs/realm/web/atlas-app-services/ \"Previous Section\")[Call a Function - Web SDK](https://mongodb.com/docs/realm/web/call-a-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/call-a-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call a Function - Web SDK On this page * [Overview](#overview)\n* [Usage](#usage)\n* [Call a Function](#call-a-function)\n* [Call a Function Programmatically](#call-a-function-programmatically) ## Overview You can call a [Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) from a connected client application. The examples in this section demonstrate calling a simple function named`sum` that takes two arguments, adds them, and returns the result: `| // sum: adds two numbers    |\n| --------------------------- |\n| exports = function (a, b) { |\n| return a + b;               |\n| };                          | ` ## Usage In the Node SDK you call Functions as a logged in user with the`User.functions` interface. There are two ways to call a function: * You can call a function as if was a method defined locally on the`User.functions` interface.\n* You can call the `User.functions.callFunction()` method to call a function by providing its stringified name and a list of arguments. ### Call a Function ```javascript const result = await user.functions.sum(2, 3); \n``` ### Call a Function Programmatically ```javascript const functionName = \"sum\"; const args = [2, 3]; const result = await user.callFunction(functionName, ...args); \n``` ← [Initialize the App Client - Web SDK](https://mongodb.com/docs/realm/web/init-app-client/ \"Previous Section\")[Manage Users - Web SDK](https://mongodb.com/docs/realm/web/users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/create-manage-api-keys/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create & Manage User API Keys - Web SDK On this page * [Overview](#overview)\n* [Create a User API Key](#create-a-user-api-key)\n* [Look up a User API Key](#look-up-a-user-api-key)\n* [Enable or Disable an API Key](#enable-or-disable-an-api-key)\n* [Delete an API Key](#delete-an-api-key) ## Overview You can use the Web SDK to create and manage [user API keys](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication-user-api-key) that allow services to log in and interact with your app on behalf of an existing user without requiring the user to re-authenticate. User API keys are managed as part of the [API Key authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication) but may only be created for users associated with a different, non-anonymous authentication provider. User objects in the Web SDK include an `ApiKeyAuth` object that exposes methods to work with that user's API keys. ## Create a User API Key To create a new user API key, call `ApiKeyAuth.create()` with an identifying name for the key. The name must be a string that's unique among all of the user's API keys. ## Warning ### Store the API Key Value The SDK only returns the value of the user API key when you create it. Make sure to store the `key` value securely so that you can use it to log in. If you lose or do not store the `key` value there is no way to recover it. You will need to create a new user API key. `| const user = app.currentUser;                      |\n| -------------------------------------------------- |\n| const key = await user.apiKeys.create(\"myApiKey\"); | ` ## Look up a User API Key To get an array that lists all of a user's API keys, call`ApiKeyAuth.fetchAll()`. You can also find a specific API key by calling`ApiKeyAuth.fetch()` with the key's `_id`. ```javascript const user = app.currentUser; // List all of a user's keys const keys = await user.apiKeys.fetchAll(); // Get a specific key by its ID const key = await user.apiKeys.fetch(API_KEY_ID); \n``` ## Enable or Disable an API Key You can enable or disable a user API key by calling `ApiKeyAuth.enable()` or`ApiKeyAuth.disable()` with the key's `_id`. When a key is disabled, it cannot be used to log in on behalf of the user. ```javascript // Get the ID of a User API Key const user = app.currentUser; const apiKeys = await user.apiKeys.fetchAll(); const keyId = apiKeys[0][\"_id\"]; // Enable the User API Key await user.apiKeys.enable(keyId); // Disable the User API Key await user.apiKeys.disable(keyId); \n``` ## Delete an API Key You can permanently delete a user API key by calling `ApiKeyAuth.delete()`with the key's `_id`. Deleted keys can no longer be used to log in on behalf of the user. ```javascript // Get the ID of a User API Key const user = app.currentUser; const apiKeys = await user.apiKeys.fetchAll(); const keyId = apiKeys.find((key) => key.name === \"apiKeyToDelete\")._id; // Delete the User API Key await user.apiKeys.delete(keyId); \n``` ← [Link User Identities - Web SDK](https://mongodb.com/docs/realm/web/link-identities/ \"Previous Section\")[Query MongoDB - Web SDK](https://mongodb.com/docs/realm/web/mongodb/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/work-with-multiple-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Work with Multiple Users - Web SDK On this page * [Overview](#overview)\n* [User Account States](#user-account-states)\n* [Add a New User to a Device](#add-a-new-user-to-a-device)\n* [List All On-Device Users](#list-all-on-device-users)\n* [Switch the Active User](#switch-the-active-user)\n* [Remove a User from the Device](#remove-a-user-from-the-device) ## Overview The Realm SDK allows multiple [users](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) to be logged in to an app simultaneously on a given browser. Realm client applications run in the context of a single active user even if multiple users are logged in simultaneously. You can quickly switch between authenticated users without requiring them to log in again. ## Important **Any logged in user may become the active user without re-authenticating.**Depending on your app, this may be a security vulnerability. For example, a user on a shared browser may switch to a coworker's logged in account without providing their credentials or requiring their explicit permission. If your application requires stricter authentication, avoid switching between users and prefer to explicitly log the active user out before authenticating another user. ### User Account States When a user first logs in through a Realm SDK on a given browser, the SDK saves the user's information and keeps track of the user's state. The user's data remains in local storage, even if they log out, unless you actively[remove the user](#std-label-web-remove-user) or purge data from the browser. The following states describe a tracked user at any given time: * **Authenticated:** any user that has logged in on the browser and has not logged out or had its session revoked.  \n   * **Active**: a single authenticated user that is currently using the app on a given browser. The SDK associates this user with outgoing requests and Atlas App Services evaluates data access permissions and runs functions in this user's context. See [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) for more information.  \n   * **Inactive**: all authenticated users that are not the current active user. You can [switch the active user](#std-label-web-switch-user) to a currently inactive user at any time.\n* **Logged Out:** any user that authenticated on the browser but has since logged out or had its session revoked. The following diagram shows how users within a Realm client app transition between states when certain events occur: ![A diagram the outlines the different states a user can be in: logged out, logged in and active, & logged in and inactive.](https://mongodb.com/docs/realm/images/multi-user.png) ## Add a New User to a Device The Realm SDK automatically saves user data to a browser's local storage when they log in for the first time on that browser. When a user logs in, they immediately become the application's [active user.](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user)\n\n ` ### List All On-Device Users You can access a list of all [user accounts](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) associated with the browser. This list includes all users that have logged in to the client app regardless of whether they are currently authenticated. ```javascript // Get an object with all Users, where the keys are the User IDs for (const userId in app.allUsers) {   const user = app.allUsers[userId];   console.log(     `User with id ${user.id} is ${       user.isLoggedIn ? \"logged in\" : \"logged out\"     }`   ); } \n``` ### Switch the Active User You can quickly switch an app's [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) to another logged in user at any time. ```javascript // Get some logged-in users const authenticatedUsers = Object.values(app.allUsers).filter(   (user) => user.isLoggedIn ); const user1 = authenticatedUsers[0]; const user2 = authenticatedUsers[1]; // Switch to user1 app.switchUser(user1); // The active user is now user1 console.assert(app.currentUser.id === user1.id); // Switch to user2 app.switchUser(user2); // The active user is now user2 console.assert(app.currentUser.id === user2.id); \n``` ### Remove a User from the Device You can remove all information about a user from the browser and automatically log the user out. ```javascript // Remove the current user from the device const user = app.currentUser; await app.removeUser(user); // The user is no longer the active user if (app.currentUser) {   // The active user is now the logged in user (if there still is one) that was   // most recently active   console.assert(user.id !== app.currentUser.id); } // The user is no longer on the device console.assert(   Object.values(app.allUsers).find(({ id }) => id === user.id) === undefined ); \n``` ← [Manage Email/Password Users - Web SDK](https://mongodb.com/docs/realm/web/manage-email-password-users/ \"Previous Section\")[Access Custom User Data - Web SDK](https://mongodb.com/docs/realm/web/access-custom-user-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/stitch/index/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # MongoDB Stitch (Legacy) * [Migrate Your Stitch App to Realm](https://mongodb.com/docs/realm/migrate/) ## Stitch Documentation Archives * [(Legacy) Stitch Documentation](http://stitch-docs-old.s3-website-us-east-1.amazonaws.com/)\n* Stitch SDK API Reference  \n   * [(Legacy) Stitch JavaScript Browser SDK](http://stitch-sdks.s3-website-us-east-1.amazonaws.com/stitch-sdks/js/4/index.html)  \n   * [(Legacy) Stitch Java/Android SDK](http://stitch-sdks.s3-website-us-east-1.amazonaws.com/stitch-sdks/java/4/overview-summary.html)  \n   * [(Legacy) Stitch Swift/iOS SDK](http://stitch-sdks.s3-website-us-east-1.amazonaws.com/stitch-sdks/swift/6/)  \n   * [(Legacy) Stitch React Native SDK](http://stitch-sdks.s3-website-us-east-1.amazonaws.com/stitch-sdks/js-react-native/4/index.html)  \n   * [(Legacy) Stitch JavaScript Server SDK](http://stitch-sdks.s3-website-us-east-1.amazonaws.com/stitch-sdks/js-server/4/index.html) [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/realm-legacy/index/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm (Legacy) Atlas App Services uses Realm Database version 10 and above. The documentation for earlier versions of Realm Database can be found on at [Realm documentation (legacy)](https://www.mongodb.com/docs/realm-legacy/docs/). [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/": " # Realm .NET SDK Use the Realm .NET SDK to develop client applications written in C# for .NET,[.NET MAUI](https://dotnet.microsoft.com/en-us/apps/maui),[UWP](https://docs.microsoft.com/en-us/windows/uwp/get-started/), [Xamarin](https://dotnet.microsoft.com/apps/xamarin), and [Unity.](https://unity.com/) Learning Paths ## Get Started with Realm .NET ![Functions Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_ATLAS_Functions3x.png) Quick Start Minimal-explanation code examples of how to work with Realm Database. [See Code Examples](https://www.mongodb.com/docs/realm/sdk/dotnet/quick-start/) ![Realm Mobile Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_Mobile3x.png) Working Example App Learn from example by dissecting a working Xamarin client app that uses Realm Database with Device Sync. [Explore an Example App](https://www.mongodb.com/docs/atlas/app-services/template-apps/) ![Tutorial Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Guided Tutorial Follow a guided tutorial to learn how to adapt the example app to create your own working Realm app. [Follow the Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/dotnet/) What You Can Do ## Develop Apps with Realm Database Essential Documentation ## Recommended Reading ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) .NET API Reference Explore generated reference docs for the Realm .NET APIs. [Realm .NET Reference](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/) ![Tutorial Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Integrate Realm with Unity Find out how to integrate Realm with your Unity project. [Install and Integrate Realm with Unity](https://www.mongodb.com/docs/realm/sdk/dotnet/unity/) ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) Check Out Releases See the latest releases, new features, and bug fixes. [See .NET Releases](https://github.com/realm/realm-dotnet/releases)",
  "https://www.mongodb.com/docs/realm/web/mongodb/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query MongoDB - Web SDK On this page * [Prerequisites](#prerequisites)\n* [Set Up Your Project](#set-up-your-project)\n* [Set Up Your Project](#set-up-your-project-1)\n* [Link a MongoDB Atlas Service Cluster](#link-a-mongodb-atlas-service-cluster)\n* [Import Realm Dependencies](#import-realm-dependencies)\n* [Instantiate a MongoDB Collection Handle](#instantiate-a-mongodb-collection-handle)\n* [Example Data](#example-data)\n* [Create Documents](#create-documents)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Read Documents](#read-documents)\n* [Find a Single Document](#find-a-single-document)\n* [Find Multiple Documents](#find-multiple-documents)\n* [Count Documents in the Collection](#count-documents-in-the-collection)\n* [Update Documents](#update-documents)\n* [Update a Single Document](#update-a-single-document)\n* [Update Multiple Documents](#update-multiple-documents)\n* [Upsert Documents](#upsert-documents)\n* [Delete Documents](#delete-documents)\n* [Delete a Single Document](#delete-a-single-document)\n* [Delete Multiple Documents](#delete-multiple-documents)\n* [Watch for Changes](#watch-for-changes)\n* [Watch for Changes in a Collection](#watch-for-changes-in-a-collection)\n* [Watch for Changes in a Collection with a Filter](#watch-for-changes-in-a-collection-with-a-filter)\n* [Aggregate Documents](#aggregate-documents)\n* [Aggregate Documents in a Collection](#aggregate-documents-in-a-collection)\n* [Aggregation Stages](#aggregation-stages)\n* [Filter Documents](#filter-documents)\n* [Group Documents](#group-documents)\n* [Project Document Fields](#project-document-fields)\n* [Add Fields to Documents](#add-fields-to-documents)\n* [Unwind Array Values](#unwind-array-values) You can query data stored in MongoDB Atlas directly from your client application code by using the Realm Web SDK's [MongoDB client](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm-MongoDB.html)with the [Query API](https://www.mongodb.com/docs/manual/tutorial/query-documents/). Atlas App Services provides data access [rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) on collections to securely retrieve results based on the logged-in user or the content of each document. The following actions let you query a linked MongoDB Atlas cluster from a Web app using the Realm Web SDK. ## Note Each operation described on this page uses a **query** to match certain documents in the collection upon which the operation executes. When a filter matches multiple documents in a collection, they are returned in an [indeterminate order](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/#return-in-natural-order) unless you specify a sorting parameter. This means that if you do not specify a sort for the `findOne()`, `updateOne()`, or `deleteOne()`functions, your operation could match _any_ document that matches the query. For more information on sorting, see[cursor.sort().](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/) ## Prerequisites\n\n ## Set Up Your Project 1 ### Set Up Your Project Follow the steps in the [Install Realm for Web](https://mongodb.com/docs/realm/web/quickstart/#std-label-web-quickstart-install)guide. 2 ### Link a MongoDB Atlas Service Cluster Follow the steps in the [Link a Data Source](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-link-a-data-source) guide. Assign your service a meaningful name -- you'll need it to connect to the cluster using the Realm SDK. 3 ### Import Realm Dependencies At the top of your source files where you want to use Realm, add the following code to import the SDK and BSON ObjectId constructor. `| import * as Realm from \"realm-web\"; |\n| ----------------------------------- |\n| const {                             |\n| BSON: { ObjectId },                 |\n| } = Realm;                          | ` 4 ### Instantiate a MongoDB Collection Handle To access a collection, create MongoDB service handle for the user that you wish to access the collection with: ```javascript const mongo = app.currentUser.mongoClient(DATA_SOURCE_NAME); const collection = mongo.db(DATABASE_NAME).collection(COLLECTION_NAME); \n``` ## Example Data The examples on this page use the following MongoDB collection that describes various plants for sale in a chain of plant stores: ```javascript {   _id: ObjectId(\"5f87976b7b800b285345a8b4\"),   name: \"venus flytrap\",   sunlight: \"full\",   color: \"white\",   type: \"perennial\",   _partition: \"Store 42\", }, {   _id: ObjectId(\"5f87976b7b800b285345a8b5\"),   name: \"sweet basil\",   sunlight: \"partial\",   color: \"green\",   type: \"annual\",   _partition: \"Store 42\", }, {   _id: ObjectId(\"5f87976b7b800b285345a8b6\"),   name: \"thai basil\",   sunlight: \"partial\",   color: \"green\",   type: \"perennial\",   _partition: \"Store 42\", }, {   _id: ObjectId(\"5f87976b7b800b285345a8b7\"),   name: \"helianthus\",   sunlight: \"full\",   color: \"yellow\",   type: \"annual\",   _partition: \"Store 42\", }, {   _id: ObjectId(\"5f87976b7b800b285345a8b8\"),   name: \"petunia\",   sunlight: \"full\",   color: \"purple\",   type: \"annual\",   _partition: \"Store 47\", }, \n``` ## Create Documents These code snippets demonstrate how to insert one or more documents into a MongoDB collection from a web app. Insert operations take a document or documents to add to MongoDB as an argument and return a[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to an object that contains the results of the execution of the operation. ### Insert a Single Document You can insert a single document by calling [collection.insertOne().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#insertOne) The following snippet inserts a single document describing a \"lily of the valley\" plant into a[collection of documents that describe plants for sale in a group of stores:](#std-label-web-mongodb-example-dataset) ```javascript const result = await plants.insertOne({   name: \"lily of the valley\",   sunlight: \"full\",   color: \"white\",   type: \"perennial\",   _partition: \"Store 47\", }); console.log(result); \n``` Running this snippet produces output resembling the following: ```javascript\n\n \n``` ### Insert Multiple Documents You can insert multiple documents at the same time using[collection.insertMany().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#insertMany) The following snippet inserts three documents describing plants into a[collection of documents that describe plants for sale in a group of stores:](#std-label-web-mongodb-example-dataset) ```javascript const result = await plants.insertMany([   {     name: \"rhubarb\",     sunlight: \"full\",     color: \"red\",     type: \"perennial\",     _partition: \"Store 47\",   },   {     name: \"wisteria lilac\",     sunlight: \"partial\",     color: \"purple\",     type: \"perennial\",     _partition: \"Store 42\",   },   {     name: \"daffodil\",     sunlight: \"full\",     color: \"yellow\",     type: \"perennial\",     _partition: \"Store 42\",   }, ]); console.log(result); \n``` Running this snippet produces output resembling the following: ```javascript {   insertedIds: [     ObjectId(\"5f87a0defc9013565c233611\"),     ObjectId(\"5f87a0defc9013565c233612\"),     ObjectId(\"5f87a0defc9013565c233613\"),   ], } \n``` ## Read Documents These code snippets demonstrate how to read data stored in a MongoDB collection from a mobile application. Read operations use [query filters](https://www.mongodb.com/docs/manual/core/document/#document-query-filter) to specify which documents to return from the database. Read operations return a[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to one of the following: a single matched document (in the case of`findOne()`), a numeric value (in the case of `count()`) or an array of matched documents (in the case of `find()`). ### Find a Single Document You can find a single document using [collection.findOne().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#findOne) The following snippet finds the document that describes venus flytraps in the[collection of documents that describe plants for sale in a group of stores:](#std-label-web-mongodb-example-dataset) ```javascript const venusFlytrap = await plants.findOne({ name: \"venus flytrap\" }); console.log(\"venusFlytrap\", venusFlytrap); \n``` Running this snippet produces output resembling the following: ```javascript {   _id: ObjectId(\"5f87976b7b800b285345a8b4\"),   name: \"venus flytrap\",   sunlight: \"full\",   color: \"white\",   type: \"perennial\",   _partition: \"Store 42\", } \n``` ### Find Multiple Documents You can find multiple documents using [collection.find().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#find) The following snippet finds all documents in a[collection of documents that describe plants for sale in a group of stores](#std-label-web-mongodb-example-dataset) that contain a field named`type` with a value of \"perennial\": ```javascript const perennials = await plants.find({ type: \"perennial\" }); console.log(\"perennials\", perennials); \n``` Running this snippet produces output resembling the following: ```javascript [   {     _id: ObjectId(\"5f87976b7b800b285345a8b4\"),     name: \"venus flytrap\",     sunlight: \"full\",     color: \"white\",     type: \"perennial\",     _partition: \"Store 42\",   },   {\n\n     name: \"thai basil\",     sunlight: \"partial\",     color: \"green\",     type: \"perennial\",     _partition: \"Store 42\",   }, ] \n``` You **cannot** use the `.skip()` operator with the Realm SDK. To paginate results, you can use range queries with the `.sort()` and `.limit()`, as described in [Using Range Queries](https://www.mongodb.com/docs/manual/reference/method/cursor.skip/#pagination-example)documentation in the MongoDB Manual. ### Count Documents in the Collection You can count documents in a collection using[collection.count()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#count). You can specify an optional query to determine which documents to count. If you don't specify a query, the action counts all documents in the collection. The following snippet counts the number of documents in a[collection of documents that describe plants for sale in a group of stores:](#std-label-web-mongodb-example-dataset) ```javascript const numPlants = await plants.count(); console.log(`There are ${numPlants} plants in the collection`); \n``` Running this snippet produces output resembling the following: ```javascript \"There are 5 plants in the collection\" \n``` ## Update Documents These code snippets demonstrate how to update data stored in a MongoDB collection from a mobile application. Update operations use queries to specify which documents to update and [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) to describe how to mutate documents that match the query. Update operations return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to an object that contains the results of the execution of the operation. ### Update a Single Document You can update a single document using[collection.updateOne().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#updateOne) The following snippet updates a single document in a[collection of documents that describe plants for sale in a group of stores](#std-label-web-mongodb-example-dataset). This operation queries for a document where the `name` field contains the value \"petunia\" and changes the value of the first matched document's `sunlight` field to \"partial\": ```javascript const result = await plants.updateOne(   { name: \"petunia\" },   { $set: { sunlight: \"partial\" } } ); console.log(result); \n``` Running this snippet produces output resembling the following: ```javascript { matchedCount: 1, modifiedCount: 1 } \n``` ### Update Multiple Documents You can update a single document using[collection.updateMany().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#updateMany) The following snippet updates multiple documents in a[collection of documents that describe plants for sale in a group of stores](#std-label-web-mongodb-example-dataset). This operation queries for documents where the `_partition` field contains the value \"Store 42\" and changes the value of the `_partition` field of each matching document to \"Store 51\": ```javascript const result = await plants.updateMany(   { _partition: \"Store 42\" },   { $set: { _partition: \"Store 51\" } } ); console.log(result); \n``` Running this snippet produces output resembling the following: ```javascript { matchedCount: 4, modifiedCount: 4 } \n``` ### Upsert Documents If an update operation does not match any document in the collection, you can automatically insert a single new document into the collection that matches the update query by setting the `upsert` option to`true`. The following snippet updates a document in a[collection of documents that describe plants for sale in a group of stores](#std-label-web-mongodb-example-dataset) or inserts a new document if no document matches the query. This operation queries for documents where:\n\n Because this snippet sets the `upsert` option to `true`, if no document matches the query, MongoDB creates a new document that includes both the query and specified updates: ```javascript const result = await plants.updateOne(   {     sunlight: \"full\",     type: \"perennial\",     color: \"green\",     _partition: \"Store 47\",   },   { $set: { name: \"super sweet basil\" } },   { upsert: true } ); console.log(result); \n``` Running this snippet produces output resembling the following: ```javascript {   matchedCount: 0,   modifiedCount: 0,   upsertedId: ObjectId(\"5f1f63055512f2cb67f460a3\"), }  \n``` ## Delete Documents These code snippets demonstrate how to delete documents that are stored in a MongoDB collection from a mobile application. Delete operations use a query to specify which documents to delete and return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise)that resolves to an object that contains the results of the execution of the operation. ### Delete a Single Document You can delete a single document from a collection using[collection.deleteOne().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#deleteOne) The following snippet deletes one document in a[collection of documents that describe plants for sale in a group of stores](#std-label-web-mongodb-example-dataset). This operation queries for a document where the `color` field has a value of \"green\" and deletes the first document that matches the query: ```javascript const result = await plants.deleteOne({ color: \"green\" }); console.log(result); \n``` Running this snippet produces output resembling the following: ```javascript { deletedCount: 1 } \n``` ### Delete Multiple Documents You can delete multiple items from a collection using[collection.deleteMany().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#deleteMany) The following snippet deletes all documents for plants that are in \"Store 42\" in a [collection of documents that describe plants for sale in a group of stores:](#std-label-web-mongodb-example-dataset) ```javascript const result = await plants.deleteMany({   _partition: \"Store 42\", }); console.log(result); \n``` Running this snippet produces output resembling the following: ```javascript { deletedCount: 4 } \n``` ## Watch for Changes You can call [collection.watch()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#watch) to subscribe to real-time[notification events](https://www.mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-events) whenever a document in the collection is added, modified, or deleted. Each notification specifies a document that changed, how it changed, and the full document after the operation that caused the event. ## Important ### Serverless Limitations You cannot watch for changes if the data source is an Atlas serverless instance. MongoDB serverless currently does not support change streams, which are used on watched collections to listen for changes. Atlas App Services uses MongoDB [change streams](https://www.mongodb.com/docs/manual/changeStreams/) on watched collections to listen for changes and broadcasts notifications to subscribed client applications. This is useful for cases where you want to know when something happened while a user is online. For example: * Track the location of a delivery\n* Get the most up-to-date score and stats for a game\n* Update a chat thread when a user sends a new message ## Note `collection.watch()` returns an [async generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of#Iterating%5Fover%5Fasync%5Fgenerators)that allows you to asynchronously pull [change events](https://www.mongodb.com/docs/manual/reference/change-events/) for operations as they occur.\n\n To watch for all changes in a collection, call [collection.watch()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#watch) without any arguments: ```javascript for await (const change of plants.watch()) {   let breakAsyncIterator = false; // Later used to exit async iterator   switch (change.operationType) {     case \"insert\": {       const { documentKey, fullDocument } = change;       console.log(`new document: ${documentKey}`, fullDocument);       breakAsyncIterator = true;       break;     }     case \"update\": {       const { documentKey, fullDocument } = change;       console.log(`updated document: ${documentKey}`, fullDocument);       breakAsyncIterator = true;       break;     }     case \"replace\": {       const { documentKey, fullDocument } = change;       console.log(`replaced document: ${documentKey}`, fullDocument);       breakAsyncIterator = true;       break;     }     case \"delete\": {       const { documentKey } = change;       console.log(`deleted document: ${documentKey}`);       breakAsyncIterator = true;       break;     }   }   if (breakAsyncIterator) break; // Exit async iterator } \n``` ### Watch for Changes in a Collection with a Filter To watch for specific changes in a collection, call [collection.watch()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#watch) with a query that specifies change event values to watch: ```javascript for await (const change of plants.watch({   filter: {     operationType: \"update\",     \"fullDocument.type\": \"perennial\",   }, })) {   // The change event will always represent a newly inserted perennial   const { documentKey, fullDocument } = change;   console.log(`new document: ${documentKey}`, fullDocument);   break; // Exit async iterator } \n``` ## Aggregate Documents Aggregation operations run all documents in a collection through a series of stages called an [aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/). Aggregation allows you to filter and transform documents, collect summary data about groups of related documents, and other complex data operations. Aggregation operations accept a list of aggregation stages as input, and return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a collection of documents processed by the pipeline. ### Aggregate Documents in a Collection You can execute an aggregation pipeline using[collection.aggregate().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#aggregate) The following snippet groups all documents in the `plants`collection by their `type` value and aggregates a count of the number of each type: ```javascript const result = await plants.aggregate([   {     $group: {       _id: \"$type\",       total: { $sum: 1 },     },   },   { $sort: { _id: 1 } }, ]); console.log(result); \n``` Running this snippet produces output resembling the following: ```javascript [   { _id: \"annual\", total: 3 },   { _id: \"perennial\", total: 2 }, ] \n``` ## Aggregation Stages ### Filter Documents You can use the [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) stage to filter documents according to standard MongoDB [query syntax.](https://www.mongodb.com/docs/manual/tutorial/query-documents/) ```javascript {   \"$match\": {     \"<Field Name>\": <Query Expression>,     ...   }\n\n \n``` ## Example The following `$match` stage filters documents to include only those where the `type` field has a value equal to \"perennial\": ```js const perennials = await plants.aggregate([   { $match: { type: { $eq: \"perennial\" } } }, ]); console.log(perennials); \n``` VIEW OUTPUT ### Group Documents You can use the [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/) stage to aggregate summary data for one or more documents. MongoDB groups documents based on the expression defined in the `_id` field of the `$group` stage. You can reference a specific document field by prefixing the field name with a `$`. ```javascript {   \"$group\": {     \"_id\": <Group By Expression>,     \"<Field Name>\": <Aggregation Expression>,     ...   } } \n``` ## Example The following `$group` stage arranges documents by the value of their`type` field and calculates the number of plant documents that each unique `type` value appears in. ```js const result = await plants.aggregate([   {     $group: {       _id: \"$type\",       numItems: { $sum: 1 },     },   },   { $sort: { _id: 1 } }, ]); console.log(result); \n``` VIEW OUTPUT ### Project Document Fields You can use the [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) stage to include or omit specific fields from documents or to calculate new fields using[aggregation operators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). Projections work in two ways: * Explicitly include fields with a value of 1\\. This has the side-effect of implicitly excluding all unspecified fields.\n* Implicitly exclude fields with a value of 0\\. This has the side-effect of implicitly including all unspecified fields. These two methods of projection are mutually exclusive: if you explicitly include fields, you cannot explicitly exclude fields, and vice versa. ## Note The `_id` field is a special case: it is always included in every query unless explicitly specified otherwise. For this reason, you_can_ exclude the `_id` field with a `0` value while simultaneously including other fields, like `_partition`, with a `1`. Only the special case of exclusion of the `_id` field allows both exclusion and inclusion in one `$project` stage. ```javascript {   \"$project\": {     \"<Field Name>\": <0 | 1 | Expression>,     ...   } } \n``` ## Example The following `$project` stage omits the `_id` field, includes the `name` field, and creates a new field named `storeNumber`. The `storeNumber` is generated using two aggregation operators: 1. `$split` separates the `_partition` value into two string segments surrounding the space character. For example, the value \"Store 42\" split in this way returns an array with two elements: \"Store\" and \"42\".\n2. `$arrayElemAt` selects a specific element from an array based on the second argument. In this case, the value `1` selects the second element from the array generated by the `$split` operator since arrays index from `0`. For example, the value \\[\"Store\", \"42\"\\] passed to this operation would return a value of \"42\". ```js const result = await plants.aggregate([   {     $project: {       _id: 0,       name: 1,       storeNumber: {         $arrayElemAt: [{ $split: [\"$_partition\", \" \"] }, 1],       },     },   }, ]); console.log(result); \n``` VIEW OUTPUT ### Add Fields to Documents You can use the [$addFields](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/) stage to add new fields with calculated values using [aggregation operators.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/) ```javascript { $addFields: { <newField>: <expression>, ... } } \n``` ## Note\n\n ## Example The following `$addFields` stage creates a new field named`storeNumber` where the value is the output of two aggregate operators that transform the value of the `_partition` field. ```js const result = await plants.aggregate([   {     $addFields: {       storeNumber: {         $arrayElemAt: [{ $split: [\"$_partition\", \" \"] }, 1],       },     },   }, ]); console.log(result); \n``` VIEW OUTPUT ### Unwind Array Values You can use the [$unwind](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/) stage to transform a single document containing an array into multiple documents containing individual values from that array. When you unwind an array field, MongoDB copies each document once for each element of the array field but replaces the array value with the array element in each copy. ```javascript {   $unwind: {     path: <Array Field Path>,     includeArrayIndex: <string>,     preserveNullAndEmptyArrays: <boolean>   } } \n``` ## Example The following example uses the `$unwind` stage for each object's `type` and `color`combination. The aggregation pipeline has the following steps: 1. Use `$group` stage with `$addToSet` to create new documents for each `type` with a new field `colors` that contains an array of all the the colors for that flower type that occur in the collection.\n2. Use `$unwind` stage to create separate documents for each combination of type and color.\n3. Use `$sort` stage to sort the results in alphabetical order. ```js const result = await plants.aggregate([   { $group: { _id: \"$type\", colors: { $addToSet: \"$color\" } } },   { $unwind: { path: \"$colors\" } },   { $sort: { _id: 1, colors: 1 } }, ]); console.log(result); \n``` VIEW OUTPUT ← [Create & Manage User API Keys - Web SDK](https://mongodb.com/docs/realm/web/create-manage-api-keys/ \"Previous Section\")[Apollo Client (React) - Web SDK](https://mongodb.com/docs/realm/web/graphql-apollo-react/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/web/authenticate/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate a User - Web SDK On this page * [Overview](#overview)\n* [Log In](#log-in)\n* [Anonymous](#anonymous)\n* [Email/Password](#email-password)\n* [API Key](#api-key)\n* [Custom Function](#custom-function)\n* [Custom JWT](#custom-jwt)\n* [Facebook Authentication](#facebook-authentication)\n* [Google Authentication](#google-authentication)\n* [Apple Authentication](#apple-authentication)\n* [Get a User Access Token](#get-a-user-access-token)\n* [Log Out](#log-out) ## Overview The Web SDK provides developers with a unified API to authenticate application users for any authentication provider. Users log in by providing authentication credentials for a given authentication provider and the SDK automatically manages authentication tokens and refreshes data for logged in users. ## Log In ### Anonymous The [Anonymous](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) provider allows users to log in to your application with ephemeral accounts that have no associated information. To log in, create an anonymous credential and pass it to `App.logIn()`: `` | async function loginAnonymous() {                        |\n| -------------------------------------------------------- |\n| // Create an anonymous credential                        |\n| const credentials = Realm.Credentials.anonymous();       |\n| // Authenticate the user                                 |\n| const user = await app.logIn(credentials);               |\n| // `App.currentUser` updates to match the logged in user |\n| console.assert(user.id === app.currentUser.id);          |\n| return user;                                             |\n| }                                                        |\n| const user = await loginAnonymous();                     |  `` ### Email/Password The [email/password](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) authentication provider allows users to log in to your application with an email address and a password. To log in, create an email/password credential with the user's email address and password and pass it to `App.logIn()`: ```javascript async function loginEmailPassword(email, password) {   // Create an email/password credential   const credentials = Realm.Credentials.emailPassword(email, password);   // Authenticate the user   const user = await app.logIn(credentials);   // `App.currentUser` updates to match the logged in user   console.assert(user.id === app.currentUser.id);   return user; } const user = await loginEmailPassword(\"joe.jasper@example.com\", \"passw0rd\"); \n``` ### API Key The [API key](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication) authentication provider allows server processes to access your app directly or on behalf of a user. To log in with an API key, create an API Key credential with a server or user API key and pass it to `App.logIn()`: ```javascript async function loginApiKey(apiKey) {   // Create an API Key credential\n\n   // Authenticate the user   const user = await app.logIn(credentials);   // `App.currentUser` updates to match the logged in user   console.assert(user.id === app.currentUser.id);   return user; } const user = await loginApiKey(REALM_API_KEY.key); // add previously generated API key \n``` ### Custom Function The [Custom Function](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication) authentication provider allows you to handle user authentication by running a [function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) that receives a payload of arbitrary information about a user. To log in with the custom function provider, create a Custom Function credential with a payload object and pass it to `App.logIn()`: ```javascript async function loginCustomFunction(payload) {   // Create a Custom Function credential   const credentials = Realm.Credentials.function(payload);   // Authenticate the user   const user = await app.logIn(credentials);   // `App.currentUser` updates to match the logged in user   console.assert(user.id === app.currentUser.id);   return user; } const user = await loginCustomFunction({ username: \"ilovemongodb\" }); \n``` ### Custom JWT The [Custom JWT](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) authentication provider allows you to handle user authentication with any authentication system that returns a[JSON web token.](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-json-web-tokens) To log in, create a Custom JWT credential with a JWT from the external system and pass it to `App.logIn()`: ```javascript async function loginCustomJwt(jwt) {   // Create a Custom JWT credential   const credentials = Realm.Credentials.jwt(jwt);   // Authenticate the user   const user = await app.logIn(credentials);   // `App.currentUser` updates to match the logged in user   console.assert(user.id === app.currentUser.id);   return user; } const user = await loginCustomJwt(\"eyJ0eXAi...Q3NJmnU8oP3YkZ8\"); \n``` ### Facebook Authentication The [Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) authentication provider allows you to authenticate users through a Facebook app using their existing Facebook account. You can use the [built-in authentication flow](#std-label-web-facebook-builtin) or [authenticate with the Facebook SDK.](#std-label-web-facebook-auth-token) ## Important ### Enable the Facebook Auth Provider To log a user in with their existing Facebook account, you must configure and enable the [Facebook authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication)for your application. ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. #### Use the Built-In Facebook OAuth 2.0 Flow The Realm Web SDK includes methods to handle the OAuth 2.0 process and does not require you to install the Facebook SDK. The built in flow follows three main steps:\n\n #### Authenticate with the Facebook SDK You can use the [official Facebook SDK](https://developers.facebook.com/docs/facebook-login/web/) to handle the user authentication and redirect flow. Once authenticated, the Facebook SDK returns an access token that you can use to finish logging the user in to your app. ```javascript // Get the access token from the Facebook SDK const { accessToken } = FB.getAuthResponse(); // Define credentials with the access token from the Facebook SDK const credentials = Realm.Credentials.facebook(accessToken); // Log the user in to your app await app.logIn(credentials); \n``` ### Google Authentication The [Google](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication) authentication provider allows you to authenticate users through a Google project using their existing Google account. ## Note ### Enable the Google Auth Provider To authenticate a Google user, you must configure the [Google authentication provider.](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication) Logging a Google user in to your App is a two step process: 1. First, you authenticate the user with Google. You can use a library like[Google One Tap](https://developers.google.com/identity/one-tap/web/guides/get-google-api-clientid) for a streamlined experience.\n2. Second, you log the user in to your App with an authentication token returned by Google upon successful user authentication. #### Authenticate with Google One Tap ## Note ### Requires OpenID Connect Google One Tap only supports user authentication through OpenID Connect. To log Google users in to your web app, you must [enable OpenID Connect](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-openIdConnect) in the App Services authentication provider configuration. [Google One Tap](https://developers.google.com/identity/one-tap/web/guides/get-google-api-clientid)is a Google SDK that lets users sign up to or log in to a website with one click (or tap). ## Example ### Basic Google One Tap Flow This example shows how to set up Google Authentication with App Services in a very basic web app. The app only contains an `index.html` file. index.html ``` <!DOCTYPE html> <html lang=\"en\">   <head>     <title>Google One Tap Example</title>   </head>   <body>     <h1>Google One Tap Example</h1>     <!-- The data-callback HTML attribute sets the callback function that is run       when the user logs in. Here we're calling the handleCredentialsResponse JavaScript       function defined in the below script section to log the user into App Services.     -->     <div       id=\"g_id_onload\"       data-client_id=\"<your_google_client_id>\"       data-callback=\"handleCredentialsResponse\"     ></div>   </body>   <!-- Load Atlas App Services -->   <script src=\"https://unpkg.com/realm-web/dist/bundle.iife.js\"></script>   <!-- Load Google One Tap -->   <script src=\"https://accounts.google.com/gsi/client\"></script>   <!-- Log in with Realm and Google Authentication -->   <script async defer>     const app = new Realm.App({       id: \"<your_realm_app_id>\",     });     // Callback used in `data-callback` to handle Google's response and log user into App Services     function handleCredentialsResponse(response) {       const credentials = Realm.Credentials.google({ id_token: response.credential });       app         .logIn(credentials)         .then((user) => alert(`Logged in with id: ${user.id}`));     }   </script> </html> \n``` #### Use the Built-In Google OAuth 2.0 Flow ## Note ### Do Not Use OpenID Connect for Built-In Google OAuth 2.0 Flow\n\n built-in Google OAuth 2.0 flow. If you'd like to use OpenID Connect with the Realm Web SDK, use the[Authentication with Google One Tap](#std-label-web-google-onetap) flow. The Realm Web SDK includes methods to handle the OAuth 2.0 process and does not require you to install a Google SDK. The built-in flow follows three main steps: 1. Call `app.logIn()` with a Google credential. The credential must specify a URL for your app that is also listed as a redirect URI in the provider configuration.\n2. A new window opens to a Google authentication screen and the user authenticates and authorizes your app in that window. Once complete, the new window redirects to the URL specified in the credential.\n3. Call `Realm.handleAuthRedirect()` on the redirected page, which stores the user's App Services access token and closes the window. Your original app window will automatically detect the access token and finish logging the user in. ## Example ### Basic Web Login Flow This example shows how to set up Google Authentication with App Services in a very basic web app. The app has the following files: ``` . ├── auth.html └── index.html \n``` index.html ``` <!DOCTYPE html> <html lang=\"en\">   <head>     <title>Google Auth Example</title>   </head>   <body>     <h1>Google Auth Example</h1>     <button id=\"google-auth\">Authenticate!</button>   </body>   <!-- Load Realm -->   <script src=\"https://unpkg.com/realm-web/dist/bundle.iife.js\"></script>   <!-- Log in with App Services and Google Authentication -->   <script>     const app = new Realm.App({       id: \"<Your-App-ID>\",     });     const authButton = document.getElementById(\"google-auth\");     authButton.addEventListener(\"click\", () => {       // The redirect URL should be on the same domain as this app and       // specified in the auth provider configuration.       const redirectUrl = \"http://yourDomain/auth.html\";       const credentials = Realm.Credentials.google({ redirectUrl });       // Calling logIn() opens a Google authentication screen in a new window.       app         .logIn(credentials)         .then((user) => {           // The logIn() promise will not resolve until you call `handleAuthRedirect()`           // from the new window after the user has successfully authenticated.           console.log(`Logged in with id: ${user.id}`);         })         .catch((err) => console.error(err));     });   </script> </html> \n``` auth.html ``` <!DOCTYPE html> <html lang=\"en\">   <head>     <title>Google Auth Redirect</title>   </head>   <body>     <p>Redirects come here for Google Authentication</p>   </body>   <script>     Realm.handleAuthRedirect();   </script> </html> \n``` ## Important ### Built-In OAuth 2.0 Redirect Limitations for Google Due to changes in OAuth application verification requirements, the built-in OAuth 2.0 process faces limitations when authenticating [Google](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication) users. If you use the Google login redirect flow using App Services' redirect flow, a maximum of 100 Google users may authenticate while the app is in development/testing/staging and all users will see an unverified application notification before they authenticate. To avoid these limitations, we advise that you use an official Google SDK to get a user access token as described above. ### Apple Authentication\n\n ## Note ### Enable the Apple Auth Provider To authenticate an Apple user, you must configure the [Apple authentication provider.](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication) #### Use the Built-In Apple OAuth 2.0 Flow The Realm Web SDK includes methods to handle the OAuth 2.0 process and does not require you to install the Apple JS SDK. The built in flow follows three main steps: 1. You call `app.logIn()` with an Apple credential. The credential must specify a URL for your app that is also listed as a redirect URI in the provider configuration.  \n```javascript  \n// The redirect URI should be on the same domain as this app and  \n// specified in the auth provider configuration.  \nconst redirectUri = \"https://app.example.com/handleOAuthLogin\";  \nconst credentials = Realm.Credentials.apple(redirectUri);  \n// Calling logIn() opens an Apple authentication screen in a new window.  \nconst user = app.logIn(credentials);  \n// The logIn() promise will not resolve until you call `Realm.handleAuthRedirect()`  \n// from the new window after the user has successfully authenticated.  \nconsole.log(`Logged in with id: ${user.id}`);  \n```\n2. A new window opens to an Apple authentication screen and the user authenticates and authorizes your app in that window. Once complete, the new window redirects to the URL specified in the credential.\n3. You call `Realm.handleAuthRedirect()` on the redirected page, which stores the user's App Services access token and closes the window. Your original app window will automatically detect the access token and finish logging the user in.  \n```javascript  \n// When the user is redirected back to your app, handle the redirect to  \n// save the user's access token and close the redirect window. This  \n// returns focus to the original application window and automatically  \n// logs the user in.  \nRealm.handleAuthRedirect();  \n``` #### Authenticate with the Apple SDK You can use the [official Sign in with Apple JS SDK](https://developer.apple.com/documentation/sign%5Fin%5Fwith%5Fapple/sign%5Fin%5Fwith%5Fapple%5Fjs) to handle the user authentication and redirect flow. Once authenticated, the Apple JS SDK returns an ID token that you can use to finish logging the user in to your app. ```javascript // Get the ID token from the Apple SDK const { id_token } = await AppleID.auth.signIn(); // Define credentials with the ID token from the Apple SDK const credentials = Realm.Credentials.apple(id_token); // Log the user in to your app const user = await app.logIn(credentials); \n``` ## Tip If you get a `Login failed` error saying that the `token contains an invalid number of segments`, verify that you're passing a UTF-8-encoded string version of the JWT. ## Get a User Access Token When a user logs in, Atlas App Services creates an access token for the user that grants them access to your App. The Realm SDK automatically manages access tokens, refreshes them when they expire, and includes a valid access token for the current user with each request. If you send requests outside of the SDK (for example, through the GraphQL API) then you need to include the user's access token with each request, and manually refresh the token when it expires. You can access and refresh a logged in user's access token in the SDK from their`Realm.User` object, as in the following example: ```javascript // Gets a valid user access token to authenticate requests async function getValidAccessToken(user) {   // An already logged in user's access token might be stale. To   // guarantee that the token is valid, refresh it if necessary.   await user.refreshAccessToken();   return user.accessToken; } \n``` ## Log Out To log any user out, call the `User.logOut()` on their user instance. Log out current user: ```javascript await app.currentUser.logOut(); \n``` Log out user by user ID: ```javascript const userId = app.currentUser.id; await app.allUsers[userId].logOut(); \n```\n\n",
  "https://www.mongodb.com/docs/realm/sdk/node/": " # Realm Node.js SDK The Realm Node.js SDK allows you to use Realm Database and Atlas App Services from Node.js applications written in JavaScript or TypeScript. Use the Node.js SDK to build for server applications, desktop applications, CLIs, IoT programs, and more. The Node.js SDK does not support applications written for web browsers. For Web apps, use the [Realm Web SDK](https://mongodb.com/docs/realm/web/#std-label-web-intro). For React Native development, use the [Realm React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/#std-label-react-native-intro) To get started with the Node.js SDK, see [Quick Start.](https://mongodb.com/docs/realm/sdk/node/quick-start/#std-label-node-client-quick-start) What You Can Do ## Develop Apps with Realm Essential Documentation ## Recommended Reading ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_ACTION_BestPractices3x.png) JavaScript API Reference Explore generated reference docs for the Node.js SDK. [Node.js Reference](https://www.mongodb.com/docs/realm-sdks/js/latest/) ![Electron Icon](https://mongodb.com/docs/realm/images/icons/electron_logo.png) Electron Integration Guide Use the Realm Node.js SDK in an Electron desktop application. [Use Realm with Electron apps](https://www.mongodb.com/docs/realm/sdk/node/integrations/electron/)",
  "https://www.mongodb.com/docs/realm/sdk/cpp/": " # C++ SDK (Alpha) Use the Realm C++ SDK to write applications in C++ that access data stored in realms and sync data with Atlas. ## Alpha SDK This SDK is currently offered as an **alpha** release. We encourage you to try out the features and [give feedback](https://feedback.mongodb.com/forums/923521-realm/). However, be aware that APIs and functionality are subject to change. The C++ SDK does not yet support all Realm database features or Atlas App Services integrations. What You Can Do ## Develop Apps with Realm Database Use free open-source Realm Database as a local object store on a device. Use Device Sync to keep data in sync with your MongoDB Atlas cluster and other clients. Essential Documentation ## Recommended Reading ![Functions Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_ATLAS_Functions3x.png) Quick Start Minimal-explanation code examples of how to work with Realm Database. [See Code Examples](https://www.mongodb.com/docs/realm/sdk/cpp/quick-start/) ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) C++ API Reference Explore generated Doxygen reference docs for the Realm C++ APIs. [C++ SDK Reference](https://www.mongodb.com/docs/realm-sdks/cpp/latest) ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) C++ SDK on GitHub Explore the Realm C++ SDK on GitHub. [C++ SDK Repository](https://github.com/realm/realm-cpp)",
  "https://www.mongodb.com/docs/realm/sdk/flutter/": " # Realm Flutter SDK The Realm Flutter SDK enables client applications written in[Dart](https://dart.dev/) for the [Flutter](https://flutter.dev/)platform to access data stored in realms, sync data with Atlas, and use Atlas App Services. Learning Paths ## Get Started with Realm Flutter ![Functions Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_ATLAS_Functions3x.png) Quick Start Minimal-explanation code examples of how to work with the Realm Flutter SDK. [See Code Examples](https://www.mongodb.com/docs/realm/sdk/flutter/quick-start/) ![Realm Mobile Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_Mobile3x.png) Working Example App Learn by example through dissecting a working app that uses the Realm Flutter SDK and Atlas Device Sync. [Explore an Example App](https://www.mongodb.com/docs/atlas/app-services/template-apps/) ![Tutorial Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Guided Tutorial Follow a guided tutorial to learn how to adapt the example app to create your own working Flutter app with Realm and Atlas Device Sync. [Follow the Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/flutter/) What You Can Do ## Develop Apps with the Realm Flutter SDK Essential Documentation ## Recommended Reading ![Reference Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Realm Flutter Reference Explore reference docs for the Realm Dart and Flutter on pub.dev. [Realm Flutter Reference](https://pub.dev/documentation/realm/latest/) ![Flutter Logo Icon](https://mongodb.com/docs/realm/images/icons/flutter.svg) Install Realm Flutter Learn how to add the Realm SDK to your Flutter project. [Add Realm to Flutter project](https://www.mongodb.com/docs/realm/sdk/flutter/install/) ## Dart Standalone Realm In addition to using Realm with Flutter, you can also use Realm with projects that just use Dart, like a CLI application or web server. The usage for Realm with Dart is the same as the Flutter SDK, except you must install and set up a separate package. [Learn how to set up Realm in your Dart project.](https://mongodb.com/docs/realm/sdk/flutter/install/#std-label-dart-install-steps)",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/": " # Realm Kotlin SDK Use the Realm Kotlin SDK to develop Android or iOS apps using the Android platform or Kotlin Multiplatform Mobile (KMM). Learning Paths ## Get Started with Realm Kotlin ![Functions Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_ATLAS_Functions3x.png) Quick Start Minimal-explanation code examples of how to work with Realm Database. [See Code Examples](https://www.mongodb.com/docs/realm/sdk/kotlin/quick-start/) ![Realm Mobile Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_Mobile3x.png) Working Example App Learn from example by dissecting a working Kotlin client app that uses Realm Database with Device Sync. [Explore an Example App](https://www.mongodb.com/docs/atlas/app-services/template-apps/) ![Tutorial Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Guided Tutorial Follow a guided tutorial to learn how to adapt the example app to create your own working Realm app. [Follow the Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/kotlin/) What You Can Do ## Develop Apps with Realm Database Use open-source Realm Database as a local object store on a device. Use Device Sync to keep data in sync with your MongoDB Atlas cluster and other clients. Essential Documentation ## Recommended Reading ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) Kotlin API Reference Explore generated reference docs for the Realm Kotlin APIs. [Realm Kotlin Reference](https://www.mongodb.com/docs/realm-sdks/kotlin/1.2.0/) ![Migrate Icon](https://mongodb.com/docs/realm/images/icons/realm/general-flexibility.png) Migrate from the Java SDK to the Kotlin SDK Learn why and how to switch from the Java SDK to the Kotlin SDK. [Migrate from Java SDK to Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/migrate-from-java-sdk-to-kotlin-sdk/)",
  "https://www.mongodb.com/docs/realm/sdk/swift/": " # Realm Swift SDK Use the Realm Swift SDK to develop iOS, macOS, watchOS and tvOS apps in Swift and Objective-C. Learning Paths ## Get Started with Realm Swift ![Functions Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_ATLAS_Functions3x.png) Quick Start Minimal-explanation code examples of how to work with Realm Database. [See Code Examples](https://www.mongodb.com/docs/realm/sdk/swift/quick-start/) ![Realm Mobile Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_Mobile3x.png) Working Example App Learn from example by dissecting a working SwiftUI client app that uses Realm Database with Device Sync. [Explore an Example App](https://www.mongodb.com/docs/atlas/app-services/template-apps/) ![Tutorial Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Guided Tutorial Follow a guided tutorial to learn how to adapt the example app to create your own working Realm app. [Follow the Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/swiftui/) What You Can Do ## Develop Apps with Realm Database Use free open-source Realm Database as a local object store on a device. Use Device Sync to keep data in sync with your MongoDB Atlas cluster and other clients. Essential Documentation ## Recommended Reading ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) Swift API Reference Explore generated reference docs for the RealmSwift APIs. [RealmSwift Reference](https://www.mongodb.com/docs/realm-sdks/swift/latest) ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) Objective-C API Reference Explore generated reference docs for the Realm Objective-C APIs. [Realm Reference](https://www.mongodb.com/docs/realm-sdks/objc/latest) ![Tutorial Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) SwiftUI Quick Start Get started with Realm Database for SwiftUI. [Explore the Quick Start](https://www.mongodb.com/docs/realm/sdk/swift/swiftui-tutorial)",
  "https://www.mongodb.com/docs/realm/sdk/java/": " # Realm Java SDK On this page * [Develop Apps with Realm Database](#develop-apps-with-realm-database)\n* [Install the Realm Java SDK](#install-the-realm-java-sdk)\n* [Define an Object Schema](#define-an-object-schema)\n* [Open a Realm](#open-a-realm)\n* [Read and Write Data](#read-and-write-data)\n* [React to Changes](#react-to-changes)\n* [Connect to an Atlas App Services App](#connect-to-an-atlas-app-services-app)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Read and Write Synced Data](#read-and-write-synced-data)\n* [Call Serverless Functions](#call-serverless-functions)\n* [Query MongoDB Atlas](#query-mongodb-atlas)\n* [Authenticate Users](#authenticate-users)\n* [Recommended Reading](#recommended-reading) Use the Realm Java SDK to develop Android apps in Java or Kotlin. To develop multiplatform apps using Kotlin Multiplatform Mobile, refer to the[Realm Kotlin SDK.](https://mongodb.com/docs/realm/sdk/kotlin/#std-label-kotlin-intro) What You Can Do ## Develop Apps with Realm Database Use free open-source Realm Database as a local object store on a device. Use Device Sync to keep data in sync with your MongoDB Atlas cluster and other clients. Essential Documentation ## Recommended Reading ![Tutorial Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Java Quick Start Get started with Realm Database for Java. [Explore the Quick Start](https://www.mongodb.com/docs/realm/sdk/java/quick-start-local/) ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) Java API Reference Explore generated reference docs for the Realm Java APIs. [Java API Reference](https://www.mongodb.com/docs/realm-sdks/java/latest/) ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_SDK3x.png) Kotlin Extensions API Reference Explore generated reference docs for the Kotlin Extensions APIs. [Kotlin Extensions Reference](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/)",
  "https://www.mongodb.com/docs/realm/sdk/cpp/manage-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Users - C++ SDK (Alpha) On this page * [Overview](#overview)\n* [Create and Delete Users](#create-and-delete-users)\n* [Log Users In and Out](#log-users-in-and-out)\n* [User Sessions](#user-sessions)\n* [Read and Update Custom User Data](#read-and-update-custom-user-data) ## Overview When you use Atlas App Services to back your client app, you get access to a[user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects). Use C++ SDK methods with this user object to conveniently: * Create and delete users\n* Log users in and out\n* Create and update custom user data ## Create and Delete Users For all authentication providers other than email/password authentication, App Services automatically creates a user object the first time a user authenticates. With email/password authentication, your app must manually register a user. The C++ SDK Alpha does not yet have the ability to delete users through the SDK. You can delete users from the server using the [App Services Admin API](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#std-label-admin-api) `delete a user` endpoints. You could optionally create an [Atlas Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) that uses the Admin API to delete a user, and [call the function from the SDK.](https://mongodb.com/docs/realm/sdk/cpp/app-services/call-a-function/#std-label-cpp-call-a-function) ## Log Users In and Out Use one or more [authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-auth-providers) to [log users in and out](https://mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-authenticate-users) of your client app. You can: * Log users in with an existing social account, such as Apple, Facebook, or Google.\n* Create new user accounts with App Services email/password management, or your own custom function or custom JWT user management.\n* Enable anonymous users to let users access your App Services App without persisting user data. When you have a logged-in user, SDK methods enable you to: * [Open a synced realm](https://mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/#std-label-cpp-open-synced-realm) with the user's configuration object\n* [Run a backend function](https://mongodb.com/docs/realm/sdk/cpp/app-services/call-a-function/#std-label-cpp-call-a-function) as the logged-in user\n* [Log the user out](https://mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-logout) On successful login, the C++ SDK caches credentials on the device. You can bypass the login flow and access the cached user. Use this to open a realm or call a function upon subsequent app opens. ### User Sessions App Services manages sessions with access tokens and refresh tokens. Client SDKs supply the logic to manage tokens, and provide them with requests. ## Tip ### See also:  [User Sessions](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) ## Read and Update Custom User Data You can [associate custom data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) with a user object, such as a preferred language or local timezone, and read it from your client application. A user object has a `customData` property that you can use to [access custom user data.](https://mongodb.com/docs/realm/sdk/cpp/users/custom-user-data/#std-label-cpp-read-a-users-custom-data)\n\n ← [Call a Function - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/app-services/call-a-function/ \"Previous Section\")[Authenticate Users - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - C++ SDK (Alpha) MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Stream Data to Atlas - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/sync/stream-data-to-atlas/ \"Previous Section\")[Realm Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/realm-database/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - C++ SDK (Alpha) On this page * [Database Internals](#database-internals)\n* [Native Database Engine](#native-database-engine)\n* [Realm Files](#realm-files)\n* [Copy-on-Write: The Secret Sauce of Data Versioning](#copy-on-write--the-secret-sauce-of-data-versioning)\n* [Memory Mapping](#memory-mapping)\n* [Compaction](#compaction)\n* [ACID Compliance](#acid-compliance)\n* [Features](#features)\n* [Queries](#queries)\n* [Encryption](#encryption)\n* [Indexes](#indexes)\n* [Schemas](#schemas)\n* [Persistent or In-Memory Realms](#persistent-or-in-memory-realms)\n* [Atlas Device Sync](#atlas-device-sync)\n* [Realm vs Other Databases](#realm-vs-other-databases)\n* [Live Queries](#live-queries)\n* [Live Object](#live-object) ## Note ### The Realm C++ SDK is Currently in Alpha While the Realm C++ SDK is in alpha, some of the features listed on this page are not yet implemented or fully supported in this SDK. Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) This page explains some of the implementation details and inner workings of Realm Database and Device Sync. This page is for you if you are: * a developer interested in learning more about Realm Database\n* comparing Realm Database with competing databases\n* trying to understand how Realm Database works with Device Sync This explanation begins with a deep dive into database internals, continues with a high-level introduction to some of the features of Realm Database, and wraps up with some of the differences of working with Device Sync and the local version of Realm Database. ## Database Internals Realm Database uses a completely unique database engine, file format, and design. This section describes some of the high-level details of those choices. This section applies to both the device-local version of Realm Database as well as the networked Device Sync version. Differences between the local database and the synchronized database are explained in the Atlas Device Sync section. ### Native Database Engine Realm Database is an entire database written from scratch in C++, instead of building on top of an underlying database engine like SQLite. Realm Database's underlying storage layer uses[B+ trees](https://en.wikipedia.org/wiki/B%2B%5Ftree) to organize objects. As a result, Realm Database controls optimizations from the storage level all the way up to the access level. Realm Database stores data in **realms**: collections of heterogeneous realm objects. You can think of each realm as a database. Each object in a realm is equivalent to a row in a SQL database table or a MongoDB document. Unlike SQL, realms do not separate different object types into individual tables. Realm Database stores objects as groups of property values. We call this column-based storage. This means that queries or writes for individual objects can be slower than row-based storage equivalents when unindexed, but querying a single field across multiple objects or fetching multiple objects can be much faster due to spatial locality and in-CPU vector operations. Realm Database uses a [zero-copy](https://en.wikipedia.org/wiki/Zero-copy) design to make queries faster than an ORM, and often faster than raw SQLite. ### Realm Files\n\n * **realm files**, suffixed with \"realm\", e.g. `default.realm`: contain object data.\n* **lock files**, suffixed with \"lock\", e.g. `default.realm.lock`: keep track of which versions of data in a realm are actively in use. This prevents realm from reclaiming storage space that is still used by a client application.\n* **note files**, suffixed with \"note\", e.g. `default.realm.note`: enable inter-thread and inter-process notifications.\n* **management files**, suffixed with \"management\", e.g. `default.realm.management`: internal state management. Realm files contain object data with the following data structures: Groups, Tables, Cluster Trees, and Clusters. Realm Database organizes these data structures into a tree structure with the following form: * The top level, known as a Group, stores object metadata, a transaction log, and a collection of Tables.\n* Each class in the realm schema corresponds to a Table within the top-level Group.\n* Each Table contains a Cluster Tree, an implementation of a B+ tree.\n* Leaves on the Cluster Tree are called Clusters. Each contains a range of objects sorted by key value.\n* Clusters store objects as collections of columns.\n* Each column contains data for a single property for multiple instances of a given object. Columns are arrays of data with uniformly sized values.\n* Columns store data in one of the following sizes: 1, 2, 4, 8, 16, 32, or 64 bits. Each column uses one value size, determined by the largest value. Since pointers refer to memory addresses, objects written to persistent files cannot store references as pointers. Instead, realm files refer to data using the offset from the beginning of the file. We call this a ref. As Realm Database uses memory mapping to read and write data, database operations translate these refs from offsets to memory pointers when navigating database structures. ### Copy-on-Write: The Secret Sauce of Data Versioning Realm Database uses a technique called **copy-on-write**, which copies data to a new location on disk for every write operation instead of overwriting older data on disk. Once the new copy of data is fully written, the database updates existing references to that data. Older data is only garbage collected when it is no longer referenced or actively in use by a client application. Because of copy-on-write, older copies of data remain valid, since all of the references in those copies still point to other valid data. Realm Database leverages this fact to offer multiple versions of data simultaneously to different threads in client applications. Most applications tie data refreshes to the repaint cycle of the looper thread that controls the UI, since data only needs to refresh as often as the UI does. Longer-running procedures on background threads, such as large write operations, can work with a single version of data for a longer period of time before committing their changes. ### Memory Mapping Writes use [memory mapping](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) to avoid copying data back and forth from memory to storage. Accessors and mutators read and write to disk via memory mapping. As a result, object data is never stored on the stack or heap of your app. By default, data is memory-mapped as read-only to prevent accidental writes. Realm Database uses operating system level paging, trusting each operating system to implement memory mapping and persistence better than a single library could on its own. ### Compaction Realm Database automatically reuses free space that is no longer needed after database writes. However, realm files never shrink automatically, even if the amount of data stored in your realm decreases significantly. Compact your realm to optimize storage space and decrease file size if possible. You should compact your realms occasionally to keep them at an optimal size. You can do this manually, or by configuring your realms to compact on launch. However, Realm Database reclaims unused space for future writes, so compaction is only an optimization to conserve space on-device. ### ACID Compliance Realm Database guarantees that transactions are [ACID](https://en.wikipedia.org/wiki/ACID) compliant. This means that all committed write operations are guaranteed to be valid and that clients don't see transient states in the event of a system crash. Realm Database complies with ACID with the following design choices:\n\n ## Features Realm Database supports many popular database features. ### Queries You can query Realm Database using platform-native queries or a raw query language that works across platforms. ### Encryption Realm Database supports on-device realm encryption. Since memory mapping does not support encryption, encrypted realms use a simulated in-library form of memory mapping instead. ## Note Realm forbids opening the same encrypted realm from multiple processes. Attempting to do so will throw the error: \"Encrypted interprocess sharing is currently unsupported.\" ### Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time. ### Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, do not require a migration. After you increment the local schema version, you can begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. See your SDK's documentation for more information on migrations. ### Persistent or In-Memory Realms You can use Realm Database to store data persistently on disk, or ephemerally in memory. Ephemeral realms can be useful in situations where you don't need to persist data between application instances, such as when a user works in a temporary workspace. ## Atlas Device Sync Device Sync adds network synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. Device Sync relies on a worker client that communicates with your application backend in a dedicated thread in your application. Additionally, synced realms keep a history of changes to contained objects. Sync uses this history to resolve conflicts between client changes and backend changes. Applications that use Device Sync define their schema on the backend using[JSON Schema](https://json-schema.org/learn/getting-started-step-by-step.html). Client applications must match that backend schema to synchronize data. However, if you prefer to define your initial schema in your application's programming language, you can use [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to create a backend JSON Schema based on native SDK objects as you write your application. However, once your application is used for production purposes, you should alter your schema using JSON Schema on the backend. ## Realm vs Other Databases The Realm data model is similar to both relational and document databases but has distinct differences from both. To underscore these differences, it's helpful to highlight what a realm **is not**: A realm is not a single, application-wide database. Applications based on other database systems generally store all of their data in a single database. Apps often split data across multiple realms to organize data more efficiently and to enforce access controls. A realm is not a relational table. Normalized tables in relational databases only store one type of information, such as street addresses or items in a store inventory. A realm can contain any number of object types that are relevant to a given domain. A realm is not a collection of schemaless documents. Document databases don't necessarily enforce a strict schema for the data in each collection. While similar to documents in form, every Realm object conforms to a schema for a specific object type in the realm. An object cannot contain a property that is not described by its schema. ## Live Queries You can read back the data that you have [stored](https://mongodb.com/docs/realm/sdk/cpp/crud/create/#std-label-cpp-write-transactions) in Realm Database by finding, filtering, and sorting objects. To get the best performance from Realm as your app grows and your queries become more complex, design your app's data access patterns around a solid understanding of Realm Database [read characteristics.](https://mongodb.com/docs/realm/sdk/cpp/crud/read/#std-label-cpp-realm-read-characteristics) ### Live Object All Realm objects are **live objects**, which means they automatically update whenever they're modified. Realm emits a notification event whenever any property changes.\n\n Valid write operations on a live object automatically persist to the realm and propagate to any other synced clients. You do not need to call an update method, modify the realm, or otherwise \"push\" updates. ← [C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/ \"Previous Section\")[Install Realm - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/install/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/crud/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - C++ SDK * [Create](https://mongodb.com/docs/realm/sdk/cpp/crud/create/)\n* [Create](https://mongodb.com/docs/realm/sdk/cpp/crud/read/)\n* [Update](https://mongodb.com/docs/realm/sdk/cpp/crud/update/)\n* [Delete](https://mongodb.com/docs/realm/sdk/cpp/crud/delete/)\n* [Filter Data](https://mongodb.com/docs/realm/sdk/cpp/crud/filter-data/)\n* [Threading](https://mongodb.com/docs/realm/sdk/cpp/crud/threading/) ← [Configure & Open a Realm - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/ \"Previous Section\")[CRUD - Create - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/crud/create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Data Between Devices - C++ SDK (Alpha) ## Overview Atlas Device Sync automatically synchronizes data between client applications and an [App Services backend](https://www.mongodb.com/docs/atlas/app-services/#std-label-realm-cloud). When a client device is online, Sync asynchronously synchronizes data in a background thread between the device and your backend App. When you use Sync in your client application, your implementation must match the Sync Mode you select in your backend App configuration. The Realm C++ SDK only supports Flexible Sync. ## Tip ### See also:  [Configure and Enable Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) ### Flexible Sync When you select [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) for your backend App configuration, your client implementation must include subscriptions to queries on [queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields). Flexible Sync works by synchronizing data that matches query subscriptions you maintain in the client application. A subscription set contains a set of queries. Flexible Sync returns documents matching those queries, where the user has the appropriate[permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read and/or read and write the documents. If documents match the query, but the client does not have the permission to read or write them, they do not sync to the client application. You can form queries using [Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Note Flexible Sync does not support all the query operators available in Realm Query Language and the SDK's query engine. See [Flexible Sync RQL Limitations](https://mongodb.com/docs/realm/realm-query-language/#std-label-flexible-sync-rql-limitations) for details. Subscription sets are based on a specific type of [Realm object](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-object-model). You might have multiple subscriptions if you have many types of Realm objects. To use Device Sync in your client application, open a synced realm with a Flexible Sync configuration. Then, manage subscriptions to determine which documents to sync. For more information, refer to[Manage Sync Subscriptions - C++ SDK (Alpha).](https://mongodb.com/docs/realm/sdk/cpp/sync/sync-subscriptions/#std-label-cpp-manage-flexible-sync-subscriptions) ### Group Updates for Improved Performance Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change. ## Unidirectional Sync Device Sync supports the ability to **send** data to Atlas, but not receive any updates. In this scenario, you can maximize sync performance by using[Asymmetric Sync](https://mongodb.com/docs/realm/sdk/cpp/sync/stream-data-to-atlas/#std-label-cpp-stream-data-to-atlas) to stream data from the client application to a Flexible Sync-enabled Atlas App Services App. ← [Custom User Data - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/users/custom-user-data/ \"Previous Section\")[Manage Sync Subscriptions - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/sync/sync-subscriptions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/": " # Realm React Native SDK Use the Realm React Native SDK to develop iOS and Android apps with JavaScript or TypeScript. Learning Paths ## Get Started with Realm React Native ![Functions Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_ATLAS_Functions3x.png) Quick Start Minimal-explanation code examples of how to work with Realm Database. [See Code Examples](https://www.mongodb.com/docs/realm/sdk/react-native/quick-start/) ![Realm Mobile Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/Technical_REALM_Mobile3x.png) Working Example App Learn from example by dissecting a working React Native client app that uses Realm Database with Device Sync. [Explore an Example App](https://www.mongodb.com/docs/atlas/app-services/template-apps/) ![Tutorial Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_CONTENT_Tutorial3x.png) Guided Tutorial Follow a guided tutorial to learn how to adapt the example app to create your own working app with Realm database and Device Sync. [Follow the Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/react-native/) What You Can Do ## Develop Apps with Realm Database Use open-source Realm Database to store data on a device. Use Device Sync to keep data in sync with your MongoDB Atlas cluster and other clients. Essential Documentation ## Recommended Reading ![Realm Icon](https://mongodb.com/docs/realm/images/icons/branding_2022/General_ACTION_BestPractices3x.png) JavaScript API Reference Explore generated reference docs for the React Native SDK. [React Native Reference](https://www.mongodb.com/docs/realm-sdks/js/latest/) ![Expo Icon](https://mongodb.com/docs/realm/images/icons/expo_logo.svg) React Native Quick Start with Expo Build and deploy a React Native application quickly using an Expo template application with Realm React. [Explore the Quick Start](https://www.mongodb.com/docs/realm/sdk/react-native/quick-start-expo/)",
  "https://www.mongodb.com/docs/realm/sdk/cpp/model-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Model Data - C++ SDK * [Object Types and Schemas](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/)\n* [Supported Data Types](https://mongodb.com/docs/realm/sdk/cpp/model-data/supported-types/)\n* [Relationships](https://mongodb.com/docs/realm/sdk/cpp/model-data/relationships/) ← [Quick Start - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/quick-start/ \"Previous Section\")[Object Models - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm - C++ SDK On this page * [Requirements](#requirements)\n* [Install](#install)\n* [Usage](#usage)\n* [Build an Android App](#build-an-android-app) The Realm C++ SDK enables client applications written in C++ to access data stored in realms and sync data with Atlas. This page details how to install Realm in your project and get started. ## Requirements * Minimum C++ standard: C++17.\n* For development on macOS: Xcode 11.x or later.\n* Otherwise, we recommend git and [CMake](https://cmake.org). ## Install ## Usage ### Include the Header Make the Realm C++ SDK available in your code by including the`cpprealm/sdk.hpp` header in the translation unit where you want to use it: `| #include <cpprealm/sdk.hpp> |\n| --------------------------- | ` ## Build an Android App The Realm C++ SDK Alpha supports building Android apps. To build an Android app: * Add `<uses-permission android:name=\"android.permission.INTERNET\" />` to your `AndroidManifest.xml`\n* Add the subdirectory of the Realm C++ SDK to your native library's `CMakeLists.txt`and link it as a target library:  \n```  \nset(CMAKE_CXX_STANDARD 17)  \nadd_subdirectory(\"realm-cpp\")  \n...  \ntarget_link_libraries(  \n   # Specifies the target library.  \n   myapplication  \n   # make sure to link the Realm C++ SDK.  \n   cpprealm  \n)  \n```\n* Ensure that the git submodules are initialized inside of the `realm-cpp` folder before building.\n* When instantiating the Realm or the Realm App, you must pass the `filesDir.path` as the `path`parameter in the respective constructor or realm open template. For an example of how to use the Realm C++ SDK Alpha in an Android app, refer to the [Android RealmExample App](https://github.com/realm/realm-cpp/tree/main/examples/Android)in the `realm-cpp` GitHub repository. Specifically, refer to the `MainActivity.kt` & `native-lib.cpp` files in the Android example app for code examples. ← [Realm Database - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/realm-database/ \"Previous Section\")[Quick Start - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/quick-start/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/application-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Application Services - C++ SDK (Alpha) On this page * [Overview](#overview)\n* [The App Client](#the-app-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Device Sync](#device-sync)\n* [Calling Functions](#calling-functions) ## Overview Realm SDKs let you connect your client apps to the Atlas App Services backend. The SDKs provide the functionality needed to authenticate users with any of the built-in [authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) and call server-side [Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions). You can also use an App Services App to [sync data between devices.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) ## The App Client When using the SDK to access the App Services backend, you start with an`App` object. This object provides all other functionality related to App Services. You initialize the `App` object with an App Services App ID, which you can [find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ## Tip To learn how to initialize the App client, see[Connect to App Services - C++ SDK.](https://mongodb.com/docs/realm/sdk/cpp/app-services/connect-to-app/#std-label-cpp-connect-to-backend) ## Authentication & User Management One of the most challenging aspects of client development is implementing a robust and secure authentication system. With the Realm SDKs, however, you can use any of the App Services authentication providers with very minimal backend setup or client-side code required. With the authentication APIs, you can implement the following functionality: * Creation of new user accounts\n* User log-in and log-out\n* Providing custom user data ## Tip To learn how to set up authentication with different providers, refer to[Authenticate Users - C++ SDK (Alpha).](https://mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-authenticate-users) To learn how to provide custom user data, refer to [Custom User Data - C++ SDK (Alpha).](https://mongodb.com/docs/realm/sdk/cpp/users/custom-user-data/#std-label-cpp-custom-user-data) ## Device Sync Device Sync adds data synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device in the same way as a non-synced Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. To get started with Sync, refer to [Device Sync.](https://mongodb.com/docs/realm/sdk/cpp/sync/#std-label-cpp-sync) ## Calling Functions [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) enable you to define and execute server-side logic for your application. You can call these Functions from your client applications via the Realm SDKs. These server-side functions can run under the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your collections. By using Functions, you provide a secure way for a variety of client applications to share complex functionality without having to reproduce that logic client-side. ## Tip To learn how to call Functions, see [Call a Function.](https://mongodb.com/docs/realm/sdk/cpp/app-services/call-a-function/#std-label-cpp-call-a-function) ← [React to Changes - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/react-to-changes/ \"Previous Section\")[Connect to App Services - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/app-services/connect-to-app/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - C++ SDK (Alpha) On this page * [Register an Object Change Listener](#register-an-object-change-listener)\n* [Register a Results Collection Change Listener](#register-a-results-collection-change-listener)\n* [Stop Watching for Changes](#stop-watching-for-changes) ## Register an Object Change Listener You can register a notification handler on a specific object within a realm. Realm Database notifies your handler: * When the object is deleted.\n* When any of the object's properties change. `| auto token = object.observe([&](auto&& change) { ... } |\n| ------------------------------------------------------ | ` The handler receives an [ObjectChange](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1ObjectChange.html)object that contains information about the changes, such as whether the object was deleted. It may include a list of [PropertyChange](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1PropertyChange.html#a71dc45a7609e6a528e70b91d20ef8f94)objects that contain information about what fields changed, the new values of those fields (except on List properties), and potentially the old values of the fields. ``` if (change.error) {     rethrow_exception(change.error); } if (change.is_deleted) {     std::cout << \"The object was deleted.\\n\"; } else {     for (auto& propertyChange : change.property_changes) {         std::cout << \"The object's \" << propertyChange.name << \" property has changed.\\n\";          auto newPropertyValue = std::get<std::string>(*propertyChange.new_value);         std::cout << \"The new value is \" << newPropertyValue << \"\\n\";     } } \n``` When you make changes, [refresh()](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html) the realm to emit a notification. ## Example ``` auto realm = realm::open<Person, Dog>(); auto dog = Dog { .name = \"Max\" }; // Create an object in the realm. realm.write([&realm, &dog] {     realm.add(dog); }); //  Set up the listener & observe object notifications. auto token = dog.observe([&](auto&& change) {     try {         if (change.error) {             rethrow_exception(change.error);         }         if (change.is_deleted) {             std::cout << \"The object was deleted.\\n\";         } else {             for (auto& propertyChange : change.property_changes) {                 std::cout << \"The object's \" << propertyChange.name << \" property has changed.\\n\";                  auto newPropertyValue = std::get<std::string>(*propertyChange.new_value);                 std::cout << \"The new value is \" << newPropertyValue << \"\\n\";             }         }     } catch (std::exception const& e) {         std::cerr << \"Error: \" << e.what() << \"\\n\";     } }); // Update the dog's name to see the effect. realm.write([&dog, &realm] {     dog.name = \"Wolfie\"; }); // Deleting the object triggers a delete notification.\n\n     realm.remove(dog); }); // Refresh the realm after the change to trigger the notification. realm.refresh(); // Unregister the token when done observing. token.unregister(); \n``` ## Register a Results Collection Change Listener You can register a notification handler on a [results collection.](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1results.html) Realm Database notifies your handler whenever a write transaction removes, adds, or changes objects in the collection. Notifications describe the changes since the prior notification with three lists of indices: the indices of the objects that were deleted, inserted, and modified. ## Important ### Order Matters In collection notification handlers, always apply changes in the following order: deletions, insertions, then modifications. Handling insertions before deletions may result in unexpected behavior. Results collection notifications provide a [results\\_change](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1results%5F%5Fbase%5F1%5F1results%5F%5Fchange.html) struct that reports the index of the objects that are deleted, added, or modified. It can also notify you if the collection was deleted. ``` // Get a results collection to observe auto dogs = realm.objects<Dog>(); //  Set up the listener & observe results notifications. auto token = dogs.observe([&](auto&& changes) {     try {         if (changes.collection_root_was_deleted) {             std::cout << \"The collection was deleted.\\n\";         } else {             // Handle deletions, then insertions, then modifications.             for (auto& resultsChange : changes.deletions) {                 std::cout << \"The object at index \" << std::to_string(resultsChange) << \" was deleted\\n\";             }             for (auto& resultsChange : changes.insertions) {                 std::cout << \"The object at index \" << std::to_string(resultsChange) << \" was inserted\\n\";             }             for (auto& resultsChange : changes.modifications) {                 std::cout << \"The object at index \" << std::to_string(resultsChange) << \" was modified\\n\";             }         }     } catch (std::exception const& e) {         std::cerr << \"Error: \" << e.what() << \"\\n\";     } }); // Delete and then add an object to see deletions and insertions. realm.write([&dog1, &dog2, &realm] {     realm.remove(dog1);     realm.add(dog2); }); // Modify an object to see a modification. realm.write([&dog2, &realm] {     dog2.age = 2; }); // Refresh the realm after the change to trigger the notification. realm.refresh(); // Unregister the token when done observing. token.unregister(); \n``` ## Stop Watching for Changes Observation stops when the token returned by an `observe` call becomes invalid. You can explicitly invalidate a token by calling its`unregister()` member function. ``` // Unregister the token when done observing. token.unregister(); \n``` ## Important ### Retain Tokens as Long as You Want to Observe Notifications stop when the token's destructor is called. For example, if the token is in a local variable that goes out of scope. You can use `std::move` to transfer the token to a variable in a different scope.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/cpp/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - C++ SDK (Alpha) On this page * [Import Realm](#import-realm)\n* [Define Your Object Model](#define-your-object-model)\n* [Open a Realm](#open-a-realm)\n* [Create, Read, Update, and Delete Objects](#create--read--update--and-delete-objects)\n* [Watch for Changes](#watch-for-changes)\n* [Add Device Sync (Optional)](#add-device-sync--optional-)\n* [Prerequisites](#prerequisites)\n* [Initialize the App](#initialize-the-app)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Realm](#open-a-realm-1)\n* [Read, Write, and React to Changes](#read--write--and-react-to-changes) This Quick Start demonstrates how to use Realm Database with the Realm C++ SDK. Before you begin, ensure you have [Installed the C++ SDK.](https://mongodb.com/docs/realm/sdk/cpp/install/#std-label-cpp-install) ## Import Realm Make the Realm C++ SDK available in your code by including the`cpprealm/sdk.hpp` header in the translation unit where you want to use it: `| #include <cpprealm/sdk.hpp> |\n| --------------------------- | ` ## Define Your Object Model For a local-only Realm Database you can define your [object model](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-object-models) directly in code. In this quick start, you can remove`ownerId` unless you want to add the optional Device Sync. ``` struct Todo : realm::object<Todo> {     realm::persisted<realm::object_id> _id{realm::object_id::generate()};     realm::persisted<std::string> name;     realm::persisted<std::string> status;     // The ownerId property stores the user.identifier() of a     // logged-in user. Omit this property for the non-sync example.     realm::persisted<std::string> ownerId;     static constexpr auto schema = realm::schema(\"Todo\",         realm::property<&Todo::_id, true>(\"_id\"),         realm::property<&Todo::name>(\"name\"),         realm::property<&Todo::status>(\"status\"),         realm::property<&Todo::ownerId>(\"ownerId\")); }; \n``` ## Open a Realm In a local-only Realm Database, the simplest option to open a realm is to use the default realm with no configuration parameter: ``` auto realm = realm::open<Todo>(); \n``` You can also specify a [db\\_config](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1realm%5F1%5F1config.html) to open a realm at a specific path, or to provide a `sync_config` to open a synced realm. For more information, see: [Configure and Open a Realm.](https://mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/#std-label-cpp-configure-and-open-a-realm) ## Create, Read, Update, and Delete Objects Once you have opened a realm, you can modify it and its [objects](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-realm-objects) in a [write transaction](https://mongodb.com/docs/realm/sdk/cpp/crud/create/#std-label-cpp-write-transactions)block. To instantiate a new Todo object and add it to the realm in a write block: ``` auto todo = Todo {     .name = \"Create my first todo item\",\n\n }; realm.write([&realm, &todo] {     realm.add(todo); }); \n``` You can retrieve a live [results collection](https://mongodb.com/docs/realm/sdk/cpp/crud/read/#std-label-cpp-read-operations) of all todos in the realm: ``` auto todos = realm.objects<Todo>(); \n``` You can also filter that collection using [where:](https://mongodb.com/docs/realm/sdk/cpp/crud/filter-data/#std-label-cpp-client-query-engine) ``` auto todosInProgress = todos.where([](auto const& todo) {     return todo.status == \"In Progress\"; }); \n``` To modify a todo, update its properties in a write transaction block: ``` auto todoToUpdate = todosInProgress[0]; realm.write([&realm, &todoToUpdate] {     todoToUpdate.status = \"Complete\"; }); \n``` Finally, you can delete a todo: ``` realm.write([&realm, &todo] {     realm.remove(todo); }); \n``` ## Watch for Changes You can watch an [object for changes](https://mongodb.com/docs/realm/sdk/cpp/react-to-changes/#std-label-cpp-react-to-changes) with the `observe` method. ``` auto token = todo.observe([&](auto&& change) {     try {         if (change.error) {             rethrow_exception(change.error);         }         if (change.is_deleted) {             std::cout << \"The object was deleted.\\n\";         } else {             for (auto& propertyChange : change.property_changes) {                 std::cout << \"The object's \" << propertyChange.name << \" property has changed.\\n\";             }         }     } catch (std::exception const& e) {         std::cerr << \"Error: \" << e.what() << \"\\n\";     } }); \n``` ## Add Device Sync (Optional) If you want to sync Realm data across devices, you can set up an Atlas App Services App and enable Device Sync. For more information on what you can do with App Services, see: [Application Services - C++ SDK (Alpha).](https://mongodb.com/docs/realm/sdk/cpp/application-services/#std-label-cpp-application-services) ### Prerequisites Before you can sync Realm data, you must: * [Create an App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enable anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)\n* [Enable Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) with [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) toggled to `On`. This example requires an `ownerId`field in your Device Sync Queryable Fields section. ### Initialize the App To use App Services features such as authentication and sync, access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) in the App Services UI. ``` auto app = realm::App(APP_ID); \n``` ### Authenticate a User\n\n ``` auto user = app.login(realm::App::credentials::anonymous()).get_future().get(); \n``` The Realm C++ SDK provides many additional ways to authenticate, register, and link users. For other authentication providers, see: [Authenticate Users - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-authenticate-users) ### Open a Realm Once you have enabled Device Sync and authenticated a user, you can create a [sync\\_configuration](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1realm%5F1%5F1sync%5F%5Fconfig.html) object and open the realm. You can then add a [Flexible Sync subscription](https://mongodb.com/docs/realm/sdk/cpp/sync/sync-subscriptions/#std-label-cpp-manage-flexible-sync-subscriptions) that determines what data the realm can read and write. ``` auto sync_config = user.flexible_sync_configuration(); auto synced_realm_ref = realm::async_open<Todo>(sync_config).get_future().get(); auto realm = synced_realm_ref.resolve(); // For this example, get the userId for the Flexible Sync query auto userId = user.identifier(); auto subscriptions = realm.subscriptions(); auto updateSubscriptionSuccess = subscriptions.update([&](realm::mutable_sync_subscription_set &subs) {     subs.add<Todo>(\"todos\", [&userId](auto &obj) {         // For this example, get only Todo items where the ownerId         // property value is equal to the userId of the logged-in user.         return obj.ownerId == userId;     }); }).get_future().get(); \n``` ### Read, Write, and React to Changes The syntax to [read](https://mongodb.com/docs/realm/sdk/cpp/crud/read/#std-label-cpp-crud-read), [write](https://mongodb.com/docs/realm/sdk/cpp/crud/create/#std-label-cpp-write-transactions), and [watch for changes](https://mongodb.com/docs/realm/sdk/cpp/react-to-changes/#std-label-cpp-react-to-changes) on a synced realm is identical to the syntax for non-synced realms above. The only difference here is that this example stores the `user.identifier()`of the logged-in user in the `ownerId` property of the `Todo` item. This lets us query for only the user's todos in the subscription, and set Sync permissions to Users can only read and write their own data. For more information about Sync permissions, refer to [Role-based Permissions.](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-sync-permissions) ``` auto todo = Todo {     .name = \"Create a Sync todo item\",     .status = \"In Progress\",     .ownerId = userId }; realm.write([&realm, &todo] {     realm.add(todo); }); auto todos = realm.objects<Todo>(); \n``` While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change. ← [Install Realm - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/install/ \"Previous Section\")[Model Data - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/model-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Configure & Open a Realm - C++ SDK (Alpha) On this page * [Key Concept: Realm Files](#key-concept--realm-files)\n* [Key Concept: Synced Realms](#key-concept--synced-realms)\n* [Synced Realms vs. Non-Synced Realms](#synced-realms-vs.-non-synced-realms)\n* [Open a Non-Sync Realm](#open-a-non-sync-realm)\n* [Open the Default Realm](#open-the-default-realm)\n* [Open a Realm at a File Path](#open-a-realm-at-a-file-path)\n* [Open a Synced Realm](#open-a-synced-realm) A **realm** is the core data structure used to organize data in Realm Database. A realm is a collection of the objects that you use in your application, called Realm objects, as well as additional metadata that describe the objects. When you open a realm, the `open` or `async_open` templates construct a [db\\_config](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1realm%5F1%5F1config.html) that specifies details about how to configure the realm file. This can include: * The models that the realm file should manage\n* An optional path where the realm is stored on device\n* A `sync_config` if you want to use the realm with Device Sync ## Key Concept: Realm Files Realm Database stores a binary encoded version of every object and type in a realm in a single `.realm` file. The file is located at [a specific path](https://mongodb.com/docs/realm/studio/open-realm-file/#std-label-find-the-default-realm-path) that you can define when you open the realm. You can open, view, and edit the contents of these files with[Realm Studio.](https://mongodb.com/docs/realm/studio/#std-label-realm-studio) ## Tip ### See: Auxiliary Realm Files Realm Database creates additional files for each realm. To learn more about these files, see [Realm Database Internals.](https://mongodb.com/docs/realm/sdk/cpp/realm-database/#std-label-cpp-realm-database) ## Key Concept: Synced Realms You can configure a realm to automatically synchronize data between many devices that each have their own local copy of the data. Synced realms need a `sync_config` and require an Atlas App Services backend to handle the synchronization process. Applications can always create, modify, and delete synced realm objects locally, even when offline. Whenever a network connection is available, the Realm SDK opens a connection to an application server and syncs changes to and from other clients. The [Atlas Device Sync protocol](https://www.mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-sync-protocol) and server-side operational transforms guarantee that all fully synced instances of a realm see exactly the same data, even if some changes occurred offline and/or were received out of order. ### Synced Realms vs. Non-Synced Realms Synced realms differ from non-synced local Realm Database in a few ways: * Synced realms attempt to sync changes with your backend App Services App, whereas non-synced realms do not.\n* Synced realms can only be accessed by authenticated users, while non-synced realms have no concept of users or authentication.\n* With synced realms, you can download updates before opening a realm. However, requiring changes to download before opening the realm requires the user to be online. Non-synced realms can always be used offline. You can manually copy data from a non-synced Realm Database to a synced realm, and vice versa, but you cannot sync a non-synced Realm Database. ## Open a Non-Sync Realm You can open a realm in the current directory using the default constructor. Or you can construct a `db_config` with a specific file path to open the realm in a specific location. ### Open the Default Realm\n\n `| // Get the default Realm with compile-time schema checking. |\n| ----------------------------------------------------------- |\n| auto realm = realm::open<Person, Dog>();                    | ` ## Tip ### Building an Android App When building an Android app that uses the Realm C++ SDK Alpha, you must pass the `filesDir.path` to the `path` parameter in the[db\\_config](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1realm%5F1%5F1config.html)constructor. For more information, refer to: [Build an Android App.](https://mongodb.com/docs/realm/sdk/cpp/install/#std-label-cpp-build-android-app) ### Open a Realm at a File Path If you need to open a realm at a specific file path, you can pass a path to the realm open template. ``` auto relative_realm_path_directory = \"custom_path_directory/\"; // Construct a path std::filesystem::path path = std::filesystem::current_path().append(relative_realm_path_directory); // Add a name for the realm file path =  path.append(\"dog_objects\"); // Add the .realm extension path = path.replace_extension(\"realm\"); // Open a realm at the path auto realm = realm::open<Dog>({ path }); \n``` ## Tip ### Building an Android App When building an Android app that uses the Realm C++ SDK Alpha, you must pass the `filesDir.path` as the `path` parameter in the[db\\_config](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1realm%5F1%5F1config.html)constructor. For more information, refer to: [Build an Android App.](https://mongodb.com/docs/realm/sdk/cpp/install/#std-label-cpp-build-android-app) ## Open a Synced Realm You must have an [Atlas App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app-ui) that you have [configured for Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) in order to sync data between devices. To open a synced realm: 1. Connect to an Atlas App Services App.\n2. Authenticate the user.\n3. Create a sync configuration.\n4. Open the user's synced realm with the configuration. To open a synced, pass the models you want the realm to manage into the template parameter list of the [async\\_open](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1async%5F%5Fopen%5F%5Fpromise.html) function, and pass the configuration as an argument to the function. ``` auto app = realm::App(APP_ID); // Ensure anonymous authentication is enabled in the App Services App auto user = app.login(realm::App::credentials::anonymous()).get_future().get(); auto sync_config = user.flexible_sync_configuration(); // Note that get_future().get() blocks this thread until the promise -  // in this case, the task kicked off by the call to async_open - is resolved auto synced_realm_ref = realm::async_open<SyncDog>(sync_config).get_future().get(); // async_open gives us a thread-safe reference to the synced realm, which  // we need to resolve() before we can safely use the realm on this thread. auto realm = synced_realm_ref.resolve(); \n``` ## Tip ### Building an Android App\n\n ← [Relationships - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/model-data/relationships/ \"Previous Section\")[CRUD - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/crud/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/users/manage-email-password-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Email/Password Users - C++ SDK On this page * [Register a New User](#register-a-new-user)\n* [Confirm Registration With an Email](#confirm-registration-with-an-email)\n* [Log a Registered User in or out](#log-a-registered-user-in-or-out)\n* [Handle Password Resets With an Atlas Function](#handle-password-resets-with-an-atlas-function) When you enable the [email/password provider](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication)in your Atlas App Services App, you can handle user authentication from client code by registering a new user account. ## Register a New User `| auto app = realm::App(INSERT_APP_ID_HERE);                       |\n| ---------------------------------------------------------------- |\n| auto user_email = \"testUser\" + random_string() + \"@example.com\"; |\n| auto user_password = \"password1234\";                             |\n| app.register_user(user_email, user_password).get_future().get(); | ` ## Confirm Registration With an Email You can use Atlas App Services to [send a confirmation email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-confirmation-function)to newly-registered user's email addresses. After confirmation, you can log the user in. ## Log a Registered User in or out Users must be registered before you can log them in or out. To log a user in: ``` auto user = app.login(realm::App::credentials::username_password(user_email, user_password))     .get_future().get(); \n``` To log a user out: ``` user.log_out().get_future().get(); \n``` ## Handle Password Resets With an Atlas Function To reset a user password, you can [run a password reset function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function). To do so, you need to properly configure your Atlas App Services App. 1. In the Atlas UI, go to your App\n2. Select Authentication, then select the Authentication Providers tab\n3. In the Email/Password row, press the EDIT button\n4. Under User Confirmation, select Run a confirmation function\n5. Select your confirmation function or create a new function, then press Save Now, you can use the custom password reset function you created in your client code. ← [Authenticate Users - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/ \"Previous Section\")[Custom User Data - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/users/custom-user-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/sync/sync-subscriptions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Sync Subscriptions - C++ SDK (Alpha) On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Align Subscriptions with Backend App](#align-subscriptions-with-backend-app)\n* [Manage Your Subscriptions](#manage-your-subscriptions)\n* [Verify Number of Subscriptions or Find a Specific Subscription](#verify-number-of-subscriptions-or-find-a-specific-subscription)\n* [Add Sync Subscriptions](#add-sync-subscriptions)\n* [Subscribe to All Objects of a Type](#subscribe-to-all-objects-of-a-type)\n* [Subscribe to Objects that Match a Query](#subscribe-to-objects-that-match-a-query)\n* [Update Sync Subscriptions](#update-sync-subscriptions)\n* [Remove Sync Subscriptions](#remove-sync-subscriptions)\n* [Remove a Specific Subscription](#remove-a-specific-subscription)\n* [Remove All Subscriptions](#remove-all-subscriptions)\n* [Refresh the Realm After Updating Subscriptions](#refresh-the-realm-after-updating-subscriptions) ## Overview Flexible Sync uses subscriptions and permissions to determine which data to sync between your Atlas App Services App and your client device. In the client, query subscriptions manage and filter the object types that can sync to the realm. ## Before You Begin To use Flexible Sync in your app, you must: * [Configure Flexible Sync on the backend](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n* [Initialize the app](https://mongodb.com/docs/realm/sdk/cpp/app-services/connect-to-app/#std-label-cpp-connect-to-backend)\n* [Authenticate a user](https://mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-authenticate-users)\n* [Open the synced Realm with a Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/#std-label-cpp-open-synced-realm) The setup code for the examples on this page handles these prerequisites: `| // Initialize the App, authenticate a user, and open the realm                  |\n| ------------------------------------------------------------------------------- |\n| auto app = realm::App(APP_ID);                                                  |\n| auto user = app.login(realm::App::credentials::anonymous()).get_future().get(); |\n| auto syncConfig = user.flexible_sync_configuration();                           |\n| auto syncedRealmRef = realm::async_open<Dog>(syncConfig).get_future().get();    |\n| auto syncedRealm = syncedRealmRef.resolve();                                    | ` ## Align Subscriptions with Backend App Your client-side subscription queries must align with the Device Sync configuration in your backend App Services App. You subscription queries can either: * **Query all objects of a type.**\n* **Query object of a type that match backend App's queryable fields.** To learn more about configuring queryable fields, refer to [Queryable Fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields) in the App Services documentation.\n\n ## Manage Your Subscriptions When configuring Flexible Sync on the backend, you specify which fields your client application can query. In the client application, the[sync\\_subscription\\_set](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1sync%5F%5Fsubscription%5F%5Fset.html)is a list of zero or more [sync\\_subscription](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1sync%5F%5Fsubscription.html) objects that determine what objects the realm can store. The Realm C++ SDK also has a [mutable\\_sync\\_subscription\\_set](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1mutable%5F%5Fsync%5F%5Fsubscription%5F%5Fset.html) that enables you to add, change, and remove `sync_subscription` objects. ### Verify Number of Subscriptions or Find a Specific Subscription When your app first opens a synced realm, you may want to verify that it has the expected number of subscriptions or has a specific subscription. You can get this information by accessing the `subscriptions()` public member function of a [realm](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html). This provides the [sync\\_subscription\\_set](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1sync%5F%5Fsubscription%5F%5Fset.html) where you can use the`size()` or `find()` public member functions. ``` // Check the subscription count CHECK(syncedRealm.subscriptions().size() == 1); // Find a specific subscription by name auto puppySubscription = *syncedRealm.subscriptions().find(\"puppies\"); // Get information about the subscription CHECK(puppySubscription.object_class_name == \"Dog\"); CHECK(puppySubscription.query_string == \"age < 3\"); \n``` ### Add Sync Subscriptions To update a subscription set, use the `subscription().updates()` function. This gives you access to a [mutable\\_sync\\_subscription\\_set](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1mutable%5F%5Fsync%5F%5Fsubscription%5F%5Fset.html) where you can use the use the `add()` function to add a new Sync subscription. This template requires the object type of the object you want to sync, and a string name for the subscription. #### Subscribe to All Objects of a Type You can subscribe to all objects of a type. This enables the synced realm to read and write any objects of the type where the user's permissions match the server-side permissions. ``` auto updateSubscriptionSuccess = syncedRealm.subscriptions().update([](realm::mutable_sync_subscription_set &subs) {     subs.add<Dog>(\"dogs\"); }).get_future().get(); // The .update() function returns a bool, which confirms whether or not the update succeeded REQUIRE(updateSubscriptionSuccess == true); // You can check the .size() of the subscription set, which tells you the  // number of sync_subscription objects in the set CHECK(syncedRealm.subscriptions().size() == 1); \n``` #### Subscribe to Objects that Match a Query If you only want to subscribe to a subset of objects, provide a query to filter the subscription. ``` updateSubscriptionSuccess = syncedRealm.subscriptions().update([](realm::mutable_sync_subscription_set &subs) {     subs.add<Dog>(\"puppies\", [](auto &obj) {         return obj.age < 3;     }); }).get_future().get(); REQUIRE(updateSubscriptionSuccess == true);\n\n \n``` When you filter a subscription, you cannot write objects that do not match the filter. In this example, the query matches `Dog` objects whose `age` is less than `3`. The realm does not sync any dogs who are 3 or older. This filter also applies to writes. If you try to write a `Dog` object where the `age` is `4`, you get a compensating write error and the write reverts. ### Update Sync Subscriptions To update a subscription set, use the `subscription().updates()` function. This gives you access to a [mutable\\_sync\\_subscription\\_set](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1mutable%5F%5Fsync%5F%5Fsubscription%5F%5Fset.html) where you can use the`update_subscription()` function to update a specific [sync\\_subscription.](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1sync%5F%5Fsubscription.html) You can change a `sync_subscription`'s query in an update. You can add, remove, or update the query string for a given `sync_subscription`. ``` updateSubscriptionSuccess = syncedRealm.subscriptions().update([](realm::mutable_sync_subscription_set &subs) {     subs.update_subscription<Dog>(\"puppies\", [](auto &obj) {         // Change the age filter from `age < 3` to `age < 2`         return obj.age < 2;     }); }).get_future().get(); REQUIRE(updateSubscriptionSuccess == true); \n``` ### Remove Sync Subscriptions To update a subscription set, use the `subscription().updates()` function. This gives you access to a [mutable\\_sync\\_subscription\\_set](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1mutable%5F%5Fsync%5F%5Fsubscription%5F%5Fset.html) where you can use the`remove()` or `clear()` functions to remove subscriptions. #### Remove a Specific Subscription You can remove a specific subscription by name using the `remove()` function. Removing a subscription by name throws an error if the subscription does not exist, so you should check for a subscription before removing it. ``` auto removeSubscriptionSuccess = syncedRealm.subscriptions().update([](realm::mutable_sync_subscription_set &subs) {     subs.remove(\"dogs\"); }).get_future().get(); REQUIRE(removeSubscriptionSuccess == true); \n``` #### Remove All Subscriptions You can remove all subscriptions in a subscription set using the `clear()`function. ``` // You can use .clear() inside a mutable_sync_subscription_set to clear all  // sync_subscription objects from the set  auto updateSubscriptionSuccess = syncedRealm.subscriptions().update([](realm::mutable_sync_subscription_set &subs) {     subs.clear(); }).get_future().get(); CHECK(updateSubscriptionSuccess == true); CHECK(syncedRealm.subscriptions().size() == 0); \n``` ## Refresh the Realm After Updating Subscriptions After you update subscriptions, call `refresh()` on the [realm](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html). This updates the realm and outstanding objects managed by the realm to point to the most recent data. ``` syncedRealm.refresh(); \n``` ← [Sync Data Between Devices - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/sync/ \"Previous Section\")[Manage a Sync Session - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/sync/manage-sync-session/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/sync/manage-sync-session/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage a Sync Session - C++ SDK (Alpha) On this page * [Prerequisites](#prerequisites)\n* [Get the Sync Session](#get-the-sync-session)\n* [Wait for Changes to Upload and Download](#wait-for-changes-to-upload-and-download)\n* [Check the Sync State](#check-the-sync-state) When you use Atlas Device Sync, the Realm C++ SDK syncs data with Atlas in the background using a sync session. The sync session starts when you open a synced realm. The sync session manages the following: * Uploading and downloading changes to the realm\n* Monitoring sync state ## Prerequisites Before you can manage a sync session state, you must: 1. [Configure Flexible Sync on the Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n2. [Open a Synced Realm](https://mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/#std-label-cpp-open-synced-realm) ## Get the Sync Session You can use the public member function [get\\_sync\\_session()](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html#a79c5e6e92896703a54693be35720ae12) to get a[sync\\_session](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1sync%5F%5Fsession.html)object for any synced realm. The SDK returns this object as an optional. It is a lightweight handle that you can pass around by value. `| auto syncSession = realm.get_sync_session(); |\n| -------------------------------------------- | ` ## Wait for Changes to Upload and Download To wait for all changes to upload to Atlas from your synced realm, use the public member function `.wait_for_upload_completion()`. ``` syncSession->wait_for_upload_completion().get_future().get(); \n``` To wait for all changes from Atlas to download to your synced realm, use the public member function`wait_for_download_completion()`. Refresh the realm after downloading any changes to be sure it reflects the most recent data. ``` syncSession->wait_for_download_completion().get_future().get(); realm.refresh(); \n``` ## Check the Sync State You can use the [sync\\_session](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1sync%5F%5Fsession.html)'s public member function `state()` to check whether the sync session is active. This returns an enum whose value reflects possible Device Sync states. ``` syncSession->state(); \n``` ← [Manage Sync Subscriptions - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/sync/sync-subscriptions/ \"Previous Section\")[Stream Data to Atlas - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/sync/stream-data-to-atlas/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/sync/stream-data-to-atlas/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Stream Data to Atlas - C++ SDK (Alpha) On this page * [Overview](#overview)\n* [Sync Data Unidirectionally from a Client Application](#sync-data-unidirectionally-from-a-client-application)\n* [Define an Asymmetric Object](#define-an-asymmetric-object)\n* [Connect and Authenticate with an App Services App](#connect-and-authenticate-with-an-app-services-app)\n* [Open a Realm](#open-a-realm)\n* [Create Asymmetric Objects](#create-asymmetric-objects) ## Overview You can use [Asymmetric Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) to stream data from the client application to a Flexible Sync-enabled Atlas App Services App. You might want to sync data unidirectionally in IoT applications, such as a weather sensor sending data to the cloud. Asymmetric Sync is also useful for writing other types of immutable data where you do not require conflict resolution, such as creating invoices from a retail app or logging application events. Asymmetric Sync is optimized to provide performance improvements for heavy client-side _insert-only_ workloads. ## Sync Data Unidirectionally from a Client Application 1 ### Define an Asymmetric Object You can sync data unidirectionally when you inherit from[asymmetric\\_object.](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1asymmetric%5F%5Fobject.html)\n\n ` For more information on how to define an `asymmetric_object`, including limitations when linking to other object types, see:[Define an Asymmetric Object.](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-define-asymmetric-object) 2 ### Connect and Authenticate with an App Services App To stream data from the client to your backend App, you must[connect to an App Services backend](https://mongodb.com/docs/realm/sdk/cpp/app-services/connect-to-app/#std-label-cpp-connect-to-backend)and [authenticate a user.](https://mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-authenticate-users) ``` auto app = realm::App(APP_ID); auto user = app.login(realm::App::credentials::anonymous()).get_future().get(); \n``` 3 ### Open a Realm After you have an authenticated user, you can open a synced realm using a `flexibleSyncConfiguration()`. Specify the `asymmetric_object`types you want to sync. ``` auto syncConfig = user.flexible_sync_configuration(); auto asymmetricRealm = realm::async_open<WeatherSensorReading>(syncConfig).get_future().get().resolve(); \n``` Unlike bidirectional Sync, Asymmetric Sync does not use a[Flexible Sync subscription.](https://mongodb.com/docs/realm/sdk/cpp/sync/sync-subscriptions/#std-label-cpp-manage-flexible-sync-subscriptions) ## Tip ### Mixed Object and Asymmetric Object Types You cannot read, query, or delete an `asymmetric_object` from a realm, so asymmetric objects are incompatible with bi-directional Flexible Sync or local realm use. You cannot open a single synced realm to manage both regular objects and asymmetric objects - you must use different realms to manage these different object types. 4 ### Create Asymmetric Objects Once you have an open realm, you can create an `asymmetric_object`and set its values as you would a regular object. However, you cannot read or delete these objects. Once created, they sync to the App Services backend and the linked Atlas database. ``` auto weatherSensorReading = WeatherSensorReading {     .deviceId = \"WX1278UIT\",     .temperatureInFahrenheit = 64.7,     .windSpeedInMph = 7 }; asymmetricRealm.write([&asymmetricRealm, &weatherSensorReading] {     asymmetricRealm.add(weatherSensorReading); }); \n``` ← [Manage a Sync Session - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/sync/manage-sync-session/ \"Previous Section\")[Telemetry - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/telemetry/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate Users - C++ SDK (Alpha) On this page * [Log In](#log-in)\n* [Anonymous User](#anonymous-user)\n* [Email/Password User](#email-password-user)\n* [API Key User](#api-key-user)\n* [Custom Function User](#custom-function-user)\n* [Custom JWT User](#custom-jwt-user)\n* [Facebook User](#facebook-user)\n* [Google User](#google-user)\n* [Apple User](#apple-user)\n* [Get a User Access Token](#get-a-user-access-token)\n* [Log Out](#log-out) ## Log In ### Anonymous User If you have enabled [Anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)in the App Services UI, users can immediately log into your app without providing any identifying information. `| auto app = realm::App(INSERT_APP_ID_HERE);                                      |\n| ------------------------------------------------------------------------------- |\n| auto user = app.login(realm::App::credentials::anonymous()).get_future().get(); | ` ### Email/Password User If you have enabled [Email/Password authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication), and have [registered an email/password user](https://mongodb.com/docs/realm/sdk/cpp/users/manage-email-password-users/#std-label-cpp-register-email-password-user), you can log that user in. ``` auto user = app.login(realm::App::credentials::username_password(user_email, user_password))     .get_future().get(); \n``` ### API Key User If you have enabled [API Key authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication), you can log in using a user API key. ``` auto app = realm::App(INSERT_APP_ID_HERE); auto user = app.login(realm::App::credentials::api_key(API_KEY)).get_future().get(); \n``` ### Custom Function User If you have enabled the [Custom Function authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication), you can log in using a custom function. ``` // Custom function authentication takes a BSON Document with parameters. // The parameter details vary depending on how you define your custom authentication function. realm::bson::BsonDocument params = {{ \"username\", \"bob\" }}; auto app = realm::App(INSERT_APP_ID_HERE); auto user = app.login(realm::App::credentials::function(params)).get_future().get(); \n``` ### Custom JWT User If you have enabled the [Custom JWT authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication), you can log in using a custom JWT. ``` auto token = \"<jwt>\"; auto app = realm::App(INSERT_APP_ID_HERE); auto user = app.login(realm::App::credentials::custom(token)).get_future().get(); \n``` ### Facebook User The [Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) authentication provider allows you to authenticate users through a Facebook app using their existing Facebook account. ## Important ### Enable the Facebook Auth Provider\n\n ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. ``` auto app = realm::App(INSERT_APP_ID_HERE); auto accessToken = \"<token>\"; auto user = app.login(realm::App::credentials::facebook(accessToken)).get_future().get(); \n``` ### Google User If you have configured the [Google authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication), you can log in using an existing Google account. To log in with a Google authentication code, pass a Google authentication code to[credentials::google(auth\\_code).](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1App%5F1%5F1credentials.html) ``` auto app = realm::App(INSERT_APP_ID_HERE); // The auth_code below is the user's server auth code you got from Google auto user = app.login(realm::App::credentials::google(auth_code)).get_future().get(); \n``` To log in with a Google ID token, pass a Google ID token to[credentials::google(id\\_token).](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1App%5F1%5F1credentials.html) ``` auto app = realm::App(INSERT_APP_ID_HERE); // The id_token below is the user's OpenID Connect id_token you got from the Google OAuth response auto user = app.login(realm::App::credentials::google(id_token)).get_future().get(); \n``` ### Apple User If you have enabled [Sign-in with Apple authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication), you can log a user in using an Apple ID token. ``` auto app = realm::App(INSERT_APP_ID_HERE); auto idToken = \"<token>\"; auto user = app.login(realm::App::credentials::apple(idToken)).get_future().get(); \n``` ## Get a User Access Token The Realm SDK automatically manages access tokens, refreshes them when they expire, and includes a valid access token for the current user with each request. If you send requests outside of the SDK - for example, through the [GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) \\- then you must include the user's access token with each request. In this scenario, you must manually refresh the token when it expires. Access tokens expire after 30 minutes. You can call [.refresh\\_custom\\_user\\_data()](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1user.html#a6e08623890de4003a00a351e939a0a9f)on a logged-in user to refresh the user's auth session. Then, get the[.access\\_token()](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1user.html#ac059073ce64f125553e5bd395bd17cd6)as a string you can use in your code. You might use code similar to this to fetch an access token: ``` // With a logged-in user, refresh the custom user data to refresh the auth session user.refresh_custom_user_data().get_future().get(); // Then get the user's access token auto userAccessToken = user.access_token(); \n``` ## Log Out Once logged in, you can log out. ## Warning\n\n ``` user.log_out().get_future().get(); \n``` ← [Manage Users - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/manage-users/ \"Previous Section\")[Manage Email/Password Users - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/users/manage-email-password-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/model-data/relationships/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Relationships - C++ SDK (Alpha) On this page * [Key Concept: Relationships](#key-concept--relationships)\n* [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationship](#inverse-relationship)\n* [Declare Relationship Properties](#declare-relationship-properties)\n* [Define a To-One Relationship](#define-a-to-one-relationship)\n* [Define a To-Many Relationship](#define-a-to-many-relationship) ## Key Concept: Relationships Realm Database doesn't use bridge tables or explicit joins to define relationships as you would in a relational database. Realm Database handles relationships through embedded objects or reference properties to other Realm Database objects. You read from and write to these properties directly. This makes querying relationships as performant as querying against any other property. Realm Database supports **to-one**, **to-many**, and **inverse**relationships. However, the C++ SDK Alpha does not yet support inverse relationships. Realm also provides a special type of object, called an[embedded object](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-embedded-object), that is conceptually similar to a relationship but provides additional constraints. ### To-One Relationship A **to-one** relationship means that an object relates to one other object. You define a to-one relationship for an object type in its object model. Specify a property where the type is the related Realm object type. For example, a dog might have a to-one relationship with a favorite toy. ### To-Many Relationship A **to-many** relationship means that an object relates to more than one other object. In Realm Database, a to-many relationship is a list of references to other objects. For example, a person might have many dogs. Realm Database represents a to-many relationship between two Realm types as a list. Lists are mutable: within a write transaction, you can add and remove elements to and from a list. Lists are not associated with a query and are declared as a property of the object model. ### Inverse Relationship Relationship definitions in Realm Database are unidirectional. An**inverse relationship** links an object back to an object that refers to it. The C++ SDK Alpha does not yet support inverse relationships. ## Declare Relationship Properties ## Tip ### See also:  With Device Sync, you can also [define your relationships](https://www.mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-define-a-relationship) in the App Services UI. ### Define a To-One Relationship A **to-one** relationship maps one property to a single instance of another object type. For example, you can model a dog having at most one favorite toy as a to-one relationship. Setting a relationship field to null removes the connection between objects. Realm does not delete the referenced object, though, unless it is[an embedded object.](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-embedded-object) ## Important ### To-one relationships must be optional When you declare a to-one relationship in your object model, it must be an optional property. If you try to make a to-one relationship required, Realm throws an exception at runtime.\n\n ` ### Define a To-Many Relationship A **to-many** relationship maps one property to zero or more instances of another object type. For example, you can model a company having any number of employees as a to-many relationship. ``` struct Company : realm::object<Company> {     realm::persisted<int64_t> _id;     realm::persisted<std::string> name;     // To-many relationships are a list, represented here as a     // vector container whose value type is the Realm object     // type that the list field links to.     realm::persisted<std::vector<Employee>> employees;     static constexpr auto schema = realm::schema(\"Company\",         realm::property<&Company::_id, true>(\"_id\"),         realm::property<&Company::name>(\"name\"),         realm::property<&Company::employees>(\"employees\")); }; \n``` ← [Supported Types - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/model-data/supported-types/ \"Previous Section\")[Configure & Open a Realm - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/app-services/connect-to-app/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Connect to App Services - C++ SDK On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Access the App Client](#access-the-app-client) ## Overview The App client is the Atlas App Services backend interface. It provides access to authentication and Atlas Functions. Some of your App Services App's features are associated with user accounts. For example, you need to [authenticate a user](https://mongodb.com/docs/realm/sdk/cpp/users/manage-email-password-users/#std-label-cpp-authenticate-user) before you can access your App's functions. ## Before You Begin 1. [Create an App Services app](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app) ## Access the App Client 1. [Find the App ID in the Realm UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id)\n2. Create an [App object](https://www.mongodb.com/docs/realm-sdks/cpp/latest/classrealm%5F1%5F1App.html)with your App's ID as the argument. You use this `App` instance to access App Services features throughout your client application. `| auto app = realm::App(APP_ID); |\n| ------------------------------ | ` ## Tip ### Building an Android App When building an Android app that uses the Realm C++ SDK Alpha, you must pass the `filesDir.path` to the `file_path` parameter in the[db\\_config](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1realm%5F1%5F1config.html)constructor. For more information, refer to: [Build an Android App.](https://mongodb.com/docs/realm/sdk/cpp/install/#std-label-cpp-build-android-app) ← [Application Services - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/application-services/ \"Previous Section\")[Call a Function - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/app-services/call-a-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/users/custom-user-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Custom User Data - C++ SDK (Alpha) On this page * [Read a User's Custom Data](#read-a-user-s-custom-data)\n* [Create a User's Custom Data Document](#create-a-user-s-custom-data-document)\n* [Update a User's Custom Data](#update-a-user-s-custom-data)\n* [Delete a User's Custom Data](#delete-a-user-s-custom-data) ## Read a User's Custom Data You can read the [custom user data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) of a currently logged-in user through that user's `User` object. You cannot edit custom user data through a `User` object. To edit custom user data, see [Update Custom User Data](#std-label-cpp-update-a-users-custom-data). To read the data, access the`custom_data` property on the `User` object of a logged-in user: `| // Custom user data could be stale, so refresh it before reading it |\n| ------------------------------------------------------------------- |\n| user.refresh_custom_user_data().get_future().get();                 |\n| CHECK((*user.custom_data())[\"favoriteColor\"] == \"gold\");            | ` ## Warning ### Custom Data May Be Stale Atlas App Services does not dynamically update the value of the client-side user custom data document immediately when underlying data changes. Instead, App Services fetches the most recent version of custom user data whenever a user refreshes their [access token](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions), which is used by most SDK operations that contact the App Services backend. If the token is not refreshed before its default 30 minute expiration time, the C++ SDK refreshes the token on the next call to the backend. Custom user data could be stale for up to 30 minutes plus the time until the next SDK call to the backend occurs. ## Note If you require the most recent version of custom user data, use the[refresh\\_custom\\_user\\_data()](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1user.html#a6e08623890de4003a00a351e939a0a9f)function to request the latest version of a user's custom data. ## Create a User's Custom Data Document To create custom user data for a user, create a MongoDB document in the custom user data collection. The user ID field of the document should contain the the user's user ID. ## Tip In the App Services UI, check the App Users page under theCustom User Data tab to find and configure custom user data settings, including: * The custom user data cluster, database, and collection\n* The user ID field used to map custom user data documents to users One way you can create this document is by calling an [Atlas Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions)that inserts a custom data document into the custom user data collection. There is no single pattern for adding custom user data from an Atlas Function. You should write your Function or Functions to suit your application's use case. In this example, the Atlas Function takes an object passed by the client add adds it to the custom user data collection in Atlas. The Function creates the custom user data if it doesn't already exist and replaces all data in it if it does exist. updateCustomUserData.js - Atlas Function running on server (JavaScript) ```js exports = async function updateCustomUserData(newCustomUserData) {   const userId = context.user.id;   const customUserDataCollection = context.services     .get(\"mongodb-atlas\")     .db(\"custom-user-data-database\")     .collection(\"cpp-custom-user-data\");   const filter = { userId };   // Replace the existing custom user data document with the new one.   const update = { $set: newCustomUserData };\n\n   const options = { upsert: true };   const res = await customUserDataCollection.updateOne(filter, update, options);   return res; }; \n``` The following example [calls a function](https://mongodb.com/docs/realm/sdk/cpp/app-services/call-a-function/#std-label-cpp-call-a-function) to insert a document containing the user ID of the currently logged in user and a `favoriteColor` value into the custom user data collection: ``` auto user = app.login(realm::App::credentials::anonymous()).get_future().get(); // Functions take an argument of BsonArray, so initialize the custom data as a BsonDocument auto customDataBson = realm::bson::BsonDocument({{\"userId\", user.identifier()}, {\"favoriteColor\", \"gold\"}}); // Call an Atlas Function to insert custom data for the user auto result = user.call_function(\"updateCustomUserData\", { customDataBson }).get_future().get(); \n``` You can add any number of arbitrary fields and values to the custom user data document when you create it. The user ID field is the only requirement for the document to become available on the `User` object as custom user data. ## Update a User's Custom Data You can update custom user data using [an Atlas Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), [MongoDB Compass](https://www.mongodb.com/docs/compass/current/), or the [MongoDB Atlas Data Explorer.](https://www.mongodb.com/docs/atlas/data-explorer/) To update a user's custom user data with an Atlas Function, edit the MongoDB document whose user ID field contains the user ID of the user. The following example calls the same function used to create the custom user data document above. Here, we update the `favoriteColor` field of the the document containing the user ID of the currently logged in user: ``` // Functions take an argument of BsonArray, so initialize the custom data as a BsonDocument auto updatedDataBson = realm::bson::BsonDocument({{\"userId\", user.identifier()}, { \"favoriteColor\", \"black\" }}); // Call an Atlas Function to update custom data for the user auto updateResult = user.call_function(\"updateCustomUserData\", { updatedDataBson }).get_future().get(); // Refresh the custom user data before reading it to verify it succeeded user.refresh_custom_user_data().get_future().get(); CHECK((*user.custom_data())[\"favoriteColor\"] == \"black\"); \n``` ## Tip To determine a user's ID, access the `user.identifier()` property or find the user in the App Services UI on the App Users page under theUsers tab. ## Delete a User's Custom Data Custom user data is stored in a document linked to the user object. Deleting a user does not delete the custom user data. To fully delete user data to comply with, for example, [Apple's Account deletion guidance](https://developer.apple.com/support/offering-account-deletion-in-your-app/), you must manually delete the user's custom data document. You can delete custom user data using [an Atlas Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), [MongoDB Compass](https://www.mongodb.com/docs/compass/current/), or the [MongoDB Atlas Data Explorer.](https://www.mongodb.com/docs/atlas/data-explorer/) In this example, the Atlas Function does not require any arguments. The Function uses the function context to determine the caller's user ID, and deletes the custom user data document matching the user's ID. deleteCustomUserData.js - Atlas Function running on server (JavaScript) ```js exports = async function deleteCustomUserData() {   const userId = context.user.id;   const customUserDataCollection = context.services     .get(\"mongodb-atlas\")     .db(\"custom-user-data-database\")     .collection(\"cpp-custom-user-data\");   const filter = { userId };   const res = await customUserDataCollection.deleteOne(filter);   return res; }; \n```\n\n ``` auto deleteResult = user.call_function(\"deleteCustomUserData\", {}).get_future().get(); \n``` ← [Manage Email/Password Users - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/users/manage-email-password-users/ \"Previous Section\")[Sync Data Between Devices - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/model-data/object-models/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Object Models - C++ SDK (Alpha) On this page * [Key Concept: Object Types & Schemas](#key-concept--object-types---schemas)\n* [Realm Schema](#realm-schema)\n* [Realm Object Model](#realm-object-model)\n* [Realm Object Schema](#realm-object-schema)\n* [Define a New Object Type](#define-a-new-object-type)\n* [Specify a Primary Key](#specify-a-primary-key)\n* [Ignore a Property](#ignore-a-property)\n* [Define an Embedded Object](#define-an-embedded-object)\n* [Define an Asymmetric Object](#define-an-asymmetric-object) ## Key Concept: Object Types & Schemas Realm Database applications model data as objects composed of field-value pairs that each contain one or more [supported](https://mongodb.com/docs/realm/sdk/cpp/model-data/supported-types/#std-label-cpp-supported-property-types) data types. Every Realm object has an _object type_ that refers to the object's class. Objects of the same type share an [object schema](#std-label-cpp-object-schema) that defines the properties and relationships of those objects. ### Realm Schema A **realm schema** is a list of valid object schemas that a realm may contain. Every Realm object must conform to an object type that's included in its realm's schema. When opening a realm, you must specify which models are available by passing the models to the template you use to open the realm. Those models must have schemas, and this list of schemas becomes the realm schema. If a realm already contains data when you open it, Realm Database validates each object to ensure that an object schema was provided for its type and that it meets all of the constraints specified in the schema. For more information about how to open a realm, refer to: [Configure & Open a Realm - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/#std-label-cpp-configure-and-open-a-realm) ### Realm Object Model Your Realm object model is the core structure that gives Realm information about how to interpret and store the objects in your app. The C++ Realm object model is a class or a struct that subclasses one of the Realm object types. The object model contains a collection of properties. You annotate the properties in the model to give Realm information about each property: * The data type and whether the property is optional or required\n* Whether Realm should store or ignore the property Properties are also the mechanism for establishing [relationships](https://mongodb.com/docs/realm/sdk/cpp/model-data/relationships/#std-label-cpp-relationships) between Realm object types. You use this object model like any other C++ class or struct when you initialize your objects. In addition to property information, each C++ Realm object model must expose a schema. ### Realm Object Schema A C++ **realm object schema** maps property names, relationships, and any property metadata for a specific object type. Because C++ does not have reflection, your model must expose a public static **constexpr**member that explicitly declares your schema. The object schema includes details like the property name and type, whether the property is a primary key, and whether it forms a relationship with other object types. ## Define a New Object Type You can define your models as classes or structs that inherit from[realm::object](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1object.html). The Realm C++ SDK uses [CRTP](https://en.cppreference.com/w/cpp/language/crtp) to simplify working with Realm objects. With this implementation, you pass the object's type as a template paramater when you declare your object struct.\n\n Realm ignores any members not declared as `realm::persisted` and not declared in the schema. `| struct Dog : realm::object<Dog> {                                    |\n| -------------------------------------------------------------------- |\n| realm::persisted<std::string> name;                                  |\n| realm::persisted<int64_t> age;                                       |\n| static constexpr auto schema = realm::schema(\"Dog\",                  |\n| realm::property<&Dog::name>(\"name\"),                                 |\n| realm::property<&Dog::age>(\"age\"));                                  |\n| };                                                                   |\n| struct Person : realm::object<Person> {                              |\n| realm::persisted<std::string> _id;                                   |\n| realm::persisted<std::string> name;                                  |\n| realm::persisted<int64_t> age;                                       |\n| // Create relationships by pointing an Object field to another Class |\n| realm::persisted<std::optional<Dog>> dog;                            |\n| static constexpr auto schema = realm::schema(\"Person\",               |\n| realm::property<&Person::_id, true>(\"_id\"), // primary key           |\n| realm::property<&Person::name>(\"name\"),                              |\n| realm::property<&Person::age>(\"age\"),                                |\n| realm::property<&Person::dog>(\"dog\"));                               |\n| };                                                                   | ` ## Note Class names are limited to a maximum of 57 UTF-8 characters. ### Specify a Primary Key You can designate a property as the **primary key** of your object. Primary keys allow you to efficiently find, update, and upsert objects. Primary keys are subject to the following limitations:\n\n If you are using [Device Sync](https://mongodb.com/docs/realm/sdk/cpp/realm-files/configure-and-open-a-realm/#std-label-cpp-synced-realm), your models must have a primary key named `_id`. The Realm C++ SDK supports primary keys of the following types, required or optional: * `realm::object_id`\n* `realm::uuid`\n* `realm::enum`\n* `std::string` You set a property as a primary key by passing `true` to the second template parameter of the `persisted` template: ``` static constexpr auto schema = realm::schema(\"Person\",     realm::property<&Person::_id, true>(\"_id\"), // primary key     realm::property<&Person::name>(\"name\"),     realm::property<&Person::age>(\"age\"),     realm::property<&Person::dog>(\"dog\")); \n``` ### Ignore a Property Your model may include properties that Realm Database does not store. Realm ignores any members not declared as `realm::persisted` and not declared in the schema. ``` struct Employee : realm::object<Employee> {     realm::persisted<int64_t> _id;     realm::persisted<std::string> firstName;     realm::persisted<std::string> lastName;     // Omitting the `realm::persisted` annotation means     // realm ignores this property     std::string jobTitle_notPersisted;     // Your schema consists of properties that you want realm to store.     // Omit properties that you want to ignore from the schema.     static constexpr auto schema = realm::schema(\"Employee\",         realm::property<&Employee::_id, true>(\"_id\"),         realm::property<&Employee::firstName>(\"firstName\"),         realm::property<&Employee::lastName>(\"lastName\")); }; \n``` ### Define an Embedded Object An **embedded object** is a special type of object that models complex data about a specific object. Embedded objects are similar to relationships, but they provide additional constraints and map more naturally to the denormalized [MongoDB document model.](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/) Realm enforces unique ownership constraints that treat each embedded object as nested data inside of a single, specific parent object. An embedded object inherits the lifecycle of its parent object and cannot exist as an independent Realm object. Realm automatically deletes embedded objects if their parent object is deleted or when overwritten by a new embedded object instance. You can declare an object as an [embedded object](#std-label-cpp-embedded-object)that does not have a lifecycle independent of the object in which it is embedded. This differs from a [to-one](https://mongodb.com/docs/realm/sdk/cpp/model-data/relationships/#std-label-cpp-to-one-relationship)or [to-many](https://mongodb.com/docs/realm/sdk/cpp/model-data/relationships/#std-label-cpp-to-many-relationship) relationship, in which the related objects have independent lifecycles. To declare an object as an embedded object, inherit from[realm::embedded\\_object.](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1embedded%5F%5Fobject.html) ``` // Inherit from realm::embedded_object to declare an embedded object struct ContactDetails : realm::embedded_object<ContactDetails> {     // Because ContactDetails is an embedded object, it cannot have its own _id     // It does not have a lifecycle outside of the top-level object     realm::persisted<std::string> emailAddress;     realm::persisted<std::string> phoneNumber;     static constexpr auto schema = realm::schema(\"ContactDetails\",         realm::property<&ContactDetails::emailAddress>(\"emailAddress\"),         realm::property<&ContactDetails::phoneNumber>(\"phoneNumber\")); }; struct Business : realm::object<Business> {\n\n     realm::persisted<std::string> name;     realm::persisted<std::optional<ContactDetails>> contactDetails;     static constexpr auto schema = realm::schema(\"Business\",         realm::property<&Business::_id, true>(\"_id\"),         realm::property<&Business::name>(\"name\"),         realm::property<&Business::contactDetails>(\"contactDetails\")); }; \n``` ### Define an Asymmetric Object You can use [Asymmetric Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) to sync an object unidirectionally from your device to the database linked to your Atlas App Services App. Define an asymmetric object by inheriting from[realm::asymmetric\\_object.](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1asymmetric%5F%5Fobject.html) ``` struct WeatherSensorReading : realm::asymmetric_object<WeatherSensorReading> {      realm::persisted<realm::object_id> _id{realm::object_id::generate()};     realm::persisted<std::string> deviceId;     realm::persisted<double> temperatureInFahrenheit;     realm::persisted<int64_t> windSpeedInMph;     static constexpr auto schema = realm::schema(\"WeatherSensorReading\",         realm::property<&WeatherSensorReading::_id, true>(\"_id\"),         realm::property<&WeatherSensorReading::deviceId>(\"deviceId\"),         realm::property<&WeatherSensorReading::temperatureInFahrenheit>(\"temperatureInFahrenheit\"),         realm::property<&WeatherSensorReading::windSpeedInMph>(\"windSpeedInMph\")); }; \n``` An `asymmetric_object` broadly has the same [supported types](https://mongodb.com/docs/realm/sdk/cpp/model-data/supported-types/#std-label-cpp-supported-property-types) as `realm::object`, with a few exceptions: * Asymmetric objects can only link to embedded objects  \n   * `object` and `std::vector<object>` properties are not supported  \n   * `embedded_object` and `std::vector<embedded_object>` _are_ supported You cannot link to an `asymmetric_object` from within an `object`. Doing so throws an error. Asymmetric objects do not function in the same way as other Realm objects. You cannot: * Remove an asymmetric object from a realm\n* Query an asymmetric object You can only create an asymmetric object, which then syncs unidirectionally to the Atlas database linked to your App with Device Sync. For more information, see: [Create an Asymmetric Object.](https://mongodb.com/docs/realm/sdk/cpp/crud/create/#std-label-cpp-create-asymmetric-object) ← [Model Data - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/model-data/ \"Previous Section\")[Supported Types - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/model-data/supported-types/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/app-services/call-a-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call a Function - C++ SDK (Alpha) On this page * [Call a Function By Name](#call-a-function-by-name) The examples on this page demonstrate calling an [Atlas Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions)named `concatenate` that takes two arguments, concatenates them, and returns the result: `| // concatenate: concatenate two strings |\n| --------------------------------------- |\n| exports = function(a, b) {              |\n| return a + b;                           |\n| };                                      | ` ## Call a Function By Name ## Important Make sure to sanitize client data to protect against code injection when using Functions. To execute a function from the C++ SDK, use the[call\\_function()](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1user.html#a82ab02822dd96e8d44201b996dd6ed0c)public member function on the `user` object. Pass in the name of the function as a string for the first parameter. This function takes two arguments, which we provide as a `BsonArray` of arguments: ``` // Connect to an App Services App and authenticate a user auto app = realm::App(APP_ID); auto user = app.login(realm::App::credentials::anonymous()).get_future().get(); auto sync_config = user.flexible_sync_configuration(); // If a function takes arguments, pass them as BSON auto arg1 = realm::bson::Bson(\"john.smith\"); auto arg2 = realm::bson::Bson(\"@companyemail.com\"); // Call an App Services function as the logged-in user auto result = user.call_function(\"concatenate\", { arg1, arg2 }).get_future().get(); // Verify that the result has a value CHECK(result); auto bsonResult = result.value(); // Translate the BSON result back to a string auto resultString = std::string(bsonResult); // Prints \"Calling the concatenate function returned john.smith@companyemail.com.\" std::cout << \"Calling the concatenate function returned \" << resultString << \".\\n\"; \n``` The callback can provide an optional BSON result, or an optional error. In the example above, we check that the result has a value, and then cast it back to a string. ← [Connect to App Services - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/app-services/connect-to-app/ \"Previous Section\")[Manage Users - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/manage-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/crud/update/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Update - C++ SDK (Alpha) On this page * [Update Realm Objects](#update-realm-objects)\n* [Update an Object](#update-an-object)\n* [Update an Embedded Object Property](#update-an-embedded-object-property)\n* [Overwrite an Embedded Object Property](#overwrite-an-embedded-object-property)\n* [Update a Map Property](#update-a-map-property) ## Update Realm Objects Updates to Realm Objects must occur within write transactions. For more information about write trasactions, see: [Key Concept: Transactions.](https://mongodb.com/docs/realm/sdk/cpp/crud/create/#std-label-cpp-write-transactions) ### Update an Object You can modify properties of a Realm object inside of a write transaction.\n\n ` #### Model This example uses the following model: ``` struct Dog : realm::object<Dog> {     realm::persisted<std::string> name;     realm::persisted<int64_t> age;     static constexpr auto schema = realm::schema(\"Dog\",         realm::property<&Dog::name>(\"name\"),         realm::property<&Dog::age>(\"age\")); }; \n``` ### Update an Embedded Object Property To update a property in an embedded object, modify the property in a write transaction. ``` auto businesses = realm.objects<Business>(); auto mongoDBPointer = businesses[0]; realm.write([&realm, &mongoDBPointer] {     mongoDBPointer.contactDetails->emailAddress = \"info@example.com\"; }); std::cout << \"New email address: \" << mongoDBPointer.contactDetails->emailAddress << \"\\n\"; \n``` #### Model This example uses the following model: ``` // Inherit from realm::embedded_object to declare an embedded object struct ContactDetails : realm::embedded_object<ContactDetails> {      // Because ContactDetails is an embedded object, it cannot have its own _id     // It does not have a lifecycle outside of the top-level object     realm::persisted<std::string> emailAddress;     realm::persisted<std::string> phoneNumber;     static constexpr auto schema = realm::schema(\"ContactDetails\",         realm::property<&ContactDetails::emailAddress>(\"emailAddress\"),         realm::property<&ContactDetails::phoneNumber>(\"phoneNumber\")); }; struct Business : realm::object<Business> {     realm::persisted<realm::object_id> _id{realm::object_id::generate()};     realm::persisted<std::string> name;     realm::persisted<std::optional<ContactDetails>> contactDetails;      static constexpr auto schema = realm::schema(\"Business\",         realm::property<&Business::_id, true>(\"_id\"),         realm::property<&Business::name>(\"name\"),         realm::property<&Business::contactDetails>(\"contactDetails\"));  }; \n``` ### Overwrite an Embedded Object Property To overwrite an embedded object, reassign the embedded object property to a new instance in a write transaction. ``` auto businesses = realm.objects<Business>(); auto mongoDBPointer = businesses[0]; realm.write([&realm, &mongoDBPointer] {     auto newContactDetails = ContactDetails {         .emailAddress = \"info@example.com\",         .phoneNumber = \"234-567-8901\"     };     // Overwrite the embedded object     mongoDBPointer.contactDetails = newContactDetails; }); std::cout << \"New email address: \" << mongoDBPointer.contactDetails->emailAddress << \"\\n\"; \n``` #### Model This example uses the following model: ``` // Inherit from realm::embedded_object to declare an embedded object struct ContactDetails : realm::embedded_object<ContactDetails> {      // Because ContactDetails is an embedded object, it cannot have its own _id     // It does not have a lifecycle outside of the top-level object     realm::persisted<std::string> emailAddress;     realm::persisted<std::string> phoneNumber;     static constexpr auto schema = realm::schema(\"ContactDetails\",         realm::property<&ContactDetails::emailAddress>(\"emailAddress\"),         realm::property<&ContactDetails::phoneNumber>(\"phoneNumber\")); }; struct Business : realm::object<Business> {     realm::persisted<realm::object_id> _id{realm::object_id::generate()};     realm::persisted<std::string> name;     realm::persisted<std::optional<ContactDetails>> contactDetails;      static constexpr auto schema = realm::schema(\"Business\",\n\n         realm::property<&Business::name>(\"name\"),         realm::property<&Business::contactDetails>(\"contactDetails\"));  }; \n``` ### Update a Map Property You can update a realm [map property](https://www.mongodb.com/docs/realm-sdks/cpp/latest/classrealm%5F1%5F1persisted%5F%5Fmap%5F%5Fbase.html)as you would a standard C++ [map:](https://en.cppreference.com/w/cpp/container/map) ``` // You can check that a key exists using `find` auto findTuesday = tommy.locationByDay.find(\"Tuesday\"); if (findTuesday != tommy.locationByDay.end())     realm.write([&realm, &tommy] {         tommy.locationByDay[\"Tuesday\"] = Employee::WorkLocation::HOME;     }); ; \n``` #### Model This example uses the following model: ``` struct Employee : realm::object<Employee> {     enum class WorkLocation {         HOME, OFFICE     };     realm::persisted<int64_t> _id;     realm::persisted<std::string> firstName;     realm::persisted<std::string> lastName;     realm::persisted<std::map<std::string, WorkLocation>> locationByDay;     static constexpr auto schema = realm::schema(\"Employee\",         realm::property<&Employee::_id, true>(\"_id\"),         realm::property<&Employee::firstName>(\"firstName\"),         realm::property<&Employee::lastName>(\"lastName\"),         realm::property<&Employee::locationByDay>(\"locationByDay\")); }; \n``` ← [CRUD - Read - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/crud/read/ \"Previous Section\")[CRUD - Delete - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/crud/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/model-data/supported-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Supported Types - C++ SDK (Alpha) On this page * [Supported Property Types](#supported-property-types)\n* [Property Cheat Sheet](#property-cheat-sheet)\n* [Map/Dictionary](#map-dictionary) ## Supported Property Types The Realm Database C++ SDK Alpha currently supports these property types. Optionals use the class template[std::optional.](https://en.cppreference.com/w/cpp/utility/optional) ### Property Cheat Sheet\n\n #### Supported Type Implementation Details Some of the supported types above are aliases for: * `mixed`: A union-like object that can represent a value any of the supported types. It is implemented using the class template[std::variant](https://en.cppreference.com/w/cpp/utility/variant). This implementation means that a `mixed` property holds a value of one of its alternative types, or in the case of error - no value.\n* For dates, use the [chrono library](https://en.cppreference.com/w/cpp/chrono)to store a `time_point` relative to the `system_clock`:`<std::chrono::time_point<std::chrono::system_clock>>` ### Map/Dictionary The [Map](https://www.mongodb.com/docs/realm-sdks/cpp/latest/classrealm%5F1%5F1persisted%5F%5Fmap%5F%5Fbase.html) is an associative array that contains key-value pairs with unique keys. You can declare a Map as a property of an object: ``` struct Dog : realm::object<Dog> {     realm::persisted<std::string> name;     realm::persisted<std::map<std::string, std::string>> favoriteParkByCity;     static constexpr auto schema = realm::schema(\"Dog\",         realm::property<&Dog::name>(\"name\"),         realm::property<&Dog::favoriteParkByCity>(\"favoriteParkByCity\")); }; \n``` String is the only supported type for a map key, but map values can be: * Required versions of any of the SDK's supported data types\n* Optional user-defined object links\n* Optional embedded objects ← [Object Models - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/ \"Previous Section\")[Relationships - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/model-data/relationships/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/crud/read/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Read - C++ SDK (Alpha) On this page * [Key Concept: Read from Realm Database](#key-concept--read-from-realm-database)\n* [Read Characteristics](#read-characteristics)\n* [Limiting Query Results](#limiting-query-results)\n* [Pagination](#pagination)\n* [Read Realm Objects](#read-realm-objects)\n* [Query All Objects of a Given Type](#query-all-objects-of-a-given-type)\n* [Filter Queries Based on Object Properties](#filter-queries-based-on-object-properties)\n* [Supported Query Operators](#supported-query-operators)\n* [Check the Size of the Results Set and Access Results](#check-the-size-of-the-results-set-and-access-results)\n* [Read a Map Property](#read-a-map-property) ## Key Concept: Read from Realm Database A read from a realm generally consists of the following steps: * Get all objects of a certain type from the realm.\n* Optionally, filter the results. [Query operations](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1query.html) return a[results collection](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1results.html). These collections are live, meaning they always contain the latest results of the associated query. ### Read Characteristics Design your app's data access patterns around these three key read characteristics to read data as efficiently as possible. #### Results Are Not Copies Results to a query are not copies of your data. Modifying the results of a query modifies the data on disk directly. This memory mapping also means that results are**live**: that is, they always reflect the current state on disk. #### Results Are Lazy Realm Database only runs a query when you actually request the results of that query. This lazy evaluation enables you to write highly performant code for handling large data sets and complex queries. You can chain several filter operations without requiring extra work to process the intermediate state. #### References Are Retained One benefit of Realm Database's object model is that Realm Database automatically retains all of an object's[relationships](https://mongodb.com/docs/realm/sdk/cpp/model-data/relationships/#std-label-cpp-relationships) as direct references. This enables you to traverse your graph of relationships directly through the results of a query. A **direct reference**, or pointer, allows you to access a related object's properties directly through the reference. Other databases typically copy objects from database storage into application memory when you need to work with them directly. Because application objects contain direct references, you are left with a choice: copy the object referred to by each direct reference out of the database in case it's needed, or just copy the foreign key for each object and query for the object with that key if it's accessed. If you choose to copy referenced objects into application memory, you can use up a lot of resources for objects that are never accessed, but if you choose to only copy the foreign key, referenced object lookups can cause your application to slow down. Realm Database bypasses all of this using zero-copy live objects. Realm object accessors point directly into database storage using memory mapping, so there is no distinction between the objects in Realm Database and the results of your query in application memory. Because of this, you can traverse direct references across an entire realm from any query result. ### Limiting Query Results As a result of lazy evaluation, you do not need any special mechanism to limit query results with Realm Database. For example, if your query matches thousands of objects, but you only want to load the first ten, simply access only the first ten elements of the results collection. ### Pagination Thanks to lazy evaluation, the common task of pagination becomes quite simple. For example, suppose you have a results collection associated with a query that matches thousands of objects in your realm. You display one hundred objects per page. To advance to any page, simply access the elements of the results collection starting at the index that corresponds to the target page. ## Read Realm Objects ### Query All Objects of a Given Type\n\n This returns a [Results](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1results.html) object representing all objects of the given type in the realm. `| auto companies = realm.objects<Company>(); |\n| ------------------------------------------ | ` ### Filter Queries Based on Object Properties A filter selects a subset of results based on the value(s) of one or more object properties. Realm Database provides a full-featured query engine that you can use to define filters. ``` auto namedDunderMifflin = companies.where([](auto &company) {     return company.name == \"Dunder Mifflin\"; }); \n``` ### Supported Query Operators Currently, the Realm C++ SDK Alpha supports the following query operators: * Equality (`==`, `!=`)\n* Greater than/less than (`>`, `>=`, `<`, `<=`)\n* Compound queries (`||`, `&&`) ### Check the Size of the Results Set and Access Results Realm [Results](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1results.html) exposes public member functions to work with results. You may want to check the size of a results set, or access the object at a specific index. ``` auto companies = realm.objects<Company>(); auto namedDunderMifflin = companies.where([](auto &company) {     return company.name == \"Dunder Mifflin\"; }); CHECK(namedDunderMifflin.size() >= 1); Company dunderMifflin = namedDunderMifflin[0]; std::cout << \"Company named: \" << dunderMifflin.name << \"\\n\"; \n``` Additionally, you can iterate through the results, or observe a results set for changes. ### Read a Map Property You can iterate and check the values of a realm [map property](https://www.mongodb.com/docs/realm-sdks/cpp/latest/classrealm%5F1%5F1persisted%5F%5Fmap%5F%5Fbase.html)as you would a standard C++ [map:](https://en.cppreference.com/w/cpp/container/map) ``` auto employees = realm.objects<Employee>(); auto employeesNamedTommy = employees.where([](auto &employee) {     return employee.firstName == \"Tommy\"; }); auto tommy = employeesNamedTommy[0]; // You can iterate through keys and values and do something with them for (auto [k, v] : tommy.locationByDay) {     if (k == \"Monday\") CHECK(v == Employee::WorkLocation::HOME);     else if (k == \"Tuesday\") CHECK(v == Employee::WorkLocation::OFFICE); } // You can get an iterator for an element matching a key using `find()` auto tuesdayIterator = tommy.locationByDay.find(\"Tuesday\"); // You can access values for keys like any other map type auto mondayLocation = tommy.locationByDay[\"Monday\"]; \n``` ← [CRUD - Create - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/crud/create/ \"Previous Section\")[CRUD - Update - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/crud/update/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/crud/filter-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Filter Data - C++ SDK (Alpha) On this page * [Overview](#overview)\n* [About the Examples on This Page](#about-the-examples-on-this-page)\n* [Filter Data](#filter-data)\n* [Comparison Operators](#comparison-operators)\n* [Logical Operators](#logical-operators)\n* [String Operators](#string-operators) ## Overview To filter data in your realm, you can leverage Realm Database's query engine. ## Note While the Realm C++ SDK is in development, it does not yet support the full range of query expressions that the other Realm SDKs provide. ## About the Examples on This Page The examples in this page use a simple data set for a todo list app. The two Realm object types are `Project`and `Item`. An `Item` has: * A name\n* A completed flag\n* An optional assignee's name\n* A number repesenting priority, where higher is more important\n* A count of minutes spent working on it A `Project` has a name and a to-many relationship to zero or more `Items`. The schemas for `Project` and `Item` are:\n\n ` You can set up the realm for these examples with the following code: ``` auto realm = realm::open<Project, Item>(); auto item1 = Item {     .name = \"Save the cheerleader\",     .assignee = std::string(\"Peter\"),     .isComplete = false,     .priority = 6,     .progressMinutes = 30 }; auto project = Project {     .name = \"New project\" }; project.items.push_back(item1); realm.write([&project, &realm] {     realm.add(project); }); auto items = realm.objects<Item>(); auto projects = realm.objects<Project>(); \n``` ## Filter Data ### Comparison Operators Value comparisons\n\n ## Example The following example uses the query engine's comparison operators to: * Find high priority tasks by comparing the value of the `priority` property value with a threshold number, above which priority can be considered high.\n* Find just-started or short-running tasks by seeing if the `progressMinutes`property falls within a certain range.\n* Find unassigned tasks by finding tasks where the `assignee` property is equal to `std::nullopt`.\n* Find tasks assigned to specific teammates Ali or Jamie by seeing if the`assignee` property is in a list of names. ``` auto highPriorityItems = items.where([](auto const& item) {     return item.priority > 5; }); auto quickItems = items.where([](auto const& item) {     return item.progressMinutes > 1 && item.progressMinutes < 30; }); auto unassignedItems = items.where([](auto const& item) {     return item.assignee == std::nullopt; }); auto aliOrJamieItems = items.where([](auto const& item) {     return item.assignee == std::string(\"Ali\") || item.assignee == std::string(\"Jamie\"); }); \n``` ### Logical Operators You can use the logical operators listed in the following table to make compound predicates: | Operator | Description                                                             |\n| -------- | ----------------------------------------------------------------------- |\n| &&       | Evaluates to true if both left-hand and right-hand expressions aretrue. |\n| !        | Negates the result of the given expression.                             |\n| \\||      | Evaluates to true if either expression returns true.                    | ## Example We can use the query language's logical operators to find all of Ali's completed tasks. That is, we find all tasks where the `assignee` property value is equal to 'Ali' AND the `isComplete` property value is `true`: ``` auto completedItemsForAli = items.where([](auto const& item) {     return item.assignee == std::string(\"Ali\") && item.isComplete == true; }); \n``` ### String Operators You can compare string values using these string operators. | Operator                    | Description                                                                                                 |\n| --------------------------- | ----------------------------------------------------------------------------------------------------------- |\n| .contains(\\_ value: String) | Evaluates to true if the left-hand string expression is found anywhere in the right-hand string expression. |\n| \\==                         | Evaluates to true if the left-hand string is lexicographically equal to the right-hand string.              |\n| !=                          | Evaluates to true if the left-hand string is not lexicographically equal to the right-hand string.          | ## Example The following example uses the query engine's string operators to find: * Projects with names that contain 'ie' ``` auto containIe = items.where([](auto const& item) {     return item.name.contains(\"ie\"); }); \n```\n\n",
  "https://www.mongodb.com/docs/realm/sdk/cpp/crud/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Delete - C++ SDK (Alpha) On this page * [Delete Realm Objects](#delete-realm-objects)\n* [Delete an Object](#delete-an-object)\n* [Delete Map Keys/Values](#delete-map-keys-values) ## Delete Realm Objects Deleting Realm Objects must occur within write transactions. For more information about write trasactions, see: [Key Concept: Transactions.](https://mongodb.com/docs/realm/sdk/cpp/crud/create/#std-label-cpp-write-transactions) ### Delete an Object To delete an object from a realm, pass the object to[Realm.remove() function](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html)inside of a write transaction. `| realm.write([&realm, &dog] { |\n| ---------------------------- |\n| realm.remove(dog);           |\n| });                          | ` ### Delete Map Keys/Values To delete a [map key](https://www.mongodb.com/docs/realm-sdks/cpp/latest/classrealm%5F1%5F1persisted%5F%5Fmap%5F%5Fbase.html), pass the key name to `erase()`: ``` realm.write([&realm, &tommy] {     tommy.locationByDay.erase(\"Tuesday\"); }); \n``` ← [CRUD - Update - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/crud/update/ \"Previous Section\")[Filter Data - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/crud/filter-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/cpp/crud/threading/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Threading - C++ SDK (Alpha) On this page * [Overview](#overview)\n* [Three Rules to Follow](#three-rules-to-follow)\n* [Communication Across Threads](#communication-across-threads)\n* [Pass Instances Across Threads](#pass-instances-across-threads)\n* [Use the Same Realm Across Threads](#use-the-same-realm-across-threads)\n* [Schedulers (Run Loops)](#schedulers--run-loops-)\n* [Refreshing Realms](#refreshing-realms)\n* [Realm's Threading Model in Depth](#realm-s-threading-model-in-depth)\n* [Compared and Contrasted with Git](#compared-and-contrasted-with-git)\n* [Internal Structure](#internal-structure) ## Overview To create performant apps, developers must write thread-safe and maintainable multithreaded code that avoids issues like deadlocking and race conditions. Realm provides tools specifically designed for performant multithreaded apps. ## Three Rules to Follow Before exploring Realm's tools for multithreaded apps, you need to understand and follow these three rules: Don't lock to read: Realm Database's [Multiversion Concurrency Control (MVCC)](#std-label-cpp-mvcc)architecture eliminates the need to lock for read operations. The values you read will never be corrupted or in a partially-modified state. You can freely read from the same Realm file on any thread without the need for locks or mutexes. Unnecessarily locking would be a performance bottleneck since each thread might need to wait its turn before reading. Avoid synchronous writes on the UI thread if you write on a background thread: You can write to a Realm file from any thread, but there can be only one writer at a time. Consequently, synchronous write transactions block each other. A synchronous write on the UI thread may result in your app appearing unresponsive while it waits for a write on a background thread to complete.[Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) writes on a background thread, so you should avoid synchronous writes on the UI thread with synced realms. Don't pass live objects, collections, or realms to other threads: Live objects, collections, and realm instances are **thread-confined**: that is, they are only valid on the thread on which they were created. Practically speaking, this means you cannot pass live instances to other threads. However, Realm Database offers several mechanisms for [sharing objects across threads.](#std-label-cpp-communication-across-threads) ## Communication Across Threads To access the same Realm file from different threads, you must instantiate a realm instance on every thread that needs access. As long as you specify the same configuration, all realm instances will map to the same file on disk. One of the key rules when working with Realm Database in a multithreaded environment is that objects are thread-confined: **you cannot access the instances of a realm, collection, or object that originated on other threads.**Realm Database's [Multiversion Concurrency Control (MVCC)](#std-label-cpp-mvcc)architecture means that there could be many active versions of an object at any time. Thread-confinement ensures that all instances in that thread are of the same internal version. When you need to communicate across threads, you have several options depending on your use case: * To modify an object on two threads, [query](https://mongodb.com/docs/realm/sdk/cpp/crud/filter-data/#std-label-cpp-client-query-engine)for the object on both threads.\n* To react to changes made on any thread, use Realm Database's[notifications.](https://mongodb.com/docs/realm/sdk/cpp/react-to-changes/#std-label-cpp-react-to-changes)\n* To see changes that happened on another thread in the current thread's realm instance, [refresh](#std-label-cpp-refreshing-realms) your realm instance.\n* To share an instance of a realm or specific object with another thread, share a [thread\\_safe\\_reference](#std-label-cpp-thread-safe-reference) to the realm instance or object.\n\n Instances of `realm::realm`, `realm::results`, and `realm::object` are_thread-confined_. That means you may only use them on the thread where you created them. You can copy thread-confined instances to another thread as follows: 1. Initialize a [thread\\_safe\\_reference](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1thread%5F%5Fsafe%5F%5Freference%5F3%5F01db%5F3%5F01Ts%5F8%5F8%5F8%5F01%5F4%5F01%5F4.html)with the thread-confined object.\n2. Pass the reference to the target thread.\n3. Resolve the reference on the target thread. If the referred object is a realm instance, resolve it by calling `.resolve()`; otherwise, move the reference to `realm.resolve()`. The returned object is now thread-confined on the target thread, as if it had been created on the target thread instead of the original thread. ## Important You must resolve a `thread_safe_reference` exactly once. Otherwise, the source realm will remain pinned until the reference gets deallocated. For this reason, `thread_safe_reference` should be short-lived.\n\n ` Another way to work with an object on another thread is to query for it again on that thread. But if the object does not have a primary key, it is not trivial to query for it. You can use `thread_safe_reference`on any object, regardless of whether it has a primary key. ### Use the Same Realm Across Threads You cannot share realm instances across threads. To use the same Realm file across threads, open a different realm instance on each thread. As long as you use the same [configuration](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1realm%5F1%5F1config.html), all Realm instances will map to the same file on disk. ## Schedulers (Run Loops) Some platforms or frameworks automatically set up a **scheduler** (or **run loop**), which continuously processes events during the lifetime of your app. The Realm C++ SDK detects and uses schedulers on the following platforms or frameworks: * macOS, iOS, tvOS, watchOS\n* Android\n* Qt Realm uses the scheduler to schedule work such as Device Sync upload and download. If your platform does not have a supported scheduler, or you otherwise want to use a custom scheduler, you can implement [realm::scheduler](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1scheduler.html) and pass the instance to the [realm::db\\_config](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1internal%5F1%5F1bridge%5F1%5F1realm%5F1%5F1config.html) you use to configure the realm. Realm will use the scheduler you pass to it. ``` struct MyScheduler : realm::scheduler {     MyScheduler() {         // ... Kick off task processor thread(s) and run until the scheduler         // goes out of scope ...     }     ~MyScheduler() override {         // ... Call in the processor thread(s) and block until return ...     }         void invoke(std::function<void()> &&task) override {         // ... Add the task to the (lock-free) processor queue ...     }     [[nodiscard]] bool is_on_thread() const noexcept override {         // ... Return true if the caller is on the same thread as a processor thread ...     }     bool is_same_as(const realm::scheduler *other) const noexcept override {         // ... Compare scheduler instances ...     }     [[nodiscard]] bool can_invoke() const noexcept override {         // ... Return true if the scheduler can accept tasks ...     }     // ... }; int main() {     // Set up a custom scheduler     auto scheduler = std::make_shared<MyScheduler>();         // Pass the scheduler instance to the realm configuration     auto config = realm::db_config{         std::nullopt, scheduler     };         // Start the program main loop     auto done = false;     while (!done) {         // This assumes the scheduler is implemented so that it         // continues processing tasks on background threads until         // the scheduler goes out of scope.                 // Handle input here         // ...         if (shouldQuitProgram) {             done = true;         }     } } \n``` ## Refreshing Realms\n\n When you initially open a realm on a thread, its state will be the most recent successful write commit, and it will remain on that version until refreshed. If a thread is not controlled by a run loop, then the [realm.refresh()](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html) method must be called manually in order to advance the transaction to the most recent state. ``` realm.refresh(); \n``` ## Note Failing to refresh realms on a regular basis could lead to some transaction versions becoming \"pinned\", preventing Realm from reusing the disk space used by that version and leading to larger file sizes. ## Realm's Threading Model in Depth Realm Database provides safe, fast, lock-free, and concurrent access across threads with its [Multiversion Concurrency Control (MVCC)](https://en.wikipedia.org/wiki/Multiversion%5Fconcurrency%5Fcontrol)architecture. ### Compared and Contrasted with Git If you are familiar with a distributed version control system like [Git](https://git-scm.com/), you may already have an intuitive understanding of MVCC. Two fundamental elements of Git are: * Commits, which are atomic writes.\n* Branches, which are different versions of the commit history. Similarly, Realm Database has atomically-committed writes in the form of transactions. Realm Database also has many different versions of the history at any given time, like branches. Unlike Git, which actively supports distribution and divergence through forking, a realm only has one true latest version at any given time and always writes to the head of that latest version. Realm Database cannot write to a previous version. This means your data converges on one latest version of the truth. ### Internal Structure A realm is implemented using a [B+ tree](https://en.wikipedia.org/wiki/B%2B%5Ftree) data structure. The top-level node represents a version of the realm; child nodes are objects in that version of the realm. The realm has a pointer to its latest version, much like how Git has a pointer to its HEAD commit. Realm Database uses a copy-on-write technique to ensure[isolation](https://en.wikipedia.org/wiki/Isolation%5F%28database%5Fsystems%29) and[durability](https://en.wikipedia.org/wiki/Durability%5F%28database%5Fsystems%29). When you make changes, Realm Database copies the relevant part of the tree for writing. Realm Database then commits the changes in two phases: * Realm Database writes changes to disk and verifies success.\n* Realm Database then sets its latest version pointer to point to the newly-written version. This two-step commit process guarantees that even if the write failed partway, the original version is not corrupted in any way because the changes were made to a copy of the relevant part of the tree. Likewise, the realm's root pointer will point to the original version until the new version is guaranteed to be valid. ## Example The following diagram illustrates the commit process: ![Realm Database copies the relevant part of the tree for writes, then replaces the latest version by updating a pointer.](https://mongodb.com/docs/realm/images/mvcc-diagram.png) click to enlarge 1. The realm is structured as a tree. The realm has a pointer to its latest version, V1.\n2. When writing, Realm Database creates a new version V2 based on V1\\. Realm Database makes copies of objects for modification (A 1, C 1), while links to unmodified objects continue to point to the original versions (B, D).\n3. After validating the commit, Realm Database updates the realm's pointer to the new latest version, V2\\. Realm Database then discards old nodes no longer connected to the tree. Realm Database uses zero-copy techniques like memory mapping to handle data. When you read a value from the realm, you are virtually looking at the value on the actual disk, not a copy of it. This is the basis for[live objects](https://mongodb.com/docs/realm/sdk/cpp/realm-database/#std-label-cpp-live-object). This is also why a realm head pointer can be set to point to the new version after the write to disk has been validated.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/cpp/crud/create/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Create - C++ SDK (Alpha) On this page * [Key Concept: Transactions](#key-concept--transactions)\n* [Write Transactions](#write-transactions)\n* [Create a New Object](#create-a-new-object)\n* [Create an Object](#create-an-object)\n* [Create an Embedded Object](#create-an-embedded-object)\n* [Create an Object with a To-One Relationship](#create-an-object-with-a-to-one-relationship)\n* [Create an Object with a To-Many Relationship](#create-an-object-with-a-to-many-relationship)\n* [Create an Object with a Map Property](#create-an-object-with-a-map-property)\n* [Create an Asymmetric Object](#create-an-asymmetric-object) ## Key Concept: Transactions ### Write Transactions Realm Database uses a highly efficient storage engine to persist objects. You can **create** objects in a realm,**update** objects in a realm, and eventually **delete**objects from a realm. Because these operations modify the state of the realm, we call them writes. Realm handles writes in terms of **transactions**. A transaction is a list of read and write operations that Realm treats as a single indivisible operation. In other words, a transaction is _all or nothing_: either all of the operations in the transaction succeed or none of the operations in the transaction take effect. All writes must happen in a transaction. A realm allows only one open transaction at a time. Realm blocks other writes on other threads until the open transaction is complete. Consequently, there is no race condition when reading values from the realm within a transaction. When you are done with your transaction, Realm either**commits** it or **cancels** it: * When Realm **commits** a transaction, Realm writes all changes to disk. For synced realms, the SDK queues the change for synchronization with Atlas Device Sync.\n* When Realm **cancels** a write transaction or an operation in the transaction causes an error, all changes are discarded (or \"rolled back\"). ## Create a New Object ### Create an Object To add an object to a realm, instantiate it as you would any other object. Then pass it to the [Realm.add() function](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html) inside of a write transaction. `| // Create a Realm object like a regular object.    |\n| -------------------------------------------------- |\n| auto dog = Dog { .name = \"Rex\", .age = 1 };        |\n| std::cout << \"dog: \" << dog << \"\\n\";               |\n| // Open a realm with compile-time schema checking. |\n| auto realm = realm::open<Dog>();                   |\n| // Persist your data in a write transaction        |\n| realm.write([&realm, &dog] {                       |\n| realm.add(dog);                                    |\n| });                                                | ` #### Model For more information about modeling an object, refer to:[Define a New Object Type.](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-define-a-new-object-type) ``` struct Dog : realm::object<Dog> {     realm::persisted<std::string> name;     realm::persisted<int64_t> age;     static constexpr auto schema = realm::schema(\"Dog\",         realm::property<&Dog::name>(\"name\"),\n\n }; \n``` ### Create an Embedded Object To create an embedded object, assign an instance of the embedded object to a parent object's property. Pass the parent object to the[Realm.add() function](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html) inside of a write transaction. ``` auto realm = realm::open<Business, ContactDetails>(); auto business = Business(); business.name = \"MongoDB\"; business.contactDetails = ContactDetails {      .emailAddress = \"email@example.com\",      .phoneNumber = \"123-456-7890\" }; realm.write([&realm, &business] {     realm.add(business); }); \n``` This adds both the parent object and the embedded object to the realm. The embedded object does not have its own lifecycle independent of the parent object. If you delete the parent object, the embedded object is also deleted. #### Model For more information about modeling an embedded object, refer to:[Define an Embedded Object.](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-embedded-object) ``` // Inherit from realm::embedded_object to declare an embedded object struct ContactDetails : realm::embedded_object<ContactDetails> {      // Because ContactDetails is an embedded object, it cannot have its own _id     // It does not have a lifecycle outside of the top-level object     realm::persisted<std::string> emailAddress;     realm::persisted<std::string> phoneNumber;     static constexpr auto schema = realm::schema(\"ContactDetails\",         realm::property<&ContactDetails::emailAddress>(\"emailAddress\"),         realm::property<&ContactDetails::phoneNumber>(\"phoneNumber\")); }; struct Business : realm::object<Business> {     realm::persisted<realm::object_id> _id{realm::object_id::generate()};     realm::persisted<std::string> name;     realm::persisted<std::optional<ContactDetails>> contactDetails;      static constexpr auto schema = realm::schema(\"Business\",         realm::property<&Business::_id, true>(\"_id\"),         realm::property<&Business::name>(\"name\"),         realm::property<&Business::contactDetails>(\"contactDetails\"));  }; \n``` ### Create an Object with a To-One Relationship To create an object with a to-one relationship link to another object, assign an instance of the linked object to the related object's property. Pass the main object to the [Realm.add() function](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html) inside of a write transaction. ``` auto realm = realm::open<Dog, FavoriteToy>(); auto favoriteToy = FavoriteToy {      ._id = realm::uuid(\"68b696c9-320b-4402-a412-d9cee10fc6a5\"),      .name = \"Wubba\" }; auto dog = Dog {      ._id = realm::uuid(\"68b696d7-320b-4402-a412-d9cee10fc6a3\"),      .name = \"Lita\",      .age = 10 }; dog.favoriteToy = favoriteToy; realm.write([&realm, &dog] {     realm.add(dog); }); \n``` This adds both the main object and the linked object to the realm, and creates a one-way connection from the main object to the linked object. In other Realm SDKs, you can create an inverse link to refer to the main object from the linked object. However, inverse links are not yet supported in the Realm C++ SDK. The linked object has its own lifecycle independent of the main object. If you delete the main object, the linked object remains. #### Model\n\n ``` struct FavoriteToy : realm::object<FavoriteToy> {     realm::persisted<realm::uuid> _id;     realm::persisted<std::string> name;     static constexpr auto schema = realm::schema(\"FavoriteToy\",         realm::property<&FavoriteToy::_id, true>(\"_id\"),         realm::property<&FavoriteToy::name>(\"name\")); }; struct Dog : realm::object<Dog> {     realm::persisted<realm::uuid> _id;     realm::persisted<std::string> name;     realm::persisted<int64_t> age;     // To-one relationship objects must be optional     realm::persisted<std::optional<FavoriteToy>> favoriteToy;     static constexpr auto schema = realm::schema(\"Dog\",         realm::property<&Dog::_id, true>(\"_id\"),         realm::property<&Dog::name>(\"name\"),         realm::property<&Dog::age>(\"age\"),         realm::property<&Dog::favoriteToy>(\"favoriteToy\")); }; \n``` ### Create an Object with a To-Many Relationship To create an object with a to-many relationship link to one or more objects: * Initialize the main object and the linked objects\n* Use the [push\\_back](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1persisted%5F3%5F01std%5F1%5F1vector%5F3%5F01T%5F01%5F4%5F00%5F01std%5F1%5F1enable%5F%5Fif%5F%5Ft%5F3%5F01std%5F1%5F1is%5F%5Fbf25bc7461a39304fb47e25c96413fa0e.html)member function available to the Realm object lists to append the linked objects to the main object's list property\n* Pass the main object to the to the [Realm.add() function](https://www.mongodb.com/docs/realm-sdks/cpp/latest/structrealm%5F1%5F1db.html) inside of a write transaction. ``` auto realm = realm::open<Company, Employee>(); auto employee1 = Employee {     ._id = 23456,     .firstName = \"Pam\",     .lastName = \"Beesly\" }; auto employee2 = Employee {     ._id = 34567,     .firstName = \"Jim\",     .lastName = \"Halpert\" }; auto company = Company {     ._id = 45678,     .name = \"Dunder Mifflin\" }; // Use the `push_back` member function available to the  // `ListObjectPersistable<T>` template to append `Employee` objects to // the `Company` `employees` list property.  company.employees.push_back(employee1); company.employees.push_back(employee2); realm.write([&realm, &company] {     realm.add(company); }); \n``` This adds the main object and the linked objects to the realm, and creates a one-way connection from the main object to the linked objects. In other Realm SDKs, you can create an inverse link to refer to the main object from the linked objects. However, inverse links are not yet supported in the Realm C++ SDK. The linked objects have their own lifecycles independent of the main object. If you delete the main object, the linked objects remain. #### Model For more information about modeling a to-many relationship, refer to:[Define a To-Many Relationship.](https://mongodb.com/docs/realm/sdk/cpp/model-data/relationships/#std-label-cpp-define-a-to-many-relationship-property) ``` struct Employee : realm::object<Employee> {     realm::persisted<int64_t> _id;     realm::persisted<std::string> firstName;\n\n     // Omitting the `realm::persisted` annotation means     // realm ignores this property     std::string jobTitle_notPersisted;     // Your schema consists of properties that you want realm to store.     // Omit properties that you want to ignore from the schema.     static constexpr auto schema = realm::schema(\"Employee\",         realm::property<&Employee::_id, true>(\"_id\"),         realm::property<&Employee::firstName>(\"firstName\"),         realm::property<&Employee::lastName>(\"lastName\")); }; \n``` ``` struct Company : realm::object<Company> {     realm::persisted<int64_t> _id;     realm::persisted<std::string> name;     // To-many relationships are a list, represented here as a     // vector container whose value type is the Realm object     // type that the list field links to.     realm::persisted<std::vector<Employee>> employees;     static constexpr auto schema = realm::schema(\"Company\",         realm::property<&Company::_id, true>(\"_id\"),         realm::property<&Company::name>(\"name\"),         realm::property<&Company::employees>(\"employees\")); }; \n``` ### Create an Object with a Map Property When you create an object that has a [map property](https://www.mongodb.com/docs/realm-sdks/cpp/latest/classrealm%5F1%5F1persisted%5F%5Fmap%5F%5Fbase.html), you can set the values for keys in a few ways: * Set keys and values on the object and then add the object to the realm\n* Set the object's keys and values directly inside a write transaction ``` auto realm = realm::open<Employee>(); auto employee = Employee {     ._id = 8675309,     .firstName = \"Tommy\",     .lastName = \"Tutone\" }; employee.locationByDay = {     { \"Monday\", Employee::WorkLocation::HOME },     { \"Tuesday\", Employee::WorkLocation::OFFICE },     { \"Wednesday\", Employee::WorkLocation::HOME },     { \"Thursday\", Employee::WorkLocation::OFFICE } }; realm.write([&realm, &employee] {     realm.add(employee);     employee.locationByDay[\"Friday\"] = Employee::WorkLocation::HOME; }); \n``` #### Model For more information about supported map data types, refer to:[Map/Dictionary.](https://mongodb.com/docs/realm/sdk/cpp/model-data/supported-types/#std-label-cpp-map) ``` struct Employee : realm::object<Employee> {     enum class WorkLocation {         HOME, OFFICE     };     realm::persisted<int64_t> _id;     realm::persisted<std::string> firstName;     realm::persisted<std::string> lastName;     realm::persisted<std::map<std::string, WorkLocation>> locationByDay;     static constexpr auto schema = realm::schema(\"Employee\",         realm::property<&Employee::_id, true>(\"_id\"),         realm::property<&Employee::firstName>(\"firstName\"),         realm::property<&Employee::lastName>(\"lastName\"),         realm::property<&Employee::locationByDay>(\"locationByDay\")); }; \n``` ### Create an Asymmetric Object\n\n ``` auto weatherSensorReading = WeatherSensorReading {     .deviceId = \"WX1278UIT\",     .temperatureInFahrenheit = 64.7,     .windSpeedInMph = 7 }; asymmetricRealm.write([&asymmetricRealm, &weatherSensorReading] {     asymmetricRealm.add(weatherSensorReading); }); \n``` For more information about working with asymmetric objects, refer to[Stream Data to Atlas - C++ SDK (Alpha).](https://mongodb.com/docs/realm/sdk/cpp/sync/stream-data-to-atlas/#std-label-cpp-stream-data-to-atlas) #### Model For more information about defining an asymmetric object, refer to:[Define an Asymmetric Object.](https://mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-define-asymmetric-object) ``` struct WeatherSensorReading : realm::asymmetric_object<WeatherSensorReading> {      realm::persisted<realm::object_id> _id{realm::object_id::generate()};     realm::persisted<std::string> deviceId;     realm::persisted<double> temperatureInFahrenheit;     realm::persisted<int64_t> windSpeedInMph;     static constexpr auto schema = realm::schema(\"WeatherSensorReading\",         realm::property<&WeatherSensorReading::_id, true>(\"_id\"),         realm::property<&WeatherSensorReading::deviceId>(\"deviceId\"),         realm::property<&WeatherSensorReading::temperatureInFahrenheit>(\"temperatureInFahrenheit\"),         realm::property<&WeatherSensorReading::windSpeedInMph>(\"windSpeedInMph\")); }; \n``` ← [CRUD - C++ SDK](https://mongodb.com/docs/realm/sdk/cpp/crud/ \"Previous Section\")[CRUD - Read - C++ SDK (Alpha)](https://mongodb.com/docs/realm/sdk/cpp/crud/read/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/migrate/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Upgrade from Stitch to Realm - Java SDK On this page * [New Features](#new-features)\n* [Changes](#changes) If you have an existing app built with the Stitch SDK, you should migrate your app to use the new Realm SDK. While much of the logic and flow of information hasn't changed, there are a few important changes in the way your app connects to the realm backend. ## New Features * The Realm Java SDK supports Android applications written in Kotlin.\n* The Realm Java SDK now includes Realm Database, which includes local object storage and [Sync.](https://mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/#std-label-java-sync-data) ## Changes\n\n ← [Interface RxObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/ \"Previous Section\")[Realm Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/livedata/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start with LiveData - Java SDK On this page * [Prerequisites](#prerequisites)\n* [Clone the LiveData Quick Start Repository](#clone-the-livedata-quick-start-repository)\n* [Import Dependencies](#import-dependencies)\n* [LiveRealmObject](#liverealmobject)\n* [Instantiating LiveData in the ViewModel](#instantiating-livedata-in-the-viewmodel)\n* [Connecting the ViewModel to the UI](#connecting-the-viewmodel-to-the-ui)\n* [Run the Application](#run-the-application)\n* [Summary](#summary)\n* [Feedback](#feedback) This page contains instructions to quickly get Realm Database integrated into an example Android application that uses [LiveData](https://developer.android.com/reference/androidx/lifecycle/LiveData). This example application allows a user to increment a counter using a button. ## Prerequisites This quick start guide uses [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) to synchronize data changes between clients. Before you begin, ensure you have: * [Installed the Java SDK.](https://mongodb.com/docs/realm/sdk/java/install/#std-label-java-install)\n* [Created an App.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enabled anonymous authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication-configuration)\n* [Enabled Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) ## Note ### Using LiveData without Sync To use this quick start without Sync, disable the sync features in the SDK. You can do this by removing the following lines from your app-level `build.gradle` file: `| realm {            |\n| ------------------ |\n| syncEnabled = true |\n| }                  | ` After removing the lines, re-synchronize the Gradle configuration to reload the Java SDK in an offline-only state. Remove the lines related to importing and using Sync Configuration, user login, and partition values from the `CounterModel` file to use the Java SDK without Sync. ## Clone the LiveData Quick Start Repository To get started, copy the [example repo](https://github.com/mongodb-university/realm-android-livedata)into your local environment. We've already put together an Android application that has most of the code you'll need. You can clone the client application repository directly from GitHub: ``` git clone https://github.com/mongodb-university/realm-android-livedata.git \n``` The repository contains two branches:`final` and `start`. The `final` branch is a finished version of the app as it should look _after_ you complete this tutorial. To walk through this tutorial, please check out the `start`branch: ``` git checkout start \n``` ## Import Dependencies Now that you've cloned the repo, you need to add the dependencies you'll need to run the Java SDK and Android LiveData. Begin by adding the Java SDK dependency to the `buildscript.dependencies`block of your project level `build.gradle` file: ``` buildscript {     ext.kotlin_version = \"1.4.10\"     repositories {         google()         jcenter()     }     dependencies {         classpath \"com.android.tools.build:gradle:4.0.2\"         classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"         classpath \"io.realm:realm-gradle-plugin:10.2.0\"     } } \n```\n\n ``` dependencies {     implementation fileTree(dir: \"libs\", include: [\"*.jar\"])     implementation \"org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version\"     implementation 'androidx.core:core-ktx:1.3.2'     implementation 'androidx.appcompat:appcompat:1.2.0'     implementation 'com.google.android.material:material:1.2.1'     implementation 'androidx.constraintlayout:constraintlayout:2.0.4'     implementation 'androidx.navigation:navigation-fragment-ktx:2.3.1'     implementation 'androidx.navigation:navigation-ui-ktx:2.3.1'     implementation \"androidx.lifecycle:lifecycle-livedata-ktx:2.2.0\"     testImplementation 'junit:junit:4.12'     androidTestImplementation 'androidx.test.ext:junit:1.1.2'     androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0' } \n``` Next, enable Sync in the SDK by creating the following top-level block in your app level `build.gradle` file: ``` realm {     syncEnabled = true } \n``` Then, enable DataBinding by creating the following block in the`android` block of your app level `build.gradle` file: ``` android {     compileSdkVersion 30     buildToolsVersion \"30.0.2\"     defaultConfig {         applicationId \"com.mongodb.realm.livedataquickstart\"         minSdkVersion 16         targetSdkVersion 30         versionCode 1         versionName \"1.0\"         testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"     }     buildFeatures {         dataBinding true     }     buildTypes {         release {             minifyEnabled false             proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'         }     }     compileOptions {         sourceCompatibility JavaVersion.VERSION_1_8         targetCompatibility JavaVersion.VERSION_1_8     }     kotlinOptions {         jvmTarget = '1.8'     } } \n``` Finally, click the \"Sync\" button or select Build > Rebuild Projectin the application menu to reconfigure your Gradle configuration with these changes and fetch the dependencies. ## LiveRealmObject With all of the dependencies in place, it's time to create a LiveData-compatible interface for our Realm objects. To do so, we'll have to handle a few events:\n\n ## Tip ### See also: Using LiveData with RealmResults This example only uses LiveData to display `RealmObjects` in the UI. For a sample implementation displaying `RealmResults`, see [LiveRealmResults.](https://github.com/mongodb-university/realm-android-livedata/blob/final/app/src/main/java/com/mongodb/realm/livedataquickstart/model/LiveRealmResults.kt) ## Instantiating LiveData in the ViewModel This application stores all of its logic and core data within a ViewModel called `CounterModel`. When the application runs, it creates an instance of `CounterModel` that is used until the application closes. That instance contains the LiveData that displays on the UI of the application. To create an instance of LiveData, we need to access a `Counter` object stored in a realm and pass it to the `LiveRealmObject` constructor. To accomplish this: 1. Connect to your App _with your_ **App ID**.\n2. Authenticate a user.\n3. Connect to a specific realm using Sync.\n4. Query the realm for a `Counter`, inserting a new `Counter` if one hasn't already been created in this realm.\n5. Instantiate a `LiveRealmObject` using the `Counter` instance and store it in the `counter` member of `CounterModel`. The following code snippet implements this behavior: ```kotlin init {     val appID = \"YOUR APP ID HERE\" // TODO: replace this with your App ID     // 1. connect to the MongoDB Realm app backend     val app = App(         AppConfiguration.Builder(appID)             .build()     )     // 2. authenticate a user     app.loginAsync(Credentials.anonymous()) {         if(it.isSuccess) {             Log.v(\"QUICKSTART\", \"Successfully logged in anonymously.\")             // 3. connect to a realm with Realm Sync             val user: User? = app.currentUser()             val partitionValue = \"example partition\"             val config = SyncConfiguration.Builder(user!!, partitionValue)                 // because this application only reads/writes small amounts of data, it's OK to read/write from the UI thread                 .allowWritesOnUiThread(true)                 .allowQueriesOnUiThread(true)                 .build()             // open the realm             realm = Realm.getInstance(config)             // 4. Query the realm for a Counter, creating a new Counter if one doesn't already exist             // access all counters stored in this realm             val counterQuery = realm!!.where<Counter>()             val counters = counterQuery.findAll()             // if we haven't created the one counter for this app before (as on first launch), create it now             if (counters.size == 0) {                 realm?.executeTransaction { transactionRealm ->                     val counter = Counter()                     transactionRealm.insert(counter)                 }             }             // 5. Instantiate a LiveRealmObject using the Counter and store it in a member variable\n\n             this._counter.postValue(counters[0]!!)         } else {             Log.e(\"QUICKSTART\", \"Failed to log in anonymously. Error: ${it.error.message}\")         }     } } \n``` ## Important ### Don't Read or Write on the UI Thread Database reads and writes are computationally expensive, so the SDK disables reads and writes by default on the UI thread. For simplicity, this example enables UI thread reads and writes with the `allowWritesOnUiThread()` and `allowQueriesOnUiThread()`config builder methods. In production applications, you should almost always defer reads and writes to a background thread using asynchronous methods. ## Connecting the ViewModel to the UI To display the data stored in the `CounterModel` on the application UI, we'll need to access the `CounterModel` singleton using the[viewModels()](https://developer.android.com/topic/libraries/architecture/viewmodel#kotlin)method when the application creates `CounterFragment`. Once we've instantiated the model, we can use the [Android Data Binding](https://developer.android.com/topic/libraries/data-binding) library to display the model's data in UI elements. To access the `CounterModel` singleton when the application creates`CounterFragment`, place the following code in the `onCreateView()`method of `CounterFragment`: ```kotlin val model: CounterModel by viewModels() \n``` Next, set up the Data Binding hooks in the UI for the counter fragment: ```kotlin <?xml version=\"1.0\" encoding=\"utf-8\"?> <layout>     <data>         <variable             name=\"counterModel\"             type=\"com.mongodb.realm.livedataquickstart.model.CounterModel\"         />     </data>         <androidx.constraintlayout.widget.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"             xmlns:app=\"http://schemas.android.com/apk/res-auto\"             xmlns:tools=\"http://schemas.android.com/tools\"             android:layout_width=\"match_parent\"             android:layout_height=\"match_parent\"             tools:context=\".CounterFragment\">             <TextView                 android:id=\"@+id/textview\"                 android:layout_width=\"wrap_content\"                 android:layout_height=\"wrap_content\"                 android:text=\"@{counterModel.counter.value.get().toString()}\"                 android:textSize=\"58pt\"                 app:layout_constraintBottom_toTopOf=\"@id/button\"                 app:layout_constraintEnd_toEndOf=\"parent\"                 app:layout_constraintStart_toStartOf=\"parent\"                 app:layout_constraintTop_toTopOf=\"parent\" />             <Button                 android:id=\"@+id/button\"                 android:layout_width=\"wrap_content\"\n\n                 android:text=\"@string/add\"                 app:layout_constraintBottom_toBottomOf=\"parent\"                 app:layout_constraintEnd_toEndOf=\"parent\"                 app:layout_constraintStart_toStartOf=\"parent\"                 app:layout_constraintTop_toBottomOf=\"@id/textview\" />     </androidx.constraintlayout.widget.ConstraintLayout> </layout> \n``` Finally, connect the model to the binding so that the UI can display the counter and iterate the counter on button press with the following code in the `onCreateView()` method of `CounterFragment`: ```kotlin val binding = CounterFragmentBinding.inflate(inflater, container, false).apply {     lifecycleOwner = viewLifecycleOwner     counterModel = model } binding.root.button.setOnClickListener {     Log.v(\"QUICKSTART\", \"Clicked increment button. Current value: ${model.counter.value?.value?.get()}\")     model.incrementCounter() } return binding.root \n``` ## Run the Application Now you should be able to run the sample application. You should see an interface that looks something like this: ![The LiveData QuickStart Counter app.](https://mongodb.com/docs/realm/images/android-livedata-quickstart-app.png) Clicking the \"ADD\" button should add one to the value of your counter. With Sync, you can view your App logs to see individual increment events. Android LiveData is lifecycle-aware, so rotating the screen or freeing the application's state by clearing your device's RAM should have no effect on the application state, which should seamlessly resume and automatically resubscribe to events on resume using the state stored in the model singleton and the encapsulated LiveData instance. ## Summary * Use the the `LiveRealmObject` and `LiveRealmResults` classes as a template for encapsulating live Realm data in Android LiveData.\n* Use a ViewModel to separate underlying data from the UI elements that display that data.\n* DataBinding lets you declare relationships between model data and UI elements without explicitly setting values in an Activity or Fragment. ## Feedback Did you find this quick start guide helpful? Please let us know with the feedback form on the right side of the page! ← [Quick Start with Sync - Java SDK](https://mongodb.com/docs/realm/sdk/java/quick-start-sync/ \"Previous Section\")[Realm Fundamentals - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Usage Examples - Java SDK ## Realm-Database (Non-Sync) * [Define a Realm Object Schema](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/)\n* [Open & Close a Realm](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/)\n* [Read & Write Data](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/)\n* [Filter Data](https://mongodb.com/docs/realm/sdk/java/examples/filter-data/)\n* [React to Changes](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/)\n* [Display Collections](https://mongodb.com/docs/realm/sdk/java/examples/adapters/)\n* [Modify an Object Schema](https://mongodb.com/docs/realm/sdk/java/examples/modify-an-object-schema/)\n* [Bundle a Realm](https://mongodb.com/docs/realm/sdk/java/examples/bundle-a-realm/)\n* [Log Realm Events](https://mongodb.com/docs/realm/sdk/java/examples/log-realm-events/) ## Application Services (Sync) * [Connect to an Atlas App Services backend](https://mongodb.com/docs/realm/sdk/java/examples/connect-to-app-services-backend/)\n* [Authenticate Users](https://mongodb.com/docs/realm/sdk/java/examples/authenticate-users/)\n* [Sync Changes Between Devices](https://mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/)\n* [Flexible Sync](https://mongodb.com/docs/realm/sdk/java/examples/flexible-sync/)\n* [Reset a Client Realm](https://mongodb.com/docs/realm/sdk/java/examples/reset-a-client-realm/)\n* [Call a Function](https://mongodb.com/docs/realm/sdk/java/examples/call-a-function/)\n* [Manage Email/Password Users](https://mongodb.com/docs/realm/sdk/java/examples/email-password-users/)\n* [Create & Manage User API Keys](https://mongodb.com/docs/realm/sdk/java/examples/manage-user-api-keys/)\n* [Query MongoDB](https://mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/) ← [Embedded Objects - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/embedded-objects/ \"Previous Section\")[Define a Realm Object Schema - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - Java SDK MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Troubleshooting - Java SDK](https://mongodb.com/docs/realm/sdk/java/troubleshooting/ \"Previous Section\")[API Reference](https://mongodb.com/docs/realm/sdk/java/api/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Fundamentals - Java SDK * [Realm Database](https://mongodb.com/docs/realm/sdk/java/fundamentals/realm-database/)\n* [Asynchronous API](https://mongodb.com/docs/realm/sdk/java/fundamentals/async-api/)\n* [Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/)\n* [Live Queries](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/)\n* [Query Engine](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/)\n* [Write Transactions](https://mongodb.com/docs/realm/sdk/java/fundamentals/write-transactions/)\n* [Relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/)\n* [Object Models & Schemas](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/)\n* [Schema Versions & Migrations](https://mongodb.com/docs/realm/sdk/java/fundamentals/schema-versions-and-migrations/)\n* [Application Services](https://mongodb.com/docs/realm/sdk/java/fundamentals/application-services/)\n* [Atlas Device Sync](https://mongodb.com/docs/realm/sdk/java/fundamentals/device-sync/) ← [Quick Start with LiveData - Java SDK](https://mongodb.com/docs/realm/sdk/java/livedata/ \"Previous Section\")[Asynchronous API - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/async-api/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Advanced Guides - Java SDK ## Realm-Database (Non-Sync) * [Encryption](https://mongodb.com/docs/realm/sdk/java/advanced-guides/encryption/)\n* [Threading](https://mongodb.com/docs/realm/sdk/java/advanced-guides/threading/)\n* [Testing](https://mongodb.com/docs/realm/sdk/java/advanced-guides/testing/)\n* [Debugging](https://mongodb.com/docs/realm/sdk/java/advanced-guides/debugging/) ## Application Services (Sync) * [Link User Identities](https://mongodb.com/docs/realm/sdk/java/advanced-guides/link-user-identities/)\n* [Multi-User Applications](https://mongodb.com/docs/realm/sdk/java/advanced-guides/multi-user-applications/)\n* [Custom User Data](https://mongodb.com/docs/realm/sdk/java/advanced-guides/custom-user-data/)\n* [Sync a Realm in the Background](https://mongodb.com/docs/realm/sdk/java/advanced-guides/background-sync/)\n* [Manual Client Reset Data Recovery](https://mongodb.com/docs/realm/sdk/java/advanced-guides/manual-client-reset-data-recovery/) ← [Query MongoDB - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/ \"Previous Section\")[Encrypt a Realm - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/encryption/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Data Types - Java SDK * [Field Types](https://mongodb.com/docs/realm/sdk/java/data-types/field-types/)\n* [Enumerations](https://mongodb.com/docs/realm/sdk/java/data-types/enums/)\n* [Counters](https://mongodb.com/docs/realm/sdk/java/data-types/counters/)\n* [RealmAny](https://mongodb.com/docs/realm/sdk/java/data-types/realmany/)\n* [RealmSet](https://mongodb.com/docs/realm/sdk/java/data-types/realmset/)\n* [RealmDictionary](https://mongodb.com/docs/realm/sdk/java/data-types/realmdictionary/)\n* [Collections](https://mongodb.com/docs/realm/sdk/java/data-types/collections/)\n* [Embedded Objects](https://mongodb.com/docs/realm/sdk/java/data-types/embedded-objects/) ← [Atlas Device Sync - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/device-sync/ \"Previous Section\")[Field Types - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/field-types/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/troubleshooting/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Troubleshooting - Java SDK On this page * [Couldn't load \"librealm-jni.so\"](#couldn-t-load--librealm-jni.so-)\n* [Network Calls to Mixpanel](#network-calls-to-mixpanel)\n* [Change Listeners in Android 12 with SDK Versions Below 10.5.1](#change-listeners-in-android-12-with-sdk-versions-below-10.5.1)\n* [Configurations Cannot be Different if Used to Open the Same File](#configurations-cannot-be-different-if-used-to-open-the-same-file)\n* [Kapt Exceptions During Builds](#kapt-exceptions-during-builds)\n* [Installation Size](#installation-size)\n* [Customize Dependecies Defined by the Realm Gradle Plugin](#customize-dependecies-defined-by-the-realm-gradle-plugin) ## Couldn't load \"librealm-jni.so\" If your app uses native libraries that don't ship with support for 64-bit architectures, Android will fail to load Realm's`librealm-jni.so` file on ARM64 devices. This happens because Android cannot load 32-bit and 64-bit native libraries concurrently. Ideally, all libraries could provide the same set of supported ABIs, but sometimes that may not be doable when using a 3rd-party library. To work around this issue, you can exclude Realm's ARM64 library from the APK file by adding the following code to the application's`build.gradle`. You can refer to Mixing 32- and 64-bit Dependencies in Android for more information. `| android {                               |\n| --------------------------------------- |\n| //...                                   |\n| packagingOptions {                      |\n| exclude \"lib/arm64-v8a/librealm-jni.so\" |\n| }                                       |\n| //...                                   |\n| }                                       | ` ## Tip ### See also:  For more information, see [Mixing 32- and 64-bit Dependencies in Android.](https://corbt.com/posts/2015/09/18/mixing-32-and-64bit-dependencies-in-android.html) ## Network Calls to Mixpanel Realm collects anonymous analytics when you run the Realm bytecode transformer on your source code. This is completely anonymous and helps us improve the product by flagging: * which version of the SDK you use\n* which operating system you use\n* if your application uses Kotlin\n* if your application uses local-only Realm Database or Sync Analytics do not run when your application runs on user devices - only when you compile your source code. To opt out of analytics, you can set the `REALM_DISABLE_ANALYTICS` environment variable to `true`. ## Change Listeners in Android 12 with SDK Versions Below 10.5.1 Due to a change in the Linux kernel,[object, collection, and realm notifications](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-client-notifications) do not work in SDK versions below 10.5.1 on devices running certain early versions of Android 12.\n\n If you experience this issue, you can restore notification functionality with the following fixes: * upgrade to a version of the SDK later than 10.5.1.\n* upgrade to a version of Android 12 that uses a Linux kernel release that contains the fix (kernel commit `3a34b13a88caeb2800ab44a4918f230041b37dd9`) or the backport of the fix (kernel commit `4b20d2de0b367bca627b49efd8d2e9e01bb66753`). ## Configurations Cannot be Different if Used to Open the Same File Realm Database runs checks whenever you open a realm file to avoid corruption. In order to avoid accidentally opening a realm file with incompatible settings, the SDK uses Java's `equals()` method to compare `RealmConfiguration` objects. This prevents the SDK from opening a single realm file with different schemas, durability levels, or writability settings. However, configurations that include lambda functions, such as those passed to[initialData()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#initialData-io.realm.Realm.Transaction-)and[compactOnLaunch()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#compactOnLaunch-io.realm.CompactOnLaunchCallback-), can break this `equals()` comparison, since two different lambdas are never considered equal using Java's built-in comparison. To avoid this error when using lambdas, you can either: 1. Store a single configuration statically in your application, so that separate realm instances use the exact same`RealmConfiguration` object and it passes the check.\n2. Override the default equals check of the `RealmConfiguration`:  \n```kotlin  \nval config = RealmConfiguration.Builder()  \n     .initialData(object: Realm.Transaction {  \n         override fun execute(realm: Realm) {  \n             TODO(\"Not yet implemented\")  \n         }  \n         override fun equals(other: Any?): Boolean {  \n             return true  \n         }  \n         override fun hashCode(): Int {  \n             return 37  \n         }  \n     }).build()  \n``` ## Kapt Exceptions During Builds If you experience an exception in the Kapt library with a description like the following: ``` A failure occurred while executing org.jetbrains.kotlin.gradle.internal.KaptWithoutKotlincTask$KaptExecutionWorkAction \n``` This most likely means there is an issue with one of your model classes. Possible causes include: * introducing a field type that is not [supported](https://mongodb.com/docs/realm/sdk/java/data-types/field-types/#std-label-java-field-types) by the SDK\n* using a visibility type other than `open` or `public` for a realm object model class\n* using a Realm annotation on an incompatible field If you experience this error, check any recent updates to your schema for problems. ## Installation Size Once your app is built for release and split for distribution, the SDK should only add about 800KB to your APK in most cases. The releases are significantly larger because they include support for more architectures, such as ARM7, ARMv7, ARM64, x86, and MIPS. The APK file contains all supported architectures, but the Android installer only installs native code for the device's architecture. This means that the installed app is smaller than the size of the APK file. You can reduce the size of the Android APK itself by splitting the APK into a version for each architecture. Use the Android Build Tool ABI Split support by adding the following to your `build.gradle`: ``` android {     splits {         abi {             enable true             reset()\n\n         }     } } \n``` Select the architectures that you'd like to include to build a separate APK for each. ## Tip ### See also:  See the [Android Tools documentation about ABI Splits](https://developer.android.com/studio/build/configure-apk-splits.html)for more information, or the [example on GitHub.](https://github.com/realm/realm-java/tree/master/examples/gridViewExample) If you don't want to handle multiple APKs, you can restrict the number of architectures supported in a single APK. This is done by adding`abiFilters` to your `build.gradle`: ``` android {     defaultConfig {         ndk {             abiFilters 'armeabi-v7a', 'arm64-v8a', 'mips', 'x86', 'x86_64'         }     } } \n``` ## Tip ### See also:  For more details about ABI splits and filters, see[Controlling APK Size When Using Native Libraries.](https://android.jlelse.eu/controlling-apk-size-when-using-native-libraries-45c6c0e5b70a) ## Customize Dependecies Defined by the Realm Gradle Plugin Realm uses a Gradle plugin because it makes it easier to set up a large number of dependencies. Unfortunately this also makes it a bit harder to ignore specific transitive dependencies. If you want to customize Realm beyond what is exposed by the plugin, you can manually set up all the dependencies and ignore the Gradle plugin. The following example demonstrates how to set up the SDK for an Android application using Kotlin manually: ``` buildscript {     ext.kotlin_version = '1.5.21'     ext.realm_version = '10.11.1'     repositories {         jcenter()         mavenCentral()     }     dependencies {         classpath \"io.realm:realm-transformer:$realm_version\"         classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\"     } } apply plugin: 'com.android.application' apply plugin: 'kotlin-android' apply plugin: 'kotlin-kapt' import io.realm.transformer.RealmTransformer android.registerTransform(new RealmTransformer(project)) dependencies {   api \"io.realm:realm-annotations:$realm_version\"   api \"io.realm:realm-android-library:$realm_version\"   api \"io.realm:realm-android-kotlin-extensions:$realm_version\"   kapt \"io.realm:realm-annotations-processor:$realm_version\" } \n``` ← [Manual Client Reset Data Recovery - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/manual-client-reset-data-recovery/ \"Previous Section\")[Telemetry - Java SDK](https://mongodb.com/docs/realm/sdk/java/telemetry/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm - Java SDK On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Installation](#installation)\n* [Project Gradle Configuration](#project-gradle-configuration)\n* [Application Module Gradle Configuration](#application-module-gradle-configuration)\n* [Enable Atlas Device Sync](#enable-atlas-device-sync)\n* [Supported Platforms](#supported-platforms) ## Overview This page details how to install Realm in your project and get started. ## Prerequisites * [Android Studio](https://developer.android.com/studio/index.html) version 1.5.1 or higher.\n* Java Development Kit (JDK) 11 or higher.\n* An emulated or hardware Android device for testing.\n* Android API Level 16 or higher (Android 4.1 and above). ## Installation Realm only supports the Gradle build system. Follow these steps to add the Realm Java SDK to your project. ## Note ### ProGuard Because Realm provides a ProGuard configuration as part of the Realm library, you do not need to add any Realm-specific rules to your ProGuard configuration. ### Project Gradle Configuration To add local-only Realm Database to your application, make the following changes to your project-level Gradle build file, typically found at `<project>/build.gradle`: ### Application Module Gradle Configuration Then, make the following changes to your application-level Gradle build file, typically found at `<project>/app/build.gradle`: After updating the `build.gradle` files, resolve the dependencies by clicking File > Sync Project with Gradle Files. ## Enable Atlas Device Sync To use Atlas Device Sync in your application, create a `realm` block in your application module `build.gradle`. Within this block, set `syncEnabled`to `true`. `| realm {            |\n| ------------------ |\n| syncEnabled = true |\n| }                  | ` ## Supported Platforms Realm's Java SDK enables you to build apps for the following platforms: * Android\n* Wear OS\n* Android Automotive OS\n* Android TV\n* Android Things ← [Realm Java SDK](https://mongodb.com/docs/realm/sdk/java/ \"Previous Section\")[Quick Start - Java SDK](https://mongodb.com/docs/realm/sdk/java/quick-start-local/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # API Reference The Java API reference docs are now integrated into the main documentation site. Use the side bar to browse packages. Miss the old reference docs? You can still see the [Javadoc version](https://www.mongodb.com/docs/realm-sdks/java/latest/) and the [Kotlin Extensions Reference Manual.](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/) ← [Telemetry - Java SDK](https://mongodb.com/docs/realm/sdk/java/telemetry/ \"Previous Section\")[io.realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/log-realm-events/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Log Realm Events - Java SDK On this page * [Set the Client Log Level](#set-the-client-log-level) The SDK logs events to the Android system log automatically. You can view these events using [Logcat.](https://developer.android.com//studio/debug/am-logcat) ## Set the Client Log Level Realm uses the log levels defined by [Log4J](https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html). To configure the log level for Realm logs in your application, pass a[LogLevel](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/log/LogLevel.html) to[RealmLog.setLevel():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/log/RealmLog.html#setLevel-int-) ## Tip To diagnose and troubleshoot errors while developing your application, set the log level to `debug` or `trace`. For production deployments, decrease the log level for improved performance. ← [Bundle a Realm File - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/bundle-a-realm/ \"Previous Section\")[Connect to an Atlas App Services backend - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/connect-to-app-services-backend/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/quick-start-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start with Sync - Java SDK On this page * [Initialize Realm](#initialize-realm)\n* [Initialize the App](#initialize-the-app)\n* [Define Your Object Model](#define-your-object-model)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Realm](#open-a-realm)\n* [Create, Read, Update, and Delete Objects](#create--read--update--and-delete-objects)\n* [Watch for Changes](#watch-for-changes)\n* [Log Out](#log-out)\n* [Complete Example](#complete-example)\n* [Output](#output) ## Tip ### This Guide uses Device Sync This guide helps you get started with an Android application that communicates with an App backend. The App provides features like [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), Realm Functions, and user management. If your application requires only local database functionality, check out the [Quick Start (Local-only)](https://mongodb.com/docs/realm/sdk/java/quick-start-local/#std-label-java-client-quick-start-local) guide. This page contains information to quickly get Atlas App Services integrated into your app. Before you begin, ensure you have: * [Created an App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enabled Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync)\n* [Installed the Java SDK](https://mongodb.com/docs/realm/sdk/java/install/#std-label-java-install) ## Initialize Realm Before you can use Realm in your app, you must initialize the Realm library. Your application should initialize Realm just once each time the application runs. To initialize the Realm library, provide an Android`context` to the `Realm.init()` static function. You can provide an Activity, Fragment, or Application `context` for initialization with no difference in behavior. You can initialize the Realm library in the `onCreate()` method of an [application subclass](https://developer.android.com/reference/android/app/Application) to ensure that you only initialize Realm once each time the application runs. ## Tip ### Register Your Application Subclass in the Android Manifest If you create your own `Application` subclass, you must add it to your application's `AndroidManifest.xml` to execute your custom application logic. Set the `android.name` property of your manifest's application definition to ensure that Android instantiates your `Application`subclass before any other class when a user launches your application.\n\n ` ## Initialize the App To use App Services features such as authentication and sync, access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) in the App Services UI. ## Note ### Android Studio Errors? If Android Studio does not recognize the `Realm`, `App`, or`AppConfiguration` types, there could be a problem with the your Gradle build configuration. To fix the issue: * Clean your project with `Build > Clean Project`\n* Rebuild your project based on your updated `build.gradle` file with `Build > Rebuild Project`\n* Revisit the [Install the Java SDK](https://mongodb.com/docs/realm/sdk/java/install/#std-label-java-install)guide to make sure that you installed the dependencies correctly. ## Define Your Object Model Your application's **data model** defines the structure of data stored within Realm Database and synchronized to and from App Services. You can define your application's data model in two ways: * Via [schemas](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) in App Services.\n* Via Kotlin or Java classes in your application code with[Realm Object Models.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/#std-label-create-schema-from-rom) This quick start uses the latter approach, which defines your schema using classes in your mobile application code. To define your App's object model in this way, you need to enable [Development Mode.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) Once you've enabled Development Mode, add the following class definitions to your application code: ## Tip ### See also:  See [Configure Your Data Model](https://www.mongodb.com/docs/atlas/app-services/sync/configure-your-data-model/#std-label-configure-your-data-model) for more information on Realm Schema, object models, and Developer Mode. ## Authenticate a User When you have enabled [anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) in the App Services UI, users can immediately log into your app without providing any identifying information: Realm provides many additional ways to authenticate, register, and link users. ## Tip ### See also:  [Authenticate a User](https://mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-authenticate) ## Open a Realm Once you have [enabled Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) and authenticated a user, you can open a synced [realm](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realms). Use`SyncConfiguration` to control the specifics of how your application synchronizes data with App Services, including timeouts, synchronous reads and writes on the UI thread, and more. ## Tip ### See also:  [Sync Data](https://mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/#std-label-java-sync-data) ## Create, Read, Update, and Delete Objects Once you have opened a realm, you can modify the[objects](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-objects) within that realm in a[write transaction](https://mongodb.com/docs/realm/sdk/java/fundamentals/write-transactions/#std-label-java-open-a-transaction) block. ## Important ### Synchronous Reads and Writes on the UI Thread\n\n This restriction exists for the benefit of your application users: performing read and write operations on the UI thread can lead to unresponsive or slow UI interactions, so it's usually best to handle these operations either asynchronously or in a background thread. However, if your application requires the use of synchronous realm reads or writes on the UI thread, you can explicitly allow the use of synchronous methods with the following`SyncConfiguration` options: To create a new `Task`, instantiate an instance of the`Task` class and add it to the realm in a write block: You can retrieve a live [collection](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-client-collections)of all items in the realm: You can also filter that collection using a [filter:](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-client-query-engine) To modify a task, update its properties in a write transaction block: Finally, you can delete a task by calling the `deleteFromRealm()`method in a write transaction block: ## Watch for Changes You can [watch a realm, collection, or object for changes](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-client-notifications) by attaching a custom`OrderedRealmCollectionChangeListener` with the `addChangeListener()`method: ## Log Out Once logged in, you can log out: ## Complete Example Run the complete example by replacing the appId with your realm app ID. If you're running this project in a fresh Android Studio project, you can copy and paste this file into your application's `MainActivity` \\-- just remember to: * change the package declaration so it matches your project\n* replace the App ID placeholder with your App's App ID\n* update the `import` statements for `Task` and `TaskStatus` if you're using Java ## Output Running the above code should produce output resembling the following: ```shell Successfully authenticated anonymously. Updated range: 0 to 1 Deleted range: 0 to 1 Successfully logged out. \n``` ← [Quick Start - Java SDK](https://mongodb.com/docs/realm/sdk/java/quick-start-local/ \"Previous Section\")[Quick Start with LiveData - Java SDK](https://mongodb.com/docs/realm/sdk/java/livedata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/adapters/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Display Collections - Java SDK On this page * [Install Adapters](#install-adapters)\n* [Example Models](#example-models)\n* [Display Collections in a ListView](#display-collections-in-a-listview)\n* [Display Collections in a RecyclerView](#display-collections-in-a-recyclerview) Android apps often populate the UI using[RecyclerView](https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html)or [ListView](https://developer.android.com/reference/android/widget/ListView) components. Realm offers **adapters** to display realm object[collections](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-client-collections). These collections implement the `OrderedRealmCollections` interface. [RealmResults](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-results-collections)and [RealmList](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-list-collections) are examples of these adaptors. With these adapters, UI components update when your app changes Realm objects. ## Install Adapters Add these dependencies to your application level `build.gradle` file: `| dependencies {                                            |\n| --------------------------------------------------------- |\n| implementation 'io.realm:android-adapters:4.0.0'          |\n| implementation 'androidx.recyclerview:recyclerview:1.1.0' |\n| }                                                         | ` Realm hosts these adapters on the[JCenter](https://mvnrepository.com/repos/jcenter)artifact repository. To use `jcenter` in your Android app, add it to your project-level `build.gradle` file: ``` buildscript {     repositories {         jcenter()     } } allprojects {     repositories {         jcenter()     } } \n``` ## Tip ### See also:  Source code: [realm/realm-android-adapters](https://github.com/realm/realm-android-adapters) on GitHub. ## Example Models The examples on this page use a Realm object named `Item`. This class contains a string named \"name\" and an identifier number named \"id\": ## Display Collections in a ListView Display Realm objects in a[ListView](https://developer.android.com/reference/android/widget/ListView) by extending[RealmBaseAdapter](https://github.com/realm/realm-android-adapters/blob/master/adapters/src/main/java/io/realm/RealmBaseAdapter.java). The adapter uses the `ListAdapter` interface. Implementation works like any `ListAdapter`. This provides support for automatically-updating Realm objects. Subclass `RealmBaseAdapter` to display[Item](#std-label-java-adapters-model-item) objects in a `ListView`: ## Display Collections in a RecyclerView Display Realm objects in a[RecyclerView](https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.html)by extending [RealmRecyclerViewAdapter](https://github.com/realm/realm-android-adapters/blob/master/adapters/src/main/java/io/realm/RealmRecyclerViewAdapter.java). The adapter extends `RecyclerView.Adapter`. Implementation works like any`RecyclerView` adapter. This provides support for automatically-updating Realm objects.\n\n ← [React to Changes - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/ \"Previous Section\")[Modify an Object Schema - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/modify-an-object-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/connect-to-app-services-backend/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Connect to an Atlas App Services backend - Java SDK On this page * [Initialize Realm](#initialize-realm)\n* [Access the App Client](#access-the-app-client)\n* [Configuration](#configuration) The App client is the interface for the App Services backend. It provides access to the [authentication functionality](https://mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-authenticate), [functions](https://mongodb.com/docs/realm/sdk/java/examples/call-a-function/#std-label-java-call-a-function), and[sync management.](https://mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/#std-label-java-sync-data) ## Initialize Realm Before you can use Realm in your app, you must initialize the Realm library. Your application should initialize Realm just once each time the application runs. To initialize the Realm library, provide an Android`context` to the `Realm.init()` static function. You can provide an Activity, Fragment, or Application `context` for initialization with no difference in behavior. You can initialize the Realm library in the `onCreate()` method of an [application subclass](https://developer.android.com/reference/android/app/Application) to ensure that you only initialize Realm once each time the application runs. ## Tip ### Register Your Application Subclass in the Android Manifest If you create your own `Application` subclass, you must add it to your application's `AndroidManifest.xml` to execute your custom application logic. Set the `android.name` property of your manifest's application definition to ensure that Android instantiates your `Application`subclass before any other class when a user launches your application. `| <?xml version=\"1.0\" encoding=\"utf-8\"?>                               |\n| -------------------------------------------------------------------- |\n| <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" |\n| package=\"com.mongodb.example\">                                       |\n| <application                                                         |\n| android:name=\".MyApplicationSubclass\"                                |\n| ...                                                                  |\n| />                                                                   |\n| </manifest>                                                          | ` ## Access the App Client Pass the App ID for your App, which you can [find in the Realm UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ## Important ### Initialize the App before Creating an Instance You must initialize your App connection with`Realm.init()` before creating any instance of an `App`. ## Note You can create multiple `App` instances to connect to multiple Apps or to the same App with different configurations. All`App` instances that share the same App ID use the same underlying connection. ## Configuration\n\n ## Note For most use cases, you only need your application's App ID to connect to Realm. The other settings demonstrated here are optional. ← [Log Realm Events - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/log-realm-events/ \"Previous Section\")[Authenticate Users - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/authenticate-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/quick-start-local/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - Java SDK On this page * [Initialize Realm](#initialize-realm)\n* [Define Your Object Model](#define-your-object-model)\n* [Open a Realm](#open-a-realm)\n* [Create, Read, Update, and Delete Objects](#create--read--update--and-delete-objects)\n* [Watch for Changes](#watch-for-changes)\n* [Complete Example](#complete-example)\n* [Output](#output) ## Tip ### This Guide Does Not Use Device Sync This guide can help you get started with device-local Realm Database. If your application needs to communicate with a backend App over the network using features like [Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), Realm Functions, or user management, you should follow the[Quick Start with Sync](https://mongodb.com/docs/realm/sdk/java/quick-start-sync/#std-label-java-client-quick-start-sync) guide. This page contains information to quickly get Realm Database integrated into your app. Before you begin, ensure you have: * [Installed the Java SDK](https://mongodb.com/docs/realm/sdk/java/install/#std-label-java-install) ## Initialize Realm Before you can use Realm in your app, you must initialize the Realm library. Your application should initialize Realm just once each time the application runs. To initialize the Realm library, provide an Android`context` to the `Realm.init()` static function. You can provide an Activity, Fragment, or Application `context` for initialization with no difference in behavior. You can initialize the Realm library in the `onCreate()` method of an [application subclass](https://developer.android.com/reference/android/app/Application) to ensure that you only initialize Realm once each time the application runs. ## Tip ### Register Your Application Subclass in the Android Manifest If you create your own `Application` subclass, you must add it to your application's `AndroidManifest.xml` to execute your custom application logic. Set the `android.name` property of your manifest's application definition to ensure that Android instantiates your `Application`subclass before any other class when a user launches your application. `| <?xml version=\"1.0\" encoding=\"utf-8\"?>                               |\n| -------------------------------------------------------------------- |\n| <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" |\n| package=\"com.mongodb.example\">                                       |\n| <application                                                         |\n| android:name=\".MyApplicationSubclass\"                                |\n| ...                                                                  |\n| />                                                                   |\n| </manifest>                                                          | ` ## Define Your Object Model\n\n To define your application's data model, add the following class definitions to your application code: ## Open a Realm Use `RealmConfiguration` to control the specifics of the realm you would like to open, including the name or location of the realm, whether to allow synchronous reads or writes to a realm on the UI thread, and more. ## Create, Read, Update, and Delete Objects Once you have opened a realm, you can modify the[objects](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-objects) within that realm in a[write transaction](https://mongodb.com/docs/realm/sdk/java/fundamentals/write-transactions/#std-label-java-open-a-transaction) block. ## Important ### Synchronous Reads and Writes on the UI Thread By default, you can only read or write to a realm in your application's UI thread using[asynchronous transactions](https://mongodb.com/docs/realm/sdk/java/fundamentals/async-api/#std-label-java-async-api). That is, you can only use `Realm` methods whose name ends with the word`Async` in the main thread of your Android application unless you explicitly allow the use of synchronous methods. This restriction exists for the benefit of your application users: performing read and write operations on the UI thread can lead to unresponsive or slow UI interactions, so it's usually best to handle these operations either asynchronously or in a background thread. However, if your application requires the use of synchronous realm reads or writes on the UI thread, you can explicitly allow the use of synchronous methods with the following`SyncConfiguration` options: To create a new `Task`, instantiate an instance of the`Task` class and add it to the realm in a write block: You can retrieve a live [collection](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-client-collections)of all items in the realm: You can also filter that collection using a [filter:](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-client-query-engine) To modify a task, update its properties in a write transaction block: Finally, you can delete a task by calling the `deleteFromRealm()`method in a write transaction block: ## Watch for Changes You can [watch a realm, collection, or object for changes](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-client-notifications) by attaching a custom`OrderedRealmCollectionChangeListener` with the `addChangeListener()`method: ## Complete Example If you're running this project in a fresh Android Studio project, you can copy and paste this file into your application's `MainActivity` \\-- just remember to: * use a package declaration at the top of the file for your own project\n* update the `import` statements for `Task` and `TaskStatus` if you're using java ## Output Running the above code should produce output resembling the following: ```shell Successfully authenticated anonymously. Updated range: 0 to 1 Deleted range: 0 to 1 Successfully logged out. \n``` ← [Install Realm - Java SDK](https://mongodb.com/docs/realm/sdk/java/install/ \"Previous Section\")[Quick Start with Sync - Java SDK](https://mongodb.com/docs/realm/sdk/java/quick-start-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Changes Between Devices - Java SDK On this page * [Prerequisites](#prerequisites)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Sync Data](#sync-data)\n* [Pause or Resume a Sync Session](#pause-or-resume-a-sync-session)\n* [When to Pause a Sync Session](#when-to-pause-a-sync-session)\n* [Check the Current Network Connection](#check-the-current-network-connection)\n* [Check Upload & Download Progress for a Sync Session](#check-upload---download-progress-for-a-sync-session)\n* [Handle Sync Errors](#handle-sync-errors)\n* [Reset a Client Realm File](#reset-a-client-realm-file) ## Prerequisites Before you can access a synced realm from the client, you must: 1. [Enable sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) in the App Services UI.\n2. [Initialize the app](https://mongodb.com/docs/realm/sdk/java/quick-start-sync/#std-label-java-quick-start-init-app)\n3. Enable Sync in your application by adding the following to the top level of your application-level `build.gradle` file:  \n`| realm { syncEnabled = true } |  \n| ---------------------------- |  \n`\n4. [Authenticate a user](https://mongodb.com/docs/realm/sdk/java/quick-start-sync/#std-label-java-quick-start-authenticate) in your client project. ## Open a Synced Realm To open a synced realm, call[getInstanceAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getInstanceAsync-io.realm.RealmConfiguration-io.realm.Realm.Callback-), passing in a [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.html)object. The following code demonstrates how to create a realm with specific sync settings created using a `SyncConfiguration` object: The code above shows how to open the realm _asynchronously_by using [getInstanceAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getInstanceAsync-io.realm.RealmConfiguration-io.realm.Realm.Callback-). You can also open a realm synchronously by using [getInstance()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getInstance-io.realm.RealmConfiguration-), which returns an open realm before synchronizing all data from the backend. However, this may lead to temporary data inconsistencies while the remote data is downloaded, and is generally not recommended. You can use the [waitForInitialRemoteData()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.Builder.html#waitForInitialRemoteData--)configuration option to force the SDK to fetch remote data before opening the realm to avoid these inconsistencies. The [partition value](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-value) specifies which subset of your data to sync. This is typically a user ID, project ID, store ID, or some other category identifier in your app that has particular relevance to the current user. ## Tip ### See also:  * [Partitions](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-sync-partitions)\n* [Fundamentals: Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realms) ## Sync Data\n\n ## Important ### When Using Sync, Avoid Writes on the Main Thread The fact that Realm performs sync integrations on a background thread means that if you write to your realm on the main thread, there's a small chance your UI could appear to hang as it waits for the background sync thread to finish a write transaction. Therefore, it's a best practice [never to write on the main thread when using Sync.](https://mongodb.com/docs/realm/sdk/java/advanced-guides/threading/#std-label-java-threading-three-rules) The following code reads a collection of `Task` objects, then writes a new `Task` to the realm: ## Tip ### See also:  [Threading](https://mongodb.com/docs/realm/sdk/java/advanced-guides/threading/#std-label-java-threading) ## Pause or Resume a Sync Session To pause a currently active sync session, call[stop()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html#stop--)on your [SyncSession:](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html) To resume a currently paused sync session, call[start()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html#start--)on your [SyncSession:](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html) ### When to Pause a Sync Session For most applications, there is no need to manually pause and resume a sync session. However, there are a few circumstances under which you may want to pause or suspend a sync session: * You only want to sync after the user takes a specific action\n* You only want to sync during a certain time of the day\n* You don't want to attempt to sync when there is poor network connectivity\n* You want to explicitly force a sync session to connect In the case of poor network connectivity, continually trying to establish a network connection can drain the user's device battery. The case of explicitly forcing a sync session to connect is most commonly related to being offline for some time. The sync client attempts to connect, and upon failure, goes into exponential backoff. After being offline for a long time, the client may not immediately reconnect. Pausing and resuming the sync session explicitly forces the connection. When you do pause a sync session, keep these things in mind: * If the client may be offline longer than the [client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), the client will be unable to resume syncing and must perform a [client reset.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets)\n* Pausing a sync session pauses it in both directions. Changes that your app makes on the device do not sync with the backend, _and_ changes to the data in the backend or on other devices do not sync to the device. There is no way to pause only uploads or pause only downloads.\n* Do not pause a sync session if you want a client to permanently stop syncing with the backend. To permanently stop syncing, copy the contents of the synced realm into a non-synced realm, and use the non-synced realm in the client. _Do not_ pause sync to stop syncing for indefinite time periods or time ranges in months and years. The functionality is not designed or tested for these use cases. You could encounter a range of issues when using it this way. ## Check the Current Network Connection To check the current network connection, call [getConnectionState()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html#getConnectionState--) on your [SyncSession:](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html) ## Important ### Connection States vs. Session States\n\n You can also subscribe to connection changes on your `SyncSession`with [addConnectionChangeListener()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html#addConnectionChangeListener-io.realm.mongodb.sync.ConnectionListener-), which works similarly to [upload and download listeners.](#std-label-java-check-sync-progress) ## Check Upload & Download Progress for a Sync Session ## Note Flexible Sync progress notifications are not yet fully supported. When using Flexible Sync, downloads only report notifications after changes are integrated. Partition-Based Sync provides ongoing notifications as changes progress downloading. Uploads report ongoing progress notifications for both Sync Modes. To subscribe to progress updates for uploads, call [addUploadProgressListener()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html#addUploadProgressListener-io.realm.mongodb.sync.ProgressMode-io.realm.mongodb.sync.ProgressListener-)on your [SyncSession](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html)with a [ProgressMode](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/ProgressMode.html)and a [ProgressListener()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/ProgressListener.html). The `ProgressMode` passed determines which upload events your listener receives: To subscribe to progress updates for downloads, call [addDownloadProgressListener()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html#addDownloadProgressListener-io.realm.mongodb.sync.ProgressMode-io.realm.mongodb.sync.ProgressListener-)on your [SyncSession](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html)with a [ProgressMode](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/ProgressMode.html)and a [ProgressListener()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/ProgressListener.html). The `ProgressMode` passed determines which download events your listener receives: ## Handle Sync Errors You can configure an error handler to detect and respond to any errors that occur in the Sync process. To define an error handler, pass an[ErrorHandler](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.ErrorHandler.html)to the [SyncConfiguration.Builder.errorHandler()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.Builder.html#errorHandler-io.realm.mongodb.sync.SyncSession.ErrorHandler-)builder method: ## Tip For a list of common Device Sync errors and how to handle them, refer to[Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services Device Sync documentation. ## Reset a Client Realm File You can customize behavior in the event of a[client reset](https://mongodb.com/docs/realm/sdk/java/examples/reset-a-client-realm/#std-label-java-client-resets) with a custom client reset handler: ## Tip ### See also:  To see how to recover unsynced local changes in a client reset, check out this [example on GitHub.](https://github.com/mongodb/realm-practice/blob/main/node/index.js#L49)\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Open & Close a Realm - Java SDK On this page * [The Default Realm](#the-default-realm)\n* [Local Realms](#local-realms)\n* [Local Realm Configuration](#local-realm-configuration)\n* [Open a Local Realm](#open-a-local-realm)\n* [Read-Only Realms](#read-only-realms)\n* [In-Memory Realms](#in-memory-realms)\n* [Dynamic Realms](#dynamic-realms)\n* [Synced Realms](#synced-realms)\n* [Synced Realm Configuration](#synced-realm-configuration)\n* [Open a Synced Realm While Online](#open-a-synced-realm-while-online)\n* [Open a Synced Realm While Offline](#open-a-synced-realm-while-offline)\n* [Open a Synced Realm with a Flexible Sync Configuration](#open-a-synced-realm-with-a-flexible-sync-configuration)\n* [Close a Realm](#close-a-realm)\n* [Configure Which Classes to Include in Your Realm Schema](#configure-which-classes-to-include-in-your-realm-schema) Interacting with [realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realms) in an Android application uses the following high-level series of steps: 1. Create a configuration for the realm you want to open.\n2. Open the realm using the config.\n3. [Close the realm](#std-label-java-close-a-realm) to free up resources when you're finished. ## The Default Realm You can save any [RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.html)or [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.html)as the default for your application using the[setDefaultConfiguration()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#setDefaultConfiguration-io.realm.RealmConfiguration-)method: You can then use[getDefaultConfiguration()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getDefaultConfiguration--)to access that configuration, or[getDefaultInstance()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getDefaultInstance--)to open a realm with that configuration: ## Local Realms Local realms store data only on the client device. You can customize the settings for a local realm with `RealmConfiguration`. ### Local Realm Configuration To configure settings for a realm, create a[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.html) with a[RealmConfiguration.Builder](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html). The following example configures a local realm with: * the file name \"alternate-realm\"\n* synchronous reads explicitly allowed on the UI thread\n* synchronous writes explicitly allowed on the UI thread\n* automatic compaction when launching the realm to save file space ## Important ### Synchronous Reads and Writes on the UI Thread By default, you can only read or write to a realm in your application's UI thread using[asynchronous transactions](https://mongodb.com/docs/realm/sdk/java/fundamentals/async-api/#std-label-java-async-api). That is, you can only use `Realm` methods whose name ends with the word`Async` in the main thread of your Android application unless you explicitly allow the use of synchronous methods.\n\n ## Tip ### See also:  [Fundamentals: Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realms) ### Open a Local Realm To open a realm, create a[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.html) with[RealmConfiguration.Builder](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html) and pass the resulting `RealmConfiguration` to[getInstance()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getInstance-io.realm.RealmConfiguration-)or [getInstanceAsync():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getInstanceAsync-io.realm.RealmConfiguration-io.realm.Realm.Callback-) ## Tip ### See also:  [Fundamentals: Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realms) ### Read-Only Realms Use the [readOnly()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#readOnly--)method when configuring your realm to make it read-only: ## Tip ### See also:  [Fundamentals: Read-Only Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-read-only-realms-fundamentals) ### In-Memory Realms To create a realm that runs entirely in memory without being written to a file, use [inMemory()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#inMemory%28%29)when configuring your realm: ## Tip ### See also:  [Fundamentals: In-Memory Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-in-memory-realms-fundamentals) ### Dynamic Realms To open a Dynamic Realm with a mutable schema, use[DynamicRealm:](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/DynamicRealm.html) ## Tip ### See also:  [Fundamentals: Dynamic Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-dynamic-realms-fundamentals) ## Synced Realms Synced realms use [Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) to store data both on the client device and in your synced data source. Opening a synced realm works exactly like opening a local realm, except you use `SyncConfiguration`to customize the settings for synced realms. ### Synced Realm Configuration To configure settings for a realm, create a[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.html) with a[SyncConfiguration.Builder](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.Builder.html). The following example configures a synced realm with: * partition-based Sync\n* synchronous reads explicitly allowed on the UI thread\n* synchronous writes explicitly allowed on the UI thread\n* explicit waiting for all backend changes to synchronize to the device before returning an open realm\n* automatic compaction when launching the realm to save file space ## Warning ### Production Applications Should Handle Client Resets Applications used in production environments should handle client reset errors. To learn more, see [Reset a Client Realm.](https://mongodb.com/docs/realm/sdk/java/examples/reset-a-client-realm/#std-label-java-client-resets) ## Important ### Synchronous Reads and Writes on the UI Thread\n\n This restriction exists for the benefit of your application users: performing read and write operations on the UI thread can lead to unresponsive or slow UI interactions, so it's usually best to handle these operations either asynchronously or in a background thread. However, if your application requires the use of synchronous realm reads or writes on the UI thread, you can explicitly allow the use of synchronous methods with the following`SyncConfiguration` options: ## Tip ### See also:  [Fundamentals: Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realms) ### Open a Synced Realm While Online To open a synced realm, call[getInstanceAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getInstanceAsync-io.realm.RealmConfiguration-io.realm.Realm.Callback-), passing in a [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.html)object. The following code demonstrates how to create a realm with specific sync settings created using a `SyncConfiguration` object: The code above shows how to open the realm _asynchronously_by using [getInstanceAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getInstanceAsync-io.realm.RealmConfiguration-io.realm.Realm.Callback-). You can also open a realm synchronously by using [getInstance()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#getInstance-io.realm.RealmConfiguration-), which returns an open realm before synchronizing all data from the backend. However, this may lead to temporary data inconsistencies while the remote data is downloaded, and is generally not recommended. You can use the [waitForInitialRemoteData()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.Builder.html#waitForInitialRemoteData--)configuration option to force the SDK to fetch remote data before opening the realm to avoid these inconsistencies. The [partition value](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-value) specifies which subset of your data to sync. This is typically a user ID, project ID, store ID, or some other category identifier in your app that has particular relevance to the current user. ## Tip ### See also:  * [Partitions](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-sync-partitions)\n* [Fundamentals: Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realms) ### Open a Synced Realm While Offline You can open a synced realm when offline with the exact same syntax that you use to [open a synced realm while online](#std-label-java-open-a-synced-realm-while-online). Not all SDKs follow this pattern, so cross-platform developers should consult the documentation for each SDK to learn more. ### Open a Synced Realm with a Flexible Sync Configuration\n\n ## Tip ### See also:  For more information about subscriptions, see[Subscribe to Queryable Fields.](https://mongodb.com/docs/realm/sdk/java/examples/flexible-sync/#std-label-java-sync-subscribe-to-queryable-fields) ## Close a Realm It is important to remember to call the [close()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#close--) method when done with a realm instance to free resources. Neglecting to close realms can lead to an`OutOfMemoryError`. ## Tip ### See also:  [Fundamentals: Realms](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realms) ## Configure Which Classes to Include in Your Realm Schema Realm modules are collections of Realm object models. Specify a module or modules when opening a realm to control which classes Realm Database should include in your schema. If you do not specify a module, Realm uses the default module, which includes all Realm objects defined in your application. ## Note Libraries that include Realm Database must expose and use their schema through a module. Doing so prevents the library from generating the default `RealmModule`, which would conflict with the default `RealmModule` used by any app that includes the library. Apps using the library access library classes through the module. ## Tip ### See also:  [Fundamentals: Modules](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-modules) ← [Define a Realm Object Schema - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/ \"Previous Section\")[Read & Write Data - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/filter-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Filter Data - Java SDK On this page * [About the Examples on This Page](#about-the-examples-on-this-page)\n* [Filters](#filters)\n* [Link Queries](#link-queries)\n* [Sort Results](#sort-results)\n* [Limit Results](#limit-results)\n* [Unique Results](#unique-results)\n* [Chain Queries](#chain-queries)\n* [Query with Realm Query Language](#query-with-realm-query-language) ## About the Examples on This Page The examples in this page use two Realm object types: `Teacher`and `Student`. See the schema for these two classes below: ## Filters You can build filters using the operator methods of the[fluent interface](https://en.wikipedia.org/wiki/Fluent%5Finterface) exposed by the[RealmQuery](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html) class: This gives you a new instance of the class [RealmResults](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmResults.html), containing teachers with the name \"Ms. Langtree\" or \"Mrs. Jacobs\". `RealmQuery` includes several methods that can execute queries: * [findAll()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html#findAll--) blocks until it finds all objects that meet the query conditions\n* [findAllAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html#findAllAsync--)returns immediately and finds all objects that meet the query conditions asynchronously on a background thread\n* [findFirst()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html#findFirst--) blocks until it finds the first object that meets the query conditions\n* [findFirstAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html#findFirstAsync--)returns immediately and finds the first object that meets the query conditions asynchronously on a background thread Queries return a list of references to the matching Realm objects using the [RealmResults](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-results-collections) type. ## Tip ### See also:  * [Fundamentals: Query Engine](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-client-query-engine)\n* [Fundamentals: Results Collections](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-results-collections) ### Link Queries When referring to an object property, you can use **dot notation** to refer to child properties of that object. You can refer to the properties of[embedded objects](https://mongodb.com/docs/realm/sdk/java/data-types/embedded-objects/#std-label-java-embedded-objects) and [relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-client-relationships) with dot notation. For example, consider a query for all teachers with a student named \"Wirt\" or \"Greg\": You can even use dot notation to query inverse relationships: ## Sort Results ## Important Realm Database applies the `distinct()`, `sort()` and`limit()` methods in the order you specify. Depending on the data set this can alter the query result. Generally, you should apply `limit()` last to avoid unintended result sets. You can define the order of query results using the[sort()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html#sort-java.lang.String-)method:\n\n ## Note ### String Sorting Limitations Realm uses non-standard sorting for upper and lowercase letters, sorting them together rather than sorting uppercase first. As a result, `'- !\"#0&()*,./:;?_+<=>123aAbBcC...xXyYzZ` is the actual sorting order in Realm Database. Additionally, sorting strings only supports the `Latin Basic`, `Latin Supplement`,`Latin Extended A`, and `Latin Extended B (UTF-8 range 0–591)`character sets. ## Limit Results You can cap the number of query results to a specific maximum number using the [limit()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html#limit-long-)method: Limited result collections automatically update like any other query result. Consequently, objects might drop out of the collection as underlying data changes. ## Tip ### Pagination is Not Necessary for Realm Database Optimization Some databases encourage paginating results with limits to avoid reading unnecessary data from disk or using too much memory. Since Realm Database queries are lazy, there is no need to take such measures. Realm Database only loads objects from query results when they are explicitly accessed. ## Tip ### Deleted Notifications in Limited Results [Collection notifications](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-collection-notifications)report objects as deleted when they drop out of the result set. This does not necessarily mean that they have been deleted from the underlying realm, just that they are no longer part of the query result. ## Unique Results You can reduce query results to unique values for a given field or fields using the [distinct()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html#distinct-java.lang.String-) method: You can only call `distinct()` on integer, long, short, and `String`fields; other field types will throw an exception. As with sorting, you can specify multiple fields to resolve ties. ## Chain Queries You can apply additional filters to a results collection by calling the[where()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmResults.html#where--) method: The `where()` method returns a `RealmQuery` that you can resolve into a `RealmResults` using a `find` method. Filtered results can only return objects of the same type as the original results set, but are otherwise able to use any [filters.](#std-label-java-client-filters) ## Query with Realm Query Language _New in version 10.4.0_. You can use [RealmQuery.rawPredicate()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmQuery.html#rawPredicate-java.lang.String-) to query realms using Realm Query Language, a string-based query language to constrain searches when retrieving objects from a realm. For more information about syntax, usage and limitations, refer to the [Realm Query Language reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql) Realm Query Language can use either the class and property names defined in your Realm Model classes or the internal names defined with `@RealmField`. You can combine raw predicates with other raw predicates or type-safe predicates created with `RealmQuery`: ## Tip ### See also: Realm Query Language Examples You can also find useful Realm Query Language examples on the following pages: * [iOS Query Examples](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-client-query-engine)\n* [Node.js Query Engine](https://mongodb.com/docs/realm/sdk/node/examples/query-data/#std-label-node-client-query-engine) ← [Read & Write Data - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/ \"Previous Section\")[React to Changes - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/modify-an-object-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Modify an Object Schema - Java SDK ## Tip ### See also:  [Fundamentals: Migrations](https://mongodb.com/docs/realm/sdk/java/fundamentals/schema-versions-and-migrations/#std-label-java-migrations) ## Tip You can use the[RealmConfiguration.shouldDeleteRealmIfMigrationNeeded()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.html#shouldDeleteRealmIfMigrationNeeded--)builder method when constructing a realm to delete the realm instead of performing a migration when a migration is required. This can come in handy during development when schemas often change. ← [Display Collections - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/adapters/ \"Previous Section\")[Bundle a Realm File - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/bundle-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/reset-a-client-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Reset a Client Realm - Java SDK On this page * [Discard Unsynced Changes](#discard-unsynced-changes)\n* [Discard Unsynced Changes after Breaking Schema Changes](#discard-unsynced-changes-after-breaking-schema-changes)\n* [Manually Recover Unsynced Changes](#manually-recover-unsynced-changes) ## Tip ### See also: Learn More About Client Resets To learn about the causes of and strategies for handling client resets, check out the Sync [Client Resets](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) page. The SDK reads and writes to a realm file on the device. When you use Atlas Device Sync, this local realm syncs with the application backend. Some conditions can cause the realm to be unable to sync with the backend. When this occurs, you get a **client reset error**. This error means you must reset the realm file in the client application. Clients in this state may continue to run and save data locally. Until you perform the client reset, the realm does not sync with the backend. Choose a **client reset strategy** to handle client reset errors. These strategies restore realm to a syncable state, but have tradeoffs: * [Discard Unsynced Changes](#std-label-java-discard-unsynced-changes). Restore Sync by discarding local changes since the last sync. Maintains change listeners.\n* [Manually Recover Unsynced Changes](#std-label-java-manually-recover-unsynced-changes):. Move the unsyncable realm and download a new copy. Invalidates change listeners. Both options let you write custom logic to recover local changes. Neither option can recover local changes for you. Discard unsynced changes is a less complex alternative to manual recovery. However, this strategy cannot handle every client reset error. You must maintain a manual client reset handler as a fallback. ## Discard Unsynced Changes _New in version 10.10.0_. **Discard unsynced changes** is a client reset strategy provided by the SDK. This strategy requires minimal code. This strategy performs a reset without closing the realm or missing notifications. It _does_ delete all local changes made since the last successful sync. This includes any data already written to the realm but not yet synced to the application backend. Do not use this strategy if your application cannot lose unsynced data. Discard unsynced changes cannot handle [breaking or destructive schema changes](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-destructive-changes-synced-schema). When breaking changes occur, the SDK falls back to manual recovery mode. To use this strategy, pass an instance of[DiscardUnsyncedChangesStrategy](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/DiscardUnsyncedChangesStrategy.html) to the[defaultSyncClientResetStrategy()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/AppConfiguration.Builder.html#defaultSyncClientResetStrategy%28io.realm.mongodb.sync.DiscardUnsyncedChangesStrategy%29)builder method when you instantiate your `App`. Your`DiscardUnsyncedChangesStrategy` instance must implement the following methods:\n\n The following example implements this strategy: ### Discard Unsynced Changes after Breaking Schema Changes ## Important ### Breaking Schema Changes Require an App Schema Update After a breaking schema change: * All clients must perform a client reset.\n* You must update client models affected by the breaking schema change. The discard unsynced changes strategy cannot handle breaking changes. You must manually handle the client reset in the `onError()` method. This example manually discards unsynced changes to handle the client reset: ## Manually Recover Unsynced Changes ## Tip Manual recovery replaces the deprecated`SyncSession.ClientResetHandler`. Clients using the deprecated handler can update to manual recovery with no logic changes. We do not recommend manual client reset recovery. It requires: * Substantial amounts of code\n* Schema concessions\n* Complex conflict resolution logic. To learn more, see the [Advanced Guide to Manual Client Reset Data Recovery.](https://mongodb.com/docs/realm/sdk/java/advanced-guides/manual-client-reset-data-recovery/#std-label-java-advanced-manual-client-reset-data-recovery) ← [Flexible Sync - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/flexible-sync/ \"Previous Section\")[Call a Function - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/call-a-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query MongoDB - Java SDK On this page * [Use Cases](#use-cases)\n* [Prerequisites](#prerequisites)\n* [Set Up Your Project](#set-up-your-project)\n* [Set Up Your Project](#set-up-your-project-1)\n* [Link a MongoDB Atlas Service Cluster](#link-a-mongodb-atlas-service-cluster)\n* [Import Realm Dependencies](#import-realm-dependencies)\n* [Instantiate a MongoDB Collection Handle](#instantiate-a-mongodb-collection-handle)\n* [Example Data](#example-data)\n* [Create Documents](#create-documents)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Read Documents](#read-documents)\n* [Find a Single Document](#find-a-single-document)\n* [Find Multiple Documents](#find-multiple-documents)\n* [Count Documents in the Collection](#count-documents-in-the-collection)\n* [Update Documents](#update-documents)\n* [Update a Single Document](#update-a-single-document)\n* [Update Multiple Documents](#update-multiple-documents)\n* [Upsert Documents](#upsert-documents)\n* [Delete Documents](#delete-documents)\n* [Delete a Single Document](#delete-a-single-document)\n* [Delete Multiple Documents](#delete-multiple-documents)\n* [Watch for Changes](#watch-for-changes)\n* [Watch for Changes in a Collection](#watch-for-changes-in-a-collection)\n* [Watch for Changes in a Collection with a Filter](#watch-for-changes-in-a-collection-with-a-filter)\n* [Aggregate Documents in a Collection](#aggregate-documents-in-a-collection)\n* [Filter Documents](#filter-documents)\n* [Group Documents](#group-documents)\n* [Project Document Fields](#project-document-fields)\n* [Add Fields to Documents](#add-fields-to-documents)\n* [Unwind Array Values](#unwind-array-values) You can query data stored in MongoDB Atlas directly from your Android application code by using the Realm Java SDK's [MongoClient](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoClient)with the [Query API](https://www.mongodb.com/docs/manual/tutorial/query-documents/). Atlas App Services provides data access [rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) on collections to securely retrieve results based on the logged-in user or the content of each document. The following actions enable access to a linked MongoDB Atlas cluster from an Android application using the Realm SDK. ## Note Each operation described on this page uses a **query** to match certain documents in the collection upon which the operation executes. When a filter matches multiple documents in a collection, they are returned in an [indeterminate order](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/#return-in-natural-order) unless you specify a sorting parameter. This means that if you do not specify a sort for the `findOne()`, `updateOne()`, or `deleteOne()`functions, your operation could match _any_ document that matches the query. For more information on sorting, see[cursor.sort().](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/) ## Use Cases There are a variety of reasons you might want to query a MongoDB data source. Working with data in your client via Atlas Device Sync is not always practical or possible. You might want to query MongoDB when:\n\n While not exhaustive, these are some common use cases for querying MongoDB directly. ## Prerequisites Before you can query MongoDB from your Android application, you must set up MongoDB Data Access in your App Services App. To learn how to set up your backend App to let the Realm SDK query Atlas, refer to [Set Up MongoDB Data Access](https://www.mongodb.com/docs/atlas/app-services/mongodb/data-access/#std-label-client-data-access)in the App Services documentation. ## Set Up Your Project 1 ### Set Up Your Project Follow the steps in the [Install the Realm Java SDK](https://mongodb.com/docs/realm/sdk/java/install/#std-label-java-install)guide. 2 ### Link a MongoDB Atlas Service Cluster Follow the steps in the [Link a MongoDB data source](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources)guide. Assign your service a meaningful name -- you'll need it to connect to the cluster using the Realm SDK. 3 ### Import Realm Dependencies For CRUD operations on a remote MongoDB collection, you will use one or more of the following `import` statements: 4 ### Instantiate a MongoDB Collection Handle To connect to an instance of MongoDB, you'll need a user with access to a MongoDB collection. [Log in to your application](https://mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-authenticate) as such a user, then use the following code to instantiate a local MongoDB collection handle. ## Note ### Using Custom Classes with MongoDB To use classes other than the built-in `Document` class with MongoDB, you can add _codecs_ to your `MongoCollection` instances. In the above example, we add the `PojoCodecProvider` to support Plain Old Java Objects (POJOs). Custom object support requires two_codec providers_: * the default codec provider, which provides support for built-in Java types (accessed through`AppConfiguration.DEFAULT_BSON_CODEC_REGISTRY`)\n* `PojoCodecProvider`, which automatically creates new codecs to support POJO classes The SDK checks registries in order until one returns a codec for the requested class. As a result, you should list the default codec registry first, and the `PojoCodecProvider` should always be the last CodecProvider since it can provide a codec for almost any class. ## Example Data The following examples operate on a MongoDB collection that describes inventory in a chain of plant stores. Consider the following collection of documents describing various plants for sale in a store: ## Create Documents These code snippets demonstrate how to insert one or more documents into a MongoDB collection from a mobile application. Insert operations take a document or documents to add to MongoDB as an argument and return a [RealmResultTask](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/RealmResultTask.html) that resolves to an object that contains the results of the execution of the operation. ### Insert a Single Document You can insert a single document using[collection.insertOne().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#insertOne-DocumentT-) The following snippet inserts a single document describing a \"lily of the valley\" plant into a[collection of documents that describe plants for sale in a group of stores:](#std-label-java-mongodb-example-dataset) Running this snippet produces output resembling the following: `| V/EXAMPLE: successfully inserted a document with id: BsonObjectId{value=5f19...} |\n| -------------------------------------------------------------------------------- | ` ### Insert Multiple Documents You can insert multiple documents at the same time using[collection.insertMany().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#insertMany-java.util.List-) The following snippet inserts three documents describing plants into a[collection of documents that describe plants for sale in a group of stores:](#std-label-java-mongodb-example-dataset) Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully inserted 3 documents into the collection. \n``` ## Read Documents\n\n ### Find a Single Document You can find a single document using [collection.findOne().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#findOne--) The following snippet finds a single document from the a[collection of documents that describe plants for sale in a group of stores](#std-label-java-mongodb-example-dataset) where the plant document's `type`field contains the string value \"perennial\": Running this snippet produces output similar to the following: ``` V/EXAMPLE: successfully found a document: Plant [id=5f18..., name=venus flytrap, sunlight=full, color=white, type=perennial, partition=Store 42] \n``` ### Find Multiple Documents You can find multiple documents using [collection.find().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#find--) The following snippet finds all documents in a[collection of documents that describe plants for sale in a group of stores](#std-label-java-mongodb-example-dataset) that contain a field named`_partition` with a value of \"Store 42\": Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully found all plants for Store 42: V/EXAMPLE: Plant [id=5f18..., name=venus flytrap, sunlight=full, color=white, type=perennial, partition=Store 42] V/EXAMPLE: Plant [id=5f18..., name=sweet basil, sunlight=partial, color=green, type=annual, partition=Store 42] V/EXAMPLE: Plant [id=5f18..., name=thai basil, sunlight=partial, color=green, type=perennial, partition=Store 42] V/EXAMPLE: Plant [id=5f18..., name=helianthus, sunlight=full, color=yellow, type=annual, partition=Store 42] \n``` ### Count Documents in the Collection You can count documents in a collection using[collection.count()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#count--). You can specify an optional query to determine which documents to count. If you don't specify a query, the action counts all documents in the collection. The following snippet counts the number of documents in a[collection of documents that describe plants for sale in a group of stores:](#std-label-java-mongodb-example-dataset) Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully counted, number of documents in the collection: 5 \n``` ## Update Documents These code snippets demonstrate how to update data stored in a MongoDB collection from a mobile application. Update operations use queries to specify which documents to update and [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) to describe how to mutate documents that match the query. Update operations return a [Task](https://developer.android.com/reference/com/google/android/play/core/tasks/Task) that resolves to an object that contains the results of the execution of the operation. ### Update a Single Document You can update a single document using[collection.updateOne().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#updateOne-Bson-Bson-) The following snippet updates a single document in a[collection of documents that describe plants for sale in a group of stores](#std-label-java-mongodb-example-dataset). This operation queries for a document where the `name` field contains the value \"petunia\" and changes the value of the first matched document's `sunlight` field to \"partial\": Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully updated a document. \n``` ### Update Multiple Documents\n\n The following snippet updates multiple documents in a[collection of documents that describe plants for sale in a group of stores](#std-label-java-mongodb-example-dataset). This operation queries for documents where the `_partition` field contains the value \"Store 47\" and changes the value of the `_partition` field of each matching document to \"Store 51\": Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully updated 2 documents. \n``` ### Upsert Documents If an update operation does not match any document in the collection, you can automatically insert a single new document into the collection that matches the update query by setting the `upsert` option to`true`. The following snippet updates a document in a[collection of documents that describe plants for sale in a group of stores](#std-label-java-mongodb-example-dataset) or inserts a new document if no document matches the query. This operation queries for documents where: * the `sunlight` field has a value of \"full\"\n* the `type` field has a value of \"perennial\"\n* the `color` field has a value of \"green\"\n* the `_partition` field has a value of \"Store 47\" Because this snippet sets the `upsert` option to `true`, if no document matches the query, MongoDB creates a new document that includes both the query and specified updates: Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully upserted a document with id: BsonObjectId{value=5f19...} \n``` ## Delete Documents These code snippets demonstrate how to delete documents that are stored in a MongoDB collection from a mobile application. Delete operations use a query to specify which documents to delete and return a [Task](https://developer.android.com/reference/com/google/android/play/core/tasks/Task)that resolves to an object that contains the results of the execution of the operation. ### Delete a Single Document You can delete a single document from a collection using[collection.deleteOne().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#deleteOne-Bson-) The following snippet deletes one document in a[collection of documents that describe plants for sale in a group of stores](#std-label-java-mongodb-example-dataset). This operation queries for a document where the `color` field has a value of \"green\" and deletes the first document that matches the query: Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully deleted a document. \n``` ### Delete Multiple Documents You can delete multiple items from a collection using[collection.deleteMany().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#deleteMany-Bson-) The following snippet deletes all documents in a[collection of documents that describe plants for sale in a group of stores](#std-label-java-mongodb-example-dataset)that match the query that matches documents containing both a `sunlight` field value of \"full\" and a `type` field value of \"annual\". Running this snippet produces output resembling the following: ``` V/EXAMPLE: succcessfully deleted 2 documents. \n``` ## Watch for Changes These code snippets demonstrate how to configure and run[watch](https://www.mongodb.com/docs/manual/reference/method/db.collection.watch/) operations on a collection. ## Important ### Serverless Limitations You cannot watch for changes if the data source is an Atlas serverless instance. MongoDB serverless currently does not support change streams, which are used on watched collections to listen for changes. ### Watch for Changes in a Collection\n\n The following snippet watches for changes to any documents in the`plants` collection: Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully inserted a document with id BsonObjectId{value=5f6bb...} V/EXAMPLE: Event type: INSERT full document: Plant [id=5f6bb..., name=triffid, sunlight=low, color=green, type=perennial, partition=Store 47] \n``` ### Watch for Changes in a Collection with a Filter You can open a stream of changes made to documents in a collection that fulfill certain criteria by calling [collection.watchWithFilter()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#watchWithFilter-BsonDocument-) or[collection.watchWithFilterAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#watchWithFilterAsync-Document-). Both methods accept a `Document` or `BsonDocument` parameter that is used as the query of a [$match operator](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) to process each[database event](https://www.mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-events) that occurs while watching the collection. The following snippet watches for changes to documents in the`plants` collection, but only triggers the provided callback for events corresponding to documents belonging to the partition named \"Store 42\": Running this snippet produces output resembling the following: ``` V/EXAMPLE: successfully inserted 2 documents into the collection V/EXAMPLE: Event type: INSERT full document: Plant [id=5f6bb..., name=venomous tentacula, sunlight=low, color=brown, type=annual, partition=Store 42] \n``` ## Aggregate Documents in a Collection Aggregation operations run all documents in a collection through a series of data aggregation stages called an [aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/). Aggregation allows you to filter and transform documents, collect summary data about groups of related documents, and other complex data operations. You can execute an aggregation pipeline using[collection.aggregate().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/mongo/MongoCollection.html#aggregate-java.util.List-) An aggregation operation accepts a list of aggregation stages as input and returns a[Task](https://developer.android.com/reference/com/google/android/play/core/tasks/Task) that resolves to a collection of documents processed by the pipeline. ### Filter Documents You can use the [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) stage to filter documents according to a Query API [query filter.](https://www.mongodb.com/docs/manual/tutorial/query-documents/) ```javascript {   \"$match\": {     \"<Field Name>\": <Query Expression>,     ...   } } \n``` ## Example The following `$match` stage filters documents to include only those where the `type` field has a value equal to \"perennial\": ### Group Documents You can use the [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/) stage to aggregate summary data for one or more documents. MongoDB groups documents based on the expression defined in the `_id` field value of the `$group`stage. You can reference a specific document field by prefixing the field name with a `$`. The following snippet groups all documents in the `plants`collection by their `type` value and aggregates a count of the number of each type: ### Project Document Fields\n\n * Explicitly include fields with a value of 1\\. This has the side-effect of implicitly excluding all unspecified fields.\n* Implicitly exclude fields with a value of 0\\. This has the side-effect of implicitly including all unspecified fields. These two methods of projection are mutually exclusive: if you explicitly include fields, you cannot explicitly exclude fields, and vice versa. ## Note The `_id` field is a special case: it is always included in every query unless explicitly specified otherwise. For this reason, you_can_ exclude the `_id` field with a `0` value while simultaneously including other fields, like `_partition`, with a `1`. Only the special case of exclusion of the `_id` field allows both exclusion and inclusion in one `$project` stage. ```javascript {   \"$project\": {     \"<Field Name>\": <0 | 1 | Expression>,     ...   } } \n``` ## Example The following `$project` stage omits the `_id` field, includes the `name` field, and creates a new field named `storeNumber`. The `storeNumber` is generated using two aggregation operators: 1. `$split` separates the `_partition` value into two string segments surrounding the space character. For example, the value \"Store 42\" split in this way returns an array with two elements: \"Store\" and \"42\".\n2. `$arrayElemAt` selects a specific element from an array based on the second argument. In this case, the value `1` selects the second element from the array generated by the `$split` operator since arrays index from `0`. For example, the value \\[\"Store\", \"42\"\\] passed to this operation would return a value of \"42\". ### Add Fields to Documents You can use the [$addFields](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/) stage to add new fields with calculated values using [aggregation operators.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/) ## Note `$addFields` is similar to [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) but does not allow you to include or omit fields. ## Example The following `$addFields` stage creates a new field named`storeNumber` where the value is the output of two aggregate operators that transform the value of the `_partition` field. ### Unwind Array Values You can use the [$unwind](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/) stage to transform a single document containing an array into multiple documents containing individual values from that array. When you unwind an array field, MongoDB copies each document once for each element of the array field but replaces the array value with the array element in each copy. ```javascript {   $unwind: {     path: <Array Field Path>,     includeArrayIndex: <string>,     preserveNullAndEmptyArrays: <boolean>   } } \n``` ## Example The following `$unwind` stage creates a new document for each element of the `items` array in each document. It also adds a field called `itemIndex` to each new document that specifies the element's position index in the original array: Consider the following document from the a collection of purchases: ```javascript    {      _id: 123,      customerId: 24601,      items: [        { name: \"Baseball\", quantity: 5 },        { name: \"Baseball Mitt\", quantity: 1 },        { name: \"Baseball Bat\", quantity: 1 },      ]    } \n``` If we apply the example `$unwind` stage to this document, the stage outputs the following three documents: ```javascript    {      _id: 123,      customerId: 24601,      itemIndex: 0,      items: { name: \"Baseball\", quantity: 5 }    }, {      _id: 123,      customerId: 24601,      itemIndex: 1,      items: { name: \"Baseball Mitt\", quantity: 1 }    }, {      _id: 123,      customerId: 24601,\n\n      items: { name: \"Baseball Bat\", quantity: 1 }    } \n``` ← [Manage User API Keys - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/manage-user-api-keys/ \"Previous Section\")[Advanced Guides - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/flexible-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Flexible Sync - Java SDK On this page * [Overview](#overview)\n* [Subscribe to Queryable Fields](#subscribe-to-queryable-fields)\n* [Add a Subscription](#add-a-subscription)\n* [Wait for Subscription Changes to Sync](#wait-for-subscription-changes-to-sync)\n* [Update Subscriptions with a New Query](#update-subscriptions-with-a-new-query)\n* [Remove Subscriptions](#remove-subscriptions)\n* [Flexible Sync RQL Limitations](#flexible-sync-rql-limitations)\n* [Unsupported Query Operators in Flexible Sync](#unsupported-query-operators-in-flexible-sync)\n* [List Queries](#list-queries)\n* [Embedded or Linked Objects](#embedded-or-linked-objects) ## Overview Flexible Sync uses subscriptions and permissions to determine which data to sync with your App. To use Flexible Sync in the SDK: * [Configure Flexible Sync on the backend](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n* [Initialize the app](https://mongodb.com/docs/realm/sdk/java/quick-start-sync/#std-label-java-quick-start-init-app)\n* [Authenticate a user](https://mongodb.com/docs/realm/sdk/java/quick-start-sync/#std-label-java-quick-start-authenticate) in your client project.\n* [Open the synced Realm with a Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/#std-label-java-flexible-sync-open-realm)\n* [Add subscriptions to the client application](#std-label-java-sync-subscribe-to-queryable-fields) You can add, update, and remove query subscriptions to determine which data syncs to the client device. ## Tip ### See also:  This page details how to manage subscriptions for Flexible Sync. For general information about using Atlas Device Sync with the SDK, such as how to sync changes in the background or pause a sync session, check out [Sync Changes Between Devices.](https://mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/#std-label-java-sync-changes-between-devices) For information about setting up permissions for Flexible Sync, check out[Flexible Sync Rules & Permissions.](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) ## Subscribe to Queryable Fields When you configure Flexible Sync on the backend, you specify which fields your client application can query. In the client application, use the`subscriptions` API to manage a set of subscriptions to specific queries on queryable fields. You can construct queries with the [Java SDK's fluent interface](https://mongodb.com/docs/realm/sdk/java/examples/filter-data/#std-label-java-client-filters) or [Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Important Flexible Sync does not support all the operators available in Realm Query Language. See [Flexible Sync RQL Limitations](#std-label-java-flexible-sync-rql-limitations) for details. You can: * Add subscriptions\n* React to subscription state\n* Update subscriptions with new queries\n* Remove individual subscriptions or all subscriptions for an object type Data matching the subscription, where the user has the appropriate permissions, syncs between clients and the backend application. You can specify an optional string name for your subscription. ## Tip ### Always Specify a Subscription Name Always specify a subscription name if your application uses multiple subscriptions. This makes your subscriptions easier to look up, update, and delete elsewhere in your app. When you create a subscription, Realm looks for data matching a query on a specific object type. You can have multiple subscription sets on different object types. You can also have multiple queries on the same object type.\n\n You can also search subscriptions by query. If you omit the name when creating a subscription, this is the only way to look up your subscription. ## Note ### Duplicate subscriptions Subscription names must be unique. Adding a subscription with the same name as an existing subscription throws an error. If you do not explicitly name a subscription, and instead subscribe to the same unnamed query more than once, Realm does not persist duplicate queries to the subscription set. If you subscribe to the same query more than once under different names, Realm persists both subscriptions to the subscription set. ### Add a Subscription Add a subscription in a subscriptions write block. You append each new subscription to the client's Realm subscriptions. ## Note ### Object Links You must add both an object and its linked object to the subscription set to see a linked object. If your subscription results contain an object with a property that links to an object not contained in the results, the link appears to be null. There is no way to distinguish whether that property's value is legitimately null, or whether the object it links to exists but is out of view of the query subscription. ### Wait for Subscription Changes to Sync Writing an update to the subscription set locally is only one component of changing a subscription. After the local subscription change, the client synchronizes with the server to resolve any updates to the data due to the subscription change. This could mean adding or removing data from the synced realm. Use the [waitForInitialRemoteData()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.Builder.html#waitForInitialRemoteData%28long,java.util.concurrent.TimeUnit%29)builder method to force your application to block until client subscription data synchronizes to the backend before opening the realm: You can also use [SubscriptionSet.waitForSynchronization()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SubscriptionSet.html#waitForSynchronization%28java.lang.Long,java.util.concurrent.TimeUnit%29)or [SubscriptionSet.waitForSynchronizationAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SubscriptionSet.html#waitForSynchronizationAsync%28java.lang.Long,java.util.concurrent.TimeUnit,io.realm.mongodb.sync.SubscriptionSet.StateChangeCallback%29)to delay execution until subscription sync completes after instantiating a sync connection. #### SubscriptionSet.State Enum Additionally, you can watch the state of the subscription set with the[SubscriptionSet.State](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SubscriptionSet.State.html) enum. You can use subscription state to: * Show a progress indicator while data is downloading\n* Find out when a subscription set becomes superseded You can access the state of your application's subscription set using[SubscriptionSet.getState().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SubscriptionSet.html#getState%28%29) ## Note ### Subscription State \"Complete\" The subscription set state \"complete\" does not mean \"sync is done\" or \"all documents have been synced\". \"Complete\" means the following two things have happened: * The subscription has become the active subscription set that is currently being synchronized with the server.\n* The documents that matched the subscription _at the time the subscription was sent to the server_ are now on the local device. Note that this does not necessarily include all documents that currently match the subscription. The Realm SDK does not provide a way to check whether all documents that match a subscription have synced to the device. #### Superseded `SUPERSEDED` is a `SubscriptionSet.State` that can occur when another thread writes a subscription on a different instance of the subscription set. If the state becomes `SUPERSEDED`, you must obtain a new instance of the subscription set before you can write to it. ### Update Subscriptions with a New Query\n\n You cannot update subscriptions created without a name. However, you can look up unnamed subscriptions by their query, remove them from the subscription set, then add a new subscription with an updated query: ### Remove Subscriptions To remove subscriptions, you can: * Remove a single subscription query\n* Remove all subscriptions to a specific object type\n* Remove all subscriptions When you remove a subscription query, Realm asynchronously removes the synced data that matched the query from the client device. #### Remove a Single Subscription You can remove a specific subscription query using [MutableSubscriptionSet.remove()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/MutableSubscriptionSet.html#remove%28io.realm.mongodb.sync.Subscription%29). You can either look up the subscription by name, then pass the returned subscription to `remove()`, or pass the subscription name directly to`remove()`: #### Remove All Subscriptions to an Object Type If you want to remove all subscriptions to a specific object type, pass a class to the [removeAll()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/MutableSubscriptionSet.html#removeAll%28java.lang.Class%29)method: #### Remove All Subscriptions To remove all subscriptions from the subscription set, use[removeAll()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/MutableSubscriptionSet.html#removeAll%28%29)with no arguments: ## Warning If you remove all subscriptions and do not add a new one, you'll get an error. A realm opened with a flexible sync configuration needs at least one subscription to sync with the server. ## Flexible Sync RQL Limitations Flexible Sync has some limitations when using RQL operators. When you write the [query subscription](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-flexible-sync-query-subscription)that determines which data to sync, the server does not support these query operators. However, you can still use the full range of RQL features to query the synced data set in the client application. ### Unsupported Query Operators in Flexible Sync | Operator Type       | Unsupported Operators          |\n| ------------------- | ------------------------------ |\n| Aggregate Operators | @avg, @count, @max, @min, @sum |\n| Query Suffixes      | DISTINCT, SORT, LIMIT          | Case insensitive queries (`[c]`) cannot use indexes effectively. As a result, case insensitive queries are not recommended, since they could lead to performance problems. Flexible Sync only supports `@count` for array fields. ### List Queries Flexible Sync supports querying lists using the `IN` operator. You can query a list of constants to see if it contains the value of a queryable field: `| // Query a constant list for a queryable field value |\n| ---------------------------------------------------- |\n| \"priority IN { 1, 2, 3 }\"                            | ` If a queryable field has an array value, you can query to see if it contains a constant value: ```javascript // Query an array-valued queryable field for a constant value \"'comedy' IN genres\" \n``` ## Warning You **cannot** compare two lists with each other in a Flexible Sync query. Note that this is valid Realm Query Language syntax outside of Flexible Sync queries. ```javascript // Invalid Flexible Sync query. Do not do this! \"{'comedy', 'horror', 'suspense'} IN genres\" // Another invalid Flexible Sync query. Do not do this! \"ANY {'comedy', 'horror', 'suspense'} != ANY genres\" \n``` ### Embedded or Linked Objects Flexible Sync does not support querying on properties in Embedded Objects or links. For example, `obj1.field == \"foo\"`.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/authenticate-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate Users - Java SDK On this page * [Log In](#log-in)\n* [Anonymous User](#anonymous-user)\n* [Email/Password User](#email-password-user)\n* [API Key User](#api-key-user)\n* [Custom JWT User](#custom-jwt-user)\n* [Custom Function User](#custom-function-user)\n* [Facebook User](#facebook-user)\n* [Google User](#google-user)\n* [Apple User](#apple-user)\n* [Offline Login](#offline-login)\n* [Get a User Access Token](#get-a-user-access-token)\n* [Log a User Out](#log-a-user-out) Realm provides an API for authenticating users using any enabled authentication provider. Instantiate a `Credentials` object and pass it to either of the `app.login()` or `app.loginAsync()` methods to authenticate a user login and create a `User` object. Each authentication provider corresponds to a static helper method used to instantiate `Credentials` objects using that authentication provider. ## Log In You can authenticate users with either the `app.login()` or`app.loginAsync()` methods of your application's instance of the`io.realm.mongodb.App` class. While the `app.login()` method blocks code execution in the calling thread until the supplied credentials have either succeeded or failed to authenticate a user, the`app.loginAsync()` method allows execution to continue, handling success or failure with a callback function that is guaranteed to execute on the same thread that called `app.loginAsync()`. If successful, the `app.login()` method returns a `User` object. In the event of a failure, the `app.login()` method throws an exception of type `ObjectServerError`. Pass a callback to the `app.loginAsync()` method to handle success or failure. This callback accepts a single parameter of type`App.Result`. The `isSuccess()` method of the `App.Result` object passed to the callback returns a boolean that indicates whether the operation succeeded. In the event of a failure, you can view the error that caused the failure using the `getError()` method. ### Anonymous User The [anonymous authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)enables users to log in to your application with short-term accounts that store no persistent personal information. To log in with anonymous authentication, create an anonymous credential by calling`Credentials.anonymous()` and then pass the generated credential to`app.login()` or `app.loginAsync()`. ### Email/Password User The [Email/Password authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication)enables users to log in to your application with an email username and a password. To log in with email/password authentication, create an email/password credential by calling `Credentials.emailPassword()`with the user's email and password. Then pass the generated credential to `app.login()` or `app.loginAsync()`. ### API Key User The [API Key authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication)enables users to log in to your application with an API Key generated automatically in the client SDK. To log in with API Key authentication, create an API Key credential by calling `Credentials.apiKey()`with an API Key. Then pass the generated credential to `app.login()` or `app.loginAsync()`. ### Custom JWT User The [Custom JWT authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication)enables users to log in to your application with a custom JSON Web Token. To log in with custom JWT authentication, create a custom JWT credential by calling `Credentials.jwt()`with your custom JWT. Then pass the generated credential to `app.login()` or `app.loginAsync()`.\n\n The [Custom Function authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication)enables users to log in to your application using a[Realm Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) defined in your App. To log in with custom function authentication, create a credential by calling`Credentials.customFunction()`. The [customFunction()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/Credentials.html#customFunction-Document-) method expects a Document that contains the properties and values used by the Realm auth function. For example, suppose the backend function expects the input parameter to include a field named `username`, like this: `| exports = async function(loginPayload) { |\n| ---------------------------------------- |\n| const { username } = loginPayload;       |\n| ...                                      |\n| }                                        | ` The document you pass to `Credentials.customFunction()` might look like this: ```java Document(\"username\", \"bob\") \n``` You then pass the generated credential to `app.login()` or `app.loginAsync()`. ### Facebook User The [Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) authentication provider allows you to authenticate users through a Facebook app using their existing Facebook account. ## Important ### Enable the Facebook Auth Provider To log a user in with their existing Facebook account, you must configure and enable the [Facebook authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication)for your application. ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. Follow the official [Facebook Login for Android Quickstart](https://developers.facebook.com/docs/facebook-login/android) to set up the authentication flow for your application. In the login completion handler, get the logged in user's access token from the Facebook [LoginResult](https://developers.facebook.com/docs/reference/android/current/class/LoginResult). Use the access token to create a Realm Facebook credential and then log the user into your Realm app. ### Google User ## Important To log a user in with their existing Google account, you must configure and enable the [Google authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication) for your application. To set up your application for Google User authentication: 1. In the [Google Cloud Platform console](https://console.cloud.google.com/apis/credentials), create an OAuth 2.0 client ID of type \"Web application\".\n2. Configure your backend App to use that client ID and the associated client secret.\n3. Enable OpenID Connect on the backend. Use Google's official [Sign-In for Android](https://developers.google.com/identity/sign-in/android) to authenticate Google users in your Android application: ## Note ### Code Example Below For an implementation of these instructions, check out the code block below.\n\n The following code implements this flow, starting with a method call to`loginWithGoogle()`: ## Tip ### See also:  To learn more about Google Sign-In for Android, check out the official [Google Sign-In for Android Integration Guide.](https://developers.google.com/identity/sign-in/android/start-integrating) ### Apple User The [Sign-in with Apple authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication)enables users to log in to your application with a custom token provided by Apple. To log in with Sign-in with Apple authentication, create a Sign-in with Apple credential by calling `Credentials.apple()`with the token provided by Apple. Then pass the generated credential to `app.login()` or `app.loginAsync()`. ## Tip If you get a `Login failed` error saying that the `token contains an invalid number of segments`, verify that you're passing a UTF-8-encoded string version of the JWT. ## Offline Login App Services manages sessions with access tokens and refresh tokens. Client SDKs supply the logic to manage tokens, and provide them with requests. The SDK stores these tokens in[Shared Preferences](https://developer.android.com/guide/topics/data/data-storage.html#pref). ## Tip ### See also:  [User Sessions](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) When your Realm application authenticates a user, it caches the user's credentials. You can check for existing user credentials to bypass the login flow and access the cached user. Use this to open a realm offline. ## Note ### Initial login requires a network connection When a user signs up for your app, or logs in for the first time with an existing account on a client, the client must have a network connection. Checking for cached user credentials lets you open a realm offline, but only if the user has previously logged in while online. ## Get a User Access Token When a user logs in, Atlas App Services creates an access token for the user that grants them access to your App. The Realm SDK automatically manages access tokens, refreshes them when they expire, and includes a valid access token for the current user with each request. If you send requests outside of the SDK (for example, through the GraphQL API) then you need to include the user's access token with each request, and manually refresh the token when it expires. You can access and refresh a logged in user's access token in the SDK from their`Realm.User` object, as in the following example: ## Log a User Out You can log out any user, regardless of the authentication provider used to log in, using the `user.logOut()` or `user.logOutAsync()`methods. Both methods: * delete locally stored user credentials from the device\n* immediately halt any synchronization to and from the user's realms Because logging out halts synchronization, you should only log out after all local Realm updates have uploaded to the server. ← [Connect to an Atlas App Services backend - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/connect-to-app-services-backend/ \"Previous Section\")[Sync Changes Between Devices - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/call-a-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call a Function - Java SDK On this page * [Call a Function by Name](#call-a-function-by-name) The examples in this section demonstrate calling a simple function named`sum` that takes two arguments, adds them, and returns the result: `| // sum: adds two numbers   |\n| -------------------------- |\n| exports = function(a, b) { |\n| return a + b;              |\n| };                         | ` ## Call a Function by Name To execute a function from the SDK, use the[getFunctions()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/App.html#getFunctions-io.realm.mongodb.User-)method of the your [App](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/App.html)to retrieve a [Functions manager](https://www.mongodb.com/docs/realm-sdks/java/latest/). Pass the name and parameters of the function you would like to call to[callFunction()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/functions/Functions.html#callFunction-java.lang.String-java.util.List--)or [callFunctionAsync():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/functions/Functions.html#callFunctionAsync-java.lang.String-java.util.List--io.realm.mongodb.App.Callback-) ← [Reset a Client Realm - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/reset-a-client-realm/ \"Previous Section\")[Manage Email/Password Users - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/email-password-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/email-password-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Email/Password Users - Java SDK On this page * [Register a New User Account](#register-a-new-user-account)\n* [Confirm a New User's Email Address](#confirm-a-new-user-s-email-address)\n* [Reset a User's Password](#reset-a-user-s-password)\n* [Send a Password Reset Email](#send-a-password-reset-email)\n* [Run a Password Reset Function](#run-a-password-reset-function) When you have enabled the [email/password provider](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) in your App, you can register a new account, confirm an email address, and reset a user's password from client code. ## Register a New User Account To register a new user, pass a user-provided email and password to the[registerUser()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html#registerUser-java.lang.String-java.lang.String-)or [registerUserAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html#registerUserAsync-java.lang.String-java.lang.String-io.realm.mongodb.App.Callback-)methods of your Realm `App`'s [EmailPasswordAuth](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html)instance: ## Confirm a New User's Email Address To confirm a newly-created user, pass a confirmation `token` and`tokenId` to the [confirmUser()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html#confirmUser-java.lang.String-java.lang.String-)or [confirmUserAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html#confirmUserAsync-java.lang.String-java.lang.String-io.realm.mongodb.App.Callback-)methods of your Realm `App`'s [EmailPasswordAuth](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html)instance: ## Tip To access the `token` and `tokenId` values sent in the user confirmation email, you can use a [custom confirmation email subject](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-confirmation-email) containing a [deep link.](https://developer.android.com/training/app-links/deep-linking) ## Reset a User's Password To reset a user password in Sync, you can either: * Send a password reset email\n* Run a password reset function Select your preferred password reset method by going to: 1. Your App\n2. Authentication\n3. Authentication Providers\n4. Email/Password \\- and press the EDIT button ### Send a Password Reset Email To reset a user's password, first send the user a password reset email with[sendResetPasswordEmail()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html#sendResetPasswordEmail-java.lang.String-)or [sendResetPasswordEmailAsync():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html#sendResetPasswordEmailAsync-java.lang.String-io.realm.mongodb.App.Callback-)\n\n ## Tip To access the `token` and `tokenId` values sent in the password reset email, you can use a [custom password reset email subject](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-password-reset-email) containing a [deep link.](https://developer.android.com/training/app-links/deep-linking) ### Run a Password Reset Function When you configure your app to [run a password reset function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function), you'll define the function that should run when you call [callResetPasswordFunction()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html#callResetPasswordFunction-java.lang.String-java.lang.String-java.lang.Object...-)or [callResetPasswordFunctionAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/EmailPasswordAuth.html#callResetPasswordFunctionAsync-java.lang.String-java.lang.String-java.lang.Object:A-io.realm.mongodb.App.Callback-)from the SDK. This function can take a username, a password, and any number of additional arguments. You can use these arguments to specify details like security question answers or other challenges that the user should pass to successfully complete a password reset. You might prefer to use a custom password reset function when you want to define your own password reset flows. For example, you might send a custom password reset email from a specific domain, or through a service other than email. ## Tip ### See also:  For more information on how to define a custom password reset function in your App, see: [Run a Password Reset Function.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function) ← [Call a Function - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/call-a-function/ \"Previous Section\")[Manage User API Keys - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/manage-user-api-keys/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/bundle-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Bundle a Realm File - Java SDK On this page * [Overview](#overview)\n* [Create a Realm File for Bundling](#create-a-realm-file-for-bundling)\n* [Bundle a Realm File in Your Production Application](#bundle-a-realm-file-in-your-production-application)\n* [Open a Realm from a Bundled Realm File](#open-a-realm-from-a-bundled-realm-file) ## Note ### Bundle Synchronized Realms SDK version 10.9.0 introduced the ability to bundle synchronized realms. Before version 10.9.0, you could only bundle local realms. Realm supports **bundling** realm files. When you bundle a realm file, you include a database and all of its data in your application download. This allows users to start applications for the first time with a set of initial data. For synced realms, bundling can avoid a lengthy initial download the first time a user opens your application. Instead, users must only download the synced changes that occurred since you generated the bundled file. ## Warning ### Synced Realm Bundling and Client Maximum Offline Time If your application has enabled [advanced backend compaction](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-advanced-backend-compaction) by configuring a[client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), users could experience a client reset the first time they open the bundled realm file. This can happen if: * the bundled realm file was generated more than**client maximum offline time** days before the user syncs the realm for the first time. Users experiencing a client reset download the full state of the realm from the application backend. This negates the advantages of bundling a realm file. To prevent client resets and preserve the advantages of realm file bundling: * Avoid using a client maximum offline time in applications that bundle a synchronized realm.\n* If your application does use a client maximum offline time, ensure that your application download always includes a recently synced realm file. Generate a new file each application version, and ensure that no version ever stays current for more than**client maximum offline time** number of days. ## Overview To create and bundle a realm file with your application: 1. [Create a realm file](#std-label-java-create-a-realm-for-bundling) that contains the data you'd like to bundle.\n2. [Bundle the realm file](#std-label-java-bundle-realm-file) in the`/<app name>/src/main/assets` folder of your production application.\n3. In your production application,[open the realm from the bundled asset file](#std-label-java-open-a-realm-from-a-bundled-realm-file). For synced realms, you must supply the partition key. ## Create a Realm File for Bundling 1. Build a temporary realm app that shares the data model of your application.\n2. Open a realm and add the data you wish to bundle. If using a synchronized realm, allow time for the realm to fully sync.\n3. Use the [writeCopyTo()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#writeCopyTo-java.io.File-)method to copy the realm to a new file:  \n`writeCopyTo()` automatically compacts your realm to the smallest possible size before copying.  \n## Tip  \n### Differences Between Synced Realms and Local-only Realms  \nThe above example uses a `SyncConfiguration` to configure a synchronized realm. To create a copy of a local realm, configure your realm with `RealmConfiguration` instead. ## Bundle a Realm File in Your Production Application Now that you have a copy of the realm that contains the initial data, bundle it with your production application.\n\n ## Tip ### Asset Folders If your application does not already contain an asset folder, you can create one by right clicking on your top-level application folder (`<app name>`) in Android Studio and selectingNew > Folder > Assets Folder in the menu. ## Open a Realm from a Bundled Realm File Now that you have a copy of the realm included with your production application, you need to add code to use it. Use the [assetFile()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#assetFile-java.lang.String-)method when configuring your realm to open the realm from the bundled file: ## Tip ### Differences Between Synced Realms and Local-only Realms The above example uses a `SyncConfiguration` to configure a synchronized realm. To create a copy of a local realm, configure your realm with `RealmConfiguration` instead. ← [Modify an Object Schema - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/modify-an-object-schema/ \"Previous Section\")[Log Realm Events - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/log-realm-events/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/manage-user-api-keys/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage User API Keys - Java SDK On this page * [Create a User API Key](#create-a-user-api-key)\n* [Look up a User API Key](#look-up-a-user-api-key)\n* [Enable or Disable a User API Key](#enable-or-disable-a-user-api-key)\n* [Disable a User API Key](#disable-a-user-api-key)\n* [Enable a User API Key](#enable-a-user-api-key)\n* [Delete a User API Key](#delete-a-user-api-key) Application users can generate user API keys with the SDK. You can allow devices or services to communicate with Realm on behalf of a user by associating a unique user API key with each device or service. User API keys are always associated with a user object created by another non-anonymous authentication provider. Each user can associate up to 20 user keys with their account. ## Tip User API keys are not the same as **server API keys**, which allow a user or service to directly authenticate with Realm using the[API Key authentication provider](https://mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-login-api-key). To learn more about server API keys, see [API Key Authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication) ## Create a User API Key To create a new user API key, call the [create()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#create-java.lang.String-) or[createAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#createAsync-java.lang.String-io.realm.mongodb.App.Callback-)methods of a logged in user's [apiKeyAuth](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html)instance. The user API key will be associated with the logged in user and can be used to interact with Realm on their behalf. You cannot create user API keys for anonymous users. ## Warning ### Store the API Key Value The SDK only returns the value of the user API key when you create it. Make sure to store the `key` value securely so that you can use it to log in. If you lose or do not store the `key` value there is no way to recover it. You will need to create a new user API key. ## Look up a User API Key To get a list of all user API keys associated with the logged in user, call the synchronous [fetchAll()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#fetchAll--)method or asynchronous [fetchAll()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#fetchAll-io.realm.mongodb.App.Callback-) method of a logged in user's [ApiKeyAuth](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html) instance.\n\n ## Enable or Disable a User API Key ### Disable a User API Key To disable a specific user API key without deleting it, pass the key's id to the [disable()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#disable-ObjectId-)or [disableAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#disableAsync-ObjectId-io.realm.mongodb.App.Callback-)methods of a logged in user's[ApiKeyAuth](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html) instance. ### Enable a User API Key To enable a specific user API key that was previously disabled, pass the key's id to the [enable()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#enable-ObjectId-)or [enableAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#enableAsync-ObjectId-io.realm.mongodb.App.Callback-)methods of a logged in user's [ApiKeyAuth](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html) instance. ## Delete a User API Key To permanently remove a specific user API key, pass the key's id to the [delete()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#delete-ObjectId-)or [deleteAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html#deleteAsync-ObjectId-io.realm.mongodb.App.Callback-)methods of a logged in user's [ApiKeyAuth](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/auth/ApiKeyAuth.html) instance. ← [Manage Email/Password Users - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/email-password-users/ \"Previous Section\")[Query MongoDB - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/enums/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enumerations - Java SDK On this page * [Usage](#usage) Enumerations, also known as enums, are not supported natively in the Java SDK. However, you can use Java and Kotlin enums in your Realm objects if you follow these steps. ## Usage To use an enum in a Realm object class, define a field with a type matching the underlying data type of your enum. Create getters and setters for the field that convert the field value between the underlying value and the enum type. You can use the Java's built-in[Enum.valueOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html#valueOf%28java.lang.Class,%20java.lang.String%29)method to convert from the underlying type to the enum type. ← [Field Types - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/field-types/ \"Previous Section\")[Counters - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/counters/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - Java SDK On this page * [Register a Realm Change Listener](#register-a-realm-change-listener)\n* [Register a Collection Change Listener](#register-a-collection-change-listener)\n* [Register an Object Change Listener](#register-an-object-change-listener)\n* [Unregister a Change Listener](#unregister-a-change-listener)\n* [Use Realm in System Apps on Custom ROMs](#use-realm-in-system-apps-on-custom-roms) ## Register a Realm Change Listener You can register a notification handler on an entire realm. Realm Database calls the notification handler whenever any write transaction involving that realm is committed. The handler receives no information about the change. This is useful when you want to know that there has been a change but do not care to know specifically what changed. For example, proof of concept apps often use this notification type and simply refresh the entire UI when anything changes. As the app becomes more sophisticated and performance-sensitive, the app developers shift to more granular notifications. ## Example Suppose you are writing a real-time collaborative app. To give the sense that your app is buzzing with collaborative activity, you want to have an indicator that lights up when any change is made. In that case, a realm notification handler would be a great way to drive the code that controls the indicator. The following code shows how to observe a realm for changes with with [addChangeListener():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmResults.html#addChangeListener-io.realm.OrderedRealmCollectionChangeListener-) ## Important ### Automatic Refresh All threads that contain a `Looper` automatically refresh`RealmObject` and `RealmResult` instances when new changes are written to the realm. As a result, it isn't necessary to fetch those objects again when reacting to a `RealmChangeListener`, since those objects are already updated and ready to be redrawn to the screen. ## Register a Collection Change Listener You can register a notification handler on a specific collection within a realm. The handler receives a description of changes since the last notification. Specifically, this description consists of three lists of indices: * The indices of the objects that were deleted.\n* The indices of the objects that were inserted.\n* The indices of the objects that were modified. Stop notification delivery by calling the `removeChangeListener()` or`removeAllChangeListeners()` methods. Notifications also stop if: * the object on which the listener is registered gets garbage collected.\n* the realm instance closes. Keep a strong reference to the object you're listening to for as long as you need the notifications. ## Important ### Order Matters In collection notification handlers, always apply changes in the following order: deletions, insertions, then modifications. Handling insertions before deletions may result in unexpected behavior. Realm Database emits an initial notification after retrieving the collection. After that, Realm Database delivers collection notifications asynchronously whenever a write transaction adds, changes, or removes objects in the collection. Unlike realm notifications, collection notifications contain detailed information about the change. This enables sophisticated and selective reactions to changes. Collection notifications provide all the information needed to manage a list or other view that represents the collection in the UI. The following code shows how to observe a collection for changes with [addChangeListener():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#addChangeListener-io.realm.RealmChangeListener-) ## Register an Object Change Listener You can register a notification handler on a specific object within a realm. Realm Database notifies your handler: * When the object is deleted.\n* When any of the object's properties change. The handler receives information about what fields changed and whether the object was deleted. Stop notification delivery by calling the `removeChangeListener()` or`removeAllChangeListeners()` methods. Notifications also stop if: * the object on which the listener is registered gets garbage collected.\n* the realm instance closes. Keep a strong reference of the object you're listening to for as long as you need the notifications.\n\n ## Unregister a Change Listener You can unregister a change listener by passing your change listener to[Realm.removeChangeListener()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#removeChangeListener-io.realm.RealmChangeListener-). You can unregister all change listeners currently subscribed to changes in a realm or any of its linked objects or collections with[Realm.removeAllChangeListeners().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#removeAllChangeListeners--) ## Use Realm in System Apps on Custom ROMs Realm uses named pipes in order to support notifications and access to the realm file from multiple processes. While this is allowed by default for normal user apps, it is disallowed for system apps. You can define a system apps by setting`android:sharedUserId=\"android.uid.system\"` in the Android manifest. When working with a system app, you may see a security violation in Logcat that looks something like this: `| 05-24 14:08:08.984  6921  6921 W .realmsystemapp: type=1400 audit(0.0:99): avc: denied { write } for name=\"realm.testapp.com.realmsystemapp-Bfqpnjj4mUvxWtfMcOXBCA==\" dev=\"vdc\" ino=14660 scontext=u:r:system_app:s0 tcontext=u:object_r:apk_data_file:s0 tclass=dir permissive=0  |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 05-24 14:08:08.984  6921  6921 W .realmsystemapp: type=1400 audit(0.0:100): avc: denied { write } for name=\"realm.testapp.com.realmsystemapp-Bfqpnjj4mUvxWtfMcOXBCA==\" dev=\"vdc\" ino=14660 scontext=u:r:system_app:s0 tcontext=u:object_r:apk_data_file:s0 tclass=dir permissive=0 | ` In order to fix this you need to adjust the SELinux security rules in the ROM. This can be done by using the tool `audit2allow`, which ships as part of AOSP: 1. Pull the current policy from the device:  \n```  \nadb pull /sys/fs/selinux/policy  \n```\n2. Copy the SELinux error inside a text file called input.txt.\n3. Run the `audit2allow` tool:  \n```  \naudit2allow -p policy -i input.txt  \n```\n4. The tool should output a rule you can add to your existing policy to enable the use of Realm. An example of such a policy is provided below: ``` # Allow system_app to create named pipes required by Realm # Credit: https://github.com/mikalackis/platform_vendor_ariel/blob/master_oreo/sepolicy/system_app.te allow system_app fuse:fifo_file create; allow system_app system_app_data_file:fifo_file create; allow system_app system_app_data_file:fifo_file { read write }; allow system_app system_app_data_file:fifo_file open; \n``` ## Tip ### See also: audit2allow `audit2allow` is produced when compiling AOSP/ROM and only runs on Linux. You can read more about it [here.](https://source.android.com/security/selinux/validate#using%5Faudit2allow) ## Note ### Changes in Android Oreo and Above Since Android Oreo, Google changed the way it configures SELinux. The default security policies are now much more modularized. Read more about that[here.](https://source.android.com/security/selinux/images/SELinux%5FTreble.pdf)\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/realmany/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # RealmAny - Java SDK On this page * [Usage](#usage)\n* [Queries](#queries)\n* [Notifications](#notifications) _New in version 10.6.0_. You can use the [RealmAny](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmAny.html) data type to create Realm object fields that can contain any of several underlying types. You can store multiple `RealmAny` instances in`RealmList`, `RealmDictionary`, or `RealmSet` fields. To change the value of a `RealmAny` field, assign a new `RealmAny` instance with a different underlying value. In Atlas App Services backend[object schemas](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/#std-label-object-schema), the `RealmAny`data type is called **mixed**. `RealmAny` fields are indexable, but cannot be used as primary keys. ## Note ### RealmAny Type Compatiblility `RealmAny` objects can refer to any[supported field type](https://mongodb.com/docs/realm/sdk/java/data-types/field-types/#std-label-java-supported-data-types) _except_: * `RealmAny`\n* `RealmList`\n* `RealmSet`\n* `RealmDictionary` ## Usage To create a `RealmAny` instance, use the[RealmAny.valueOf()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmAny.html#valueOf--) method to assign an initial value or `RealmAny.nullValue()` to assign no value. `RealmAny` instances are immutable just like `String` or`Integer` instances; if you want to assign a new value to a`RealmAny` field, you must create a new `RealmAny` instance. ## Warning ### Two Possible Null RealmAny Values `RealmAny` instances are always [nullable](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-optionality). Additionally, instances can contain a value of type `RealmAny.Type.NULL`. ## Queries You can query a `RealmAny` field just like any other data type. Operators that only work with certain types, such as [string operators](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-string-operators) and arithmetic operators, ignore values that do not contain that type. Negating such operators matches values that do not contain the type. Type queries match the underlying type, rather than `RealmAny`. Arithmetic operators convert numeric values implicitly to compare across types. ## Notifications To subscribe to changes to a `RealmAny` field, use the[RealmObject.addChangeListener](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmObject.html#addChangeListener-io.realm.RealmChangeListener-)method of the enclosing object. You can use the[ObjectChangeSet](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/ObjectChangeSet.html)parameter to determine if the `RealmAny` field changed. ← [Counters - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/counters/ \"Previous Section\")[RealmSet - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/realmset/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Define a Realm Object Schema - Java SDK On this page * [Define a Realm Object](#define-a-realm-object)\n* [Extend RealmObject](#extend-realmobject)\n* [Implement RealmModel](#implement-realmmodel)\n* [Lists](#lists)\n* [Define a Relationship Field](#define-a-relationship-field)\n* [Many-to-One](#many-to-one)\n* [Many-to-Many](#many-to-many)\n* [Inverse Relationships](#inverse-relationships)\n* [Define an Embedded Object Field](#define-an-embedded-object-field)\n* [Annotations](#annotations)\n* [Primary Key](#primary-key)\n* [Required Fields](#required-fields)\n* [Optional Fields](#optional-fields)\n* [Default Field Values](#default-field-values)\n* [Index a Field](#index-a-field)\n* [Ignore a Field](#ignore-a-field)\n* [Rename a Field](#rename-a-field)\n* [Rename a Class](#rename-a-class)\n* [Omit Classes from your Realm Schema](#omit-classes-from-your-realm-schema) ## Tip ### See also:  For conceptual information about schemas, as well as details about types and constraints, see [Fundamentals: Object Models & Schemas.](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-object-models-and-schemas) ## Define a Realm Object To define a Realm object in your application, create a subclass of [RealmObject](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmObject.html)or implement [RealmModel.](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmModel.html) ## Important * All Realm objects must provide an empty constructor.\n* All Realm objects must use the `public` visibility modifier in Java or the `open` visibility modifier in Kotlin. ## Note Class names are limited to a maximum of 57 UTF-8 characters. ### Extend `RealmObject` The following code block shows a Realm object that describes a Frog. This Frog class can be stored in Realm Database because it `extends` the `RealmObject` class. ### Implement `RealmModel` The following code block shows a Realm object that describes a Frog. This Frog class can be stored in Realm Database because it `implements` the`RealmModel` class and uses the `@RealmClass` annotation: ## Tip ### Using RealmObject Methods When you create a Realm object by extending the `RealmObject`class, you can access `RealmObject` class methods dynamically on instances of your Realm object. Realm objects created by implementing `RealmModel` can access those same methods statically through the `RealmObject` class: ## Lists Realm objects can contain lists of non-Realm-object data types: ## Tip ### See also:  [Data Types: Lists](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-field-relationships-lists) ## Define a Relationship Field ## Tip ### See also:  With Device Sync, you can also [define your relationships](https://www.mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-define-a-relationship) in the App Services UI. ## Warning ### Always Define Accessors and Mutators for Modifiable Fields Realm objects use getters and setters to persist updated field values to your realms. Always use getters and setters for updates. ## Tip ### See also:  [Fundamentals: Relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-client-relationships) ### Many-to-One To set up a many-to-one or one-to-one relationship, create a field whose type is a Realm object in your application: ## Important ### To-one relationships must be optional\n\n Each `Frog` references either zero `Frog` instances or one other `Frog` instance. Nothing prevents multiple `Frog` instances from referencing the same `Frog`as a best friend; the distinction between a many-to-one and a one-to-one relationship is up to your application. ## Tip ### See also:  [Fundamentals: To-One Relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-to-one-relationship) ### Many-to-Many `RealmList` s are containers of `RealmObject` s, but otherwise behave like a regular collection. You can use the same object in multiple`RealmList` s. ## Tip ### See also:  [Fundamentals: To-Many Relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-to-many-relationship) ### Inverse Relationships By default, Realm Database relationships are unidirectional. You can follow a link from one class to a referenced class, but not in the opposite direction. Consider the following class defining a `Toad` with a list of `frogFriends`: You can provide a link in the opposite direction, from `Frog` to `Toad`, with the [@LinkingObjects](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/LinkingObjects.html)annotation on a `final` (in Java) or `val` (in Kotlin) field of type`RealmResults<T>`: ## Important Inverse relationship fields must be marked `final`. ## Tip ### See also:  [Fundamentals: Inverse Relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-inverse-relationship) ## Define an Embedded Object Field Realm Database provides the ability to nest objects within other objects. This has several advantages: * If using Sync, objects translate into MongoDB documents that follow a [denormalized data model.](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/)\n* When you delete an object that contains another object, the delete operation removes both objects from the realm, so unused objects don't accumulate in your realm file, taking up valuable space on user's mobile devices. To embed an object, set the `embedded` property of the[@RealmClass](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/RealmClass.html#embedded--)annotation to `true` on the class that you'd like to nest within another class: Then, any time you reference that class from another class, Realm Database will embed the referenced class within the enclosing class, as in the following example: ## Tip ### See also:  [Data Types: Embedded Objects](https://mongodb.com/docs/realm/sdk/java/data-types/embedded-objects/#std-label-java-embedded-objects) ## Annotations Use annotations to customize your Realm object models. ### Primary Key You may optionally define a primary key for an object type as part of the [object schema](#std-label-java-object-schema) with the[@PrimaryKey](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/PrimaryKey.html) annotation: Only one field in a RealmObject can use the `@PrimaryKey`annotation. ## Tip ### See also:  [Fundamentals: Primary Key](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-primary-key-fundamentals) ### Required Fields ## Tip ### See also:  [Fundamentals: Optionality](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-optionality) ### Optional Fields Fields are only optional if they can hold a value of `null` and they are not marked with the `Required` annotation. ## Tip ### See also:  [Fundamentals: Optionality](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-optionality) ### Default Field Values\n\n ## Note ### Default Values and Nullability While default values ensure that a newly created object cannot contain a value of `null` (unless you specify a default value of `null`), they do not impact the nullability of a field. To make a field non-nullable, see [Required Fields.](#std-label-java-required-field) ### Index a Field To index a field, use the [@Index](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/Index.html)annotation: ## Tip ### See also:  [Fundamentals: Indexes](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-indexes-fundamentals) ### Ignore a Field If you don't want to save a field in your model to a realm, you can ignore a field. Ignore a field from a Realm object model with the[@Ignore](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/Ignore.html) annotation: ## Note ### The SDK ignores static and transient Fields Fields marked `static` or `transient` are always ignored, and do not need the `@Ignore` annotation. ### Rename a Field By default, Realm Database uses the name defined in the model class to represent fields internally. In some cases you might want to change this behavior: * To make it easier to work across platforms, since naming conventions differ.\n* To change a field name in Kotlin without forcing a migration. Choosing an internal name that differs from the name used in model classes has the following implications: * Migrations must use the internal name when creating classes and fields.\n* Schema errors reported will use the internal name. Use the [@RealmField](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/RealmField.html)annotation to rename a field: Alternatively, you can also assign a naming policy at the module or class levels to change the way that Realm Database interprets field names. You can define a[naming policy](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/RealmNamingPolicy.html)at the [module level](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/#std-label-java-realm-modules), which will affect all classes included in the module: You can also define a[naming policy](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/RealmNamingPolicy.html)at the class level, which overrides module level settings: ### Rename a Class By default, Realm Database uses the name defined in the model class to represent classes internally. In some cases you might want to change this behavior: * To support multiple model classes with the same simple name in different packages.\n* To make it easier to work across platforms, since naming conventions differ.\n* To use a class name that is longer than the 57 character limit enforced by Realm Database.\n* To change a class name in Kotlin without forcing a migration. Use the [@RealmClass](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/RealmClass.html)annotation to rename a class: ## Omit Classes from your Realm Schema By default, your application's Realm Schema includes all classes that extend `RealmObject`. If you only want to include a subset of classes that extend `RealmObject` in your Realm Schema, you can include that subset of classes in a module and open your realm using that module: ← [Usage Examples - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/ \"Previous Section\")[Open & Close a Realm - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/collections/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Collections - Java SDK On this page * [Lists](#lists)\n* [List Collections](#list-collections)\n* [Results Collections](#results-collections)\n* [Iteration](#iteration)\n* [Adapters](#adapters)\n* [Collections are Live](#collections-are-live)\n* [Results are Lazily Evaluated](#results-are-lazily-evaluated)\n* [Limiting Query Results](#limiting-query-results)\n* [Pagination](#pagination)\n* [List vs. Results](#list-vs.-results) A Realm collection is an object that contains zero or more instances of one[type](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-objects). Realm collections are homogenous, i.e. all objects in a collection are of the same type. You can filter and sort any collection using Realm Database's[query engine](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-client-query-engine). Collections are[live](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/#std-label-java-live-object), so they always reflect the current state of the realm instance on the current thread. You can also listen for changes in the collection by subscribing to [collection notifications.](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-collection-notifications) Realm Database has two kinds of collections: **lists** and **results**. ## Lists Realm objects can contain lists of non-Realm-object data types. You can model these collections with the type `RealmList<T>`, where `T` can be the following types: * `String`\n* `Integer`\n* `UUID`\n* `ObjectId`\n* `Boolean`\n* `Float`\n* `Double`\n* `Short`\n* `Long`\n* `Byte`\n* `byte[]`\n* `Date` ## Tip ### See also:  [Usage Example: Lists](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-field-relationships-lists-example) ### List Collections A **list collection** represents a [to-many relationship](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-to-many-relationship) between two Realm types. Lists are mutable: within a write transaction, you can add and remove elements on a list. Lists are not associated with a query. ### Results Collections A **results collection** represents the lazily-evaluated results of a query operation. Results are immutable: you cannot add or remove elements on the results collection. Results have an associated query that determines their contents. The [RealmResults](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmResults.html) class inherits from[AbstractList](https://developer.android.com/reference/java/util/AbstractList) and behaves in similar ways. For example, `RealmResults` are ordered, and you can access the individual objects through an index. If a query has no matches, the returned `RealmResults` object will be a list of length 0, not a `null` object reference. You can only modify or delete objects in a `RealmResults` set in a write transaction. ## Iteration Because Realm collections are live, objects may move as you iterate over a collection. You can use[snapshots](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/#std-label-java-iteration) to iterate over collections safely. ## Adapters Realm Database offers adapters to help bind data to standard UI widgets. These classes work with any class that implements the `OrderedRealmCollection` interface, which includes the built-in `RealmResults` and `RealmList` classes. For more information on adapters, see the documentation on[Displaying Collections.](https://mongodb.com/docs/realm/sdk/java/examples/adapters/#std-label-java-adapters) ## Important\n\n The Realm Database adapters only accept _managed_Realm object instances tied to an instance of a realm. To display non-managed objects, use the general-use Android`RecyclerView.Adapter` for recycler views or `ArrayAdapter` for list views. ## Collections are Live Like [live objects](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/#std-label-java-live-object), Realm collections are usually **live**: * Live results collections always reflect the current results of the associated query.\n* Live lists always reflect the current state of the relationship on the realm instance. There are three cases when a collection is **not** live: * The collection is unmanaged, e.g. a List property of a Realm object that has not been added to a realm yet or that has been copied from a realm.\n* The collection is [frozen.](https://mongodb.com/docs/realm/sdk/java/advanced-guides/threading/#std-label-java-frozen-objects)\n* The collection is part of a snapshot. Combined with [collection notifications](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-collection-notifications), live collections enable clean, reactive code. For example, suppose your view displays the results of a query. You can keep a reference to the results collection in your view class, then read the results collection as needed without having to refresh it or validate that it is up-to-date. ## Warning ### Indexes may change Results update themselves automatically. If you store the positional index of an object in a collection or the count of objects in a collection, the stored index or count value could be outdated by the time you use it. ## Results are Lazily Evaluated Realm Database only runs a query when you actually request the results of that query, e.g. by accessing elements of the results collection. This lazy evaluation enables you to write elegant, highly performant code for handling large data sets and complex queries. ### Limiting Query Results As a result of lazy evaluation, you do not need any special mechanism to limit query results with Realm Database. For example, if your query matches thousands of objects, but you only want to load the first ten, simply access only the first ten elements of the results collection. ### Pagination Thanks to lazy evaluation, the common task of pagination becomes quite simple. For example, suppose you have a results collection associated with a query that matches thousands of objects in your realm. You display one hundred objects per page. To advance to any page, simply access the elements of the results collection starting at the index that corresponds to the target page. ## List vs. Results When you need a collection, you can use the following rule of thumb to determine whether a list or a results collection is appropriate: * When you define the properties of your Realm objects, use lists to define [to-many relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-to-many-relationship) except [implicit inverse relationships.](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-inverse-relationship)\n* Use results everywhere else. To understand these different use cases, consider whether you should be able to add or remove objects directly. Lists allow you to add and remove objects directly, because you control the relationships. Results collections do not allow you to add or remove objects directly, because their contents are determined by a query. ## Example Consider a Realm type called Person with a field called`emails` that is a collection of strings representing email addresses. You control this data. Your application needs to add and remove email addresses from your Person instances. Therefore, use a **list** to define the field type of `emails`. On the other hand, when you query the realm for all Persons over the age of 25, it would not make sense for you to add or remove Persons directly to the resulting collection. The contents of that collection only change when the query matches a different set of Persons. Therefore, Realm Database gives you a **results** collection. ## Note ### Inverse one-to-many relationships Since Realm automatically determines the contents of[implicit inverse relationship](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-inverse-relationship) collections, you may not add or remove objects from such a collection. Therefore, the type of such a one-to-many relationship property is actually a results collection, not a list.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/field-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Field Types - Java SDK On this page * [Updating Strings and Byte Arrays](#updating-strings-and-byte-arrays)\n* [Object IDs and UUIDs](#object-ids-and-uuids) Realm Database supports the following field data types: * `Boolean` or `boolean`\n* `Integer` or `int`\n* `Short` or `short`\n* `Long` or `long`\n* `Byte` or `byte[]`\n* `Double` or `double`\n* `Float` or `float`\n* `String`\n* `Date`\n* `Decimal128` from `org.bson.types`\n* `ObjectId` from `org.bson.types`\n* `UUID` from `java.util.UUID`\n* Any `RealmObject` subclass\n* `RealmList`\n* `RealmAny`\n* `RealmSet`\n* `RealmDictionary` The `Byte`, `Short`, `Integer`, and `Long` types and their lowercase primitive alternatives are all stored as `Long` values within Realm Database. Similarly, Realm Database stores objects of the `Float` and `float` types as type `Double`. Realm does not support fields with modifiers `final` and`volatile`, though you can use fields with those modifiers if you[ignore](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-ignore-field) them. If you choose to provide custom constructors, you must declare a public constructor with no arguments. ## Updating Strings and Byte Arrays Since Realm Database operates on fields as a whole, it's not possible to directly update individual elements of strings or byte arrays. Instead, you'll need to read the whole field, make your modification to individual elements, and then write the entire field back again in a transaction block. ## Object IDs and UUIDs `ObjectId` and `UUID` (Universal Unique Identifier) both provide unique values that can be used as identifiers for objects.`ObjectId` is a [MongoDB-specific](https://www.mongodb.com/docs/manual/reference/method/ObjectId/)12-byte unique value. `UUID` is a [standardized](https://tools.ietf.org/html/rfc4122) 16-byte unique value. Both types are [indexable](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-indexes-fundamentals)and can be used as [primary keys.](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-primary-key-fundamentals) ← [Realm Data Types - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/ \"Previous Section\")[Enumerations - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/enums/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/realmset/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # RealmSet - Java SDK On this page * [Method Limitations](#method-limitations)\n* [Usage](#usage)\n* [Notifications](#notifications) _New in version 10.6.0_. You can use the [RealmSet](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmSet.html) data type to manage a collection of unique keys. `RealmSet` implements Java's`Set` interface, so it works just like the built-in `HashSet` class, except managed `RealmSet` instances persist their contents to a realm. `RealmSet` instances that contain Realm objects actually only store references to those objects, so deleting a Realm object from a realm also deletes that object from any `RealmSet` instances that contain the object. Because `RealmSet` implements `RealmCollection`, it has some useful mathematical methods, such as `sum`, `min`, and `max`. For a complete list of available `RealmSet` methods, see: [the RealmSet API reference.](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmSet.html) ## Method Limitations You cannot use the following `Realm` methods on objects that contain a field of type `RealmSet`: * `Realm.insert()`\n* `Realm.insertOrUpdate()`\n* `Realm.createAllFromJson()`\n* `Realm.createObjectFromJson()`\n* `Realm.createOrUpdateAllFromJson()`\n* `Realm.createOrUpdateObjectFromJson()` ## Usage To create a field of type `RealmSet`, define an object property of type `RealmSet<E>`, where `E` defines the keys you would like to store in your `RealmSet`. * Add an object to a `RealmSet` with[RealmSet.add()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmSet.html#add-E-)\n* Add multiple objects with[RealmSet.addAll()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmSet.html#addAll-Collection-)\n* Check if the set contains a specific object with[RealmSet.contains()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmSet.html#contains-Object-)\n* Check if the set contains all of multiple objects with[RealmSet.containsAll()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmSet.html#containsAll-Collection-) ## Notifications To subscribe to changes to a `RealmSet`, pass a[SetChangeListener](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/SetChangeListener.html)implementation to the [RealmSet.addChangeListener](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmSet.html#addChangeListener-io.realm.SetChangeListener-) method. Your `SetChangeListener` implementation must define an`onChange()` method, which accepts a reference to the changed `RealmSet`and a set of changes as parameters. You can access the number of items added to the set as well as the number of items removed from the set through the `SetChangeSet` parameter. ← [RealmAny - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/realmany/ \"Previous Section\")[RealmDictionary - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/realmdictionary/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/realmdictionary/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # RealmDictionary - Java SDK On this page * [Usage](#usage)\n* [Notifications](#notifications) _New in version 10.6.0_. You can use the [RealmDictionary](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmDictionary.html) data type to manage a collection of unique `String` keys paired with values. `RealmDictionary`implements Java's `Map` interface, so it works just like the built-in`HashMap` class, except managed `RealmDictionary` instances persist their contents to a realm. `RealmDictionary` instances that contain Realm objects store references to those objects. When you delete a Realm object from a realm, any references to that object in a `RealmDictionary` become `null`values. ## Usage To create a field of type `RealmDictionary`, define an object property of type `RealmDictionary<T>`, where `T` defines the values you would like to store in your `RealmDictionary`. Currently, `RealmDictionary`instances can only use keys of type `String`. The following table shows which methods you can use to complete common collection tasks with `RealmDictionary`: | Task                                              | Method                                                                                                                             |\n| ------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\n| Add an object to a RealmDictionary                | [put()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmDictionary.html#put-E-) (or the \\[\\] operator in Kotlin) |\n| Add multiple objects to a RealmDictionary         | [putAll()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmDictionary.html#putAll-Map-)                          |\n| Check if the dictionary contains an specific key  | [containsKey()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmDictionary.html#containsKey-String-)             |\n| Check if the dictionary contains a specific value | [containsValue()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmDictionary.html#containsValue-Object-)         | ## Notifications To subscribe to changes to a `RealmDictionary`, pass a[MapChangeListener](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/MapChangeListener.html)implementation to the [RealmSet.addChangeListener](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmMap.html#addChangeListener-io.realm.MapChangeListener-) method. Your `MapChangeListener` implementation must define an`onChange()` method, which accepts a reference to the changed `RealmDictionary`and a set of changes as parameters. You can access the keys added to the dictionary as well as the keys removed from the dictionary through the `MapChangeSet` parameter.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Read & Write Data - Java SDK On this page * [About the Examples on this Page](#about-the-examples-on-this-page)\n* [Read from Realm Database](#read-from-realm-database)\n* [Find a Specific Object by Primary Key](#find-a-specific-object-by-primary-key)\n* [Query All Objects of a Given Type](#query-all-objects-of-a-given-type)\n* [Filter Queries Based on Object Properties](#filter-queries-based-on-object-properties)\n* [Sort Query Results](#sort-query-results)\n* [Query a Relationship](#query-a-relationship)\n* [Query an Inverse Relationship](#query-an-inverse-relationship)\n* [Aggregate Data](#aggregate-data)\n* [Write Operations](#write-operations)\n* [Create a New Object](#create-a-new-object)\n* [Modify an Object](#modify-an-object)\n* [Upsert an Object](#upsert-an-object)\n* [Update a Collection](#update-a-collection)\n* [Iteration](#iteration)\n* [Delete an Object](#delete-an-object)\n* [Delete Multiple Objects](#delete-multiple-objects)\n* [Delete an Object and its Dependent Objects](#delete-an-object-and-its-dependent-objects)\n* [Delete All Objects of a Specific Type](#delete-all-objects-of-a-specific-type)\n* [Delete All Objects in a Realm](#delete-all-objects-in-a-realm) ## About the Examples on this Page The examples on this page use the data model of a project management app that has two Realm object types: `Project`and `Task`. A `Project` has zero or more `Tasks`. See the schema for these two classes, `Project` and`Task`, below: ## Read from Realm Database A read from a realm generally consists of the following steps: * Get all [objects](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-objects) of a certain type from the realm.\n* Optionally, [filter](#std-label-java-filter-results) the results using the [query engine.](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-client-query-engine)\n* Optionally, [sort](#std-label-java-sort-results) the results. All query, filter, and sort operations return a[results collection](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-results-collections). The results collections are live, meaning they always contain the latest results of the associated query. ## Important ### Synchronous Reads and Writes on the UI Thread By default, you can only read or write to a realm in your application's UI thread using[asynchronous transactions](https://mongodb.com/docs/realm/sdk/java/fundamentals/async-api/#std-label-java-async-api). That is, you can only use `Realm` methods whose name ends with the word`Async` in the main thread of your Android application unless you explicitly allow the use of synchronous methods. This restriction exists for the benefit of your application users: performing read and write operations on the UI thread can lead to unresponsive or slow UI interactions, so it's usually best to handle these operations either asynchronously or in a background thread. However, if your application requires the use of synchronous realm reads or writes on the UI thread, you can explicitly allow the use of synchronous methods with the following`SyncConfiguration` options: ## Tip ### See also:  [Fundamentals: Live Queries](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/#std-label-java-live-queries) ### Find a Specific Object by Primary Key\n\n ### Query All Objects of a Given Type The first step of any read is to **get all objects** of a certain type in a realm. With this results collection, you can operate on all instances on a type or filter and sort to refine the results. In order to access all instances of `ProjectTask` and `Project`, use the [where()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmResults.html#where--) method to specify a class: ### Filter Queries Based on Object Properties A **filter** selects a subset of results based on the value(s) of one or more object properties. Realm Database provides a full-featured [query engine](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-client-query-engine) you can use to define filters. The most common use case is to find objects where a certain property matches a certain value. Additionally, you can compare strings, aggregate over collections of numbers, and use logical operators to build up complex queries. In the following example, we use the query engine's comparison operators to: * Find high priority tasks by comparing the value of the `priority` property value with a threshold number, above which priority can be considered high.\n* Find just-started or short-running tasks by seeing if the `progressMinutes` property falls within a certain range.\n* Find unassigned tasks by finding tasks where the `assignee` property is equal to null.\n* Find tasks assigned to specific teammates Ali or Jamie by seeing if the `assignee` property is in a list of names. ### Sort Query Results A **sort** operation allows you to configure the order in which Realm Database returns queried objects. You can sort based on one or more properties of the objects in the results collection. Realm Database only guarantees a consistent order of results when the results are sorted. The following code sorts the projects by name in reverse alphabetical order (i.e. \"descending\" order). ### Query a Relationship ## Tip ### See also:  [Fundamentals: Relationships](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-relationships) ### Query an Inverse Relationship ## Tip ### See also:  [Fundamentals: Inverse Relationships](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-inverse-relationships) ### Aggregate Data ## Write Operations All write operations to a realm must occur within a**write transaction**. For more information about how to perform a write transaction, see [Write Transactions.](https://mongodb.com/docs/realm/sdk/java/fundamentals/write-transactions/#std-label-java-write-transactions) ## Tip ### Realm Object Writes are File Writes Whenever you create, update, or delete a Realm object, your changes update the representation of that object in Realm Database and emit[notifications](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-react-to-changes) to any subscribed listeners. As a result, you should only write to Realm objects when necessary to persist data. ## Important ### Synchronous Reads and Writes on the UI Thread By default, you can only read or write to a realm in your application's UI thread using[asynchronous transactions](https://mongodb.com/docs/realm/sdk/java/fundamentals/async-api/#std-label-java-async-api). That is, you can only use `Realm` methods whose name ends with the word`Async` in the main thread of your Android application unless you explicitly allow the use of synchronous methods. This restriction exists for the benefit of your application users: performing read and write operations on the UI thread can lead to unresponsive or slow UI interactions, so it's usually best to handle these operations either asynchronously or in a background thread. However, if your application requires the use of synchronous realm reads or writes on the UI thread, you can explicitly allow the use of synchronous methods with the following`SyncConfiguration` options: ### Create a New Object\n\n The following example demonstrates how to create an object with[createObject():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#createObject-java.lang.Class-java.lang.Object-) You can also insert objects into a realm from JSON. Realm supports creating objects from `String`,[JSONObject](https://developer.android.com/reference/org/json/JSONObject.html), and[InputStream](https://developer.android.com/reference/java/io/InputStream.html) types. Realm ignores any properties present in the JSON that are not defined in the Realm object schema. The following example demonstrates how to create a single object from JSON with[createObjectFromJson()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#createObjectFromJson-java.lang.Class-java.lang.String-)or multiple objects from JSON with[createAllFromJson():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#createAllFromJson-java.lang.Class-java.lang.String-) ### Modify an Object Within a transaction, you can update a Realm object the same way you would update any other object in your language of choice. Just assign a new value to the property or update the property. The following example changes the turtle's name to \"Archibald\" and sets Archibald's age to 101 by assigning new values to properties: ### Upsert an Object An **upsert** is a write operation that either inserts a new object with a given primary key or updates an existing object that already has that primary key. We call this an upsert because it is an \"**update** or**insert**\" operation. This is useful when an object may or may not already exist, such as when bulk importing a dataset into an existing realm. Upserting is an elegant way to update existing entries while adding any new entries. The following example demonstrates how to upsert an object with realm. We create a new turtle enthusiast named \"Drew\" and then update their name to \"Andy\" using [insertOrUpdate():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#insertOrUpdate-io.realm.RealmModel-) You can also use [copyToRealmOrUpdate()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#copyToRealmOrUpdate-E-io.realm.ImportFlag...-) to either create a new object based on a supplied object or update an existing object with the same primary key value. Use the`CHECK_SAME_VALUES_BEFORE_SET` [ImportFlag](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/ImportFlag.html) to only update fields that are different in the supplied object: The following example demonstrates how to insert an object or, if an object already exists with the same primary key, update only those fields that differ: ### Update a Collection Realm Database supports collection-wide updates. A collection update applies the same update to specific properties of several objects in a collection at once. The following example demonstrates how to update a collection. Thanks to the [implicit inverse relationship](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-inverse-relationship) between the Turtle's`owner` property and the TurtleEnthusiast's `turtles` property, Realm Database automatically updates Josephine's list of turtles when you use [setObject()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmResults.html#setObject-java.lang.String-io.realm.RealmModel-)to update the \"owner\" property for all turtles in the collection. ### Iteration Because realm collections always reflect the latest state, they can appear, disappear, or change while you iterate over a collection. To get a stable collection you can iterate over, you can create a**snapshot** of a collection's data. A snapshot guarantees the order of elements will not change, even if an element is deleted or modified.\n\n The following example demonstrates how to iterate over a collection safely using either an implicit snapshot created from a `RealmResults` `Iterator` or a manual snapshot created from a `RealmList`: ### Delete an Object To delete an object from a realm, use either the dynamic or static versions of the `deleteFromRealm()` method of a [RealmObject](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmObject.html) subclass. The following example shows how to delete one object from its realm with [deleteFromRealm():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmObject.html#deleteFromRealm--) ## Tip ### Do not use objects after delete The SDK throws an error if you try to use an object after it has been deleted. ### Delete Multiple Objects To delete an object from a realm, use the `deleteAllFromRealm()`method of the [RealmResults](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmResults.html)instance that contains the objects you would like to delete. You can filter the `RealmResults` down to a subset of objects using the[where()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#where-java.lang.Class-) method. The following example demonstrates how to delete a collection from a realm with [deleteAllFromRealm():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmResults.html#deleteAllFromRealm--) ### Delete an Object and its Dependent Objects Sometimes, you have [dependent objects](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-client-relationships) that you want to delete when you delete the parent object. We call this a **chaining delete**. Realm Database does not delete the dependent objects for you. If you do not delete the objects yourself, they will remain orphaned in your realm. Whether or not this is a problem depends on your application's needs. Currently, the best way to delete dependent objects is to iterate through the dependencies and delete them before deleting the parent object. The following example demonstrates how to perform a chaining delete by first deleting all of Ali's turtles, then deleting Ali: ### Delete All Objects of a Specific Type Realm Database supports deleting all instances of a [Realm type](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-objects) from a realm. The following example demonstrates how to delete all Turtle instances from a realm with [delete():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#delete-java.lang.Class-) ### Delete All Objects in a Realm It is possible to delete all objects from the realm. This does not affect the schema of the realm. This is useful for quickly clearing out your realm while prototyping. The following example demonstrates how to delete everything from a realm with [deleteAll():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#deleteAll--) ← [Open & Close a Realm - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/ \"Previous Section\")[Filter Data - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/filter-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/embedded-objects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Embedded Objects - Java SDK On this page * [Embedded Object Data Models](#embedded-object-data-models)\n* [Realm Object Models](#realm-object-models)\n* [JSON Schema](#json-schema)\n* [Read and Write Embedded Objects](#read-and-write-embedded-objects)\n* [Create an Embedded Object](#create-an-embedded-object)\n* [Update an Embedded Object Property](#update-an-embedded-object-property)\n* [Overwrite an Embedded Object](#overwrite-an-embedded-object)\n* [Query a Collection on Embedded Object Properties](#query-a-collection-on-embedded-object-properties) An embedded object is a special type of [Realm object](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-objects) that models complex data about a specific object. Embedded objects are similar to [relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-client-relationships), but they provide additional constraints and map more naturally to the denormalized [MongoDB document model.](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/) Realm enforces unique ownership constraints that treat each embedded object as nested data inside of a single, specific parent object. An embedded object inherits the lifecycle of its parent object and cannot exist as an independent Realm object. Realm automatically deletes embedded objects if their parent object is deleted or when overwritten by a new embedded object instance. ## Warning ### Realm Uses Cascading Deletes for Embedded Objects When you delete a Realm object, Realm automatically deletes any embedded objects referenced by that object. Any objects that your application must persist after the deletion of their parent object should use [relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-client-relationships)instead. ## Embedded Object Data Models You can define embedded object types using either Realm object models or a server-side document schema. Embedded object types are reusable and composable. You can use the same embedded object type in multiple parent object types and you can embed objects inside of other embedded objects. ## Important Embedded objects cannot have a primary key. ### Realm Object Models To define an embedded object, derive a class from [RealmObject](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmObject.html) and set the `embedded` property of the[RealmClass](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/RealmClass.html) annotation to `true`. You can reference an embedded object type from parent object types in the same way as you would define a relationship: ### JSON Schema Embedded objects map to embedded documents in the parent type's [schema](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). This behavior differs from regular Realm objects, which map to their own MongoDB collection.\n\n ` ``` {   \"title\": \"Business\",   \"bsonType\": \"object\",   \"required\": [\"_id\", \"name\", \"addresses\"],   \"properties\": {     \"_id\": \"objectId\",     \"name\": { \"bsonType\": \"string\" },     \"addresses\": {       \"bsonType\": \"array\",       \"items\": {         \"title\": \"Address\",         \"bsonType\": \"object\",         \"properties\": {           \"street\": { \"bsonType\": \"string\" },           \"city\": { \"bsonType\": \"string\" },           \"country\": { \"bsonType\": \"string\" },           \"postalCode\": { \"bsonType\": \"string\" }         }       }     }   } } \n``` ## Read and Write Embedded Objects ### Create an Embedded Object To create an embedded object, assign an instance of the embedded object to a parent object's property: ### Update an Embedded Object Property To update a property in an embedded object, modify the property in a write transaction: ### Overwrite an Embedded Object To overwrite an embedded object, reassign the embedded object property of a party to a new instance in a write transaction: ### Query a Collection on Embedded Object Properties Use dot notation to filter or sort a [collection](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-client-collections) of objects based on an embedded object property value: ## Note It is not possible to query embedded objects directly. Instead, access embedded objects through a query for the parent object type. ← [Collections - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/collections/ \"Previous Section\")[Usage Examples - Java SDK](https://mongodb.com/docs/realm/sdk/java/examples/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/data-types/counters/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Counters - Java SDK On this page * [Usage](#usage) Realm Database offers [MutableRealmInteger](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/MutableRealmInteger.html), a wrapper around numeric values, to help better synchronize numeric changes across multiple clients. Typically, incrementing or decrementing a`byte`, `short`, `int`, or `long` field of a Realm object looks something like this: 1. Read the current value of the field.\n2. Update that value in memory to a new value based on the increment or decrement.\n3. Write a new value back to the field. When multiple distributed clients attempt this at the same time, updates reaching clients in different orders can result in different values on different clients. `MutableRealmInteger`improves on this by translating numeric updates into sync operations that can be executed in any order to converge to the same value. `MutableRealmInteger` fields are backed by traditional numeric types, so no migration is required when changing a field from `byte`, `short`,`int` or `long` to `MutableRealmInteger`. The following example demonstrates a `MutableRealmInteger` field that counts the number of ghosts found in a haunted house: ## Important ### Counter Fields Must be Final `MutableRealmInteger` is a live object like `RealmObject`,`RealmResults` and `RealmList`. This means the value contained inside the `MutableRealmInteger` can change when a realm is written to. For this reason `MutableRealmInteger` fields must be marked final in Java and `val` in Kotlin. ## Usage The [counter.increment()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/MutableRealmInteger.html#increment-long-)and [counter.decrement()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/MutableRealmInteger.html#decrement-long-)operators ensure that increments and decrements from multiple distributed clients are aggregated correctly. To change a [MutableRealmInteger](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/MutableRealmInteger.html) value, call `increment()` or`decrement()` within a write transaction: You can assign a `MutableRealmInteger` a new value with a call to[counter.set()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/MutableRealmInteger.html#set-long-)within a write transaction. ## Warning ### Counter Resets Use the `set()` operator with extreme care. `set()` ignores the effects of any prior calls to `increment()` or `decrement()`. Although the value of a `MutableRealmInteger` always converges across devices, the specific value on which it converges depends on the actual order in which operations took place. Mixing `set()` with `increment()` and `decrement()` is not advised unless fuzzy counting is acceptable. Since `MutableRealmInteger` instances retain a reference to their parent object, neither object can be garbage collected while you still retain a reference to the `MutableRealmInteger`. ← [Enumerations - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/enums/ \"Previous Section\")[RealmAny - Java SDK](https://mongodb.com/docs/realm/sdk/java/data-types/realmany/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/index/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # API Reference   \n* io.realm\n* io.realm.annotations\n* io.realm.coroutines\n* io.realm.exceptions\n* io.realm.gradle\n* io.realm.log\n* io.realm.mongodb\n* io.realm.mongodb.auth\n* io.realm.mongodb.functions\n* io.realm.mongodb.log.obfuscator\n* io.realm.mongodb.mongo\n* io.realm.mongodb.mongo.events\n* io.realm.mongodb.mongo.iterable\n* io.realm.mongodb.mongo.options\n* io.realm.mongodb.mongo.result\n* io.realm.mongodb.push\n* io.realm.mongodb.sync\n* io.realm.rx\n* io.realm.transformer [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Java API   \n* io.realm\n* io.realm.annotations\n* io.realm.coroutines\n* io.realm.exceptions\n* io.realm.log\n* io.realm.mongodb\n* io.realm.mongodb.auth\n* io.realm.mongodb.functions\n* io.realm.mongodb.log.obfuscator\n* io.realm.mongodb.mongo\n* io.realm.mongodb.mongo.events\n* io.realm.mongodb.mongo.iterable\n* io.realm.mongodb.mongo.options\n* io.realm.mongodb.mongo.result\n* io.realm.mongodb.push\n* io.realm.mongodb.sync\n* io.realm.rx [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.annotations   \n* [io.realm.annotations.Beta](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Beta/#std-label-io%5Frealm%5Fannotations%5FBeta)\n* [io.realm.annotations.Ignore](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Ignore/#std-label-io%5Frealm%5Fannotations%5FIgnore)\n* [io.realm.annotations.Index](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Index/#std-label-io%5Frealm%5Fannotations%5FIndex)\n* [io.realm.annotations.LinkingObjects](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/LinkingObjects/#std-label-io%5Frealm%5Fannotations%5FLinkingObjects)\n* [io.realm.annotations.PrimaryKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/PrimaryKey/#std-label-io%5Frealm%5Fannotations%5FPrimaryKey)\n* [io.realm.annotations.RealmClass](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/#std-label-io%5Frealm%5Fannotations%5FRealmClass)\n* [io.realm.annotations.RealmField](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmField/#std-label-io%5Frealm%5Fannotations%5FRealmField)\n* [io.realm.annotations.RealmModule](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmModule/#std-label-io%5Frealm%5Fannotations%5FRealmModule)\n* [io.realm.annotations.RealmNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmNamingPolicy/#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy)\n* [io.realm.annotations.Required](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Required/#std-label-io%5Frealm%5Fannotations%5FRequired) ← [Enum Sort](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/ \"Previous Section\")[Annotation Type Beta](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Beta/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm\n\n ← [API Reference](https://mongodb.com/docs/realm/sdk/java/api/ \"Previous Section\")[Enum Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionChangeListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface OrderedRealmCollectionChangeListener On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onChange](#onchange) ## io.realm [OrderedRealmCollectionChangeListener](#std-label-io%5Frealm%5FOrderedRealmCollectionChangeListener) can be registered with a [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) to receive a notification with a [OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/#std-label-io%5Frealm%5FOrderedCollectionChangeSet) to describe the details of what have been changed in the collection since last time. Realm instances on a thread without an [android.os.Looper](https://developer.android.com/reference/android/os/Looper) cannot register a [OrderedRealmCollectionChangeListener](#std-label-io%5Frealm%5FOrderedRealmCollectionChangeListener) . ## Tip ### See also:  * [RealmResults.addChangeListener(OrderedRealmCollectionChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults%5FaddChangeListener%5FOrderedRealmCollectionChangeListener%5F) ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                                                                                             |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public **void**   | [onChange](#std-label-io%5Frealm%5FOrderedRealmCollectionChangeListener%5FonChange) (**T** t,[OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/#std-label-io%5Frealm%5FOrderedCollectionChangeSet) changeSet)This will be called when the async query is finished the first time or the collection of objects has changed. | ## Method Detail ### onChange\n\n ← [Interface OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/ \"Previous Section\")[Class OrderedRealmCollectionSnapshot](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmMigration On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [migrate](#migrate) ## io.realm The RealmMigration class is used to perform the migration of one Realm schema to another. The schema for a Realm is defined by all classes in a project that extend [io.realm.RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) or implement [io.realm.RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/#std-label-io%5Frealm%5FRealmModel) , so any changes to these classes will require a migration. To support migrations from any previous schemaVersion to the newest, the following pattern is recommended when writing a migration:\n\n ` During development when RealmObject classes can change frequently, it is possible to use [io.realm.Realm.deleteRealm(RealmConfiguration)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FdeleteRealm%5FRealmConfiguration%5F) . This will delete the database file and eliminate the need for any migrations. ## Tip ### See also:  * [io.realm.RealmConfiguration.Builder.schemaVersion(long)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FschemaVersion%5Flong%5F)\n* [io.realm.RealmConfiguration.Builder.migration(RealmMigration)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5Fmigration%5FRealmMigration%5F)\n* [io.realm.RealmConfiguration.Builder.deleteRealmIfMigrationNeeded()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FdeleteRealmIfMigrationNeeded%5F%5F) ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                              |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [migrate](#std-label-io%5Frealm%5FRealmMigration%5Fmigrate) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,**long** oldVersion,**long** newVersion)This method will be called if a migration is needed. | ## Method Detail ### migrate\n\n ← [Class RealmMap](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/ \"Previous Section\")[Interface RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmCollection/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmCollection On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [average](#average)\n* [contains](#contains)\n* [deleteAllFromRealm](#deleteallfromrealm)\n* [isLoaded](#isloaded)\n* [isManaged](#ismanaged)\n* [isValid](#isvalid)\n* [load](#load)\n* [max](#max)\n* [maxDate](#maxdate)\n* [min](#min)\n* [minDate](#mindate)\n* [sum](#sum)\n* [where](#where) ## io.realm **Implemented interfaces:** * [java.util.Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)\n* [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html) `RealmCollection` is the root of the collection hierarchy that Realm supports. It defines operations on data collections and the behavior that they will have in all implementations of `RealmCollection` s. Realm collections are \"live\" views to the underlying data. This means that they automatically will be kept up to date. As a consequence, using methods like [Collections.unmodifiableCollection(Collection)](https://docs.oracle.com/javase/7/docs/api/java/util/Collections/unmodifiableCollection%28Collection%29.html) will not prevent a collection from being modified. ## Method Summary\n\n ## Inherited Methods ## Method Detail ### average | public **double** [average](#std-label-io%5Frealm%5FRealmCollection%5Faverage) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the average of a given field.**Parameters**fieldName \\- the field to calculate average on. Only number fields are supported.**Returns**the average for the given field amongst objects in query results. This will be of type double for all types of number fields. If no objects exist or they all have null as the value for the given field, 0 will be returned. When computing the average, objects with null values are ignored.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field is not a number type.[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm has been closed or called from an incorrect thread. | ### contains\n\n ### deleteAllFromRealm | public **boolean** [deleteAllFromRealm](#std-label-io%5Frealm%5FRealmCollection%5FdeleteAllFromRealm) ()                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| This deletes all objects in the collection from the underlying Realm as well as from the collection.**Returns**true if objects was deleted, false otherwise.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the corresponding Realm is closed or in an incorrect thread.[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm has been closed or called from an incorrect thread. | ### isLoaded | public **boolean** [isLoaded](#std-label-io%5Frealm%5FRealmCollection%5FisLoaded) ()                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if a collection has finished loading its data yet.**Returns**true if data has been loaded and is available, false if data is still being loaded. | ### isManaged\n\n ### isValid | public **boolean** [isValid](#std-label-io%5Frealm%5FRealmCollection%5FisValid) ()                                                                                                                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Checks if the collection is still valid to use, i.e., the [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) instance hasn't been closed. It will always return true for an unmanaged collection.**Returns**true if it is still valid to use or an unmanaged collection, false otherwise. | ### load | public **boolean** [load](#std-label-io%5Frealm%5FRealmCollection%5Fload) ()                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------- |\n| Blocks the collection until all data are available.**Returns**true if the data could be successfully loaded, false otherwise. | ### max\n\n ### maxDate | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [maxDate](#std-label-io%5Frealm%5FRealmCollection%5FmaxDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the maximum date.**Parameters**fieldName \\- the field to look for the maximum date. If fieldName is not of Date type, an exception is thrown.**Returns**if no objects exist or they all have null as the value for the given date field, null will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with null values are ignored.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if fieldName is not a Date field.[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm has been closed or called from an incorrect thread. | ### min\n\n ### minDate | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [minDate](#std-label-io%5Frealm%5FRealmCollection%5FminDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the minimum date.**Parameters**fieldName \\- the field to look for the minimum date. If fieldName is not of Date type, an exception is thrown.**Returns**if no objects exist or they all have null as the value for the given date field, null will be returned. Otherwise the minimum date is returned. When determining the minimum date, objects with null values are ignored.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if fieldName is not a Date field.[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm has been closed or called from an incorrect thread. | ### sum\n\n ### where | public [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) [where](#std-label-io%5Frealm%5FRealmCollection%5Fwhere) ()                                                                                                                                                                                                                                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) , which can be used to query for specific objects from this collection.**Returns**a RealmQuery object.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm instance has been closed or queries are not otherwise available.TipSee also: [io.realm.RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) | ← [Interface RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/ \"Previous Section\")[Class RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class DynamicRealm On this page * [io.realm](#io.realm)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [addChangeListener](#addchangelistener)\n* [asFlowable](#asflowable)\n* [createEmbeddedObject](#createembeddedobject)\n* [createObject](#createobject)\n* [delete](#delete)\n* [executeTransaction](#executetransaction)\n* [executeTransactionAsync](#executetransactionasync)\n* [freeze](#freeze)\n* [getInstance](#getinstance)\n* [getInstanceAsync](#getinstanceasync)\n* [getSchema](#getschema)\n* [isEmpty](#isempty)\n* [removeAllChangeListeners](#removeallchangelisteners)\n* [removeChangeListener](#removechangelistener)\n* [where](#where) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) **io.realm.BaseRealm** io.realm.DynamicRealm DynamicRealm is a dynamic variant of [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) . This means that all access to data and/or queries are done using string based class names instead of class type references. This is useful during migrations or when working with string-based data like CSV or XML files. The same [io.realm.RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) can be used to open a Realm file in both dynamic and typed mode, but modifying the schema while having both a typed and dynamic version open is highly discouraged and will most likely crash the typed Realm. During migrations only a DynamicRealm will be open. Dynamic Realms do not enforce schemas or schema versions and [RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/#std-label-io%5Frealm%5FRealmMigration) code is not used even if it has been defined in the [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) . This means that the schema is not created or validated until a Realm has been opened in typed mode. If a Realm file is opened in dynamic mode first it will not contain any information about classes and fields, and any queries for classes defined by the schema will fail. ## Tip ### See also:  * [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm)\n* [RealmSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSchema/#std-label-io%5Frealm%5FRealmSchema) ## Nested Class Summary\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class **io.realm.BaseRealm**: `setAutoRefresh` , `isAutoRefresh` , `refresh` , `isInTransaction` , `addListener` , `removeListener` , `asFlowable` , `removeAllListeners` , `writeCopyTo` , `writeEncryptedCopyTo` , `waitForChange` , `stopWaitForChange` , `beginTransaction` , `commitTransaction` , `cancelTransaction` , `freeze` , `isFrozen` , `getNumberOfActiveVersions` , `checkIfValid` , `checkAllowQueriesOnUiThread` , `checkAllowWritesOnUiThread` , `checkIfInTransaction` , `checkIfValidAndInTransaction` , `getPath` , `getConfiguration` , `getVersion` , `close` , `isClosed` , `isEmpty` , `getSchema` , `getSubscriptions` , `deleteAll` , `migrateRealm` , `finalize` ## Method Detail ### addChangeListener\n\n ### asFlowable\n\n ### createEmbeddedObject | public [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) [createEmbeddedObject](#std-label-io%5Frealm%5FDynamicRealm%5FcreateEmbeddedObject) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className,[DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) parentObject,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) parentProperty)                                                                                                                                                                                                                                                                                                                                                                                                 |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Instantiates and adds a new embedded object to the Realm.This method should only be used to create objects of types marked as embedded.**Parameters**className \\- the class name of the object to create.parentObject \\- The parent object which should hold a reference to the embedded object. If the parent property is a list the embedded object will be added to the end of that list.parentProperty \\- the property in the parent class which holds the reference.**Returns**the newly created embedded object.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if clazz is not an embedded class or if the property in the parent class cannot hold objects of the appropriate type.TipSee also: [RealmClass.embedded()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/#std-label-io%5Frealm%5Fannotations%5FRealmClass%5Fembedded%5F%5F) | ### createObject\n\n | public [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) [createObject](#std-label-io%5Frealm%5FDynamicRealm%5FcreateObject) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className)                                         |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Instantiates and adds a new object to the Realm.**Parameters**className \\- the class name of the object to create.**Returns**the new object.**Throws**[RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) \\- if the object could not be created. | ### delete | public **void** [delete](#std-label-io%5Frealm%5FDynamicRealm%5Fdelete) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className)                                                                                                                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deletes all objects of the specified class from the Realm.**Parameters**className \\- the class for which all objects should be removed.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm is closed or called from an incorrect thread. | ### executeTransaction\n\n ### executeTransactionAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [executeTransactionAsync](#std-label-io%5Frealm%5FDynamicRealm%5FexecuteTransactionAsync) ([DynamicRealm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction) transaction,[DynamicRealm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnSuccess/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnSuccess) onSuccess,[DynamicRealm.Transaction.OnError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnError/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnError) onError)                                                                                                             |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Similar to [executeTransactionAsync(Transaction)](#std-label-io%5Frealm%5FDynamicRealm%5FexecuteTransactionAsync%5FTransaction%5F) , but also accepts an OnSuccess and OnError callbacks.**Parameters**transaction \\- [Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction) to execute.onSuccess \\- callback invoked when the transaction succeeds.onError \\- callback invoked when the transaction fails.**Returns**a [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) representing a cancellable task.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the transaction is null , or if the realm is opened from another thread. |\n\n | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [executeTransactionAsync](#std-label-io%5Frealm%5FDynamicRealm%5FexecuteTransactionAsync) ([DynamicRealm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction) transaction,[DynamicRealm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnSuccess/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnSuccess) onSuccess)                                                                                                                                                                                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Similar to [executeTransactionAsync(Transaction)](#std-label-io%5Frealm%5FDynamicRealm%5FexecuteTransactionAsync%5FTransaction%5F) , but also accepts an OnSuccess callback.**Parameters**transaction \\- [Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction) to execute.onSuccess \\- callback invoked when the transaction succeeds.**Returns**a [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) representing a cancellable task.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the transaction is null , or if the realm is opened from another thread. |\n\n ### freeze\n\n ### getInstance\n\n ### getInstanceAsync\n\n ### getSchema | public [RealmSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSchema/#std-label-io%5Frealm%5FRealmSchema) [getSchema](#std-label-io%5Frealm%5FDynamicRealm%5FgetSchema) ()                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the mutable schema for this Realm.**Returns**The [RealmSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSchema/#std-label-io%5Frealm%5FRealmSchema) for this Realm.**Overrides**getSchema in class **BaseRealm** | ### isEmpty | public **boolean** [isEmpty](#std-label-io%5Frealm%5FDynamicRealm%5FisEmpty) ()                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if this [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) contains any objects.**Returns**true if empty, @{code false} otherwise.**Overrides**isEmpty in class **BaseRealm** | ### removeAllChangeListeners | public **void** [removeAllChangeListeners](#std-label-io%5Frealm%5FDynamicRealm%5FremoveAllChangeListeners) ()                                                                                                                                                                                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes all user-defined change listeners.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove listeners from a non-Looper Thread.TipSee also: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) | ### removeChangeListener\n\n ### where | public [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) [where](#std-label-io%5Frealm%5FDynamicRealm%5Fwhere) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className)                                                                                                                                                                                                                                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a RealmQuery, which can be used to query the provided class.**Parameters**className \\- the class of the object which is to be queried.**Returns**a RealmQuery, which can be used to query for specific objects of provided type.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the class doesn't exist.TipSee also: [io.realm.RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) | ← [Class DefaultCompactOnLaunchCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DefaultCompactOnLaunchCallback/ \"Previous Section\")[Class DynamicRealm.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Callback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmObject On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [addChangeListener](#addchangelistener)\n* [asChangesetObservable](#aschangesetobservable)\n* [asFlowable](#asflowable)\n* [deleteFromRealm](#deletefromrealm)\n* [freeze](#freeze)\n* [getRealm](#getrealm)\n* [isFrozen](#isfrozen)\n* [isLoaded](#isloaded)\n* [isManaged](#ismanaged)\n* [isValid](#isvalid)\n* [load](#load)\n* [removeAllChangeListeners](#removeallchangelisteners)\n* [removeChangeListener](#removechangelistener) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmObject **Implemented interfaces:** * [io.realm.RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/#std-label-io%5Frealm%5FRealmModel) In Realm you define your RealmObject classes by sub-classing RealmObject and adding fields to be persisted. You then create your objects within a Realm, and use your custom subclasses instead of using the RealmObject class directly.An annotation processor will create a proxy class for your RealmObject subclass. The following field data types are supported: * boolean/Boolean\n* short/Short\n* int/Integer\n* long/Long\n* float/Float\n* double/Double\n* byte\\[\\]\n* String\n* Date\n* UUID\n* org.bson.types.Decimal128\n* org.bson.types.ObjectId\n* Any RealmObject subclass\n* RealmList\n* RealmDictionary The types `short` , `int` , and `long` are mapped to `long` when storing within a Realm. The only restriction a RealmObject has is that fields are not allowed to be final or volatile. Any method as well as public fields are allowed. When providing custom constructors, a public constructor with no arguments must be declared. Fields annotated with [io.realm.annotations.Ignore](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Ignore/#std-label-io%5Frealm%5Fannotations%5FIgnore) don't have these restrictions and don't require either a getter or setter. Realm will create indexes for fields annotated with [io.realm.annotations.Index](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Index/#std-label-io%5Frealm%5Fannotations%5FIndex) . This will speedup queries but will have a negative impact on inserts and updates. A RealmObject cannot be passed between different threads. ## Tip ### See also:  * [Realm.createObject(Class)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcreateObject%5FClass%5F)\n* [Realm.copyToRealm(RealmModel, ImportFlag...)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcopyToRealm%5FRealmModel%5F%5FImportFlag%5F%5F%5F%5F) ## Constructors | Constructor and Description                             |\n| ------------------------------------------------------- |\n| [RealmObject](#std-label-io%5Frealm%5FRealmObject-1) () |\n\n\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [RealmObject](#std-label-io%5Frealm%5FRealmObject-1) () |\n| -------------------------------------------------------------- | ## Method Detail ### addChangeListener\n\n\n\n\n\n\n\n ### asChangesetObservable\n\n\n\n ### asFlowable\n\n\n\n ### deleteFromRealm | public static **void** [deleteFromRealm](#std-label-io%5Frealm%5FRealmObject%5FdeleteFromRealm) <**E** \\>(**E** object)                                                                                                                                                                                                                                                                                                                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Deletes the object from the Realm it is currently associated with.After this method is called the object will be invalid and any operation (read or write) performed on it will fail with an IllegalStateException.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the corresponding Realm is closed or in an incorrect thread.TipSee also: [isValid()](#std-label-io%5Frealm%5FRealmObject%5FisValid%5F%5F) |\n\n ### freeze\n\n\n\n ### getRealm\n\n\n\n ### isFrozen | public static **boolean** [isFrozen](#std-label-io%5Frealm%5FRealmObject%5FisFrozen) <**E** \\>(**E** object)                                                                                   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns whether or not this RealmObject is frozen.**Returns**true if the RealmObject is frozen, false if it is not.TipSee also: [freeze()](#std-label-io%5Frealm%5FRealmObject%5Ffreeze%5F%5F) | | public final **boolean** [isFrozen](#std-label-io%5Frealm%5FRealmObject%5FisFrozen) ()                                                                                                         |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns whether or not this RealmObject is frozen.**Returns**true if the RealmObject is frozen, false if it is not.TipSee also: [freeze()](#std-label-io%5Frealm%5FRealmObject%5Ffreeze%5F%5F) | ### isLoaded\n\n\n\n ### isManaged\n\n\n\n ### isValid | public static **boolean** [isValid](#std-label-io%5Frealm%5FRealmObject%5FisValid) <**E** \\>(**E** object)                                                                                                                                                                                                                                                                                                       |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if the RealmObject is still valid to use i.e., the RealmObject hasn't been deleted nor has the [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) been closed. It will always return true for unmanaged objects.**Parameters**object \\- RealmObject to check validity for.**Returns**true if the object is still accessible or an unmanaged object, false otherwise. |\n\n ### load | public static **boolean** [load](#std-label-io%5Frealm%5FRealmObject%5Fload) <**E** \\>(**E** object)                                                                                                                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Makes an asynchronous query blocking. This will also trigger any registered listeners.Note: This will return true if called for an unmanaged object (created outside of Realm).**Parameters**object \\- RealmObject to force load.**Returns**true if it successfully completed the query, false otherwise. | | public final **boolean** [load](#std-label-io%5Frealm%5FRealmObject%5Fload) ()                                                                                                                                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Makes an asynchronous query blocking. This will also trigger any registered listeners.Note: This will return true if called for an unmanaged object (created outside of Realm).**Returns**true if it successfully completed the query, false otherwise. | ### removeAllChangeListeners | public static **void** [removeAllChangeListeners](#std-label-io%5Frealm%5FRealmObject%5FremoveAllChangeListeners) <**E** \\>(**E** object)                                                                                                                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes all registered listeners from the given RealmObject.**Parameters**object \\- RealmObject to remove all listeners from.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if object is null or isn't managed by Realm. |\n\n ### removeChangeListener | public static **void** [removeChangeListener](#std-label-io%5Frealm%5FRealmObject%5FremoveChangeListener) <**E** \\>(**E** object,[io.realm.RealmChangeListener<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) listener)                                                                                                                                                                                                                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes a previously registered listener on the given RealmObject.**Parameters**object \\- RealmObject to remove listener from.listener \\- the instance to be removed.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the object or the change listener is null .[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if object is an unmanaged RealmObject.[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove a listener from a non-Looper Thread. |\n\n | public final **void** [removeChangeListener](#std-label-io%5Frealm%5FRealmObject%5FremoveChangeListener) ([io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) listener)                                                                                                                                                                                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes a previously registered listener.**Parameters**listener \\- the instance to be removed.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the change listener is null or the object is an unmanaged object.[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove a listener from a non-Looper Thread. | | public final **void** [removeChangeListener](#std-label-io%5Frealm%5FRealmObject%5FremoveChangeListener) ([io.realm.RealmObjectChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectChangeListener/#std-label-io%5Frealm%5FRealmObjectChangeListener) listener)                                                                                                                                                                                           |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes a previously registered listener.**Parameters**listener \\- the instance to be removed.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the change listener is null or the object is an unmanaged object.[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove a listener from a non-Looper Thread. | ← [Interface RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/ \"Previous Section\")[Interface RealmObjectChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectChangeListener/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectChangeListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmObjectChangeListener On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onChange](#onchange) ## io.realm `RealmObjectChangeListener` can be registered on a [RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/#std-label-io%5Frealm%5FRealmModel) or [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) to receive detailed notifications when an object changes. Realm instances on a thread without an [android.os.Looper](https://developer.android.com/reference/android/os/Looper) cannot register a `RealmObjectChangeListener` . Listener cannot be registered inside a transaction. ## Tip ### See also:  * [Realm.addChangeListener(RealmChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FaddChangeListener%5FRealmChangeListener%5F)\n* [Realm.removeAllChangeListeners()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FremoveAllChangeListeners%5F%5F)\n* [Realm.removeChangeListener(RealmChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FremoveChangeListener%5FRealmChangeListener%5F) ## Method Summary\n\n ## Method Detail ### onChange\n\n ← [Class RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/ \"Previous Section\")[Class RealmObjectSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/gradle/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.gradle   \n* [io.realm.gradle.RealmPluginExtension](https://mongodb.com/docs/realm/sdk/java/api/io/realm/gradle/RealmPluginExtension/#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension-1)\n* [io.realm.gradle.RealmPluginExtension.PropertyChangedListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/gradle/RealmPluginExtension/PropertyChangedListener/#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FPropertyChangedListener) [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmAny On this page * [io.realm](#io.realm)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [asBinary](#asbinary)\n* [asBoolean](#asboolean)\n* [asByte](#asbyte)\n* [asDate](#asdate)\n* [asDecimal128](#asdecimal128)\n* [asDouble](#asdouble)\n* [asFloat](#asfloat)\n* [asInteger](#asinteger)\n* [asLong](#aslong)\n* [asObjectId](#asobjectid)\n* [asRealmModel](#asrealmmodel)\n* [asShort](#asshort)\n* [asString](#asstring)\n* [asUUID](#asuuid)\n* [coercedEquals](#coercedequals)\n* [equals](#equals)\n* [getType](#gettype)\n* [getValueClass](#getvalueclass)\n* [hashCode](#hashcode)\n* [isNull](#isnull)\n* [nullValue](#nullvalue)\n* [toString](#tostring)\n* [valueOf](#valueof) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmAny [io.realm.RealmAny](#std-label-io%5Frealm%5FRealmAny) is used to represent a polymorphic Realm value. At any particular moment an instance of this class stores a definite value of a definite type. If, for instance, that is an double value, you may call asDouble() to extract that value. You may call getType() to discover what type of value is currently stored. Calling asDouble() on an instance that does not store an double would raise a [java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) . RealmAny behaves like a value type on all the supported types except on Realm objects. It means that Realm will not persist any change to the RealmAny value except when the type is Realm object. When a RealmAny holds a Realm object, it just holds the reference to it, not a copy of the object. So modifications to the Realm object are reflected in the RealmAny value, including if the object is deleted. Because RealmAny instances are immutable, a new instance is needed to update a RealmAny attribute. `| anObject.realmAnyAttribute = RealmAny.valueOf(5);    |\n| ---------------------------------------------------- |\n| anObject.realmAnyAttribute = RealmAny.valueOf(10.f); | ` It is crucial to understand that the act of extracting a value of a particular type requires definite knowledge about the stored type. Calling a getter method for any particular type, that is not the same type as the stored value, would raise an exception.Our recommendation to handle the RealmAny polymorphism is to write a switch case around the RealmAny type and its inner value class. ```java RealmAny realmAny = aRealmObject.realmAnyAttribute; switch (realmAny.getType()) {     case OBJECT:         if (realmAny.getValueClass().equals(DogRealmModel.class)) {             DogRealmModel value = realmAny.asRealmModel(DogRealmModel.class);         }     case INTEGER:         performAction(realmAny.asInteger());         break;     case BOOLEAN:         performAction(realmAny.asBoolean());         break;     case STRING:         performAction(realmAny.asString());         break;     case BINARY:\n\n         break;     case DATE:         performAction(realmAny.asDate());         break;     case FLOAT:         performAction(realmAny.asFloat());         break;     case DOUBLE:         performAction(realmAny.asDouble());         break;     case DECIMAL128:         performAction(realmAny.asDecimal128());         break;     case OBJECT_ID:         performAction(realmAny.asObjectId());         break;     case UUID:         performAction(realmAny.asUUID());         break;     case NULL:         performNullAction();         break; } \n``` getValueClass() returns the Java class that represents the inner value wrapped by the RealmAny instance. If the resulting class is a realization of [io.realm.RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/#std-label-io%5Frealm%5FRealmModel) asRealmModel() can be called to cast the RealmAny value to a Realm object reference. RealmAny values can also be sorted. The sorting order used between different RealmAny types, from lowest to highest, is: 1. Boolean\n2. Byte/Short/Integer/Long/Float/Double/Decimal128\n3. byte\\[\\]/String\n4. Date\n5. ObjectId\n6. UUID\n7. RealmObject This has implications on how [RealmQuery.sort(String)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5Fsort%5FString%5F) , [RealmQuery.minRealmAny(String)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5FminRealmAny%5FString%5F) and [RealmQuery.maxRealmAny(String)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5FmaxRealmAny%5FString%5F) work. Especially `min()` and `max()` will not only take numeric fields into account, but will use the sorting order to determine the \"largest\" or \"lowest\" value. ## Nested Class Summary | Modifier and Type   | Class and Description                                                                                    |\n| ------------------- | -------------------------------------------------------------------------------------------------------- |\n| public static final | [RealmAny.Type](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### asBinary | public **byte** [asBinary](#std-label-io%5Frealm%5FRealmAny%5FasBinary) ()                                                                                                                                                                                       |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a byte\\[\\] if it is one, otherwise throws exception.**Returns**a byte\\[\\].**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asBoolean | public [Boolean](https://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html) [asBoolean](#std-label-io%5Frealm%5FRealmAny%5FasBoolean) ()                                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a Boolean if it is one, otherwise throws exception.**Returns**a Boolean.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asByte | public [Byte](https://docs.oracle.com/javase/7/docs/api/java/lang/Byte.html) [asByte](#std-label-io%5Frealm%5FRealmAny%5FasByte) ()                                                                                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a Byte if it is one, otherwise throws exception.**Returns**a Byte.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asDate\n\n ### asDecimal128 | public **Decimal128** [asDecimal128](#std-label-io%5Frealm%5FRealmAny%5FasDecimal128) ()                                                                                                                                                                             |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a Decimal128 if it is one, otherwise throws exception.**Returns**a Decimal128.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asDouble | public [Double](https://docs.oracle.com/javase/7/docs/api/java/lang/Double.html) [asDouble](#std-label-io%5Frealm%5FRealmAny%5FasDouble) ()                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Gets this value as a Double if it is one, otherwise throws exception.**Returns**a Double.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asFloat | public [Float](https://docs.oracle.com/javase/7/docs/api/java/lang/Float.html) [asFloat](#std-label-io%5Frealm%5FRealmAny%5FasFloat) ()                                                                                                                    |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a Float if it is one, otherwise throws exception.**Returns**a Float.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asInteger\n\n ### asLong | public [Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) [asLong](#std-label-io%5Frealm%5FRealmAny%5FasLong) ()                                                                                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a Long if it is one, otherwise throws exception.**Returns**a Long.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asObjectId | public **ObjectId** [asObjectId](#std-label-io%5Frealm%5FRealmAny%5FasObjectId) ()                                                                                                                                                                                |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a ObjectId if it is one, otherwise throws exception.**Returns**an ObjectId.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asRealmModel | public **T** [asRealmModel](#std-label-io%5Frealm%5FRealmAny%5FasRealmModel) <**T** \\>([java.lang.Class<T>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) clazz)                                                                                                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a RealmModel if it is one, otherwise throws exception.**Type Parameters**T \\- the RealmModel type to cast the inner value to.**Returns**a RealmModel of the T type.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asShort\n\n ### asString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [asString](#std-label-io%5Frealm%5FRealmAny%5FasString) ()                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Gets this value as a String if it is one, otherwise throws exception.**Returns**a String.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### asUUID | public [UUID](https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html) [asUUID](#std-label-io%5Frealm%5FRealmAny%5FasUUID) ()                                                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets this value as a UUID if it is one, otherwise throws exception.**Returns**an UUID.**Throws**[java.lang.ClassCastException](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html) \\- if this value is not of the expected type. | ### coercedEquals | public final **boolean** [coercedEquals](#std-label-io%5Frealm%5FRealmAny%5FcoercedEquals) ([RealmAny](#std-label-io%5Frealm%5FRealmAny) other) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------- | ### equals | public final **boolean** [equals](#std-label-io%5Frealm%5FRealmAny%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) other)                                                                                                 |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Two RealmAny s are .equals if and only if their contents are equal.**Parameters**other \\- compare target**Returns**true if the target has the same value**Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### getType\n\n ### getValueClass | public [Class](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) [getValueClass](#std-label-io%5Frealm%5FRealmAny%5FgetValueClass) ()                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the Java class that represents the inner value wrapped by this RealmAny value.**Returns**the class that represents the inner value wrapped by this RealmAny value. | ### hashCode | public final **int** [hashCode](#std-label-io%5Frealm%5FRealmAny%5FhashCode) ()                                                                                                                                                                                                                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| A RealmAny 's hash code is, exactly, the hash code of its value.**Returns**true if the target has the same value**Throws**[NullPointerException](https://docs.oracle.com/javase/7/docs/api/java/lang/NullPointerException.html) \\- if the inner value is null**Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### isNull | public **boolean** [isNull](#std-label-io%5Frealm%5FRealmAny%5FisNull) ()                                             |\n| --------------------------------------------------------------------------------------------------------------------- |\n| Returns true if the inner value is null, false otherwise.**Returns**true if the inner value is null, false otherwise. | ### nullValue | public static [RealmAny](#std-label-io%5Frealm%5FRealmAny) [nullValue](#std-label-io%5Frealm%5FRealmAny%5FnullValue) () |\n| ----------------------------------------------------------------------------------------------------------------------- |\n| Creates a new RealmAny of a null value.**Returns**a new RealmAny instance of a null value.                              | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5FRealmAny%5FtoString) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                    | ### valueOf\n\n | public static [RealmAny](#std-label-io%5Frealm%5FRealmAny) [valueOf](#std-label-io%5Frealm%5FRealmAny%5FvalueOf) (**ObjectId** value)                                                                                                                                                                                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new RealmAny with the specified value. If the value is not null the type will be [RealmAny.Type.OBJECT\\_ID](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FOBJECT%5FID) , [RealmAny.Type.NULL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FNULL) otherwise.**Parameters**value \\- the RealmAny value.**Returns**a new RealmAny of an ObjectId. |\n\n | public static [RealmAny](#std-label-io%5Frealm%5FRealmAny) [valueOf](#std-label-io%5Frealm%5FRealmAny%5FvalueOf) (**byte\\[\\]** value)                                                                                                                                                                                                                                                                                                   |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new RealmAny with the specified value. If the value is not null the type will be [RealmAny.Type.BINARY](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FBINARY) , [RealmAny.Type.NULL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FNULL) otherwise.**Parameters**value \\- the RealmAny value.**Returns**a new RealmAny of a byte\\[\\]. |\n\n | public static [RealmAny](#std-label-io%5Frealm%5FRealmAny) [valueOf](#std-label-io%5Frealm%5FRealmAny%5FvalueOf) ([Double](https://docs.oracle.com/javase/7/docs/api/java/lang/Double.html) value)                                                                                                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new RealmAny with the specified value. If the value is not null the type will be [RealmAny.Type.DOUBLE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FDOUBLE) , [RealmAny.Type.NULL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FNULL) otherwise.**Parameters**value \\- the RealmAny value.**Returns**a new RealmAny of a Double. | | public static [RealmAny](#std-label-io%5Frealm%5FRealmAny) [valueOf](#std-label-io%5Frealm%5FRealmAny%5FvalueOf) ([Float](https://docs.oracle.com/javase/7/docs/api/java/lang/Float.html) value)                                                                                                                                                                                                                                   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new RealmAny with the specified value. If the value is not null the type will be [RealmAny.Type.FLOAT](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FFLOAT) , [RealmAny.Type.NULL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FNULL) otherwise.**Parameters**value \\- the RealmAny value.**Returns**a new RealmAny of a Float. |\n\n | public static [RealmAny](#std-label-io%5Frealm%5FRealmAny) [valueOf](#std-label-io%5Frealm%5FRealmAny%5FvalueOf) ([Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) value)                                                                                                                                                                                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new RealmAny with the specified value. If the value is not null the type will be [RealmAny.Type.INTEGER](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FINTEGER) , [RealmAny.Type.NULL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FNULL) otherwise.**Parameters**value \\- the RealmAny value.**Returns**a new RealmAny of a Long. | | public static [RealmAny](#std-label-io%5Frealm%5FRealmAny) [valueOf](#std-label-io%5Frealm%5FRealmAny%5FvalueOf) ([Integer](https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html) value)                                                                                                                                                                                                                                     |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new RealmAny with the specified value. If the value is not null the type will be [RealmAny.Type.INTEGER](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FINTEGER) , [RealmAny.Type.NULL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FNULL) otherwise.**Parameters**value \\- the RealmAny value.**Returns**a new RealmAny of a Integer. |\n\n | public static [RealmAny](#std-label-io%5Frealm%5FRealmAny) [valueOf](#std-label-io%5Frealm%5FRealmAny%5FvalueOf) ([Byte](https://docs.oracle.com/javase/7/docs/api/java/lang/Byte.html) value)                                                                                                                                                                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new RealmAny with the specified value. If the value is not null the type will be [RealmAny.Type.INTEGER](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FINTEGER) , [RealmAny.Type.NULL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/#std-label-io%5Frealm%5FRealmAny%5FType%5FNULL) otherwise.**Parameters**value \\- the RealmAny value.**Returns**a new RealmAny containing a Byte value. | ← [Interface Realm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnSuccess/ \"Previous Section\")[Enum RealmAny.Type](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/log/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.log   \n* [io.realm.log.LogLevel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel-1)\n* [io.realm.log.RealmLog](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLog/#std-label-io%5Frealm%5Flog%5FRealmLog-1)\n* [io.realm.log.RealmLogger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLogger/#std-label-io%5Frealm%5Flog%5FRealmLogger) ← [Error RealmError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmError/ \"Previous Section\")[Class LogLevel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface OrderedCollectionChangeSet On this page * [io.realm](#io.realm)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [getChangeRanges](#getchangeranges)\n* [getChanges](#getchanges)\n* [getDeletionRanges](#getdeletionranges)\n* [getDeletions](#getdeletions)\n* [getError](#geterror)\n* [getInsertionRanges](#getinsertionranges)\n* [getInsertions](#getinsertions)\n* [getState](#getstate) ## io.realm This interface describes the changes made to a collection during the last update.:ref:`OrderedCollectionChangeSet <io_realm_OrderedCollectionChangeSet>` is passed to the [OrderedRealmCollectionChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionChangeListener/#std-label-io%5Frealm%5FOrderedRealmCollectionChangeListener) which is registered by [RealmResults.addChangeListener(OrderedRealmCollectionChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults%5FaddChangeListener%5FOrderedRealmCollectionChangeListener%5F) . The change information is available in two formats: a simple array of row indices in the collection for each type of change, or an array of [Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) s. ## Nested Class Summary | Modifier and Type   | Class and Description                                                                                                                                               |\n| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static final | [OrderedCollectionChangeSet.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/State/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState)   |\n| public static       | [OrderedCollectionChangeSet.Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) | ## Method Summary\n\n ## Method Detail ### getChangeRanges | public [OrderedCollectionChangeSet.Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) [getChangeRanges](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FgetChangeRanges) ()                               |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| The modified ranges of objects in the new version of the collection.**Returns**the [Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) array. A zero-sized array will be returned if no objects were modified. | ### getChanges | public **int** [getChanges](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FgetChanges) ()                                                                                                                                                                                                                                                                                                                   |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| The modified indices in the new version of the collection.For [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) , this means that one or more of the properties of the object at the given index were modified (or an object linked to by that object was modified).**Returns**the indices array. A zero-sized array will be returned if objects were modified. | ### getDeletionRanges | public [OrderedCollectionChangeSet.Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) [getDeletionRanges](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FgetDeletionRanges) ()                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| The deleted ranges of objects in the previous version of the collection.**Returns**the [Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) array. A zero-sized array will be returned if no objects were deleted. | ### getDeletions\n\n ### getError | public [Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [getError](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FgetError) ()                                                                                                                 |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns any error that happened. If an error has happened, the state of the collection and other changeset information is undefined. It is possible for a collection to go into an error state after being created and starting to send updates.**Returns**the error that happened. | ### getInsertionRanges | public [OrderedCollectionChangeSet.Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) [getInsertionRanges](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FgetInsertionRanges) ()                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| The inserted ranges of objects in the new version of the collection.**Returns**the [Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) array. A zero-sized array will be returned if no objects were inserted. | ### getInsertions | public **int** [getInsertions](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FgetInsertions) ()                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| The inserted indices in the new version of the collection.**Returns**the indices array. A zero-sized array will be returned if no objects were inserted. | ### getState\n\n ← [Interface ObjectChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ObjectChangeSet/ \"Previous Section\")[Class OrderedCollectionChangeSet.Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAnyNativeFunctionsImpl/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmAnyNativeFunctionsImpl On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [callRawPredicate](#callrawpredicate)\n* [handleItem](#handleitem) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmAnyNativeFunctionsImpl ## Constructors | Constructor and Description                                                             |\n| --------------------------------------------------------------------------------------- |\n| [RealmAnyNativeFunctionsImpl](#std-label-io%5Frealm%5FRealmAnyNativeFunctionsImpl-1) () | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [RealmAnyNativeFunctionsImpl](#std-label-io%5Frealm%5FRealmAnyNativeFunctionsImpl-1) () |\n| ---------------------------------------------------------------------------------------------- | ## Method Detail ### callRawPredicate | public **void** [callRawPredicate](#std-label-io%5Frealm%5FRealmAnyNativeFunctionsImpl%5FcallRawPredicate) (**TableQuery** query,**OsKeyPathMapping** mapping,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) predicate,[io.realm.RealmAny\\[\\]](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) arguments) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### handleItem | public **void** [handleItem](#std-label-io%5Frealm%5FRealmAnyNativeFunctionsImpl%5FhandleItem) (**long** containerPtr,[java.util.Map.Entry<java.lang.String, io.realm.RealmAny>](https://docs.oracle.com/javase/7/docs/api/java/util/Map/Entry.html) entry) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | public **void** [handleItem](#std-label-io%5Frealm%5FRealmAnyNativeFunctionsImpl%5FhandleItem) (**long** listPtr,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) realmAny) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ← [Enum RealmAny.Type](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/ \"Previous Section\")[Class RealmAnyOperator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAnyOperator/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/ProxyState/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class ProxyState On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [addChangeListener](#addchangelistener)\n* [checkValidObject](#checkvalidobject)\n* [getAcceptDefaultValue$realm](#getacceptdefaultvalue-realm)\n* [getExcludeFields$realm](#getexcludefields-realm)\n* [getRealm$realm](#getrealm-realm)\n* [getRow$realm](#getrow-realm)\n* [isLoaded](#isloaded)\n* [isUnderConstruction](#isunderconstruction)\n* [load](#load)\n* [onQueryFinished](#onqueryfinished)\n* [removeAllChangeListeners](#removeallchangelisteners)\n* [removeChangeListener](#removechangelistener)\n* [setAcceptDefaultValue$realm](#setacceptdefaultvalue-realm)\n* [setConstructionFinished](#setconstructionfinished)\n* [setExcludeFields$realm](#setexcludefields-realm)\n* [setRealm$realm](#setrealm-realm)\n* [setRow$realm](#setrow-realm) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.ProxyState This implements `RealmObjectProxy` interface, to eliminate copying logic between [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) and [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) . ## Constructors | Constructor and Description                                      |\n| ---------------------------------------------------------------- |\n| [ProxyState](#std-label-io%5Frealm%5FProxyState-1) ()            |\n| [ProxyState](#std-label-io%5Frealm%5FProxyState-1) (**E** model) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [ProxyState](#std-label-io%5Frealm%5FProxyState-1) () |\n| ------------------------------------------------------------ | | public [ProxyState](#std-label-io%5Frealm%5FProxyState-1) (**E** model) |\n| ----------------------------------------------------------------------- | ## Method Detail ### addChangeListener | public **void** [addChangeListener](#std-label-io%5Frealm%5FProxyState%5FaddChangeListener) ([io.realm.RealmObjectChangeListener<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectChangeListener/#std-label-io%5Frealm%5FRealmObjectChangeListener) listener) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### checkValidObject | public **void** [checkValidObject](#std-label-io%5Frealm%5FProxyState%5FcheckValidObject) ([RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/#std-label-io%5Frealm%5FRealmModel) value) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Check that object is a valid and managed object by this Realm. Used by proxy classes to verify input.**Parameters**value \\- model object                                                        | ### getAcceptDefaultValue$realm | public **boolean** [getAcceptDefaultValue$realm](#std-label-io%5Frealm%5FProxyState%5FgetAcceptDefaultValue%5Frealm) () |\n| ----------------------------------------------------------------------------------------------------------------------- | ### getExcludeFields$realm | public [List](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) [getExcludeFields$realm](#std-label-io%5Frealm%5FProxyState%5FgetExcludeFields%5Frealm) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getRealm$realm | public **BaseRealm** [getRealm$realm](#std-label-io%5Frealm%5FProxyState%5FgetRealm%5Frealm) () |\n| ----------------------------------------------------------------------------------------------- | ### getRow$realm | public **Row** [getRow$realm](#std-label-io%5Frealm%5FProxyState%5FgetRow%5Frealm) () |\n| ------------------------------------------------------------------------------------- | ### isLoaded | public **boolean** [isLoaded](#std-label-io%5Frealm%5FProxyState%5FisLoaded) () |\n| ------------------------------------------------------------------------------- | ### isUnderConstruction | public **boolean** [isUnderConstruction](#std-label-io%5Frealm%5FProxyState%5FisUnderConstruction) () |\n| ----------------------------------------------------------------------------------------------------- | ### load | public **void** [load](#std-label-io%5Frealm%5FProxyState%5Fload) () |\n| -------------------------------------------------------------------- | ### onQueryFinished | public **void** [onQueryFinished](#std-label-io%5Frealm%5FProxyState%5FonQueryFinished) (**Row** row) |\n| ----------------------------------------------------------------------------------------------------- | ### removeAllChangeListeners | public **void** [removeAllChangeListeners](#std-label-io%5Frealm%5FProxyState%5FremoveAllChangeListeners) () |\n| ------------------------------------------------------------------------------------------------------------ | ### removeChangeListener\n\n ### setAcceptDefaultValue$realm | public **void** [setAcceptDefaultValue$realm](#std-label-io%5Frealm%5FProxyState%5FsetAcceptDefaultValue%5Frealm) (**boolean** acceptDefaultValue) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------- | ### setConstructionFinished | public **void** [setConstructionFinished](#std-label-io%5Frealm%5FProxyState%5FsetConstructionFinished) () |\n| ---------------------------------------------------------------------------------------------------------- | ### setExcludeFields$realm | public **void** [setExcludeFields$realm](#std-label-io%5Frealm%5FProxyState%5FsetExcludeFields%5Frealm) ([java.util.List<java.lang.String>](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) excludeFields) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### setRealm$realm | public **void** [setRealm$realm](#std-label-io%5Frealm%5FProxyState%5FsetRealm%5Frealm) (**BaseRealm** realm) |\n| ------------------------------------------------------------------------------------------------------------- | ### setRow$realm | public **void** [setRow$realm](#std-label-io%5Frealm%5FProxyState%5FsetRow%5Frealm) (**Row** row) |\n| ------------------------------------------------------------------------------------------------- | ← [Class OrderedRealmCollectionSnapshot](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/ \"Previous Section\")[Class Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/Case/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum Case On this page * [io.realm](#io.realm)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [INSENSITIVE](#insensitive)\n* [SENSITIVE](#sensitive)\n* [Method Detail](#method-detail)\n* [getValue](#getvalue)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.Case This class describes the Case settings used in Realm queries. ## Tip ### See also:  * [io.realm.RealmQuery.equalTo(String, String, Case)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5FequalTo%5FString%5F%5FString%5F%5FCase%5F)\n* [io.realm.RealmQuery.contains(String, String, Case)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5Fcontains%5FString%5F%5FString%5F%5FCase%5F)\n* [io.realm.RealmQuery.beginsWith(String, String, Case)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5FbeginsWith%5FString%5F%5FString%5F%5FCase%5F)\n* [io.realm.RealmQuery.endsWith(String, String, Case)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5FendsWith%5FString%5F%5FString%5F%5FCase%5F) ## Enum Constant Summary | Enum Constant and Description                             |\n| --------------------------------------------------------- |\n| [INSENSITIVE](#std-label-io%5Frealm%5FCase%5FINSENSITIVE) |\n| [SENSITIVE](#std-label-io%5Frealm%5FCase%5FSENSITIVE)     | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `INSENSITIVE` public static final [Case](#std-label-io%5Frealm%5FCase) ### `SENSITIVE` public static final [Case](#std-label-io%5Frealm%5FCase) ## Method Detail ### getValue | public **boolean** [getValue](#std-label-io%5Frealm%5FCase%5FgetValue) ()                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the value for this setting that is used by the underlying query engine.**Returns**The value used by the underlying query engine to indicate this value. | ### valueOf | public static [Case](#std-label-io%5Frealm%5FCase) [valueOf](#std-label-io%5Frealm%5FCase%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [Case](#std-label-io%5Frealm%5FCase) [values](#std-label-io%5Frealm%5FCase%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------- | ← [io.realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ \"Previous Section\")[Class CollectionUtils](https://mongodb.com/docs/realm/sdk/java/api/io/realm/CollectionUtils/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class DynamicRealmObject On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [get](#get)\n* [getBlob](#getblob)\n* [getBoolean](#getboolean)\n* [getByte](#getbyte)\n* [getDate](#getdate)\n* [getDecimal128](#getdecimal128)\n* [getDictionary](#getdictionary)\n* [getDouble](#getdouble)\n* [getDynamicRealm](#getdynamicrealm)\n* [getFieldNames](#getfieldnames)\n* [getFieldType](#getfieldtype)\n* [getFloat](#getfloat)\n* [getInt](#getint)\n* [getList](#getlist)\n* [getLong](#getlong)\n* [getObject](#getobject)\n* [getObjectId](#getobjectid)\n* [getRealmAny](#getrealmany)\n* [getRealmSet](#getrealmset)\n* [getShort](#getshort)\n* [getString](#getstring)\n* [getType](#gettype)\n* [getUUID](#getuuid)\n* [hasField](#hasfield)\n* [hashCode](#hashcode)\n* [isNull](#isnull)\n* [linkingObjects](#linkingobjects)\n* [realm$injectObjectContext](#realm-injectobjectcontext)\n* [realmGet$proxyState](#realmget-proxystate)\n* [set](#set)\n* [setBlob](#setblob)\n* [setBoolean](#setboolean)\n* [setByte](#setbyte)\n* [setDate](#setdate)\n* [setDecimal128](#setdecimal128)\n* [setDictionary](#setdictionary)\n* [setDouble](#setdouble)\n* [setFloat](#setfloat)\n* [setInt](#setint)\n* [setList](#setlist)\n* [setLong](#setlong)\n* [setNull](#setnull)\n* [setObject](#setobject)\n* [setObjectId](#setobjectid)\n* [setRealmAny](#setrealmany)\n* [setRealmSet](#setrealmset)\n* [setShort](#setshort)\n* [setString](#setstring)\n* [setUUID](#setuuid)\n* [toString](#tostring) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [io.realm.RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) io.realm.DynamicRealmObject Class that wraps a normal RealmObject in order to allow dynamic access instead of a typed interface. Using a DynamicRealmObject is slower than using the regular RealmObject class. ## Constructors\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [io.realm.RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) : `deleteFromRealm` , `deleteFromRealm` , `isValid` , `isValid` , `isFrozen` , `freeze` , `isFrozen` , `freeze` , `isLoaded` , `isLoaded` , `isManaged` , `isManaged` , `getRealm` , `getRealm` , `load` , `load` , `addChangeListener` , `addChangeListener` , `addChangeListener` , `addChangeListener` , `removeChangeListener` , `removeChangeListener` , `removeChangeListener` , `removeChangeListener` , `removeAllChangeListeners` , `removeAllChangeListeners` , `asFlowable` , `asChangesetObservable` , `asFlowable` , `asChangesetObservable` ## Constructor Detail | public [DynamicRealmObject](#std-label-io%5Frealm%5FDynamicRealmObject-1) ([RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/#std-label-io%5Frealm%5FRealmModel) obj)                                                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a dynamic Realm object based on an existing object.**Parameters**obj \\- the Realm object to convert to a dynamic object. Only objects managed by [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) can be used. | ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5FDynamicRealmObject%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                         | ### get\n\n ### getBlob | public **byte** [getBlob](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetBlob) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the byte\\[\\] value for a given field.**Parameters**fieldName \\- the name of the field.**Returns**the byte\\[\\] value.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain binary data. | ### getBoolean\n\n ### getByte | public **byte** [getByte](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetByte) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the byte value for a given field.If the field is nullable, use [isNull(String)](#std-label-io%5Frealm%5FDynamicRealmObject%5FisNull%5FString%5F) to check for null instead of using this method.**Parameters**fieldName \\- the name of the field.**Returns**the byte value.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain integers.[io.realm.exceptions.RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) \\- if the return value would be null . | ### getDate\n\n ### getDecimal128 | public **Decimal128** [getDecimal128](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetDecimal128) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the Decimal128 value for a given field.**Parameters**fieldName \\- the name of the field.**Returns**the Decimal128 value.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain Decimal128. | ### getDictionary\n\n | public [RealmDictionary](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmDictionary/#std-label-io%5Frealm%5FRealmDictionary-1) [getDictionary](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetDictionary) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [RealmDictionary](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmDictionary/#std-label-io%5Frealm%5FRealmDictionary-1) of [DynamicRealmObject](#std-label-io%5Frealm%5FDynamicRealmObject-1) s being linked from the given field.If the dictionary contains primitive types, use [getDictionary(String, Class)](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetDictionary%5FString%5F%5FClass%5F) instead.**Parameters**fieldName \\- the name of the field.**Returns**the [RealmDictionary](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmDictionary/#std-label-io%5Frealm%5FRealmDictionary-1) data for this field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain a dictionary of objects. | ### getDouble\n\n ### getDynamicRealm | public [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) [getDynamicRealm](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetDynamicRealm) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) instance where this [DynamicRealmObject](#std-label-io%5Frealm%5FDynamicRealmObject-1) belongs.You **must not** call **DynamicRealm.close()** against returned instance.**Returns**[DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) instance where this object belongs.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if this object was deleted or the corresponding [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) was already closed. | ### getFieldNames | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getFieldNames](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetFieldNames) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the list of field names on this object.**Returns**list of field names on this objects or the empty list if the object doesn't have any fields.          | ### getFieldType\n\n ### getFloat | public **float** [getFloat](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetFloat) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the float value for a given field.If the field is nullable, use [isNull(String)](#std-label-io%5Frealm%5FDynamicRealmObject%5FisNull%5FString%5F) to check for null instead of using this method.**Parameters**fieldName \\- the name of the field.**Returns**the float value.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain floats.[io.realm.exceptions.RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) \\- if the return value would be null . | ### getInt\n\n ### getList | public [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) [getList](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetList) <**E** \\>([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[java.lang.Class<E>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) primitiveType)                                                                                                                                                                                                                                                                                                                                                                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) containing only primitive values.If the list contains references to other Realm objects, use [getList(String)](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetList%5FString%5F) instead.**Parameters**fieldName \\- the name of the field.primitiveType \\- the type of elements in the list. Only primitive types are supported.**Returns**the [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) data for this field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain a list of primitive objects. |\n\n ### getLong | public **long** [getLong](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetLong) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the long value for a given field.If the field is nullable, use [isNull(String)](#std-label-io%5Frealm%5FDynamicRealmObject%5FisNull%5FString%5F) to check for null instead of using this method.**Parameters**fieldName \\- the name of the field.**Returns**the long value. Integer values exceeding Long.MAX\\_VALUE will wrap.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain integers.[io.realm.exceptions.RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) \\- if the return value would be null . | ### getObject\n\n ### getObjectId | public **ObjectId** [getObjectId](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetObjectId) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the ObjectId value for a given field.**Parameters**fieldName \\- the name of the field.**Returns**the ObjectId value.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain ObjectId. | ### getRealmAny | public [RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) [getRealmAny](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetRealmAny) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the RealmAny value for a given field.**Parameters**fieldName \\- the name of the field.**Returns**the RealmAny value.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain RealmAny. | ### getRealmSet\n\n | public [RealmSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet-1) [getRealmSet](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetRealmSet) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [RealmSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet-1) of [DynamicRealmObject](#std-label-io%5Frealm%5FDynamicRealmObject-1) s being linked from the given field.If the set contains primitive types, use [getRealmSet(String, Class)](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetRealmSet%5FString%5F%5FClass%5F) instead.**Parameters**fieldName \\- the name of the field.**Returns**the [RealmSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet-1) data for this field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain a set of objects. | ### getShort\n\n ### getString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getString](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetString) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the String value for a given field.**Parameters**fieldName \\- the name of the field.**Returns**the String value.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain Strings. | ### getType | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getType](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetType) ()                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the type of object. This will normally correspond to the name of a class that is extending [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) .**Returns**this objects type. | ### getUUID | public [UUID](https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html) [getUUID](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetUUID) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the UUID value for a given field.**Parameters**fieldName \\- the name of the field.**Returns**the UUID value.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or it doesn't contain UUID. | ### hasField | public **boolean** [hasField](#std-label-io%5Frealm%5FDynamicRealmObject%5FhasField) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)         |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks whether an object has the given field or not.**Parameters**fieldName \\- field name to check.**Returns**true if the object has a field with the given name, false otherwise. | ### hashCode\n\n ### isNull | public **boolean** [isNull](#std-label-io%5Frealm%5FDynamicRealmObject%5FisNull) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                         |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if the value of a given field is null .**Parameters**fieldName \\- the name of the field.**Returns**true if field value is null, false otherwise.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist. | ### linkingObjects\n\n ### realm$injectObjectContext | public **void** [realm$injectObjectContext](#std-label-io%5Frealm%5FDynamicRealmObject%5Frealm%5FinjectObjectContext) () |\n| ------------------------------------------------------------------------------------------------------------------------ | ### realmGet$proxyState | public [ProxyState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ProxyState/#std-label-io%5Frealm%5FProxyState-1) [realmGet$proxyState](#std-label-io%5Frealm%5FDynamicRealmObject%5FrealmGet%5FproxyState) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### set\n\n ### setBlob | public **void** [setBlob](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetBlob) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**byte\\[\\]** value)                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the binary value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a binary field. | ### setBoolean | public **void** [setBoolean](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetBoolean) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**boolean** value)                                                                                                             |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the boolean value of the given field.**Parameters**fieldName \\- field name to update.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a boolean field. | ### setByte\n\n ### setDate | public **void** [setDate](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) value)                                         |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the Date value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a Date field. | ### setDecimal128 | public **void** [setDecimal128](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetDecimal128) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** value)                                                                                                |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the Decimal128 value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a Decimal128 field. | ### setDictionary\n\n ### setDouble | public **void** [setDouble](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetDouble) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**double** value)                                                                                                    |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the double value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a double field. | ### setFloat | public **void** [setFloat](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetFloat) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**float** value)                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the float value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a float field. | ### setInt\n\n ### setList | public **void** [setList](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetList) <**E** \\>([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[io.realm.RealmList<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) list)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the reference to a [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) on the given field.This will copy all the elements in the list into Realm, but any further changes to the list will not be reflected in the Realm. Use [getList(String)](#std-label-io%5Frealm%5FDynamicRealmObject%5FgetList%5FString%5F) in order to get a reference to the managed list.**Parameters**fieldName \\- field name.list \\- list of objects. Must either be primitive types or [DynamicRealmObject](#std-label-io%5Frealm%5FDynamicRealmObject-1) s.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, it is not a list field, the objects in the list doesn't match the expected type or any Realm object in the list belongs to a different Realm. | ### setLong\n\n ### setNull | public **void** [setNull](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetNull) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                             |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the value to null for the given field.**Parameters**fieldName \\- field name.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, or the field isn't nullable.[RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) \\- if the field is a [io.realm.annotations.PrimaryKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/PrimaryKey/#std-label-io%5Frealm%5Fannotations%5FPrimaryKey) field. | ### setObject\n\n ### setObjectId | public **void** [setObjectId](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetObjectId) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the ObjectId value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a ObjectId field. | ### setRealmAny | public **void** [setRealmAny](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetRealmAny) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value)                       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the RealmAny value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a RealmAny field. | ### setRealmSet\n\n ### setShort | public **void** [setShort](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetShort) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**short** value)                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the short value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't an integer field.[RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) \\- if the field is a [io.realm.annotations.PrimaryKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/PrimaryKey/#std-label-io%5Frealm%5Fannotations%5FPrimaryKey) field. | ### setString\n\n ### setUUID | public **void** [setUUID](#std-label-io%5Frealm%5FDynamicRealmObject%5FsetUUID) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[UUID](https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html) value)                                         |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the UUID value of the given field.**Parameters**fieldName \\- field name.value \\- value to insert.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or field isn't a UUID field. | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5FDynamicRealmObject%5FtoString) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                              | ← [Interface DynamicRealm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnSuccess/ \"Previous Section\")[Enum FieldAttribute](https://mongodb.com/docs/realm/sdk/java/api/io/realm/FieldAttribute/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface OrderedRealmCollection On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [createSnapshot](#createsnapshot)\n* [deleteFirstFromRealm](#deletefirstfromrealm)\n* [deleteFromRealm](#deletefromrealm)\n* [deleteLastFromRealm](#deletelastfromrealm)\n* [first](#first)\n* [last](#last)\n* [sort](#sort) ## io.realm **Implemented interfaces:** * [java.util.List](https://docs.oracle.com/javase/7/docs/api/java/util/List.html)\n* [io.realm.RealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmCollection/#std-label-io%5Frealm%5FRealmCollection)\n* [java.util.Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)\n* [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html)\n* [java.util.Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)\n* [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html) An `OrderedRealmCollection` is a collection which maintains an ordering for its elements. Every element in the `OrderedRealmCollection` has an index. Each element can thus be accessed by its index, with the first index being zero. Normally, `OrderedRealmCollection` s allow duplicate elements, as compared to Sets, where elements have to be unique. There are three types of [OrderedRealmCollection](#std-label-io%5Frealm%5FOrderedRealmCollection) . [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) and [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) are live collections. They are up-to-date all the time and they will never contain an invalid [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . [OrderedRealmCollectionSnapshot](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) is different. An [OrderedRealmCollectionSnapshot](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) can be created from another [OrderedRealmCollection](#std-label-io%5Frealm%5FOrderedRealmCollection) . Its size and elements order stay the same as the original collection's when it was created. [OrderedRealmCollectionSnapshot](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) may contain invalid [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) s if the objects get deleted.\n\n `| RealmResults<Dog> dogs = realm.where(Dog.class).findAll();                         |\n| ---------------------------------------------------------------------------------- |\n| int s = dogs.size(); // 10                                                         |\n| realm.beginTransaction();                                                          |\n| for (Dog dog : dogs) {                                                             |\n| dog.deleteFromRealm();                                                             |\n| s = dogs.size(); // This will be decreased by 1 every time after a dog is removed. |\n| }                                                                                  |\n| realm.commitTransaction();                                                         |\n| s = dogs.size(); // 0                                                              | ` An iterator created from a live collection will create a stable view when the iterator is created, allowing you to delete and modify elements while iterating without impacting the iterator. However, the `RealmResults` backing the iterator will still be live updated meaning that size and order of elements can change when iterating. [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) has the same behaviour as [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) since they are both live collections. A simple for-loop is different. See below example: ```java RealmResults<Dog> dogs = realm.where(Dog.class).findAll(); realm.beginTransaction(); for (int i = 0; i < dogs.size(); i++) {     dogs.get(i).deleteFromRealm(); } realm.commitTransaction(); s = dogs.size(); // 5 \n```\n\n ```java RealmResults<Dog> dogs = realm.where(Dog.class).findAll(); OrderedRealmCollectionSnapshot snapshot = dogs.createSnapshot(); // dogs.size() == 10 && snapshot.size() == 10 realm.beginTransaction(); for (int i = 0; i < snapshot.size(); i++) {     snapshot.get(0).deleteFromRealm();     // snapshot.get(0).isValid() == false } realm.commitTransaction(); // dogs.size() == 0 && snapshot.size() == 10 \n``` As you can see, after deletion, the size and elements order of snapshot stay the same as before. But the element at the position becomes invalid. ## Method Summary\n\n ## Inherited Methods ## Method Detail ### createSnapshot | public [OrderedRealmCollectionSnapshot](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) [createSnapshot](#std-label-io%5Frealm%5FOrderedRealmCollection%5FcreateSnapshot) ()                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a snapshot from this [OrderedRealmCollection](#std-label-io%5Frealm%5FOrderedRealmCollection) .**Returns**the snapshot of this collection.**Throws**[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm is closed or the method is called from the wrong thread.[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if the collection is unmanaged.TipSee also: [OrderedRealmCollectionSnapshot](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) | ### deleteFirstFromRealm\n\n ### deleteFromRealm | public **void** [deleteFromRealm](#std-label-io%5Frealm%5FOrderedRealmCollection%5FdeleteFromRealm) (**int** location)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deletes the object at the given index from the Realm. This also removes it from the collection.**Parameters**location \\- the array index identifying the object to be removed.**Throws**[IndexOutOfBoundsException](https://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html) \\- if location < 0 \\|| location >= size() .[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm is closed or the method is called from the wrong thread.[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if the collection is unmanaged. | ### deleteLastFromRealm\n\n ### first | public **E** [first](#std-label-io%5Frealm%5FOrderedRealmCollection%5Ffirst) (**E** defaultValue)                                                                     |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the first object from the collection. If the collection is empty, the provided default will be used instead.**Returns**the first object or the provided default. | | public **E** [first](#std-label-io%5Frealm%5FOrderedRealmCollection%5Ffirst) ()                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Gets the first object from the collection.**Returns**the first object.**Throws**[IndexOutOfBoundsException](https://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html) \\- if the collection is empty. | ### last | public **E** [last](#std-label-io%5Frealm%5FOrderedRealmCollection%5Flast) (**E** defaultValue)                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the last object from the collection. If the collection is empty, the provided default will be used instead.**Returns**the last object or the provided default. | | public **E** [last](#std-label-io%5Frealm%5FOrderedRealmCollection%5Flast) ()                                                                                                                                                |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the last object from the collection.**Returns**the last object.**Throws**[IndexOutOfBoundsException](https://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html) \\- if the collection is empty. | ### sort\n\n\n\n | public [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) [sort](#std-label-io%5Frealm%5FOrderedRealmCollection%5Fsort) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Sort](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrder)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sorts a collection based on the provided field and sort order.**Parameters**fieldName \\- the field name to sort by. Only fields of type boolean, short, int, long, float, double, Date, and String are supported.sortOrder \\- the direction to sort by.**Returns**a new sorted [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) will be created and returned. The original collection stays unchanged.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name does not exist or has an invalid type.[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm is closed, called on the wrong thread or the collection is an unmanaged collection. |\n\n ← [Enum OrderedCollectionChangeSet.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/State/ \"Previous Section\")[Interface OrderedRealmCollectionChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionChangeListener/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/FieldAttribute/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum FieldAttribute On this page * [io.realm](#io.realm)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [INDEXED](#indexed)\n* [PRIMARY\\_KEY](#primary%5Fkey)\n* [REQUIRED](#required)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.FieldAttribute This class contains all Realm attributes for a Realm field. These will usually match the annotations found in the `io.realm.annotation` package. See the relevant annotation for further information on each modifier. ## Enum Constant Summary | Enum Constant and Description                                                                                      |\n| ------------------------------------------------------------------------------------------------------------------ |\n| [INDEXED](#std-label-io%5Frealm%5FFieldAttribute%5FINDEXED)Marks a field as indexed.                               |\n| [PRIMARY\\_KEY](#std-label-io%5Frealm%5FFieldAttribute%5FPRIMARY%5FKEY)Marks a field as a primary key.              |\n| [REQUIRED](#std-label-io%5Frealm%5FFieldAttribute%5FREQUIRED)Marks a field as explicitly not allowing null values. | ## Method Summary | Modifier and Type                                                      | Method and Description                                                                                                                       |\n| ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static [FieldAttribute](#std-label-io%5Frealm%5FFieldAttribute) | [valueOf](#std-label-io%5Frealm%5FFieldAttribute%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [FieldAttribute](#std-label-io%5Frealm%5FFieldAttribute) | [values](#std-label-io%5Frealm%5FFieldAttribute%5Fvalues) ()                                                                                 | ## Inherited Methods\n\n ## Enum Constant Detail ### `INDEXED` public static final [FieldAttribute](#std-label-io%5Frealm%5FFieldAttribute) Marks a field as indexed. ### `PRIMARY_KEY` public static final [FieldAttribute](#std-label-io%5Frealm%5FFieldAttribute) Marks a field as a primary key. This also implicitly mark it as [INDEXED](#std-label-io%5Frealm%5FFieldAttribute%5FINDEXED) . ### `REQUIRED` public static final [FieldAttribute](#std-label-io%5Frealm%5FFieldAttribute) Marks a field as explicitly not allowing null values. The default behavior for allowing `null` depends on the type of the field. ## Method Detail ### valueOf | public static [FieldAttribute](#std-label-io%5Frealm%5FFieldAttribute) [valueOf](#std-label-io%5Frealm%5FFieldAttribute%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [FieldAttribute](#std-label-io%5Frealm%5FFieldAttribute) [values](#std-label-io%5Frealm%5FFieldAttribute%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------------------------------------- | ← [Class DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/ \"Previous Section\")[Enum FrozenPendingRow](https://mongodb.com/docs/realm/sdk/java/api/io/realm/FrozenPendingRow/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/FrozenPendingRow/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum FrozenPendingRow On this page * [io.realm](#io.realm)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [INSTANCE](#instance)\n* [Method Detail](#method-detail)\n* [checkIfAttached](#checkifattached)\n* [createEmbeddedObject](#createembeddedobject)\n* [freeze](#freeze)\n* [getBinaryByteArray](#getbinarybytearray)\n* [getBoolean](#getboolean)\n* [getColumnCount](#getcolumncount)\n* [getColumnKey](#getcolumnkey)\n* [getColumnNames](#getcolumnnames)\n* [getColumnType](#getcolumntype)\n* [getDate](#getdate)\n* [getDecimal128](#getdecimal128)\n* [getDouble](#getdouble)\n* [getFloat](#getfloat)\n* [getLink](#getlink)\n* [getLong](#getlong)\n* [getModelList](#getmodellist)\n* [getModelMap](#getmodelmap)\n* [getModelSet](#getmodelset)\n* [getNativeRealmAny](#getnativerealmany)\n* [getObjectId](#getobjectid)\n* [getObjectKey](#getobjectkey)\n* [getRealmAnyMap](#getrealmanymap)\n* [getRealmAnySet](#getrealmanyset)\n* [getString](#getstring)\n* [getTable](#gettable)\n* [getUUID](#getuuid)\n* [getValueList](#getvaluelist)\n* [getValueMap](#getvaluemap)\n* [getValueSet](#getvalueset)\n* [hasColumn](#hascolumn)\n* [isLoaded](#isloaded)\n* [isNull](#isnull)\n* [isNullLink](#isnulllink)\n* [isValid](#isvalid)\n* [nullifyLink](#nullifylink)\n* [setBinaryByteArray](#setbinarybytearray)\n* [setBoolean](#setboolean)\n* [setDate](#setdate)\n* [setDecimal128](#setdecimal128)\n* [setDouble](#setdouble)\n* [setFloat](#setfloat)\n* [setLink](#setlink)\n* [setLong](#setlong)\n* [setNull](#setnull)\n* [setObjectId](#setobjectid)\n* [setRealmAny](#setrealmany)\n* [setString](#setstring)\n* [setUUID](#setuuid)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.FrozenPendingRow A PendingRow that has been frozen. This behaves in many ways similar to a deleted Row, but will report [isLoaded()](#std-label-io%5Frealm%5FFrozenPendingRow%5FisLoaded%5F%5F) as `as false` . ## Enum Constant Summary | Enum Constant and Description                                   |\n| --------------------------------------------------------------- |\n| [INSTANCE](#std-label-io%5Frealm%5FFrozenPendingRow%5FINSTANCE) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `INSTANCE` public static final [FrozenPendingRow](#std-label-io%5Frealm%5FFrozenPendingRow) ## Method Detail ### checkIfAttached | public **void** [checkIfAttached](#std-label-io%5Frealm%5FFrozenPendingRow%5FcheckIfAttached) () |\n| ------------------------------------------------------------------------------------------------ | ### createEmbeddedObject | public **long** [createEmbeddedObject](#std-label-io%5Frealm%5FFrozenPendingRow%5FcreateEmbeddedObject) (**long** columnKey,[RealmFieldType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmFieldType/#std-label-io%5Frealm%5FRealmFieldType) parentPropertyType) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### freeze | public **Row** [freeze](#std-label-io%5Frealm%5FFrozenPendingRow%5Ffreeze) (**OsSharedRealm** frozenRealm) |\n| ---------------------------------------------------------------------------------------------------------- | ### getBinaryByteArray | public **byte** [getBinaryByteArray](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetBinaryByteArray) (**long** columnKey) |\n| ------------------------------------------------------------------------------------------------------------------------ | ### getBoolean | public **boolean** [getBoolean](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetBoolean) (**long** columnKey) |\n| ----------------------------------------------------------------------------------------------------------- | ### getColumnCount | public **long** [getColumnCount](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetColumnCount) () |\n| ---------------------------------------------------------------------------------------------- | ### getColumnKey | public **long** [getColumnKey](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetColumnKey) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) columnName) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### getColumnNames | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getColumnNames](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetColumnNames) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getColumnType | public [RealmFieldType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmFieldType/#std-label-io%5Frealm%5FRealmFieldType) [getColumnType](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetColumnType) (**long** columnKey) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getDate | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [getDate](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetDate) (**long** columnKey) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getDecimal128 | public **Decimal128** [getDecimal128](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetDecimal128) (**long** columnKey) |\n| -------------------------------------------------------------------------------------------------------------------- | ### getDouble\n\n ### getFloat | public **float** [getFloat](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetFloat) (**long** columnKey) |\n| ----------------------------------------------------------------------------------------------------- | ### getLink | public **long** [getLink](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetLink) (**long** columnKey) |\n| -------------------------------------------------------------------------------------------------- | ### getLong | public **long** [getLong](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetLong) (**long** columnKey) |\n| -------------------------------------------------------------------------------------------------- | ### getModelList | public **OsList** [getModelList](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetModelList) (**long** columnKey) |\n| -------------------------------------------------------------------------------------------------------------- | ### getModelMap | public **OsMap** [getModelMap](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetModelMap) (**long** columnKey) |\n| ----------------------------------------------------------------------------------------------------------- | ### getModelSet | public **OsSet** [getModelSet](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetModelSet) (**long** columnKey) |\n| ----------------------------------------------------------------------------------------------------------- | ### getNativeRealmAny | public **NativeRealmAny** [getNativeRealmAny](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetNativeRealmAny) (**long** columnKey) |\n| -------------------------------------------------------------------------------------------------------------------------------- | ### getObjectId | public **ObjectId** [getObjectId](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetObjectId) (**long** columnKey) |\n| -------------------------------------------------------------------------------------------------------------- | ### getObjectKey | public **long** [getObjectKey](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetObjectKey) () |\n| ------------------------------------------------------------------------------------------ | ### getRealmAnyMap | public **OsMap** [getRealmAnyMap](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetRealmAnyMap) (**long** columnKey) |\n| ----------------------------------------------------------------------------------------------------------------- | ### getRealmAnySet | public **OsSet** [getRealmAnySet](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetRealmAnySet) (**long** columnKey) |\n| ----------------------------------------------------------------------------------------------------------------- | ### getString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getString](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetString) (**long** columnKey) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getTable | public **Table** [getTable](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetTable) () |\n| ----------------------------------------------------------------------------------- | ### getUUID | public [UUID](https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html) [getUUID](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetUUID) (**long** columnKey) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getValueList | public **OsList** [getValueList](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetValueList) (**long** columnKey,[RealmFieldType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmFieldType/#std-label-io%5Frealm%5FRealmFieldType) fieldType) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getValueMap\n\n ### getValueSet | public **OsSet** [getValueSet](#std-label-io%5Frealm%5FFrozenPendingRow%5FgetValueSet) (**long** columnKey,[RealmFieldType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmFieldType/#std-label-io%5Frealm%5FRealmFieldType) fieldType) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### hasColumn | public **boolean** [hasColumn](#std-label-io%5Frealm%5FFrozenPendingRow%5FhasColumn) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### isLoaded | public **boolean** [isLoaded](#std-label-io%5Frealm%5FFrozenPendingRow%5FisLoaded) () |\n| ------------------------------------------------------------------------------------- | ### isNull | public **boolean** [isNull](#std-label-io%5Frealm%5FFrozenPendingRow%5FisNull) (**long** columnKey) |\n| --------------------------------------------------------------------------------------------------- | ### isNullLink | public **boolean** [isNullLink](#std-label-io%5Frealm%5FFrozenPendingRow%5FisNullLink) (**long** columnKey) |\n| ----------------------------------------------------------------------------------------------------------- | ### isValid | public **boolean** [isValid](#std-label-io%5Frealm%5FFrozenPendingRow%5FisValid) () |\n| ----------------------------------------------------------------------------------- | ### nullifyLink | public **void** [nullifyLink](#std-label-io%5Frealm%5FFrozenPendingRow%5FnullifyLink) (**long** columnKey) |\n| ---------------------------------------------------------------------------------------------------------- | ### setBinaryByteArray | public **void** [setBinaryByteArray](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetBinaryByteArray) (**long** columnKey,**byte\\[\\]** data) |\n| ------------------------------------------------------------------------------------------------------------------------------------------ | ### setBoolean | public **void** [setBoolean](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetBoolean) (**long** columnKey,**boolean** value) |\n| -------------------------------------------------------------------------------------------------------------------------- | ### setDate | public **void** [setDate](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetDate) (**long** columnKey,[Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) date) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### setDecimal128 | public **void** [setDecimal128](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetDecimal128) (**long** columnKey,**Decimal128** value) |\n| ----------------------------------------------------------------------------------------------------------------------------------- | ### setDouble | public **void** [setDouble](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetDouble) (**long** columnKey,**double** value) |\n| ----------------------------------------------------------------------------------------------------------------------- | ### setFloat | public **void** [setFloat](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetFloat) (**long** columnKey,**float** value) |\n| -------------------------------------------------------------------------------------------------------------------- | ### setLink | public **void** [setLink](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetLink) (**long** columnKey,**long** value) |\n| ----------------------------------------------------------------------------------------------------------------- | ### setLong | public **void** [setLong](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetLong) (**long** columnKey,**long** value) |\n| ----------------------------------------------------------------------------------------------------------------- | ### setNull | public **void** [setNull](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetNull) (**long** columnKey) |\n| -------------------------------------------------------------------------------------------------- | ### setObjectId\n\n ### setRealmAny | public **void** [setRealmAny](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetRealmAny) (**long** columnKey,**long** value) |\n| ------------------------------------------------------------------------------------------------------------------------- | ### setString | public **void** [setString](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetString) (**long** columnKey,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### setUUID | public **void** [setUUID](#std-label-io%5Frealm%5FFrozenPendingRow%5FsetUUID) (**long** columnKey,[UUID](https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html) value) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### valueOf | public static [FrozenPendingRow](#std-label-io%5Frealm%5FFrozenPendingRow) [valueOf](#std-label-io%5Frealm%5FFrozenPendingRow%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [FrozenPendingRow](#std-label-io%5Frealm%5FFrozenPendingRow) [values](#std-label-io%5Frealm%5FFrozenPendingRow%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------- | ← [Enum FieldAttribute](https://mongodb.com/docs/realm/sdk/java/api/io/realm/FieldAttribute/ \"Previous Section\")[Enum ImportFlag](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ImportFlag/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmModel On this page * [io.realm](#io.realm) ## io.realm Interface for marking classes as RealmObjects, it can be used instead of extending [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . All helper methods available to classes that extend RealmObject are instead available as static methods: `| Person p = realm.createObject(Person.class); |\n| -------------------------------------------- |\n| // With the RealmModel interface             |\n| RealmObject.isValid(p);                      |\n| // With the RealmObject base class           |\n| p.isValid();                                 | ` Note: Object implementing this interface needs also to be annotated with [RealmClass](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/#std-label-io%5Frealm%5Fannotations%5FRealmClass) , so the annotation processor can generate the underlining proxy class. ## Tip ### See also:  * [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) ← [Interface RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/ \"Previous Section\")[Class RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAnyOperator/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmAnyOperator On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [checkValidObject](#checkvalidobject)\n* [createNativeRealmAny](#createnativerealmany) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmAnyOperator ## Method Summary | Modifier and Type                     | Method and Description                                                                                |\n| ------------------------------------- | ----------------------------------------------------------------------------------------------------- |\n| public **void**                       | [checkValidObject](#std-label-io%5Frealm%5FRealmAnyOperator%5FcheckValidObject) (**BaseRealm** realm) |\n| protected abstract **NativeRealmAny** | [createNativeRealmAny](#std-label-io%5Frealm%5FRealmAnyOperator%5FcreateNativeRealmAny) ()            | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### checkValidObject | public **void** [checkValidObject](#std-label-io%5Frealm%5FRealmAnyOperator%5FcheckValidObject) (**BaseRealm** realm) |\n| --------------------------------------------------------------------------------------------------------------------- | ### createNativeRealmAny | protected abstract **NativeRealmAny** [createNativeRealmAny](#std-label-io%5Frealm%5FRealmAnyOperator%5FcreateNativeRealmAny) () |\n| -------------------------------------------------------------------------------------------------------------------------------- | ← [Class RealmAnyNativeFunctionsImpl](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAnyNativeFunctionsImpl/ \"Previous Section\")[Interface RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/ImportFlag/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum ImportFlag On this page * [io.realm](#io.realm)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [CHECK\\_SAME\\_VALUES\\_BEFORE\\_SET](#check%5Fsame%5Fvalues%5Fbefore%5Fset)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.ImportFlag This class describe how data is saved to Realm when saving whole objects. ## Tip ### See also:  * [Realm.copyToRealm(RealmModel, ImportFlag...)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcopyToRealm%5FRealmModel%5F%5FImportFlag%5F%5F%5F%5F) ## Enum Constant Summary | Enum Constant and Description                                                                                                                                                                                                                               |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [CHECK\\_SAME\\_VALUES\\_BEFORE\\_SET](#std-label-io%5Frealm%5FImportFlag%5FCHECK%5FSAME%5FVALUES%5FBEFORE%5FSET)With this flag enabled, fields will not be written to the Realm file if they contain the same value as the value already present in the Realm. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `CHECK_SAME_VALUES_BEFORE_SET` public static final [ImportFlag](#std-label-io%5Frealm%5FImportFlag) With this flag enabled, fields will not be written to the Realm file if they contain the same value as the value already present in the Realm.For local Realms this only has an impact on change listeners which will not report changes to those fields that were not written. For synchronized Realms this also impacts the server, which will see improved performance as there are fewer changes to upload and merge into the server Realm. It also impacts how the server merges changes from different devices. Realm uses a last-write-wins approach when merging individual fields in an object, so if a field is not written it will be considered \"older\" than other fields modified. E.g: 1. Server starts out with (Field A = 1, Field B = 1)\n2. Device 1 writes (Field A = 2, Field B = 2).\n3. Device 2 writes (Field A = 3, Field B = 1) but ignores (Field B = 1), because that is the value in the Realm file at this point.\n4. Device 1 uploads its changes to the server making the server (Field A = 2, Field B = 2). Then Device 2 uploads its changes. Due to last-write-wins, the server version now becomes (Field A = 3, Field B = 2). This is normally the desired behavior as the final object is the merged result of the latest changes from both devices, however if all the fields in an object are considered an atomic unit, then this flag should not be set as it will ensure that all fields are set and thus have the same \"age\" when data are sent to the server. ## Method Detail ### valueOf | public static [ImportFlag](#std-label-io%5Frealm%5FImportFlag) [valueOf](#std-label-io%5Frealm%5FImportFlag%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [ImportFlag](#std-label-io%5Frealm%5FImportFlag) [values](#std-label-io%5Frealm%5FImportFlag%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------------------------- | ← [Enum FrozenPendingRow](https://mongodb.com/docs/realm/sdk/java/api/io/realm/FrozenPendingRow/ \"Previous Section\")[Interface MapChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/MapChangeListener/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmMap On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [addChangeListener](#addchangelistener)\n* [clear](#clear)\n* [containsKey](#containskey)\n* [containsValue](#containsvalue)\n* [entrySet](#entryset)\n* [freeze](#freeze)\n* [get](#get)\n* [isEmpty](#isempty)\n* [isFrozen](#isfrozen)\n* [isManaged](#ismanaged)\n* [isValid](#isvalid)\n* [keySet](#keyset)\n* [put](#put)\n* [putAll](#putall)\n* [remove](#remove)\n* [removeAllChangeListeners](#removeallchangelisteners)\n* [removeChangeListener](#removechangelistener)\n* [size](#size)\n* [values](#values) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmMap **Implemented interfaces:** * [java.util.Map](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) RealmMap is used to map keys to values. A RealmMap cannot contain duplicate keys and each key can map to at most one value. A RealmMap cannot have `null` keys but can have `null` values. Similarly to [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) s, a RealmDictionary can operate in managed and unmanaged modes. In managed mode a RealmDictionary persists all its contents inside a Realm whereas in unmanaged mode it functions like a [HashMap](https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html) . Managed RealmDictionaries can only be created by Realm and will automatically update its content whenever the underlying Realm is updated. Managed RealmDictionaries can only be accessed using the getter that points to a RealmDictionary field of a [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . Unmanaged RealmDictionaries can be created by the user and can contain both managed and unmanaged RealmObjects. This is useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class. Unmanaged RealmMaps can be added to a Realm using the [Realm.copyToRealm(Iterable, ImportFlag...)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcopyToRealm%5FIterable%5F%5FImportFlag%5F%5F%5F%5F) method. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### addChangeListener\n\n\n\n ### clear | public **void** [clear](#std-label-io%5Frealm%5FRealmMap%5Fclear) () |\n| -------------------------------------------------------------------- | ### containsKey | public **boolean** [containsKey](#std-label-io%5Frealm%5FRealmMap%5FcontainsKey) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) key) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### containsValue | public **boolean** [containsValue](#std-label-io%5Frealm%5FRealmMap%5FcontainsValue) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) value) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### entrySet | public [Set](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html) [entrySet](#std-label-io%5Frealm%5FRealmMap%5FentrySet) () |\n| ------------------------------------------------------------------------------------------------------------------------------------- | ### freeze | public [RealmMap](#std-label-io%5Frealm%5FRealmMap) [freeze](#std-label-io%5Frealm%5FRealmMap%5Ffreeze) () |\n| ---------------------------------------------------------------------------------------------------------- | ### get | public **V** [get](#std-label-io%5Frealm%5FRealmMap%5Fget) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) key) |\n| ------------------------------------------------------------------------------------------------------------------------------------------ | ### isEmpty | public **boolean** [isEmpty](#std-label-io%5Frealm%5FRealmMap%5FisEmpty) () |\n| --------------------------------------------------------------------------- | ### isFrozen | public **boolean** [isFrozen](#std-label-io%5Frealm%5FRealmMap%5FisFrozen) () |\n| ----------------------------------------------------------------------------- | ### isManaged | public **boolean** [isManaged](#std-label-io%5Frealm%5FRealmMap%5FisManaged) () |\n| ------------------------------------------------------------------------------- | ### isValid | public **boolean** [isValid](#std-label-io%5Frealm%5FRealmMap%5FisValid) () |\n| --------------------------------------------------------------------------- | ### keySet | public [Set](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html) [keySet](#std-label-io%5Frealm%5FRealmMap%5FkeySet) () |\n| --------------------------------------------------------------------------------------------------------------------------------- | ### put | public **V** [put](#std-label-io%5Frealm%5FRealmMap%5Fput) (**K** key,**V** value) |\n| ---------------------------------------------------------------------------------- | ### putAll | public **void** [putAll](#std-label-io%5Frealm%5FRealmMap%5FputAll) ([java.util.Map<? extends K, ? extends V>](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) m) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### remove | public **V** [remove](#std-label-io%5Frealm%5FRealmMap%5Fremove) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) key) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------ | ### removeAllChangeListeners\n\n ### removeChangeListener | public **void** [removeChangeListener](#std-label-io%5Frealm%5FRealmMap%5FremoveChangeListener) ([io.realm.RealmChangeListener<io.realm.RealmMap<K, V>>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) listener)                                                                                                                                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes the specified change listener.**Parameters**listener \\- the change listener to be removed.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the change listener is null .[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove a listener from a non-Looper Thread.TipSee also: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) |\n\n ### size | public **int** [size](#std-label-io%5Frealm%5FRealmMap%5Fsize) () |\n| ----------------------------------------------------------------- | ### values | public [Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) [values](#std-label-io%5Frealm%5FRealmMap%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/ \"Previous Section\")[Interface RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/MutableRealmInteger/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class MutableRealmInteger On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [compareTo](#compareto)\n* [decrement](#decrement)\n* [equals](#equals)\n* [get](#get)\n* [hashCode](#hashcode)\n* [increment](#increment)\n* [isNull](#isnull)\n* [ofNull](#ofnull)\n* [set](#set)\n* [valueOf](#valueof) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.MutableRealmInteger **Implemented interfaces:** * [java.lang.Comparable](https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html) A `MutableRealmInteger` is a mutable, [Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) \\-like numeric quantity. It behaves almost exactly as a reference to a [Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) . More specifically: * A `MutableRealmInteger` may have the value `null` .\n* The [equals](#std-label-io%5Frealm%5FMutableRealmInteger%5Fequals) operator compares the contained [Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) values. `null` \\-valued `MutableRealmInteger` are `.equals`\n* The [compareTo](#std-label-io%5Frealm%5FMutableRealmInteger%5FcompareTo) operator compares the contained [Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) values. It considers `null` < any non-`null` value.\n* The [increment](#std-label-io%5Frealm%5FMutableRealmInteger%5Fincrement) and [decrement](#std-label-io%5Frealm%5FMutableRealmInteger%5Fdecrement) operators throw [IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) when applied to a `null` \\-valued `MutableRealmInteger` . `MutableRealmInteger` s are most interesting as members of a managed [RealmModel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmModel/#std-label-io%5Frealm%5FRealmModel) object. When managed, the [increment](#std-label-io%5Frealm%5FMutableRealmInteger%5Fincrement) and [decrement](#std-label-io%5Frealm%5FMutableRealmInteger%5Fdecrement) operators implement a [conflict free replicated data type](https://en.wikipedia.org/wiki/Conflict-free%5Freplicated%5Fdata%5Ftype) : Simultaneous increments and decrements from multiple distributed clients will be aggregated correctly. For instance, if the value of `counter` field for the object representing user \"Fred\" is currently 0, then the following code, executed on two different devices, simultaneously, even if connected by only a slow, unreliable network, will **always** cause the value of `counter` to converge, eventually on the value 2.\n\n ` Note that the [set(Long)](#std-label-io%5Frealm%5FMutableRealmInteger%5Fset%5FLong%5F) operator must be used with extreme care. It will quash the effects of any prior calls to [increment(long)](#std-label-io%5Frealm%5FMutableRealmInteger%5Fincrement%5Flong%5F) or [decrement(long)](#std-label-io%5Frealm%5FMutableRealmInteger%5Fdecrement%5Flong%5F) . Although the value of a `MutableRealmInteger` will always converge across devices, the specific value on which it converges will depend on the actual order in which operations took place. Mixing [set(Long)](#std-label-io%5Frealm%5FMutableRealmInteger%5Fset%5FLong%5F) with [increment(long)](#std-label-io%5Frealm%5FMutableRealmInteger%5Fincrement%5Flong%5F) and [decrement(long)](#std-label-io%5Frealm%5FMutableRealmInteger%5Fdecrement%5Flong%5F) is, therefore, not advised, unless fuzzy counting is acceptable. `MutableRealmInteger` s may not be primary keys. Their implementations are not thread safe. Like all managed Realm objects, managed `MutableRealmInteger` s may not be moved across threads. Unmanaged `MutableRealmInteger` s may be moved across threads but require safe publication. A `MutableRealmInteger` , in a model class, must always be declared `final` . For instance: `public final MutableRealmInteger counter = MutableRealmInteger.ofNull();` Although initializing the `MutableRealmInteger` as `null` may work very limited circumstances, developers are advised **not** to do it: ```java public final MutableRealmInteger counter = null; // DO NOT DO THIS! \n``` Also note that when a `MutableRealmInteger` is `@Required` , it is better, though not required, to initialize it with a non-null value. @Required public final MutableRealmInteger counter = MutableRealmInteger.valueOf(0L); A reference to a managed `MutableRealmInteger` is subject to all of the constraints that apply to the model object from which it was obtained: It can only be mutated within a transaction and it becomes invalid if the Realm backing it is closed. Use the `isManaged()` and `isValid()` operators to determine whether a `MutableRealmInteger` is in a consistent state. Note, in particular, that a reference to a managed `MutableRealmInteger` retains a reference to the model object to which it belongs. For example in this code: `MutableRealmInteger counter = realm.where(Users.class).findFirst().counter;` the `counter` holds a reference to the `User` model object from which it was obtained. Neither can be GCed until all references to both are unreachable. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### compareTo | public final **int** [compareTo](#std-label-io%5Frealm%5FMutableRealmInteger%5FcompareTo) ([MutableRealmInteger](#std-label-io%5Frealm%5FMutableRealmInteger) o)                                                                                                        |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| MutableRealmInteger s compare strictly by their values. Null is a legal value for a MutableRealmInteger and null < any non-null value**Parameters**o \\- the compare target**Returns**\\-1, 0, or 1, depending on whether this object's value is <, =, or > the target's. | ### decrement | public abstract **void** [decrement](#std-label-io%5Frealm%5FMutableRealmInteger%5Fdecrement) (**long** dec)                                                                                                                                                   |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Decrements the MutableRealmInteger , subtracting the value of the argument. Increment/decrement from all devices are reflected in the new value, which is guaranteed to converge.**Parameters**dec \\- quantity to be subtracted from the MutableRealmInteger . | ### equals | public final **boolean** [equals](#std-label-io%5Frealm%5FMutableRealmInteger%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o)                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Two MutableRealmInteger s are .equals if and only if their longValues are equal.**Parameters**o \\- compare target**Returns**true if the target has the same value.**Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### get\n\n ### hashCode | public final **int** [hashCode](#std-label-io%5Frealm%5FMutableRealmInteger%5FhashCode) ()                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| A MutableRealmInteger 's hash code is, exactly, the hash code of its value.**Returns**true if the target has the same value.**Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### increment | public abstract **void** [increment](#std-label-io%5Frealm%5FMutableRealmInteger%5Fincrement) (**long** inc)                                                                                                                                       |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Increments the MutableRealmInteger , adding the value of the argument. Increment/decrement from all devices are reflected in the new value, which is guaranteed to converge.**Parameters**inc \\- quantity to be added to the MutableRealmInteger . | ### isNull | public final **boolean** [isNull](#std-label-io%5Frealm%5FMutableRealmInteger%5FisNull) ()                 |\n| ---------------------------------------------------------------------------------------------------------- |\n| **Returns**true if and only if [get](#std-label-io%5Frealm%5FMutableRealmInteger%5Fget) will return null . | ### ofNull | public static [MutableRealmInteger](#std-label-io%5Frealm%5FMutableRealmInteger) [ofNull](#std-label-io%5Frealm%5FMutableRealmInteger%5FofNull) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new, unmanaged MutableRealmInteger whose value is null .                                                                                 | ### set\n\n | public abstract **void** [set](#std-label-io%5Frealm%5FMutableRealmInteger%5Fset) ([Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) newValue)                                                                                                                                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets the MutableRealmInteger value. Calling set forcibly sets the MutableRealmInteger to the provided value. Doing this obliterates the effects of any calls to [increment](#std-label-io%5Frealm%5FMutableRealmInteger%5Fincrement) and [decrement](#std-label-io%5Frealm%5FMutableRealmInteger%5Fdecrement) perceived before the call to set .**Parameters**newValue \\- new value. | ### valueOf | public static [MutableRealmInteger](#std-label-io%5Frealm%5FMutableRealmInteger) [valueOf](#std-label-io%5Frealm%5FMutableRealmInteger%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new, unmanaged MutableRealmInteger with the specified initial value.**Parameters**value \\- initial value: parsed by [Long.parseLong](https://docs.oracle.com/javase/7/docs/api/java/lang/Long/parseLong.html) .           | | public static [MutableRealmInteger](#std-label-io%5Frealm%5FMutableRealmInteger) [valueOf](#std-label-io%5Frealm%5FMutableRealmInteger%5FvalueOf) (**long** value) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a new, unmanaged MutableRealmInteger with the specified initial value.**Parameters**value \\- initial value.                                                | | public static [MutableRealmInteger](#std-label-io%5Frealm%5FMutableRealmInteger) [valueOf](#std-label-io%5Frealm%5FMutableRealmInteger%5FvalueOf) ([Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) value) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a new, unmanaged MutableRealmInteger with the specified initial value.**Parameters**value \\- initial value.                                                                                                             |\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.coroutines   \n* [io.realm.coroutines.FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory)\n* [io.realm.coroutines.RealmFlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/RealmFlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory-1) ← [Annotation Type Required](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Required/ \"Previous Section\")[Interface FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/CompactOnLaunchCallback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface CompactOnLaunchCallback On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [shouldCompact](#shouldcompact) ## io.realm This interface is used to determine if a Realm file should be compacted the first time the file is opened and before the instance is returned.Note that compacting a file can take a while, so compacting should generally only be done on a background thread or when used in combination with [Realm.getInstanceAsync(RealmConfiguration, io.realm.Realm.Callback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FgetInstanceAsync%5FRealmConfiguration%5F%5Fio%5Frealm%5FRealm%5FCallback%5F) . ## Method Summary | Modifier and Type  | Method and Description                                                                                                                                                                                                        |\n| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **boolean** | [shouldCompact](#std-label-io%5Frealm%5FCompactOnLaunchCallback%5FshouldCompact) (**long** totalBytes,**long** usedBytes)This method determines if the Realm file should be compacted before opened and returned to the user. | ## Method Detail ### shouldCompact\n\n ← [Class CollectionUtils](https://mongodb.com/docs/realm/sdk/java/api/io/realm/CollectionUtils/ \"Previous Section\")[Class DefaultCompactOnLaunchCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DefaultCompactOnLaunchCallback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmList On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [baseRealm](#baserealm)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [add](#add)\n* [addChangeListener](#addchangelistener)\n* [asChangesetObservable](#aschangesetobservable)\n* [asFlowable](#asflowable)\n* [average](#average)\n* [clear](#clear)\n* [contains](#contains)\n* [createSnapshot](#createsnapshot)\n* [deleteAllFromRealm](#deleteallfromrealm)\n* [deleteFirstFromRealm](#deletefirstfromrealm)\n* [deleteFromRealm](#deletefromrealm)\n* [deleteLastFromRealm](#deletelastfromrealm)\n* [first](#first)\n* [freeze](#freeze)\n* [get](#get)\n* [getRealm](#getrealm)\n* [isFrozen](#isfrozen)\n* [isLoaded](#isloaded)\n* [isManaged](#ismanaged)\n* [isValid](#isvalid)\n* [iterator](#iterator)\n* [last](#last)\n* [listIterator](#listiterator)\n* [load](#load)\n* [max](#max)\n* [maxDate](#maxdate)\n* [min](#min)\n* [minDate](#mindate)\n* [move](#move)\n* [remove](#remove)\n* [removeAll](#removeall)\n* [removeAllChangeListeners](#removeallchangelisteners)\n* [removeChangeListener](#removechangelistener)\n* [set](#set)\n* [size](#size)\n* [sort](#sort)\n* [sum](#sum)\n* [toString](#tostring)\n* [where](#where) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.util.AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html) [java.util.AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html) io.realm.RealmList **Implemented interfaces:** * [io.realm.OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection)\n* [java.util.List](https://docs.oracle.com/javase/7/docs/api/java/util/List.html)\n* [io.realm.RealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmCollection/#std-label-io%5Frealm%5FRealmCollection)\n* [java.util.Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)\n* [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html)\n* [java.util.Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)\n* [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html)\n\n Only Realm can create managed RealmLists. Managed RealmLists will automatically update the content whenever the underlying Realm is updated, and can only be accessed using the getter of a [io.realm.RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . Unmanaged RealmLists can be created by the user and can contain both managed and unmanaged RealmObjects. This is useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class. Unmanaged elements in this list can be added to a Realm using the [Realm.copyToRealm(Iterable, ImportFlag...)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcopyToRealm%5FIterable%5F%5FImportFlag%5F%5F%5F%5F) method. [RealmList](#std-label-io%5Frealm%5FRealmList-1) can contain more elements than `Integer.MAX_VALUE` . In that case, you can access only first `Integer.MAX_VALUE` elements in it. ## Constructors | Constructor and Description                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------- |\n| [RealmList](#std-label-io%5Frealm%5FRealmList-1) ()Creates a RealmList in unmanaged mode, where the elements are not controlled by a Realm. |\n| [RealmList](#std-label-io%5Frealm%5FRealmList-1) (**E\\[\\]** objects)Creates a RealmList in unmanaged mode with an initial list of elements. | ## Field Summary | Modifier and Type          | Field and Description                                                                                                                                                                           |\n| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public final **BaseRealm** | [baseRealm](#std-label-io%5Frealm%5FRealmList%5FbaseRealm)The **BaseRealm** instance in which this list resides.Warning: This field is only exposed for internal usage, and should not be used. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.util.AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html) : `iterator` , `size` , `isEmpty` , `contains` , `toArray` , `toArray` , `add` , `remove` , `containsAll` , `addAll` , `removeAll` , `retainAll` , `clear` , `toString`\n* Methods inherited from class [java.util.AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html) : `add` , `get` , `set` , `add` , `remove` , `indexOf` , `lastIndexOf` , `clear` , `addAll` , `iterator` , `listIterator` , `listIterator` , `subList` , `equals` , `hashCode` , `removeRange` ## Field Detail ### `baseRealm` The **BaseRealm** instance in which this list resides. Warning: This field is only exposed for internal usage, and should not be used. ## Constructor Detail\n\n | public [RealmList](#std-label-io%5Frealm%5FRealmList-1) (**E\\[\\]** objects)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a RealmList in unmanaged mode with an initial list of elements. A RealmList in unmanaged mode function as a [java.util.ArrayList](https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html) and it is not possible to query the objects in this state.Use [io.realm.Realm.copyToRealm(Iterable, ImportFlag...)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcopyToRealm%5FIterable%5F%5FImportFlag%5F%5F%5F%5F) to properly persist all unmanaged elements in Realm.**Parameters**objects \\- initial objects in the list. | ## Method Detail ### add\n\n\n\n ### addChangeListener\n\n\n\n ### asChangesetObservable\n\n ### asFlowable\n\n ### average | public **double** [average](#std-label-io%5Frealm%5FRealmList%5Faverage) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the average of a given field.**Returns**the average for the given field amongst objects in query results. This will be of type double for all types of number fields. If no objects exist or they all have null as the value for the given field, 0 will be returned. When computing the average, objects with null values are ignored. | ### clear\n\n ### contains | public **boolean** [contains](#std-label-io%5Frealm%5FRealmList%5Fcontains) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) object)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns true if the list contains the specified element when attached to a Realm. This method will query the native Realm underlying storage engine to quickly find the specified element.If the list is not attached to a Realm, the default [List.contains(Object)](https://docs.oracle.com/javase/7/docs/api/java/util/List/contains%28Object%29.html) implementation will occur.**Parameters**object \\- the element whose presence in this list is to be tested.**Returns**true if this list contains the specified element otherwise false .**Overrides**contains in class [AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html) | ### createSnapshot | public [OrderedRealmCollectionSnapshot](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) [createSnapshot](#std-label-io%5Frealm%5FRealmList%5FcreateSnapshot) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a snapshot from this [OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection) .**Returns**the snapshot of this collection.                              | ### deleteAllFromRealm\n\n ### deleteFirstFromRealm | public **boolean** [deleteFirstFromRealm](#std-label-io%5Frealm%5FRealmList%5FdeleteFirstFromRealm) ()                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deletes the first object from the Realm. This also removes it from this collection.**Returns**true if an object was deleted, false otherwise. | ### deleteFromRealm | public **void** [deleteFromRealm](#std-label-io%5Frealm%5FRealmList%5FdeleteFromRealm) (**int** location) |\n| --------------------------------------------------------------------------------------------------------- |\n| Deletes the object at the given index from the Realm. This also removes it from the collection.           | ### deleteLastFromRealm | public **boolean** [deleteLastFromRealm](#std-label-io%5Frealm%5FRealmList%5FdeleteLastFromRealm) ()                                         |\n| -------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deletes the last object from the Realm. This also removes it from this collection.**Returns**true if an object was deleted, false otherwise. | ### first | public **E** [first](#std-label-io%5Frealm%5FRealmList%5Ffirst) (**E** defaultValue)                                                                                  |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the first object from the collection. If the collection is empty, the provided default will be used instead.**Returns**the first object or the provided default. | | public **E** [first](#std-label-io%5Frealm%5FRealmList%5Ffirst) ()     |\n| ---------------------------------------------------------------------- |\n| Gets the first object from the collection.**Returns**the first object. | ### freeze | public [RealmList](#std-label-io%5Frealm%5FRealmList-1) [freeze](#std-label-io%5Frealm%5FRealmList%5Ffreeze) () |\n| --------------------------------------------------------------------------------------------------------------- | ### get\n\n ### getRealm\n\n ### isFrozen | public **boolean** [isFrozen](#std-label-io%5Frealm%5FRealmList%5FisFrozen) () |\n| ------------------------------------------------------------------------------ | ### isLoaded | public **boolean** [isLoaded](#std-label-io%5Frealm%5FRealmList%5FisLoaded) ()                                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if a collection has finished loading its data yet.**Returns**true if data has been loaded and is available, false if data is still being loaded. | ### isManaged\n\n ### isValid | public **boolean** [isValid](#std-label-io%5Frealm%5FRealmList%5FisValid) ()                                                                                                                                                                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Checks if the collection is still valid to use, i.e., the [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) instance hasn't been closed. It will always return true for an unmanaged collection.**Returns**true if it is still valid to use or an unmanaged collection, false otherwise. | ### iterator | public [Iterator](https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html) [iterator](#std-label-io%5Frealm%5FRealmList%5Fiterator) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Overrides**iterator in class [AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html)                             | ### last | public **E** [last](#std-label-io%5Frealm%5FRealmList%5Flast) (**E** defaultValue)                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the last object from the collection. If the collection is empty, the provided default will be used instead.**Returns**the last object or the provided default. | | public **E** [last](#std-label-io%5Frealm%5FRealmList%5Flast) ()     |\n| -------------------------------------------------------------------- |\n| Gets the last object from the collection.**Returns**the last object. | ### listIterator | public [ListIterator](https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html) [listIterator](#std-label-io%5Frealm%5FRealmList%5FlistIterator) (**int** location) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**listIterator in class [AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html)                                                         |\n\n ### load | public **boolean** [load](#std-label-io%5Frealm%5FRealmList%5Fload) ()                                                        |\n| ----------------------------------------------------------------------------------------------------------------------------- |\n| Blocks the collection until all data are available.**Returns**true if the data could be successfully loaded, false otherwise. | ### max | public [Number](https://docs.oracle.com/javase/7/docs/api/java/lang/Number.html) [max](#std-label-io%5Frealm%5FRealmList%5Fmax) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the maximum value of a field.**Returns**if no objects exist or they all have null as the value for the given field, null will be returned. Otherwise the maximum value is returned. When determining the maximum value, objects with null values are ignored. | ### maxDate | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [maxDate](#std-label-io%5Frealm%5FRealmList%5FmaxDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                  |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the maximum date.**Returns**if no objects exist or they all have null as the value for the given date field, null will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with null values are ignored. | ### min | public [Number](https://docs.oracle.com/javase/7/docs/api/java/lang/Number.html) [min](#std-label-io%5Frealm%5FRealmList%5Fmin) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the minimum value of a field.**Returns**if no objects exist or they all have null as the value for the given field, null will be returned. Otherwise the minimum value is returned. When determining the minimum value, objects with null values are ignored. | ### minDate | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [minDate](#std-label-io%5Frealm%5FRealmList%5FminDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                  |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the minimum date.**Returns**if no objects exist or they all have null as the value for the given date field, null will be returned. Otherwise the minimum date is returned. When determining the minimum date, objects with null values are ignored. | ### move\n\n ### remove\n\n | public **E** [remove](#std-label-io%5Frealm%5FRealmList%5Fremove) (**int** location)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes the object at the specified location from this list.**Parameters**location \\- the index of the object to remove.**Returns**the removed object.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if Realm instance has been closed or parent object has been removed.[IndexOutOfBoundsException](https://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html) \\- if location < 0 \\|| location >= size() .**Overrides**remove in class [AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html) | ### removeAll\n\n ### removeAllChangeListeners | public **void** [removeAllChangeListeners](#std-label-io%5Frealm%5FRealmList%5FremoveAllChangeListeners) ()                                                                                                                                                                                                                                                           |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes all user-defined change listeners.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove listeners from a non-Looper Thread.TipSee also: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) | ### removeChangeListener\n\n | public **void** [removeChangeListener](#std-label-io%5Frealm%5FRealmList%5FremoveChangeListener) ([io.realm.OrderedRealmCollectionChangeListener<io.realm.RealmList<E>>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionChangeListener/#std-label-io%5Frealm%5FOrderedRealmCollectionChangeListener) listener)                                                                                                                                                                                                                                                         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes the specified change listener.**Parameters**listener \\- the change listener to be removed.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the change listener is null .[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove a listener from a non-Looper Thread.TipSee also: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) | ### set\n\n ### size | public **int** [size](#std-label-io%5Frealm%5FRealmList%5Fsize) ()                                                                                                                                                                                                                                                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the number of elements in this List .**Returns**the number of elements in this List .**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if Realm instance has been closed or parent object has been removed.**Overrides**size in class [AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html) | ### sort | public [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) [sort](#std-label-io%5Frealm%5FRealmList%5Fsort) ([java.lang.String\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldNames,[io.realm.Sort\\[\\]](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrders) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sorts a collection based on the provided fields and sort orders.**Returns**a new sorted [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) will be created and returned. The original collection stays unchanged.                                                                                                   |\n\n | public [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) [sort](#std-label-io%5Frealm%5FRealmList%5Fsort) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Sort](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrder) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sorts a collection based on the provided field and sort order.**Returns**a new sorted [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) will be created and returned. The original collection stays unchanged.                                                                        | | public [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) [sort](#std-label-io%5Frealm%5FRealmList%5Fsort) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sorts a collection based on the provided field in ascending order.**Returns**a new sorted [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) will be created and returned. The original collection stays unchanged. | ### sum | public [Number](https://docs.oracle.com/javase/7/docs/api/java/lang/Number.html) [sum](#std-label-io%5Frealm%5FRealmList%5Fsum) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Calculates the sum of a given field.**Returns**the sum. If no objects exist or they all have null as the value for the given field, 0 will be returned. When computing the sum, objects with null values are ignored. | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5FRealmList%5FtoString) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html)             | ### where\n\n ← [Enum RealmFieldType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmFieldType/ \"Previous Section\")[Class RealmMap](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSchema/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmSchema On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [contains](#contains)\n* [create](#create)\n* [createKeyPathMapping](#createkeypathmapping)\n* [createWithPrimaryKeyField](#createwithprimarykeyfield)\n* [get](#get)\n* [getAll](#getall)\n* [getColumnInfo](#getcolumninfo)\n* [remove](#remove)\n* [rename](#rename) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmSchema Class for interacting with the Realm schema. This makes it possible to inspect, add, delete and change the classes in the Realm.:ref:`Realm.getSchema() <io_realm_Realm_getSchema__>` returns an immutable `RealmSchema` which can only be used for inspecting. Use [DynamicRealm.getSchema()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm%5FgetSchema%5F%5F) to get a mutable schema. All changes must happen inside a write transaction for the particular Realm. ## Tip ### See also:  * [RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/#std-label-io%5Frealm%5FRealmMigration) ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### contains | public **boolean** [contains](#std-label-io%5Frealm%5FRealmSchema%5Fcontains) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if a given class already exists in the schema.**Parameters**className \\- class name to check.**Returns**true if the class already exists. false otherwise.   | ### create | public abstract [RealmObjectSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/#std-label-io%5Frealm%5FRealmObjectSchema) [create](#std-label-io%5Frealm%5FRealmSchema%5Fcreate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className)                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds a new class to the Realm.**Parameters**className \\- name of the class.**Returns**a Realm schema object for that class.**Throws**[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmSchema](#std-label-io%5Frealm%5FRealmSchema) is immutable. | ### createKeyPathMapping | public **void** [createKeyPathMapping](#std-label-io%5Frealm%5FRealmSchema%5FcreateKeyPathMapping) () |\n| ----------------------------------------------------------------------------------------------------- |\n| Create the underlying keypath mapping. Should only be called by typed Realms.                         | ### createWithPrimaryKeyField\n\n ### get | public abstract [RealmObjectSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/#std-label-io%5Frealm%5FRealmObjectSchema) [get](#std-label-io%5Frealm%5FRealmSchema%5Fget) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className)                                                                                                                                                                                                                                                                                                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [RealmObjectSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/#std-label-io%5Frealm%5FRealmObjectSchema) for a given class. If this [RealmSchema](#std-label-io%5Frealm%5FRealmSchema) is immutable, an immutable [RealmObjectSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/#std-label-io%5Frealm%5FRealmObjectSchema) will be returned. Otherwise, it returns a mutable [RealmObjectSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/#std-label-io%5Frealm%5FRealmObjectSchema) .**Parameters**className \\- name of the class**Returns**schema object for that class or null if the class doesn't exists. | ### getAll\n\n ### getColumnInfo | protected final **ColumnInfo** [getColumnInfo](#std-label-io%5Frealm%5FRealmSchema%5FgetColumnInfo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### remove | public abstract **void** [remove](#std-label-io%5Frealm%5FRealmSchema%5Fremove) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className)                                                                                                                                                                                                                                                                                                                                                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Removes a class from the Realm. All data will be removed. Removing a class while other classes point to it will throw an [IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) . Removes those classes or fields first.**Parameters**className \\- name of the class to remove.**Throws**[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmSchema](#std-label-io%5Frealm%5FRealmSchema) is immutable or of a synced Realm. | ### rename\n\n ← [Class RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/ \"Previous Section\")[Class RealmSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/MapChangeListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface MapChangeListener On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onChange](#onchange) ## io.realm [MapChangeListener](#std-label-io%5Frealm%5FMapChangeListener) can be registered with a [RealmMap](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/#std-label-io%5Frealm%5FRealmMap) to receive a notification with a [MapChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/MapChangeSet/#std-label-io%5Frealm%5FMapChangeSet) to describe the details of what have been changed in the map since last time. Realm instances on a thread without an [android.os.Looper](https://developer.android.com/reference/android/os/Looper) cannot register a [MapChangeListener](#std-label-io%5Frealm%5FMapChangeListener) . ## Tip ### See also:  * [RealmMap.addChangeListener(MapChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/#std-label-io%5Frealm%5FRealmMap%5FaddChangeListener%5FMapChangeListener%5F) ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                                                                                                                                             |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public **void**   | [onChange](#std-label-io%5Frealm%5FMapChangeListener%5FonChange) ([io.realm.RealmMap<K, V>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/#std-label-io%5Frealm%5FRealmMap) map,[io.realm.MapChangeSet<K>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/MapChangeSet/#std-label-io%5Frealm%5FMapChangeSet) changes)This will be called when the async query is finished the first time or the collection of objects has changed. | ## Method Detail ### onChange\n\n ← [Enum ImportFlag](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ImportFlag/ \"Previous Section\")[Interface MapChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/MapChangeSet/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.exceptions   \n* [io.realm.exceptions.RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind)\n* [io.realm.exceptions.DownloadingRealmInterruptedException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/DownloadingRealmInterruptedException/#std-label-io%5Frealm%5Fexceptions%5FDownloadingRealmInterruptedException-1)\n* [io.realm.exceptions.RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1)\n* [io.realm.exceptions.RealmFileException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException-1)\n* [io.realm.exceptions.RealmMigrationNeededException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmMigrationNeededException/#std-label-io%5Frealm%5Fexceptions%5FRealmMigrationNeededException-1)\n* [io.realm.exceptions.RealmPrimaryKeyConstraintException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmPrimaryKeyConstraintException/#std-label-io%5Frealm%5Fexceptions%5FRealmPrimaryKeyConstraintException-1)\n* [io.realm.exceptions.RealmError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmError/#std-label-io%5Frealm%5Fexceptions%5FRealmError-1) ← [Class RealmFlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/RealmFlowFactory/ \"Previous Section\")[Enum RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/ObjectChangeSet/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface ObjectChangeSet On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [getChangedFields](#getchangedfields)\n* [isDeleted](#isdeleted)\n* [isFieldChanged](#isfieldchanged) ## io.realm Information about the changes made to an object. ## Tip ### See also:  * [RealmObject.addChangeListener(RealmObjectChangeListener) .](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject%5FaddChangeListener%5FRealmObjectChangeListener%5F) ## Method Summary\n\n ## Method Detail ### getChangedFields | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getChangedFields](#std-label-io%5Frealm%5FObjectChangeSet%5FgetChangedFields) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Returns**the names of changed fields if the object still exists and there are field changes. Returns an empty String\\[\\] if the object has been deleted.         | ### isDeleted | public **boolean** [isDeleted](#std-label-io%5Frealm%5FObjectChangeSet%5FisDeleted) () |\n| -------------------------------------------------------------------------------------- |\n| **Returns**true if the object has been deleted from the Realm.                         | ### isFieldChanged | public **boolean** [isFieldChanged](#std-label-io%5Frealm%5FObjectChangeSet%5FisFieldChanged) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                   |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if a given field has been changed.**Parameters**fieldName \\- to be checked if its value has been changed.**Returns**true if the field has been changed. It returns false if the object is deleted, the field cannot be found or the field hasn't been changed. | ← [Class MutableRealmInteger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/MutableRealmInteger/ \"Previous Section\")[Interface OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/DefaultCompactOnLaunchCallback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class DefaultCompactOnLaunchCallback On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [shouldCompact](#shouldcompact) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.DefaultCompactOnLaunchCallback **Implemented interfaces:** * [io.realm.CompactOnLaunchCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/CompactOnLaunchCallback/#std-label-io%5Frealm%5FCompactOnLaunchCallback) The default implementation for determining if a file should be compacted or not. This implementation will only trigger if the file is above 50 MB and more than 50% can be reclaimed. ## Constructors | Constructor and Description                                                                   |\n| --------------------------------------------------------------------------------------------- |\n| [DefaultCompactOnLaunchCallback](#std-label-io%5Frealm%5FDefaultCompactOnLaunchCallback-1) () | ## Method Summary | Modifier and Type  | Method and Description                                                                                                                                                                                                               |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public **boolean** | [shouldCompact](#std-label-io%5Frealm%5FDefaultCompactOnLaunchCallback%5FshouldCompact) (**long** totalBytes,**long** usedBytes)This method determines if the Realm file should be compacted before opened and returned to the user. | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [DefaultCompactOnLaunchCallback](#std-label-io%5Frealm%5FDefaultCompactOnLaunchCallback-1) () |\n| ---------------------------------------------------------------------------------------------------- | ## Method Detail ### shouldCompact\n\n ← [Interface CompactOnLaunchCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/CompactOnLaunchCallback/ \"Previous Section\")[Class DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionSnapshot/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class OrderedRealmCollectionSnapshot On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [createSnapshot](#createsnapshot)\n* [deleteAllFromRealm](#deleteallfromrealm)\n* [deleteFirstFromRealm](#deletefirstfromrealm)\n* [deleteFromRealm](#deletefromrealm)\n* [deleteLastFromRealm](#deletelastfromrealm)\n* [freeze](#freeze)\n* [isFrozen](#isfrozen)\n* [isLoaded](#isloaded)\n* [load](#load)\n* [size](#size)\n* [sort](#sort)\n* [where](#where) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.util.AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html) [java.util.AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html) **io.realm.OrderedRealmCollectionImpl** io.realm.OrderedRealmCollectionSnapshot An [OrderedRealmCollectionSnapshot](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) is a special type of [OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection) . It can be created by calling [OrderedRealmCollection.createSnapshot()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection%5FcreateSnapshot%5F%5F) . Unlike [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) and [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) , its size and order of elements will never be changed after creation. [OrderedRealmCollectionSnapshot](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) is useful when making changes which may impact the size or order of the collection in simple loops. For example:\n\n ` ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.util.AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html) : `iterator` , `size` , `isEmpty` , `contains` , `toArray` , `toArray` , `add` , `remove` , `containsAll` , `addAll` , `removeAll` , `retainAll` , `clear` , `toString`\n* Methods inherited from class [java.util.AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html) : `add` , `get` , `set` , `add` , `remove` , `indexOf` , `lastIndexOf` , `clear` , `addAll` , `iterator` , `listIterator` , `listIterator` , `subList` , `equals` , `hashCode` , `removeRange`\n* Methods inherited from class **io.realm.OrderedRealmCollectionImpl**: `isValid` , `isManaged` , `contains` , `get` , `first` , `first` , `last` , `last` , `deleteFromRealm` , `deleteAllFromRealm` , `iterator` , `listIterator` , `listIterator` , `sort` , `sort` , `sort` , `sort` , `size` , `min` , `minDate` , `max` , `maxDate` , `sum` , `average` , `remove` , `remove` , `removeAll` , `set` , `retainAll` , `deleteLastFromRealm` , `deleteFirstFromRealm` , `clear` , `add` , `add` , `addAll` , `addAll` , `createSnapshot` , `getRealm` , `getCollectionOperator` ## Method Detail ### createSnapshot | public [OrderedRealmCollectionSnapshot](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) [createSnapshot](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5FcreateSnapshot) ()                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a snapshot from this [OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection) .**Returns**the snapshot of this collection.**Overrides**createSnapshot in class **OrderedRealmCollectionImpl** | ### deleteAllFromRealm\n\n ### deleteFirstFromRealm | public **boolean** [deleteFirstFromRealm](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5FdeleteFirstFromRealm) ()                                                                                                                                                                                                                                                                                         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deletes the first object from the Realm. The first object will become invalid.**Returns**true if an object was deleted, false otherwise.**Throws**[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm is closed or the method is called on the wrong thread.**Overrides**deleteFirstFromRealm in class **OrderedRealmCollectionImpl** | ### deleteFromRealm\n\n ### deleteLastFromRealm | public **boolean** [deleteLastFromRealm](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5FdeleteLastFromRealm) ()                                                                                                                                                                                                                                                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Deletes the last object from the Realm. The last object will become invalid.**Returns**true if an object was deleted, false otherwise.**Throws**[java.lang.IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm is closed or the method is called from the wrong thread.**Overrides**deleteLastFromRealm in class **OrderedRealmCollectionImpl** | ### freeze | public [OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection) [freeze](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5Ffreeze) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### isFrozen | public **boolean** [isFrozen](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5FisFrozen) () |\n| --------------------------------------------------------------------------------------------------- | ### isLoaded | public **boolean** [isLoaded](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5FisLoaded) ()                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if a collection has finished loading its data yet.**Returns**true if data has been loaded and is available, false if data is still being loaded. | ### load | public **boolean** [load](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5Fload) ()                                   |\n| ----------------------------------------------------------------------------------------------------------------------------- |\n| Blocks the collection until all data are available.**Returns**true if the data could be successfully loaded, false otherwise. | ### size\n\n ### sort | public [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) [sort](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5Fsort) ([java.lang.String\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldNames,[io.realm.Sort\\[\\]](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrders)                                                                                                                                                                                                                                                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Not supported by [OrderedRealmCollectionSnapshot](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) . Use 'sort()' on the original [OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection) instead.**Returns**a new sorted [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) will be created and returned. The original collection stays unchanged.**Throws**[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\-**Overrides**sort in class **OrderedRealmCollectionImpl** |\n\n | public [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) [sort](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5Fsort) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Sort](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrder)                                                                                                                                                                                                                                                                                                                       |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Not supported by [OrderedRealmCollectionSnapshot](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) . Use 'sort()' on the original [OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection) instead.**Returns**a new sorted [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) will be created and returned. The original collection stays unchanged.**Throws**[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\-**Overrides**sort in class **OrderedRealmCollectionImpl** |\n\n ### where | public [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) [where](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot%5Fwhere) ()                                                                                                                                                                                                                                                                         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Not supported by [OrderedRealmCollectionSnapshot](#std-label-io%5Frealm%5FOrderedRealmCollectionSnapshot) . Use 'where()' on the original [OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/#std-label-io%5Frealm%5FOrderedRealmCollection) instead.**Returns**a RealmQuery object.**Throws**[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- | ← [Interface OrderedRealmCollectionChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionChangeListener/ \"Previous Section\")[Class ProxyState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ProxyState/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmDictionary/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmDictionary On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [io.realm.RealmMap](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/#std-label-io%5Frealm%5FRealmMap) io.realm.RealmDictionary Specialization of [RealmMap](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/#std-label-io%5Frealm%5FRealmMap) s whose keys are strings. Similarly to [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) s, a RealmDictionary can operate in managed and unmanaged modes. In managed mode a RealmDictionary persists all its contents inside a Realm whereas in unmanaged mode it functions like a [HashMap](https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html) . Managed RealmDictionaries can only be created by Realm and will automatically update its content whenever the underlying Realm is updated. Managed RealmDictionaries can only be accessed using the getter that points to a RealmDictionary field of a [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . Unmanaged RealmDictionaries can be created by the user and can contain both managed and unmanaged RealmObjects. This is useful when dealing with JSON deserializers like GSON or other frameworks that inject values into a class. Unmanaged RealmDictionaries can be added to a Realm using the [Realm.copyToRealm(Iterable, ImportFlag...)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcopyToRealm%5FIterable%5F%5FImportFlag%5F%5F%5F%5F) method. ## Constructors\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [io.realm.RealmMap](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/#std-label-io%5Frealm%5FRealmMap) : `isManaged` , `isValid` , `isFrozen` , `size` , `isEmpty` , `containsKey` , `containsValue` , `get` , `put` , `remove` , `putAll` , `clear` , `keySet` , `values` , `entrySet` , `freeze` , `addChangeListener` , `addChangeListener` , `removeChangeListener` , `removeChangeListener` , `removeAllChangeListeners` ## Constructor Detail | public [RealmDictionary](#std-label-io%5Frealm%5FRealmDictionary-1) () |\n| ---------------------------------------------------------------------- |\n| Instantiates a RealmDictionary in unmanaged mode.                      | | public [RealmDictionary](#std-label-io%5Frealm%5FRealmDictionary-1) ([java.util.Map<java.lang.String, V>](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) map) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Instantiates a RealmDictionary in unmanaged mode with an initial dictionary.**Parameters**map \\- initial dictionary                                                          | ← [Class RealmConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/ \"Previous Section\")[Enum RealmFieldType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmFieldType/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/MapChangeSet/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface MapChangeSet On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [getChanges](#getchanges)\n* [getDeletions](#getdeletions)\n* [getInsertions](#getinsertions)\n* [isEmpty](#isempty) ## io.realm This interface describes the changes made to a map during the last update.:ref:`MapChangeSet <io_realm_MapChangeSet>` is passed to the [MapChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/MapChangeListener/#std-label-io%5Frealm%5FMapChangeListener) which is registered by [RealmMap.addChangeListener(MapChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMap/#std-label-io%5Frealm%5FRealmMap%5FaddChangeListener%5FMapChangeListener%5F) . ## Method Summary | Modifier and Type  | Method and Description                                                                                                                                        |\n| ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **T**       | [getChanges](#std-label-io%5Frealm%5FMapChangeSet%5FgetChanges) ()Array containing the keys that have been modified in the previous version of the map.       |\n| public **T**       | [getDeletions](#std-label-io%5Frealm%5FMapChangeSet%5FgetDeletions) ()The number of entries that have been deleted in the previous version of the map.        |\n| public **T**       | [getInsertions](#std-label-io%5Frealm%5FMapChangeSet%5FgetInsertions) ()Array containing the keys that have been inserted in the previous version of the map. |\n| public **boolean** | [isEmpty](#std-label-io%5Frealm%5FMapChangeSet%5FisEmpty) ()Whether the change set is empty or not.                                                           | ## Method Detail ### getChanges | public **T** [getChanges](#std-label-io%5Frealm%5FMapChangeSet%5FgetChanges) ()                                                              |\n| -------------------------------------------------------------------------------------------------------------------------------------------- |\n| Array containing the keys that have been modified in the previous version of the map.**Returns**array with the keys that have been modified. | ### getDeletions | public **T** [getDeletions](#std-label-io%5Frealm%5FMapChangeSet%5FgetDeletions) ()                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------- |\n| The number of entries that have been deleted in the previous version of the map.**Returns**array with the keys that have been deleted. |\n\n | public **T** [getInsertions](#std-label-io%5Frealm%5FMapChangeSet%5FgetInsertions) ()                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------- |\n| Array containing the keys that have been inserted in the previous version of the map.**Returns**array with the keys that have been inserted. | ### isEmpty | public **boolean** [isEmpty](#std-label-io%5Frealm%5FMapChangeSet%5FisEmpty) ()                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Whether the change set is empty or not. This is needed to detect whether a notification has been triggered right after subscription.**Returns**whether the change set contains changes. | ← [Interface MapChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/MapChangeListener/ \"Previous Section\")[Class MutableRealmInteger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/MutableRealmInteger/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb\n\n ← [Interface RealmLogger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLogger/ \"Previous Section\")[Class App](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SetChangeListener On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onChange](#onchange) ## io.realm [SetChangeListener](#std-label-io%5Frealm%5FSetChangeListener) can be registered with a [RealmSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet-1) to receive a notification with a [SetChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeSet/#std-label-io%5Frealm%5FSetChangeSet-1) to describe the details of what have been changed in the set since last time. Realm instances on a thread without an [android.os.Looper](https://developer.android.com/reference/android/os/Looper) cannot register a [SetChangeListener](#std-label-io%5Frealm%5FSetChangeListener) . ## Tip ### See also:  * [RealmSet.addChangeListener(SetChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet%5FaddChangeListener%5FSetChangeListener%5F) ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                     |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public **void**   | [onChange](#std-label-io%5Frealm%5FSetChangeListener%5FonChange) ([io.realm.RealmSet<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet-1) set,[SetChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeSet/#std-label-io%5Frealm%5FSetChangeSet-1) changes) | ## Method Detail ### onChange | public **void** [onChange](#std-label-io%5Frealm%5FSetChangeListener%5FonChange) ([io.realm.RealmSet<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet-1) set,[SetChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeSet/#std-label-io%5Frealm%5FSetChangeSet-1) changes) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmResults On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [addChangeListener](#addchangelistener)\n* [asChangesetObservable](#aschangesetobservable)\n* [asFlowable](#asflowable)\n* [asJSON](#asjson)\n* [freeze](#freeze)\n* [isFrozen](#isfrozen)\n* [isLoaded](#isloaded)\n* [load](#load)\n* [removeAllChangeListeners](#removeallchangelisteners)\n* [removeChangeListener](#removechangelistener)\n* [setBlob](#setblob)\n* [setBoolean](#setboolean)\n* [setByte](#setbyte)\n* [setDate](#setdate)\n* [setDecimal128](#setdecimal128)\n* [setDouble](#setdouble)\n* [setFloat](#setfloat)\n* [setInt](#setint)\n* [setList](#setlist)\n* [setLong](#setlong)\n* [setNull](#setnull)\n* [setObject](#setobject)\n* [setObjectId](#setobjectid)\n* [setShort](#setshort)\n* [setString](#setstring)\n* [setUUID](#setuuid)\n* [setValue](#setvalue)\n* [sort](#sort)\n* [where](#where) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.util.AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html) [java.util.AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html) **io.realm.OrderedRealmCollectionImpl** io.realm.RealmResults This class holds all the matches of a [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) for a given Realm. The objects are not copied from the Realm to the RealmResults list, but are just referenced from the RealmResult instead. This saves memory and increases speed. RealmResults are live views, which means that if it is on an **Looper** thread, it will automatically update its query results after a transaction has been committed. If on a non-looper thread, **Realm.refresh()** must be called to update the results. Updates to RealmObjects from a RealmResults list must be done from within a transaction and the modified objects are persisted to the Realm file during the commit of the transaction. A RealmResults object cannot be passed between different threads. Notice that a RealmResults is never `null` not even in the case where it contains no objects. You should always use the **RealmResults.size()** method to check if a RealmResults is empty or not. If a RealmResults is built on RealmList through [RealmList.where()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList%5Fwhere%5F%5F) , it will become empty when the source RealmList gets deleted. [RealmResults](#std-label-io%5Frealm%5FRealmResults) can contain more elements than `Integer.MAX_VALUE` . In that case, you can access only first `Integer.MAX_VALUE` elements in it. ## Tip ### See also: \n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.util.AbstractCollection](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html) : `iterator` , `size` , `isEmpty` , `contains` , `toArray` , `toArray` , `add` , `remove` , `containsAll` , `addAll` , `removeAll` , `retainAll` , `clear` , `toString`\n* Methods inherited from class [java.util.AbstractList](https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html) : `add` , `get` , `set` , `add` , `remove` , `indexOf` , `lastIndexOf` , `clear` , `addAll` , `iterator` , `listIterator` , `listIterator` , `subList` , `equals` , `hashCode` , `removeRange`\n* Methods inherited from class **io.realm.OrderedRealmCollectionImpl**: `isValid` , `isManaged` , `contains` , `get` , `first` , `first` , `last` , `last` , `deleteFromRealm` , `deleteAllFromRealm` , `iterator` , `listIterator` , `listIterator` , `sort` , `sort` , `sort` , `sort` , `size` , `min` , `minDate` , `max` , `maxDate` , `sum` , `average` , `remove` , `remove` , `removeAll` , `set` , `retainAll` , `deleteLastFromRealm` , `deleteFirstFromRealm` , `clear` , `add` , `add` , `addAll` , `addAll` , `createSnapshot` , `getRealm` , `getCollectionOperator` ## Method Detail ### addChangeListener\n\n\n\n ### asChangesetObservable\n\n ### asFlowable\n\n ### asJSON | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [asJSON](#std-label-io%5Frealm%5FRealmResults%5FasJSON) ()                                                                                                                                                                                                                                                                                                                                                                                         |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a JSON representation of the matches of a [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) . Cycles will be returned as row indices. This is a helper method used to inspect data, or for debugging purpose, this method could pull a large string which could cause an OutOfMemory error.**Returns**string representation of a JSON array containing entries of the resulting [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) . | ### freeze | public [RealmResults](#std-label-io%5Frealm%5FRealmResults) [freeze](#std-label-io%5Frealm%5FRealmResults%5Ffreeze) () |\n| ---------------------------------------------------------------------------------------------------------------------- | ### isFrozen | public **boolean** [isFrozen](#std-label-io%5Frealm%5FRealmResults%5FisFrozen) () |\n| --------------------------------------------------------------------------------- | ### isLoaded | public **boolean** [isLoaded](#std-label-io%5Frealm%5FRealmResults%5FisLoaded) ()                                                                                                                     |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns false if the results are not yet loaded, true if they are loaded.**Returns**true if the query has completed and the data is available, false if the query is still running in the background. | ### load\n\n ### removeAllChangeListeners | public **void** [removeAllChangeListeners](#std-label-io%5Frealm%5FRealmResults%5FremoveAllChangeListeners) ()                                                                                                                                                                                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes all user-defined change listeners.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove listeners from a non-Looper Thread.TipSee also: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) | ### removeChangeListener | public **void** [removeChangeListener](#std-label-io%5Frealm%5FRealmResults%5FremoveChangeListener) ([io.realm.OrderedRealmCollectionChangeListener<io.realm.RealmResults<E>>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionChangeListener/#std-label-io%5Frealm%5FOrderedRealmCollectionChangeListener) listener)                                                                                                                                                                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes the specified change listener.**Parameters**listener \\- the change listener to be removed.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the change listener is null .[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove a listener from a non-Looper Thread.TipSee also: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) |\n\n ### setBlob | public **void** [setBlob](#std-label-io%5Frealm%5FRealmResults%5FsetBlob) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**byte\\[\\]** value)                                                                                                                                                                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the binary value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a binary field. | ### setBoolean | public **void** [setBoolean](#std-label-io%5Frealm%5FRealmResults%5FsetBoolean) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**boolean** value)                                                                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the boolean value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a boolean field. | ### setByte\n\n ### setDate | public **void** [setDate](#std-label-io%5Frealm%5FRealmResults%5FsetDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) value)                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the Date value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a Date field. | ### setDecimal128 | public **void** [setDecimal128](#std-label-io%5Frealm%5FRealmResults%5FsetDecimal128) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** value)                                                                                                                                                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the Decimal128 value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a Decimal128 field. | ### setDouble\n\n ### setFloat | public **void** [setFloat](#std-label-io%5Frealm%5FRealmResults%5FsetFloat) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**float** value)                                                                                                                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the float value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a float field. | ### setInt | public **void** [setInt](#std-label-io%5Frealm%5FRealmResults%5FsetInt) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**int** value)                                                                                                                                                                                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the int value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't an integer field. | ### setList\n\n ### setLong | public **void** [setLong](#std-label-io%5Frealm%5FRealmResults%5FsetLong) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**long** value)                                                                                                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the long value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a long field. | ### setNull | public **void** [setNull](#std-label-io%5Frealm%5FRealmResults%5FsetNull) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets the value to null for the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or is a primary key property.[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the field cannot hold null values. | ### setObject\n\n ### setObjectId | public **void** [setObjectId](#std-label-io%5Frealm%5FRealmResults%5FsetObjectId) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                                                                                                              |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the ObjectId value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a ObjectId field. | ### setShort | public **void** [setShort](#std-label-io%5Frealm%5FRealmResults%5FsetShort) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**short** value)                                                                                                                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the short value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a short field. | ### setString\n\n ### setUUID | public **void** [setUUID](#std-label-io%5Frealm%5FRealmResults%5FsetUUID) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[UUID](https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html) value)                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the UUID value of the given field in all of the objects in the collection.**Parameters**fieldName \\- name of the field to update.value \\- new value for the field.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, is a primary key property or isn't a UUID field. | ### setValue\n\n ### sort | public [RealmResults](#std-label-io%5Frealm%5FRealmResults) [sort](#std-label-io%5Frealm%5FRealmResults%5Fsort) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName1,[Sort](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrder1,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName2,[Sort](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrder2) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sorts a collection based on the provided fields and sort orders.**Returns**a new sorted [RealmResults](#std-label-io%5Frealm%5FRealmResults) will be created and returned. The original collection stays unchanged.**Overrides**sort in class **OrderedRealmCollectionImpl**                                                                                                                                                                                              | ### where | public [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) [where](#std-label-io%5Frealm%5FRealmResults%5Fwhere) ()                                                  |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) , which can be used to query for specific objects from this collection.**Returns**a RealmQuery object. | ← [Class RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/ \"Previous Section\")[Class RealmSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSchema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/rx/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.rx   \n* [io.realm.rx.CollectionChange](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/CollectionChange/#std-label-io%5Frealm%5Frx%5FCollectionChange-1)\n* [io.realm.rx.ObjectChange](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/ObjectChange/#std-label-io%5Frealm%5Frx%5FObjectChange-1)\n* [io.realm.rx.RealmObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RealmObservableFactory/#std-label-io%5Frealm%5Frx%5FRealmObservableFactory-1)\n* [io.realm.rx.RxObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/#std-label-io%5Frealm%5Frx%5FRxObservableFactory) ← [Exception ClientResetRequiredError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ClientResetRequiredError/ \"Previous Section\")[Class CollectionChange](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/CollectionChange/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmAsyncTask On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [cancel](#cancel)\n* [isCancelled](#iscancelled) ## io.realm Represents a pending asynchronous Realm task, like asynchronous transactions.Users are responsible for maintaining a reference to `RealmAsyncTask` in order to call [cancel()](#std-label-io%5Frealm%5FRealmAsyncTask%5Fcancel%5F%5F) in case of a configuration change for example (to avoid memory leak, as the transaction will post the result to the caller's thread callback). ## Method Summary | Modifier and Type  | Method and Description                                                                                                                                                 |\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**    | [cancel](#std-label-io%5Frealm%5FRealmAsyncTask%5Fcancel) ()Attempts to cancel execution of this transaction (if it hasn't already completed or previously cancelled). |\n| public **boolean** | [isCancelled](#std-label-io%5Frealm%5FRealmAsyncTask%5FisCancelled) ()Checks whether an attempt to cancel the transaction was performed.                               | ## Method Detail ### cancel | public **void** [cancel](#std-label-io%5Frealm%5FRealmAsyncTask%5Fcancel) ()                               |\n| ---------------------------------------------------------------------------------------------------------- |\n| Attempts to cancel execution of this transaction (if it hasn't already completed or previously cancelled). | ### isCancelled | public **boolean** [isCancelled](#std-label-io%5Frealm%5FRealmAsyncTask%5FisCancelled) ()                                                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Checks whether an attempt to cancel the transaction was performed.**Returns**true if [cancel()](#std-label-io%5Frealm%5FRealmAsyncTask%5Fcancel%5F%5F) has already been called, false otherwise. | ← [Class RealmAnyOperator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAnyOperator/ \"Previous Section\")[Interface RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmFieldType/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum RealmFieldType On this page\n\n ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.RealmFieldType List of the types used by Realm's underlying storage engine.Normally there is no reason to interact with the underlying Realm types as Realm will automatically convert between normal Java types and the Realm types. However it is possible to access these types through a [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) . ## Enum Constant Summary\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `BINARY` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `BINARY_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `BINARY_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `BOOLEAN` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `BOOLEAN_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `BOOLEAN_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DATE` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DATE_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DATE_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DECIMAL128` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DECIMAL128_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DECIMAL128_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DOUBLE` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DOUBLE_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `DOUBLE_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `FLOAT` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `FLOAT_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `FLOAT_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `INTEGER` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `INTEGER_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `INTEGER_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `LINKING_OBJECTS` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `LINK_SET`\n\n ### `LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `MIXED` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `MIXED_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `MIXED_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `OBJECT` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `OBJECT_ID` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `OBJECT_ID_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `OBJECT_ID_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_SET` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_BINARY_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_BOOLEAN_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_DATE_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_DECIMAL128_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_DOUBLE_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_FLOAT_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_INTEGER_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_LINK_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_MIXED_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_OBJECT_ID_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_STRING_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `STRING_TO_UUID_MAP` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `TYPED_LINK` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `UUID` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `UUID_LIST` public static final [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) ### `UUID_SET`\n\n ## Method Detail ### fromNativeValue | public static [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) [fromNativeValue](#std-label-io%5Frealm%5FRealmFieldType%5FfromNativeValue) (**int** value)                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Converts the underlying value used by the storage engine to the proper Realm type.**Parameters**value \\- the value to convert**Returns**the corresponding Realm type.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if value isn't valid. | ### getNativeValue | public **int** [getNativeValue](#std-label-io%5Frealm%5FRealmFieldType%5FgetNativeValue) ()                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the native value representing this type.**Returns**the value used by the underlying storage engine to represent this type. | ### isValid | public **boolean** [isValid](#std-label-io%5Frealm%5FRealmFieldType%5FisValid) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) obj)                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if the given Java object can be converted to the underlying Realm type.**Parameters**obj \\- object to test compatibility on.**Returns**true if object can be converted to the Realm type, false otherwise. | ### valueOf | public static [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) [valueOf](#std-label-io%5Frealm%5FRealmFieldType%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [RealmFieldType](#std-label-io%5Frealm%5FRealmFieldType) [values](#std-label-io%5Frealm%5FRealmFieldType%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------------------------------------- | ← [Class RealmDictionary](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmDictionary/ \"Previous Section\")[Class RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmChangeListener On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onChange](#onchange) ## io.realm RealmChangeListener can be registered with a [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) , [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) or [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) to receive a notification about updates. When registered against a `Realm` you'll get notified when a Realm instance has been updated. Register against a `RealmResults` , `RealmList` , `RealmDictionary` or `RealmObject` to only get notified about changes to them. Realm instances on a thread without an [android.os.Looper](https://developer.android.com/reference/android/os/Looper) cannot register a RealmChangeListener. All [io.realm.RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) and [io.realm.RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) will automatically contain their new values when the **onChange(Object)** method is called. Normally this means that it isn't necessary to query again for those objects, but just invalidate any UI elements that are using them. If there is a chance that a object has been been deleted, it can be verified by using [RealmObject.isValid()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject%5FisValid%5F%5F) . ## Tip ### See also:  * [Realm.addChangeListener(RealmChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FaddChangeListener%5FRealmChangeListener%5F)\n* [Realm.removeAllChangeListeners()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FremoveAllChangeListeners%5F%5F)\n* [Realm.removeChangeListener(RealmChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FremoveChangeListener%5FRealmChangeListener%5F) ## Method Summary | Modifier and Type | Method and Description                                                                                              |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onChange](#std-label-io%5Frealm%5FRealmChangeListener%5FonChange) (**T** t)Called when a transaction is committed. | ## Method Detail ### onChange\n\n ← [Interface RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/ \"Previous Section\")[Interface RealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmCollection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum Sort On this page * [io.realm](#io.realm)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [ASCENDING](#ascending)\n* [DESCENDING](#descending)\n* [Method Detail](#method-detail)\n* [getValue](#getvalue)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.Sort This class describes the sorting order used in Realm queries. ## Tip ### See also:  * [io.realm.RealmQuery.sort(String, Sort)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5Fsort%5FString%5F%5FSort%5F-1) ## Enum Constant Summary | Enum Constant and Description                           |\n| ------------------------------------------------------- |\n| [ASCENDING](#std-label-io%5Frealm%5FSort%5FASCENDING)   |\n| [DESCENDING](#std-label-io%5Frealm%5FSort%5FDESCENDING) | ## Method Summary | Modifier and Type                                  | Method and Description                                                                                                                |\n| -------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |\n| public **boolean**                                 | [getValue](#std-label-io%5Frealm%5FSort%5FgetValue) ()Returns the value for this setting that is used by the underlying query engine. |\n| public static [Sort](#std-label-io%5Frealm%5FSort) | [valueOf](#std-label-io%5Frealm%5FSort%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name)    |\n| public static [Sort](#std-label-io%5Frealm%5FSort) | [values](#std-label-io%5Frealm%5FSort%5Fvalues) ()                                                                                    | ## Inherited Methods\n\n ## Enum Constant Detail ### `ASCENDING` public static final [Sort](#std-label-io%5Frealm%5FSort) ### `DESCENDING` public static final [Sort](#std-label-io%5Frealm%5FSort) ## Method Detail ### getValue | public **boolean** [getValue](#std-label-io%5Frealm%5FSort%5FgetValue) ()                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the value for this setting that is used by the underlying query engine.**Returns**the value used by the underlying query engine to indicate this value. | ### valueOf | public static [Sort](#std-label-io%5Frealm%5FSort) [valueOf](#std-label-io%5Frealm%5FSort%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [Sort](#std-label-io%5Frealm%5FSort) [values](#std-label-io%5Frealm%5FSort%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------- | ← [Class SetChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeSet/ \"Previous Section\")[io.realm.annotations](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/transformer/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.transformer   \n* [io.realm.transformer.Utils](https://mongodb.com/docs/realm/sdk/java/api/io/realm/transformer/Utils/#std-label-io%5Frealm%5Ftransformer%5FUtils-1) [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeSet/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class SetChangeSet On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getNumberOfDeletions](#getnumberofdeletions)\n* [getNumberOfInsertions](#getnumberofinsertions)\n* [isEmpty](#isempty) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.SetChangeSet This class describes the changes made to a set during the last update.:ref:`SetChangeSet <io_realm_SetChangeSet>` is passed to the [SetChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeListener/#std-label-io%5Frealm%5FSetChangeListener) which is registered by [RealmSet.addChangeListener(SetChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet%5FaddChangeListener%5FSetChangeListener%5F) . ## Constructors | Constructor and Description                                                                              |\n| -------------------------------------------------------------------------------------------------------- |\n| [SetChangeSet](#std-label-io%5Frealm%5FSetChangeSet-1) (**OsCollectionChangeSet** osCollectionChangeSet) | ## Method Summary | Modifier and Type  | Method and Description                                                                                                                 |\n| ------------------ | -------------------------------------------------------------------------------------------------------------------------------------- |\n| public **int**     | [getNumberOfDeletions](#std-label-io%5Frealm%5FSetChangeSet%5FgetNumberOfDeletions) ()The number of entries that have been deleted     |\n| public **int**     | [getNumberOfInsertions](#std-label-io%5Frealm%5FSetChangeSet%5FgetNumberOfInsertions) ()The number of entries that have been inserted. |\n| public **boolean** | [isEmpty](#std-label-io%5Frealm%5FSetChangeSet%5FisEmpty) ()Whether the change set is empty or not.                                    | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [SetChangeSet](#std-label-io%5Frealm%5FSetChangeSet-1) (**OsCollectionChangeSet** osCollectionChangeSet) |\n| --------------------------------------------------------------------------------------------------------------- | ## Method Detail ### getNumberOfDeletions\n\n ### getNumberOfInsertions | public **int** [getNumberOfInsertions](#std-label-io%5Frealm%5FSetChangeSet%5FgetNumberOfInsertions) () |\n| ------------------------------------------------------------------------------------------------------- |\n| The number of entries that have been inserted.**Returns**the number of insertions.                      | ### isEmpty | public **boolean** [isEmpty](#std-label-io%5Frealm%5FSetChangeSet%5FisEmpty) ()                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Whether the change set is empty or not. This is needed to detect whether a notification has been triggered right after subscription.**Returns**whether the change set contains changes. | ← [Interface SetChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeListener/ \"Previous Section\")[Enum Sort](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmConfiguration On this page * [io.realm](#io.realm)\n* [Nested Class Summary](#nested-class-summary)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [DEFAULT\\_REALM\\_NAME](#default%5Frealm%5Fname)\n* [Method Detail](#method-detail)\n* [createSchemaMediator](#createschemamediator)\n* [equals](#equals)\n* [forRecovery](#forrecovery)\n* [getAssetFilePath](#getassetfilepath)\n* [getCompactOnLaunchCallback](#getcompactonlaunchcallback)\n* [getDurability](#getdurability)\n* [getEncryptionKey](#getencryptionkey)\n* [getFlowFactory](#getflowfactory)\n* [getInitialDataTransaction](#getinitialdatatransaction)\n* [getInstance](#getinstance)\n* [getMaxNumberOfActiveVersions](#getmaxnumberofactiveversions)\n* [getMigration](#getmigration)\n* [getPath](#getpath)\n* [getRealmDirectory](#getrealmdirectory)\n* [getRealmFileName](#getrealmfilename)\n* [getRealmObjectClasses](#getrealmobjectclasses)\n* [getRxFactory](#getrxfactory)\n* [getSchemaMediator](#getschemamediator)\n* [getSchemaVersion](#getschemaversion)\n* [hasAssetFile](#hasassetfile)\n* [hashCode](#hashcode)\n* [isAllowQueriesOnUiThread](#isallowqueriesonuithread)\n* [isAllowWritesOnUiThread](#isallowwritesonuithread)\n* [isReadOnly](#isreadonly)\n* [isRecoveryConfiguration](#isrecoveryconfiguration)\n* [isSyncConfiguration](#issyncconfiguration)\n* [realmExists](#realmexists)\n* [shouldDeleteRealmIfMigrationNeeded](#shoulddeleterealmifmigrationneeded)\n* [toString](#tostring) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmConfiguration A RealmConfiguration is used to setup a specific Realm instance.Instances of a RealmConfiguration can only created by using the [io.realm.RealmConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) and calling its [io.realm.RealmConfiguration.Builder.build()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5Fbuild%5F%5F) method. A commonly used RealmConfiguration can easily be accessed by first saving it as [Realm.setDefaultConfiguration(RealmConfiguration)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FsetDefaultConfiguration%5FRealmConfiguration%5F) and then using [io.realm.Realm.getDefaultInstance()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FgetDefaultInstance%5F%5F) . A minimal configuration can be created using: `RealmConfiguration config = new RealmConfiguration.Builder().build()` This will create a RealmConfiguration with the following properties. * Realm file is called \"default.realm\"\n* It is saved in Context.getFilesDir()\n* It has its schema version set to 0.\n\n | Modifier and Type | Class and Description                                                                                                                             |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static     | [RealmConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) | ## Field Summary | Modifier and Type                                                                             | Field and Description                                                                       |\n| --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |\n| public static final [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | [DEFAULT\\_REALM\\_NAME](#std-label-io%5Frealm%5FRealmConfiguration%5FDEFAULT%5FREALM%5FNAME) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `DEFAULT_REALM_NAME` ## Method Detail ### createSchemaMediator | protected static **RealmProxyMediator** [createSchemaMediator](#std-label-io%5Frealm%5FRealmConfiguration%5FcreateSchemaMediator) ([java.util.Set<java.lang.Object>](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html) modules,[java.util.Set<java.lang.Class<? extends io.realm.RealmModel>>](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html) debugSchema,**boolean** excludeDebugSchema) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### equals | public **boolean** [equals](#std-label-io%5Frealm%5FRealmConfiguration%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) obj) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                           | ### forRecovery | protected static [RealmConfiguration](#std-label-io%5Frealm%5FRealmConfiguration) [forRecovery](#std-label-io%5Frealm%5FRealmConfiguration%5FforRecovery) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) canonicalPath,**byte\\[\\]** encryptionKey,**RealmProxyMediator** schemaMediator) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getAssetFilePath | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getAssetFilePath](#std-label-io%5Frealm%5FRealmConfiguration%5FgetAssetFilePath) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the path to the Realm asset file.**Returns**path to the asset file relative to the asset directory or null if not asset file was specified.                   | ### getCompactOnLaunchCallback\n\n ### getDurability | public **OsRealmConfig.Durability** [getDurability](#std-label-io%5Frealm%5FRealmConfiguration%5FgetDurability) () |\n| ------------------------------------------------------------------------------------------------------------------ | ### getEncryptionKey | public **byte** [getEncryptionKey](#std-label-io%5Frealm%5FRealmConfiguration%5FgetEncryptionKey) () |\n| ---------------------------------------------------------------------------------------------------- | ### getFlowFactory | public [FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory) [getFlowFactory](#std-label-io%5Frealm%5FRealmConfiguration%5FgetFlowFactory) ()                                                                                                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory) that is used to create Kotlin Flows from Realm objects.**Returns**the factory instance used to create Flows.**Throws**[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if the required coroutines framework is not on the classpath. | ### getInitialDataTransaction | protected [Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) [getInitialDataTransaction](#std-label-io%5Frealm%5FRealmConfiguration%5FgetInitialDataTransaction) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the transaction instance with initial data.**Returns**the initial data transaction.                                                                                                                                           | ### getInstance | protected [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) [getInstance](#std-label-io%5Frealm%5FRealmConfiguration%5FgetInstance) (**OsSharedRealm.VersionID** version) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### getMaxNumberOfActiveVersions\n\n ### getMigration | public [RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/#std-label-io%5Frealm%5FRealmMigration) [getMigration](#std-label-io%5Frealm%5FRealmConfiguration%5FgetMigration) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getPath | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getPath](#std-label-io%5Frealm%5FRealmConfiguration%5FgetPath) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the absolute path to where the Realm file will be saved.**Returns**the absolute path to the Realm file defined by this configuration.       | ### getRealmDirectory | public [File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html) [getRealmDirectory](#std-label-io%5Frealm%5FRealmConfiguration%5FgetRealmDirectory) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getRealmFileName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getRealmFileName](#std-label-io%5Frealm%5FRealmConfiguration%5FgetRealmFileName) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getRealmObjectClasses | public [Set](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html) [getRealmObjectClasses](#std-label-io%5Frealm%5FRealmConfiguration%5FgetRealmObjectClasses) ()                                                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the unmodifiable [Set](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html) of model classes that make up the schema for this Realm.**Returns**unmodifiable [Set](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html) of model classes. | ### getRxFactory\n\n ### getSchemaMediator | protected **RealmProxyMediator** [getSchemaMediator](#std-label-io%5Frealm%5FRealmConfiguration%5FgetSchemaMediator) () |\n| ----------------------------------------------------------------------------------------------------------------------- |\n| Returns the mediator instance of schema which is defined by this configuration.**Returns**the mediator of the schema.   | ### getSchemaVersion | public **long** [getSchemaVersion](#std-label-io%5Frealm%5FRealmConfiguration%5FgetSchemaVersion) () |\n| ---------------------------------------------------------------------------------------------------- | ### hasAssetFile | public **boolean** [hasAssetFile](#std-label-io%5Frealm%5FRealmConfiguration%5FhasAssetFile) ()                                |\n| ------------------------------------------------------------------------------------------------------------------------------ |\n| Indicates if an asset file has been configured for this configuration.**Returns**true if there is asset file, false otherwise. | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5FRealmConfiguration%5FhashCode) ()                      |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### isAllowQueriesOnUiThread\n\n ### isAllowWritesOnUiThread | public **boolean** [isAllowWritesOnUiThread](#std-label-io%5Frealm%5FRealmConfiguration%5FisAllowWritesOnUiThread) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns whether calls to [Realm.executeTransaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FexecuteTransaction) can be done on the UI thread.Note: Realm does not allow blocking transactions to be run on the main thread unless users explicitly opt in with [Builder.allowWritesOnUiThread(boolean)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FallowWritesOnUiThread%5Fboolean%5F) or its Realm Sync builder counterpart.**Returns**whether or not write operations are allowed to be run from the UI thread. | ### isReadOnly\n\n ### isRecoveryConfiguration | public **boolean** [isRecoveryConfiguration](#std-label-io%5Frealm%5FRealmConfiguration%5FisRecoveryConfiguration) ()                                      |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Returns**true if this configuration is intended to open a backup Realm (as a result of a client reset).TipSee also: **{@link ClientResetRequiredError}** | ### isSyncConfiguration | protected **boolean** [isSyncConfiguration](#std-label-io%5Frealm%5FRealmConfiguration%5FisSyncConfiguration) () |\n| ---------------------------------------------------------------------------------------------------------------- | ### realmExists | protected **boolean** [realmExists](#std-label-io%5Frealm%5FRealmConfiguration%5FrealmExists) ()                                                                                                                                                                                                                                              |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if the Realm file defined by this configuration already exists.WARNING: This method is just a point-in-time check. Unless protected by external synchronization another thread or process might have created or deleted the Realm file right after this method has returned.**Returns**true if the Realm file exists, false otherwise. | ### shouldDeleteRealmIfMigrationNeeded | public **boolean** [shouldDeleteRealmIfMigrationNeeded](#std-label-io%5Frealm%5FRealmConfiguration%5FshouldDeleteRealmIfMigrationNeeded) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------- | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5FRealmConfiguration%5FtoString) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                              | ← [Interface RealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmCollection/ \"Previous Section\")[Class RealmConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmObjectSchema On this page * [io.realm](#io.realm)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [addField](#addfield)\n* [addIndex](#addindex)\n* [addPrimaryKey](#addprimarykey)\n* [addRealmDictionaryField](#addrealmdictionaryfield)\n* [addRealmListField](#addrealmlistfield)\n* [addRealmObjectField](#addrealmobjectfield)\n* [addRealmSetField](#addrealmsetfield)\n* [getClassName](#getclassname)\n* [getFieldNames](#getfieldnames)\n* [getFieldType](#getfieldtype)\n* [getPrimaryKey](#getprimarykey)\n* [hasField](#hasfield)\n* [hasIndex](#hasindex)\n* [hasPrimaryKey](#hasprimarykey)\n* [isEmbedded](#isembedded)\n* [isNullable](#isnullable)\n* [isPrimaryKey](#isprimarykey)\n* [isRequired](#isrequired)\n* [removeField](#removefield)\n* [removeIndex](#removeindex)\n* [removePrimaryKey](#removeprimarykey)\n* [renameField](#renamefield)\n* [setClassName](#setclassname)\n* [setEmbedded](#setembedded)\n* [setNullable](#setnullable)\n* [setRequired](#setrequired)\n* [transform](#transform) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmObjectSchema Class for interacting with the schema for a given RealmObject class. This makes it possible to inspect, add, delete or change the fields for given class.If this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) is retrieved from an immutable [RealmSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSchema/#std-label-io%5Frealm%5FRealmSchema) , this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) will be immutable as well. ## Tip ### See also:  * [io.realm.RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/#std-label-io%5Frealm%5FRealmMigration) ## Nested Class Summary | Modifier and Type       | Class and Description                                                                                                                           |\n| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static interface | [RealmObjectSchema.Function](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/Function/#std-label-io%5Frealm%5FRealmObjectSchema%5FFunction) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### addField\n\n ### addIndex | public abstract [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) [addIndex](#std-label-io%5Frealm%5FRealmObjectSchema%5FaddIndex) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds an index to a given field. This is the equivalent of adding the [io.realm.annotations.Index](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Index/#std-label-io%5Frealm%5Fannotations%5FIndex) annotation on the field.**Parameters**fieldName \\- field to add index to.**Returns**the updated schema.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist, the field cannot be indexed or it already has a index defined.[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) is immutable. | ### addPrimaryKey\n\n ### addRealmDictionaryField\n\n\n\n ### addRealmListField\n\n | public abstract [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) [addRealmListField](#std-label-io%5Frealm%5FRealmObjectSchema%5FaddRealmListField) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) objectSchema)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds a new field that contains a [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) with references to other Realm model classes.If the list contains primitive types, use [addRealmListField(String, Class)](#std-label-io%5Frealm%5FRealmObjectSchema%5FaddRealmListField%5FString%5F%5FClass%5F) instead.**Parameters**fieldName \\- name of the field to add.objectSchema \\- schema for the Realm type being referenced.**Returns**the updated schema.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name is illegal or a field with that name already exists.[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) is immutable. |\n\n | public abstract [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) [addRealmObjectField](#std-label-io%5Frealm%5FRealmObjectSchema%5FaddRealmObjectField) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) objectSchema)                                                                                                                                                                                                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Adds a new field that references another [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) .**Parameters**fieldName \\- name of the field to add.objectSchema \\- schema for the Realm type being referenced.**Returns**the updated schema.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name is illegal or a field with that name already exists.[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) is immutable. | ### addRealmSetField\n\n | public abstract [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) [addRealmSetField](#std-label-io%5Frealm%5FRealmObjectSchema%5FaddRealmSetField) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) objectSchema)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds a new field that contains a [RealmSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/#std-label-io%5Frealm%5FRealmSet-1) with references to other Realm model classes.If the set contains primitive types, use [addRealmSetField(String, Class)](#std-label-io%5Frealm%5FRealmObjectSchema%5FaddRealmSetField%5FString%5F%5FClass%5F) instead.**Parameters**fieldName \\- name of the field to add.objectSchema \\- schema for the Realm type being referenced.**Returns**the updated schema.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name is illegal or a field with that name already exists.[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) is immutable. | ### getClassName\n\n ### getFieldNames | public [Set](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html) [getFieldNames](#std-label-io%5Frealm%5FRealmObjectSchema%5FgetFieldNames) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns all fields in this class.**Returns**a list of all the fields in this class.                                                                      | ### getFieldType | public [RealmFieldType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmFieldType/#std-label-io%5Frealm%5FRealmFieldType) [getFieldType](#std-label-io%5Frealm%5FRealmObjectSchema%5FgetFieldType) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the type used by the underlying storage engine to represent this field.**Parameters**fieldName \\- name of the target field.**Returns**the underlying type used by Realm to represent this field.                                                                        | ### getPrimaryKey | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getPrimaryKey](#std-label-io%5Frealm%5FRealmObjectSchema%5FgetPrimaryKey) ()                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the name of the primary key field.**Returns**the name of the primary key field.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the class doesn't have a primary key defined. | ### hasField | public **boolean** [hasField](#std-label-io%5Frealm%5FRealmObjectSchema%5FhasField) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Tests if the class has field defined with the given name.**Parameters**fieldName \\- field name to test.**Returns**true if the field exists, false otherwise.              | ### hasIndex\n\n ### hasPrimaryKey | public **boolean** [hasPrimaryKey](#std-label-io%5Frealm%5FRealmObjectSchema%5FhasPrimaryKey) ()                                                                                                                                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if the class has a primary key defined.**Returns**true if a primary key is defined, false otherwise.TipSee also: [io.realm.annotations.PrimaryKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/PrimaryKey/#std-label-io%5Frealm%5Fannotations%5FPrimaryKey) | ### isEmbedded | public **boolean** [isEmbedded](#std-label-io%5Frealm%5FRealmObjectSchema%5FisEmbedded) ()                                                                                                                                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns true if objects of this type are considered \"embedded\". See [RealmClass.embedded()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/#std-label-io%5Frealm%5Fannotations%5FRealmClass%5Fembedded%5F%5F) for further details.**Returns**true if objects of this type are embedded. false if not. | ### isNullable\n\n ### isPrimaryKey | public **boolean** [isPrimaryKey](#std-label-io%5Frealm%5FRealmObjectSchema%5FisPrimaryKey) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if a given field is the primary key field.**Parameters**fieldName \\- field to check.**Returns**true if it is the primary key field, false otherwise.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist.TipSee also: [addPrimaryKey(String)](#std-label-io%5Frealm%5FRealmObjectSchema%5FaddPrimaryKey%5FString%5F) | ### isRequired | public **boolean** [isRequired](#std-label-io%5Frealm%5FRealmObjectSchema%5FisRequired) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if a given field is required i.e., it is not allowed to contain null values.**Parameters**fieldName \\- field to check.**Returns**true if it is required, false otherwise.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist.TipSee also: [setRequired(String, boolean)](#std-label-io%5Frealm%5FRealmObjectSchema%5FsetRequired%5FString%5F%5Fboolean%5F) | ### removeField\n\n ### removeIndex | public abstract [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) [removeIndex](#std-label-io%5Frealm%5FRealmObjectSchema%5FremoveIndex) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes an index from a given field. This is the same as removing the @Index annotation on the field.**Parameters**fieldName \\- field to remove index from.**Returns**the updated schema.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or the field doesn't have an index.[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) is immutable or of a synced Realm. | ### removePrimaryKey\n\n ### renameField | public abstract [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) [renameField](#std-label-io%5Frealm%5FRealmObjectSchema%5FrenameField) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) currentFieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) newFieldName)                                                                                                                                                                                                                                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Renames a field from one name to another.**Parameters**currentFieldName \\- field name to rename.newFieldName \\- the new field name.**Returns**the updated schema.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if field name doesn't exist or if the new field name already exists.[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) is immutable or for a synced Realm. | ### setClassName\n\n ### setEmbedded\n\n ### setNullable\n\n ### setRequired\n\n ### transform | public abstract [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) [transform](#std-label-io%5Frealm%5FRealmObjectSchema%5Ftransform) ([RealmObjectSchema.Function](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/Function/#std-label-io%5Frealm%5FRealmObjectSchema%5FFunction) function)                                                                                                                                                                                                                                                                                                     |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Runs a transformation function on each RealmObject instance of the current class. The object will be represented as a [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) .There is no guarantees in which order the objects are returned.**Parameters**function \\- transformation function.**Returns**this schema.**Throws**[UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if this [RealmObjectSchema](#std-label-io%5Frealm%5FRealmObjectSchema) is immutable. | ← [Interface RealmObjectChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectChangeListener/ \"Previous Section\")[Interface RealmObjectSchema.Function](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/Function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSet/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmSet On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [add](#add)\n* [addAll](#addall)\n* [addChangeListener](#addchangelistener)\n* [average](#average)\n* [clear](#clear)\n* [contains](#contains)\n* [containsAll](#containsall)\n* [deleteAllFromRealm](#deleteallfromrealm)\n* [freeze](#freeze)\n* [getValueClass](#getvalueclass)\n* [getValueClassName](#getvalueclassname)\n* [isEmpty](#isempty)\n* [isFrozen](#isfrozen)\n* [isLoaded](#isloaded)\n* [isManaged](#ismanaged)\n* [isValid](#isvalid)\n* [iterator](#iterator)\n* [load](#load)\n* [max](#max)\n* [maxDate](#maxdate)\n* [min](#min)\n* [minDate](#mindate)\n* [remove](#remove)\n* [removeAll](#removeall)\n* [removeAllChangeListeners](#removeallchangelisteners)\n* [removeChangeListener](#removechangelistener)\n* [retainAll](#retainall)\n* [size](#size)\n* [sum](#sum)\n* [toArray](#toarray)\n* [where](#where) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmSet **Implemented interfaces:** * [java.util.Set](https://docs.oracle.com/javase/7/docs/api/java/util/Set.html)\n* [io.realm.RealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmCollection/#std-label-io%5Frealm%5FRealmCollection)\n* [java.util.Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)\n* [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html)\n* [java.util.Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html)\n* [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html) RealmSet is a collection that contains no duplicate elements.Similarly to [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) s, a RealmSet can operate in managed and unmanaged modes. In managed mode a RealmSet persists all its contents inside a Realm whereas in unmanaged mode it functions like a [HashSet](https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html) . Managed RealmSets can only be created by Realm and will automatically update their content whenever the underlying Realm is updated. Managed RealmSet can only be accessed using the getter that points to a RealmSet field of a [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) .\n\n Warning: the following methods are not supported for classes containing set fields yet: * [Realm.insert(RealmModel)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5Finsert%5FRealmModel%5F)\n* [Realm.insert(Collection)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5Finsert%5FCollection%5F)\n* [Realm.insertOrUpdate(RealmModel)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FinsertOrUpdate%5FRealmModel%5F)\n* [Realm.insertOrUpdate(Collection)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FinsertOrUpdate%5FCollection%5F)\n* **Realm.createAllFromJson(Class, String)**\n* [Realm.createAllFromJson(Class, JSONArray)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcreateAllFromJson%5FClass%5F%5FJSONArray%5F)\n* **Realm.createAllFromJson(Class, InputStream)**\n* **Realm.createObjectFromJson(Class, String)**\n* [Realm.createObjectFromJson(Class, JSONObject)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcreateObjectFromJson%5FClass%5F%5FJSONObject%5F) }\n* **Realm.createObjectFromJson(Class, InputStream)**}\n* **Realm.createOrUpdateAllFromJson(Class, String)**\n* [Realm.createOrUpdateAllFromJson(Class, JSONArray)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcreateOrUpdateAllFromJson%5FClass%5F%5FJSONArray%5F)\n* **Realm.createOrUpdateAllFromJson(Class, InputStream)**\n* **Realm.createOrUpdateObjectFromJson(Class, String)**\n* [Realm.createOrUpdateObjectFromJson(Class, JSONObject)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FcreateOrUpdateObjectFromJson%5FClass%5F%5FJSONObject%5F)\n* **Realm.createOrUpdateObjectFromJson(Class, InputStream)** ## Constructors\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [RealmSet](#std-label-io%5Frealm%5FRealmSet-1) () |\n| -------------------------------------------------------- |\n| Instantiates a RealmSet in unmanaged mode.               | | public [RealmSet](#std-label-io%5Frealm%5FRealmSet-1) ([java.util.Collection<E>](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) collection) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Instantiates a RealmSet in unmanaged mode with another collection.**Parameters**collection \\- the collection with which the set will be initially populated.      | | public [RealmSet](#std-label-io%5Frealm%5FRealmSet-1) (**BaseRealm** baseRealm,**OsSet** osSet,[java.lang.Class<E>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) valueClass) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Instantiates a RealmSet in managed mode. This constructor is used internally by Realm.**Parameters**baseRealm \\-osSet \\-valueClass \\-                                                           | | public [RealmSet](#std-label-io%5Frealm%5FRealmSet-1) (**BaseRealm** baseRealm,**OsSet** osSet,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) className) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Instantiates a RealmSet in managed mode. This constructor is used internally by a Dynamic Realm.**Parameters**baseRealm \\-osSet \\-className \\-                                      | ## Method Detail ### add | public **boolean** [add](#std-label-io%5Frealm%5FRealmSet%5Fadd) (**E** e) |\n| -------------------------------------------------------------------------- | ### addAll | public **boolean** [addAll](#std-label-io%5Frealm%5FRealmSet%5FaddAll) ([java.util.Collection<? extends E>](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) c) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### addChangeListener\n\n\n\n ### average | public **double** [average](#std-label-io%5Frealm%5FRealmSet%5Faverage) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                   |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the average of a given field.**Returns**the average for the given field amongst objects in query results. This will be of type double for all types of number fields. If no objects exist or they all have null as the value for the given field, 0 will be returned. When computing the average, objects with null values are ignored. | ### clear | public **void** [clear](#std-label-io%5Frealm%5FRealmSet%5Fclear) () |\n| -------------------------------------------------------------------- | ### contains | public **boolean** [contains](#std-label-io%5Frealm%5FRealmSet%5Fcontains) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o)                                                                                                                                            |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Tests whether this Collection contains the specified object. Returns true if and only if at least one element elem in this Collection meets following requirement: (object==null ? elem==null : object.equals(elem)) .**Returns**true if object is an element of this Collection , false otherwise. | ### containsAll | public **boolean** [containsAll](#std-label-io%5Frealm%5FRealmSet%5FcontainsAll) ([java.util.Collection<?>](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) c) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### deleteAllFromRealm | public **boolean** [deleteAllFromRealm](#std-label-io%5Frealm%5FRealmSet%5FdeleteAllFromRealm) ()                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| This deletes all objects in the collection from the underlying Realm as well as from the collection.**Returns**true if objects was deleted, false otherwise. | ### freeze | public [RealmSet](#std-label-io%5Frealm%5FRealmSet-1) [freeze](#std-label-io%5Frealm%5FRealmSet%5Ffreeze) () |\n| ------------------------------------------------------------------------------------------------------------ | ### getValueClass\n\n ### getValueClassName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getValueClassName](#std-label-io%5Frealm%5FRealmSet%5FgetValueClassName) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### isEmpty | public **boolean** [isEmpty](#std-label-io%5Frealm%5FRealmSet%5FisEmpty) () |\n| --------------------------------------------------------------------------- | ### isFrozen | public **boolean** [isFrozen](#std-label-io%5Frealm%5FRealmSet%5FisFrozen) () |\n| ----------------------------------------------------------------------------- | ### isLoaded | public **boolean** [isLoaded](#std-label-io%5Frealm%5FRealmSet%5FisLoaded) ()                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if a collection has finished loading its data yet.**Returns**true if data has been loaded and is available, false if data is still being loaded. | ### isManaged\n\n ### isValid | public **boolean** [isValid](#std-label-io%5Frealm%5FRealmSet%5FisValid) ()                                                                                                                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Checks if the collection is still valid to use, i.e., the [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) instance hasn't been closed. It will always return true for an unmanaged collection.**Returns**true if it is still valid to use or an unmanaged collection, false otherwise. | ### iterator | public [Iterator](https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html) [iterator](#std-label-io%5Frealm%5FRealmSet%5Fiterator) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------- | ### load | public **boolean** [load](#std-label-io%5Frealm%5FRealmSet%5Fload) ()                                                         |\n| ----------------------------------------------------------------------------------------------------------------------------- |\n| Blocks the collection until all data are available.**Returns**true if the data could be successfully loaded, false otherwise. | ### max | public [Number](https://docs.oracle.com/javase/7/docs/api/java/lang/Number.html) [max](#std-label-io%5Frealm%5FRealmSet%5Fmax) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the maximum value of a field.**Returns**if no objects exist or they all have null as the value for the given field, null will be returned. Otherwise the maximum value is returned. When determining the maximum value, objects with null values are ignored. | ### maxDate | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [maxDate](#std-label-io%5Frealm%5FRealmSet%5FmaxDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the maximum date.**Returns**if no objects exist or they all have null as the value for the given date field, null will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with null values are ignored. | ### min\n\n ### minDate | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [minDate](#std-label-io%5Frealm%5FRealmSet%5FminDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the minimum date.**Returns**if no objects exist or they all have null as the value for the given date field, null will be returned. Otherwise the minimum date is returned. When determining the minimum date, objects with null values are ignored. | ### remove | public **boolean** [remove](#std-label-io%5Frealm%5FRealmSet%5Fremove) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------- | ### removeAll | public **boolean** [removeAll](#std-label-io%5Frealm%5FRealmSet%5FremoveAll) ([java.util.Collection<?>](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) c) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### removeAllChangeListeners | public **void** [removeAllChangeListeners](#std-label-io%5Frealm%5FRealmSet%5FremoveAllChangeListeners) ()                                                                                                                                                                                                                                                            |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes all user-defined change listeners.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove listeners from a non-Looper Thread.TipSee also: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) | ### removeChangeListener\n\n | public **void** [removeChangeListener](#std-label-io%5Frealm%5FRealmSet%5FremoveChangeListener) ([io.realm.RealmChangeListener<io.realm.RealmSet<E>>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) listener)                                                                                                                                                                |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes the specified change listener.**Parameters**listener \\- the change listener to be removed.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the change listener is null .[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove a listener from a non-Looper Thread. | ### retainAll | public **boolean** [retainAll](#std-label-io%5Frealm%5FRealmSet%5FretainAll) ([java.util.Collection<?>](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) c) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### size | public **int** [size](#std-label-io%5Frealm%5FRealmSet%5Fsize) () |\n| ----------------------------------------------------------------- | ### sum | public [Number](https://docs.oracle.com/javase/7/docs/api/java/lang/Number.html) [sum](#std-label-io%5Frealm%5FRealmSet%5Fsum) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)  |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Calculates the sum of a given field.**Returns**the sum. If no objects exist or they all have null as the value for the given field, 0 will be returned. When computing the sum, objects with null values are ignored. | ### toArray | public **T** [toArray](#std-label-io%5Frealm%5FRealmSet%5FtoArray) <**T** \\>(**T\\[\\]** a) |\n| ----------------------------------------------------------------------------------------- | | public [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [toArray](#std-label-io%5Frealm%5FRealmSet%5FtoArray) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------- | ### where\n\n ← [Class RealmSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmSchema/ \"Previous Section\")[Interface SetChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/SetChangeListener/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/CollectionUtils/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class CollectionUtils On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [DICTIONARY\\_TYPE](#dictionary%5Ftype)\n* [LIST\\_TYPE](#list%5Ftype)\n* [SET\\_TYPE](#set%5Ftype)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [checkForAddRemoveListener](#checkforaddremovelistener)\n* [copyToRealm](#copytorealm) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.CollectionUtils ## Constructors | Constructor and Description                                     |\n| --------------------------------------------------------------- |\n| [CollectionUtils](#std-label-io%5Frealm%5FCollectionUtils-1) () | ## Field Summary | Modifier and Type                                                                             | Field and Description                                                           |\n| --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\n| public static final [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | [DICTIONARY\\_TYPE](#std-label-io%5Frealm%5FCollectionUtils%5FDICTIONARY%5FTYPE) |\n| public static final [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | [LIST\\_TYPE](#std-label-io%5Frealm%5FCollectionUtils%5FLIST%5FTYPE)             |\n| public static final [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | [SET\\_TYPE](#std-label-io%5Frealm%5FCollectionUtils%5FSET%5FTYPE)               | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `DICTIONARY_TYPE` ### `LIST_TYPE` ### `SET_TYPE` ## Constructor Detail | public [CollectionUtils](#std-label-io%5Frealm%5FCollectionUtils-1) () |\n| ---------------------------------------------------------------------- | ## Method Detail ### checkForAddRemoveListener | public static **void** [checkForAddRemoveListener](#std-label-io%5Frealm%5FCollectionUtils%5FcheckForAddRemoveListener) (**BaseRealm** baseRealm,[Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) listener,**boolean** checkListener) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks whether it is possible to add or remove a provided listener.**Parameters**listener \\- The listener to be checked.checkListener \\- whether the check should be performed.                                                                                | ### copyToRealm | public static **E** [copyToRealm](#std-label-io%5Frealm%5FCollectionUtils%5FcopyToRealm) <**E** \\>(**BaseRealm** baseRealm,**E** object)                                                                                                                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Called by both list and dictionary operators to copy a RealmModel to Realm in case it has been deemed necessary.**Type Parameters**E \\- The RealmModel type.**Parameters**baseRealm \\- The Realm instance to copy the object to.object \\- The object to copy.**Returns**the copied object | ← [Enum Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/ \"Previous Section\")[Interface CompactOnLaunchCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/CompactOnLaunchCallback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Index/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type Index On this page * [io.realm.annotations](#io.realm.annotations) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) This annotation will add a search index to the field. A search index will make the Realm file larger and inserts slower but queries will be faster.NOTICE: Only String, int, byte, short, long, boolean and Date fields can be indexed. ← [Annotation Type Ignore](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Ignore/ \"Previous Section\")[Annotation Type LinkingObjects](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/LinkingObjects/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Ignore/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type Ignore On this page * [io.realm.annotations](#io.realm.annotations) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) ← [Annotation Type Beta](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Beta/ \"Previous Section\")[Annotation Type Index](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Index/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmField/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type RealmField On this page * [io.realm.annotations](#io.realm.annotations)\n* [Optional Element Summary](#optional-element-summary)\n* [Element Detail](#element-detail) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) Annotation used on fields in Realm model classes. It describes metadata about the field. ## Optional Element Summary | Modifier and Type                                                                | Optional Element and Description                             |\n| -------------------------------------------------------------------------------- | ------------------------------------------------------------ |\n| public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | Manually set the internal name used by Realm for this field. |\n| public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | Manually set the internal name used by Realm for this field. | ## Element Detail\n\n | value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public String valueManually set the internal name used by Realm for this field. This will override any [RealmNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmNamingPolicy/#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) set on the class or the module.**Default:** \"\"TipSee also: [io.realm.annotations.RealmNamingPolicy for more information about what setting the name means.](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmNamingPolicy/#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy)[name()](#std-label-io%5Frealm%5Fannotations%5FRealmField%5Fname%5F%5F) | ← [Annotation Type RealmClass](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/ \"Previous Section\")[Annotation Type RealmModule](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmModule/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Beta/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type Beta On this page * [io.realm.annotations](#io.realm.annotations) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) This annotation is added to classes, constructors or methods which are considered in beta phase. It indicates that any public interface can change without prior announcements. Moreover, classes, constructors, and methods annotated as beta are not considered at production quality, and should be used with care. ← [io.realm.annotations](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/ \"Previous Section\")[Annotation Type Ignore](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Ignore/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type RealmClass On this page * [io.realm.annotations](#io.realm.annotations)\n* [Optional Element Summary](#optional-element-summary)\n* [Element Detail](#element-detail) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) Interface used to mark a class that can be persisted by Realm. ## Optional Element Summary | Modifier and Type                                                                                                                                   | Optional Element and Description                             |\n| --------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------ |\n| public **boolean**                                                                                                                                  | Define objects of this type as \"Embedded\".                   |\n| public [RealmNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmNamingPolicy/#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) | The naming policy applied to all fields in this class.       |\n| public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html)                                                                    | Manually set the internal name used by Realm for this class. |\n| public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html)                                                                    | Manually set the internal name used by Realm for this class. | ## Element Detail\n\n\n\n | name                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public String nameManually set the internal name used by Realm for this class. If this class is part of any modules, this will also override any name policy set using [RealmModule.classNamingPolicy()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmModule/#std-label-io%5Frealm%5Fannotations%5FRealmModule%5FclassNamingPolicy%5F%5F) .**Default:** \"\"TipSee also: [io.realm.annotations.RealmNamingPolicy for more information about what setting the name means.](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmNamingPolicy/#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) |\n\n ← [Annotation Type PrimaryKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/PrimaryKey/ \"Previous Section\")[Annotation Type RealmField](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmField/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmModule/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type RealmModule On this page * [io.realm.annotations](#io.realm.annotations)\n* [RealmModules and libraries](#realmmodules-and-libraries)\n* [Optional Element Summary](#optional-element-summary)\n* [Element Detail](#element-detail) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) By default a Realm can store all classes extending RealmObject in a project. However, if you want to restrict a Realm to only contain a subset of classes or want to share them between a library project and an app project, you must use a RealmModule.A RealmModule is a collection of classes extending RealmObject that can be combined with other RealmModules to create the schema for a Realm. This makes it easier to control versioning and migration of those Realms. A RealmModule can either be a library module or an app module. The distinction is made by setting `library = true` . Setting `library = true` is normally only relevant for library authors. See below for further details. Currently, it is not possible to have multiple RealmModule declarations in a single file. If you have more than one RealmModule, you will have to use separate Java files for each module. ## RealmModules and libraries Realms default behavior is to automatically create a RealmModule called `DefaultRealmModule` which contains all classes extending RealmObject in a project. This module is automatically known by Realm. This behavior is problematic when combining a library project and an app project that both uses Realm. This is because the `DefaultRealmModule` will be created for both the library project and the app project, which will cause the project to fail with duplicate class definition errors. Library authors are responsible for avoiding this conflict by using explicit modules where `library = true` is set. This disables the generation of the DefaultRealmModule for the library project and allows the library to be included in the app project that also uses Realm. This means that library projects that uses Realm internally are required to specify a specific module using `RealmConfiguration.modules()` . App developers are not required to specify any modules, as they implicitly use the `DefaultRealmModule` , but they now has the option of adding the library project classes to their schema using `RealmConfiguration.addModule()` . ## Tip ### See also:  * [Example of a project using modules](https://github.com/realm/realm-java/tree/master/examples/moduleExample) ## Optional Element Summary\n\n ## Element Detail | allClasses                                                                                                                                                                                                                                                                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public boolean allClassesInstead of adding all Realm classes manually to a module, set this boolean to true to automatically include all Realm classes in this project. This does not include classes from other libraries which must be exposed using their own module. Setting both allClasses = true and classes() will result in the annotation processor throwing an exception.**Default:** false |\n\n | classes                                                                                                                                                                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public Class classesSpecifies the classes extending RealmObject that should be part of this module. Only classes in this project can be included. Classes from other libraries must be exposed using their own module. Setting both allClasses = true and classes() will result in the annotation processor throwing an exception.**Default:** {} |\n\n | library                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public boolean librarySetting this to true will mark this module as a library module. This will prevent Realm from generating the DefaultRealmModule containing all classes. This is required by libraries so they do not interfere with Realms running in app code, but it also means that all libraries using Realm must explicitly use a module and cannot rely on the default module being present. Creating library modules and normal modules in the same project is not allowed and will result in the annotation processor throwing an exception.**Default:** false | ← [Annotation Type RealmField](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmField/ \"Previous Section\")[Enum RealmNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmNamingPolicy/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/LinkingObjects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type LinkingObjects On this page * [io.realm.annotations](#io.realm.annotations)\n* [Optional Element Summary](#optional-element-summary)\n* [Element Detail](#element-detail) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) Annotation for defining a reverse relationship from one class to another. This annotation can only be added to a field of the type `RealmResults` . To expose reverse relationships for use, create a declaration as follows: `| public class Person extends RealmObject {                                               |\n| --------------------------------------------------------------------------------------- |\n| String name;                                                                            |\n| Dog dog; // Normal relation                                                             |\n| }                                                                                       |\n| public class Dog extends RealmObject {                                                  |\n| // This holds all Person objects with a relation to this Dog object (= linking objects) |\n| @LinkingObjects(\"dog\")                                                                  |\n| final RealmResults<Person> owners = null;                                               |\n| }                                                                                       |\n| // Find all Dogs with at least one owner named John                                     |\n| realm.where(Dog.class).equalTo(\"owners.name\", \"John\").findAll();                        | `\n\n * The link is maintained by Realm and only works for managed objects.\n* They can be queried just like normal relation.\n* They can be followed just like normal relation.\n* They are ignored when doing a \\`copyToRealm().\\`\n* They are ignored when doing a \\`copyFromRealm().\\`\n* They are ignored when using the various \\`createObjectFromJson\\*\\` and \\`createAllFromJson\\*\\` methods.\n* Listeners on an object with a \\`@LinkingObject\\` field will not be triggered if the linking objects change, e.g: if another object drops a reference to this object. In addition, they have the following restrictions: * @Ignore takes precedence. A @LinkingObjects annotation on @Ignore field will be ignored.\n* The annotated field cannot be @Required.\n* The annotated field must be \\`final\\`.\n* The annotation argument (the name of the backlinked field) is required.\n* The annotation argument must be a simple field name. It cannot contain periods ('.').\n* The annotated field must be of type \\`RealmResults<T>\\` where T is concrete class that extends \\`RealmModel\\`. Note that when the source of the reverse reference (\\`dog\\` in the case above) is a \\`List\\`, there is a reverse reference for each forward reference, even if both forward references are to the same object. If the \\`Person\\` class above were defined as: ```java   public class DogLover extends RealmObject {    String name;    List<Dog> dogs = new ArrayList<Dog>;    } then the following code executes without error \n``` ```java Dog fido = new Dog();  DogLover john = new DogLover()  john.dogs.add(fido);  john.dogs.add(fido);  assert john.dogs.size() == 2;  assert fido.owners.size() == 2; \n``` Querying inverse relationship is like querying any `RealmResults` . This means that an inverse relationship cannot be `null` but it can be empty (length is 0). It is possible to query fields in the source class. This is equivalent to link queries. Please read [for more information](https://docs.mongodb.com/realm/sdk/android/examples/define-a-realm-object-model/#std-label-android-field-relationships-inverse) . ## Optional Element Summary | Modifier and Type                                                                | Optional Element and Description                                                                     |\n| -------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |\n| public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | The name of a field that contains a relation to an instance of the class containing this annotation. | ## Element Detail\n\n ← [Annotation Type Index](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Index/ \"Previous Section\")[Annotation Type PrimaryKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/PrimaryKey/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/PrimaryKey/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type PrimaryKey On this page * [io.realm.annotations](#io.realm.annotations) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) The @PrimaryKey annotation will mark a field as a primary key inside Realm. Only one field in a RealmObject class can have this annotation, and the field should uniquely identify the object. Trying to insert an object with an existing primary key will result in an `io.realm.exceptions.RealmPrimaryKeyConstraintException` . Primary key cannot be changed after the object created. Primary keys also count as having the [Index](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Index/#std-label-io%5Frealm%5Fannotations%5FIndex) annotation. It is allowed to apply this annotation on the following primitive types: byte, short, int, and long. String, Byte, Short, Integer, Long, ObjectId and UUID are also allowed, and further permitted to have `null` as a primary key value. This annotation is not allowed inside Realm classes marked as `@RealmClass(embedded = true)` . ← [Annotation Type LinkingObjects](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/LinkingObjects/ \"Previous Section\")[Annotation Type RealmClass](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Required/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Annotation Type Required On this page * [io.realm.annotations](#io.realm.annotations) ## io.realm.annotations **Implemented interfaces:** * [java.lang.annotation.Annotation](https://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Annotation.html) This annotation will mark the field or the element in `io.realm.RealmList` as not nullable. When a field of type `Boolean, Byte, Short, Integer, Long, Float, Double, String, byte[], Date` is annotated with [Required](#std-label-io%5Frealm%5Fannotations%5FRequired) , it cannot be set to `null` and Realm will throw an exception if it happens. Fields with primitive types are implicitly required. Note, `String` is not a primitive type, so in Java it is default nullable unless it is marked `@Required` . In Kotlin the reverse is true, so a `String` is non-null. To specify a nullable String in Kotlin you should use `String?` . If this annotation is used on a `RealmList` , the annotation is applied to the elements inside the list and not the list itself. The list itself is always non-null. This means that a list marked with this annotation are never allowed to hold `null` values even if the datatype would otherwise allow it. Realm will throw an exception if you attempt to store null values into a list marked `@Required` . This annotation cannot be used on a `RealmAny` , as the inner value of a RealmAny field is always nullable. Realm will throw an exception if you attempt mark a `RealmAny` as `@Required` . Compiling will fail if the [Required](#std-label-io%5Frealm%5Fannotations%5FRequired) annotation is put an a `RealmList` containing references to other Realm objects. ← [Enum RealmNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmNamingPolicy/ \"Previous Section\")[io.realm.coroutines](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface Realm.Transaction On this page * [io.realm](#io.realm)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [execute](#execute) ## io.realm **Enclosing class:** [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) Encapsulates a Realm transaction.Using this class will automatically handle **io.realm.Realm.beginTransaction()** and **io.realm.Realm.commitTransaction()** If any exception is thrown during the transaction **io.realm.Realm.cancelTransaction()** will be called instead of **io.realm.Realm.commitTransaction()**. ## Nested Class Summary | Modifier and Type       | Class and Description                                                                                                                                |\n| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static           | [Realm.Transaction.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/Callback/#std-label-io%5Frealm%5FRealm%5FTransaction%5FCallback-1)  |\n| public static interface | [Realm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnSuccess/#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnSuccess) |\n| public static interface | [Realm.Transaction.OnError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnError/#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnError)       | ## Method Summary | Modifier and Type | Method and Description                                                                                                                                  |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [execute](#std-label-io%5Frealm%5FRealm%5FTransaction%5Fexecute) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm) | ## Method Detail ### execute | public **void** [execute](#std-label-io%5Frealm%5FRealm%5FTransaction%5Fexecute) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class Realm.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Callback/ \"Previous Section\")[Class Realm.Transaction.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/Callback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmNamingPolicy/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum RealmNamingPolicy On this page * [io.realm.annotations](#io.realm.annotations)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [CAMEL\\_CASE](#camel%5Fcase)\n* [IDENTITY](#identity)\n* [LOWER\\_CASE\\_WITH\\_UNDERSCORES](#lower%5Fcase%5Fwith%5Funderscores)\n* [NO\\_POLICY](#no%5Fpolicy)\n* [PASCAL\\_CASE](#pascal%5Fcase)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.annotations [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.annotations.RealmNamingPolicy This enum defines the possible ways class and field names can be mapped from what is used in Java to the name used internally in the Realm file.Examples where this is useful: * To support two model classes with the same simple name but in different packages.\n* To make it easier to work with cross platform schemas as naming conventions are different.\n* To use a Java class name that is longer than the 57 character limit enforced by Realm.\n* To change a field name in Java without forcing app users through a migration process. Depending on where the policy is applied, it will have slightly different semantics: * If applied to [RealmModule.classNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmModule/#std-label-io%5Frealm%5Fannotations%5FRealmModule%5FclassNamingPolicy) all classes part of that module will be affected. If a class is part of multiple modules, the same naming policy must be applied to both modules, otherwise an error will be thrown.\n* If applied to [RealmModule.fieldNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmModule/#std-label-io%5Frealm%5Fannotations%5FRealmModule%5FfieldNamingPolicy) all persistable fields in all classes part of this module will be affected.\n* If applied to [RealmClass.fieldNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/#std-label-io%5Frealm%5Fannotations%5FRealmClass%5FfieldNamingPolicy) all fields in that class will be affected. This will override any field naming policy specified on a module. An example of this: `| @RealmClass(name = \"__person\", fieldNamingPolicy = RealmNamingPolicy.LOWER_CASE_WITH_UNDERSCORES) |\n| ------------------------------------------------------------------------------------------------- |\n| public class Person implements RealmModel { // is converted to \"__person\" internally              |\n| public string firstName; // Is converted to \"first_name\" internally                               |\n| }                                                                                                 | ` Choosing an internal name that differs from the name used in the Java model classes has the following implications:\n\n When automatically converting Java variable names, each variable name is normalized by splitting it into a list of words that are then joined using the rules of the target format. The following heuristics are used for determining what constitutes a \"word\". 1. Anytime a `_` or `$` is encountered. Examples are \"\\_FirstName\", \"\\_First\\_Name\" and \"$First$Name\" which all becomes \"First\" and \"Name\".\n2. Anytime you switch from a lower case character to an upper case character as identified by [Character.isUpperCase(int)](https://docs.oracle.com/javase/7/docs/api/java/lang/Character/isUpperCase%28int%29.html) and [Character.isLowerCase(int)](https://docs.oracle.com/javase/7/docs/api/java/lang/Character/isLowerCase%28int%29.html) . Example is \"FirstName\" which becomes \"First\" and \"Name\".\n3. Anytime you switch from more than one uppercase character to a lower case one. The last upper case letter is assumed to be part of the next word. This is identified by using [Character.isUpperCase(int)](https://docs.oracle.com/javase/7/docs/api/java/lang/Character/isUpperCase%28int%29.html) and [Character.isLowerCase(int)](https://docs.oracle.com/javase/7/docs/api/java/lang/Character/isLowerCase%28int%29.html) . Example is \"FIRSTName\" which becomes \"FIRST\" and \"Name.\n4. Some characters like emojiis are neither uppercase nor lowercase characters, so they will be part of the current word. Examples are \"my😁\" and \"MY😁\" which are both treated as one word.\n5. Hungarian notation, i.e. variable names starting with lowercase \"m\" followed by uppercase letter is stripped and not considered part of any word. Example is \"mFirstName\" and \"mFIRSTName\" which becomes \"First\" and \"Name. Note that changing the internal name does _NOT_ affect importing data from JSON. The JSON data must still follow the names as defined in the Realm Java class. When it comes to parsing JSON using standard libraries like Moshi, GSON or Jackson it is important to keep in mind that these libraries define the transformation from JSON to Java while setting internal Realm names define the transformation from Java to the Realm file. This means that if you want to import data into Realm from JSON using these libraries you still need to provide the annotations from both the JSON parser library and Realm. Using Moshi, it would look something like this: ```java public class Person extends RealmObject {     @Json(name = \"first_name\") // Name used in JSON input.     @RealmField(name = \"first_name\") // Name used internally in the Realm file.     public string firstName; // name used in Java } \n``` ## Tip ### See also:  * [RealmModule](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmModule/#std-label-io%5Frealm%5Fannotations%5FRealmModule)\n* [RealmClass](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/#std-label-io%5Frealm%5Fannotations%5FRealmClass)\n* [RealmField](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmField/#std-label-io%5Frealm%5Fannotations%5FRealmField) ## Enum Constant Summary\n\n ## Method Summary | Modifier and Type                                                                          | Method and Description                                                                                                                                        |\n| ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static [RealmNamingPolicy](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) | [valueOf](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [RealmNamingPolicy](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) | [values](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy%5Fvalues) ()                                                                                 | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `CAMEL_CASE` public static final [RealmNamingPolicy](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) The name in the Java model class is converted to camelCase, i.e. all words are joined together with the first letter in the first word lower cased, and the first letter of all subsequent words upper cased. This is the standard naming schema in Java, Kotlin, Swift and JavaScript.Examples: \"firstName\", \"FirstName\", \"mFirstName\", \"FIRST\\_NAME\", \"First$Name\" all becomes \"firstName\". ### `IDENTITY` public static final [RealmNamingPolicy](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) The name in the Java model class is used as is internally. ### `LOWER_CASE_WITH_UNDERSCORES` public static final [RealmNamingPolicy](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) The name in the Java model class is converted lowercase with each word separated by `_` . This is the default naming scheme in C++. Examples: \"firstName\", \"FirstName\", \"mFirstName\", \"FIRST\\_NAME\", \"First$Name\" all becomes \"first\\_name\". ### `NO_POLICY`\n\n No policy is applied. This policy will not override any policy set on a parent element, e.g. if set in [RealmClass.fieldNamingPolicy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmClass/#std-label-io%5Frealm%5Fannotations%5FRealmClass%5FfieldNamingPolicy) , the module policy will still apply to field names. If two modules disagree on the policy and one of them is `NO_POLICY` , the other will be chosen without an error being thrown. This policy is the default. ### `PASCAL_CASE` public static final [RealmNamingPolicy](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) The name in the Java model class is converted to PascalCase, i.e. all words are joined together with the first letter of all words upper cased. This is the default naming scheme in .NET.Examples: \"firstName\", \"FirstName\", \"mFirstName\", \"FIRST\\_NAME\", \"First$Name\" all becomes \"FirstName\". ## Method Detail ### valueOf | public static [RealmNamingPolicy](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) [valueOf](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [RealmNamingPolicy](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy) [values](#std-label-io%5Frealm%5Fannotations%5FRealmNamingPolicy%5Fvalues) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ← [Annotation Type RealmModule](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/RealmModule/ \"Previous Section\")[Annotation Type Required](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Required/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Callback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Realm.Callback On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [onError](#onerror)\n* [onSuccess](#onsuccess) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) **io.realm.BaseRealm.InstanceCallback** io.realm.Realm.Callback **Enclosing class:** [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) ## Constructors | Constructor and Description                               |\n| --------------------------------------------------------- |\n| [Callback](#std-label-io%5Frealm%5FRealm%5FCallback-1) () | ## Method Summary | Modifier and Type        | Method and Description                                                                                                                                                                                                                   |\n| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**          | [onError](#std-label-io%5Frealm%5FRealm%5FCallback%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception)Deliver an error happens when creating the Realm instance to the caller thread. |\n| public abstract **void** | [onSuccess](#std-label-io%5Frealm%5FRealm%5FCallback%5FonSuccess) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm)                                                                                 | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class **io.realm.BaseRealm.InstanceCallback**: `onSuccess` , `onError` ## Constructor Detail | public [Callback](#std-label-io%5Frealm%5FRealm%5FCallback-1) () |\n| ---------------------------------------------------------------- | ## Method Detail ### onError\n\n ### onSuccess | public abstract **void** [onSuccess](#std-label-io%5Frealm%5FRealm%5FCallback%5FonSuccess) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**onSuccess in class **InstanceCallback**                                                                                                                              | ← [Class Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/ \"Previous Section\")[Interface Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnError/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface Realm.Transaction.OnError On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onError](#onerror) ## io.realm **Enclosing class:** [Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) Callback invoked to notify the caller thread about error during the transaction. The transaction will be rolled back and the background Realm will be closed before invoking [onError(Throwable)](#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnError%5FonError%5FThrowable%5F) . ## Method Summary | Modifier and Type | Method and Description                                                                                                                                             |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public **void**   | [onError](#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnError%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) error) | ## Method Detail ### onError | public **void** [onError](#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnError%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) error) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class Realm.Transaction.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/Callback/ \"Previous Section\")[Interface Realm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnSuccess/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnSuccess/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface Realm.Transaction.OnSuccess On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onSuccess](#onsuccess) ## io.realm **Enclosing class:** [Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) Callback invoked to notify the caller thread about the success of the transaction. ## Method Summary | Modifier and Type | Method and Description                                                              |\n| ----------------- | ----------------------------------------------------------------------------------- |\n| public **void**   | [onSuccess](#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnSuccess%5FonSuccess) () | ## Method Detail ### onSuccess | public **void** [onSuccess](#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnSuccess%5FonSuccess) () |\n| --------------------------------------------------------------------------------------------------- | ← [Interface Realm.Transaction.OnError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnError/ \"Previous Section\")[Class RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/Callback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Realm.Transaction.Callback On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [onError](#onerror)\n* [onSuccess](#onsuccess) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.Realm.Transaction.Callback **Enclosing class:** [Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) Callback invoked to notify the caller thread. ## Constructors | Constructor and Description                                             |\n| ----------------------------------------------------------------------- |\n| [Callback](#std-label-io%5Frealm%5FRealm%5FTransaction%5FCallback-1) () | ## Method Summary | Modifier and Type | Method and Description                                                                                                                                               |\n| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onError](#std-label-io%5Frealm%5FRealm%5FTransaction%5FCallback%5FonError) ([Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) ignore) |\n| public **void**   | [onSuccess](#std-label-io%5Frealm%5FRealm%5FTransaction%5FCallback%5FonSuccess) ()                                                                                   | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [Callback](#std-label-io%5Frealm%5FRealm%5FTransaction%5FCallback-1) () |\n| ------------------------------------------------------------------------------ | ## Method Detail ### onError | public **void** [onError](#std-label-io%5Frealm%5FRealm%5FTransaction%5FCallback%5FonError) ([Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) ignore) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### onSuccess | public **void** [onSuccess](#std-label-io%5Frealm%5FRealm%5FTransaction%5FCallback%5FonSuccess) () |\n| -------------------------------------------------------------------------------------------------- |\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.mongo   \n* [io.realm.mongodb.mongo.MongoClient](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoClient)\n* [io.realm.mongodb.mongo.MongoCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection)\n* [io.realm.mongodb.mongo.MongoDatabase](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase)\n* [io.realm.mongodb.mongo.MongoNamespace](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoNamespace/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace-1) ← [Class HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/ \"Previous Section\")[Class MongoClient](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Credentials On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [anonymous](#anonymous)\n* [apiKey](#apikey)\n* [apple](#apple)\n* [asJson](#asjson)\n* [customFunction](#customfunction)\n* [emailPassword](#emailpassword)\n* [facebook](#facebook)\n* [getIdentityProvider](#getidentityprovider)\n* [google](#google)\n* [jwt](#jwt) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.Credentials Credentials represent a login with a given login provider, and are used by the MongoDB Realm to verify the user and grant access. The [Provider.EMAIL\\_PASSWORD](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider%5FEMAIL%5FPASSWORD) provider is enabled by default. All other providers must be enabled on MongoDB Realm to work. Note that users wanting to login using Email/Password must register first using [EmailPasswordAuth.registerUser(String, String)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/EmailPasswordAuth/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FregisterUser%5FString%5F%5FString%5F) . Credentials are used the following way:\n\n ` ## Tip ### See also:  * [Authentication Providers](https://docs.mongodb.com/realm/authentication/providers/) ## Nested Class Summary | Modifier and Type   | Class and Description                                                                                                                           |\n| ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static final | [Credentials.Provider](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### anonymous | public static [Credentials](#std-label-io%5Frealm%5Fmongodb%5FCredentials) [anonymous](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5Fanonymous) ()                                                                                                                                                                                                                                                                                                                                                                                                         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates credentials representing an anonymous user.Logging the user out again means that data is lost with no means of recovery and it isn't possible to share the user details across devices.The anonymous user must be linked to another real user to preserve data after a log out.**Returns**a set of credentials that can be used to log into MongoDB Realm using [App.loginAsync(Credentials, App.Callback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FloginAsync%5FCredentials%5F%5FApp%5FCallback%5F) . | ### apiKey\n\n ### apple | public static [Credentials](#std-label-io%5Frealm%5Fmongodb%5FCredentials) [apple](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5Fapple) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) idToken)                                                                                                                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates credentials representing a login using an Apple ID token.This provider must be enabled on MongoDB Realm to work.**Parameters**idToken \\- the ID token generated when using your Apple login.**Returns**a set of credentials that can be used to log into MongoDB Realm using [App.loginAsync(Credentials, App.Callback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FloginAsync%5FCredentials%5F%5FApp%5FCallback%5F) . | ### asJson | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [asJson](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FasJson) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the credentials object serialized as a json string.**Returns**a json serialized string of the credentials object.                            | ### customFunction\n\n ### emailPassword | public static [Credentials](#std-label-io%5Frealm%5Fmongodb%5FCredentials) [emailPassword](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FemailPassword) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) email,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) password)                                                                                                          |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates credentials representing a login using email and password.**Parameters**email \\- email of the user logging in.password \\- password of the user logging in.**Returns**a set of credentials that can be used to log into MongoDB Realm using [App.loginAsync(Credentials, App.Callback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FloginAsync%5FCredentials%5F%5FApp%5FCallback%5F) . | ### facebook | public static [Credentials](#std-label-io%5Frealm%5Fmongodb%5FCredentials) [facebook](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5Ffacebook) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) accessToken)                                                                                                                                                                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates credentials representing a login using a Facebook access token.This provider must be enabled on MongoDB Realm to work.**Parameters**accessToken \\- the access token returned when logging in to Facebook.**Returns**a set of credentials that can be used to log into MongoDB Realm using [App.loginAsync(Credentials, App.Callback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FloginAsync%5FCredentials%5F%5FApp%5FCallback%5F) . | ### getIdentityProvider\n\n ### google | public static [Credentials](#std-label-io%5Frealm%5Fmongodb%5FCredentials) [google](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5Fgoogle) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) authorizationCode)                                                                                                                                                                                                                                                                                                                                                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates credentials representing a login using a [GoogleAuthType.AUTH\\_CODE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/GoogleAuthType/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType%5FAUTH%5FCODE) Google access token.This provider must be enabled on MongoDB Realm to work.**Parameters**authorizationCode \\- the authorization code returned when logging in to Google.**Returns**a set of credentials that can be used to log into MongoDB Realm using [App.loginAsync(Credentials, App.Callback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FloginAsync%5FCredentials%5F%5FApp%5FCallback%5F) . |\n\n ### jwt | public static [Credentials](#std-label-io%5Frealm%5Fmongodb%5FCredentials) [jwt](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5Fjwt) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) jwtToken)                                                                                                                                                                                                                                                                                                                            |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates credentials representing a login using a JWT Token. This token is normally generated after a custom OAuth2 login flow.This provider must be enabled on MongoDB Realm to work.**Parameters**jwtToken \\- the jwt token returned after a custom login to a another service.**Returns**a set of credentials that can be used to log into MongoDB Realm using [App.loginAsync(Credentials, App.Callback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FloginAsync%5FCredentials%5F%5FApp%5FCallback%5F) . | ← [Interface AuthenticationListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AuthenticationListener/ \"Previous Section\")[Enum Credentials.Provider](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/UserIdentity/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class UserIdentity On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [getId](#getid)\n* [getProvider](#getprovider)\n* [hashCode](#hashcode)\n* [toString](#tostring) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.UserIdentity Each User is represented by 1 or more identities each defined by an [Credentials.Provider](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) . This class represents the identity defined by a specific provider. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5FUserIdentity%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                             | ### getId | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getId](#std-label-io%5Frealm%5Fmongodb%5FUserIdentity%5FgetId) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a unique identifier for this identity.**Returns**a unique identifier for this identifier.                                                   | ### getProvider | public [Credentials.Provider](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) [getProvider](#std-label-io%5Frealm%5Fmongodb%5FUserIdentity%5FgetProvider) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the provider defining this identity.**Returns**                                                                                                                                                                               | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5FUserIdentity%5FhashCode) ()                  |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### toString\n\n ← [Enum User.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/State/ \"Previous Section\")[Class UserProfile](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/UserProfile/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmConfiguration.Builder On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [addModule](#addmodule)\n* [allowQueriesOnUiThread](#allowqueriesonuithread)\n* [allowWritesOnUiThread](#allowwritesonuithread)\n* [assetFile](#assetfile)\n* [build](#build)\n* [compactOnLaunch](#compactonlaunch)\n* [deleteRealmIfMigrationNeeded](#deleterealmifmigrationneeded)\n* [directory](#directory)\n* [encryptionKey](#encryptionkey)\n* [flowFactory](#flowfactory)\n* [inMemory](#inmemory)\n* [initialData](#initialdata)\n* [maxNumberOfActiveVersions](#maxnumberofactiveversions)\n* [migration](#migration)\n* [modules](#modules)\n* [name](#name)\n* [readOnly](#readonly)\n* [rxFactory](#rxfactory)\n* [schemaVersion](#schemaversion) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmConfiguration.Builder **Enclosing class:** [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) RealmConfiguration.Builder used to construct instances of a RealmConfiguration in a fluent manner. ## Constructors | Constructor and Description                                                                                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------- |\n| [Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) ()Creates an instance of the Builder for the RealmConfiguration. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) ()                                                                                                                                                                                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates an instance of the Builder for the RealmConfiguration.This will use the app's own internal directory for storing the Realm file. This does not require any additional permissions. The default location is /data/data/<packagename>/files , but can change depending on vendor implementations of Android. | ## Method Detail ### addModule | public final [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [addModule](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FaddModule) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) module) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| FIXME: Temporary visible DEBUG method. Will add a module unconditionally. Adds a module to already defined modules.                                                                                                                                                | ### allowQueriesOnUiThread\n\n ### allowWritesOnUiThread | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [allowWritesOnUiThread](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FallowWritesOnUiThread) (**boolean** allowWritesOnUiThread)                                                                                                                                                                                                                                                                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets whether or not calls to [Realm.executeTransaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FexecuteTransaction) are allowed from the UI thread.**WARNING: Realm does not allow synchronous transactions to be run on the main thread unless users explicitly opt in with this method.** We recommend diverting calls to executeTransaction to non-UI threads or, alternatively, using [Realm.executeTransactionAsync](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FexecuteTransactionAsync) . | ### assetFile\n\n ### build | public [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) [build](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5Fbuild) ()         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates the RealmConfiguration based on the builder parameters.**Returns**the created [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) . | ### compactOnLaunch | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [compactOnLaunch](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FcompactOnLaunch) ([CompactOnLaunchCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/CompactOnLaunchCallback/#std-label-io%5Frealm%5FCompactOnLaunchCallback) compactOnLaunch)                                                                                                                                         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets this to determine if the Realm file should be compacted before returned to the user. It is passed the total file size (data + free space) and the bytes used by data in the file.**Parameters**compactOnLaunch \\- a callback called when opening a Realm for the first time during the life of a process to determine if it should be compacted before being returned to the user. It is passed the total file size (data + free space) and the bytes used by data in the file. | | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [compactOnLaunch](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FcompactOnLaunch) ()                                                                                                                                       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Setting this will cause Realm to compact the Realm file if the Realm file has grown too large and a significant amount of space can be recovered. See [DefaultCompactOnLaunchCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DefaultCompactOnLaunchCallback/#std-label-io%5Frealm%5FDefaultCompactOnLaunchCallback-1) for details. | ### deleteRealmIfMigrationNeeded\n\n ### directory | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [directory](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5Fdirectory) ([File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html) directory)                                                                                                                                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Specifies the directory where the Realm file will be saved. The default value is context.getFilesDir() . If the directory does not exist, it will be created.**Parameters**directory \\- the directory to save the Realm file in. Directory must be writable.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if directory is null, not writable or a file. | ### encryptionKey | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [encryptionKey](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FencryptionKey) (**byte\\[\\]** key) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the 64 byte key used to encrypt and decrypt the Realm file. Sets the io.realm.Realm#ENCRYPTION\\_KEY\\_LENGTH bytes key used to encrypt and decrypt the Realm file.                               | ### flowFactory | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [flowFactory](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FflowFactory) ([FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory) factory)                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets the [FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory) used to create coroutines Flows from Realm objects. The default factory is [RealmFlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/RealmFlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory-1) .**Parameters**factory \\- factory to use. | ### inMemory\n\n ### initialData | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [initialData](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FinitialData) ([Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) transaction)                                                                                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the initial data in [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) . This transaction will be executed only for the first time when database file is created or while migrating the data when [Builder.deleteRealmIfMigrationNeeded()](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FdeleteRealmIfMigrationNeeded%5F%5F) is set.**Parameters**transaction \\- transaction to execute. | ### maxNumberOfActiveVersions\n\n ### migration | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [migration](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5Fmigration) ([RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/#std-label-io%5Frealm%5FRealmMigration) migration)                                                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the [io.realm.RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/#std-label-io%5Frealm%5FRealmMigration) to be run if a migration is needed. If this migration fails to upgrade the on-disc schema to the runtime schema, a [io.realm.exceptions.RealmMigrationNeededException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmMigrationNeededException/#std-label-io%5Frealm%5Fexceptions%5FRealmMigrationNeededException-1) will be thrown. | ### modules\n\n ### name | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [name](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5Fname) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) filename) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the filename for the Realm file.                                                                                                                                                                                                                | ### readOnly\n\n ### rxFactory | public [RealmConfiguration.Builder](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder-1) [rxFactory](#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FrxFactory) ([RxObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/#std-label-io%5Frealm%5Frx%5FRxObservableFactory) factory)                                                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the [RxObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/#std-label-io%5Frealm%5Frx%5FRxObservableFactory) used to create Rx Observables from Realm objects. The default factory is [RealmObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RealmObservableFactory/#std-label-io%5Frealm%5Frx%5FRealmObservableFactory-1) .**Parameters**factory \\- factory to use. | ### schemaVersion\n\n ← [Class RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/ \"Previous Section\")[Class RealmDictionary](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmDictionary/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Realm On this page * [io.realm](#io.realm)\n* [Nested Class Summary](#nested-class-summary)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [DEFAULT\\_REALM\\_NAME](#default%5Frealm%5Fname)\n* [ENCRYPTION\\_KEY\\_LENGTH](#encryption%5Fkey%5Flength)\n* [Method Detail](#method-detail)\n* [addChangeListener](#addchangelistener)\n* [asFlowable](#asflowable)\n* [compactRealm](#compactrealm)\n* [copyFromRealm](#copyfromrealm)\n* [copyToRealm](#copytorealm)\n* [copyToRealmOrUpdate](#copytorealmorupdate)\n* [createAllFromJson](#createallfromjson)\n* [createEmbeddedObject](#createembeddedobject)\n* [createObject](#createobject)\n* [createObjectFromJson](#createobjectfromjson)\n* [createOrUpdateAllFromJson](#createorupdateallfromjson)\n* [createOrUpdateObjectFromJson](#createorupdateobjectfromjson)\n* [delete](#delete)\n* [deleteRealm](#deleterealm)\n* [executeTransaction](#executetransaction)\n* [executeTransactionAsync](#executetransactionasync)\n* [freeze](#freeze)\n* [getApplicationContext](#getapplicationcontext)\n* [getDefaultConfiguration](#getdefaultconfiguration)\n* [getDefaultInstance](#getdefaultinstance)\n* [getDefaultModule](#getdefaultmodule)\n* [getGlobalInstanceCount](#getglobalinstancecount)\n* [getInstance](#getinstance)\n* [getInstanceAsync](#getinstanceasync)\n* [getLocalInstanceCount](#getlocalinstancecount)\n* [getSchema](#getschema)\n* [init](#init)\n* [insert](#insert)\n* [insertOrUpdate](#insertorupdate)\n* [isEmpty](#isempty)\n* [migrateRealm](#migraterealm)\n* [removeAllChangeListeners](#removeallchangelisteners)\n* [removeChangeListener](#removechangelistener)\n* [removeDefaultConfiguration](#removedefaultconfiguration)\n* [setDefaultConfiguration](#setdefaultconfiguration)\n* [where](#where) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) **io.realm.BaseRealm** io.realm.Realm The Realm class is the storage and transactional manager of your object persistent store. It is in charge of creating instances of your RealmObjects. Objects within a Realm can be queried and read at any time. Creating, modifying, and deleting objects must be done while inside a transaction. See [executeTransaction(Transaction)](#std-label-io%5Frealm%5FRealm%5FexecuteTransaction%5FTransaction%5F) The transactions ensure that multiple instances (on multiple threads) can access the same objects in a consistent state with full ACID guarantees. It is important to remember to call the **close()** method when done with a Realm instance. Failing to do so can lead to [java.lang.OutOfMemoryError](https://docs.oracle.com/javase/7/docs/api/java/lang/OutOfMemoryError.html) as the native resources cannot be freed.\n\n For the UI thread this means that opening and closing Realms should occur in either onCreate/onDestroy or onStart/onStop. Realm instances coordinate their state across threads using the [android.os.Handler](https://developer.android.com/reference/android/os/Handler) mechanism. This also means that Realm instances on threads without an [android.os.Looper](https://developer.android.com/reference/android/os/Looper) cannot receive updates unless **refresh()** is manually called. A standard pattern for working with Realm in Android activities can be seen below:\n\n ` Realm supports String and byte fields containing up to 16 MB. ## Tip ### See also:  * [ACID](http://en.wikipedia.org/wiki/ACID)\n* [Examples using Realm](https://github.com/realm/realm-java/tree/master/examples) ## Nested Class Summary | Modifier and Type       | Class and Description                                                                                                |\n| ----------------------- | -------------------------------------------------------------------------------------------------------------------- |\n| public static interface | [Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) |\n| public abstract static  | [Realm.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Callback/#std-label-io%5Frealm%5FRealm%5FCallback-1)        | ## Field Summary | Modifier and Type                                                                             | Field and Description                                                                                                                                   |\n| --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static final [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | [DEFAULT\\_REALM\\_NAME](#std-label-io%5Frealm%5FRealm%5FDEFAULT%5FREALM%5FNAME)                                                                          |\n| public static final **int**                                                                   | [ENCRYPTION\\_KEY\\_LENGTH](#std-label-io%5Frealm%5FRealm%5FENCRYPTION%5FKEY%5FLENGTH)The required length for encryption keys used to encrypt Realm data. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class **io.realm.BaseRealm**: `setAutoRefresh` , `isAutoRefresh` , `refresh` , `isInTransaction` , `addListener` , `removeListener` , `asFlowable` , `removeAllListeners` , `writeCopyTo` , `writeEncryptedCopyTo` , `waitForChange` , `stopWaitForChange` , `beginTransaction` , `commitTransaction` , `cancelTransaction` , `freeze` , `isFrozen` , `getNumberOfActiveVersions` , `checkIfValid` , `checkAllowQueriesOnUiThread` , `checkAllowWritesOnUiThread` , `checkIfInTransaction` , `checkIfValidAndInTransaction` , `getPath` , `getConfiguration` , `getVersion` , `close` , `isClosed` , `isEmpty` , `getSchema` , `getSubscriptions` , `deleteAll` , `migrateRealm` , `finalize` ## Field Detail ### `DEFAULT_REALM_NAME` ### `ENCRYPTION_KEY_LENGTH` The required length for encryption keys used to encrypt Realm data. ## Method Detail ### addChangeListener\n\n ### asFlowable\n\n ### compactRealm | public static **boolean** [compactRealm](#std-label-io%5Frealm%5FRealm%5FcompactRealm) ([RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) configuration)                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Compacts a Realm file. A Realm file usually contain free/unused space. This method removes this free space and the file size is thereby reduced. Objects within the Realm files are untouched.The file must be closed before this method is called, otherwise false will be returned.The file system should have free space for at least a copy of the Realm file.The Realm file is left untouched if any file operation fails.**Parameters**configuration \\- a [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) pointing to a Realm file.**Returns**true if successful, false if any file operation failed. | ### copyFromRealm\n\n\n\n\n\n\n\n ### copyToRealm\n\n\n\n ### copyToRealmOrUpdate\n\n\n\n ### createAllFromJson\n\n ### createEmbeddedObject\n\n ### createObject\n\n\n\n ### createObjectFromJson\n\n ### createOrUpdateAllFromJson\n\n ### createOrUpdateObjectFromJson\n\n ### delete | public **void** [delete](#std-label-io%5Frealm%5FRealm%5Fdelete) ([java.lang.Class<? extends io.realm.RealmModel>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) clazz)                                                                                                                  |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deletes all objects of the specified class from the Realm.**Parameters**clazz \\- the class which objects should be removed.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the Realm is closed or called from an incorrect thread. | ### deleteRealm\n\n ### executeTransaction\n\n ### executeTransactionAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [executeTransactionAsync](#std-label-io%5Frealm%5FRealm%5FexecuteTransactionAsync) ([Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) transaction,[Realm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnSuccess/#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnSuccess) onSuccess,[Realm.Transaction.OnError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnError/#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnError) onError)                                                                                                                                                                             |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Similar to [executeTransactionAsync(Transaction)](#std-label-io%5Frealm%5FRealm%5FexecuteTransactionAsync%5FTransaction%5F) , but also accepts an OnSuccess and OnError callbacks.**Parameters**transaction \\- [io.realm.Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) to execute.onSuccess \\- callback invoked when the transaction succeeds.onError \\- callback invoked when the transaction fails.**Returns**a [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) representing a cancellable task.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the transaction is null , or if the realm is opened from another thread. |\n\n | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [executeTransactionAsync](#std-label-io%5Frealm%5FRealm%5FexecuteTransactionAsync) ([Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) transaction,[Realm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/OnSuccess/#std-label-io%5Frealm%5FRealm%5FTransaction%5FOnSuccess) onSuccess)                                                                                                                                                                                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Similar to [executeTransactionAsync(Transaction)](#std-label-io%5Frealm%5FRealm%5FexecuteTransactionAsync%5FTransaction%5F) , but also accepts an OnSuccess callback.**Parameters**transaction \\- [io.realm.Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) to execute.onSuccess \\- callback invoked when the transaction succeeds.**Returns**a [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) representing a cancellable task.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the transaction is null , or if the realm is opened from another thread. |\n\n ### freeze\n\n ### getApplicationContext | public static **Context** [getApplicationContext](#std-label-io%5Frealm%5FRealm%5FgetApplicationContext) ()                                                                                                                                                                                                                                                                                                                                                                                                                            |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Get the application context used when initializing Realm with [Realm.init(Context)](#std-label-io%5Frealm%5FRealm%5Finit%5FContext%5F) or [Realm.init(Context, String)](#std-label-io%5Frealm%5FRealm%5Finit%5FContext%5F%5FString%5F) .**Returns**the application context used when initializing Realm with [Realm.init(Context)](#std-label-io%5Frealm%5FRealm%5Finit%5FContext%5F) or [Realm.init(Context, String)](#std-label-io%5Frealm%5FRealm%5Finit%5FContext%5F%5FString%5F) , or null if Realm has not been initialized yet. | ### getDefaultConfiguration | public static [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) [getDefaultConfiguration](#std-label-io%5Frealm%5FRealm%5FgetDefaultConfiguration) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the default configuration for [getDefaultInstance()](#std-label-io%5Frealm%5FRealm%5FgetDefaultInstance%5F%5F) .**Returns**default configuration object or null if no default configuration is specified.         | ### getDefaultInstance\n\n ### getDefaultModule | public static [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [getDefaultModule](#std-label-io%5Frealm%5FRealm%5FgetDefaultModule) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the default Realm module. This module contains all Realm classes in the current project, but not those from library or project dependencies. Realm classes in these should be exposed using their own module.**Returns**the default Realm module or null if no default module exists.**Throws**[RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) \\- if unable to create an instance of the module.TipSee also: [io.realm.RealmConfiguration.Builder.modules(Object, Object...)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5Fmodules%5FObject%5F%5FObject%5F%5F%5F%5F) | ### getGlobalInstanceCount\n\n ### getInstance\n\n ### getInstanceAsync\n\n ### getLocalInstanceCount | public static **int** [getLocalInstanceCount](#std-label-io%5Frealm%5FRealm%5FgetLocalInstanceCount) ([RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) configuration)                                                                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the current number of open Realm instances on the thread calling this method. This include both dynamic and normal Realms.**Parameters**configuration \\- the [io.realm.RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) for the Realm.**Returns**number of open Realm instances on the caller thread. | ### getSchema\n\n ### init\n\n\n\n ### insert\n\n\n\n ### insertOrUpdate\n\n\n\n ### isEmpty | public **boolean** [isEmpty](#std-label-io%5Frealm%5FRealm%5FisEmpty) ()                                                                                                          |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if this [io.realm.Realm](#std-label-io%5Frealm%5FRealm) contains any objects.**Returns**true if empty, @{code false} otherwise.**Overrides**isEmpty in class **BaseRealm** | ### migrateRealm | public static **void** [migrateRealm](#std-label-io%5Frealm%5FRealm%5FmigrateRealm) ([RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) configuration,[RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/#std-label-io%5Frealm%5FRealmMigration) migration)                                                                                                                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Manually triggers a migration on a RealmMigration.**Parameters**configuration \\- the:ref:RealmConfiguration <io\\_realm\\_RealmConfiguration> .migration \\- the [RealmMigration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmMigration/#std-label-io%5Frealm%5FRealmMigration) to run on the Realm. This will override any migration set on the configuration.**Throws**[FileNotFoundException](https://docs.oracle.com/javase/7/docs/api/java/io/FileNotFoundException.html) \\- if the Realm file doesn't exist. |\n\n ### removeAllChangeListeners | public **void** [removeAllChangeListeners](#std-label-io%5Frealm%5FRealm%5FremoveAllChangeListeners) ()                                                                                                                                                                                                                                                               |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes all user-defined change listeners.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if you try to remove listeners from a non-Looper Thread.TipSee also: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) | ### removeChangeListener\n\n ### removeDefaultConfiguration | public static **void** [removeDefaultConfiguration](#std-label-io%5Frealm%5FRealm%5FremoveDefaultConfiguration) ()                                                                                                                                                                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes the current default configuration (if any). Any further calls to [getDefaultInstance()](#std-label-io%5Frealm%5FRealm%5FgetDefaultInstance%5F%5F) will fail until a new default configuration has been set using [setDefaultConfiguration(RealmConfiguration)](#std-label-io%5Frealm%5FRealm%5FsetDefaultConfiguration%5FRealmConfiguration%5F) . | ### setDefaultConfiguration\n\n ### where | public [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) [where](#std-label-io%5Frealm%5FRealm%5Fwhere) <**E** \\>([java.lang.Class<E>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) clazz)                                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a typed RealmQuery, which can be used to query for specific objects of this type**Parameters**clazz \\- the class of the object which is to be queried for.**Returns**a typed RealmQuery, which can be used to query for specific objects of this type.TipSee also: [io.realm.RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) | ← [Class ProxyState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ProxyState/ \"Previous Section\")[Class Realm.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Callback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.sync\n\n ← [Class Push](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/Push/ \"Previous Section\")[Interface ConnectionListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionListener/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/UserProfile/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class UserProfile On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [getBirthday](#getbirthday)\n* [getEmail](#getemail)\n* [getFirstName](#getfirstname)\n* [getGender](#getgender)\n* [getLastName](#getlastname)\n* [getMaxAge](#getmaxage)\n* [getMinAge](#getminage)\n* [getName](#getname)\n* [getPictureUrl](#getpictureurl)\n* [getUser](#getuser)\n* [hashCode](#hashcode)\n* [toString](#tostring) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.UserProfile ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                            | ### getBirthday | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getBirthday](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetBirthday) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the birthday of the user.**Returns**the birthday of the user or null if there is no birthday associated with the user.                                 | ### getEmail | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getEmail](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetEmail) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the email address of the user.**Returns**the email address of the user or null if there is no email address associated with the user. address.   | ### getFirstName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getFirstName](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetFirstName) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return the first name of the user.**Returns**the first name of the user or null if there is no first name associated with the user.                              | ### getGender | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getGender](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetGender) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the gender of the user.**Returns**the gender of the user or null if there is no gender associated with the user.                                   | ### getLastName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getLastName](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetLastName) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Return the last name of the user.**Returns**the last name of the user or null if there is no last name associated with the user.                               | ### getMaxAge\n\n ### getMinAge | public [Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) [getMinAge](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetMinAge) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the minimum age of the user.**Returns**the minimum age of the user or null if there is no minimum age associated with the user.                | ### getName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getName](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetName) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the name of the user.**Returns**the name of the user.                                                                                          | ### getPictureUrl | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getPictureUrl](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetPictureUrl) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the picture URL of the user.**Returns**the picture URL of the user or null if there is no picture URL associated with the user.                            | ### getUser | public [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) [getUser](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FgetUser) ()                                                                                                                          |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that this instance in associated with.**Returns**The [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that this instance in associated with. | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5FUserProfile%5FhashCode) ()                   |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### toString\n\n ← [Class UserIdentity](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/UserIdentity/ \"Previous Section\")[Exception AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AuthenticationListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface AuthenticationListener On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [loggedIn](#loggedin)\n* [loggedOut](#loggedout) ## io.realm.mongodb Interface describing events related to Users and their authentication ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                           |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public **void**   | [loggedIn](#std-label-io%5Frealm%5Fmongodb%5FAuthenticationListener%5FloggedIn) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user)A user was logged into the Object Server                     |\n| public **void**   | [loggedOut](#std-label-io%5Frealm%5Fmongodb%5FAuthenticationListener%5FloggedOut) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user)A user was successfully logged out from the Object Server. | ## Method Detail ### loggedIn | public **void** [loggedIn](#std-label-io%5Frealm%5Fmongodb%5FAuthenticationListener%5FloggedIn) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| A user was logged into the Object Server**Parameters**user \\- [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that is now logged in.                   | ### loggedOut | public **void** [loggedOut](#std-label-io%5Frealm%5Fmongodb%5FAuthenticationListener%5FloggedOut) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user)          |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| A user was successfully logged out from the Object Server.**Parameters**user \\- [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that was successfully logged out. |\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamTask/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmEventStreamTask On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [getNext](#getnext)\n* [isOpen](#isopen) ## io.realm.mongodb **Implemented interfaces:** * [io.realm.RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) The RealmEventStreamTask is a specific version of [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) that provides a blocking mechanism to work with asynchronous operations carried out against MongoDB Realm that yield stream results. ## Method Summary | Modifier and Type                                                                                                                                                   | Method and Description                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public [BaseChangeEvent](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent) | [getNext](#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamTask%5FgetNext) ()Blocks the thread on which the call is made until the result of the operation arrives. |\n| public **boolean**                                                                                                                                                  | [isOpen](#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamTask%5FisOpen) ()Whether or not the stream is currently open.                                             | ## Inherited Methods ## Method Detail ### getNext\n\n ### isOpen | public **boolean** [isOpen](#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamTask%5FisOpen) () |\n| ----------------------------------------------------------------------------------------------- |\n| Whether or not the stream is currently open.**Returns**true if open, false if not.              | ← [Interface RealmEventStreamAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamAsyncTask/ \"Previous Section\")[Interface RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.auth   \n* [io.realm.mongodb.auth.ApiKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKey/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKey)\n* [io.realm.mongodb.auth.ApiKeyAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKeyAuth/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth)\n* [io.realm.mongodb.auth.EmailPasswordAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/EmailPasswordAuth/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth)\n* [io.realm.mongodb.auth.GoogleAuthType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/GoogleAuthType/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType) ← [Exception AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/ \"Previous Section\")[Class ApiKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKey/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class AppConfiguration On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Nested Class Summary](#nested-class-summary)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [DEFAULT\\_AUTHORIZATION\\_HEADER\\_NAME](#default%5Fauthorization%5Fheader%5Fname)\n* [DEFAULT\\_BASE\\_URL](#default%5Fbase%5Furl)\n* [DEFAULT\\_BSON\\_CODEC\\_REGISTRY](#default%5Fbson%5Fcodec%5Fregistry)\n* [DEFAULT\\_REQUEST\\_TIMEOUT](#default%5Frequest%5Ftimeout)\n* [loginObfuscators](#loginobfuscators)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [getAppId](#getappid)\n* [getAppName](#getappname)\n* [getAppVersion](#getappversion)\n* [getAuthorizationHeaderName](#getauthorizationheadername)\n* [getBaseUrl](#getbaseurl)\n* [getCustomRequestHeaders](#getcustomrequestheaders)\n* [getDefaultClientResetHandler](#getdefaultclientresethandler)\n* [getDefaultCodecRegistry](#getdefaultcodecregistry)\n* [getDefaultErrorHandler](#getdefaulterrorhandler)\n* [getDefaultSyncClientResetStrategy](#getdefaultsyncclientresetstrategy)\n* [getEncryptionKey](#getencryptionkey)\n* [getHttpLogObfuscator](#gethttplogobfuscator)\n* [getRequestTimeoutMs](#getrequesttimeoutms)\n* [getSyncRootDirectory](#getsyncrootdirectory)\n* [hashCode](#hashcode) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.AppConfiguration An AppConfiguration is used to setup a MongoDB Realm application.Instances of an AppConfiguration can only created by using the [AppConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) and calling its [AppConfiguration.Builder.build()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5Fbuild%5F%5F) method. Configuring an App is only required if the default settings are not enough. Otherwise calling `new App(\"app-id\")` is sufficient. ## Nested Class Summary | Modifier and Type | Class and Description                                                                                                                                         |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static     | [AppConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) | ## Field Summary\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `DEFAULT_AUTHORIZATION_HEADER_NAME` The default header name used to carry authorization data when making network requests towards MongoDB Realm. ### `DEFAULT_BASE_URL` The default url for MongoDB Realm applications. ## Tip ### See also:  * [Builder.baseUrl(String)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FbaseUrl%5FString%5F) ### `DEFAULT_BSON_CODEC_REGISTRY` Default BSON codec registry for encoding/decoding arguments and results to/from MongoDB App Services backend.This will encode/decode most primitive types, list and map types and BsonValues. ## Tip ### See also:  * [AppConfiguration.getDefaultCodecRegistry()](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetDefaultCodecRegistry%5F%5F)\n* [AppConfiguration.Builder.codecRegistry(CodecRegistry)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FcodecRegistry%5FCodecRegistry%5F)\n* **ValueCodecProvider**\n* **BsonValueCodecProvider**\n* **IterableCodecProvider**\n* **MapCodecProvider**\n* **DocumentCodecProvider** ### `DEFAULT_REQUEST_TIMEOUT` The default request timeout for network requests towards MongoDB Realm in seconds. ## Tip ### See also:  * [Builder.requestTimeout(long, TimeUnit)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FrequestTimeout%5Flong%5F%5FTimeUnit%5F) ### `loginObfuscators` Default obfuscators for login requests used in a MongoDB Realm app.This map is needed to instantiate the default [HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) , which will keep all login-sensitive information from being shown in Logcat. This map's keys represent the different login identity providers which can be used to authenticate against an app and the values are the concrete obfuscators used for that provider. ## Tip ### See also:  * [Credentials.Provider](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider)\n* **RegexPatternObfuscator**\n* **ApiKeyObfuscator**\n* **TokenObfuscator**\n* **CustomFunctionObfuscator**\n* **EmailPasswordObfuscator**\n* [HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) ## Method Detail ### equals\n\n ### getAppId | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getAppId](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetAppId) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the unique app id that identities the Realm application.**Returns**the app unique identifier.                                                         | ### getAppName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getAppName](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetAppName) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the name used to describe the Realm application. This is only used as debug information.**Returns**the app name.                                          | ### getAppVersion | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getAppVersion](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetAppVersion) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the version of this Realm application. This is only used as debug information.**Returns**the app version.                                                       | ### getAuthorizationHeaderName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getAuthorizationHeaderName](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetAuthorizationHeaderName) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the name of the header used to carry authentication data when making network requests towards MongoDB Realm.**Returns**the authentication header name.                                    | ### getBaseUrl | public [URL](https://docs.oracle.com/javase/7/docs/api/java/net/URL.html) [getBaseUrl](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetBaseUrl) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the base url for this Realm application.**Returns**the app base url.                                                                               | ### getCustomRequestHeaders | public [Map](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) [getCustomRequestHeaders](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetCustomRequestHeaders) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns any custom configured headers that will be sent alongside other headers when making network requests towards MongoDB Realm.**Returns**a Map of custom configured headers.     | ### getDefaultClientResetHandler\n\n ### getDefaultCodecRegistry | public **CodecRegistry** [getDefaultCodecRegistry](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetDefaultCodecRegistry) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the default codec registry used to encode and decode BSON arguments and results when calling remote Realm [io.realm.mongodb.functions.Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions) and accessing a remote [io.realm.mongodb.mongo.MongoDatabase](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase) .**Returns**The default codec registry for the App.TipSee also: [DEFAULT\\_BSON\\_CODEC\\_REGISTRY](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FDEFAULT%5FBSON%5FCODEC%5FREGISTRY)**Builder.getDefaultCodecRegistry()** | ### getDefaultErrorHandler\n\n ### getDefaultSyncClientResetStrategy | public [SyncClientResetStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncClientResetStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncClientResetStrategy) [getDefaultSyncClientResetStrategy](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetDefaultSyncClientResetStrategy) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the default sync client reset strategy used by synced Realms if there are problems with their [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) .**Returns**the app default error handler.                          | ### getEncryptionKey | public **byte** [getEncryptionKey](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetEncryptionKey) ()                                                                                                   |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the encryption key, if any, that is used to encrypt Realm users meta data on this device. If no key is returned, the data is not encrypted.**Returns**the encryption key if exists, or null otherwise. | ### getHttpLogObfuscator | public [HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) [getHttpLogObfuscator](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetHttpLogObfuscator) ()                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) used in the app, which keeps sensitive information in HTTP requests from being displayed in the logcat.**Returns**the HTTP log obfuscator. | ### getRequestTimeoutMs | public **long** [getRequestTimeoutMs](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetRequestTimeoutMs) ()                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the default timeout for network requests against the Realm application in milliseconds.**Returns**the default timeout for network requests in milliseconds. | ### getSyncRootDirectory\n\n ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FhashCode) ()              |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ← [Class App.Result](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Result/ \"Previous Section\")[Class AppConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class App On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Constructors](#constructors)\n* [Nested Class Summary](#nested-class-summary)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [NETWORK\\_POOL\\_EXECUTOR](#network%5Fpool%5Fexecutor)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [addAuthenticationListener](#addauthenticationlistener)\n* [allUsers](#allusers)\n* [currentUser](#currentuser)\n* [equals](#equals)\n* [getConfiguration](#getconfiguration)\n* [getEmailPassword](#getemailpassword)\n* [getFunctions](#getfunctions)\n* [getSync](#getsync)\n* [hashCode](#hashcode)\n* [login](#login)\n* [loginAsync](#loginasync)\n* [removeAuthenticationListener](#removeauthenticationlistener)\n* [removeUser](#removeuser)\n* [setNetworkTransport](#setnetworktransport)\n* [switchUser](#switchuser) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.App An _App_ is the main client-side entry point for interacting with a _MongoDB Realm App_.The _App_ can be used to: * Register uses and perform various user-related operations through authentication providers ([io.realm.mongodb.auth.ApiKeyAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKeyAuth/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth) , **EmailPasswordAuthImpl**)\n* Synchronize data between the local device and a remote Realm App with Synchronized Realms\n* Invoke Realm App functions with [Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions)\n* Access remote data from MongoDB databases with a [io.realm.mongodb.mongo.MongoClient](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoClient) To create an app that is linked with a remote _Realm App_ initialize Realm and configure the _App_ as shown below:\n\n ` After configuring the _App_ you can start managing users, configure Synchronized Realms, call remote Realm Functions and access remote data through Mongo Collections. The examples below show the synchronized APIs which cannot be used from the main thread. For the equivalent asynchronous counterparts. The example project in please see [https://github.com/realm/realm-java/tree/v10/examples/mongoDbRealmExample.](https://github.com/realm/realm-java/tree/v10/examples/mongoDbRealmExample) To register a new user and/or login with an existing user do as shown below: ```java // Register new user APP.getEmailPassword().registerUser(username, password); // Login with existing user User user = APP.login(Credentials.emailPassword(username, password)) \n``` With an authorized user you can synchronize data between the local device and the remote Realm App by opening a Realm with a [io.realm.mongodb.sync.SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) as indicated below: ```java SyncConfiguration syncConfiguration = new SyncConfiguration.Builder(user, \"<partition value>\")          .build(); Realm instance = Realm.getInstance(syncConfiguration); SyncSession session = APP.getSync().getSession(syncConfiguration); instance.executeTransaction(realm -> {     realm.insert(...); }); session.uploadAllLocalChanges(); instance.close(); \n``` You can call remote Realm functions as shown below: ```java Functions functions = user.getFunctions(); Integer sum = functions.callFunction(\"sum\", Arrays.asList(1, 2, 3, 4), Integer.class); \n``` And access collections from the remote Realm App as shown here: ```java MongoClient client = user.getMongoClient(SERVICE_NAME) MongoDatabase database = client.getDatabase(DATABASE_NAME) MongoCollection<DocumentT> collection = database.getCollection(COLLECTION_NAME); Long count = collection.count().get() \n``` ## Tip ### See also:  * [AppConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1)\n* [EmailPasswordAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/EmailPasswordAuth/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth)\n* [io.realm.mongodb.sync.SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration)\n* [User.getFunctions()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetFunctions%5F%5F)\n* [User.getMongoClient(String)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetMongoClient%5FString%5F) ## Constructors\n\n ## Nested Class Summary | Modifier and Type       | Class and Description                                                                                                   |\n| ----------------------- | ----------------------------------------------------------------------------------------------------------------------- |\n| public static           | [App.Result](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Result/#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult)       |\n| public static interface | [App.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) | ## Field Summary | Modifier and Type                                                                                                          | Field and Description                                                                                                                                                                                                                                                                           |\n| -------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static [ThreadPoolExecutor](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html) | [NETWORK\\_POOL\\_EXECUTOR](#std-label-io%5Frealm%5Fmongodb%5FApp%5FNETWORK%5FPOOL%5FEXECUTOR)Thread pool used when doing network requests against MongoDB Realm.This pool is only exposed for testing purposes and replacing it while the queue is not empty will result in undefined behaviour. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `NETWORK_POOL_EXECUTOR` Thread pool used when doing network requests against MongoDB Realm.This pool is only exposed for testing purposes and replacing it while the queue is not empty will result in undefined behaviour. ## Constructor Detail | public [App](#std-label-io%5Frealm%5Fmongodb%5FApp-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) appId) |\n| --------------------------------------------------------------------------------------------------------------------------------------- | | public [App](#std-label-io%5Frealm%5Fmongodb%5FApp-1) ([AppConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration) config)                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Constructor for creating an _App_ according to the given _AppConfiguration_.**Parameters**config \\- The configuration to use for this _App_ instance.TipSee also: [AppConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) | ## Method Detail ### addAuthenticationListener | public **void** [addAuthenticationListener](#std-label-io%5Frealm%5Fmongodb%5FApp%5FaddAuthenticationListener) ([AuthenticationListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AuthenticationListener/#std-label-io%5Frealm%5Fmongodb%5FAuthenticationListener) listener)                                                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets a global authentication listener that will be notified about User events like login and logout.Callbacks to authentication listeners will happen on the UI thread.**Parameters**listener \\- listener to register.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if listener is null . | ### allUsers\n\n ### currentUser | public [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) [currentUser](#std-label-io%5Frealm%5Fmongodb%5FApp%5FcurrentUser) ()                                                                                                                                                                                                                                                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the current user that is logged in and still valid.A user is invalidated when he/she logs out or the user's refresh token expires or is revoked.If two or more users are logged in, it is the last valid user that is returned by this method.**Returns**current [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that has logged in and is still valid. null if no user is logged in or the user has expired. | ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5FApp%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o)                                                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Two Apps are considered equal and will share their underlying state if they both refer to the same [AppConfiguration.getAppId()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetAppId%5F%5F) .**Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### getConfiguration\n\n ### getEmailPassword | public [EmailPasswordAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/EmailPasswordAuth/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth) [getEmailPassword](#std-label-io%5Frealm%5Fmongodb%5FApp%5FgetEmailPassword) ()                                                                                                                                                                                                                                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns a wrapper for interacting with functionality related to users either being created or logged in using the [Credentials.Provider.EMAIL\\_PASSWORD](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider%5FEMAIL%5FPASSWORD) identity provider.**Returns**wrapper for interacting with the [Credentials.Provider.EMAIL\\_PASSWORD](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider%5FEMAIL%5FPASSWORD) identity provider. | ### getFunctions | public [Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions) [getFunctions](#std-label-io%5Frealm%5Fmongodb%5FApp%5FgetFunctions) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user,**CodecRegistry** codecRegistry) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a _Functions_ manager for invoking the Realm App's Realm Functions with a custom codec registry for encoding and decoding arguments and results.TipSee also: [Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions)                                             |\n\n ### getSync | public [Sync](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync) [getSync](#std-label-io%5Frealm%5Fmongodb%5FApp%5FgetSync) ()                                             |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the _Sync_ instance managing the ongoing _Realm Sync_ sessions synchronizing data between the local and the remote _Realm App_ associated with this app.**Returns**the _Sync_ instance associated with this _App_. | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5FApp%5FhashCode) ()                           |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### login\n\n ### loginAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [loginAsync](#std-label-io%5Frealm%5Fmongodb%5FApp%5FloginAsync) ([Credentials](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/#std-label-io%5Frealm%5Fmongodb%5FCredentials) credentials,[io.realm.mongodb.App.Callback<io.realm.mongodb.User>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs in as a user with the given credentials associated with an authentication provider.The user who logs in becomes the current user. Other App functionality acts on behalf of the current user.If there was already a current user, that user is still logged in and can be found in the list returned by [allUsers()](#std-label-io%5Frealm%5Fmongodb%5FApp%5FallUsers%5F%5F) .It is also possible to switch between which user is considered the current user by using [switchUser(User)](#std-label-io%5Frealm%5Fmongodb%5FApp%5FswitchUser%5FUser%5F) .**Parameters**credentials \\- the credentials representing the type of login.callback \\- callback when logging in has completed or failed. The callback will always happen on the same thread as this method is called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if not called on a looper thread. | ### removeAuthenticationListener\n\n ### removeUser | public [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) [removeUser](#std-label-io%5Frealm%5Fmongodb%5FApp%5FremoveUser) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user)                                                                                                                                                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Removes a users credentials from this device. If the user was currently logged in, they will be logged out as part of the process. This is only a local change and does not affect the user state on the server.**Parameters**user \\- to remove**Returns**user that was removed.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if called from the UI thread or if the user was logged in, but could not be logged out. | ### setNetworkTransport | protected **void** [setNetworkTransport](#std-label-io%5Frealm%5Fmongodb%5FApp%5FsetNetworkTransport) (**OsJavaNetworkTransport** transport)                      |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Exposed for testing.Swap the currently configured network transport with the provided one. This should only be done if no network requests are currently running. | ### switchUser\n\n ← [io.realm.mongodb](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ \"Previous Section\")[Interface App.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.functions   \n* [io.realm.mongodb.functions.Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions) ← [Enum GoogleAuthType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/GoogleAuthType/ \"Previous Section\")[Class Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamAsyncTask/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmEventStreamAsyncTask On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [get](#get)\n* [isOpen](#isopen) ## io.realm.mongodb **Implemented interfaces:** * [io.realm.RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) The RealmEventStreamAsyncTask is a specific version of [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) that provides a non-blocking mechanism to work with asynchronous operations carried out against MongoDB Realm that yield stream results. ## Method Summary\n\n ## Inherited Methods ## Method Detail ### get | public **void** [get](#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamAsyncTask%5Fget) ([io.realm.mongodb.App.Callback<io.realm.mongodb.mongo.events.BaseChangeEvent<T>>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                                                                                                                                                           |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Provides a way to subscribe to asynchronous operations via a callback, which handles both results and errors.**Parameters**callback \\- the [App.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) designed to receive event results.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if the stream is already open. | ### isOpen | public **boolean** [isOpen](#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamAsyncTask%5FisOpen) () |\n| ---------------------------------------------------------------------------------------------------- |\n| Whether or not the stream is currently open.**Returns**true if open, false if not.                   | ← [Class ErrorCode.Type](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Type/ \"Previous Section\")[Interface RealmEventStreamTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamTask/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class User On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [getAccessToken](#getaccesstoken)\n* [getApiKeys](#getapikeys)\n* [getApp](#getapp)\n* [getCustomData](#getcustomdata)\n* [getDeviceId](#getdeviceid)\n* [getFunctions](#getfunctions)\n* [getId](#getid)\n* [getIdentities](#getidentities)\n* [getMongoClient](#getmongoclient)\n* [getProfile](#getprofile)\n* [getProviderType](#getprovidertype)\n* [getPush](#getpush)\n* [getRefreshToken](#getrefreshtoken)\n* [getState](#getstate)\n* [hashCode](#hashcode)\n* [isLoggedIn](#isloggedin)\n* [linkCredentials](#linkcredentials)\n* [linkCredentialsAsync](#linkcredentialsasync)\n* [logOut](#logout)\n* [logOutAsync](#logoutasync)\n* [refreshCustomData](#refreshcustomdata)\n* [remove](#remove)\n* [removeAsync](#removeasync) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.User A _user_ holds the user's meta data and tokens for accessing Realm App functionality.The user is used to configure Synchronized Realms and gives access to calling Realm App _Functions_ through [Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions) and accessing remote Realm App _Mongo Databases_ through a [MongoClient](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoClient) . ## Tip ### See also:  * [App.login(Credentials)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5Flogin%5FCredentials%5F)\n* **io.realm.mongodb.sync.SyncConfiguration.Builder.Builder(User, String)** ## Nested Class Summary | Modifier and Type   | Class and Description                                                                                             |\n| ------------------- | ----------------------------------------------------------------------------------------------------------------- |\n| public static final | [User.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/State/#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5FUser%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o)                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Two Users are considered equal if they have the same user identity and are associated with the same app.**Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### getAccessToken | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getAccessToken](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetAccessToken) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the current access token for the user.**Returns**the current access token.                                                                            | ### getApiKeys | public synchronized [ApiKeyAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKeyAuth/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth) [getApiKeys](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetApiKeys) ()                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns a wrapper for managing API keys controlled by the current user.**Returns**wrapper for managing API keys controlled by the current user.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if no user is currently logged in. | ### getApp\n\n ### getCustomData | public **Document** [getCustomData](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetCustomData) ()                                                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Return the custom user data associated with the user in the Realm App.The data is only refreshed when the user's access token is refreshed or when explicitly calling [refreshCustomData()](#std-label-io%5Frealm%5Fmongodb%5FUser%5FrefreshCustomData%5F%5F) .**Returns**The custom user data associated with the user. | ### getDeviceId | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getDeviceId](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetDeviceId) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a unique identifier for the device the user logged in to.**Returns**a unique device identifier for the user.                                    | ### getFunctions | public [Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions) [getFunctions](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetFunctions) (**CodecRegistry** codecRegistry)                                                                                                                                                                           |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a _functions_ manager for invoking Realm Functions with custom codec registry for encoding and decoding arguments and results.**Parameters**codecRegistry \\- The codec registry to use for encoding and decoding arguments and results towards the remote Realm App.TipSee also: [Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions) |\n\n ### getId | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getId](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetId) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the server id of the user.**Returns**the server id of the user.                                                                     | ### getIdentities | public [List](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) [getIdentities](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetIdentities) ()                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a new list of the user's identities.**Returns**the list of identities.TipSee also: [UserIdentity](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/UserIdentity/#std-label-io%5Frealm%5Fmongodb%5FUserIdentity) | ### getMongoClient | public synchronized [MongoClient](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoClient) [getMongoClient](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetMongoClient) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) serviceName) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a [MongoClient](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoClient) instance for accessing documents in the database.**Parameters**serviceName \\- the service name used to connect to the server.                                               | ### getProfile | public [UserProfile](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/UserProfile/#std-label-io%5Frealm%5Fmongodb%5FUserProfile) [getProfile](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetProfile) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the profile for this user.**Returns**the profile for this user                                                                                                                         | ### getProviderType\n\n ### getPush | public synchronized [Push](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/Push/#std-label-io%5Frealm%5Fmongodb%5Fpush%5FPush-1) [getPush](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetPush) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) serviceName) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [Push](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/Push/#std-label-io%5Frealm%5Fmongodb%5Fpush%5FPush-1) instance for managing push notification registrations.**Parameters**serviceName \\- the service name used to connect to the server.                          | ### getRefreshToken | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getRefreshToken](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetRefreshToken) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the current refresh token for the user.**Returns**the current refresh token.                                                                            | ### getState | public [User.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/State/#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) [getState](#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetState) ()                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/State/#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) the user is in.**Returns**the [State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/State/#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) of the user. | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5FUser%5FhashCode) ()                          |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### isLoggedIn\n\n ### linkCredentials\n\n ### linkCredentialsAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [linkCredentialsAsync](#std-label-io%5Frealm%5Fmongodb%5FUser%5FlinkCredentialsAsync) ([Credentials](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/#std-label-io%5Frealm%5Fmongodb%5FCredentials) credentials,[io.realm.mongodb.App.Callback<io.realm.mongodb.User>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Links the current user with a new user identity represented by the given credentials.Linking a user with more credentials, mean the user can login either of these credentials. It also makes it possible to \"upgrade\" an anonymous user by linking it with e.g. Email/Password credentials.// ExampleApp app \\= new App(\"app-id\")User user \\= app.login(Credentials.anonymous());user.linkCredentials(Credentials.emailPassword(\"email\", \"password\"));Note: It is not possible to link two existing users of MongoDB Realm. The provided credentials must not have been used by another user.**Parameters**credentials \\- the credentials to link with the current user.callback \\- callback when user identities has been linked or it failed. The callback will always happen on the same thread as this method is called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread. | ### logOut\n\n ### logOutAsync\n\n ### refreshCustomData | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [refreshCustomData](#std-label-io%5Frealm%5Fmongodb%5FUser%5FrefreshCustomData) ([io.realm.mongodb.App.Callback<Document>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                                                                                                                                            |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Re-fetch custom user data from the Realm App asynchronously.This is the asynchronous variant of [refreshCustomData()](#std-label-io%5Frealm%5Fmongodb%5FUser%5FrefreshCustomData%5F%5F) .**Parameters**callback \\- The callback that will receive the result or any errors from the request.**Returns**The task representing the ongoing operation.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if not called on a looper thread. | | public **Document** [refreshCustomData](#std-label-io%5Frealm%5Fmongodb%5FUser%5FrefreshCustomData) ()                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Re-fetch custom user data from the Realm App.**Returns**The updated custom user data associated with the user.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the request failed in some way. | ### remove\n\n ### removeAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [removeAsync](#std-label-io%5Frealm%5Fmongodb%5FUser%5FremoveAsync) ([io.realm.mongodb.App.Callback<io.realm.mongodb.User>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                                                                                                                                                                                                   |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Calling this will asynchronously remove the user and any Realms the user has from the device. No data is removed from the server. If the user is logged in when calling this method, the user is logged out before any data is deleted.**Parameters**callback \\- callback when removing the user has completed or failed. The callback will always happen on the same thread as this method is called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread. | ← [Interface RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/ \"Previous Section\")[Enum User.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/State/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Exception AppException On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getCategory](#getcategory)\n* [getErrorCode](#geterrorcode)\n* [getErrorIntValue](#geterrorintvalue)\n* [getErrorMessage](#geterrormessage)\n* [getErrorType](#geterrortype)\n* [getException](#getexception)\n* [toString](#tostring) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [java.lang.Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) [java.lang.RuntimeException](https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) io.realm.mongodb.AppException This class is a wrapper for all errors happening when communicating with a MongoDB Realm app. This include both exceptions and protocol errors. Only [getErrorCode()](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetErrorCode%5F%5F) is guaranteed to contain a value. If the error was caused by an underlying exception [getErrorMessage()](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetErrorMessage%5F%5F) is `null` and [getException()](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetException%5F%5F) is set, while if the error was a protocol error [getErrorMessage()](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetErrorMessage%5F%5F) is set and [getException()](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetException%5F%5F) is null. ## Tip ### See also:  * [ErrorCode for a list of possible errors.](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ## Constructors\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) : `getMessage` , `getLocalizedMessage` , `getCause` , `initCause` , `toString` , `printStackTrace` , `printStackTrace` , `printStackTrace` , `fillInStackTrace` , `getStackTrace` , `setStackTrace` , `addSuppressed` , `getSuppressed` ## Constructor Detail | public [AppException](#std-label-io%5Frealm%5Fmongodb%5FAppException-1) ([ErrorCode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode) errorCode,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) errorMessage) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Create an error caused by an error in the protocol when communicating with the Object Server.**Parameters**errorCode \\- error code for this type of error.errorMessage \\- detailed error message.                                                                                       |\n\n | public [AppException](#std-label-io%5Frealm%5Fmongodb%5FAppException-1) ([ErrorCode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode) errorCode,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Create an error caused by an an exception when communicating with the Object Server.**Parameters**errorCode \\- error code for this type of error.exception \\- underlying exception causing this error.                                                                                     | | public [AppException](#std-label-io%5Frealm%5Fmongodb%5FAppException-1) ([ErrorCode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode) errorCode,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) title,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) hint) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Errors happening while trying to authenticate a user.**Parameters**errorCode \\- error code for this type of error.title \\- title for this type of error.hint \\- a hint for resolving the error.                                                                                                                                                                 | | public [AppException](#std-label-io%5Frealm%5Fmongodb%5FAppException-1) ([ErrorCode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode) errorCode,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) errorMessage,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Generic error happening that could happen anywhere.**Parameters**errorCode \\- error code for this type of error.errorMessage \\- detailed error message.exception \\- underlying exception if the error was caused by this.                                                                                                                                                         |\n\n ## Method Detail ### getCategory | public [ErrorCode.Category](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) [getCategory](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetCategory) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [ErrorCode.Category](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) category for this error. Errors that are [ErrorCode.Category.RECOVERABLE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory%5FRECOVERABLE) mean that it is still possible for a given [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) to resume synchronization. [ErrorCode.Category.FATAL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory%5FFATAL) errors means that session has stopped and cannot be recovered.**Returns**the error category. | ### getErrorCode\n\n ### getErrorIntValue | public **int** [getErrorIntValue](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetErrorIntValue) ()                                                                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns an integer representing this specific type of error. This value is only unique within the value provided by [getErrorType()](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetErrorType%5F%5F) .**Returns**the integer value representing this type of error. | ### getErrorMessage | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getErrorMessage](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetErrorMessage) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a more detailed error message about the cause of this error.**Returns**a detailed error message or null if one was not available.                               | ### getErrorType | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getErrorType](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetErrorType) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a string describing the type of error it is.**Returns**                                                                                                   | ### getException | public [Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [getException](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FgetException) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the underlying exception causing this error, if any.**Returns**the underlying exception causing this error, or null if not caused by an exception.              | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5FAppException%5FtoString) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html)                                            | ← [Class UserProfile](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/UserProfile/ \"Previous Section\")[io.realm.mongodb.auth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.push   \n* [io.realm.mongodb.push.Push](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/Push/#std-label-io%5Frealm%5Fmongodb%5Fpush%5FPush-1) ← [Class UpdateResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/UpdateResult/ \"Previous Section\")[Class Push](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/Push/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/State/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum User.State On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [LOGGED\\_IN](#logged%5Fin)\n* [LOGGED\\_OUT](#logged%5Fout)\n* [REMOVED](#removed)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.User.State **Enclosing class:** [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) The user's potential states. ## Enum Constant Summary | Enum Constant and Description                                                |\n| ---------------------------------------------------------------------------- |\n| [LOGGED\\_IN](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState%5FLOGGED%5FIN)   |\n| [LOGGED\\_OUT](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState%5FLOGGED%5FOUT) |\n| [REMOVED](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState%5FREMOVED)          | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `LOGGED_IN` public static final [User.State](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) ### `LOGGED_OUT` public static final [User.State](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) ### `REMOVED` public static final [User.State](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) ## Method Detail ### valueOf | public static [User.State](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) [valueOf](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [User.State](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState) [values](#std-label-io%5Frealm%5Fmongodb%5FUser%5FState%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/ \"Previous Section\")[Class UserIdentity](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/UserIdentity/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncClientResetStrategy/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SyncClientResetStrategy On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync) ## io.realm.mongodb.sync Interface that defines a generic sync client reset strategy, it could be either [ManuallyRecoverUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ManuallyRecoverUnsyncedChangesStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FManuallyRecoverUnsyncedChangesStrategy) or [DiscardUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/DiscardUnsyncedChangesStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FDiscardUnsyncedChangesStrategy) . ← [Class Sync.Debug](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/Debug/ \"Previous Section\")[Class SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmQuery On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [alwaysFalse](#alwaysfalse)\n* [alwaysTrue](#alwaystrue)\n* [and](#and)\n* [average](#average)\n* [averageDecimal128](#averagedecimal128)\n* [averageRealmAny](#averagerealmany)\n* [beginGroup](#begingroup)\n* [beginsWith](#beginswith)\n* [between](#between)\n* [contains](#contains)\n* [containsEntry](#containsentry)\n* [containsKey](#containskey)\n* [containsValue](#containsvalue)\n* [count](#count)\n* [distinct](#distinct)\n* [endGroup](#endgroup)\n* [endsWith](#endswith)\n* [equalTo](#equalto)\n* [findAll](#findall)\n* [findAllAsync](#findallasync)\n* [findFirst](#findfirst)\n* [findFirstAsync](#findfirstasync)\n* [getDescription](#getdescription)\n* [getQueryPointer](#getquerypointer)\n* [getRealm](#getrealm)\n* [getTypeQueried](#gettypequeried)\n* [greaterThan](#greaterthan)\n* [greaterThanOrEqualTo](#greaterthanorequalto)\n* [in](#in)\n* [isEmpty](#isempty)\n* [isNotEmpty](#isnotempty)\n* [isNotNull](#isnotnull)\n* [isNull](#isnull)\n* [isValid](#isvalid)\n* [lessThan](#lessthan)\n* [lessThanOrEqualTo](#lessthanorequalto)\n* [like](#like)\n* [limit](#limit)\n* [max](#max)\n* [maxRealmAny](#maxrealmany)\n* [maximumDate](#maximumdate)\n* [min](#min)\n* [minRealmAny](#minrealmany)\n* [minimumDate](#minimumdate)\n* [not](#not)\n* [notEqualTo](#notequalto)\n* [or](#or)\n* [rawPredicate](#rawpredicate)\n* [sort](#sort)\n* [sum](#sum) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.RealmQuery A RealmQuery encapsulates a query on a [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) or a [io.realm.RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) using the Builder pattern. The query is executed using either [findAll()](#std-label-io%5Frealm%5FRealmQuery%5FfindAll%5F%5F) or [findFirst()](#std-label-io%5Frealm%5FRealmQuery%5FfindFirst%5F%5F) . The input to many of the query functions take a field name as String. Note that this is not type safe. If a RealmObject class is refactored care has to be taken to not break any queries.\n\n A RealmQuery cannot be passed between different threads. Results are obtained quickly most of the times. However, launching heavy queries from the UI thread may result in a drop of frames or even ANRs. If you want to prevent these behaviors, you can instantiate a Realm using a [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) that explicitly sets [RealmConfiguration.Builder.allowQueriesOnUiThread(boolean)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FallowQueriesOnUiThread%5Fboolean%5F) to `false` . This way queries will be forced to be launched from a non-UI thread. Alternatively, you can also use [findAllAsync()](#std-label-io%5Frealm%5FRealmQuery%5FfindAllAsync%5F%5F) or [findFirstAsync()](#std-label-io%5Frealm%5FRealmQuery%5FfindFirstAsync%5F%5F) . ## Tip ### See also:  * [Builder pattern](http://en.wikipedia.org/wiki/Builder%5Fpattern)\n* [Realm.where(Class)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5Fwhere%5FClass%5F)\n* [RealmResults.where()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults%5Fwhere%5F%5F) ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### alwaysFalse | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [alwaysFalse](#std-label-io%5Frealm%5FRealmQuery%5FalwaysFalse) () |\n| -------------------------------------------------------------------------------------------------------------------------- |\n| This predicate will never match, resulting in the query always returning 0 results.                                        | ### alwaysTrue | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [alwaysTrue](#std-label-io%5Frealm%5FRealmQuery%5FalwaysTrue) () |\n| ------------------------------------------------------------------------------------------------------------------------ |\n| This predicate will always match.                                                                                        | ### and | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [and](#std-label-io%5Frealm%5FRealmQuery%5Fand) ()                                                                              |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logical-and two conditions Realm automatically applies logical-and between all query statements, so this is intended only as a mean to increase readability.**Returns**the query object | ### average\n\n ### averageDecimal128\n\n ### averageRealmAny\n\n ### beginGroup | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [beginGroup](#std-label-io%5Frealm%5FRealmQuery%5FbeginGroup) ()                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Begin grouping of conditions (\"left parenthesis\"). A group must be closed with a call to endGroup() .**Returns**the query object.TipSee also: [endGroup()](#std-label-io%5Frealm%5FRealmQuery%5FendGroup%5F%5F) | ### beginsWith | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [beginsWith](#std-label-io%5Frealm%5FRealmQuery%5FbeginsWith) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value,[Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase) casing)                                                                                                                                                                    |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that the value of field begins with the specified substring.**Parameters**fieldName \\- the field to compare.value \\- the substring.casing \\- how to handle casing. Setting this to [Case.INSENSITIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase%5FINSENSITIVE) only works for Latin-1 characters.**Returns**the query object**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [beginsWith](#std-label-io%5Frealm%5FRealmQuery%5FbeginsWith) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value)                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Condition that the value of field begins with the specified string.**Parameters**fieldName \\- the field to compare.value \\- the string.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [beginsWith](#std-label-io%5Frealm%5FRealmQuery%5FbeginsWith) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value)                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Condition that the value of field begins with the specified string.**Parameters**fieldName \\- the field to compare.value \\- the string.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | ### between | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [between](#std-label-io%5Frealm%5FRealmQuery%5Fbetween) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** from,**Decimal128** to)                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Between condition.**Parameters**fieldName \\- the field to compare.from \\- lowest value (inclusive).to \\- highest value (inclusive).**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [between](#std-label-io%5Frealm%5FRealmQuery%5Fbetween) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) from,[Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) to)      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Between condition.**Parameters**fieldName \\- the field to compare.from \\- lowest value (inclusive).to \\- highest value (inclusive).**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [between](#std-label-io%5Frealm%5FRealmQuery%5Fbetween) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**float** from,**float** to)                                                                                                                              |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Between condition.**Parameters**fieldName \\- the field to compare.from \\- lowest value (inclusive).to \\- highest value (inclusive).**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [between](#std-label-io%5Frealm%5FRealmQuery%5Fbetween) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**double** from,**double** to)                                                                                                                            |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Between condition.**Parameters**fieldName \\- the field to compare.from \\- lowest value (inclusive).to \\- highest value (inclusive).**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [between](#std-label-io%5Frealm%5FRealmQuery%5Fbetween) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**int** from,**int** to)                                                                                                                                  |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Between condition.**Parameters**fieldName \\- the field to compare.from \\- lowest value (inclusive).to \\- highest value (inclusive).**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | ### contains | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [contains](#std-label-io%5Frealm%5FRealmQuery%5Fcontains) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value,[Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase) casing)                                                                                                                                                                  |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value of field contains the specified substring.**Parameters**fieldName \\- the field to compare.value \\- the substring.casing \\- how to handle casing. Setting this to [Case.INSENSITIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase%5FINSENSITIVE) only works for Latin-1 characters.**Returns**The query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [contains](#std-label-io%5Frealm%5FRealmQuery%5Fcontains) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value)                                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value of field contains the specified substring.**Parameters**fieldName \\- the field to compare.value \\- the substring.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [contains](#std-label-io%5Frealm%5FRealmQuery%5Fcontains) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value)                                                                           |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value of field contains the specified substring.**Parameters**fieldName \\- the field to compare.value \\- the substring.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | ### containsEntry | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsEntry](#std-label-io%5Frealm%5FRealmQuery%5FcontainsEntry) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[java.util.Map.Entry<java.lang.String, ?>](https://docs.oracle.com/javase/7/docs/api/java/util/Map/Entry.html) entry)                     |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified entry.**Parameters**fieldName \\- the field to compare.entry \\- the entry to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. | ### containsKey\n\n ### containsValue | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                                       |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** value)                                                                                                                     |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) value)                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value)                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Float](https://docs.oracle.com/javase/7/docs/api/java/lang/Float.html) value)                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Double](https://docs.oracle.com/javase/7/docs/api/java/lang/Double.html) value)                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Integer](https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html) value)                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Short](https://docs.oracle.com/javase/7/docs/api/java/lang/Short.html) value)                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [containsValue](#std-label-io%5Frealm%5FRealmQuery%5FcontainsValue) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Byte](https://docs.oracle.com/javase/7/docs/api/java/lang/Byte.html) value)                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that value, if a dictionary field, contains the specified value.**Parameters**fieldName \\- the field to compare.value \\- the value to search for.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid. |\n\n ### count | public **long** [count](#std-label-io%5Frealm%5FRealmQuery%5Fcount) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Counts the number of objects that fulfill the query conditions.**Returns**the number of matching objects.**Throws**[java.lang.UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if the query is not valid (\"syntax error\").[RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) \\- if called from the UI thread after opting out via [RealmConfiguration.Builder.allowQueriesOnUiThread(boolean)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FallowQueriesOnUiThread%5Fboolean%5F) . | ### distinct\n\n ### endGroup | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [endGroup](#std-label-io%5Frealm%5FRealmQuery%5FendGroup) ()                                                                                        |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| End grouping of conditions (\"right parenthesis\") which was opened by a call to beginGroup() .**Returns**the query object.TipSee also: [beginGroup()](#std-label-io%5Frealm%5FRealmQuery%5FbeginGroup%5F%5F) | ### endsWith | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [endsWith](#std-label-io%5Frealm%5FRealmQuery%5FendsWith) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value,[Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase) casing)                                                                                                                                                                       |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that the value of field ends with the specified substring.**Parameters**fieldName \\- the field to compare.value \\- the substring.casing \\- how to handle casing. Setting this to [Case.INSENSITIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase%5FINSENSITIVE) only works for Latin-1 characters.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [endsWith](#std-label-io%5Frealm%5FRealmQuery%5FendsWith) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value)                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that the value of field ends with the specified string.**Parameters**fieldName \\- the field to compare.value \\- the string.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [endsWith](#std-label-io%5Frealm%5FRealmQuery%5FendsWith) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value)                                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that the value of field ends with the specified string.**Parameters**fieldName \\- the field to compare.value \\- the string.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | ### equalTo | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [equalTo](#std-label-io%5Frealm%5FRealmQuery%5FequalTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                           |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [equalTo](#std-label-io%5Frealm%5FRealmQuery%5FequalTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value,[Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase) casing)                                                                                                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.casing \\- how to handle casing. Setting this to [Case.INSENSITIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase%5FINSENSITIVE) only works for Latin-1 characters.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [equalTo](#std-label-io%5Frealm%5FRealmQuery%5FequalTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value,[Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase) casing)                                                                                                                                                   |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.casing \\- how to handle casing. Setting this to [Case.INSENSITIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase%5FINSENSITIVE) only works for Latin-1 characters.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n ### findAll\n\n ### findAllAsync | public [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) [findAllAsync](#std-label-io%5Frealm%5FRealmQuery%5FfindAllAsync) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds all objects that fulfill the query conditions. This method is only available from a Looper thread.**Returns**immediately an empty [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) . Users need to register a listener [io.realm.RealmResults.addChangeListener(RealmChangeListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults%5FaddChangeListener%5FRealmChangeListener%5F) to be notified when the query completes.TipSee also: [io.realm.RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) | ### findFirst\n\n ### findFirstAsync\n\n ### getDescription | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getDescription](#std-label-io%5Frealm%5FRealmQuery%5FgetDescription) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a textual description of this query.**Returns**the textual description of the query.                                                              | ### getQueryPointer | public **long** [getQueryPointer](#std-label-io%5Frealm%5FRealmQuery%5FgetQueryPointer) ()                                                                                                                                                                        |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the pointer to the underlying C++ query. This method is only public due to architectural design choices that are hard to work around and should be considered internal and can change without warning.**Returns**the pointer to the underlying C++ query. | ### getRealm\n\n ### getTypeQueried | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getTypeQueried](#std-label-io%5Frealm%5FRealmQuery%5FgetTypeQueried) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the internal Realm name of the type being queried.**Returns**the internal name of the Realm model class being queried.                            | ### greaterThan | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThan](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                       |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThan](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** value)                                                                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThan](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) value)                                              |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThan](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**float** value)                                                                                                          |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThan](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**double** value)                                                                                                         |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThan](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**int** value)                                                                                                            |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | ### greaterThanOrEqualTo | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThanOrEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThanOrEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                 |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than-or-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThanOrEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThanOrEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** value)                                                                                               |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than-or-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThanOrEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThanOrEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**float** value)                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than-or-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThanOrEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThanOrEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**double** value)                                                                                                   |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than-or-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [greaterThanOrEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FgreaterThanOrEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**long** value)                                                                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Greater-than-or-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n ### in | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [in](#std-label-io%5Frealm%5FRealmQuery%5Fin) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[io.realm.RealmAny\\[\\]](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) values)                                                                                                                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| In comparison. This allows you to test if objects match any value in an array of values.**Parameters**fieldName \\- the field to compare.values \\- array of values to compare with. If null or the empty array is provided the query will never match any results.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field isn't a Date field. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [in](#std-label-io%5Frealm%5FRealmQuery%5Fin) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[java.util.Date\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) values)                                                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| In comparison. This allows you to test if objects match any value in an array of values.**Parameters**fieldName \\- the field to compare.values \\- array of values to compare with. If null or the empty array is provided the query will never match any results.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field isn't a Date field. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [in](#std-label-io%5Frealm%5FRealmQuery%5Fin) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[java.lang.Float\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Float.html) values)                                                                                                                                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| In comparison. This allows you to test if objects match any value in an array of values.**Parameters**fieldName \\- the field to compare.values \\- array of values to compare with. If null or the empty array is provided the query will never match any results.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field isn't a Float field. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [in](#std-label-io%5Frealm%5FRealmQuery%5Fin) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[java.lang.Double\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Double.html) values)                                                                                                                                                                                  |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| In comparison. This allows you to test if objects match any value in an array of values.**Parameters**fieldName \\- the field to compare.values \\- array of values to compare with. If null or the empty array is provided the query will never match any results.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field isn't a Double field. empty. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [in](#std-label-io%5Frealm%5FRealmQuery%5Fin) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[java.lang.Integer\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html) values)                                                                                                                                                                          |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| In comparison. This allows you to test if objects match any value in an array of values.**Parameters**fieldName \\- the field to compare.values \\- array of values to compare with. If null or the empty array is provided the query will never match any results.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field isn't a Integer field. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [in](#std-label-io%5Frealm%5FRealmQuery%5Fin) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[java.lang.Short\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Short.html) values)                                                                                                                                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| In comparison. This allows you to test if objects match any value in an array of values.**Parameters**fieldName \\- the field to compare.values \\- array of values to compare with. If null or the empty array is provided the query will never match any results.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field isn't a Short field. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [in](#std-label-io%5Frealm%5FRealmQuery%5Fin) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[java.lang.String\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) values,[Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase) casing)                                                                                                                                                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| In comparison. This allows you to test if objects match any value in an array of values.**Parameters**fieldName \\- the field to compare.values \\- array of values to compare with. If null or the empty array is provided the query will never match any results.casing \\- how casing is handled. [Case.INSENSITIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase%5FINSENSITIVE) works only for the Latin-1 characters.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field isn't a String field. |\n\n ### isEmpty | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [isEmpty](#std-label-io%5Frealm%5FRealmQuery%5FisEmpty) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that finds values that are considered \"empty\" i.e., an empty list, the 0-length string or byte array.**Parameters**fieldName \\- the field to compare.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid or its type isn't either a RealmList, String or byte array. | ### isNotEmpty | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [isNotEmpty](#std-label-io%5Frealm%5FRealmQuery%5FisNotEmpty) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                         |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that finds values that are considered \"Not-empty\" i.e., a list, a string or a byte array with not-empty values.**Parameters**fieldName \\- the field to compare.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name isn't valid or its type isn't either a RealmList, String or byte array. | ### isNotNull\n\n ### isNull | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [isNull](#std-label-io%5Frealm%5FRealmQuery%5FisNull) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Tests if a field is null . Only works for nullable fields.For link queries, if any part of the link path is null the whole path is considered to be null e.g., isNull(\"linkField.stringField\") will be considered to be null if either linkField or linkField.stringField is null .**Parameters**fieldName \\- the field name.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field is not nullable.TipSee also: [Required for further infomation.](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/Required/#std-label-io%5Frealm%5Fannotations%5FRequired) | ### isValid\n\n ### lessThan | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [lessThan](#std-label-io%5Frealm%5FRealmQuery%5FlessThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                          |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Less-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [lessThan](#std-label-io%5Frealm%5FRealmQuery%5FlessThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** value)                                                                                                        |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Less-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [lessThan](#std-label-io%5Frealm%5FRealmQuery%5FlessThan) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**long** value)                                                                                                              |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Less-than comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n ### lessThanOrEqualTo | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [lessThanOrEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FlessThanOrEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Less-than-or-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [lessThanOrEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FlessThanOrEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** value)                                                                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Less-than-or-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [lessThanOrEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FlessThanOrEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**long** value)                                                                                                        |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Less-than-or-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n ### like | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [like](#std-label-io%5Frealm%5FRealmQuery%5Flike) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value,[Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase) casing)                                                                                                                                                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Condition that the value of field matches with the specified substring, with wildcards:'\\*' matches \\[0, n\\] unicode chars'?' matches a single unicode char.**Parameters**fieldName \\- the field to compare.value \\- the wildcard string.casing \\- how to handle casing. Setting this to [Case.INSENSITIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase%5FINSENSITIVE) only works for Latin-1 characters.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [like](#std-label-io%5Frealm%5FRealmQuery%5Flike) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) value)                                                                                                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that the value of field matches with the specified substring, with wildcards:'\\*' matches \\[0, n\\] unicode chars'?' matches a single unicode char.**Parameters**fieldName \\- the field to compare.value \\- the wildcard string.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [like](#std-label-io%5Frealm%5FRealmQuery%5Flike) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value)                                                                                                                                                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Condition that the value of field matches with the specified substring, with wildcards:'\\*' matches \\[0, n\\] unicode chars'?' matches a single unicode char.**Parameters**fieldName \\- the field to compare.value \\- the wildcard string.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | ### limit\n\n ### max\n\n ### maxRealmAny\n\n ### maximumDate | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [maximumDate](#std-label-io%5Frealm%5FRealmQuery%5FmaximumDate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName)                                                                                                                                                                                                                                                                         |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds the maximum value of a field.**Parameters**fieldName \\- the field name.**Returns**if no objects exist or they all have null as the value for the given date field, null will be returned. Otherwise the maximum date is returned. When determining the maximum date, objects with null values are ignored.**Throws**[java.lang.UnsupportedOperationException](https://docs.oracle.com/javase/7/docs/api/java/lang/UnsupportedOperationException.html) \\- if the query is not valid (\"syntax error\"). | ### min\n\n ### minRealmAny\n\n ### minimumDate\n\n ### not | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [not](#std-label-io%5Frealm%5FRealmQuery%5Fnot) () |\n| ---------------------------------------------------------------------------------------------------------- |\n| Negate condition.**Returns**the query object.                                                              | ### notEqualTo | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [notEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FnotEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**ObjectId** value)                                                                                                         |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Not-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [notEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FnotEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,**Decimal128** value)                                                                                                       |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Not-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [notEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FnotEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value,[Case](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase) casing)                                                                                                                                      |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Not-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.casing \\- how casing is handled. [Case.INSENSITIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Case/#std-label-io%5Frealm%5FCase%5FINSENSITIVE) works only for the Latin-1 characters.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [notEqualTo](#std-label-io%5Frealm%5FRealmQuery%5FnotEqualTo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) value)                                            |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Not-equal-to comparison.**Parameters**fieldName \\- the field to compare.value \\- the value to compare with.**Returns**the query object.**Throws**[java.lang.IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if one or more arguments do not match class or field type. | ### or | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [or](#std-label-io%5Frealm%5FRealmQuery%5For) () |\n| -------------------------------------------------------------------------------------------------------- |\n| Logical-or two conditions.**Returns**the query object.                                                   | ### rawPredicate\n\n ### sort | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [sort](#std-label-io%5Frealm%5FRealmQuery%5Fsort) ([java.lang.String\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldNames,[io.realm.Sort\\[\\]](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrders)                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sorts the query result by the specific field names in the provided orders. Later fields will only be used if the previous field values are equal.Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A', 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.**Parameters**fieldNames \\- an array of field names to sort by.sortOrders \\- how to sort the field names.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name does not exist.[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if a sorting order was already defined. |\n\n | public [RealmQuery](#std-label-io%5Frealm%5FRealmQuery) [sort](#std-label-io%5Frealm%5FRealmQuery%5Fsort) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fieldName,[Sort](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Sort/#std-label-io%5Frealm%5FSort) sortOrder)                                                                                                                                                                                                                                                                                                                                                                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sorts the query result by the specified field name and order.Sorting is currently limited to character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A', 'Latin Extended B' (UTF-8 range 0-591). For other character sets, sorting will have no effect.**Parameters**fieldName \\- the field name to sort by.sortOrder \\- how to sort the results.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the field name does not exist.[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if a sorting order was already defined. |\n\n ### sum\n\n ← [Interface RealmObjectSchema.Function](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/Function/ \"Previous Section\")[Class RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmResultTask On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [get](#get)\n* [getAsync](#getasync) ## io.realm.mongodb **Implemented interfaces:** * [io.realm.RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) The RealmResultTask is a specific version of [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) that provides a mechanism to work with asynchronous operations carried out against MongoDB Realm that yield a result. This class offers both blocking (`get` ) and non-blocking (`getAsync` ) method calls. ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                                                                       |\n| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **T**      | [get](#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask%5Fget) ()Blocks the thread on which the call is made until the result of the operation arrives.                                                                                                                                                                                      |\n| public **void**   | [getAsync](#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask%5FgetAsync) ([io.realm.mongodb.App.Callback<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)Provides a way to subscribe to asynchronous operations via a callback, which handles both results and errors. |\n\n ## Method Detail ### get | public **T** [get](#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask%5Fget) ()                                                                      |\n| --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Blocks the thread on which the call is made until the result of the operation arrives.**Returns**the result of the operation executed by this task. | ### getAsync | public **void** [getAsync](#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask%5FgetAsync) ([io.realm.mongodb.App.Callback<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                                                                                                                                                                                                                                                                                                                                                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Provides a way to subscribe to asynchronous operations via a callback, which handles both results and errors.**Parameters**callback \\- the [App.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) designed to receive results.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a thread without a [android.os.Looper](https://developer.android.com/reference/android/os/Looper) or from an [android.app.IntentService](https://developer.android.com/reference/android/app/IntentService) thread. | ← [Interface RealmEventStreamTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamTask/ \"Previous Section\")[Class User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressMode/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum ProgressMode On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [CURRENT\\_CHANGES](#current%5Fchanges)\n* [INDEFINITELY](#indefinitely)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.sync.ProgressMode Enum describing how to listen to progress changes. ## Enum Constant Summary\n\n ## Method Summary | Modifier and Type                                                                   | Method and Description                                                                                                                                      |\n| ----------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static [ProgressMode](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode) | [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [ProgressMode](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode) | [values](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode%5Fvalues) ()                                                                                 | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `CURRENT_CHANGES` public static final [ProgressMode](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode) When registering the [ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) , it will record the current size of changes, and will only continue to report progress updates until those changes have been either downloaded or uploaded. After that the progress listener will not report any further changes. This means that listeners registered in this mode should be done _before_ changes are written to the Realm. Progress reported in this mode will only ever increase. This is useful when e.g. reporting progress when downloading a Realm for the first time. ### `INDEFINITELY` public static final [ProgressMode](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode) A [ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) registered in this mode, will continue to report progress changes, even if changes are being added after the listener was registered.\n\n This is useful when you want to track if all changes have been uploaded to the server from the device. ## Method Detail ### valueOf | public static [ProgressMode](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode) [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [ProgressMode](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode) [values](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode%5Fvalues) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Interface ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/ \"Previous Section\")[Interface Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Sync On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [getAllSessions](#getallsessions)\n* [getOrCreateSession](#getorcreatesession)\n* [getSession](#getsession)\n* [reconnect](#reconnect) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.sync.Sync A _sync_ manager handling synchronization of local Realms with remote Realm Apps.The primary role of this is to access the [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) for a synchronized Realm. After opening the synchronized Realm you can access the [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) and perform synchronization related operations as shown below:\n\n ` ## Tip ### See also:  * [App.getSync()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FgetSync%5F%5F)\n* [Sync.getSession(SyncConfiguration)](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync%5FgetSession%5FSyncConfiguration%5F) ## Nested Class Summary | Modifier and Type | Class and Description                                                                                                           |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------- |\n| public static     | [Sync.Debug](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/Debug/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync%5FDebug-1) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### getAllSessions | public synchronized [Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) [getAllSessions](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync%5FgetAllSessions) ()                                                                                                                                       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets a collection of all the cached [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) .**Returns**a collection of [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) . | ### getOrCreateSession\n\n ### getSession\n\n ### reconnect | public **void** [reconnect](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync%5Freconnect) ()                                                                                                                                                                                                                                                                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Realm will automatically detect when a device gets connectivity after being offline and resume syncing.However, as some of these checks are performed using incremental backoff, this will in some cases not happen immediately.In those cases it can be beneficial to call this method manually, which will force all sessions to attempt to reconnect immediately and reset any timers they are using for incremental backoff. | ← [Interface SubscriptionSet.UpdateCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/UpdateCallback/ \"Previous Section\")[Class Sync.Debug](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/Debug/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/DiscardUnsyncedChangesStrategy/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface DiscardUnsyncedChangesStrategy On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [onAfterReset](#onafterreset)\n* [onBeforeReset](#onbeforereset)\n* [onError](#onerror) ## io.realm.mongodb.sync **Implemented interfaces:** * [io.realm.mongodb.sync.SyncClientResetStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncClientResetStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncClientResetStrategy) Strategy that automatically resolves a Client Reset by discarding any unsynced data, but otherwise keep the Realm open. Any changes will be reported through the normal collection and object notifications.A synced Realm may need to be reset because the MongoDB Realm Server encountered an error and had to be restored from a backup or because it has been too long since the client connected to the server so the server has rotated the logs. The Client Reset thus occurs because the server does not have the full information required to bring the Client fully up to date. The discard unsynced changes reset process is as follows: when a client reset is triggered the [onBeforeReset(Realm)](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FDiscardUnsyncedChangesStrategy%5FonBeforeReset%5FRealm%5F) callback is invoked, providing an instance of the Realm before the reset and another after the reset, both read-only. Once the reset has concluded the callback [onAfterReset(Realm, Realm)](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FDiscardUnsyncedChangesStrategy%5FonAfterReset%5FRealm%5F%5FRealm%5F) would be invoked with an instance of the final Realm. In the event that discarding the unsynced data is not enough to resolve the reset the [onError(SyncSession, ClientResetRequiredError)](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FDiscardUnsyncedChangesStrategy%5FonError%5FSyncSession%5F%5FClientResetRequiredError%5F) would be invoked, it allows to manually resolve the reset as it would be done in [ManuallyRecoverUnsyncedChangesStrategy.onClientReset(SyncSession, ClientResetRequiredError)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ManuallyRecoverUnsyncedChangesStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FManuallyRecoverUnsyncedChangesStrategy%5FonClientReset%5FSyncSession%5F%5FClientResetRequiredError%5F) . ## Method Summary\n\n ## Inherited Methods ## Method Detail ### onAfterReset | public **void** [onAfterReset](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FDiscardUnsyncedChangesStrategy%5FonAfterReset) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) before,[Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) after)                                                                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Callback invoked once the Client Reset happens. It provides of two Realm instances, a frozen one displaying the state before the reset and a regular Realm with the current state, that can be used to recover objects from the reset.**Parameters**before \\- [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) frozen Realm in the before after the reset.after \\- [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) Realm after the reset. | ### onBeforeReset | public **void** [onBeforeReset](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FDiscardUnsyncedChangesStrategy%5FonBeforeReset) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm)                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Callback that indicates a Client Reset is about to happen. It provides with a frozen instance of the Realm that is will be reset.**Parameters**realm \\- frozen [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) in its state before the reset. | ### onError\n\n ← [Enum ConnectionState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionState/ \"Previous Section\")[Interface ManuallyRecoverUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ManuallyRecoverUnsyncedChangesStrategy/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Progress/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Progress On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [getFractionTransferred](#getfractiontransferred)\n* [getTransferableBytes](#gettransferablebytes)\n* [getTransferredBytes](#gettransferredbytes)\n* [hashCode](#hashcode)\n* [isTransferComplete](#istransfercomplete)\n* [toString](#tostring) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.sync.Progress Class used to encapsulate progress notifications when either downloading or uploading Realm data. Each instance of this class is an immutable snapshot of the current progress.If the [ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) was registered with [ProgressMode.INDEFINITELY](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressMode/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode%5FINDEFINITELY) , the progress reported by [getFractionTransferred()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress%5FgetFractionTransferred%5F%5F) can both increase and decrease since more changes might be added while the progres listener is registered. This means it is possible for one notification to report `true` for [isTransferComplete()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress%5FisTransferComplete%5F%5F) , and then on the next event report `false` . If the [ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) was registered with [ProgressMode.CURRENT\\_CHANGES](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressMode/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode%5FCURRENT%5FCHANGES) , progress can only ever increase, and once [isTransferComplete()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress%5FisTransferComplete%5F%5F) returns `true` , no further events will be generated. ## Tip ### See also:  * [SyncSession.addDownloadProgressListener(ProgressMode, ProgressListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FaddDownloadProgressListener%5FProgressMode%5F%5FProgressListener%5F)\n* [SyncSession.addUploadProgressListener(ProgressMode, ProgressListener)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FaddUploadProgressListener%5FProgressMode%5F%5FProgressListener%5F) ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                | ### getFractionTransferred | public **double** [getFractionTransferred](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress%5FgetFractionTransferred) ()                                                                                                                                                                                                                                                                          |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| The fraction of bytes transferred out of all transferable bytes. Counting from since the [ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) was added.**Returns**a number between 0.0 and 1.0 , where 0.0 represents that no data has been transferred yet, and 1.0 that all data has been transferred. | ### getTransferableBytes\n\n ### getTransferredBytes | public **long** [getTransferredBytes](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress%5FgetTransferredBytes) ()                                                                                                                                                                                                                                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the total number of bytes that has been transferred since the [ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) was added.**Returns**the total number of bytes transferred since the [ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) was added. | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress%5FhashCode) ()               |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### isTransferComplete\n\n ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress%5FtoString) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                     | ← [Interface MutableSubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/ \"Previous Section\")[Interface ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface ProgressListener On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onChange](#onchange) ## io.realm.mongodb.sync Interface used when interested in updates on data either being uploaded to or downloaded from a Realm Object Server. ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                                                                                                             |\n| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onChange](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener%5FonChange) ([Progress](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Progress/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgress) progress)This method will be called periodically from the underlying Object Server Client responsible for uploading and downloading changes from the remote Object Server. | ## Method Detail ### onChange\n\n ← [Class Progress](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Progress/ \"Previous Section\")[Enum ProgressMode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressMode/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ManuallyRecoverUnsyncedChangesStrategy/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface ManuallyRecoverUnsyncedChangesStrategy On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [onClientReset](#onclientreset) ## io.realm.mongodb.sync **Implemented interfaces:** * [io.realm.mongodb.sync.SyncClientResetStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncClientResetStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncClientResetStrategy) Strategy to manually resolve a Client Reset, determined by the error code [ErrorCode.CLIENT\\_RESET](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCLIENT%5FRESET) . A synced Realm may need to be reset because the MongoDB Realm Server encountered an error and had to be restored from a backup or because it has been too long since the client connected to the server so the server has rotated the logs. The Client Reset thus occurs because the server does not have the full information required to bring the Client fully up to date. The manual reset process is as follows: the local copy of the Realm is copied into a recovery directory for safekeeping, and then deleted from the original location. The next time the Realm for that URL is opened, the Realm will automatically be re-downloaded from MongoDB Realm, and can be used as normal. Data written to the Realm after the local copy of the Realm diverged from the backup remote copy will be present in the local recovery copy of the Realm file. The re-downloaded Realm will initially contain only the data present at the time the Realm was backed up on the server. The client reset process can be initiated in one of two ways: 1. Run [ClientResetRequiredError.executeClientReset()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ClientResetRequiredError/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FClientResetRequiredError%5FexecuteClientReset%5F%5F) manually. All Realm instances must be closed before this method is called.\n2. If Client Reset isn't executed manually, it will automatically be carried out the next time all Realm instances have been closed and re-opened. This will most likely be when the app is restarted. **WARNING:** Any writes to the Realm file between this callback and Client Reset has been executed, will not be synchronized to MongoDB Realm. Those changes will only be present in the backed up file. It is therefore recommended to close all open Realm instances as soon as possible. ## Method Summary\n\n ## Inherited Methods ## Method Detail ### onClientReset | public **void** [onClientReset](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FManuallyRecoverUnsyncedChangesStrategy%5FonClientReset) ([SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) session,[ClientResetRequiredError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ClientResetRequiredError/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FClientResetRequiredError) error)                                                                                                                                                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Callback that indicates a Client Reset has happened. This should be handled as quickly as possible as any further changes to the Realm will not be synchronized with the server and must be moved manually from the backup Realm to the new one.**Parameters**session \\- [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) this error happened on.error \\- [ClientResetRequiredError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ClientResetRequiredError/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FClientResetRequiredError) the specific Client Reset error. | ← [Interface DiscardUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/DiscardUnsyncedChangesStrategy/ \"Previous Section\")[Interface MutableSubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum ErrorCode On this page\n\n ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.ErrorCode This class enumerate all potential errors related to using the Object Server or synchronizing data. ## Nested Class Summary | Modifier and Type   | Class and Description                                                                                                                     |\n| ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| public static       | [ErrorCode.Type](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Type/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FType-1)           |\n| public static final | [ErrorCode.Category](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) | ## Enum Constant Summary\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `ACCOUNT_NAME_IN_USE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `API_KEY_ALREADY_EXISTS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `API_KEY_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `ARGUMENTS_NOT_ALLOWED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `AUTH_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `AUTH_PROVIDER_ALREADY_EXISTS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `AUTH_PROVIDER_DUPLICATE_NAME` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `AUTH_PROVIDER_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `AUTO_CLIENT_RESET_FAILURE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `AWS_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_AUTHENTICATION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_CHANGESET` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_CHANGESETS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_CHANGESET_HEADER_SYNTAX` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_CHANGESET_SIZE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_CLIENT_FILE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_CLIENT_FILE_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_CLIENT_VERSION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_DECOMPRESSION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_GATEWAY`\n\n ### `BAD_MESSAGE_ORDER` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_ORIGIN_FILE_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_QUERY` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_REQUEST` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_SERVER_FILE_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_SERVER_VERSION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_SESSION_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BAD_SYNTAX` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BOUND_IN_OTHER_SESSION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BSON_CODEC_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BSON_DECODING` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `BSON_ENCODING` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_CHANGESET` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_CHANGESET_HEADER_SYNTAX` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_CHANGESET_SIZE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_CLIENT_FILE_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_CLIENT_FILE_IDENT_SALT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_CLIENT_VERSION_DOWNLOAD` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_COMPRESSION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_ERROR_CODE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_MESSAGE_ORDER` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_OBJECT_ID_SUBSTITUTIONS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_ORIGIN_FILE_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode)\n\n public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_PROTOCOL_FROM_SERVER` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_REQUEST_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_SERIAL_TRANSACT_STATUS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_SERVER_VERSION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_SESSION_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_STATE_MESSAGE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_BAD_TIMESTAMP` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_CONNECTION_CLOSED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_CONNECT_TIMEOUT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_FILE_BLACKLISTED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_FILE_EXPIRED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_FILE_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_HTTP_TUNNEL_FAILED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_LIMITS_EXCEEDED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_MISSING_PROTOCOL_FEATURE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_PONG_TIMEOUT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_PROTOCOL_MISMATCH` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_RESET` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_SSL_SERVER_CERT_REJECTED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_TOO_NEW_FOR_SERVER` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_TOO_OLD_FOR_SERVER` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CLIENT_UNKNOWN_MESSAGE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CONFLICT`\n\n ### `CONNECTION_ADDRESS_IN_USE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CONNECTION_CLOSED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CONNECTION_CONNECTION_ABORTED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CONNECTION_REFUSED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CONNECTION_RESET_BY_PEER` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `CONNECTION_SOCKET_SHUTDOWN` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `DISABLED_SESSION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `DIVERGING_HISTORIES` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `DOMAIN_NOT_ALLOWED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `EVENT_DESERIALIZING` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `EXECUTION_TIME_LIMIT_EXCEEDED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `EXPECTATION_FAILED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FAILED_DEPENDENCY` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FORBIDDEN` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FUNCTION_ALREADY_EXISTS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FUNCTION_DUPLICATE_NAME` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FUNCTION_EXECUTION_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FUNCTION_INVALID` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FUNCTION_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `FUNCTION_SYNTAX_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `GATEWAY_TIMEOUT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `GCM_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `GONE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `HTTP_BAD_REQUEST`\n\n ### `HTTP_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `HTTP_VERSION_NOT_SUPPORTED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `ILLEGAL_REALM_PATH` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INCOMING_WEBHOOK_ALREADY_EXISTS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INCOMING_WEBHOOK_AUTH_FAILED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INCOMING_WEBHOOK_DUPLICATE_NAME` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INCOMING_WEBHOOK_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INITIAL_SYNC_NOT_COMPLETE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INSUFFICIENT_STORAGE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INTERNAL_SERVER_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INVALID_EMAIL_PASSWORD` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INVALID_PARAMETER` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INVALID_SCHEMA_CHANGE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `INVALID_SESSION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `LENGTH_REQUIRED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `LIMITS_EXCEEDED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `LOCKED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `LOOP_DETECTED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `METHOD_NOT_ALLOWED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `MISC_DELIMITER_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `MISC_END_OF_INPUT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `MISC_PREMATURE_END_OF_INPUT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `MISDIRECTED_REQUEST` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `MISSING_PARAMETER`\n\n ### `MONGODB_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `MOVED_PERMANENTLY` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `MULTIPLE_CHOICES` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NETWORK_AUTHENTICATION_REQUIRED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NETWORK_INTERRUPTED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NETWORK_IO_EXCEPTION` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NETWORK_UNKNOWN` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NOT_ACCEPTABLE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NOT_CALLABLE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NOT_EXTENDED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NOT_IMPLEMENTED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NOT_MODIFIED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NO_MATCHING_RULE_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `NO_SUCH_PATH` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `OBJECT_ALREADY_EXISTS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `OTHER_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `OTHER_SESSION_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `PARTIAL_SYNC_DISABLED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `PAYLOAD_TOO_LARGE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `PAYMENT_REQUIRED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `PERMANENT_REDIRECT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `PERMISSION_DENIED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `PRECONDITION_FAILED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `PRECONDITION_REQUIRED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode)\n\n public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `RANGE_NOT_SATISFIABLE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `READ_SIZE_LIMIT_EXCEEDED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `REQUEST_HEADER_FIELDS_TOO_LARGE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `REQUEST_TIMEOUT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `RESTRICTED_HOST` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `REUSE_OF_SESSION_IDENT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `RULE_ALREADY_EXISTS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `RULE_DUPLICATE_NAME` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `RULE_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SEE_OTHER` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVER_FILE_DELETED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVER_PERMISSIONS_CHANGED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVICE_ALREADY_EXISTS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVICE_COMMAND_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVICE_INTERNAL_SERVER_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVICE_NONE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVICE_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVICE_TYPE_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVICE_UNAVAILABLE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SERVICE_UNKNOWN` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `SESSION_CLOSED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `TEMPORARY_REDIRECT` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `TOKEN_EXPIRED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `TOO_MANY_REQUESTS`\n\n ### `TOO_MANY_SESSIONS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `TRANSACT_BEFORE_UPLOAD` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `TWILIO_ERROR` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `UNAUTHORIZED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `UNAVAILABLE_FOR_LEGAL_REASONS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `UNKNOWN` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `UNKNOWN_MESSAGE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `UNPROCESSABLE_ENTITY` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `UNSUPPORTED_MEDIA_TYPE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `UNSUPPORTED_SESSION_FEATURE` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `UPGRADE_REQUIRED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `URI_TOO_LONG` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `USER_ALREADY_CONFIRMED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `USER_APP_DOMAIN_MISMATCH` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `USER_BLACKLISTED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `USER_DISABLED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `USER_MISMATCH` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `USER_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `USE_PROXY` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `VALUE_ALREADY_EXISTS` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `VALUE_DUPLICATE_NAME` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `VALUE_NOT_FOUND` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `VARIANT_ALSO_NEGOTIATES` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `WRITE_NOT_ALLOWED` public static final [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ### `WRONG_PROTOCOL_VERSION`\n\n ## Method Detail ### fromNativeError | public static [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) [fromNativeError](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FfromNativeError) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) type,**int** errorCode)                                                                                                                                    |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Converts a native error to the appropriate Java equivalent**Parameters**type \\- type of error. This is normally the C++ category.errorCode \\- specific code within the type**Returns**the Java error representing the native error. This method will never throw, so in case a Java error does not exists. [UNKNOWN](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FUNKNOWN) will be returned. | ### getCategory | public [ErrorCode.Category](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) [getCategory](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FgetCategory) ()                                                                                                                                                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the getCategory of the error.Errors come in 2 categories: FATAL, RECOVERABLEFATAL: The session cannot be recovered and needs to be re-created. A likely cause is that the User does not have access to this Realm. Check that the [SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) is correct.RECOVERABLE: Temporary error. The session will automatically try to recover as soon as possible.**Returns**the severity of the error. | ### getType\n\n ### intValue | public **int** [intValue](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FintValue) ()                                                                                       |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the numerical value for this error code. Note that an error is only uniquely identified by the (type:value) pair.**Returns**the error code as an unique int value. | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FtoString) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Overrides**toString in class [Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html)                                                   | ### valueOf | public static [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) [valueOf](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### values | public static [ErrorCode](#std-label-io%5Frealm%5Fmongodb%5FErrorCode) [values](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5Fvalues) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------- | ← [Enum Credentials.Provider](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/ \"Previous Section\")[Enum ErrorCode.Category](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionState/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum ConnectionState On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [CONNECTED](#connected)\n* [CONNECTING](#connecting)\n* [DISCONNECTED](#disconnected)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.sync.ConnectionState Enum describing the states of the underlying connection used by a [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) . ## Enum Constant Summary | Enum Constant and Description                                                                                                                  |\n| ---------------------------------------------------------------------------------------------------------------------------------------------- |\n| [CONNECTED](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState%5FCONNECTED)A connection was successfully established to the server.      |\n| [CONNECTING](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState%5FCONNECTING)A connection is currently in progress of being established. |\n| [DISCONNECTED](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState%5FDISCONNECTED)No connection to the server exists.                     | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `CONNECTED` public static final [ConnectionState](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) A connection was successfully established to the server. If the SyncSession is [SyncSession.State.ACTIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FACTIVE) data will now be transferred between the device and the server. ### `CONNECTING` public static final [ConnectionState](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) A connection is currently in progress of being established. If successful the next state is [CONNECTED](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState%5FCONNECTED) . If the connection fails it will be [DISCONNECTED](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState%5FDISCONNECTED) . ### `DISCONNECTED` public static final [ConnectionState](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) No connection to the server exists. No data is being transferred even if the session is [SyncSession.State.ACTIVE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FACTIVE) . If the connection entered this state due to an error, this error will be reported to the [SyncSession.ErrorHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FErrorHandler) . ## Method Detail ### valueOf | public static [ConnectionState](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [ConnectionState](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) [values](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState%5Fvalues) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ← [Interface ConnectionListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionListener/ \"Previous Section\")[Interface DiscardUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/DiscardUnsyncedChangesStrategy/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ClientResetRequiredError/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Exception ClientResetRequiredError On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [executeClientReset](#executeclientreset)\n* [getBackupFile](#getbackupfile)\n* [getBackupRealmConfiguration](#getbackuprealmconfiguration)\n* [getOriginalFile](#getoriginalfile) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [java.lang.Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) [java.lang.RuntimeException](https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) [io.realm.mongodb.AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) io.realm.mongodb.sync.ClientResetRequiredError Class encapsulating information needed for handling a Client Reset event. ## Tip ### See also:  * [SyncSession.ErrorHandler.onError(SyncSession, AppException) for more information about when and why Client Reset occurs and how to deal with it.](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FErrorHandler%5FonError%5FSyncSession%5F%5FAppException%5F) ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) : `getMessage` , `getLocalizedMessage` , `getCause` , `initCause` , `toString` , `printStackTrace` , `printStackTrace` , `printStackTrace` , `fillInStackTrace` , `getStackTrace` , `setStackTrace` , `addSuppressed` , `getSuppressed`\n* Methods inherited from class [io.realm.mongodb.AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) : `getErrorCode` , `getErrorType` , `getErrorIntValue` , `getErrorMessage` , `getException` , `getCategory` , `toString` ## Method Detail ### executeClientReset\n\n ### getBackupFile | public [File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html) [getBackupFile](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FClientResetRequiredError%5FgetBackupFile) ()                                                                                                   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the location of the backed up Realm file. The file will not be present until the Client Reset has been fully executed.**Returns**a reference to the location of the backup file once Client Reset has been executed. Use file.exists() to check if the file exists or not. | ### getBackupRealmConfiguration | public [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) [getBackupRealmConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FClientResetRequiredError%5FgetBackupRealmConfiguration) ()                                                      |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| The configuration that can be used to open the backup Realm offline. This configuration can only be used in combination with a [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) .**Returns**the configuration that can be used to open the backup Realm offline. | ### getOriginalFile | public [File](https://docs.oracle.com/javase/7/docs/api/java/io/File.html) [getOriginalFile](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FClientResetRequiredError%5FgetOriginalFile) ()                                                                                                                       |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the location of the original Realm file. After the Client Reset has completed, the file at this location will be deleted.**Returns**a reference to the location of the original Realm file. After Client Reset has been executed this file will no longer exists. Use file.exists() to check this. | ← [Enum SyncSession.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/State/ \"Previous Section\")[io.realm.rx](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface ConnectionListener On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onChange](#onchange) ## io.realm.mongodb.sync Interface used when reporting changes that happened to the connection used by the session.Multiple sessions might re-use the same connection. In that case, any connection change will be reported to all sessions. If a disconnect happened due to an error, that error will be reported to the sessions [SyncSession.ErrorHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FErrorHandler) . ## Tip ### See also:  * [SyncSession.isConnected()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FisConnected%5F%5F)\n* [SyncConfiguration.Builder.errorHandler(SyncSession.ErrorHandler)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FerrorHandler%5FSyncSession%5FErrorHandler%5F) ## Method Summary\n\n ## Method Detail ### onChange | public **void** [onChange](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionListener%5FonChange) ([ConnectionState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionState/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) oldState,[ConnectionState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionState/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) newState) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| A change in the connection to the server was detected.**Parameters**oldState \\- the state the connection transitioned from.newState \\- the state the connection transitioned to.                                                                                                                                                                                                                             | ← [io.realm.mongodb.sync](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ \"Previous Section\")[Enum ConnectionState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionState/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface Subscription On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [create](#create)\n* [getCreatedAt](#getcreatedat)\n* [getName](#getname)\n* [getObjectType](#getobjecttype)\n* [getQuery](#getquery)\n* [getUpdatedAt](#getupdatedat) ## io.realm.mongodb.sync A subscription defines a specific server query and its metadata. The result of this query is continuously being synchronized with the device as long as the subscription is part of a [SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) with a state of [SubscriptionSet.State.COMPLETE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5FCOMPLETE) . Subscriptions are immutable once created, but they can be updated by using a [MutableSubscriptionSet.addOrUpdate(Subscription)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5FaddOrUpdate%5FSubscription%5F) . ## Method Summary\n\n ## Method Detail ### create | public static [Subscription](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) [create](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription%5Fcreate) ([io.realm.RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) query)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Create an unmanaged anonymous subscription for a flexible sync enabled Realm. The subscription will not take effect until it has been stored using either [MutableSubscriptionSet.add(Subscription)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5Fadd%5FSubscription%5F) or [MutableSubscriptionSet.addOrUpdate(Subscription)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5FaddOrUpdate%5FSubscription%5F) .**Parameters**query \\- the query that is subscribed to. Note, subscription queries have restrictions compared to normal queries.**Returns**the unmanaged subscription. |\n\n ### getCreatedAt | public [Date](https://docs.oracle.com/javase/7/docs/api/java/util/Date.html) [getCreatedAt](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription%5FgetCreatedAt) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the timestamp for when this subscription was persisted. This will return null until the Subscription has been added using either [MutableSubscriptionSet.add(Subscription)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5Fadd%5FSubscription%5F) or [MutableSubscriptionSet.addOrUpdate(Subscription)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5FaddOrUpdate%5FSubscription%5F) .**Returns**the time this subscription was persisted, or null if the subscription hasn't been persisted yet. | ### getName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getName](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription%5FgetName) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the name of subscription or null if no name was defined.**Returns**the name of the subscription.                                                       | ### getObjectType\n\n ### getQuery | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getQuery](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription%5FgetQuery) ()                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the subscription query that is running on objects of type [getObjectType()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription%5FgetObjectType%5F%5F) .**Returns**the query covered by this subscription. | ### getUpdatedAt\n\n ← [Enum ProgressMode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressMode/ \"Previous Section\")[Interface SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class SyncSession On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [addConnectionChangeListener](#addconnectionchangelistener)\n* [addDownloadProgressListener](#adddownloadprogresslistener)\n* [addUploadProgressListener](#adduploadprogresslistener)\n* [downloadAllServerChanges](#downloadallserverchanges)\n* [getConfiguration](#getconfiguration)\n* [getConnectionState](#getconnectionstate)\n* [getServerUrl](#getserverurl)\n* [getState](#getstate)\n* [getUser](#getuser)\n* [isConnected](#isconnected)\n* [removeConnectionChangeListener](#removeconnectionchangelistener)\n* [removeProgressListener](#removeprogresslistener)\n* [start](#start)\n* [stop](#stop)\n* [uploadAllLocalChanges](#uploadalllocalchanges) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.sync.SyncSession A session controls how data is synchronized between a single Realm on the device and the server Realm on the Realm Object Server.A Session is created by opening a Realm instance using a [SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) . Once a session has been created, it will continue to exist until the app is closed or all threads using this [SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) closes their respective [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) s. A session is controlled by Realm, but can provide additional information in case of errors. These errors are passed along in the [SyncSession.ErrorHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FErrorHandler) . When creating a session, Realm will establish a connection to the server. This connection is controlled by Realm and might be shared between multiple sessions. It is possible to get insight into the connection using [addConnectionChangeListener(ConnectionListener)](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FaddConnectionChangeListener%5FConnectionListener%5F) and [isConnected()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FisConnected%5F%5F) . The session itself has a different lifecycle than the underlying connection. The state of the session can be found using [getState()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FgetState%5F%5F) . The [SyncSession](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) object is thread safe. ## Nested Class Summary\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### addConnectionChangeListener | public synchronized **void** [addConnectionChangeListener](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FaddConnectionChangeListener) ([ConnectionListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionListener) listener)                                                                                                                                                                                                                                                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds a listener tracking changes to the connection backing this session. See [ConnectionState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionState/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) for further details.**Parameters**listener \\- the listener to register.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the listener is null .TipSee also: [ConnectionState](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionState/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState) | ### addDownloadProgressListener\n\n ### addUploadProgressListener | public synchronized **void** [addUploadProgressListener](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FaddUploadProgressListener) ([ProgressMode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressMode/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode) mode,[ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) listener)                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Adds a progress listener tracking changes that need to be uploaded from the device to the Realm Object Server.The [ProgressListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressListener) will be triggered immediately when registered, and periodically afterwards.**Parameters**mode \\- type of mode used. See [ProgressMode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ProgressMode/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FProgressMode) for more information.listener \\- the listener to register. | ### downloadAllServerChanges\n\n | public **void** [downloadAllServerChanges](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FdownloadAllServerChanges) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Calling this method will block until all known remote changes have been downloaded and applied to the Realm. This will involve network access, so calling this method should only be done from a non-UI thread.If the device is offline, this method might never return.This method cannot be called before the session has been started.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called on the Android main thread.[InterruptedException](https://docs.oracle.com/javase/7/docs/api/java/lang/InterruptedException.html) \\- if the thread was interrupted while downloading was in progress. | ### getConfiguration | public [SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) [getConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FgetConfiguration) ()                            |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) that is responsible for controlling the session.**Returns**SyncConfiguration that defines and controls this session. | ### getConnectionState\n\n ### getServerUrl | public [URI](https://docs.oracle.com/javase/7/docs/api/java/net/URI.html) [getServerUrl](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FgetServerUrl) ()                                                                                                                   |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [URI](https://docs.oracle.com/javase/7/docs/api/java/net/URI.html) describing the remote Realm which this session connects to and synchronizes changes with.**Returns**[URI](https://docs.oracle.com/javase/7/docs/api/java/net/URI.html) describing the remote Realm. | ### getState | public [SyncSession.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) [getState](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FgetState) ()                                                                                                                                                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Get the current session's state, as defined in [SyncSession.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) .Note that the state may change after this method returns.**Returns**the state of the session.TipSee also: [SyncSession.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) | ### getUser\n\n ### isConnected | public **boolean** [isConnected](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FisConnected) ()                                                                                                                                                                                                                                                                                                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if the session is connected to the server and can synchronize data. This is a best guess effort. To conserve battery the underlying implementation uses heartbeats to detect if the connection is still available. So if no data is actively being synced and some time has elapsed since the last heartbeat, the connection could have been dropped but this method will still return true .**Returns**true if the session is connected and ready to synchronize data, false if not or if it is in the process of connecting. | ### removeConnectionChangeListener | public synchronized **void** [removeConnectionChangeListener](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FremoveConnectionChangeListener) ([ConnectionListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionListener) listener)                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes a previously registered [ConnectionListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionListener/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionListener) .**Parameters**listener \\- listener to remove**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the listener is null . | ### removeProgressListener\n\n ### start\n\n ### stop | public synchronized **void** [stop](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5Fstop) ()                                                                                                                                                                                                                       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Stops any synchronization with the Realm Object Server until the Realm is re-opened again after fully closing it.Synchronization can be re-enabled by calling [start()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5Fstart%5F%5F) again.If the session is already stopped, calling this method will do nothing. | ### uploadAllLocalChanges\n\n | public **void** [uploadAllLocalChanges](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FuploadAllLocalChanges) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Calling this method will block until all known local changes have been uploaded to the server. This will involve network access, so calling this method should only be done from a non-UI thread.If the device is offline, this method might never return.This method cannot be called before the Realm has been opened.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called on the Android main thread.[InterruptedException](https://docs.oracle.com/javase/7/docs/api/java/lang/InterruptedException.html) \\- if the thread was interrupted while downloading was in progress. | ← [Interface SyncConfiguration.InitialFlexibleSyncSubscriptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/InitialFlexibleSyncSubscriptions/ \"Previous Section\")[Interface SyncSession.ClientResetHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ClientResetHandler/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ClientResetHandler/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SyncSession.ClientResetHandler On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Inherited Methods](#inherited-methods) ## io.realm.mongodb.sync **Implemented interfaces:** * [io.realm.mongodb.sync.ManuallyRecoverUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ManuallyRecoverUnsyncedChangesStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FManuallyRecoverUnsyncedChangesStrategy)\n* [io.realm.mongodb.sync.SyncClientResetStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncClientResetStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncClientResetStrategy) **Enclosing class:** [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) Callback for the specific error event known as a Client Reset, determined by the error code [ErrorCode.CLIENT\\_RESET](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCLIENT%5FRESET) . A synced Realm may need to be reset because the MongoDB Realm Server encountered an error and had to be restored from a backup or because it has been too long since the client connected to the server so the server has rotated the logs. The Client Reset thus occurs because the server does not have the full information required to bring the Client fully up to date. The reset process is as follows: the local copy of the Realm is copied into a recovery directory for safekeeping, and then deleted from the original location. The next time the Realm for that URL is opened, the Realm will automatically be re-downloaded from MongoDB Realm, and can be used as normal. Data written to the Realm after the local copy of the Realm diverged from the backup remote copy will be present in the local recovery copy of the Realm file. The re-downloaded Realm will initially contain only the data present at the time the Realm was backed up on the server. The client reset process can be initiated in one of two ways: 1. Run [ClientResetRequiredError.executeClientReset()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ClientResetRequiredError/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FClientResetRequiredError%5FexecuteClientReset%5F%5F) manually. All Realm instances must be closed before this method is called.\n2. If Client Reset isn't executed manually, it will automatically be carried out the next time all Realm instances have been closed and re-opened. This will most likely be when the app is restarted. **WARNING:** Any writes to the Realm file between this callback and Client Reset has been executed, will not be synchronized to MongoDB Realm. Those changes will only be present in the backed up file. It is therefore recommended to close all open Realm instances as soon as possible. ## Inherited Methods ← [Class SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ \"Previous Section\")[Interface SyncSession.ErrorHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface MutableSubscriptionSet On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [add](#add)\n* [addOrUpdate](#addorupdate)\n* [remove](#remove)\n* [removeAll](#removeall) ## io.realm.mongodb.sync **Implemented interfaces:** * [io.realm.mongodb.sync.SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet)\n* [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html) A mutable subscription set is available when calling [SubscriptionSet.update(UpdateCallback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5Fupdate%5FUpdateCallback%5F) This is the only way to modify a [SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) . [Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) s can be either _managed_ or _unmanaged_. Unmanaged subscriptions are those created by using [Subscription.create(RealmQuery)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription%5Fcreate%5FRealmQuery%5F) or [Subscription.create(String, RealmQuery)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription%5Fcreate%5FString%5F%5FRealmQuery%5F) , while managed subscriptions are the ones being returned from the subscription set. ## Tip ### See also:  * [SubscriptionSet for more information about subscription sets and flexible sync.](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) ## Method Summary\n\n ## Inherited Methods ## Method Detail ### add | public [Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) [add](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5Fadd) ([Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) subscription) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds a new unmanaged subscription to the subscription set.**Parameters**subscription \\- unmanaged subscription to add.**Returns**the newly added managed subscription.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if a subscription matching the provided one already exists.           | ### addOrUpdate | public [Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) [addOrUpdate](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5FaddOrUpdate) ([Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) subscription)                                        |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Add a new subscription or update an existing named subscription. It isn't possible to update an anonymous subscription. These must removed and re-inserted.**Parameters**subscription \\- anonymous or named subscription created via Subscription.create(...) , used to update a matching one within a specific set. It creates a new one in case there is no match..**Returns**the updated or inserted managed subscription. | ### remove | public **boolean** [remove](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5Fremove) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Remove a named subscription.**Parameters**name \\- name of managed subscription to remove.**Returns**true if the subscription was removed, false if not.                                |\n\n ### removeAll | public **boolean** [removeAll](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5FremoveAll) ()                            |\n| ----------------------------------------------------------------------------------------------------------------------------------------- |\n| Remove all current managed subscriptions.**Returns**true if 1 or more subscriptions were removed, false if no subscriptions were removed. | | public **boolean** [removeAll](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5FremoveAll) <**T** \\>([java.lang.Class<T>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) clazz)                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Remove all subscriptions with queries on a given given model class.**Parameters**clazz \\- subscriptions on this type will be removed.**Returns**true if 1 or more subscriptions were removed, false if no subscriptions were removed. | | public **boolean** [removeAll](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet%5FremoveAll) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) objectType)                                                                                                                                                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Remove all subscriptions on a given [Subscription.getObjectType()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription%5FgetObjectType%5F%5F) .**Parameters**objectType \\- subscriptions on this object type will be removed.**Returns**true if 1 or more subscriptions were removed, false if no subscriptions were removed. | ← [Interface ManuallyRecoverUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ManuallyRecoverUnsyncedChangesStrategy/ \"Previous Section\")[Class Progress](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Progress/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/State/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum SyncSession.State On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [ACTIVE](#active)\n* [DYING](#dying)\n* [INACTIVE](#inactive)\n* [WAITING\\_FOR\\_ACCESS\\_TOKEN](#waiting%5Ffor%5Faccess%5Ftoken)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.sync.SyncSession.State **Enclosing class:** [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) Enum describing the states a SyncSession can be in. The initial state is [State.INACTIVE](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FINACTIVE) . A Realm will automatically synchronize data with the server if the session is either [State.ACTIVE](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FACTIVE) or [State.DYING](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FDYING) and **isConnected()** returns `true` . ## Enum Constant Summary\n\n ## Method Summary | Modifier and Type                                                                               | Method and Description                                                                                                                                             |\n| ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public static [SyncSession.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) | [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [SyncSession.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) | [values](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5Fvalues) ()                                                                                 | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `ACTIVE` public static final [SyncSession.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) The Realm is open and data will be synchronized between the device and the server if the underlying connection is [ConnectionState.CONNECTED](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ConnectionState/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FConnectionState%5FCONNECTED) . The session will remain in this state until the Realm is closed. In which case it will become [DYING](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FDYING) . ### `DYING` public static final [SyncSession.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState)\n\n ### `INACTIVE` public static final [SyncSession.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) This is the initial state. The session is closed. No data is being synchronized. The session will automatically transition to [ACTIVE](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FACTIVE) when a Realm is opened. ### `WAITING_FOR_ACCESS_TOKEN` public static final [SyncSession.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) The user is attempting to synchronize data but needs a valid access token to do so. Realm will either use a cached token or automatically try to acquire one based on the current users login. This requires a network connection.Data cannot be synchronized in this state. Once a valid token is acquired, the session will transition to [ACTIVE](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FACTIVE) . ## Method Detail ### valueOf | public static [SyncSession.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### values | public static [SyncSession.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState) [values](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FState%5Fvalues) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Interface SyncSession.ErrorHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/ \"Previous Section\")[Exception ClientResetRequiredError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ClientResetRequiredError/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SubscriptionSet On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [find](#find)\n* [getErrorMessage](#geterrormessage)\n* [getState](#getstate)\n* [size](#size)\n* [update](#update)\n* [updateAsync](#updateasync)\n* [waitForSynchronization](#waitforsynchronization)\n* [waitForSynchronizationAsync](#waitforsynchronizationasync) ## io.realm.mongodb.sync **Implemented interfaces:** * [java.lang.Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html) A subscription set is an immutable view of all current [Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) s for a given Realm that has been configured for flexible sync. Flexible Sync is a way of defining which data gets synchronized to and from the device using [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) s. The query and its metadata are represented by a [Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) . A subscription set thus defines all the data that is available to the device and being synchronized with the server. If the subscription set encounters an error, e.g. by containing an invalid query, the entire subscription set will enter an [SubscriptionSet.State.ERROR](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5FERROR) state, and no synchronization will happen until the error has been fixed. If a subscription is removed, so is the corresponding data, but it is only removed from the device. It isn't deleted on the server. It is possible to modify a subscription set while offline, but modification isn't accepted by the server before [getState()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FgetState%5F%5F) returns [SubscriptionSet.State.COMPLETE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5FCOMPLETE) . It is possible to force the subscription set to be synchronized with the server by using [waitForSynchronization()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FwaitForSynchronization%5F%5F) and its variants. ## Nested Class Summary\n\n ## Method Summary\n\n ## Inherited Methods ## Method Detail ### find | public [Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) [find](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5Ffind) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Find the subscription with a given name.**Parameters**name \\- name of subscription to search for.**Returns**the matching subscription or null if no subscription with that name was found.                                                                                                        | | public [Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscription) [find](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5Ffind) ([io.realm.RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) query) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Find the first subscription that contains the given query. It is possible for multiple named subscriptions to contain the same query.**Parameters**query \\- query to search for.**Returns**the first subscription containing the query or null if no match was found.                                                           | ### getErrorMessage\n\n ### getState | public [SubscriptionSet.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) [getState](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FgetState) ()                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the current state of the SubscriptionSet. See [SubscriptionSet.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/State/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) for more details about each state.**Returns**current state of the SubscriptionSet. | ### size | public **int** [size](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5Fsize) ()                                                |\n| ---------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns how many subscriptions are currently in this subscription set.**Returns**the number of of subscriptions in the subscription set. | ### update | public [SubscriptionSet](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) [update](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5Fupdate) ([SubscriptionSet.UpdateCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/UpdateCallback/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FUpdateCallback) action)                                                                                                                                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Modify the subscription set. If an exception is thrown during the update, no changes will be applied. If the update succeeds, this subscription set is updated with the modified state.**Parameters**action \\- the block that modifies the subscription set. It will run on the caller thread.**Returns**this subscription set, that now has been updated.**Throws**[Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) \\- any exception thrown during the update, will propagate back. | ### updateAsync\n\n ### waitForSynchronization | public **boolean** [waitForSynchronization](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FwaitForSynchronization) ([Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) timeOut,[TimeUnit](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html) unit)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Wait for the subscription set to synchronize with the server. It will return when the server either accepts the set of queries and has downloaded data for them, or if an error has occurred. Note, that you will either need to manually call **Realm.refresh()** or wait for change listeners to trigger to see the downloaded data. If an error occurred, the underlying reason can be found through [getErrorMessage()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FgetErrorMessage%5F%5F) .**Parameters**timeOut \\- how long to wait for the synchronization to either succeed or fail.unit \\- unit of time used for the timeout.**Returns**true if all current subscriptions were accepted by the server and data has been downloaded, or false if an error occurred.**Throws**[RuntimeException](https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) \\- if the timeout is exceeded. |\n\n ### waitForSynchronizationAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [waitForSynchronizationAsync](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FwaitForSynchronizationAsync) ([Long](https://docs.oracle.com/javase/7/docs/api/java/lang/Long.html) timeOut,[TimeUnit](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html) unit,[SubscriptionSet.StateChangeCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/StateChangeCallback/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FStateChangeCallback) callback)                                                                                                                                                                                                                                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Asynchronously wait for the subscription set to synchronize with the server. The callback is invoked when the server either accepts the set of queries and has downloaded data for them, or if an error has occurred. Note, that you will either need to manually call **Realm.refresh()** or wait for change listeners to trigger to see the downloaded data. If an error occurred, the underlying reason can be found through [getErrorMessage()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FgetErrorMessage%5F%5F) .**Parameters**timeOut \\- how long to wait for the synchronization to either succeed or fail.unit \\- unit of time used for the timeout.callback \\- callback to trigger when the synchronization either succeed or fail. Results will be reported on the UI thread.**Returns**true if all current subscriptions were accepted by the server and data has been downloaded, or false if an error occurred. |\n\n ← [Interface Subscription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Subscription/ \"Previous Section\")[Enum SubscriptionSet.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/State/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/State/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum SubscriptionSet.State On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [BOOTSTRAPPING](#bootstrapping)\n* [COMPLETE](#complete)\n* [ERROR](#error)\n* [PENDING](#pending)\n* [SUPERSEDED](#superseded)\n* [UNCOMMITTED](#uncommitted)\n* [Method Detail](#method-detail)\n* [fromNativeValue](#fromnativevalue)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.sync.SubscriptionSet.State **Enclosing class:** [SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) The possible states a subscription set can be in. ## Enum Constant Summary\n\n ## Method Summary | Modifier and Type                                                                                       | Method and Description                                                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) | [fromNativeValue](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5FfromNativeValue) (**long** value)                                                 |\n| public static [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) | [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) | [values](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5Fvalues) ()                                                                                 | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `BOOTSTRAPPING` public static final [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) A subscription set was accepted by the server and initial data is being sent to the device. ### `COMPLETE` public static final [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState)\n\n ### `ERROR` public static final [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) An error occurred in the subscription set or one of the subscriptions. The cause is found in **getErrorMessage()**. ### `PENDING` public static final [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) A subscription set has been modified locally, but is still waiting to be sent to the server. ### `SUPERSEDED` public static final [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) Another subscription set was stored before this one, the changes made to this set are ignorde by the server. Get the latest subscription set by calling **Realm.getSubscriptions()**. ### `UNCOMMITTED` public static final [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) The initial state of subscriptions when opening a new Realm or when entering a **update(UpdateCallback)**. ## Method Detail ### fromNativeValue | public static [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) [fromNativeValue](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5FfromNativeValue) (**long** value) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### valueOf | public static [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### values | public static [SubscriptionSet.State](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState) [values](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FState%5Fvalues) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Interface SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/ \"Previous Section\")[Interface SubscriptionSet.StateChangeCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/StateChangeCallback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SyncSession.ErrorHandler On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onError](#onerror) ## io.realm.mongodb.sync **Enclosing class:** [SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) Interface used to report any session errors. ## Tip ### See also:  * [SyncConfiguration.Builder.errorHandler(ErrorHandler)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FerrorHandler%5FErrorHandler%5F) ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                                                                                                                                  |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onError](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FErrorHandler%5FonError) ([SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession) session,[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) error)Callback for errors on a session object. | ## Method Detail ### onError\n\n ← [Interface SyncSession.ClientResetHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ClientResetHandler/ \"Previous Section\")[Enum SyncSession.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/State/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class SyncConfiguration On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [defaultConfig](#defaultconfig)\n* [equals](#equals)\n* [forRecovery](#forrecovery)\n* [getClientResetHandler](#getclientresethandler)\n* [getErrorHandler](#geterrorhandler)\n* [getInitialDataTransaction](#getinitialdatatransaction)\n* [getInitialRemoteDataTimeout](#getinitialremotedatatimeout)\n* [getInitialSubscriptionsHandler](#getinitialsubscriptionshandler)\n* [getPartitionValue](#getpartitionvalue)\n* [getServerUrl](#getserverurl)\n* [getSessionStopPolicy](#getsessionstoppolicy)\n* [getSyncClientResetStrategy](#getsyncclientresetstrategy)\n* [getUrlPrefix](#geturlprefix)\n* [getUser](#getuser)\n* [hashCode](#hashcode)\n* [isFlexibleSyncConfiguration](#isflexiblesyncconfiguration)\n* [isPartitionBasedSyncConfiguration](#ispartitionbasedsyncconfiguration)\n* [isSyncConfiguration](#issyncconfiguration)\n* [realmExists](#realmexists)\n* [shouldDeleteRealmOnLogout](#shoulddeleterealmonlogout)\n* [shouldWaitForInitialRemoteData](#shouldwaitforinitialremotedata)\n* [toString](#tostring) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [io.realm.RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) io.realm.mongodb.sync.SyncConfiguration A [SyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) is used to setup a Realm Database that can be synchronized between devices using MongoDB Realm. A valid [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) is required to create a [SyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) . See [Credentials](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/#std-label-io%5Frealm%5Fmongodb%5FCredentials) and [App.loginAsync(Credentials, App.Callback)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FloginAsync%5FCredentials%5F%5FApp%5FCallback%5F) for more information on how to get a user object. A minimal [SyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) can be found below.\n\n ` Synchronized Realms only support additive migrations which can be detected and performed automatically, so the following builder options are not accessible compared to a normal Realm: * `deleteRealmIfMigrationNeeded()`\n* `migration(Migration)` Synchronized Realms are created by using [Realm.getInstance(RealmConfiguration)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FgetInstance%5FRealmConfiguration%5F) and [Realm.getDefaultInstance()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FgetDefaultInstance%5F%5F) like ordinary unsynchronized Realms. ## Tip ### See also:  * [The docs](https://docs.mongodb.com/realm/sync/) for more information about synchronization. ## Nested Class Summary | Modifier and Type       | Class and Description                                                                                                                                                                                                                                 |\n| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static interface | [SyncConfiguration.InitialFlexibleSyncSubscriptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/InitialFlexibleSyncSubscriptions/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FInitialFlexibleSyncSubscriptions) |\n| public static final     | [SyncConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1)                                                                          | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [io.realm.RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) : `getRealmDirectory` , `getRealmFileName` , `getEncryptionKey` , `getSchemaVersion` , `getMigration` , `shouldDeleteRealmIfMigrationNeeded` , `getDurability` , `getSchemaMediator` , `getInitialDataTransaction` , `hasAssetFile` , `getAssetFilePath` , `getCompactOnLaunchCallback` , `getRealmObjectClasses` , `getPath` , `realmExists` , `getRxFactory` , `getFlowFactory` , `isReadOnly` , `isRecoveryConfiguration` , `getMaxNumberOfActiveVersions` , `isAllowWritesOnUiThread` , `isAllowQueriesOnUiThread` , `equals` , `getInstance` , `hashCode` , `createSchemaMediator` , `toString` , `isSyncConfiguration` , `forRecovery` ## Method Detail ### defaultConfig | public static [SyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) [defaultConfig](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FdefaultConfig) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user,**ObjectId** partitionValue)                         |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a default Partition-based Sync configuration for the given user and partition value.**Parameters**user \\- The user that will be used for accessing the Realm App.partitionValue \\- The partition value identifying the remote Realm that will be synchronized.**Returns**the default configuration for the given user and partition value. | | public static [SyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) [defaultConfig](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FdefaultConfig) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user,[Integer](https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html) partitionValue) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a default Partition-based Sync configuration for the given user and partition value.**Parameters**user \\- The user that will be used for accessing the Realm App.partitionValue \\- The partition value identifying the remote Realm that will be synchronized.**Returns**the default configuration for the given user and partition value.                                        |\n\n | public static [SyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) [defaultConfig](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FdefaultConfig) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) partitionValue) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a default Partition-based Sync configuration for the given user and partition value.**Parameters**user \\- The user that will be used for accessing the Realm App.partitionValue \\- The partition value identifying the remote Realm that will be synchronized.**Returns**the default configuration for the given user and partition value.                                      | | public static [SyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) [defaultConfig](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FdefaultConfig) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user)         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns a default Flexible Sync configuration for the given user.**Parameters**user \\- The user that will be used for accessing the Realm App.**Returns**the default Flexible Sync configuration for the given user.TipSee also: **{@link SubscriptionSet} for more information about Flexible Sync.** | ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Overrides**equals in class [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration)                             | ### forRecovery\n\n | public static [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) [forRecovery](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FforRecovery) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) canonicalPath,**byte\\[\\]** encryptionKey,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) modules)                                                                                                                                                          |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) appropriate to open a read-only, non-synced Realm to recover any pending changes. This is useful when trying to open a backup/recovery Realm (after a client reset).**Parameters**canonicalPath \\- the absolute path to the Realm file defined by this configuration.encryptionKey \\- the key used to encrypt/decrypt the Realm file.modules \\- if specified it will restricts Realm schema to the provided module.**Returns**RealmConfiguration that can be used offline | ### getClientResetHandler | public [SyncSession.ClientResetHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ClientResetHandler/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FClientResetHandler) [getClientResetHandler](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FgetClientResetHandler) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the Client Reset handler for this _SyncConfiguration_.**Returns**the Client Reset handler.                                                                                                                                                                                                              | ### getErrorHandler\n\n ### getInitialDataTransaction | protected [Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) [getInitialDataTransaction](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FgetInitialDataTransaction) ()            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the transaction instance with initial data.**Returns**the initial data transaction.**Overrides**getInitialDataTransaction in class [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) | ### getInitialRemoteDataTimeout | public **long** [getInitialRemoteDataTimeout](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FgetInitialRemoteDataTimeout) ([TimeUnit](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html) unit)                                                                                                                                                                                                                                                                                                                                                                                                                                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the timeout defined when downloading any initial data the first time the Realm is opened.This value is only applicable if [shouldWaitForInitialRemoteData()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FshouldWaitForInitialRemoteData%5F%5F) returns true .**Returns**the time Realm will wait for all changes to be downloaded before it is aborted and an exception is thrown.TipSee also: [SyncConfiguration.Builder.waitForInitialRemoteData(long, TimeUnit)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FwaitForInitialRemoteData%5Flong%5F%5FTimeUnit%5F) | ### getInitialSubscriptionsHandler\n\n ### getPartitionValue | public **BsonValue** [getPartitionValue](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FgetPartitionValue) ()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Returns the value this Realm is partitioned on. The partition key is a property defined in MongoDB Realm. All classes with a property with this value will be synchronized to the Realm.**Returns**the value being used by MongoDB Realm to partition the server side MongoDB Database into Realms that can be synchronized independently.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if this configuration is for a realm configured for flexible sync. You can use [isPartitionBasedSyncConfiguration()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FisPartitionBasedSyncConfiguration%5F%5F) before calling this method to check. | ### getServerUrl\n\n ### getSessionStopPolicy | public **OsRealmConfig.SyncSessionStopPolicy** [getSessionStopPolicy](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FgetSessionStopPolicy) ()                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| NOTE: Only for internal usage. May change without warning. Returns the stop policy for the session for this Realm once the Realm has been closed.**Returns**the stop policy used by the session once the Realm is closed. | ### getSyncClientResetStrategy | public [SyncClientResetStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncClientResetStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncClientResetStrategy) [getSyncClientResetStrategy](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FgetSyncClientResetStrategy) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the sync client reset strategy for this _SyncConfiguration_.**Returns**the sync client reset strategy.                                                                                                                                                                                     | ### getUrlPrefix | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getUrlPrefix](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FgetUrlPrefix) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the url prefix used when establishing a sync connection to the Realm Object Server.                                                                                   | ### getUser | public [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) [getUser](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FgetUser) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the user.**Returns**the user.                                                                                                                                                   | ### hashCode\n\n ### isFlexibleSyncConfiguration | public **boolean** [isFlexibleSyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FisFlexibleSyncConfiguration) ()                                   |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns whether or not this configuration is for opening a Realm configured for Flexible Sync.**Returns**true if this configuration is for a Flexible Sync Realm, false if not. | ### isPartitionBasedSyncConfiguration | public **boolean** [isPartitionBasedSyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FisPartitionBasedSyncConfiguration) ()                                     |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns whether or not this configuration is for opening a Realm configured for Partition-based Sync.**Returns**true if this configuration is for a Partition-based Sync Realm, false if not. | ### isSyncConfiguration | protected **boolean** [isSyncConfiguration](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FisSyncConfiguration) ()                                |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**isSyncConfiguration in class [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) | ### realmExists | protected **boolean** [realmExists](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FrealmExists) ()                                                                                                                                                                                                                                                                                                                                                                                     |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Checks if the Realm file defined by this configuration already exists.WARNING: This method is just a point-in-time check. Unless protected by external synchronization another thread or process might have created or deleted the Realm file right after this method has returned.**Returns**true if the Realm file exists, false otherwise.**Overrides**realmExists in class [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration) | ### shouldDeleteRealmOnLogout\n\n ### shouldWaitForInitialRemoteData | public **boolean** [shouldWaitForInitialRemoteData](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FshouldWaitForInitialRemoteData) ()                                                                                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns true if the Realm will download all known changes from the remote server before being opened the first time.**Returns**true if all remote changes will be downloaded before the Realm can be opened. false if the Realm can be opened immediately. | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FtoString) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [RealmConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/#std-label-io%5Frealm%5FRealmConfiguration)                  | ← [Interface SyncClientResetStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncClientResetStrategy/ \"Previous Section\")[Class SyncConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/UpdateCallback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SubscriptionSet.UpdateCallback On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [update](#update) ## io.realm.mongodb.sync **Enclosing class:** [SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) Interface used when modifying a subscription set. See **update(UpdateCallback)** and **updateAsync(UpdateAsyncCallback)**. ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                                                                                               |\n| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [update](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FUpdateCallback%5Fupdate) ([MutableSubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet) subscriptions)Updates the current subscription set by passing in a version of it that can be modified. | ## Method Detail ### update | public **void** [update](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FUpdateCallback%5Fupdate) ([MutableSubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet) subscriptions) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Updates the current subscription set by passing in a version of it that can be modified. If an exception is throwing during the update, all changes will be rolled back.**Parameters**subscriptions \\- a modifiable version of the subscription set.                                         | ← [Interface SubscriptionSet.UpdateAsyncCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/UpdateAsyncCallback/ \"Previous Section\")[Class Sync](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/StateChangeCallback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SubscriptionSet.StateChangeCallback On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onError](#onerror)\n* [onStateChange](#onstatechange) ## io.realm.mongodb.sync **Enclosing class:** [SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) Callback used when asynchronously waiting for the server to process the subscription set. When the server either succeed or fail to apply the subscription set, the result is returned in `onStateChange` . This include errors from the server. If a local exception is thrown, it is reported through on `onError()` . ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                     |\n| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onError](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FStateChangeCallback%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) e)                                                                                    |\n| public **void**   | [onStateChange](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FStateChangeCallback%5FonStateChange) ([SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) subscriptions) | ## Method Detail ### onError | public **void** [onError](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FStateChangeCallback%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) e) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### onStateChange\n\n ← [Enum SubscriptionSet.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/State/ \"Previous Section\")[Interface SubscriptionSet.UpdateAsyncCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/UpdateAsyncCallback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/UpdateAsyncCallback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SubscriptionSet.UpdateAsyncCallback On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [onError](#onerror)\n* [onSuccess](#onsuccess) ## io.realm.mongodb.sync **Implemented interfaces:** * [io.realm.mongodb.sync.SubscriptionSet.UpdateCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/UpdateCallback/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FUpdateCallback) **Enclosing class:** [SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) Callback used when asynchronously updating a subscription set. If an exception is throwing during the update, all changes will be rolled back and the exception will be reported in `onError()` . ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                             |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public **void**   | [onError](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FUpdateAsyncCallback%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception)                                                                    |\n| public **void**   | [onSuccess](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FUpdateAsyncCallback%5FonSuccess) ([SubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet) subscriptions) | ## Inherited Methods ## Method Detail ### onError | public **void** [onError](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSubscriptionSet%5FUpdateAsyncCallback%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### onSuccess\n\n ← [Interface SubscriptionSet.StateChangeCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/StateChangeCallback/ \"Previous Section\")[Interface SubscriptionSet.UpdateCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SubscriptionSet/UpdateCallback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/Debug/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Sync.Debug On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Constructors](#constructors)\n* [Field Summary](#field-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [separatedDirForSyncManager](#separateddirforsyncmanager)\n* [skipOnlineChecking](#skiponlinechecking)\n* [Constructor Detail](#constructor-detail) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.sync.Sync.Debug **Enclosing class:** [Sync](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync) Debugging related options. ## Constructors | Constructor and Description                                         |\n| ------------------------------------------------------------------- |\n| [Debug](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync%5FDebug-1) () | ## Field Summary | Modifier and Type         | Field and Description                                                                                                                                                                                                                                                                                       |\n| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static **boolean** | [separatedDirForSyncManager](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync%5FDebug%5FseparatedDirForSyncManager)Set this to true to init a SyncManager with a directory named by the process ID. This is useful for integration tests which are emulating multiple sync client by using multiple processes. |\n| public static **boolean** | [skipOnlineChecking](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync%5FDebug%5FskipOnlineChecking)Set this to true to bypass checking if the device is offline before making HTTP requests.                                                                                                                   | ## Inherited Methods\n\n ## Field Detail ### `separatedDirForSyncManager` Set this to true to init a SyncManager with a directory named by the process ID. This is useful for integration tests which are emulating multiple sync client by using multiple processes. ### `skipOnlineChecking` Set this to true to bypass checking if the device is offline before making HTTP requests. ## Constructor Detail | public [Debug](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSync%5FDebug-1) () |\n| -------------------------------------------------------------------------- | ← [Class Sync](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/Sync/ \"Previous Section\")[Interface SyncClientResetStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncClientResetStrategy/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/InitialFlexibleSyncSubscriptions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface SyncConfiguration.InitialFlexibleSyncSubscriptions On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [configure](#configure) ## io.realm.mongodb.sync **Enclosing class:** [SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) Interface for configuring the initial set of of subscriptions. This should only be used for synced realms configured for flexible sync. ## Tip ### See also:  * [Builder.initialSubscriptions(SyncConfiguration.InitialFlexibleSyncSubscriptions)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FinitialSubscriptions%5FSyncConfiguration%5FInitialFlexibleSyncSubscriptions%5F) ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                                                                                                                      |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [configure](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FInitialFlexibleSyncSubscriptions%5Fconfigure) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,[MutableSubscriptionSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/MutableSubscriptionSet/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FMutableSubscriptionSet) subscriptions) | ## Method Detail ### configure\n\n ← [Class SyncConfiguration.Builder](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/ \"Previous Section\")[Class SyncSession](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.log.obfuscator   \n* [io.realm.mongodb.log.obfuscator.HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) ← [Class Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/ \"Previous Section\")[Class HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class HttpLogObfuscator On this page * [io.realm.mongodb.log.obfuscator](#io.realm.mongodb.log.obfuscator)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [hashCode](#hashcode)\n* [obfuscate](#obfuscate) ## io.realm.mongodb.log.obfuscator [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.log.obfuscator.HttpLogObfuscator The HttpLogObfuscator keeps sensitive information from being displayed in Logcat. ## Constructors | Constructor and Description                                                                                                                                                                                                                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| [HttpLogObfuscator](#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) feature,[java.util.Map<java.lang.String, RegexPatternObfuscator>](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) patternObfuscatorMap)Constructor for creating an HTTP log obfuscator. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [HttpLogObfuscator](#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) feature,[java.util.Map<java.lang.String, RegexPatternObfuscator>](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) patternObfuscatorMap)                                                                                                  |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Constructor for creating an HTTP log obfuscator.**Parameters**feature \\- the feature to obfuscate, e.g. \"providers\" for login requests - see **io.realm.internal.network.LoggingInterceptor**.patternObfuscatorMap \\- [Map](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) of keys subject to being obfuscated and RegexPatternObfuscator\\*\\*s used to determine which obfuscator has to be used for the given feature. | ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                                     | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator%5FhashCode) () |\n| --------------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)        | ### obfuscate\n\n ← [io.realm.mongodb.log.obfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/ \"Previous Section\")[io.realm.mongodb.mongo](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/Push/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Push On this page * [io.realm.mongodb.push](#io.realm.mongodb.push)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [deregisterDevice](#deregisterdevice)\n* [deregisterDeviceAsync](#deregisterdeviceasync)\n* [registerDevice](#registerdevice)\n* [registerDeviceAsync](#registerdeviceasync) ## io.realm.mongodb.push [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.push.Push The Push client allows to register/deregister for push notifications from a client app. ## Constructors | Constructor and Description                                                 |\n| --------------------------------------------------------------------------- |\n| [Push](#std-label-io%5Frealm%5Fmongodb%5Fpush%5FPush-1) (**OsPush** osPush) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [Push](#std-label-io%5Frealm%5Fmongodb%5Fpush%5FPush-1) (**OsPush** osPush) |\n| ---------------------------------------------------------------------------------- | ## Method Detail ### deregisterDevice | public **void** [deregisterDevice](#std-label-io%5Frealm%5Fmongodb%5Fpush%5FPush%5FderegisterDevice) () |\n| ------------------------------------------------------------------------------------------------------- |\n| Deregisters the FCM registration token bound to the currently logged in user's device on MongoDB Realm. | ### deregisterDeviceAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [deregisterDeviceAsync](#std-label-io%5Frealm%5Fmongodb%5Fpush%5FPush%5FderegisterDeviceAsync) ([io.realm.mongodb.App.Callback<java.lang.Void>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deregisters the FCM registration token bound to the currently logged in user's device on MongoDB Realm.**Parameters**callback \\- The callback used when the device has been registered or the call failed - it will always happen on the same thread as this method was called on.                                                                                                  | ### registerDevice | public **void** [registerDevice](#std-label-io%5Frealm%5Fmongodb%5Fpush%5FPush%5FregisterDevice) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) registrationToken) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Registers the given FCM registration token with the currently logged in user's device on MongoDB Realm.**Parameters**registrationToken \\- The registration token to register.                  | ### registerDeviceAsync\n\n ← [io.realm.mongodb.push](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/ \"Previous Section\")[io.realm.mongodb.sync](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/GoogleAuthType/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum GoogleAuthType On this page * [io.realm.mongodb.auth](#io.realm.mongodb.auth)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [AUTH\\_CODE](#auth%5Fcode)\n* [ID\\_TOKEN](#id%5Ftoken)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb.auth [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.auth.GoogleAuthType This enum contains the list of Google authentication types supported by MongoDB Realm. ## Tip ### See also:  * [Google Authentication](https://docs.mongodb.com/realm/authentication/google) ## Enum Constant Summary | Enum Constant and Description                                                       |\n| ----------------------------------------------------------------------------------- |\n| [AUTH\\_CODE](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType%5FAUTH%5FCODE) |\n| [ID\\_TOKEN](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType%5FID%5FTOKEN)   | ## Method Summary | Modifier and Type                                                                       | Method and Description                                                                                                                                        |\n| --------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static [GoogleAuthType](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType) | [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [GoogleAuthType](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType) | [values](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType%5Fvalues) ()                                                                                 | ## Inherited Methods\n\n ## Enum Constant Detail ### `AUTH_CODE` public static final [GoogleAuthType](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType) ### `ID_TOKEN` public static final [GoogleAuthType](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType) ## Method Detail ### valueOf | public static [GoogleAuthType](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType) [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [GoogleAuthType](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType) [values](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FGoogleAuthType%5Fvalues) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class EmailPasswordAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/EmailPasswordAuth/ \"Previous Section\")[io.realm.mongodb.functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKey/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class ApiKey On this page * [io.realm.mongodb.auth](#io.realm.mongodb.auth)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [getId](#getid)\n* [getName](#getname)\n* [getValue](#getvalue)\n* [hashCode](#hashcode)\n* [isEnabled](#isenabled)\n* [toString](#tostring) ## io.realm.mongodb.auth [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.auth.ApiKey Class representing an API key for a [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) . An API can be used to represent the user when logging instead of using email and password. These keys are created or fetched through [ApiKeyAuth.create(String)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKeyAuth/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5Fcreate%5FString%5F) or the various `fetch` \\-methods. Note that a keys **value** is only available when the key is created, after that it is not visible. So anyone creating an API key is responsible for storing it safely after that. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKey%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                              | ### getId | public **ObjectId** [getId](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKey%5FgetId) ()     |\n| ------------------------------------------------------------------------------------------- |\n| Returns the unique identifier for this key.**Returns**the id, uniquely identifying the key. | ### getName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getName](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKey%5FgetName) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the name of this key.**Returns**the name of the key.                                                                                             | ### getValue | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getValue](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKey%5FgetValue) ()                                          |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns this keys value. This value is only returned when the key is created. After that the value is no longer visible.**Returns**the value of this key. Is only returned when the key is created. | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKey%5FhashCode) ()                 |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### isEnabled | public **boolean** [isEnabled](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKey%5FisEnabled) () |\n| ---------------------------------------------------------------------------------------------- |\n| Returns whether or not this key is currently enabled.**Returns**if the key is enabled or not.  | ### toString\n\n ← [io.realm.mongodb.auth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ \"Previous Section\")[Class ApiKeyAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKeyAuth/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class SyncConfiguration.Builder On this page * [io.realm.mongodb.sync](#io.realm.mongodb.sync)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [addModule](#addmodule)\n* [allowQueriesOnUiThread](#allowqueriesonuithread)\n* [allowWritesOnUiThread](#allowwritesonuithread)\n* [assetFile](#assetfile)\n* [build](#build)\n* [clientResetHandler](#clientresethandler)\n* [compactOnLaunch](#compactonlaunch)\n* [encryptionKey](#encryptionkey)\n* [errorHandler](#errorhandler)\n* [flowFactory](#flowfactory)\n* [inMemory](#inmemory)\n* [initialData](#initialdata)\n* [initialSubscriptions](#initialsubscriptions)\n* [maxNumberOfActiveVersions](#maxnumberofactiveversions)\n* [modules](#modules)\n* [name](#name)\n* [readOnly](#readonly)\n* [rxFactory](#rxfactory)\n* [schemaVersion](#schemaversion)\n* [syncClientResetStrategy](#syncclientresetstrategy)\n* [urlPrefix](#urlprefix)\n* [waitForInitialRemoteData](#waitforinitialremotedata) ## io.realm.mongodb.sync [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.sync.SyncConfiguration.Builder **Enclosing class:** [SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) Builder used to construct instances of a SyncConfiguration in a fluent manner. ## Constructors\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user)                                                                  |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates an instance of the builder for a Flexible Sync _SyncConfiguration_ with the given user.**Parameters**user \\- The user that will be used for accessing the Realm App.TipSee also: **{@link SubscriptionSet} for more information about Flexible Sync.** | | public [Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) partitionValue)               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates an instance of the builder for a Partition-based Sync _SyncConfiguration_ with the given user and partition value.**Parameters**user \\- The user that will be used for accessing the Realm App.partitionValue \\- The partition value identifying the remote Realm that will be synchronized. | | public [Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) ([User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) user,**ObjectId** partitionValue)                                                                            |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates an instance of the builder for a Partition-based Sync _SyncConfiguration_ with the given user and partition value.**Parameters**user \\- The user that will be used for accessing the Realm App.partitionValue \\- The partition value identifying the remote Realm that will be synchronized. | ## Method Detail ### addModule\n\n ### allowQueriesOnUiThread | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [allowQueriesOnUiThread](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FallowQueriesOnUiThread) (**boolean** allowQueriesOnUiThread)                                                                                                                                                                                                                                                                                        |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets whether or not RealmQueries are allowed from the UI thread.By default Realm allows queries on the main thread. However, by doing so your application may experience a drop of frames or even ANRs. We recommend diverting queries to non-UI threads or, alternatively, using [RealmQuery.findAllAsync()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5FfindAllAsync%5F%5F) or [RealmQuery.findFirstAsync()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery%5FfindFirstAsync%5F%5F) . | ### allowWritesOnUiThread\n\n ### assetFile | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [assetFile](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FassetFile) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) assetFile)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| When opening the Realm for the first time, instead of creating an empty file, the Realm file will be copied from the provided asset file and used instead.This can be used to pre-populate the Realm with data, so it doesn't have to be downloaded from the server.The provided Realm file must be a valid synced Realm for the given user, and it must have been created using the **Realm.writeCopyTo(File)** API.WARNING: This could potentially be a lengthy operation and should ideally be done on a background thread.**Parameters**assetFile \\- path to the asset database file.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if this Realm is also marked as [inMemory()](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FinMemory%5F%5F) . | ### build\n\n ### clientResetHandler | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [clientResetHandler](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FclientResetHandler) ([SyncSession.ClientResetHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ClientResetHandler/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FClientResetHandler) handler) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets the handler for when a Client Reset occurs. If no handler is set, and error is logged when a Client Reset occurs.**Parameters**handler \\- custom handler in case of a Client Reset.                                                                                                                                                                                                                                       | ### compactOnLaunch | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [compactOnLaunch](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FcompactOnLaunch) ([CompactOnLaunchCallback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/CompactOnLaunchCallback/#std-label-io%5Frealm%5FCompactOnLaunchCallback) compactOnLaunch)                                                                                                          |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets this to determine if the Realm file should be compacted before returned to the user. It is passed the total file size (data + free space) and the bytes used by data in the file.**Parameters**compactOnLaunch \\- a callback called when opening a Realm for the first time during the life of a process to determine if it should be compacted before being returned to the user. It is passed the total file size (data + free space) and the bytes used by data in the file. |\n\n ### encryptionKey | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [encryptionKey](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FencryptionKey) (**byte\\[\\]** key)                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets the io.realm.Realm#ENCRYPTION\\_KEY\\_LENGTH bytes key used to encrypt and decrypt the Realm file.**Parameters**key \\- the encryption key.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if key is invalid. | ### errorHandler | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [errorHandler](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FerrorHandler) ([SyncSession.ErrorHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FErrorHandler) errorHandler)                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the error handler used by this configuration.Only errors not handled by the defined SyncPolicy will be reported to this error handler.**Parameters**errorHandler \\- error handler used to report back errors when communicating with the Realm Object Server.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if null is given as an error handler. | ### flowFactory | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [flowFactory](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FflowFactory) ([FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory) factory)                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets the [FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory) used to create coroutines Flows from Realm objects. The default factory is [RealmFlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/RealmFlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory-1) .**Parameters**factory \\- factory to use. | ### inMemory\n\n ### initialData | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [initialData](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FinitialData) ([Realm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/Transaction/#std-label-io%5Frealm%5FRealm%5FTransaction) transaction)                                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the initial data in [io.realm.Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) . This transaction will be executed only the first time the Realm file is opened (created) or while migrating the data if [RealmConfiguration.Builder.deleteRealmIfMigrationNeeded()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-RealmConfiguration%5FBuilder%5FdeleteRealmIfMigrationNeeded%5F%5F) is set.**Parameters**transaction \\- transaction to execute. | ### initialSubscriptions\n\n ### maxNumberOfActiveVersions\n\n ### modules\n\n\n\n ### name | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [name](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5Fname) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) filename) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the filename for the Realm file on this device.**Parameters**filename \\- name for the Realm file.                                                                                                                                                                              | ### readOnly\n\n ### rxFactory | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [rxFactory](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FrxFactory) ([RxObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/#std-label-io%5Frealm%5Frx%5FRxObservableFactory) factory)                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the [RxObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/#std-label-io%5Frealm%5Frx%5FRxObservableFactory) used to create Rx Observables from Realm objects. The default factory is [RealmObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RealmObservableFactory/#std-label-io%5Frealm%5Frx%5FRealmObservableFactory-1) .**Parameters**factory \\- factory to use. | ### schemaVersion\n\n ### syncClientResetStrategy | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [syncClientResetStrategy](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FsyncClientResetStrategy) ([DiscardUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/DiscardUnsyncedChangesStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FDiscardUnsyncedChangesStrategy) handler)                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Sets the handler for when a Client Reset occurs. If no handler is set, and error is logged when a Client Reset occurs. This strategy is only available for synced realms using partition based sync. Realms using flexible sync currently only support [syncClientResetStrategy(ManuallyRecoverUnsyncedChangesStrategy)](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FsyncClientResetStrategy%5FManuallyRecoverUnsyncedChangesStrategy%5F) .**Parameters**handler \\- custom seamless loss handler in case of a Client Reset. | | public [SyncConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder-1) [syncClientResetStrategy](#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FsyncClientResetStrategy) ([ManuallyRecoverUnsyncedChangesStrategy](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/ManuallyRecoverUnsyncedChangesStrategy/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FManuallyRecoverUnsyncedChangesStrategy) handler) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the handler for when a Client Reset occurs. If no handler is set, and error is logged when a Client Reset occurs.**Parameters**handler \\- custom manual handler in case of a Client Reset.                                                                                                                                                                                                                                                                | ### urlPrefix\n\n ### waitForInitialRemoteData\n\n\n\n ← [Class SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/ \"Previous Section\")[Interface SyncConfiguration.InitialFlexibleSyncSubscriptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/InitialFlexibleSyncSubscriptions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Functions On this page * [io.realm.mongodb.functions](#io.realm.mongodb.functions)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [callFunction](#callfunction)\n* [callFunctionAsync](#callfunctionasync)\n* [getApp](#getapp)\n* [getDefaultCodecRegistry](#getdefaultcodecregistry)\n* [getUser](#getuser)\n* [invoke](#invoke) ## io.realm.mongodb.functions [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.functions.Functions A _Functions_ manager to call remote Realm functions for the associated Realm App.Arguments and results are encoded/decoded with the _Functions'_ codec registry either inherited from the [AppConfiguration.getDefaultCodecRegistry()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FgetDefaultCodecRegistry%5F%5F) or set explicitly when creating the _Functions_\\-instance through [User.getFunctions(CodecRegistry)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetFunctions%5FCodecRegistry%5F) or through the individual calls to [callFunction(String, List, Class, CodecRegistry)](#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions%5FcallFunction%5FString%5F%5FList%5F%5FClass%5F%5FCodecRegistry%5F) . ## Tip ### See also:  * [User.getFunctions()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetFunctions%5F%5F)\n* [User.getFunctions(CodecRegistry)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser%5FgetFunctions%5FCodecRegistry%5F)\n* [App.getFunctions(User)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FgetFunctions%5FUser%5F)\n* [App.getFunctions(User, CodecRegistry)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp%5FgetFunctions%5FUser%5F%5FCodecRegistry%5F)\n* [AppConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration)\n* **CodecRegistry** ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### callFunction\n\n\n\n\n\n ### callFunctionAsync\n\n\n\n\n\n ### getApp | public [App](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp-1) [getApp](#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions%5FgetApp) ()                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [App](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp-1) that this instance in associated with.**Returns**The [App](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp-1) that this instance in associated with. | ### getDefaultCodecRegistry | public **CodecRegistry** [getDefaultCodecRegistry](#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions%5FgetDefaultCodecRegistry) ()                       |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the default codec registry used for encoding arguments and decoding results for this _Realm functions_ instance.**Returns**The default codec registry. | ### getUser | public [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) [getUser](#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions%5FgetUser) ()                                                                                                                |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that this instance in associated with.**Returns**The [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that this instance in associated with. | ### invoke | protected abstract **T** [invoke](#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions%5Finvoke) <**T** \\>([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name,[java.util.List<?>](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) args,**CodecRegistry** codecRegistry,**<any>** resultDecoder) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKeyAuth/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class ApiKeyAuth On this page * [io.realm.mongodb.auth](#io.realm.mongodb.auth)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [call](#call)\n* [create](#create)\n* [createAsync](#createasync)\n* [delete](#delete)\n* [deleteAsync](#deleteasync)\n* [disable](#disable)\n* [disableAsync](#disableasync)\n* [enable](#enable)\n* [enableAsync](#enableasync)\n* [equals](#equals)\n* [fetch](#fetch)\n* [fetchAll](#fetchall)\n* [fetchAsync](#fetchasync)\n* [getApp](#getapp)\n* [getUser](#getuser)\n* [hashCode](#hashcode)\n* [toString](#tostring) ## io.realm.mongodb.auth [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.auth.ApiKeyAuth This class exposes functionality for a user to manage API keys under their control. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### call | protected abstract **void** [call](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5Fcall) (**int** functionType,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) arg,**OsJavaNetworkTransport.NetworkTransportJNIResultCallback** callback) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### create | public [ApiKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKey/#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKey) [create](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5Fcreate) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name)                                                                                                                                                                                                                                                                                                                    |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a user API key that can be used to authenticate as the user.The value of the key must be persisted at this time as this is the only time it is visible.The key is enabled when created. It can be disabled by calling [disable(ObjectId)](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5Fdisable%5FObjectId%5F) .**Parameters**name \\- the name of the key**Returns**the new API key for the user.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to create the API key. | ### createAsync\n\n ### delete | public **void** [delete](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5Fdelete) (**ObjectId** id)                                                                                                                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deletes a specific API key created by the user.**Parameters**id \\- the id of the key to delete.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to delete the API key. | ### deleteAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [deleteAsync](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5FdeleteAsync) (**ObjectId** id,[io.realm.mongodb.App.Callback<java.lang.Void>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                      |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Deletes a specific API key created by the user.**Parameters**id \\- the id of the key to delete.callback \\- callback used when the was deleted or the call failed. The callback will always happen on the same thread as this method was called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread. | ### disable | public **void** [disable](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5Fdisable) (**ObjectId** id)                                                                                                                                                                         |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Disables a specific API key created by the user.**Parameters**id \\- the id of the key to disable.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to disable the API key. | ### disableAsync\n\n ### enable | public **void** [enable](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5Fenable) (**ObjectId** id)                                                                                                                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Enables a specific API key created by the user.**Parameters**id \\- the id of the key to enable.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to enable the API key. | ### enableAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [enableAsync](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5FenableAsync) (**ObjectId** id,[io.realm.mongodb.App.Callback<java.lang.Void>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                          |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Enables a specific API key created by the user.**Parameters**id \\- the id of the key to enable.callback \\- callback used when the key was enabled or the call failed. The callback will always happen on the same thread as this method was called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread. | ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                  | ### fetch\n\n ### fetchAll | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [fetchAll](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5FfetchAll) ([io.realm.mongodb.App.Callback<java.util.List<io.realm.mongodb.auth.ApiKey>>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Fetches all API keys associated with the user.**Parameters**callback \\- callback used when the keys were fetched or the call failed. The callback will always happen on the same thread as this method was called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread.                 | | public [List](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) [fetchAll](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5FfetchAll) ()                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Fetches all API keys associated with the user.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to fetch the API keys. | ### fetchAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [fetchAsync](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5FfetchAsync) (**ObjectId** id,[io.realm.mongodb.App.Callback<io.realm.mongodb.auth.ApiKey>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                       |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Fetches a specific user API key associated with the user.**Parameters**id \\- the id of the key to fetch.callback \\- callback used when the key was fetched or the call failed. The callback will always happen on the same thread as this method was called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread. | ### getApp\n\n ### getUser | public [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) [getUser](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5FgetUser) ()                                                                                                                    |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that this instance in associated with.**Returns**The [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) that this instance in associated with. | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5FhashCode) ()             |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FApiKeyAuth%5FtoString) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                       | ← [Class ApiKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKey/ \"Previous Section\")[Class EmailPasswordAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/EmailPasswordAuth/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface App.Callback On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onResult](#onresult) ## io.realm.mongodb **Enclosing class:** [App](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp-1) Callback for async methods available to the [App](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp-1) . ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                  |\n| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onResult](#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback%5FonResult) ([io.realm.mongodb.App.Result<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Result/#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult) result)Returns the result of the request when available. | ## Method Detail ### onResult | public **void** [onResult](#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback%5FonResult) ([io.realm.mongodb.App.Result<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Result/#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult) result) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the result of the request when available.**Parameters**result \\- the request response.                                                                                                                                         | ← [Class App](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/ \"Previous Section\")[Class App.Result](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Result/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum Credentials.Provider On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [ANONYMOUS](#anonymous)\n* [API\\_KEY](#api%5Fkey)\n* [APPLE](#apple)\n* [CUSTOM\\_FUNCTION](#custom%5Ffunction)\n* [EMAIL\\_PASSWORD](#email%5Fpassword)\n* [FACEBOOK](#facebook)\n* [GOOGLE](#google)\n* [JWT](#jwt)\n* [UNKNOWN](#unknown)\n* [Method Detail](#method-detail)\n* [fromId](#fromid)\n* [getId](#getid)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.Credentials.Provider **Enclosing class:** [Credentials](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/#std-label-io%5Frealm%5Fmongodb%5FCredentials) This enum contains the list of identity providers supported by MongoDB Realm. All of these except [EMAIL\\_PASSWORD](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider%5FEMAIL%5FPASSWORD) must be enabled manually on MongoDB Realm to work. ## Tip ### See also:  * [Authentication Providers](https://docs.mongodb.com/realm/authentication/providers/) ## Enum Constant Summary\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `ANONYMOUS` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ### `API_KEY` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ### `APPLE` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ### `CUSTOM_FUNCTION` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ### `EMAIL_PASSWORD` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ### `FACEBOOK` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ### `GOOGLE` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ### `JWT` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ### `UNKNOWN` public static final [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) ## Method Detail ### fromId | public static [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) [fromId](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider%5FfromId) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) id)                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Create the identity provider from the ID string returned by MongoDB Realm.**Parameters**id \\- the string identifier for the provider**Returns**the enum representing the provider or [UNKNOWN](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider%5FUNKNOWN) if no matching provider was found. | ### getId\n\n ### valueOf | public static [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) [valueOf](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [Credentials.Provider](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider) [values](#std-label-io%5Frealm%5Fmongodb%5FCredentials%5FProvider%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class Credentials](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/ \"Previous Section\")[Enum ErrorCode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Type/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class ErrorCode.Type On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Constructors](#constructors)\n* [Field Summary](#field-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [AUTH](#auth)\n* [CONNECTION](#connection)\n* [DEPRECATED](#deprecated)\n* [HTTP](#http)\n* [JAVA](#java)\n* [JSON](#json)\n* [MISC](#misc)\n* [PROTOCOL](#protocol)\n* [SERVICE](#service)\n* [SESSION](#session)\n* [UNKNOWN](#unknown)\n* [Constructor Detail](#constructor-detail) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.ErrorCode.Type **Enclosing class:** [ErrorCode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ## Constructors | Constructor and Description                                     |\n| --------------------------------------------------------------- |\n| [Type](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FType-1) () | ## Field Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `AUTH` ### `CONNECTION` ### `DEPRECATED` ### `HTTP` ### `JAVA` ### `JSON` ### `MISC` ### `PROTOCOL` ### `SERVICE` ### `SESSION` ### `UNKNOWN` ## Constructor Detail | public [Type](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FType-1) () |\n| ---------------------------------------------------------------------- | ← [Enum ErrorCode.Category](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/ \"Previous Section\")[Interface RealmEventStreamAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamAsyncTask/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Category/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum ErrorCode.Category On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [FATAL](#fatal)\n* [RECOVERABLE](#recoverable)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.ErrorCode.Category **Enclosing class:** [ErrorCode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/#std-label-io%5Frealm%5Fmongodb%5FErrorCode) ## Enum Constant Summary | Enum Constant and Description                                                       |\n| ----------------------------------------------------------------------------------- |\n| [FATAL](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory%5FFATAL)             |\n| [RECOVERABLE](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory%5FRECOVERABLE) | ## Method Summary | Modifier and Type                                                                          | Method and Description                                                                                                                                       |\n| ------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public static [ErrorCode.Category](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) | [valueOf](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [ErrorCode.Category](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) | [values](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory%5Fvalues) ()                                                                                 | ## Inherited Methods\n\n ## Enum Constant Detail ### `FATAL` public static final [ErrorCode.Category](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) ### `RECOVERABLE` public static final [ErrorCode.Category](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) ## Method Detail ### valueOf | public static [ErrorCode.Category](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) [valueOf](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [ErrorCode.Category](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory) [values](#std-label-io%5Frealm%5Fmongodb%5FErrorCode%5FCategory%5Fvalues) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Enum ErrorCode](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/ \"Previous Section\")[Class ErrorCode.Type](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ErrorCode/Type/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.mongo.result   \n* [io.realm.mongodb.mongo.result.DeleteResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/DeleteResult/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FDeleteResult-1)\n* [io.realm.mongodb.mongo.result.InsertOneResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/InsertOneResult/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FInsertOneResult-1)\n* [io.realm.mongodb.mongo.result.UpdateResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/UpdateResult/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult-1) ← [Class UpdateOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/UpdateOptions/ \"Previous Section\")[Class DeleteResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/DeleteResult/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.mongo.iterable   \n* [io.realm.mongodb.mongo.iterable.AggregateIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/AggregateIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FAggregateIterable-1)\n* [io.realm.mongodb.mongo.iterable.FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1)\n* [io.realm.mongodb.mongo.iterable.MongoCursor](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoCursor/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoCursor)\n* [io.realm.mongodb.mongo.iterable.MongoIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoIterable) ← [Class UpdateDescription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/UpdateDescription/ \"Previous Section\")[Class AggregateIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/AggregateIterable/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Result/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class App.Result On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [get](#get)\n* [getError](#geterror)\n* [getOrDefault](#getordefault)\n* [getOrThrow](#getorthrow)\n* [isSuccess](#issuccess)\n* [success](#success)\n* [withError](#witherror)\n* [withResult](#withresult) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.App.Result **Enclosing class:** [App](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/#std-label-io%5Frealm%5Fmongodb%5FApp-1) Result class representing the result of an async request from this app towards MongoDB Realm. ## Tip ### See also:  * [Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### get | public **T** [get](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult%5Fget) ()                                           |\n| --------------------------------------------------------------------------------------------------------------------- |\n| Returns the response in case the request was a success.**Returns**the response value in case of a successful request. | ### getError | public [AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) [getError](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult%5FgetError) ()           |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the error in case of a failed request.**Returns**the [AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) in case of a failed request. | ### getOrDefault | public **T** [getOrDefault](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult%5FgetOrDefault) (**T** defaultValue)                                                                                                                     |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the response if the request was a success. If it failed, the default value is returned instead.**Returns**the response value in case of a successful request. If the request failed, the default value is returned instead. | ### getOrThrow\n\n ### isSuccess | public **boolean** [isSuccess](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult%5FisSuccess) ()            |\n| -------------------------------------------------------------------------------------------------------- |\n| Returns whether or not request was successful**Returns**true if the request was a success, false if not. | ### success | public static [App.Result](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult) [success](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult%5Fsuccess) <**T** \\>() |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a successful request result with no return value.                                                                                                  | ### withError | public static [App.Result](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult) [withError](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult%5FwithError) <**T** \\>([AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) exception) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a failed request result. The request failed for some reason, either because there was a network error or the Realm Object Server returned an error.**Parameters**exception \\- error that occurred.                                                                                      | ### withResult | public static [App.Result](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult) [withResult](#std-label-io%5Frealm%5Fmongodb%5FApp%5FResult%5FwithResult) <**T** \\>(**T** result) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a successful request result with a return value.**Parameters**result \\- the result value.                                                                            | ← [Interface App.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/ \"Previous Section\")[Class AppConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.mongo.events   \n* [io.realm.mongodb.mongo.events.BaseChangeEvent](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent)\n* [io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/OperationType/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType)\n* [io.realm.mongodb.mongo.events.UpdateDescription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/UpdateDescription/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription) ← [Class MongoNamespace](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoNamespace/ \"Previous Section\")[Class BaseChangeEvent](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class MongoClient On this page * [io.realm.mongodb.mongo](#io.realm.mongodb.mongo)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [getDatabase](#getdatabase)\n* [getServiceName](#getservicename) ## io.realm.mongodb.mongo [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.MongoClient The remote MongoClient used for working with data in MongoDB remotely via Realm. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### getDatabase | public [MongoDatabase](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase) [getDatabase](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoClient%5FgetDatabase) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) databaseName) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets a [MongoDatabase](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase) instance for the given database name.**Parameters**databaseName \\- the name of the database to retrieve**Returns**a RemoteMongoDatabase representing the specified database | ### getServiceName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getServiceName](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoClient%5FgetServiceName) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the service name for this client.**Returns**the service name.                                                                                                        | ← [io.realm.mongodb.mongo](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/ \"Previous Section\")[Class MongoCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class MongoDatabase On this page * [io.realm.mongodb.mongo](#io.realm.mongodb.mongo)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [getCollection](#getcollection)\n* [getName](#getname) ## io.realm.mongodb.mongo [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.MongoDatabase The RemoteMongoDatabase provides access to its **Document** [MongoCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection) s. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### getCollection | public [MongoCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection) [getCollection](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase%5FgetCollection) <**DocumentT** \\>([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) collectionName,[java.lang.Class<DocumentT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) documentClass) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets a collection, with a specific default document class.**Type Parameters**DocumentT \\- the type of the class to use instead of Document .**Parameters**collectionName \\- the name of the collection to returndocumentClass \\- the default class to cast any documents returned from the database into.**Returns**the collection                                                                                                                                  | | public [MongoCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection) [getCollection](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase%5FgetCollection) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) collectionName) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets a collection.**Parameters**collectionName \\- the name of the collection to return**Returns**the collection                                                                                                                                                                                                                         | ### getName\n\n ← [Class MongoCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/ \"Previous Section\")[Class MongoNamespace](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoNamespace/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # io.realm.mongodb.mongo.options   \n* [io.realm.mongodb.mongo.options.CountOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/CountOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions-1)\n* [io.realm.mongodb.mongo.options.FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1)\n* [io.realm.mongodb.mongo.options.FindOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions-1)\n* [io.realm.mongodb.mongo.options.InsertManyResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/InsertManyResult/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FInsertManyResult-1)\n* [io.realm.mongodb.mongo.options.UpdateOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/UpdateOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions-1) ← [Class MongoIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoIterable/ \"Previous Section\")[Class CountOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/CountOptions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoNamespace/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class MongoNamespace On this page * [io.realm.mongodb.mongo](#io.realm.mongodb.mongo)\n* [Constructors](#constructors)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [COMMAND\\_COLLECTION\\_NAME](#command%5Fcollection%5Fname)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [checkCollectionNameValidity](#checkcollectionnamevalidity)\n* [checkDatabaseNameValidity](#checkdatabasenamevalidity)\n* [equals](#equals)\n* [getCollectionName](#getcollectionname)\n* [getDatabaseName](#getdatabasename)\n* [getFullName](#getfullname)\n* [hashCode](#hashcode)\n* [toString](#tostring) ## io.realm.mongodb.mongo [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.MongoNamespace A MongoDB namespace, which includes a database name and collection name. ## Constructors | Constructor and Description                                                                                                                                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [MongoNamespace](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fullName)Construct an instance for the given full name.                                                                                                                       |\n| [MongoNamespace](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) databaseName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) collectionName)Construct an instance from the given database name and collection name. | ## Field Summary\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `COMMAND_COLLECTION_NAME` ## Constructor Detail | public [MongoNamespace](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) fullName)                                                                                                                                                                                                                                                                                          |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Construct an instance for the given full name. The database name is the string preceding the first \".\" character.**Parameters**fullName \\- the non-null full namespaceTipSee also: [checkDatabaseNameValidity(String)](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5FcheckDatabaseNameValidity%5FString%5F)[checkCollectionNameValidity(String)](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5FcheckCollectionNameValidity%5FString%5F) |\n\n ## Method Detail ### checkCollectionNameValidity | public static **void** [checkCollectionNameValidity](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5FcheckCollectionNameValidity) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) collectionName)                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Check the validity of the given collection name. A valid collection name is non-null and non-empty. The server may impose additional restrictions on collection names.**Parameters**collectionName \\- the collection name**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the collection name is invalid | ### checkDatabaseNameValidity | public static **void** [checkDatabaseNameValidity](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5FcheckDatabaseNameValidity) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) databaseName)                                                                                                                                                                                                                                |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Check the validity of the given database name. A valid database name is non-null, non-empty, and does not contain any of the following characters: '\\\\0', '/', '\\\\\\\\', ' ', '\"', '.' . The server may impose additional restrictions on database names.**Parameters**databaseName \\- the database name**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if the database name is invalid | ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                       | ### getCollectionName\n\n ### getDatabaseName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getDatabaseName](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5FgetDatabaseName) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the database name.**Returns**the database name                                                                                                                               | ### getFullName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getFullName](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5FgetFullName) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the full name, which is the database name and the collection name, separated by a period.**Returns**the full name                                                    | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5FhashCode) ()        |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace%5FtoString) ()                                                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the standard MongoDB representation of a namespace, which is <database>.<collection> .**Returns**string representation of the namespace.**Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ← [Class MongoDatabase](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/ \"Previous Section\")[io.realm.mongodb.mongo.events](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/Builder/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class AppConfiguration.Builder On this page * [io.realm.mongodb](#io.realm.mongodb)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [addCustomRequestHeader](#addcustomrequestheader)\n* [addCustomRequestHeaders](#addcustomrequestheaders)\n* [appName](#appname)\n* [appVersion](#appversion)\n* [authorizationHeaderName](#authorizationheadername)\n* [baseUrl](#baseurl)\n* [build](#build)\n* [codecRegistry](#codecregistry)\n* [defaultClientResetHandler](#defaultclientresethandler)\n* [defaultSyncClientResetStrategy](#defaultsyncclientresetstrategy)\n* [defaultSyncErrorHandler](#defaultsyncerrorhandler)\n* [encryptionKey](#encryptionkey)\n* [httpLogObfuscator](#httplogobfuscator)\n* [requestTimeout](#requesttimeout)\n* [syncRootDirectory](#syncrootdirectory) ## io.realm.mongodb [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.AppConfiguration.Builder **Enclosing class:** [AppConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration) Builder used to construct instances of a [AppConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration) in a fluent manner. ## Constructors | Constructor and Description                                                                                                                                                                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) appId)Creates an instance of the Builder for the AppConfiguration. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) appId) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates an instance of the Builder for the AppConfiguration.**Parameters**appId \\- the application id of the MongoDB Realm Application.                            | ## Method Detail ### addCustomRequestHeader | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [addCustomRequestHeader](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FaddCustomRequestHeader) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) headerName,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) headerValue) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds an extra HTTP header to append to every request to a Realm Object Server.**Parameters**headerName \\- the name of the header.headerValue \\- the value of header.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if a non-empty headerName is provided or a null headerValue .                                   | ### addCustomRequestHeaders | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [addCustomRequestHeaders](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FaddCustomRequestHeaders) ([java.util.Map<java.lang.String, java.lang.String>](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) headers) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds extra HTTP headers to append to every request to a Realm Object Server.**Parameters**headers \\- map of (headerName, headerValue) pairs.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- If any of the headers provided are illegal.                              | ### appName\n\n ### appVersion | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [appVersion](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FappVersion) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) appVersion) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the apps version. This is only used as part of debug headers sent when making network requests at the MongoDB Realm application.**Parameters**appVersion \\- app version used to identify the application.                                                                   | ### authorizationHeaderName | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [authorizationHeaderName](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FauthorizationHeaderName) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) headerName)                                                                                                                                                                                                      |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the name of the HTTP header used to send authorization data in when making requests to MongoDB Realm. The MongoDB server or firewall must have been configured to expect a custom authorization header.The default authorization header is named **DEFAULT\\_AUTHORIZATION\\_HEADER\\_NAME**.**Parameters**headerName \\- name of the header.**Throws**[IllegalArgumentException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalArgumentException.html) \\- if a null or empty header is provided. | ### baseUrl | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [baseUrl](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FbaseUrl) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) baseUrl) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the base url for the MongoDB Realm Application. The default value is **DEFAULT\\_BASE\\_URL**.**Parameters**baseUrl \\- the base url for the MongoDB Realm application.                                                                                               | ### build\n\n ### codecRegistry | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [codecRegistry](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FcodecRegistry) (**CodecRegistry** codecRegistry)                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Set the default codec registry used to encode and decode BSON arguments and results when calling remote Realm [io.realm.mongodb.functions.Functions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/functions/Functions/#std-label-io%5Frealm%5Fmongodb%5Ffunctions%5FFunctions) and accessing a remote [io.realm.mongodb.mongo.MongoDatabase](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase) .Will default to **DEFAULT\\_BSON\\_CODEC\\_REGISTRY** if not specified.**Parameters**codecRegistry \\- The default codec registry for the App.TipSee also: **DEFAULT\\_BSON\\_CODEC\\_REGISTRY** **Builder.getDefaultCodecRegistry()** | ### defaultClientResetHandler\n\n ### defaultSyncClientResetStrategy\n\n\n\n ### defaultSyncErrorHandler | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [defaultSyncErrorHandler](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FdefaultSyncErrorHandler) ([SyncSession.ErrorHandler](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/ErrorHandler/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FErrorHandler) errorHandler)                                                                                                                                                                                                                                                                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the default error handler used by Synced Realms when reporting errors with their session.This default can be overridden by calling [io.realm.mongodb.sync.SyncConfiguration.Builder.errorHandler(SyncSession.ErrorHandler)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration%5FBuilder%5FerrorHandler%5FSyncSession%5FErrorHandler%5F) when creating the [io.realm.mongodb.sync.SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) .**Parameters**errorHandler \\- the default error handler. | ### encryptionKey\n\n ### httpLogObfuscator | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [httpLogObfuscator](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FhttpLogObfuscator) ([HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) httpLogObfuscator)                             |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the [HttpLogObfuscator](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/log/obfuscator/HttpLogObfuscator/#std-label-io%5Frealm%5Fmongodb%5Flog%5Fobfuscator%5FHttpLogObfuscator-1) used to keep sensitive information in HTTP requests from being displayed in the logcat.If left unspecified, it will default to obfuscating HTTP login requests.**Parameters**httpLogObfuscator \\- the default HTTP log obfuscator for the app. | ### requestTimeout | public [AppConfiguration.Builder](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder-1) [requestTimeout](#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FBuilder%5FrequestTimeout) (**long** time,[TimeUnit](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/TimeUnit.html) unit)                                                                                                                                                                                     |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the default timeout used by network requests against the MongoDB Realm application. Requests will terminate with a failure if they exceed this limit. The default value is [AppConfiguration.DEFAULT\\_REQUEST\\_TIMEOUT](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/#std-label-io%5Frealm%5Fmongodb%5FAppConfiguration%5FDEFAULT%5FREQUEST%5FTIMEOUT) seconds.**Parameters**time \\- the timeout value for network requests.unit \\- the unit of time used to define the timeout. | ### syncRootDirectory\n\n ← [Class AppConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppConfiguration/ \"Previous Section\")[Interface AuthenticationListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AuthenticationListener/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/DeleteResult/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class DeleteResult On this page * [io.realm.mongodb.mongo.result](#io.realm.mongodb.mongo.result)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getDeletedCount](#getdeletedcount) ## io.realm.mongodb.mongo.result [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.result.DeleteResult The result of a delete operation. ## Constructors | Constructor and Description                                                                                                   |\n| ----------------------------------------------------------------------------------------------------------------------------- |\n| [DeleteResult](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FDeleteResult-1) (**long** deletedCount)Constructs a result. | ## Method Summary | Modifier and Type | Method and Description                                                                                                                       |\n| ----------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **long**   | [getDeletedCount](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FDeleteResult%5FgetDeletedCount) ()Gets the number of documents deleted. | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [DeleteResult](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FDeleteResult-1) (**long** deletedCount) |\n| ---------------------------------------------------------------------------------------------------------------- |\n| Constructs a result.**Parameters**deletedCount \\- the number of documents deleted.                               | ## Method Detail ### getDeletedCount | public **long** [getDeletedCount](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FDeleteResult%5FgetDeletedCount) () |\n| ----------------------------------------------------------------------------------------------------------------------- |\n| Gets the number of documents deleted.**Returns**the number of documents deleted                                         |\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/InsertOneResult/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class InsertOneResult On this page * [io.realm.mongodb.mongo.result](#io.realm.mongodb.mongo.result)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getInsertedId](#getinsertedid) ## io.realm.mongodb.mongo.result [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.result.InsertOneResult The result of an insert one operation. ## Constructors | Constructor and Description                                                                                                            |\n| -------------------------------------------------------------------------------------------------------------------------------------- |\n| [InsertOneResult](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FInsertOneResult-1) (**BsonValue** insertedId)Constructs a result. | ## Method Summary | Modifier and Type    | Method and Description                                                                                                                           |\n| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |\n| public **BsonValue** | [getInsertedId](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FInsertOneResult%5FgetInsertedId) ()Returns the \\_id of the inserted document. | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [InsertOneResult](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FInsertOneResult-1) (**BsonValue** insertedId) |\n| ------------------------------------------------------------------------------------------------------------------------- |\n| Constructs a result.**Parameters**insertedId \\- the \\_id of the inserted document.                                        | ## Method Detail ### getInsertedId | public **BsonValue** [getInsertedId](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FInsertOneResult%5FgetInsertedId) () |\n| --------------------------------------------------------------------------------------------------------------------------- |\n| Returns the \\_id of the inserted document.**Returns**the \\_id of the inserted document.                                     |\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/EmailPasswordAuth/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class EmailPasswordAuth On this page * [io.realm.mongodb.auth](#io.realm.mongodb.auth)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [call](#call)\n* [callResetPasswordFunction](#callresetpasswordfunction)\n* [callResetPasswordFunctionAsync](#callresetpasswordfunctionasync)\n* [confirmUser](#confirmuser)\n* [confirmUserAsync](#confirmuserasync)\n* [registerUser](#registeruser)\n* [registerUserAsync](#registeruserasync)\n* [resendConfirmationEmail](#resendconfirmationemail)\n* [resendConfirmationEmailAsync](#resendconfirmationemailasync)\n* [resetPassword](#resetpassword)\n* [resetPasswordAsync](#resetpasswordasync)\n* [retryCustomConfirmation](#retrycustomconfirmation)\n* [retryCustomConfirmationAsync](#retrycustomconfirmationasync)\n* [sendResetPasswordEmail](#sendresetpasswordemail)\n* [sendResetPasswordEmailAsync](#sendresetpasswordemailasync) ## io.realm.mongodb.auth [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.auth.EmailPasswordAuth Class encapsulating functionality provided when [User](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/User/#std-label-io%5Frealm%5Fmongodb%5FUser) 's are logged in through the [Credentials.Provider.EMAIL\\_PASSWORD](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-Credentials%5FProvider%5FEMAIL%5FPASSWORD) provider. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### call | protected abstract **void** [call](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5Fcall) (**int** functionType,**OsJavaNetworkTransport.NetworkTransportJNIResultCallback** callback,[java.lang.String\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) args) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### callResetPasswordFunction | public **void** [callResetPasswordFunction](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FcallResetPasswordFunction) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) email,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) newPassword,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                                                                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Call the reset password function configured to the [Credentials.Provider.EMAIL\\_PASSWORD](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/Credentials/Provider/#std-label-Credentials%5FProvider%5FEMAIL%5FPASSWORD) provider.**Parameters**email \\- the email of the user.newPassword \\- the new password of the user.args \\- any additional arguments provided to the reset function. All arguments must be able to be converted to JSON compatible values using toString() .**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to confirm the user. | ### callResetPasswordFunctionAsync\n\n ### confirmUser | public **void** [confirmUser](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FconfirmUser) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) token,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) tokenId)                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Confirms a user with the given token and token id.**Parameters**token \\- the confirmation token.tokenId \\- the id of the confirmation token.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to confirm the user. | ### confirmUserAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [confirmUserAsync](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FconfirmUserAsync) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) token,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) tokenId,[io.realm.mongodb.App.Callback<java.lang.Void>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Confirms a user with the given token and token id.**Parameters**token \\- the confirmation token.tokenId \\- the id of the confirmation token.callback \\- callback when confirmation has completed or failed. The callback will always happen on the same thread as this method is called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread.                                                                                                      | ### registerUser\n\n ### registerUserAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [registerUserAsync](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FregisterUserAsync) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) email,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) password,[io.realm.mongodb.App.Callback<java.lang.Void>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback)                                                                                                                                                                                       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Registers a new user with the given email and password.**Parameters**email \\- the email to register with. This will be the username used during log in.password \\- the password to associated with the email. The password must be between 6 and 128 characters long.callback \\- callback when registration has completed or failed. The callback will always happen on the same thread as this method is called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread.[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to register the user. | ### resendConfirmationEmail | public **void** [resendConfirmationEmail](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FresendConfirmationEmail) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) email)                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Resend the confirmation for a user to the given email.**Parameters**email \\- the email of the user.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to confirm the user. | ### resendConfirmationEmailAsync\n\n ### resetPassword | public **void** [resetPassword](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FresetPassword) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) token,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) tokenId,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) newPassword)                                                                                                                     |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Resets the password of a user with the given token, token id, and new password.**Parameters**token \\- the reset password token.tokenId \\- the id of the reset password token.newPassword \\- the new password for the user identified by the token . The password must be between 6 and 128 characters long.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to confirm the user. | ### resetPasswordAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [resetPasswordAsync](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FresetPasswordAsync) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) token,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) tokenId,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) newPassword,[io.realm.mongodb.App.Callback<java.lang.Void>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Resets the newPassword of a user with the given token, token id, and new password.**Parameters**token \\- the reset password token.tokenId \\- the id of the reset password token.newPassword \\- the new password for the user identified by the token . The password must be between 6 and 128 characters long.callback \\- callback when the reset has completed or failed. The callback will always happen on the same thread as this this method is called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread.                            | ### retryCustomConfirmation\n\n ### retryCustomConfirmationAsync | public [RealmAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAsyncTask/#std-label-io%5Frealm%5FRealmAsyncTask) [retryCustomConfirmationAsync](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FretryCustomConfirmationAsync) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) email,[io.realm.mongodb.App.Callback<java.lang.Void>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/App/Callback/#std-label-io%5Frealm%5Fmongodb%5FApp%5FCallback) callback) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Retries the custom confirmation on a user for a given email.**Parameters**email \\- the email of the user.callback \\- callback when retrying the custom confirmation has completed or failed. The callback will always happen on the same thread as this method is called on.**Throws**[IllegalStateException](https://docs.oracle.com/javase/7/docs/api/java/lang/IllegalStateException.html) \\- if called from a non-looper thread.                                                           | ### sendResetPasswordEmail | public **void** [sendResetPasswordEmail](#std-label-io%5Frealm%5Fmongodb%5Fauth%5FEmailPasswordAuth%5FsendResetPasswordEmail) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) email)                                                                     |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sends a user a password reset email for the given email.**Parameters**email \\- the email of the user.**Throws**[AppException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/AppException/#std-label-io%5Frealm%5Fmongodb%5FAppException-1) \\- if the server failed to confirm the user. | ### sendResetPasswordEmailAsync\n\n ← [Class ApiKeyAuth](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/ApiKeyAuth/ \"Previous Section\")[Enum GoogleAuthType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/auth/GoogleAuthType/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/UpdateResult/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class UpdateResult On this page * [io.realm.mongodb.mongo.result](#io.realm.mongodb.mongo.result)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getMatchedCount](#getmatchedcount)\n* [getModifiedCount](#getmodifiedcount)\n* [getUpsertedId](#getupsertedid) ## io.realm.mongodb.mongo.result [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.result.UpdateResult The result of an update operation. ## Constructors | Constructor and Description                                                                                                                                                   |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [UpdateResult](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult-1) (**long** matchedCount,**long** modifiedCount,**BsonValue** upsertedId)Constructs a result. | ## Method Summary | Modifier and Type    | Method and Description                                                                                                                                                                                      |\n| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **long**      | [getMatchedCount](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult%5FgetMatchedCount) ()Returns the number of documents matched by the query.                                                |\n| public **long**      | [getModifiedCount](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult%5FgetModifiedCount) ()Returns the number of documents modified.                                                          |\n| public **BsonValue** | [getUpsertedId](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult%5FgetUpsertedId) ()If the replace resulted in an inserted document, gets the \\_id of the inserted document, otherwise null. |\n\n * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [UpdateResult](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult-1) (**long** matchedCount,**long** modifiedCount,**BsonValue** upsertedId)                                                                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Constructs a result.**Parameters**matchedCount \\- the number of documents matched by the query.modifiedCount \\- the number of documents modified.upsertedId \\- the \\_id of the inserted document if the replace resulted in an inserted document, otherwise null. | ## Method Detail ### getMatchedCount | public **long** [getMatchedCount](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult%5FgetMatchedCount) () |\n| ----------------------------------------------------------------------------------------------------------------------- |\n| Returns the number of documents matched by the query.**Returns**the number of documents matched.                        | ### getModifiedCount | public **long** [getModifiedCount](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult%5FgetModifiedCount) () |\n| ------------------------------------------------------------------------------------------------------------------------- |\n| Returns the number of documents modified.**Returns**the number of documents modified.                                     | ### getUpsertedId | public **BsonValue** [getUpsertedId](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fresult%5FUpdateResult%5FgetUpsertedId) ()                                                                                               |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| If the replace resulted in an inserted document, gets the \\_id of the inserted document, otherwise null.**Returns**if the replace resulted in an inserted document, the \\_id of the inserted document, otherwise null. | ← [Class InsertOneResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/InsertOneResult/ \"Previous Section\")[io.realm.mongodb.push](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/push/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/OperationType/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum BaseChangeEvent.OperationType On this page * [io.realm.mongodb.mongo.events](#io.realm.mongodb.mongo.events)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [DELETE](#delete)\n* [INSERT](#insert)\n* [REPLACE](#replace)\n* [UNKNOWN](#unknown)\n* [UPDATE](#update)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.mongodb.mongo.events [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.mongodb.mongo.events.BaseChangeEvent.OperationType **Enclosing class:** [BaseChangeEvent](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent) Represents the different MongoDB operations that can occur. ## Enum Constant Summary | Enum Constant and Description                                                                           |\n| ------------------------------------------------------------------------------------------------------- |\n| [DELETE](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType%5FDELETE)   |\n| [INSERT](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType%5FINSERT)   |\n| [REPLACE](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType%5FREPLACE) |\n| [UNKNOWN](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType%5FUNKNOWN) |\n| [UPDATE](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType%5FUPDATE)   | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `DELETE` public static final [BaseChangeEvent.OperationType](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) ### `INSERT` public static final [BaseChangeEvent.OperationType](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) ### `REPLACE` public static final [BaseChangeEvent.OperationType](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) ### `UNKNOWN` public static final [BaseChangeEvent.OperationType](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) ### `UPDATE` public static final [BaseChangeEvent.OperationType](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) ## Method Detail ### valueOf | public static [BaseChangeEvent.OperationType](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) [valueOf](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [BaseChangeEvent.OperationType](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) [values](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType%5Fvalues) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ← [Class BaseChangeEvent](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/ \"Previous Section\")[Class UpdateDescription](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/UpdateDescription/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class BaseChangeEvent On this page * [io.realm.mongodb.mongo.events](#io.realm.mongodb.mongo.events)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [getDocumentKey](#getdocumentkey)\n* [getFullDocument](#getfulldocument)\n* [getOperationType](#getoperationtype)\n* [getUpdateDescription](#getupdatedescription)\n* [hasUncommittedWrites](#hasuncommittedwrites)\n* [toBsonDocument](#tobsondocument) ## io.realm.mongodb.mongo.events [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.events.BaseChangeEvent Represents the set of properties that exist on all MongoDB realm change events produced by watch streams in this SDK. Other change event types inherit from this type. ## Nested Class Summary | Modifier and Type   | Class and Description                                                                                                                                                                                    |\n| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static final | [BaseChangeEvent.OperationType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/OperationType/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### getDocumentKey | public **BsonDocument** [getDocumentKey](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FgetDocumentKey) () |\n| -------------------------------------------------------------------------------------------------------------------------------- |\n| The unique identifier for the document that was actually changed.**Returns**the document key.                                    | ### getFullDocument | public **DocumentT** [getFullDocument](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FgetFullDocument) () |\n| ------------------------------------------------------------------------------------------------------------------------------- |\n| The full document at some point after the change has been applied.**Returns**the full document.                                 | ### getOperationType | public [BaseChangeEvent.OperationType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/OperationType/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FOperationType) [getOperationType](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FgetOperationType) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the operation type of the change that triggered the change event.**Returns**the operation type of this change event.                                                                                                                                                                                                 | ### getUpdateDescription\n\n ### hasUncommittedWrites | public **boolean** [hasUncommittedWrites](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FhasUncommittedWrites) ()                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Indicates a local change event that has not yet been synchronized with a remote data store. Used only for the sync use case.**Returns**whether or not this change event represents uncommitted writes. | ### toBsonDocument | public abstract **BsonDocument** [toBsonDocument](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FBaseChangeEvent%5FtoBsonDocument) ()                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Converts the change event to a BSON representation, as it would look on a MongoDB realm change stream, or a Realm compact watch stream.**Returns**The BSON document representation of the change event. | ← [io.realm.mongodb.mongo.events](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/ \"Previous Section\")[Enum BaseChangeEvent.OperationType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/OperationType/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/UpdateDescription/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class UpdateDescription On this page * [io.realm.mongodb.mongo.events](#io.realm.mongodb.mongo.events)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [diff](#diff)\n* [equals](#equals)\n* [fromBsonDocument](#frombsondocument)\n* [getRemovedFields](#getremovedfields)\n* [getUpdatedFields](#getupdatedfields)\n* [hashCode](#hashcode)\n* [isEmpty](#isempty)\n* [merge](#merge)\n* [toBsonDocument](#tobsondocument)\n* [toUpdateDocument](#toupdatedocument) ## io.realm.mongodb.mongo.events [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.events.UpdateDescription Indicates which fields have been modified in a given update operation. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### diff | public static [UpdateDescription](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription) [diff](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5Fdiff) (**BsonDocument** beforeDocument,**BsonDocument** afterDocument)                                                                                                                       |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Find the diff between two documents.NOTE: This does not do a full diff on \\[BsonArray\\]. If there is an inequality between the old and new array, the old array will simply be replaced by the new one.**Parameters**beforeDocument \\- original documentafterDocument \\- document to diff on**Returns**a description of the updated fields and removed keys between the documents. | ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) obj) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                                     | ### fromBsonDocument | public static [UpdateDescription](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription) [fromBsonDocument](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5FfromBsonDocument) (**BsonDocument** document) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Converts an update description BSON document from a MongoDB Change Event into an UpdateDescription object.**Parameters**document \\- the**Returns**the converted UpdateDescription                                                               | ### getRemovedFields | public [Collection](https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html) [getRemovedFields](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5FgetRemovedFields) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a [List](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) containing the field names that have been removed in the corresponding update.**Returns**the removed fields names.      | ### getUpdatedFields\n\n ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5FhashCode) () |\n| ------------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)      | ### isEmpty | public **boolean** [isEmpty](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5FisEmpty) ()         |\n| ----------------------------------------------------------------------------------------------------------------------- |\n| Determines whether this update description is empty.**Returns**true if the update description is empty, false otherwise | ### merge | public [UpdateDescription](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription) [merge](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5Fmerge) ([UpdateDescription](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription) otherDescription) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Unilaterally merge an update description into this update description.**Parameters**otherDescription \\- the update description to merge into this**Returns**this merged update description                                                                                                          | ### toBsonDocument | public **BsonDocument** [toBsonDocument](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5FtoBsonDocument) ()                                                           |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Converts this update description to its document representation as it would appear in a MongoDB Change Event.**Returns**the update description document as it would appear in a change event | ### toUpdateDocument | public **BsonDocument** [toUpdateDocument](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fevents%5FUpdateDescription%5FtoUpdateDocument) () |\n| -------------------------------------------------------------------------------------------------------------------------------------- |\n| Convert this update description to an update document.**Returns**an update document with the appropriate $set and $unset documents.    | ← [Enum BaseChangeEvent.OperationType](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/events/BaseChangeEvent/OperationType/ \"Previous Section\")[io.realm.mongodb.mongo.iterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/InsertManyResult/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class InsertManyResult On this page * [io.realm.mongodb.mongo.options](#io.realm.mongodb.mongo.options)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getInsertedIds](#getinsertedids) ## io.realm.mongodb.mongo.options [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.options.InsertManyResult The result of an insert many operation. ## Constructors | Constructor and Description                                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [InsertManyResult](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FInsertManyResult-1) ([java.util.Map<java.lang.Long, BsonValue>](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) insertedIds)Constructs a result. | ## Method Summary | Modifier and Type                                                          | Method and Description                                                                                                                                                                                                                   |\n| -------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public [Map](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) | [getInsertedIds](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FInsertManyResult%5FgetInsertedIds) ()Returns the \\_ids of the inserted documents arranged by the index of the document from the operation and its corresponding id. | ## Inherited Methods\n\n ## Constructor Detail | public [InsertManyResult](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FInsertManyResult-1) ([java.util.Map<java.lang.Long, BsonValue>](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) insertedIds) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Constructs a result.**Parameters**insertedIds \\- the \\_ids of the inserted documents arranged by the index of the document from the operation and its corresponding id.                                                  | ## Method Detail ### getInsertedIds | public [Map](https://docs.oracle.com/javase/7/docs/api/java/util/Map.html) [getInsertedIds](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FInsertManyResult%5FgetInsertedIds) ()                                                                           |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the \\_ids of the inserted documents arranged by the index of the document from the operation and its corresponding id.**Returns**the \\_ids of the inserted documents arranged by the index of the document from the operation and its corresponding id. | ← [Class FindOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOptions/ \"Previous Section\")[Class UpdateOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/UpdateOptions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/CountOptions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class CountOptions On this page * [io.realm.mongodb.mongo.options](#io.realm.mongodb.mongo.options)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getLimit](#getlimit)\n* [limit](#limit)\n* [toString](#tostring) ## io.realm.mongodb.mongo.options [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.options.CountOptions The options for a count operation. ## Constructors | Constructor and Description                                                           |\n| ------------------------------------------------------------------------------------- |\n| [CountOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions-1) () | ## Method Summary | Modifier and Type                                                                         | Method and Description                                                                                                    |\n| ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- |\n| public **int**                                                                            | [getLimit](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions%5FgetLimit) ()Gets the limit to apply.        |\n| public [CountOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions-1) | [limit](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions%5Flimit) (**int** limit)Sets the limit to apply. |\n| public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html)          | [toString](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions%5FtoString) ()                                | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail\n\n ## Method Detail ### getLimit | public **int** [getLimit](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions%5FgetLimit) () |\n| --------------------------------------------------------------------------------------------------------- |\n| Gets the limit to apply. The default is 0, which means there is no limit.**Returns**the limit             | ### limit | public [CountOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions-1) [limit](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions%5Flimit) (**int** limit) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the limit to apply.**Parameters**limit \\- the limit**Returns**this                                                                                                                     | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions%5FtoString) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                    | ← [io.realm.mongodb.mongo.options](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/ \"Previous Section\")[Class FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/UpdateOptions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class UpdateOptions On this page * [io.realm.mongodb.mongo.options](#io.realm.mongodb.mongo.options)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [isUpsert](#isupsert)\n* [toString](#tostring)\n* [upsert](#upsert) ## io.realm.mongodb.mongo.options [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.options.UpdateOptions The options to apply when updating documents. ## Constructors | Constructor and Description                                                             |\n| --------------------------------------------------------------------------------------- |\n| [UpdateOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions-1) () | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [UpdateOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions-1) () |\n| ---------------------------------------------------------------------------------------------- | ## Method Detail ### isUpsert | public **boolean** [isUpsert](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions%5FisUpsert) ()                                                                                                       |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns true if a new document should be inserted if there are no matches to the query filter. The default is false.**Returns**true if a new document should be inserted if there are no matches to the query filter | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions%5FtoString) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                     | ### upsert | public [UpdateOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions-1) [upsert](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions%5Fupsert) (**boolean** upsert)                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Set to true if a new document should be inserted if there are no matches to the query filter.**Parameters**upsert \\- true if a new document should be inserted if there are no matches to the query filter.**Returns**this | ← [Class InsertManyResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/InsertManyResult/ \"Previous Section\")[io.realm.mongodb.mongo.result](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/result/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/AggregateIterable/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class AggregateIterable On this page * [io.realm.mongodb.mongo.iterable](#io.realm.mongodb.mongo.iterable)\n* [Constructors](#constructors)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail) ## io.realm.mongodb.mongo.iterable [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [io.realm.mongodb.mongo.iterable.MongoIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoIterable) io.realm.mongodb.mongo.iterable.AggregateIterable Specific iterable for [io.realm.mongodb.mongo.MongoCollection.aggregate(List)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Faggregate%5FList%5F) operations. ## Constructors\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [io.realm.mongodb.mongo.iterable.MongoIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoIterable) : `iterator` , `first` ## Constructor Detail | public [AggregateIterable](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FAggregateIterable-1) ([ThreadPoolExecutor](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html) threadPoolExecutor,**<any>** osMongoCollection,**CodecRegistry** codecRegistry,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass,[java.util.List<? extends Bson>](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) pipeline) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ← [io.realm.mongodb.mongo.iterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/ \"Previous Section\")[Class FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoCursor/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class MongoCursor On this page * [io.realm.mongodb.mongo.iterable](#io.realm.mongodb.mongo.iterable)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [close](#close)\n* [hasNext](#hasnext)\n* [next](#next)\n* [tryNext](#trynext) ## io.realm.mongodb.mongo.iterable [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.iterable.MongoCursor **Implemented interfaces:** * [java.util.Iterator](https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html)\n* [java.io.Closeable](https://docs.oracle.com/javase/7/docs/api/java/io/Closeable.html)\n* [java.lang.AutoCloseable](https://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html) The Mongo Cursor class is fundamentally an [Iterator](https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html) containing an additional `tryNext()` method for convenience. An application should ensure that a cursor is closed in all circumstances, e.g. using a try-with-resources statement. ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### close | public **void** [close](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoCursor%5Fclose) () |\n| ---------------------------------------------------------------------------------------------------- | ### hasNext | public **boolean** [hasNext](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoCursor%5FhasNext) () |\n| ----------------------------------------------------------------------------------------------------------- | ### next | public **ResultT** [next](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoCursor%5Fnext) () |\n| ----------------------------------------------------------------------------------------------------- | ### tryNext | public **ResultT** [tryNext](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoCursor%5FtryNext) ()                                    |\n| ---------------------------------------------------------------------------------------------------------------------------------------------- |\n| A special next() case that returns the next document if available or null.**Returns**A Task containing the next document if available or null. | ← [Class FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/ \"Previous Section\")[Class MongoIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoIterable/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOptions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class FindOptions On this page * [io.realm.mongodb.mongo.options](#io.realm.mongodb.mongo.options)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getLimit](#getlimit)\n* [getProjection](#getprojection)\n* [getSort](#getsort)\n* [limit](#limit)\n* [projection](#projection)\n* [sort](#sort)\n* [toString](#tostring) ## io.realm.mongodb.mongo.options [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.options.FindOptions The options to apply to a find operation (also commonly referred to as a query). ## Constructors | Constructor and Description                                                                                  |\n| ------------------------------------------------------------------------------------------------------------ |\n| [FindOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions-1) ()Construct a new instance. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [FindOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions-1) () |\n| ------------------------------------------------------------------------------------------ |\n| Construct a new instance.                                                                  | ## Method Detail ### getLimit | public **int** [getLimit](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions%5FgetLimit) () |\n| -------------------------------------------------------------------------------------------------------- |\n| Gets the limit to apply. The default is null.**Returns**the limit                                        | ### getProjection | public **Bson** [getProjection](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions%5FgetProjection) ()           |\n| ----------------------------------------------------------------------------------------------------------------------------- |\n| Gets a document describing the fields to return for all matching documents.**Returns**the project document, which may be null | ### getSort | public **Bson** [getSort](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions%5FgetSort) ()                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the sort criteria to apply to the query. The default is null, which means that the documents will be returned in an undefined order.**Returns**a document describing the sort criteria | ### limit | public [FindOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions-1) [limit](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions%5Flimit) (**int** limit) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the limit to apply.**Parameters**limit \\- the limit, which may be null**Returns**this                                                                                               | ### projection\n\n ### sort | public [FindOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions-1) [sort](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions%5Fsort) (**Bson** sort) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the sort criteria to apply to the query.**Parameters**sort \\- the sort criteria, which may be null.**Returns**this                                                                | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions%5FtoString) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                   | ← [Class FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/ \"Previous Section\")[Class InsertManyResult](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/InsertManyResult/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoIterable/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class MongoIterable On this page * [io.realm.mongodb.mongo.iterable](#io.realm.mongodb.mongo.iterable)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [first](#first)\n* [iterator](#iterator) ## io.realm.mongodb.mongo.iterable [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.iterable.MongoIterable The MongoIterable is the results from an operation, such as a `find()` or an `aggregate()` query. This class somewhat mimics the behavior of an [Iterable](https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html) but given its results are obtained asynchronously, its values are wrapped inside a `Task` . ## Method Summary | Modifier and Type                                                                                                                     | Method and Description                                                                                                                                      |\n| ------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) | [first](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoIterable%5Ffirst) ()Helper to return the first item in the iterator or null.              |\n| public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) | [iterator](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoIterable%5Fiterator) ()Returns a cursor of the operation represented by this iterable. | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### first\n\n ### iterator | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [iterator](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoIterable%5Fiterator) ()                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns a cursor of the operation represented by this iterable.The result is wrapped in a Task since the iterator should be capable of asynchronously retrieve documents from the server.**Returns**an asynchronous task with cursor of the operation represented by this iterable. | ← [Class MongoCursor](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoCursor/ \"Previous Section\")[io.realm.mongodb.mongo.options](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class FindIterable On this page * [io.realm.mongodb.mongo.iterable](#io.realm.mongodb.mongo.iterable)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [filter](#filter)\n* [limit](#limit)\n* [projection](#projection)\n* [sort](#sort) ## io.realm.mongodb.mongo.iterable [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [io.realm.mongodb.mongo.iterable.MongoIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoIterable) io.realm.mongodb.mongo.iterable.FindIterable Specific iterable for [io.realm.mongodb.mongo.MongoCollection.find()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Ffind%5F%5F) operations. ## Constructors | Constructor and Description                                                                                                                                                                                                                                                                                                                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [FindIterable](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) ([ThreadPoolExecutor](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html) threadPoolExecutor,**<any>** osMongoCollection,**CodecRegistry** codecRegistry,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [io.realm.mongodb.mongo.iterable.MongoIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FMongoIterable) : `iterator` , `first` ## Constructor Detail | public [FindIterable](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) ([ThreadPoolExecutor](https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html) threadPoolExecutor,**<any>** osMongoCollection,**CodecRegistry** codecRegistry,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ## Method Detail ### filter | public [FindIterable](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) [filter](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable%5Ffilter) (**Bson** filter) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the query filter to apply to the query.**Parameters**filter \\- the filter, which may be null.**Returns**this                                                                                 | ### limit | public [FindIterable](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) [limit](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable%5Flimit) (**int** limit) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the limit to apply.**Parameters**limit \\- the limit, which may be 0**Returns**this                                                                                                       | ### projection | public [FindIterable](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) [projection](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable%5Fprojection) (**Bson** projection) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets a document describing the fields to return for all matching documents.**Parameters**projection \\- the project document, which may be null.**Returns**this                                                | ### sort\n\n ← [Class AggregateIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/AggregateIterable/ \"Previous Section\")[Class MongoCursor](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/MongoCursor/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class FindOneAndModifyOptions On this page * [io.realm.mongodb.mongo.options](#io.realm.mongodb.mongo.options)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getProjection](#getprojection)\n* [getSort](#getsort)\n* [isReturnNewDocument](#isreturnnewdocument)\n* [isUpsert](#isupsert)\n* [projection](#projection)\n* [returnNewDocument](#returnnewdocument)\n* [sort](#sort)\n* [toString](#tostring)\n* [upsert](#upsert) ## io.realm.mongodb.mongo.options [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.options.FindOneAndModifyOptions The options to apply to a findOneAndUpdate, findOneAndReplace, or findOneAndDelete operation (also commonly referred to as findOneAndModify operations). ## Constructors | Constructor and Description                                                                                 |\n| ----------------------------------------------------------------------------------------------------------- |\n| [FindOneAndModifyOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) () | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [FindOneAndModifyOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) () |\n| ------------------------------------------------------------------------------------------------------------------ | ## Method Detail ### getProjection | public **Bson** [getProjection](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions%5FgetProjection) () |\n| ------------------------------------------------------------------------------------------------------------------------------- |\n| Gets a document describing the fields to return for all matching documents.**Returns**the project document, which may be null   | ### getSort | public **Bson** [getSort](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions%5FgetSort) ()                                                                         |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the sort criteria to apply to the query. The default is null, which means that the documents will be returned in an undefined order.**Returns**a document describing the sort criteria | ### isReturnNewDocument | public **boolean** [isReturnNewDocument](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions%5FisReturnNewDocument) ()                                                                                                                                                           |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns true if the findOneAndModify operation should return the new document. The default is false Note: Only findOneAndUpdate and findOneAndReplace take this options findOneAndDelete will always return the old document**Returns**true if findOneAndModify operation should return the new document | ### isUpsert\n\n ### projection | public [FindOneAndModifyOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) [projection](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions%5Fprojection) (**Bson** projection) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets a document describing the fields to return for all matching documents.**Parameters**projection \\- the project document, which may be null.**Returns**this                                                                               | ### returnNewDocument | public [FindOneAndModifyOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) [returnNewDocument](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions%5FreturnNewDocument) (**boolean** returnNewDocument)                                                                                                                                                          |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Set to true if findOneAndModify operations should return the new updated document. Set to false / leave blank to have these operation return the document before the update. Note: Only findOneAndUpdate and findOneAndReplace take this options findOneAndDelete will always return the old document**Parameters**returnNewDocument \\- true if findOneAndModify operations should return the updated document**Returns**this | ### sort | public [FindOneAndModifyOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) [sort](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions%5Fsort) (**Bson** sort) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Sets the sort criteria to apply to the query.**Parameters**sort \\- the sort criteria, which may be null.**Returns**this                                                                                                    | ### toString\n\n ### upsert | public [FindOneAndModifyOptions](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) [upsert](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions%5Fupsert) (**boolean** upsert) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Set to true if a new document should be inserted if there are no matches to the query filter.**Parameters**upsert \\- true if a new document should be inserted if there are no matches to the query filter.**Returns**this          | ← [Class CountOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/CountOptions/ \"Previous Section\")[Class FindOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOptions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/State/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum OrderedCollectionChangeSet.State On this page * [io.realm](#io.realm)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [ERROR](#error)\n* [INITIAL](#initial)\n* [UPDATE](#update)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.OrderedCollectionChangeSet.State **Enclosing class:** [OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/#std-label-io%5Frealm%5FOrderedCollectionChangeSet) State describing the nature of the changeset. ## Enum Constant Summary | Enum Constant and Description                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| [ERROR](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState%5FERROR)This state is used if some error occurred on the background evaluating the query. |\n| [INITIAL](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState%5FINITIAL)This state is used first time the callback is invoked.                        |\n| [UPDATE](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState%5FUPDATE)This state is used for every subsequent update after the first.                 | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `ERROR` public static final [OrderedCollectionChangeSet.State](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState) This state is used if some error occurred on the background evaluating the query.For local and fully synchronized Realms, this state should only be encountered if the Realm could not be succesfully opened in the background,. ### `INITIAL` public static final [OrderedCollectionChangeSet.State](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState) This state is used first time the callback is invoked. The query will have completed and data is ready for the UI. ### `UPDATE` public static final [OrderedCollectionChangeSet.State](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState) This state is used for every subsequent update after the first. ## Method Detail ### valueOf | public static [OrderedCollectionChangeSet.State](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState) [valueOf](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [OrderedCollectionChangeSet.State](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState) [values](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FState%5Fvalues) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class OrderedCollectionChangeSet.Range](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/ \"Previous Section\")[Interface OrderedRealmCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/Range/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class OrderedCollectionChangeSet.Range On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [length](#length)\n* [startIndex](#startindex)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [toString](#tostring) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.OrderedCollectionChangeSet.Range **Enclosing class:** [OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/#std-label-io%5Frealm%5FOrderedCollectionChangeSet) ## Constructors | Constructor and Description                                                                                                                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Range](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) (**int** startIndex,**int** length)Creates a [Range](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) with given start index and length. | ## Field Summary | Modifier and Type    | Field and Description                                                                                                      |\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------- |\n| public final **int** | [length](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange%5Flength)How many elements are inside this range.      |\n| public final **int** | [startIndex](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange%5FstartIndex)The start index of this change range. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `length` How many elements are inside this range. ### `startIndex` The start index of this change range. ## Constructor Detail | public [Range](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) (**int** startIndex,**int** length)                                                                                                                      |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a [Range](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange-1) with given start index and length.**Parameters**startIndex \\- the start index of this change range.length \\- how many elements are inside this range. | ## Method Detail ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5FOrderedCollectionChangeSet%5FRange%5FtoString) () |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                              | ← [Interface OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/ \"Previous Section\")[Enum OrderedCollectionChangeSet.State](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/State/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/DownloadingRealmInterruptedException/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Exception DownloadingRealmInterruptedException On this page * [io.realm.exceptions](#io.realm.exceptions)\n* [Constructors](#constructors)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail) ## io.realm.exceptions [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [java.lang.Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) [java.lang.RuntimeException](https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) io.realm.exceptions.DownloadingRealmInterruptedException Exception class used when a Realm was interrupted while downloading the initial data set. This can only happen if [SyncConfiguration.Builder.waitForInitialRemoteData()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/Builder/#std-label-SyncConfiguration%5FBuilder%5FwaitForInitialRemoteData%5F%5F) is set. ## Constructors | Constructor and Description                                                                                                                                                                                                                                                                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [DownloadingRealmInterruptedException](#std-label-io%5Frealm%5Fexceptions%5FDownloadingRealmInterruptedException-1) ([SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) syncConfig,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception) |\n| [DownloadingRealmInterruptedException](#std-label-io%5Frealm%5Fexceptions%5FDownloadingRealmInterruptedException-1) ([SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) syncConfig,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message)         | ## Inherited Methods\n\n ## Constructor Detail | public [DownloadingRealmInterruptedException](#std-label-io%5Frealm%5Fexceptions%5FDownloadingRealmInterruptedException-1) ([SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) syncConfig,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | public [DownloadingRealmInterruptedException](#std-label-io%5Frealm%5Fexceptions%5FDownloadingRealmInterruptedException-1) ([SyncConfiguration](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncConfiguration/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncConfiguration) syncConfig,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Enum RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/ \"Previous Section\")[Exception RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmPrimaryKeyConstraintException/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Exception RealmPrimaryKeyConstraintException On this page * [io.realm.exceptions](#io.realm.exceptions)\n* [Constructors](#constructors)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail) ## io.realm.exceptions [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [java.lang.Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) [java.lang.RuntimeException](https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) io.realm.exceptions.RealmPrimaryKeyConstraintException Class for reporting problems when the primary key constraint is being broken. ## Tip ### See also:  * [io.realm.annotations.PrimaryKey](https://mongodb.com/docs/realm/sdk/java/api/io/realm/annotations/PrimaryKey/#std-label-io%5Frealm%5Fannotations%5FPrimaryKey) ## Constructors | Constructor and Description                                                                                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [RealmPrimaryKeyConstraintException](#std-label-io%5Frealm%5Fexceptions%5FRealmPrimaryKeyConstraintException-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message) | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) : `getMessage` , `getLocalizedMessage` , `getCause` , `initCause` , `toString` , `printStackTrace` , `printStackTrace` , `printStackTrace` , `fillInStackTrace` , `getStackTrace` , `setStackTrace` , `addSuppressed` , `getSuppressed` ## Constructor Detail | public [RealmPrimaryKeyConstraintException](#std-label-io%5Frealm%5Fexceptions%5FRealmPrimaryKeyConstraintException-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Exception RealmMigrationNeededException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmMigrationNeededException/ \"Previous Section\")[Error RealmError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmError/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Exception RealmException On this page * [io.realm.exceptions](#io.realm.exceptions)\n* [Constructors](#constructors)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail) ## io.realm.exceptions [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [java.lang.Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) [java.lang.RuntimeException](https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) io.realm.exceptions.RealmException RealmException is for Realm specific exceptions. ## Constructors | Constructor and Description                                                                                                                                                                                                                                 |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [RealmException](#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) detailMessage)                                                                                           |\n| [RealmException](#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) detailMessage,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception) | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) : `getMessage` , `getLocalizedMessage` , `getCause` , `initCause` , `toString` , `printStackTrace` , `printStackTrace` , `printStackTrace` , `fillInStackTrace` , `getStackTrace` , `setStackTrace` , `addSuppressed` , `getSuppressed` ## Constructor Detail\n\n | public [RealmException](#std-label-io%5Frealm%5Fexceptions%5FRealmException-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) detailMessage,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ← [Exception DownloadingRealmInterruptedException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/DownloadingRealmInterruptedException/ \"Previous Section\")[Exception RealmFileException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/Type/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum RealmAny.Type On this page * [io.realm](#io.realm)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [BINARY](#binary)\n* [BOOLEAN](#boolean)\n* [DATE](#date)\n* [DECIMAL128](#decimal128)\n* [DOUBLE](#double)\n* [FLOAT](#float)\n* [INTEGER](#integer)\n* [NULL](#null)\n* [OBJECT](#object)\n* [OBJECT\\_ID](#object%5Fid)\n* [STRING](#string)\n* [UUID](#uuid)\n* [Method Detail](#method-detail)\n* [fromNativeValue](#fromnativevalue)\n* [getTypedClass](#gettypedclass)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.RealmAny.Type **Enclosing class:** [RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/#std-label-io%5Frealm%5FRealmAny) Enum describing all the types supported by RealmAny. ## Enum Constant Summary\n\n ## Method Summary | Modifier and Type                                                              | Method and Description                                                                                                                        |\n| ------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType)         | [fromNativeValue](#std-label-io%5Frealm%5FRealmAny%5FType%5FfromNativeValue) (**int** realmFieldType)                                         |\n| public [Class](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) | [getTypedClass](#std-label-io%5Frealm%5FRealmAny%5FType%5FgetTypedClass) ()                                                                   |\n| public static [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType)         | [valueOf](#std-label-io%5Frealm%5FRealmAny%5FType%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType)         | [values](#std-label-io%5Frealm%5FRealmAny%5FType%5Fvalues) ()                                                                                 | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `BINARY` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `BOOLEAN` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `DATE`\n\n ### `DECIMAL128` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `DOUBLE` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `FLOAT` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `INTEGER` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `NULL` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `OBJECT` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `OBJECT_ID` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `STRING` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ### `UUID` public static final [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) ## Method Detail ### fromNativeValue | public static [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) [fromNativeValue](#std-label-io%5Frealm%5FRealmAny%5FType%5FfromNativeValue) (**int** realmFieldType) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### getTypedClass | public [Class](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) [getTypedClass](#std-label-io%5Frealm%5FRealmAny%5FType%5FgetTypedClass) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------- | ### valueOf | public static [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) [valueOf](#std-label-io%5Frealm%5FRealmAny%5FType%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [RealmAny.Type](#std-label-io%5Frealm%5FRealmAny%5FType) [values](#std-label-io%5Frealm%5FRealmAny%5FType%5Fvalues) () |\n| ------------------------------------------------------------------------------------------------------------------------------------ | ← [Class RealmAny](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAny/ \"Previous Section\")[Class RealmAnyNativeFunctionsImpl](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmAnyNativeFunctionsImpl/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmMigrationNeededException/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Exception RealmMigrationNeededException On this page * [io.realm.exceptions](#io.realm.exceptions)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getPath](#getpath) ## io.realm.exceptions [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [java.lang.Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) [java.lang.RuntimeException](https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) io.realm.exceptions.RealmMigrationNeededException ## Constructors | Constructor and Description                                                                                                                                                                                                                                                                  |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [RealmMigrationNeededException](#std-label-io%5Frealm%5Fexceptions%5FRealmMigrationNeededException-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) canonicalRealmPath,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) detailMessage) | ## Method Summary | Modifier and Type                                                                | Method and Description                                                                                                                                            |\n| -------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) | [getPath](#std-label-io%5Frealm%5Fexceptions%5FRealmMigrationNeededException%5FgetPath) ()Returns the canonical path to the Realm file that needs to be migrated. | ## Inherited Methods\n\n ## Constructor Detail | public [RealmMigrationNeededException](#std-label-io%5Frealm%5Fexceptions%5FRealmMigrationNeededException-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) canonicalRealmPath,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) detailMessage) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ## Method Detail ### getPath | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getPath](#std-label-io%5Frealm%5Fexceptions%5FRealmMigrationNeededException%5FgetPath) ()                                                                                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the canonical path to the Realm file that needs to be migrated.This can be used for easy reference during a migration:**Returns**Canonical path to the Realm file.TipSee also: [File.getCanonicalPath()](https://docs.oracle.com/javase/7/docs/api/java/io/File/getCanonicalPath%28%29.html) | ← [Exception RealmFileException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/ \"Previous Section\")[Exception RealmPrimaryKeyConstraintException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmPrimaryKeyConstraintException/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmError/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Error RealmError On this page * [io.realm.exceptions](#io.realm.exceptions)\n* [Constructors](#constructors)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail) ## io.realm.exceptions [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [java.lang.Error](https://docs.oracle.com/javase/7/docs/api/java/lang/Error.html) io.realm.exceptions.RealmError RealmError is a Realm specific Error used when unrecoverable problems happen in the underlying storage engine. A RealmError should never be caught or ignored. By doing so, the Realm could possibly get corrupted. ## Constructors | Constructor and Description                                                                                                                               |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [RealmError](#std-label-io%5Frealm%5Fexceptions%5FRealmError-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) detailMessage) | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) : `getMessage` , `getLocalizedMessage` , `getCause` , `initCause` , `toString` , `printStackTrace` , `printStackTrace` , `printStackTrace` , `fillInStackTrace` , `getStackTrace` , `setStackTrace` , `addSuppressed` , `getSuppressed` ## Constructor Detail | public [RealmError](#std-label-io%5Frealm%5Fexceptions%5FRealmError-1) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) detailMessage) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Exception RealmPrimaryKeyConstraintException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmPrimaryKeyConstraintException/ \"Previous Section\")[io.realm.log](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Exception RealmFileException On this page * [io.realm.exceptions](#io.realm.exceptions)\n* [Constructors](#constructors)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [getKind](#getkind)\n* [toString](#tostring) ## io.realm.exceptions [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) [java.lang.Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) [java.lang.RuntimeException](https://docs.oracle.com/javase/7/docs/api/java/lang/RuntimeException.html) io.realm.exceptions.RealmFileException Class for reporting problems when accessing the Realm related files. ## Constructors\n\n ## Nested Class Summary | Modifier and Type   | Class and Description                                                                                                                                          |\n| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static final | [RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) | ## Method Summary | Modifier and Type                                                                                                                                                     | Method and Description                                                                                              |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |\n| public [RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) | [getKind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FgetKind) ()Gets the **kind** of this exception. |\n| public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html)                                                                                      | [toString](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FtoString) ()                                   | ## Inherited Methods\n\n ## Constructor Detail | public [RealmFileException](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException-1) (**byte** value,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | public [RealmFileException](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException-1) ([RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) kind,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | public [RealmFileException](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException-1) ([RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) kind,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) cause) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | public [RealmFileException](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException-1) ([RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) kind,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) cause) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ## Method Detail ### getKind | public [RealmFileException.Kind](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) [getKind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FgetKind) () |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the **kind** of this exception.**Returns**the **kind** of this exception.                                                                                                                                                                        | ### toString\n\n ← [Exception RealmException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmException/ \"Previous Section\")[Exception RealmMigrationNeededException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmMigrationNeededException/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/Kind/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Enum RealmFileException.Kind On this page * [io.realm.exceptions](#io.realm.exceptions)\n* [Enum Constant Summary](#enum-constant-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Enum Constant Detail](#enum-constant-detail)\n* [ACCESS\\_ERROR](#access%5Ferror)\n* [BAD\\_HISTORY](#bad%5Fhistory)\n* [EXISTS](#exists)\n* [FORMAT\\_UPGRADE\\_REQUIRED](#format%5Fupgrade%5Frequired)\n* [INCOMPATIBLE\\_LOCK\\_FILE](#incompatible%5Flock%5Ffile)\n* [INCOMPATIBLE\\_SYNC\\_FILE](#incompatible%5Fsync%5Ffile)\n* [NOT\\_FOUND](#not%5Ffound)\n* [PERMISSION\\_DENIED](#permission%5Fdenied)\n* [Method Detail](#method-detail)\n* [valueOf](#valueof)\n* [values](#values) ## io.realm.exceptions [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) io.realm.exceptions.RealmFileException.Kind **Enclosing class:** [RealmFileException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException-1) The specific kind of this [RealmFileException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/RealmFileException/#std-label-io%5Frealm%5Fexceptions%5FRealmFileException-1) . ## Enum Constant Summary\n\n ## Method Summary | Modifier and Type                                                                                       | Method and Description                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) | [valueOf](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| public static [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) | [values](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind%5Fvalues) ()                                                                                 | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class [java.lang.Enum](https://docs.oracle.com/javase/7/docs/api/java/lang/Enum.html) : `name` , `ordinal` , `toString` , `equals` , `hashCode` , `clone` , `compareTo` , `getDeclaringClass` , `valueOf` , `finalize` ## Enum Constant Detail ### `ACCESS_ERROR` public static final [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) Thrown for any I/O related exception scenarios when a Realm is opened. ### `BAD_HISTORY` public static final [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) Thrown if the history type of the on-disk Realm is unexpected or incompatible. ### `EXISTS` public static final [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) Thrown if the destination file exists but it is not supposed to. ### `FORMAT_UPGRADE_REQUIRED` public static final [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) Thrown if the file needs to be upgraded to a new format, but upgrades have been explicitly disabled. ### `INCOMPATIBLE_LOCK_FILE`\n\n Thrown if the database file is currently open in another process which cannot share with the current process due to an architecture mismatch. ### `INCOMPATIBLE_SYNC_FILE` public static final [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) Thrown if an attempt was made to open an Realm file created with Realm Object Server 1.\\*, which is not compatible with Realm Object Server 2.\\*. This exception should automatically be handled by Realm. ### `NOT_FOUND` public static final [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) Thrown if the relevant file cannot be found. ### `PERMISSION_DENIED` public static final [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) Thrown if the user does not have permission to open or create the specified file in the specified access mode when the Realm is opened. ## Method Detail ### valueOf | public static [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) [valueOf](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind%5FvalueOf) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) name) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### values | public static [RealmFileException.Kind](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind) [values](#std-label-io%5Frealm%5Fexceptions%5FRealmFileException%5FKind%5Fvalues) () |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [io.realm.exceptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/ \"Previous Section\")[Exception DownloadingRealmInterruptedException](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/DownloadingRealmInterruptedException/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class LogLevel On this page * [io.realm.log](#io.realm.log)\n* [Constructors](#constructors)\n* [Field Summary](#field-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [ALL](#all)\n* [DEBUG](#debug)\n* [ERROR](#error)\n* [FATAL](#fatal)\n* [INFO](#info)\n* [OFF](#off)\n* [TRACE](#trace)\n* [WARN](#warn)\n* [Constructor Detail](#constructor-detail) ## io.realm.log [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.log.LogLevel The Log levels defined and used by Realm when logging events in the API.Realm uses the log levels defined by Log4J: <https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/Level.html> ## Tip ### See also:  * [RealmLog.add(RealmLogger)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLog/#std-label-io%5Frealm%5Flog%5FRealmLog%5Fadd%5FRealmLogger%5F) ## Constructors | Constructor and Description                             |\n| ------------------------------------------------------- |\n| [LogLevel](#std-label-io%5Frealm%5Flog%5FLogLevel-1) () | ## Field Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `ALL` The ALL has the lowest possible rank and is intended to turn on all logging. ### `DEBUG` The DEBUG level designates fine-grained informational events that are mostly useful to debug an application. ### `ERROR` The ERROR level designates error events that might still allow the application to continue running. ### `FATAL` The FATAL level designates very severe error events that will presumably lead the application to abort. ### `INFO` The INFO level designates informational messages that highlight the progress of the application at coarse-grained level. ### `OFF` The OFF has the highest possible rank and is intended to turn off logging. ### `TRACE` The TRACE level designates finer-grained informational events than DEBUG. ### `WARN` The WARN level designates potentially harmful situations. ## Constructor Detail | public [LogLevel](#std-label-io%5Frealm%5Flog%5FLogLevel-1) () |\n| -------------------------------------------------------------- | ← [io.realm.log](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/ \"Previous Section\")[Class RealmLog](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLog/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLogger/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmLogger On this page * [io.realm.log](#io.realm.log)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [log](#log) ## io.realm.log Interface for custom loggers that can be registered at [RealmLog.add(RealmLogger)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLog/#std-label-io%5Frealm%5Flog%5FRealmLog%5Fadd%5FRealmLogger%5F) . The different log levels are described in [LogLevel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel-1) . ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                                                                                                                                                                               |\n| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [log](#std-label-io%5Frealm%5Flog%5FRealmLogger%5Flog) (**int** level,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) tag,[Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message)Handles a log event. | ## Method Detail ### log\n\n ← [Class RealmLog](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLog/ \"Previous Section\")[io.realm.mongodb](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoCollection/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class MongoCollection On this page * [io.realm.mongodb.mongo](#io.realm.mongodb.mongo)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Method Detail](#method-detail)\n* [aggregate](#aggregate)\n* [count](#count)\n* [deleteMany](#deletemany)\n* [deleteOne](#deleteone)\n* [find](#find)\n* [findOne](#findone)\n* [findOneAndDelete](#findoneanddelete)\n* [findOneAndReplace](#findoneandreplace)\n* [findOneAndUpdate](#findoneandupdate)\n* [getCodecRegistry](#getcodecregistry)\n* [getDocumentClass](#getdocumentclass)\n* [getName](#getname)\n* [getNamespace](#getnamespace)\n* [insertMany](#insertmany)\n* [insertOne](#insertone)\n* [updateMany](#updatemany)\n* [updateOne](#updateone)\n* [watch](#watch)\n* [watchAsync](#watchasync)\n* [watchWithFilter](#watchwithfilter)\n* [watchWithFilterAsync](#watchwithfilterasync)\n* [withCodecRegistry](#withcodecregistry)\n* [withDocumentClass](#withdocumentclass) ## io.realm.mongodb.mongo [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.mongodb.mongo.MongoCollection The MongoCollection interface provides read and write access to documents.Use [MongoDatabase.getCollection](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase%5FgetCollection) to get a collection instance. Before any access is possible, there must be an active, logged-in user. ## Tip ### See also:  * [MongoDatabase](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoDatabase) ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Method Detail ### aggregate | public [AggregateIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/AggregateIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FAggregateIterable-1) [aggregate](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Faggregate) <**ResultT** \\>([java.util.List<? extends Bson>](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) pipeline,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass)                                                                                                                                                                                                                                                                                     |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Aggregates documents according to the specified aggregation pipeline specifying an output class.All documents will be delivered in the form of an [AggregateIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/AggregateIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FAggregateIterable-1) from which individual elements can be extracted.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**pipeline \\- the aggregation pipelineresultClass \\- the class to decode each document into**Returns**an [AggregateIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/AggregateIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FAggregateIterable-1) from which the results can be extracted |\n\n ### count | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [count](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Fcount) (**Bson** filter,[CountOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/CountOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FCountOptions-1) options) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Counts the number of documents in the collection according to the given options.**Parameters**filter \\- the query filteroptions \\- the options describing the count**Returns**a task containing the number of documents in the collection                                                                                                                                                          | | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [count](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Fcount) (**Bson** filter) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Counts the number of documents in the collection according to the given options.**Parameters**filter \\- the query filter**Returns**a task containing the number of documents in the collection                                     | | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [count](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Fcount) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Counts the number of documents in the collection.**Returns**a task containing the number of documents in the collection                                                                                             | ### deleteMany\n\n ### deleteOne | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [deleteOne](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FdeleteOne) (**Bson** filter)                                          |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes at most one document from the collection that matches the given filter. If no documents match, the collection is not modified.**Parameters**filter \\- the query filter to apply the the delete operation**Returns**a task containing the result of the remove one operation | ### find\n\n | public [FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) [find](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Ffind) <**ResultT** \\>(**Bson** filter,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass)                                                                                                                                                                                                              |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds all documents in the collection that match the given filter specifying an output class.All documents will be delivered in the form of a [FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) from which individual elements can be extracted.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**filter \\- the query filterresultClass \\- the class to decode each document into**Returns**an iterable containing the result of the find operation |\n\n | public [FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) [find](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Ffind) (**Bson** filter)                                                                                                                                                                             |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds all documents in the collection that match the given filter.All documents will be delivered in the form of a [FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) from which individual elements can be extracted.**Parameters**filter \\- the query filter**Returns**an iterable containing the result of the find operation |\n\n | public [FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) [find](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Ffind) <**ResultT** \\>([java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass)                                                                                                                                                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds all documents in the collection specifying an output class.All documents will be delivered in the form of a [FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) from which individual elements can be extracted.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**resultClass \\- the class to decode each document into**Returns**an iterable containing the result of the find operation |\n\n | public [FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) [find](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Ffind) ()                                                                                                                        |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds all documents in the collection.All documents will be delivered in the form of a [FindIterable](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/iterable/FindIterable/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Fiterable%5FFindIterable-1) from which individual elements can be extracted.**Returns**an iterable containing the result of the find operation | ### findOne | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOne](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOne) <**ResultT** \\>(**Bson** filter,[FindOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions-1) options,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**filter \\- the query filteroptions \\- a [FindOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOptions-1) structresultClass \\- the class to decode each document into**Returns**a task containing the result of the find one operation                                                                          |\n\n | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOne](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOne) <**ResultT** \\>(**Bson** filter,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Finds a document in the collection.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**filter \\- the query filterresultClass \\- the class to decode each document into**Returns**a task containing the result of the find one operation                                                                                     | | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOne](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOne) (**Bson** filter) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection.**Parameters**filter \\- the query filter**Returns**a task containing the result of the find one operation                                                                                           | | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOne](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOne) <**ResultT** \\>([java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection.**Type Parameters**ResultT \\- the target document type**Parameters**resultClass \\- the class to decode each document into**Returns**a task containing the result of the find one operation                                                                                                                |\n\n ### findOneAndDelete | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndDelete](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndDelete) <**ResultT** \\>(**Bson** filter,[FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) options,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection and delete it.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**filter \\- the query filteroptions \\- a [FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) structresultClass \\- the class to decode each document into**Returns**a task containing the resulting document                                                                                            | | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndDelete](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndDelete) (**Bson** filter,[FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) options) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection and delete it.**Parameters**filter \\- the query filteroptions \\- a [FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) struct**Returns**a task containing the resulting document                                                                                                  |\n\n | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndDelete](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndDelete) (**Bson** filter) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection and delete it.**Parameters**filter \\- the query filter**Returns**a task containing the resulting document                                                                                                             | ### findOneAndReplace | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndReplace](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndReplace) <**ResultT** \\>(**Bson** filter,**Bson** replacement,[FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) options,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Finds a document in the collection and replaces it with the given document.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**filter \\- the query filterreplacement \\- the document to replace the matched document withoptions \\- a [FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) structresultClass \\- the class to decode each document into**Returns**a task containing the resulting document                         |\n\n | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndReplace](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndReplace) <**ResultT** \\>(**Bson** filter,**Bson** replacement,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection and replaces it with the given document.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**filter \\- the query filterreplacement \\- the document to replace the matched document withresultClass \\- the class to decode each document into**Returns**a task containing the resulting document                                    | | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndReplace](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndReplace) (**Bson** filter,**Bson** replacement) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection and replaces it with the given document.**Parameters**filter \\- the query filterreplacement \\- the document to replace the matched document with**Returns**a task containing the resulting document                                          | ### findOneAndUpdate | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndUpdate](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndUpdate) <**ResultT** \\>(**Bson** filter,**Bson** update,[FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) options,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection and performs the given update.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**filter \\- the query filterupdate \\- the update documentoptions \\- a [FindOneAndModifyOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/FindOneAndModifyOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FFindOneAndModifyOptions-1) structresultClass \\- the class to decode each document into**Returns**a task containing the resulting document                                                               |\n\n | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndUpdate](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndUpdate) <**ResultT** \\>(**Bson** filter,**Bson** update,[java.lang.Class<ResultT>](https://docs.oracle.com/javase/7/docs/api/java/lang/Class.html) resultClass) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Finds a document in the collection and performs the given update.**Type Parameters**ResultT \\- the target document type of the iterable.**Parameters**filter \\- the query filterupdate \\- the update documentresultClass \\- the class to decode each document into**Returns**a task containing the resulting document                                                                          | | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [findOneAndUpdate](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FfindOneAndUpdate) (**Bson** filter,**Bson** update) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Finds a document in the collection and performs the given update.**Parameters**filter \\- the query filterupdate \\- the update document**Returns**a task containing the resulting document                                                                                | ### getCodecRegistry | public **CodecRegistry** [getCodecRegistry](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FgetCodecRegistry) () |\n| ---------------------------------------------------------------------------------------------------------------------------- |\n| Gets the codec registry for the MongoCollection.**Returns**the **CodecRegistry** for this collection                         | ### getDocumentClass\n\n ### getName | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [getName](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FgetName) () |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Gets the name of this collection**Returns**the name                                                                                                                | ### getNamespace | public [MongoNamespace](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoNamespace/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoNamespace-1) [getNamespace](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FgetNamespace) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Gets the namespace of this collection, i.e. the database and collection names together.**Returns**the namespace                                                                                                                                | ### insertMany | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [insertMany](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FinsertMany) ([java.util.List<? extends DocumentT>](https://docs.oracle.com/javase/7/docs/api/java/util/List.html) documents) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Inserts one or more documents.**Parameters**documents \\- the documents to insert**Returns**a task containing the result of the insert many operation                                                                                                                                                                                        | ### insertOne\n\n ### updateMany | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [updateMany](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FupdateMany) (**Bson** filter,**Bson** update,[UpdateOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/UpdateOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions-1) updateOptions) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Update all documents in the collection according to the specified arguments.**Parameters**filter \\- a document describing the query filter, which may not be null.update \\- a document describing the update, which may not be null. The update to apply must include only update operators.updateOptions \\- the options to apply to the update operation**Returns**a task containing the result of the update many operation         | | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [updateMany](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FupdateMany) (**Bson** filter,**Bson** update)                                                                                                     |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Update all documents in the collection according to the specified arguments.**Parameters**filter \\- a document describing the query filter, which may not be null.update \\- a document describing the update, which may not be null. The update to apply must include only update operators.**Returns**a task containing the result of the update many operation | ### updateOne | public [RealmResultTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmResultTask/#std-label-io%5Frealm%5Fmongodb%5FRealmResultTask) [updateOne](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FupdateOne) (**Bson** filter,**Bson** update,[UpdateOptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/options/UpdateOptions/#std-label-io%5Frealm%5Fmongodb%5Fmongo%5Foptions%5FUpdateOptions-1) updateOptions) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Update a single document in the collection according to the specified arguments.**Parameters**filter \\- a document describing the query filter, which may not be null.update \\- a document describing the update, which may not be null. The update to apply must include only update operators.updateOptions \\- the options to apply to the update operation**Returns**a task containing the result of the update one operation    |\n\n ### watch | public [RealmEventStreamTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamTask/#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamTask) [watch](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Fwatch) (**ObjectId\\[\\]** ids)                                                                                      |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Watches specified IDs in a collection. This convenience overload supports the use case of non-**BsonValue** instances of **ObjectId** by wrapping them in **BsonObjectId** instances for the user.**Parameters**ids \\- unique object identifiers of the IDs to watch.**Returns**a task that provides access to the stream of change events. | | public [RealmEventStreamTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamTask/#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamTask) [watch](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Fwatch) (**BsonValue\\[\\]** ids) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Watches specified IDs in a collection.**Parameters**ids \\- the ids to watch.**Returns**a task that provides access to the stream of change events.                                                                                                      | | public [RealmEventStreamTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamTask/#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamTask) [watch](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5Fwatch) ()                        |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Watches a collection. The resulting stream will be notified of all events on this collection that the active user is authorized to see based on the configured MongoDB Realm rules.**Returns**a task that provides access to the stream of change events. | ### watchAsync\n\n | public [RealmEventStreamAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamAsyncTask/#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamAsyncTask) [watchAsync](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FwatchAsync) (**BsonValue\\[\\]** ids) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Watches specified IDs in a collection asynchronously.**Parameters**ids \\- the ids to watch.**Returns**a task that provides access to the stream of change events.                                                                                                                | | public [RealmEventStreamAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamAsyncTask/#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamAsyncTask) [watchAsync](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FwatchAsync) ()              |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Watches a collection asynchronously. The resulting stream will be notified of all events on this collection that the active user is authorized to see based on the configured MongoDB Realm rules.**Returns**a task that provides access to the stream of change events. | ### watchWithFilter\n\n | public [RealmEventStreamTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamTask/#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamTask) [watchWithFilter](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FwatchWithFilter) (**Document** matchFilter)                                                                                                                                                                                                                                                                                                                                                                                                  |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Watches a collection. The provided document will be used as a match expression filter on the change events coming from the stream. This convenience overload supports the use of non-**BsonDocument** instances for the user.See [how to define a match filter](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) .Defining the match expression to filter ChangeEvents is similar to [how to define the match expression for triggers](https://docs.mongodb.com/realm/triggers/database-triggers/)**Parameters**matchFilter \\- the $match filter to apply to incoming change events**Returns**a task that provides access to the stream of change events. | ### watchWithFilterAsync\n\n | public [RealmEventStreamAsyncTask](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/RealmEventStreamAsyncTask/#std-label-io%5Frealm%5Fmongodb%5FRealmEventStreamAsyncTask) [watchWithFilterAsync](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FwatchWithFilterAsync) (**Document** matchFilter)                                                                                                                                                                                                                                                                                                                                                                                        |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Watches a collection asynchronously. The provided document will be used as a match expression filter on the change events coming from the stream. This convenience overload supports the use of non-**BsonDocument** instances for the user.See [how to define a match filter](https://docs.mongodb.com/manual/reference/operator/aggregation/match/) .Defining the match expression to filter ChangeEvents is similar to [how to define the match expression for triggers](https://docs.mongodb.com/realm/triggers/database-triggers/)**Parameters**matchFilter \\- the $match filter to apply to incoming change events**Returns**a task that provides access to the stream of change events. | ### withCodecRegistry | public [MongoCollection](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection) [withCodecRegistry](#std-label-io%5Frealm%5Fmongodb%5Fmongo%5FMongoCollection%5FwithCodecRegistry) (**CodecRegistry** codecRegistry)       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a new MongoCollection instance with a different codec registry.**Parameters**codecRegistry \\- the new **CodecRegistry** for the collection.**Returns**a new MongoCollection instance with the different codec registry | ### withDocumentClass\n\n ← [Class MongoClient](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoClient/ \"Previous Section\")[Class MongoDatabase](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/mongo/MongoDatabase/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/gradle/RealmPluginExtension/PropertyChangedListener/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmPluginExtension.PropertyChangedListener On this page * [io.realm.gradle](#io.realm.gradle)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onChange](#onchange) ## io.realm.gradle **Enclosing class:** [RealmPluginExtension](https://mongodb.com/docs/realm/sdk/java/api/io/realm/gradle/RealmPluginExtension/#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension-1) ## Method Summary | Modifier and Type | Method and Description                                                                                               |\n| ----------------- | -------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onChange](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FPropertyChangedListener%5FonChange) (**T** value) | ## Method Detail ### onChange | public **void** [onChange](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FPropertyChangedListener%5FonChange) (**T** value) |\n| ------------------------------------------------------------------------------------------------------------------------------------ | [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/gradle/RealmPluginExtension/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmPluginExtension On this page * [io.realm.gradle](#io.realm.gradle)\n* [Constructors](#constructors)\n* [Nested Class Summary](#nested-class-summary)\n* [Field Summary](#field-summary)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Field Detail](#field-detail)\n* [KEY\\_KOTLIN\\_EXTENSIONS\\_ENABLED](#key%5Fkotlin%5Fextensions%5Fenabled)\n* [KEY\\_SYNC\\_ENABLED](#key%5Fsync%5Fenabled)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [addPropertyListener](#addpropertylistener)\n* [isKotlinExtensionsEnabled](#iskotlinextensionsenabled)\n* [isSyncEnabled](#issyncenabled)\n* [setKotlinExtensionsEnabled](#setkotlinextensionsenabled)\n* [setSyncEnabled](#setsyncenabled) ## io.realm.gradle [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.gradle.RealmPluginExtension ## Constructors | Constructor and Description                                                        |\n| ---------------------------------------------------------------------------------- |\n| [RealmPluginExtension](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension-1) () | ## Nested Class Summary | Modifier and Type       | Class and Description                                                                                                                                                                                                 |\n| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static interface | [RealmPluginExtension.PropertyChangedListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/gradle/RealmPluginExtension/PropertyChangedListener/#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FPropertyChangedListener) | ## Field Summary\n\n ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Field Detail ### `KEY_KOTLIN_EXTENSIONS_ENABLED` ### `KEY_SYNC_ENABLED` ## Constructor Detail | public [RealmPluginExtension](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension-1) () |\n| ----------------------------------------------------------------------------------------- | ## Method Detail ### addPropertyListener | public **void** [addPropertyListener](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FaddPropertyListener) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) property,[io.realm.gradle.RealmPluginExtension.PropertyChangedListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/gradle/RealmPluginExtension/PropertyChangedListener/#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FPropertyChangedListener) listener) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ### isKotlinExtensionsEnabled | public **boolean** [isKotlinExtensionsEnabled](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FisKotlinExtensionsEnabled) () |\n| ------------------------------------------------------------------------------------------------------------------------------------ | ### isSyncEnabled | public **boolean** [isSyncEnabled](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FisSyncEnabled) () |\n| ------------------------------------------------------------------------------------------------------------ | ### setKotlinExtensionsEnabled | public **void** [setKotlinExtensionsEnabled](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FsetKotlinExtensionsEnabled) (**boolean** kotlinExtensionsEnabled) |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### setSyncEnabled | public **void** [setSyncEnabled](#std-label-io%5Frealm%5Fgradle%5FRealmPluginExtension%5FsetSyncEnabled) (**boolean** syncEnabled) |\n| ---------------------------------------------------------------------------------------------------------------------------------- | [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/transformer/Utils/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class Utils On this page * [io.realm.transformer](#io.realm.transformer)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [base64Encode](#base64encode)\n* [hexStringify](#hexstringify)\n* [isSyncEnabled](#issyncenabled)\n* [sha256Hash](#sha256hash) ## io.realm.transformer [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.transformer.Utils ## Constructors | Constructor and Description                               |\n| --------------------------------------------------------- |\n| [Utils](#std-label-io%5Frealm%5Ftransformer%5FUtils-1) () | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [Utils](#std-label-io%5Frealm%5Ftransformer%5FUtils-1) () |\n| ---------------------------------------------------------------- | ## Method Detail ### base64Encode | public static [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [base64Encode](#std-label-io%5Frealm%5Ftransformer%5FUtils%5Fbase64Encode) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) data) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Encode the given string with Base64**Parameters**data \\- the string to encode**Returns**the encoded string**Throws**[UnsupportedEncodingException](https://docs.oracle.com/javase/7/docs/api/java/io/UnsupportedEncodingException.html) \\-          | ### hexStringify | public static [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [hexStringify](#std-label-io%5Frealm%5Ftransformer%5FUtils%5FhexStringify) (**byte\\[\\]** data) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Convert a byte array to its hex-string**Parameters**data \\- the byte array to convert**Returns**the hex-string of the byte array                                                       | ### isSyncEnabled | public static **boolean** [isSyncEnabled](#std-label-io%5Frealm%5Ftransformer%5FUtils%5FisSyncEnabled) (**Project** project) |\n| ---------------------------------------------------------------------------------------------------------------------------- | ### sha256Hash | public static **byte** [sha256Hash](#std-label-io%5Frealm%5Ftransformer%5FUtils%5Fsha256Hash) (**byte\\[\\]** data)                                                                                                                                          |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Compute the SHA-256 hash of the given byte array**Parameters**data \\- the byte array to hash**Returns**the hashed byte array**Throws**[NoSuchAlgorithmException](https://docs.oracle.com/javase/7/docs/api/java/security/NoSuchAlgorithmException.html) \\- | [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface DynamicRealm.Transaction On this page * [io.realm](#io.realm)\n* [Nested Class Summary](#nested-class-summary)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [execute](#execute) ## io.realm **Enclosing class:** [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) Encapsulates a Realm transaction.Using this class will automatically handle **io.realm.DynamicRealm.beginTransaction()** and **io.realm.DynamicRealm.commitTransaction()** If any exception is thrown during the transaction **io.realm.DynamicRealm.cancelTransaction()** will be called instead of **io.realm.DynamicRealm.commitTransaction()**. ## Nested Class Summary | Modifier and Type       | Class and Description                                                                                                                                                     |\n| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public static           | [DynamicRealm.Transaction.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/Callback/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FCallback-1)  |\n| public static interface | [DynamicRealm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnSuccess/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnSuccess) |\n| public static interface | [DynamicRealm.Transaction.OnError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnError/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnError)       | ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                              |\n| ----------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [execute](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5Fexecute) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm) | ## Method Detail ### execute\n\n ← [Class DynamicRealm.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Callback/ \"Previous Section\")[Class DynamicRealm.Transaction.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/Callback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Callback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class DynamicRealm.Callback On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [onError](#onerror)\n* [onSuccess](#onsuccess) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) **io.realm.BaseRealm.InstanceCallback** io.realm.DynamicRealm.Callback **Enclosing class:** [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) ## Constructors | Constructor and Description                                      |\n| ---------------------------------------------------------------- |\n| [Callback](#std-label-io%5Frealm%5FDynamicRealm%5FCallback-1) () | ## Method Summary | Modifier and Type        | Method and Description                                                                                                                                                                                                                          |\n| ------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**          | [onError](#std-label-io%5Frealm%5FDynamicRealm%5FCallback%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) exception)Deliver an error happens when creating the Realm instance to the caller thread. |\n| public abstract **void** | [onSuccess](#std-label-io%5Frealm%5FDynamicRealm%5FCallback%5FonSuccess) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm)                                                            | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize`\n* Methods inherited from class **io.realm.BaseRealm.InstanceCallback**: `onSuccess` , `onError` ## Constructor Detail | public [Callback](#std-label-io%5Frealm%5FDynamicRealm%5FCallback-1) () |\n| ----------------------------------------------------------------------- | ## Method Detail ### onError\n\n ### onSuccess | public abstract **void** [onSuccess](#std-label-io%5Frealm%5FDynamicRealm%5FCallback%5FonSuccess) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**onSuccess in class **InstanceCallback**                                                                                                                                                          | ← [Class DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/ \"Previous Section\")[Interface DynamicRealm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/RealmFlowFactory/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmFlowFactory On this page * [io.realm.coroutines](#io.realm.coroutines)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [changesetFrom](#changesetfrom)\n* [from](#from) ## io.realm.coroutines [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.coroutines.RealmFlowFactory **Implemented interfaces:** * [io.realm.coroutines.FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory) Factory class used to create coroutine Flow\\*\\*s. This class is used by default unless overridden in [io.realm.RealmConfiguration.Builder.flowFactory(FlowFactory)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmConfiguration/Builder/#std-label-io%5Frealm%5FRealmConfiguration%5FBuilder%5FflowFactory%5FFlowFactory%5F) . ## Constructors | Constructor and Description                                                                                                                                                                                    |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [RealmFlowFactory](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory-1) ([Boolean](https://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html) returnFrozenObjects)Constructor for the Flow factory. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [RealmFlowFactory](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory-1) ([Boolean](https://docs.oracle.com/javase/7/docs/api/java/lang/Boolean.html) returnFrozenObjects) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Constructor for the Flow factory.**Parameters**returnFrozenObjects \\- whether the emissions should return frozen objects or not.                                                     | ## Method Detail ### changesetFrom | public **<any>** [changesetFrom](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5FchangesetFrom) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm,[DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) dynamicRealmObject)                                                                                                                                                                                                                                                                                                                     |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) . It should emit the initial object when subscribed to and on each subsequent update of the object it should emit the object plus the [io.realm.ObjectChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ObjectChangeSet/#std-label-io%5Frealm%5FObjectChangeSet) that describes the update.Changeset observables do not support backpressure as a changeset depends on the state of the previous changeset. Handling backpressure should therefore be left to the user.**Returns** **Flow** that emits all updates to the DynamicRealmObject. |\n\n | public **<any>** [changesetFrom](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5FchangesetFrom) <**T** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm,[io.realm.RealmList<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) list)                                                                                                                                                                                                                                                                                                               |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) . It should emit the initial list when subscribed to and on each subsequent update of the list it should emit the list plus the [io.realm.rx.CollectionChange](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/CollectionChange/#std-label-io%5Frealm%5Frx%5FCollectionChange-1) that describes the update.Changeset observables do not support backpressure as a changeset depends on the state of the previous changeset. Handling backpressure should therefore be left to the user.**Returns** **Flow** that emits all updates to the RealmList. |\n\n | public **<any>** [changesetFrom](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5FchangesetFrom) <**T** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm,[io.realm.RealmResults<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) results)                                                                                                                                                                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a **Flow** for a [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) instance. It should emit the initial results when subscribed to and on each subsequent update of the results it should emit the results plus the [io.realm.rx.CollectionChange](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/CollectionChange/#std-label-io%5Frealm%5Frx%5FCollectionChange-1) that describes the update.Changeset observables do not support backpressure as a changeset depends on the state of the previous changeset. Handling backpressure should therefore be left to the user.**Returns** **Flow** that emits all updates to the RealmResults. |\n\n ### from | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5Ffrom) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm,[DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) dynamicRealmObject) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) . It should emit the initial object when subscribed to and on each subsequent update of the object.**Returns** **Flow** that emits all updates to the DynamicRealmObject.                          | | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5Ffrom) <**T** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,**T** realmObject)                                                                                               |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . It should emit the initial object when subscribed to and on each subsequent update of the object.**Returns** **Flow** that emits all updates to the DynamicRealmObject. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5Ffrom) <**T** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,[io.realm.RealmList<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) realmList)                                                                                                                                                                       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a **Flow** for a [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) . It should emit the initial RealmResult when subscribed to and on each subsequent update of the RealmList.Note: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) is currently not supported on RealmLists.**Returns** **Flow** that emit all updates to the RealmList. | | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5Ffrom) <**T** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm,[io.realm.RealmResults<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) results) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) . It should emit the initial RealmResult when subscribed to and on each subsequent update of the RealmResults.**Returns** **Flow** that emits all updates to the RealmObject.                                |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5Ffrom) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm)                                                                                        |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) . It should emit the initial state of the Realm when subscribed to and on each subsequent update of the Realm.**Returns**Flow that emits all updates to the Realm. | | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FRealmFlowFactory%5Ffrom) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm)                                                                                               |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) . It should emit the initial state of the Realm when subscribed to and on each subsequent update of the Realm.**Returns**Flow that emits all updates to the Realm. | ← [Interface FlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/ \"Previous Section\")[io.realm.exceptions](https://mongodb.com/docs/realm/sdk/java/api/io/realm/exceptions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnError/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface DynamicRealm.Transaction.OnError On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onError](#onerror) ## io.realm **Enclosing class:** [Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction) Callback invoked to notify the caller thread about error during the transaction. The transaction will be rolled back and the background Realm will be closed before invoking [onError(Throwable)](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnError%5FonError%5FThrowable%5F) . ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                    |\n| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onError](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnError%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) error) | ## Method Detail ### onError | public **void** [onError](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnError%5FonError) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) error) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class DynamicRealm.Transaction.Callback](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/Callback/ \"Previous Section\")[Interface DynamicRealm.Transaction.OnSuccess](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnSuccess/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/FlowFactory/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface FlowFactory On this page * [io.realm.coroutines](#io.realm.coroutines)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [changesetFrom](#changesetfrom)\n* [from](#from) ## io.realm.coroutines Factory interface for creating Kotlin Flow\\*\\*s for Realm classes. ## Method Summary\n\n ## Method Detail ### changesetFrom\n\n\n\n\n\n\n\n\n\n\n\n ### from | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory%5Ffrom) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm,[DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) dynamicRealmObject)                                                                                                                                                                                                                                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) . It should emit the initial object when subscribed to and on each subsequent update of the object.**Parameters**dynamicRealm \\- [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) instance from where the object is coming.dynamicRealmObject \\- [DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) instance being observed for changes to be emitted by the flow.**Returns** **Flow** that emits all updates to the DynamicRealmObject. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory%5Ffrom) <**T** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm,[io.realm.RealmList<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) realmList)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a **Flow** for a [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) . It should emit the initial RealmResult when subscribed to and on each subsequent update of the RealmList.Note: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) is currently not supported on RealmLists.**Type Parameters**T \\- type of RealmObject**Parameters**realmList \\- [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) instance being observed for changes to be emitted by the flow.dynamicRealm \\- [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) instance from where the results are coming.**Returns** **Flow** that emit all updates to the RealmList. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory%5Ffrom) <**T** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm,[io.realm.RealmResults<T>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) results)                                                                                                                                                                                                                                                                                                                                                                             |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) . It should emit the initial RealmResult when subscribed to and on each subsequent update of the RealmResults.**Type Parameters**T \\- type of RealmObject.**Parameters**results \\- [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) instance being observed for changes to be emitted by the flow.dynamicRealm \\- [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) instance from where the results are coming.**Returns** **Flow** that emits all updates to the RealmObject. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Fcoroutines%5FFlowFactory%5Ffrom) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) dynamicRealm)                                                                                                                                                                                                                                                                                             |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a **Flow** for a [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) . It should emit the initial state of the Realm when subscribed to and on each subsequent update of the Realm.**Parameters**dynamicRealm \\- [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) instance being observed for changes to be emitted by the flow.**Returns**Flow that emits all updates to the Realm. |\n\n ← [io.realm.coroutines](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/ \"Previous Section\")[Class RealmFlowFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/coroutines/RealmFlowFactory/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnSuccess/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface DynamicRealm.Transaction.OnSuccess On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [onSuccess](#onsuccess) ## io.realm **Enclosing class:** [Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction) Callback invoked to notify the caller thread about the success of the transaction. ## Method Summary | Modifier and Type | Method and Description                                                                     |\n| ----------------- | ------------------------------------------------------------------------------------------ |\n| public **void**   | [onSuccess](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnSuccess%5FonSuccess) () | ## Method Detail ### onSuccess | public **void** [onSuccess](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FOnSuccess%5FonSuccess) () |\n| ---------------------------------------------------------------------------------------------------------- | ← [Interface DynamicRealm.Transaction.OnError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnError/ \"Previous Section\")[Class DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/Function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RealmObjectSchema.Function On this page * [io.realm](#io.realm)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [apply](#apply) ## io.realm **Enclosing class:** [RealmObjectSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/#std-label-io%5Frealm%5FRealmObjectSchema) Function interface, used when traversing all objects of the current class and apply a function on each. ## Tip ### See also:  * **transform(Function)** ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                                              |\n| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [apply](#std-label-io%5Frealm%5FRealmObjectSchema%5FFunction%5Fapply) ([DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) obj) | ## Method Detail ### apply | public **void** [apply](#std-label-io%5Frealm%5FRealmObjectSchema%5FFunction%5Fapply) ([DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) obj) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Class RealmObjectSchema](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectSchema/ \"Previous Section\")[Class RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/Callback/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class DynamicRealm.Transaction.Callback On this page * [io.realm](#io.realm)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [onError](#onerror)\n* [onSuccess](#onsuccess) ## io.realm [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.DynamicRealm.Transaction.Callback **Enclosing class:** [Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/#std-label-io%5Frealm%5FDynamicRealm%5FTransaction) Callback invoked to notify the caller thread. ## Constructors | Constructor and Description                                                    |\n| ------------------------------------------------------------------------------ |\n| [Callback](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FCallback-1) () | ## Method Summary | Modifier and Type | Method and Description                                                                                                                                                      |\n| ----------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| public **void**   | [onError](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FCallback%5FonError) ([Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) ignore) |\n| public **void**   | [onSuccess](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FCallback%5FonSuccess) ()                                                                                   | ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [Callback](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FCallback-1) () |\n| ------------------------------------------------------------------------------------- | ## Method Detail ### onError | public **void** [onError](#std-label-io%5Frealm%5FDynamicRealm%5FTransaction%5FCallback%5FonError) ([Exception](https://docs.oracle.com/javase/7/docs/api/java/lang/Exception.html) ignore) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ### onSuccess\n\n ← [Interface DynamicRealm.Transaction](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/ \"Previous Section\")[Interface DynamicRealm.Transaction.OnError](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/Transaction/OnError/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/rx/CollectionChange/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class CollectionChange On this page * [io.realm.rx](#io.realm.rx)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [getChangeset](#getchangeset)\n* [getCollection](#getcollection)\n* [hashCode](#hashcode) ## io.realm.rx [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.rx.CollectionChange Container wrapping the result of a [io.realm.OrderedRealmCollectionChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedRealmCollectionChangeListener/#std-label-io%5Frealm%5FOrderedRealmCollectionChangeListener) being triggered. This is used by [RealmResults.asChangesetObservable()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults%5FasChangesetObservable%5F%5F) } and [RealmList.asChangesetObservable()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList%5FasChangesetObservable%5F%5F) as RxJava is only capable of emitting one item, not multiple. ## Constructors | Constructor and Description                                                                                                                                                                                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [CollectionChange](#std-label-io%5Frealm%5Frx%5FCollectionChange-1) (**E** collection,[OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/#std-label-io%5Frealm%5FOrderedCollectionChangeSet) changeset)Constructor for a CollectionChange. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [CollectionChange](#std-label-io%5Frealm%5Frx%5FCollectionChange-1) (**E** collection,[OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/#std-label-io%5Frealm%5FOrderedCollectionChangeSet) changeset) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Constructor for a CollectionChange.**Parameters**collection \\- the collection that changed.changeset \\- the changeset describing the change.                                                                                                          | ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Frx%5FCollectionChange%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                            | ### getChangeset\n\n ### getCollection | public **E** [getCollection](#std-label-io%5Frealm%5Frx%5FCollectionChange%5FgetCollection) () |\n| ---------------------------------------------------------------------------------------------- |\n| Returns the collection that was updated.**Returns**collection that was updated.                | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Frx%5FCollectionChange%5FhashCode) ()                   |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ← [io.realm.rx](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/ \"Previous Section\")[Class ObjectChange](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/ObjectChange/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLog/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmLog On this page * [io.realm.log](#io.realm.log)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [add](#add)\n* [clear](#clear)\n* [debug](#debug)\n* [error](#error)\n* [fatal](#fatal)\n* [getLevel](#getlevel)\n* [info](#info)\n* [registerDefaultLogger](#registerdefaultlogger)\n* [remove](#remove)\n* [setLevel](#setlevel)\n* [trace](#trace)\n* [warn](#warn) ## io.realm.log [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.log.RealmLog Global logger used by all Realm components. Custom loggers can be added by registering classes implementing [RealmLogger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLogger/#std-label-io%5Frealm%5Flog%5FRealmLogger) . ## Constructors | Constructor and Description                             |\n| ------------------------------------------------------- |\n| [RealmLog](#std-label-io%5Frealm%5Flog%5FRealmLog-1) () | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [RealmLog](#std-label-io%5Frealm%5Flog%5FRealmLog-1) () |\n| -------------------------------------------------------------- | ## Method Detail ### add | public static **void** [add](#std-label-io%5Frealm%5Flog%5FRealmLog%5Fadd) ([RealmLogger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLogger/#std-label-io%5Frealm%5Flog%5FRealmLogger) logger)                                         |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds a logger implementation that will be notified on log events.**Parameters**logger \\- the reference to a [RealmLogger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLogger/#std-label-io%5Frealm%5Flog%5FRealmLogger) implementation. | ### clear | public static **void** [clear](#std-label-io%5Frealm%5Flog%5FRealmLog%5Fclear) ()                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes all loggers. The default native logger will be removed as well. Use [registerDefaultLogger()](#std-label-io%5Frealm%5Flog%5FRealmLog%5FregisterDefaultLogger%5F%5F) to add it back. | ### debug | public static **void** [debug](#std-label-io%5Frealm%5Flog%5FRealmLog%5Fdebug) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs a [LogLevel.DEBUG](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FDEBUG) event.**Parameters**throwable \\- optional exception to log.message \\- optional message.args \\- optional args used to format the message using [String.format(String, Object...)](https://docs.oracle.com/javase/7/docs/api/java/lang/String/format%28String,Object///%29.html) . |\n\n | public static **void** [debug](#std-label-io%5Frealm%5Flog%5FRealmLog%5Fdebug) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable)    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs a [LogLevel.DEBUG](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FDEBUG) exception.**Parameters**throwable \\- exception to log. | ### error | public static **void** [error](#std-label-io%5Frealm%5Flog%5FRealmLog%5Ferror) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs an [LogLevel.ERROR](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FERROR) event.**Parameters**throwable \\- optional exception to log.message \\- optional message.args \\- optional args used to format the message using [String.format(String, Object...)](https://docs.oracle.com/javase/7/docs/api/java/lang/String/format%28String,Object///%29.html) . | | public static **void** [error](#std-label-io%5Frealm%5Flog%5FRealmLog%5Ferror) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs an [LogLevel.ERROR](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FERROR) event.**Parameters**message \\- message to log.args \\- optional args used to format the message using [String.format(String, Object...)](https://docs.oracle.com/javase/7/docs/api/java/lang/String/format%28String,Object///%29.html) . | | public static **void** [error](#std-label-io%5Frealm%5Flog%5FRealmLog%5Ferror) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable)     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Logs an [LogLevel.ERROR](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FERROR) exception.**Parameters**throwable \\- exception to log. | ### fatal\n\n | public static **void** [fatal](#std-label-io%5Frealm%5Flog%5FRealmLog%5Ffatal) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs an [LogLevel.FATAL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FFATAL) event.**Parameters**message \\- message to log.args \\- optional args used to format the message using [String.format(String, Object...)](https://docs.oracle.com/javase/7/docs/api/java/lang/String/format%28String,Object///%29.html) . | | public static **void** [fatal](#std-label-io%5Frealm%5Flog%5FRealmLog%5Ffatal) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable)    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs a [LogLevel.FATAL](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FFATAL) exception.**Parameters**throwable \\- exception to log. | ### getLevel | public static **int** [getLevel](#std-label-io%5Frealm%5Flog%5FRealmLog%5FgetLevel) ()                                                                                                                                                            |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Get the current [LogLevel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel-1) .**Returns**the current [LogLevel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel-1) . | ### info\n\n | public static **void** [info](#std-label-io%5Frealm%5Flog%5FRealmLog%5Finfo) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs an [LogLevel.INFO](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FINFO) event.**Parameters**message \\- message to log.args \\- optional args used to format the message using [String.format(String, Object...)](https://docs.oracle.com/javase/7/docs/api/java/lang/String/format%28String,Object///%29.html) . | | public static **void** [info](#std-label-io%5Frealm%5Flog%5FRealmLog%5Finfo) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable)     |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs an [LogLevel.INFO](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FINFO) exception.**Parameters**throwable \\- exception to log. | ### registerDefaultLogger | public static **void** [registerDefaultLogger](#std-label-io%5Frealm%5Flog%5FRealmLog%5FregisterDefaultLogger) ()                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Adds default native logger if it has been removed before. If the default logger has been registered already, it won't be added again. The default logger on Android will log to logcat. | ### remove | public static **boolean** [remove](#std-label-io%5Frealm%5Flog%5FRealmLog%5Fremove) ([RealmLogger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLogger/#std-label-io%5Frealm%5Flog%5FRealmLogger) logger) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Removes the given logger if it is currently added.**Returns**true if the logger was removed, false otherwise.                                                                                           | ### setLevel\n\n ### trace | public static **void** [trace](#std-label-io%5Frealm%5Flog%5FRealmLog%5Ftrace) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable,[String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs a [LogLevel.TRACE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FTRACE) event.**Parameters**throwable \\- optional exception to log.message \\- optional message.args \\- optional args used to format the message using [String.format(String, Object...)](https://docs.oracle.com/javase/7/docs/api/java/lang/String/format%28String,Object///%29.html) . | | public static **void** [trace](#std-label-io%5Frealm%5Flog%5FRealmLog%5Ftrace) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs a [LogLevel.TRACE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FTRACE) event.**Parameters**message \\- message to log.args \\- optional args used to format the message using [String.format(String, Object...)](https://docs.oracle.com/javase/7/docs/api/java/lang/String/format%28String,Object///%29.html) . | | public static **void** [trace](#std-label-io%5Frealm%5Flog%5FRealmLog%5Ftrace) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable)    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs a [LogLevel.TRACE](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FTRACE) exception.**Parameters**throwable \\- exception to log. | ### warn\n\n | public static **void** [warn](#std-label-io%5Frealm%5Flog%5FRealmLog%5Fwarn) ([String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) message,[java.lang.Object\\[\\]](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) args)                                                                                                |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Logs a [LogLevel.WARN](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FWARN) event.**Parameters**message \\- message to log.args \\- optional args used to format the message using [String.format(String, Object...)](https://docs.oracle.com/javase/7/docs/api/java/lang/String/format%28String,Object///%29.html) . | | public static **void** [warn](#std-label-io%5Frealm%5Flog%5FRealmLog%5Fwarn) ([Throwable](https://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) throwable)    |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Logs a [LogLevel.WARN](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/#std-label-io%5Frealm%5Flog%5FLogLevel%5FWARN) exception.**Parameters**throwable \\- exception to log. | ← [Class LogLevel](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/LogLevel/ \"Previous Section\")[Interface RealmLogger](https://mongodb.com/docs/realm/sdk/java/api/io/realm/log/RealmLogger/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Live Queries - Java SDK On this page * [Auto-Refresh](#auto-refresh)\n* [Read Operations](#read-operations)\n* [Read Characteristics](#read-characteristics)\n* [Results Are Not Copies](#results-are-not-copies)\n* [Results Are Lazy](#results-are-lazy)\n* [References Are Retained](#references-are-retained)\n* [Managed Objects](#managed-objects)\n* [Unmanaged objects](#unmanaged-objects)\n* [Notifications](#notifications) Objects in Realm clients are **live objects** that update automatically to reflect data changes, including[synced](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) remote changes, and emit[notification events](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-client-notifications) that you can subscribe to whenever their underlying data changes. You can use live objects to work with object-oriented data natively without an [ORM](https://en.wikipedia.org/wiki/Object-relational%5Fmapping) tool. Live objects are direct proxies to the underlying stored data, which means that a live object doesn't directly contain data. Instead, a live object always references the most up-to-date data on disk and[lazy loads](https://en.wikipedia.org/wiki/Lazy%5Floading) field values when you access them from a [collection](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-client-collections). This means that a realm can contain many objects but only pays the performance cost for data that the application is actually using. Valid write operations on a live object automatically persist to the realm and propagate to any other synced clients. You do not need to call an update method, modify the realm, or otherwise \"push\" updates. ## Auto-Refresh Realm objects accessed on a thread associated with a[Looper](https://developer.android.com/reference/android/os/Looper.html) automatically update periodically to reflect changes to underlying data. The Android UI thread always contains a `Looper` instance. If you need to keep Realm objects around for long periods of time on any other thread, you should configure a `Looper` for that thread. ## Warning ### Always Close Realm Instances on Non-Looper Threads to Avoid Resource Leaks Realms on a thread without a [Looper](https://developer.android.com/reference/android/os/Looper)do not automatically advance their version. This can increase the size of the realm in memory and on disk. Avoid using realm instances on non-Looper threads when possible. If you _do_ open a realm on a non-Looper thread, close the realm when you're done using it. ## Read Operations You can read back the data that you have[stored](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/#std-label-java-realm-database-writes) in Realm Database. The standard data access pattern across Realm SDKs is to find, filter, and sort objects, in that order. To get the best performance from Realm as your app grows and your queries become more complex, design your app's data access patterns around a solid understanding of Realm Database[read characteristics.](#std-label-java-realm-read-characteristics) ### Read Characteristics When you design your app's data access patterns around the following three key characteristics of reads in Realm Database, you can be confident you are reading data as efficiently as possible. ### Results Are Not Copies Results to a query are not copies of your data: modifying the results of a query will modify the data on disk directly. This memory mapping also means that results are**live**: that is, they always reflect the current state on disk. ## Tip ### See also:  [Collections are Live.](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-live-collections) ### Results Are Lazy Realm Database defers execution of a query until you access the results. You can chain several filter and sort operations without requiring extra work to process the intermediate state. ## Tip ### See also: \n\n ### References Are Retained One benefit of Realm Database's object model is that Realm Database automatically retains all of an object's[relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-client-relationships) as direct references, so you can traverse your graph of relationships directly through the results of a query. A **direct reference**, or pointer, allows you to access a related object's properties directly through the reference. Other databases typically copy objects from database storage into application memory when you need to work with them directly. Because application objects contain direct references, you are left with a choice: copy the object referred to by each direct reference out of the database in case it's needed, or just copy the foreign key for each object and query for the object with that key if it's accessed. If you choose to copy referenced objects into application memory, you can use up a lot of resources for objects that are never accessed, but if you choose to only copy the foreign key, referenced object lookups can cause your application to slow down. Realm Database bypasses all of this using zero-copy live objects. Realm object accessors point directly into database storage using memory mapping, so there is no distinction between the objects in Realm Database and the results of your query in application memory. Because of this, you can traverse direct references across an entire realm from any query result. ## Managed Objects **Managed objects** are live Realm objects that update based on changes to underlying data in Realm Database. Managed objects can only come from an open realm, and receive updates as long as that realm remains open. Managed objects _cannot be passed between threads_. ## Unmanaged objects **Unmanaged objects** are instances of Realm objects that are not live. You can get an unmanaged object by manually constructing a Realm object yourself, or by calling[Realm.copyFromRealm()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#copyFromRealm-E-). Unmanaged objects _can be passed between threads_. ## Notifications Any modern app should be able to react when data changes, regardless of where that change originated. When a user adds a new item to a list, you may want to update the UI, show a notification, or log a message. When someone updates that item, you may want to change its visual state or fire off a network request. Finally, when someone deletes the item, you probably want to remove it from the UI. Realm's notification system allows you to watch for and react to changes in your data, independent of the writes that caused the changes. Realm emits three kinds of notifications: * [Realm notifications](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-realm-notifications) whenever a specific realm commits a write transaction.\n* [Collection notifications](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-collection-notifications) whenever any Realm object in a collection changes, including inserts, updates, and deletes.\n* [Object notifications](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-object-notifications) whenever a specific Realm object changes, including updates and deletes. ## Tip ### See also:  [Usage Example: React to Changes](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-react-to-changes) ← [Realms - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/ \"Previous Section\")[Query Engine - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/device-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Atlas Device Sync - Java SDK On this page * [Overview](#overview)\n* [Partition-Based Sync](#partition-based-sync)\n* [Flexible Sync](#flexible-sync)\n* [Group Updates for Improved Performance](#group-updates-for-improved-performance) ## Overview Atlas Device Sync automatically synchronizes data between client applications and an [Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/#std-label-realm-cloud). When a client device is online, Sync asynchronously synchronizes data in a background thread between the device and your backend App. When you use Sync in your client application, your implementation must match the Sync Mode you select in your backend App configuration. The Sync Mode options are: * Partition-Based Sync\n* Flexible Sync You can only use one Sync Mode for your application. You cannot mix Partition-Based Sync and Flexible Sync within the same App. ## Tip ### See also:  [Configure and Enable Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) ## Partition-Based Sync When you select [Partition-Based Sync](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync) for your backend App configuration, your client implementation must include a partition value. This is the value of the [partition key](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-key) field you select when you configure Partition-Based Sync. The partition value determines which data the client application can access. You pass in the partition value when you open a synced realm. ## Flexible Sync When you select [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) for your backend App configuration, your client implementation must include subscriptions to queries on [queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields). Flexible Sync works by synchronizing data that matches query subscriptions you maintain in the client application. A subscription set contains a set of queries. Realm Flexible Sync returns documents matching those queries, where the user has the appropriate[permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read and/or read and write the documents. If documents match the query, but the client does not have the permission to read or write them, they do not sync to the client application. You can form queries using [Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language)or the [Fluent Interface for Android.](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-client-query-engine) ## Note Flexible Sync does not support all the query operators available in Realm Query Language and the SDK's query engine. See [Flexible Sync RQL Limitations](https://mongodb.com/docs/realm/realm-query-language/#std-label-flexible-sync-rql-limitations) for details. Subscription sets are based on a specific type of [Realm object](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-objects). You might have multiple subscriptions if you have many types of Realm objects. To use Flexible Sync in your client application, open a synced realm with a flexible sync configuration. Then, manage subscriptions to determine which documents to sync. ### Group Updates for Improved Performance Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/realm-database/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - Java SDK On this page * [Database Internals](#database-internals)\n* [Native Database Engine](#native-database-engine)\n* [Realm Files](#realm-files)\n* [Copy-on-Write: The Secret Sauce of Data Versioning](#copy-on-write--the-secret-sauce-of-data-versioning)\n* [Memory Mapping](#memory-mapping)\n* [Compaction](#compaction)\n* [ACID Compliance](#acid-compliance)\n* [Features](#features)\n* [Queries](#queries)\n* [Encryption](#encryption)\n* [Indexes](#indexes)\n* [Schemas](#schemas)\n* [Persistent or In-Memory Realms](#persistent-or-in-memory-realms)\n* [Atlas Device Sync](#atlas-device-sync) Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) This page explains some of the implementation details and inner workings of Realm Database and Device Sync. This page is for you if you are: * a developer interested in learning more about Realm Database\n* comparing Realm Database with competing databases\n* trying to understand how Realm Database works with Device Sync This explanation begins with a deep dive into database internals, continues with a high-level introduction to some of the features of Realm Database, and wraps up with some of the differences of working with Device Sync and the local version of Realm Database. ## Database Internals Realm Database uses a completely unique database engine, file format, and design. This section describes some of the high-level details of those choices. This section applies to both the device-local version of Realm Database as well as the networked Device Sync version. Differences between the local database and the synchronized database are explained in the Atlas Device Sync section. ### Native Database Engine Realm Database is an entire database written from scratch in C++, instead of building on top of an underlying database engine like SQLite. Realm Database's underlying storage layer uses[B+ trees](https://en.wikipedia.org/wiki/B%2B%5Ftree) to organize objects. As a result, Realm Database controls optimizations from the storage level all the way up to the access level. Realm Database stores data in **realms**: collections of heterogeneous realm objects. You can think of each realm as a database. Each object in a realm is equivalent to a row in a SQL database table or a MongoDB document. Unlike SQL, realms do not separate different object types into individual tables. Realm Database stores objects as groups of property values. We call this column-based storage. This means that queries or writes for individual objects can be slower than row-based storage equivalents when unindexed, but querying a single field across multiple objects or fetching multiple objects can be much faster due to spatial locality and in-CPU vector operations. Realm Database uses a [zero-copy](https://en.wikipedia.org/wiki/Zero-copy) design to make queries faster than an ORM, and often faster than raw SQLite. ### Realm Files Realm Database persists data in files saved on device storage. The database uses several kinds of file:\n\n Realm files contain object data with the following data structures: Groups, Tables, Cluster Trees, and Clusters. Realm Database organizes these data structures into a tree structure with the following form: * The top level, known as a Group, stores object metadata, a transaction log, and a collection of Tables.\n* Each class in the realm schema corresponds to a Table within the top-level Group.\n* Each Table contains a Cluster Tree, an implementation of a B+ tree.\n* Leaves on the Cluster Tree are called Clusters. Each contains a range of objects sorted by key value.\n* Clusters store objects as collections of columns.\n* Each column contains data for a single property for multiple instances of a given object. Columns are arrays of data with uniformly sized values.\n* Columns store data in one of the following sizes: 1, 2, 4, 8, 16, 32, or 64 bits. Each column uses one value size, determined by the largest value. Since pointers refer to memory addresses, objects written to persistent files cannot store references as pointers. Instead, realm files refer to data using the offset from the beginning of the file. We call this a ref. As Realm Database uses memory mapping to read and write data, database operations translate these refs from offsets to memory pointers when navigating database structures. ### Copy-on-Write: The Secret Sauce of Data Versioning Realm Database uses a technique called **copy-on-write**, which copies data to a new location on disk for every write operation instead of overwriting older data on disk. Once the new copy of data is fully written, the database updates existing references to that data. Older data is only garbage collected when it is no longer referenced or actively in use by a client application. Because of copy-on-write, older copies of data remain valid, since all of the references in those copies still point to other valid data. Realm Database leverages this fact to offer multiple versions of data simultaneously to different threads in client applications. Most applications tie data refreshes to the repaint cycle of the looper thread that controls the UI, since data only needs to refresh as often as the UI does. Longer-running procedures on background threads, such as large write operations, can work with a single version of data for a longer period of time before committing their changes. ### Memory Mapping Writes use [memory mapping](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) to avoid copying data back and forth from memory to storage. Accessors and mutators read and write to disk via memory mapping. As a result, object data is never stored on the stack or heap of your app. By default, data is memory-mapped as read-only to prevent accidental writes. Realm Database uses operating system level paging, trusting each operating system to implement memory mapping and persistence better than a single library could on its own. ### Compaction Realm Database automatically reuses free space that is no longer needed after database writes. However, realm files never shrink automatically, even if the amount of data stored in your realm decreases significantly. Compact your realm to optimize storage space and decrease file size if possible. You should compact your realms occasionally to keep them at an optimal size. You can do this manually, or by configuring your realms to compact on launch. However, Realm Database reclaims unused space for future writes, so compaction is only an optimization to conserve space on-device. ### ACID Compliance Realm Database guarantees that transactions are [ACID](https://en.wikipedia.org/wiki/ACID) compliant. This means that all committed write operations are guaranteed to be valid and that clients don't see transient states in the event of a system crash. Realm Database complies with ACID with the following design choices:\n\n ## Features Realm Database supports many popular database features. ### Queries You can query Realm Database using platform-native queries or a raw query language that works across platforms. ### Encryption Realm Database supports on-device realm encryption. Since memory mapping does not support encryption, encrypted realms use a simulated in-library form of memory mapping instead. ## Note Realm forbids opening the same encrypted realm from multiple processes. Attempting to do so will throw the error: \"Encrypted interprocess sharing is currently unsupported.\" ### Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time. ### Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, do not require a migration. After you increment the local schema version, you can begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. See your SDK's documentation for more information on migrations. ### Persistent or In-Memory Realms You can use Realm Database to store data persistently on disk, or ephemerally in memory. Ephemeral realms can be useful in situations where you don't need to persist data between application instances, such as when a user works in a temporary workspace. ## Atlas Device Sync Device Sync adds network synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. Device Sync relies on a worker client that communicates with your application backend in a dedicated thread in your application. Additionally, synced realms keep a history of changes to contained objects. Sync uses this history to resolve conflicts between client changes and backend changes. Applications that use Device Sync define their schema on the backend using[JSON Schema](https://json-schema.org/learn/getting-started-step-by-step.html). Client applications must match that backend schema to synchronize data. However, if you prefer to define your initial schema in your application's programming language, you can use [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to create a backend JSON Schema based on native SDK objects as you write your application. However, once your application is used for production purposes, you should alter your schema using JSON Schema on the backend. ← [Asynchronous API - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/async-api/ \"Previous Section\")[Realms - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/rx/ObjectChange/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class ObjectChange On this page * [io.realm.rx](#io.realm.rx)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [equals](#equals)\n* [getChangeset](#getchangeset)\n* [getObject](#getobject)\n* [hashCode](#hashcode)\n* [toString](#tostring) ## io.realm.rx [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.rx.ObjectChange Container wrapping the result of a [io.realm.RealmObjectChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObjectChangeListener/#std-label-io%5Frealm%5FRealmObjectChangeListener) being triggered. This is used by [RealmObject.asChangesetObservable()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject%5FasChangesetObservable%5F%5F) and [RealmObject.asChangesetObservable(RealmModel)](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject%5FasChangesetObservable%5FRealmModel%5F) as RxJava is only capable of emitting one item, not multiple. ## Constructors | Constructor and Description                                                                                                                                                                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ObjectChange](#std-label-io%5Frealm%5Frx%5FObjectChange-1) (**E** object,[ObjectChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ObjectChangeSet/#std-label-io%5Frealm%5FObjectChangeSet) changeset)Constructor for a ObjectChange. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [ObjectChange](#std-label-io%5Frealm%5Frx%5FObjectChange-1) (**E** object,[ObjectChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ObjectChangeSet/#std-label-io%5Frealm%5FObjectChangeSet) changeset) |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Constructor for a ObjectChange.**Parameters**object \\- the object that was updated.changeset \\- the changeset describing the update.                                                                     | ## Method Detail ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Frx%5FObjectChange%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                        | ### getChangeset | public [ObjectChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ObjectChangeSet/#std-label-io%5Frealm%5FObjectChangeSet) [getChangeset](#std-label-io%5Frealm%5Frx%5FObjectChange%5FgetChangeset) ()                                                                                                                                                                                                                                                                                                                   |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Returns the changeset describing the update.This will be null the first time the stream emits the object as well as when a asynchronous query is loaded for the first time.// Examplerealm.where(Person.class).findFirstAsync().asChangesetObservable()  .subscribe(new Consumer<ObjectChange>() {   @Override    public void accept(ObjectChange item) throws Exception {      item.getChangeset(); // Will return null the first two times  }});**Returns**the changeset describing how the object was updated. | ### getObject\n\n ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Frx%5FObjectChange%5FhashCode) ()                       |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ### toString | public [String](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html) [toString](#std-label-io%5Frealm%5Frx%5FObjectChange%5FtoString) () |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**toString in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                             | ← [Class CollectionChange](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/CollectionChange/ \"Previous Section\")[Class RealmObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RealmObservableFactory/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/relationships/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Relationships - Java SDK On this page * [Key Concepts](#key-concepts)\n* [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationship](#inverse-relationship) Realm allows you to define explicit relationships between the types of objects in an App. A relationship is an object property that references another Realm object rather than one of the primitive data types. You define relationships by setting the type of an object property to another object type in the [property schema.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/#std-label-property-schema) Relationships are direct references to other objects in a realm, which means that you don't need bridge tables or explicit joins to define a relationship like you would in a relational database. Instead you can access related objects by reading and writing to the property that defines the relationship. Realm Database executes read operations lazily as they come in, so querying a relationship is just as performant as reading a regular property. There are three primary types of relationships between objects: * [One-to-One Relationship](#std-label-java-to-one-relationship)\n* [One-to-Many Relationship](#std-label-java-to-many-relationship)\n* [Inverse Relationship](#std-label-java-inverse-relationship) ## Key Concepts You can define relationships, collections, and embedded objects in your object schema using the following types: * `RealmObject`\n* `RealmList <? extends RealmObject>` Use annotations to indicate whether a given field represents a foreign key relationship or an embedded object relationship. For more information, see [Relationship Annotations.](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-relationships) ### To-One Relationship A **to-one** relationship means that an object is related in a specific way to no more than one other object. You define a to-one relationship for an object type in its [object schema](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-object-schema) by specifying a property where the type is the related Realm object type. Setting a relationship field to null removes the connection between objects, but Realm Database does not delete the referenced object unless that object is [embedded.](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-field-relationships-embedded) ## Tip ### See also:  [Usage Example: To-One Relationships](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-field-relationships-many-to-one) ### To-Many Relationship A **to-many** relationship means that an object is related in a specific way to multiple objects. You can create a relationship between one object and any number of objects using a field of type `RealmList<T>`where `T` is a Realm object in your application: ## Tip ### See also:  [Usage Example: To-Many Relationships](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-field-relationships-many-to-many) ### Inverse Relationship An **inverse relationship** links an object back to any other objects that refer to it in a defined to-one or to-many relationship. Relationship definitions are unidirectional, so you must explicitly define a property in the object's model as an inverse relationship. For example, the to-many relationship \"User has many Tasks\" does not automatically create the inverse relationship \"Task belongs to User\". If you don't specify the inverse relationship in the object model, you would need to run a separate query to look up the user that is assigned to a given task. To define an inverse relationship, define a `LinkingObjects` property in your object model. The `LinkingObjects` definition specifies the object type and property name of the relationship that it inverts.\n\n Fields annotated with `@LinkingObjects` must be: * marked `final`\n* of type `RealmResults<T>` where `T` is the type at the opposite end of the relationship Since relationships are many-to-one or many-to-many, following inverse relationships can result in zero, one, or many objects. Like any other `RealmResults` set, you can[query](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/#std-label-java-client-query-engine) an inverse relationship. ## Tip ### See also:  [Usage Example: Inverse Relationships](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-field-relationships-inverse) ← [Write Transactions - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/write-transactions/ \"Previous Section\")[Object Models & Schemas - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/realms/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realms - Java SDK On this page * [Types of Realm](#types-of-realm)\n* [Read-Only Realms](#read-only-realms)\n* [In-Memory Realms](#in-memory-realms)\n* [Dynamic Realms](#dynamic-realms)\n* [The Realm Lifecycle](#the-realm-lifecycle)\n* [Multi-process](#multi-process)\n* [Comparison with Other Databases](#comparison-with-other-databases)\n* [Realm Schema](#realm-schema)\n* [Synced Realms](#synced-realms)\n* [Find Your Realm File](#find-your-realm-file)\n* [Realm File Size](#realm-file-size)\n* [Limit the Maximum Number of Active Versions](#limit-the-maximum-number-of-active-versions)\n* [Compact a Realm](#compact-a-realm)\n* [Backup and Restore Realms](#backup-and-restore-realms) A **realm** is a set of related objects that conform to a pre-defined schema. Realms may contain more than one type of data as long as a schema exists for each type. Every realm stores data in a separate realm file that contains a binary encoding of each object in the realm. You can automatically [synchronize realm across multiple devices](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) and set up [reactive event handlers](https://mongodb.com/docs/realm/sdk/java/examples/react-to-changes/#std-label-java-realm-notifications) that call a function any time an object in a realm is created, modified, or deleted. ## Types of Realm When opening a realm, you can configure many properties of the realm. ### Read-Only Realms It's sometimes useful to ship a prepared realm file with your app that contains shared data that does not frequently change. You can use the [readOnly()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#readOnly--)method when configuring your realm to make it read-only. This can prevent accidental writes to the realm and causes the realm to throw an `IllegalStateException` if a write occurs. ## Warning ### Read-Only Realm Files are Writeable Read-only realms are only enforced as read-only in process. The realm file itself is still writeable. ## Tip ### See also:  [Usage Examples: Read-Only Realms](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/#std-label-java-read-only-realms) ### In-Memory Realms To create a realm that runs entirely in memory without being written to a file, use the [inMemory()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#inMemory--) method. When memory runs low on an Android device, in-memory realms may [swap](https://en.wikipedia.org/wiki/Memory%5Fpaging#Terminology) temporarily from main memory to disk space. The SDK deletes all files created by an in-memory realm when: * the realm closes\n* all references to that realm fall out of scope ## Tip ### See also:  [Usage Examples: In-Memory Realms](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/#std-label-java-in-memory-realms) ### Dynamic Realms Conventional realms define a schema using `RealmObject` subclasses or the `RealmModel` interface. A[DynamicRealm](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/DynamicRealm.html) uses strings to define a schema at runtime. Opening a dynamic realm uses the same configuration as a conventional realm, but dynamic realms ignore all configured schema, migration, and schema versions.\n\n ## Tip ### See also:  [Usage Examples: Dynamic Realms](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/#std-label-java-dynamic-realms) ## The Realm Lifecycle Every realm instance consumes a significant amount of resources. Opening and closing a realm are both expensive operations, but keeping a realm open also incurs significant resource overhead. To maximize the performance of your application, you should minimize the number of open realms at any given time and limit the number of open and close operations used. However, opening a realm is not always consistently expensive. If the realm is already open within the same process or thread, opening an additional instance requires fewer resources: * If the realm is not open within the same process, opening the realm is expensive.\n* If the realm is already open on a different thread within the same process, opening the realm is less expensive, but still nontrivial.\n* If the realm is already open on the same thread within the same process, opening the realm requires minimal additional resources. When you open a realm for the first time, Realm Database performs the memory-mapping and schema validation required to read and write data to the realm. Additional instances of that realm on the same thread use the same underlying resources. Instances of that realm on separate threads use some of the same underlying resources. When all connections to a realm are closed in a thread, Realm Database frees the thread resources used to connect to that realm. When all connections to a realm are closed in a process, Realm Database frees all resources used to connect to that realm. As a best practice, we recommend tying the realm instance lifecycle to the lifecycles of the views that observe the realm. For instance, consider a `RecyclerView` that displays `RealmResults`data via a `Fragment`. You could: * Open a single realm that contains the data for that view in the `Fragment.onCreateView()` lifecycle method.\n* Close that same realm in the `Fragment.onDestroyView()`lifecycle method. ## Note If your realm is especially large, fetching a realm instance in `Fragment.onCreateView()` may briefly block rendering. If opening your realm in `onCreateView()` causes performance issues, consider managing the realm from `Fragment.onStart()`and `Fragment.onStop()` instead. If multiple `Fragment` instances require access to the same dataset, you could manage a single realm in the enclosing `Activity`: * Open the realm in the `Activity.onCreate()` lifecycle method.\n* Close the realm in the `Activity.onDestroy()` lifecycle method. ## Multi-process You cannot access [encrypted](https://mongodb.com/docs/realm/sdk/java/advanced-guides/encryption/#std-label-java-encrypt-a-realm) or[synced](https://mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/#std-label-java-sync-changes-between-devices) realms simultaneously from different processes. However, local realms function normally across processes, so you can read, write, and receive notifications from multiple APKs. ## Comparison with Other Databases The Realm data model is similar to both relational and document databases but has distinct differences from both. To underscore these differences, it's helpful to highlight what a realm **is not**: A realm is not a single, application-wide database. Unlike other applications, which store all of their data in a single database, Apps often split data across multiple realms to organize data more efficiently and to enforce access controls. A realm is not a table. Tables typically only store one kind of information, such as street addresses or items in a store inventory, whereas a realm can contain any number of object types. A realm is not a collection of schemaless documents. Application objects are similar to documents, but every object in a realm conforms to a defined schema for its object type. An object cannot contain a field that is not described by its schema. ## Realm Schema A **Realm Schema** is a list of valid [object schemas](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-objects) that each define an object type that an App may persist. All objects in a realm must conform to the Realm Schema.\n\n Client applications provide a Realm Schema when they open a realm. If a realm already contains data, then Realm Database validates each existing object to ensure that an object schema was provided for its type and that it meets all of the constraints specified in the schema. ## Example A realm that contains basic data about books in libraries might use a schema like the following: `| [                                                |\n| ------------------------------------------------ |\n| {                                                |\n| \"type\": \"Library\",                               |\n| \"properties\": {                                  |\n| \"address\": \"string\",                             |\n| \"books\": \"Book[]\"                                |\n| }                                                |\n| },                                               |\n| {                                                |\n| \"type\": \"Book\",                                  |\n| \"primaryKey\": \"isbn\",                            |\n| \"properties\": {                                  |\n| \"isbn\": \"string\",                                |\n| \"title\": \"string\",                               |\n| \"author\": \"string\",                              |\n| \"numberOwned\": { \"type\": \"int?\", \"default\": 0 }, |\n| \"numberLoaned\": { \"type\": \"int?\", \"default\": 0 } |\n| }                                                |\n| }                                                |\n| ]                                                | ` ## Synced Realms\n\n When you use [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync), you can customize the data your client application syncs by [subscribing to queries](https://mongodb.com/docs/realm/sdk/java/examples/flexible-sync/#std-label-java-sync-subscribe-to-queryable-fields). These queries search for data in your App backend, and the Flexible Sync realm syncs data that matches the queries. The client application can only sync data where the user has the appropriate [read or read and write permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to access the data. You can customize permissions for the data that synced realms can read and write from your App when you configure[Realm Rules.](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-sync-rules) ## Find Your Realm File Realm Database stores a binary encoded version of every object and type in a realm in a single `.realm` file. The filesystem used by Android emulators is not directly accessible from the machine running Realm Studio. You must download the file from the emulator before you can access it. First, find the path of the file on the emulator: ```java // Run this on the device to find the path on the emulator Realm realm = Realm.getDefaultInstance(); Log.i(\"Realm\", realm.getPath()); \n``` Then, download the file using ADB. You can do this while the app is running. ```java > adb pull <path> \n``` You can also upload the modified file again using ADB, but only when the app isn't running. Uploading a modified file while the app is running can corrupt the file. ```java > adb push <file> <path> \n``` ## Tip ### See also: Auxiliary Realm Files Realm Database creates additional files for each realm. To learn more about these files, see [Realm Database Internals.](https://mongodb.com/docs/realm/sdk/java/fundamentals/realm-database/#std-label-java-realm-database) ## Realm File Size Realm Database usually takes up less space on disk than an equivalent SQLite database. However, in order to give you a consistent view of your data, Realm operates on multiple versions of a realm. If many versions of a realm are opened simultaneously, the realm file can require additional space on disk. These versions take up an amount of space dependent on the amount of changes in each transaction. Many small transactions have the same overhead as a small number of large transactions. Unexpected file size growth usually happens for one of three reasons: 1. _You open a realm on a background thread and forget to close it again._ As a result, Realm Database retains a reference to the older version of data on the background thread. Because Realm Database automatically updates realms to the most recent version on threads with loopers, the UI thread and other Looper threads do not have this problem.\n2. _You hold references to too many versions of frozen objects._Frozen objects preserve the version of a realm that existed when the object was first frozen. If you need to freeze a large number of objects, consider using [Realm.copyFromRealm()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#copyFromRealm-E-) instead to only preserve the data you need.\n3. _You read some data from a realm. Then, you block the thread with a long-running operation. Meanwhile, you write many times to the realm on other threads._ This causes Realm Database to create many intermediate versions. You can avoid this by:  \n   * batching the writes  \n   * avoiding leaving the realm open while otherwise blocking the background thread. ### Limit the Maximum Number of Active Versions You can set [maxNumberOfActiveVersions()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#maxNumberOfActiveVersions-long-)when building your `RealmConfiguration` to throw an`IllegalStateException` if your application opens more versions of a realm than the permitted number. Versions are created when executing a write transaction.\n\n ### Compact a Realm You can remove unused space by **compacting** the realm file: * Manually: call [compactRealm()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#compactRealm-io.realm.RealmConfiguration-)\n* Automatically: specify the [compactOnLaunch()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#compactOnLaunch-io.realm.CompactOnLaunchCallback-)builder option when opening the first connection to a realm in your Android application ## Important ### Compact All Production Applications Every production application should implement compacting to periodically reduce realm file size. ## Backup and Restore Realms Realm Database persists realms to disk using files on your Android device. To back up a realm, [find your realm file](#std-label-java-realm-file) and copy it to a safe location. You should close all instances of the realm before copying it. Alternatively, you can also use [realm.writeCopyTo()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#writeCopyTo-java.io.File-) to write a compacted version of a realm to a destination file. ## Tip ### See also:  If you want to back up a realm to an external location like Google Drive, see the following article series: ([Part 1](https://medium.com/glucosio-project/example-class-to-export-import-a-realm-database-on-java-c429ade2b4ed#.80ibsc7wm),[Part 2](https://medium.com/glucosio-project/backup-restore-a-realm-database-on-google-drive-with-drive-api-c238515a5975#.qbuugb322),[Part 3](https://medium.com/glucosio-project/build-a-nice-ux-to-backup-and-sync-your-app-data-on-google-drive-3-3-a3b598cab68b#.5mjk4w4se)). ← [Realm Database - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/realm-database/ \"Previous Section\")[Live Queries - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query Engine - Java SDK On this page * [Fluent Interface](#fluent-interface)\n* [About the examples on this page](#about-the-examples-on-this-page)\n* [Comparison Operators](#comparison-operators)\n* [Logical Operators](#logical-operators)\n* [String Operators](#string-operators)\n* [Aggregate Operators](#aggregate-operators)\n* [Realm Query Language](#realm-query-language) To filter data in your realm, use the Realm Database query engine. There are two ways to access the query engine with the Java SDK: * [Fluent interface](#std-label-java-query-fluent-interface)\n* [Realm Query Language](#std-label-java-realm-query-language) ## Fluent Interface The Java SDK uses a [Fluent interface](https://en.wikipedia.org/wiki/Fluent%5Finterface)to construct multi-clause queries that are passed to the query engine. See [RealmQuery API](https://realm.io/docs/java/latest/api/io/realm/RealmQuery.html)for a complete list of available methods. There are several types of operators available to filter a[Realm collection](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-client-collections). Filters work by **evaluating** an operator expression for every object in the collection being filtered. If the expression resolves to `true`, Realm Database includes the object in the results collection. An **expression** consists of one of the following: * The name of a property of the object currently being evaluated.\n* An operator and up to two argument expression(s).\n* A literal string, number, or date. ## About the examples on this page The examples in this page use a simple data set for a task list app. The two Realm object types are `Project`and `Task`. A `Task` has a name, assignee's name, and completed flag. There is also an arbitrary number for priority (higher is more important) and a count of minutes spent working on it. A `Project` has zero or more`Tasks`. See the schema for these two classes, `Project` and`Task`, below: ### Comparison Operators The most straightforward operation in a search is to compare values.\n\n ## Example The following example uses the query engine's comparison operators to: * Find high priority tasks by comparing the value of the `priority` property value with a threshold number, above which priority can be considered high.\n* Find just-started or short-running tasks by seeing if the `progressMinutes` property falls within a certain range.\n* Find unassigned tasks by finding tasks where the `assignee` property is equal to `null`.\n* Find tasks assigned to specific teammates Ali or Jamie by seeing if the `assignee` property is in a list of names. ### Logical Operators You can make compound predicates using logical operators. | Operator | Description                                                              |\n| -------- | ------------------------------------------------------------------------ |\n| and      | Evaluates to true if both left-hand and right-hand expressions are true. |\n| not      | Negates the result of the given expression.                              |\n| or       | Evaluates to true if either expression returns true.                     | ## Example We can use the query language's logical operators to find all of Ali's completed tasks. That is, we find all tasks where the `assignee` property value is equal to 'Ali' AND the `isComplete` property value is `true`: ### String Operators You can compare string values using these string operators. Regex-like wildcards allow more flexibility in search.\n\n ## Example We use the query engine's string operators to find projects with a name starting with the letter 'e' and projects with names that contain 'ie': ## Note ### Case-insensitive Character Limitations Case-insensitive string operators only support the`Latin Basic`, `Latin Supplement`, `Latin Extended A`, and`Latin Extended B (UTF-8 range 0–591)` character sets. Setting the case insensitive flag in queries when using `equalTo`,`notEqualTo`, `contains`, `endsWith`, `beginsWith`, or`like` only works on English locale characters. ### Aggregate Operators You can apply an aggregate operator to a collection property of a Realm object. Aggregate operators traverse a[collection](https://mongodb.com/docs/realm/sdk/java/data-types/collections/#std-label-java-client-collections) and reduce it to a single value. | Operator | Description                                                                       |\n| -------- | --------------------------------------------------------------------------------- |\n| average  | Evaluates to the average value of a given numerical property across a collection. |\n| count    | Evaluates to the number of objects in the given collection.                       |\n| max      | Evaluates to the highest value of a given numerical property across a collection. |\n| min      | Evaluates to the lowest value of a given numerical property across a collection.  |\n| sum      | Evaluates to the sum of a given numerical property across a collection.           | ## Example We create a couple of filters to show different facets of the data: * Projects with average tasks priority above 5.\n* Long running projects. ## Realm Query Language You can also query realms using Realm Query Language, a string-based query language to constrain searches when retrieving objects from a realm. To learn more about using Realm Query Language with the Java SDK, refer to the following documentation: * [Realm Query Language reference](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql)\n* [Usage Examples - Realm Query Language](https://mongodb.com/docs/realm/sdk/java/examples/filter-data/#std-label-java-filter-with-realm-query-language) ← [Live Queries - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/ \"Previous Section\")[Write Transactions - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/write-transactions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/async-api/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Asynchronous API - Java SDK On this page * [Asynchronous Calls](#asynchronous-calls)\n* [Realm.Callback](#realm.callback)\n* [App.Callback](#app.callback)\n* [RealmAsyncTask](#realmasynctask)\n* [RealmResults](#realmresults)\n* [RealmResultTask](#realmresulttask)\n* [Coroutines](#coroutines) The Java SDK lets you access network and disk resources in two ways: **synchronously** and **asynchronously**. While synchronous, or \"sync\", requests block execution until the request returns success or failure, asynchronous, or \"async\", requests assign a callback and proceed execution to the next line of code. When the request returns, the callback runs to process results. In the callback, you can check if the request executed successfully and either access the returned results or the returned error. ## Asynchronous Calls Asynchronous API requests in the SDK end with the suffix \"Async\". There are several different ways an asynchronous request can behave, depending on which part of the SDK you're using. ### Realm.Callback Asynchronous calls to open a realm, both with and without Sync, use a final parameter of type [Realm.Callback](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.Callback.html). To retrieve returned values after the request completes, implement the `onSuccess()` method in the callback object passed as the final parameter to these asynchronous methods. You should also implement the `onError()` method to handle request failures, but it is not required. ### App.Callback When you query Atlas App Services like [Functions](https://mongodb.com/docs/realm/sdk/java/examples/call-a-function/#std-label-java-call-a-function) and [user authentication](https://mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-authenticate-users), asynchronous calls accept a final parameter of type [App.Callback](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/App.Callback.html). You can handle this callback with a lambda function that accepts a single parameter of type [App.Result](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/App.Result.html). To retrieve a returned values from`App.Callback` requests: 1. Use the `isSuccess()` method of the `App.Result` passed to the callback function to determine if the query completed successfully.\n2. If the query was successful, use the `get()` method to retrieve the result of the query. If the query failed, use `getError()` to retrieve the exception that caused the query to fail. ### RealmAsyncTask Asynchronous calls to [execute transactions](https://mongodb.com/docs/realm/sdk/java/fundamentals/write-transactions/#std-label-java-write-transactions) on a realm return an instance of [RealmAsyncTask](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmAsyncTask.html). You can optionally [specify an error handler](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.Transaction.OnError.html) or a[success notification](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.Transaction.OnSuccess.html) for `RealmAsyncTask` by passing additional parameters to the asynchronous call. Additionally, you use the [cancel()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmAsyncTask.html#cancel--)method to stop a transaction from completing. The lambda function passed to a `RealmAsyncTask` contains the write operations to include in the transaction. ### RealmResults\n\n ### RealmResultTask Asynchronous [queries to Atlas](https://mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/#std-label-java-mongodb-data-access) return an instance of[RealmResultTask](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/RealmResultTask.html). You can cancel `RealmResultTask` instances just like`RealmAsyncTask`. To access the values returned by your query, you can use: * [get()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/RealmResultTask.html#get--) to block until the operation completes\n* [getAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/RealmResultTask.html#getAsync-io.realm.mongodb.App.Callback-)to handle the result via an [App.Callback](#std-label-java-app-callback)instance ## Coroutines The SDK provides a set of [Kotlin extensions](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/) to request asynchronously using coroutines and flows instead of callbacks. You can use these extensions to [execute transactions](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/io.realm.kotlin/io.realm.-realm/execute-transaction-await.html),[watch for changes](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/io.realm.kotlin/add-change-listener.html), [read](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/io.realm.kotlin/io.realm.-realm/where.html), and [write.](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/io.realm.kotlin/io.realm.-realm/create-object.html)\n\n ` ## Tip ### Kotlin Flows use Frozen Objects Across Multiple Threads The `toFlow()` extension method passes [frozen](https://mongodb.com/docs/realm/sdk/java/advanced-guides/threading/#std-label-java-frozen-objects) Realm objects to safely communicate between threads. ## Tip ### See also:  The SDK also includes Kotlin extensions that make specifying type parameters for Realm Database [reads](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/io.realm.kotlin/io.realm.-realm/where.html) and[writes](https://www.mongodb.com/docs/realm-sdks/java/latest/kotlin-extensions/io.realm.kotlin/io.realm.-realm/create-object.html) easier. ← [Realm Fundamentals - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/ \"Previous Section\")[Realm Database - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/realm-database/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/write-transactions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Write Transactions - Java SDK On this page * [Run a Transaction](#run-a-transaction) You can **create** objects in a realm,**update** objects in a realm, and eventually **delete**objects from a realm. Because these operations modify the state of the realm, we call them writes. Realm Database handles writes in terms of **transactions**. A transaction is a list of read and write operations that Realm treats as a single indivisible operation. In other words, a transaction is _all or nothing_: either all of the operations in the transaction succeed or none of the operations in the transaction take effect. ## Note All writes must happen in a transaction. A realm allows only one open write transaction at a time. Realm blocks other writes on other threads until the open transaction is complete. Consequently, there is no race condition when reading values from the realm within a transaction. When you are done with your transaction, Realm either**commits** it or **cancels** it: * When Realm **commits** a transaction, Realm writes all changes to disk. For synced realms, Realm queues the change for synchronization with Atlas App Services.\n* When Realm **cancels** a write transaction or an operation in the transaction causes an error, all changes are discarded (or \"rolled back\"). ## Run a Transaction Realm represents each transaction as a callback function that contains zero or more read and write operations. To run a transaction, define a transaction callback and pass it to the realm's `write` method. Within this callback, you are free to create, read, update, and delete on the realm. If the code in the callback throws an exception when Realm runs it, Realm cancels the transaction. Otherwise, Realm commits the transaction immediately after the callback. ## Example The following code shows how to run a transaction with[executeTransaction()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#executeTransaction-io.realm.Realm.Transaction-)or [executeTransactionAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#executeTransactionAsync-io.realm.Realm.Transaction-). If the code in the callback throws an exception, Realm cancels the transaction. Otherwise, Realm commits the transaction. ## Tip ### See also:  [Usage Example: Read and Write Data](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/#std-label-java-read-and-write-data) ← [Query Engine - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/query-engine/ \"Previous Section\")[Relationships - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/schema-versions-and-migrations/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Schema Versions & Migrations - Java SDK On this page * [Schema Version](#schema-version)\n* [Migrations](#migrations) ## Schema Version A **schema version** identifies the state of a [Realm Schema](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realm-schema) at some point in time. Realm Database tracks the schema version of each realm and uses it to map the objects in each realm to the correct schema. Schema versions are integers that you may include in the realm configuration when you open a realm. If a client application does not specify a version number when it opens a realm then the realm defaults to version `0`. ## Important ### Increment Versions Monotonically [Migrations](https://mongodb.com/docs/realm/sdk/java/examples/modify-an-object-schema/#std-label-java-client-migrations) must update a realm to a higher schema version. Realm Database throws an error if a client application opens a realm with a schema version that is lower than the realm's current version or if the specified schema version is the same as the realm's current version but includes different[object schemas.](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-object-schema) ## Migrations A **local migration** is a migration for a realm that does not automatically [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) with another realm. Local migrations have access to the existing Realm Schema, version, and objects and define logic that incrementally updates the realm to its new schema version. To perform a local migration you must specify a new schema version that is higher than the current version and provide a migration function when you open the out-of-date realm. With the SDK, you can update underlying data to reflect schema changes using manual migrations. During such a manual migration, you can define new and deleted properties when they are added or removed from your schema. The editable schema exposed via a[DynamicRealm](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/DynamicRealm.html) provides convenience functions for renaming fields. This gives you full control over the behavior of your data during complex schema migrations. ## Tip ### Migrations During Application Development During development of an application, `RealmObject` classes can change frequently. You can use [Realm.deleteRealm()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#deleteRealm-io.realm.RealmConfiguration-) to delete the database file and eliminate the need to write a full migration for testing data. ## Tip ### See also:  [Usage Example: Migration Functions](https://mongodb.com/docs/realm/sdk/java/examples/modify-an-object-schema/#std-label-java-migration-function) ← [Object Models & Schemas - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/ \"Previous Section\")[Application Services - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/application-services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Object Models & Schemas - Java SDK On this page * [Realm Apps](#realm-apps)\n* [Primary Keys](#primary-keys)\n* [Optionality](#optionality)\n* [Relationships](#relationships)\n* [Indexes](#indexes)\n* [Modules](#modules)\n* [Realm Objects](#realm-objects)\n* [RealmProxy](#realmproxy)\n* [Realm Object Limitations](#realm-object-limitations)\n* [Incremental Builds](#incremental-builds) An **object schema** is a configuration object that defines the fields and relationships of a Realm object type. Android Realm applications define object schemas with Java or Kotlin classes using Realm Schemas. Object schemas specify constraints on object fields such as the data[type](https://mongodb.com/docs/realm/sdk/java/data-types/field-types/#std-label-java-supported-data-types) of each field, whether a field is required, and default field values. Schemas can also define[relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-client-relationships) between object types in a realm. Modifying your application's Realm Schema requires you to[migrate](https://mongodb.com/docs/realm/sdk/java/fundamentals/schema-versions-and-migrations/#std-label-java-schema-versions-and-migrations) data from older versions of your Realm Schema to the new version. ## Realm Apps Every App has a [Realm Schema](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realm-schema)composed of a list of object schemas for each type of object that the realms in that application may contain. Realm guarantees that all objects in a realm conform to the schema for their object type and validates objects whenever they're created, modified, or deleted. Apps that use Atlas Device Sync can define schemas in two ways: * object schemas [using Kotlin and Java class declarations](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/#std-label-create-schema-from-rom) with [Development Mode.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)\n* JSON [object schemas](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/#std-label-object-schema) in your App backend. ## Primary Keys _New in version 10.6.0_: Realm Database automatically [indexes](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-indexes-fundamentals)primary key fields. Previously, Realm only indexed `String` primary keys automatically. Realm treats fields marked with the[@PrimaryKey](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/PrimaryKey.html) annotation as primary keys for their corresponding object schema. Primary keys are subject to the following limitations: * You can define only one primary key per object schema.\n* Primary key values must be unique across all instances of an object in a realm. Attempting to insert a duplicate primary key value results in a [RealmPrimaryKeyConstraintException.](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/exceptions/RealmPrimaryKeyConstraintException.html)\n* Primary key values are immutable. To change the primary key value of an object, you must delete the original object and insert a new object with a different primary key value.\n* [Embedded objects](https://mongodb.com/docs/realm/sdk/java/data-types/embedded-objects/#std-label-java-embedded-objects) cannot define a primary key. You can create a primary key with any of the following types:\n\n Non-primitive types can contain a value of `null` as a primary key value, but only for one object of a particular type, since each primary key value must be unique. Attempting to insert an object with an existing primary key into a realm will result in a[RealmPrimaryKeyConstraintException.](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/exceptions/RealmPrimaryKeyConstraintException.html) Realm Database automatically [indexes](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-index-field)primary key fields, which allows you to efficiently read and modify objects based on their primary key. You cannot change the primary key field for an object type after adding any object of that type to a realm. If you are using Sync, you cannot change the primary key field for an object after defining the primary key in your backend [schema.](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) Embedded objects cannot contain primary keys. ## Tip ### See also:  * [Usage Examples: Define a Primary Key](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-primary-key)\n* [Usage Examples: Find a Specific Object by Primary Key](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/#std-label-java-find-a-specific-object-by-primary-key) ## Optionality You can make a field required to disallow `null` values in a field. Fields marked with Java object types and Kotlin nullable types (ending with `?`) are nullable by default. All other types (primitives, non-nullable Kotlin object types) are required by default. You can mark a nullable field with the [@Required](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/Required.html)annotation to prevent that field from holding a null value.[RealmLists](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmList.html) are never nullable, but you can use the `@Required` annotation to prevent objects in a list from holding a null value, even if the base type would otherwise allow it. You cannot mark a `RealmList` of `RealmObject` subtypes as required. You can make any of the following types required: * `String`\n* `UUID`\n* `ObjectId`\n* `Integer`\n* `Long`\n* `Short`\n* `Byte` or `byte[]`\n* `Boolean`\n* `Float`\n* `Double`\n* `Date`\n* `RealmList` Primitive types such as `int` and the `RealmList` type are implicitly required. Fields with the `RealmObject` type are always nullable, and cannot be made required. ## Important ### Kotlin Types and Nullability In Kotlin, types are non-nullable by default unless you explicitly add a `?` suffix to the type. You can only annotate[nullable types](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-optional-field). Using the`@Required` annotation on non-nullable types will fail compilation. ## Tip ### See also:  * [Usage Example: Required Fields](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-required-field)\n* [Usage Example: Optional Fields](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-optional-field) ## Relationships\n\n ## Tip ### See also:  * [Fundamentals: Relationships](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-client-relationships)\n* [Usage Example: Define a Relationship Field](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-relationships) ## Indexes **Indexes** support the efficient execution of queries in Realm Database. Without indexes, Realm Database must perform a_collection scan_, i.e. scan every document in a collection, to select those documents that match a query. If an appropriate index exists for a query, Realm Database can use the index to limit the number of documents that it must inspect. Indexes are special data structures that store a small portion of a realm's data in an easy to traverse form. The index stores the value of a specific field ordered by the value of the field. The ordering of the index entries supports efficient equality matches and range-based query operations. Adding an index can speed up some queries at the cost of slightly slower write times and additional storage and memory overhead. Indexes require space in your realm file, so adding an index to a property will increase disk space consumed by your realm file. Each index entry is a minimum of 12 bytes. You can index fields with the following types: * `String`\n* `UUID`\n* `ObjectId`\n* `Integer` or `int`\n* `Long` or `long`\n* `Short` or `short`\n* `Byte` or `byte[]`\n* `Boolean` or `bool`\n* `Date`\n* `RealmAny` Realm creates indexes for fields annotated with[@Index.](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/Index.html) ## Tip ### See also:  [Usage Example: Index a Field](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-index-field) ## Modules Realm Modules describe the set of Realm objects that can be stored in a realm. By default, Realm automatically creates a Realm Module that contains all Realm objects defined in your application. You can define a [RealmModule](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/annotations/RealmModule.html)to restrict a realm to a subset of classes defined in an application. If you produce a library that uses Realm, you can use a Realm Module to explicitly include only the Realm objects defined in your library in your realm. This allows applications that include your library to also use Realm without managing object name conflicts and migrations with your library's defined Realm objects. ## Tip ### See also:  [Usage Example: Omit Classes from your Realm Schema](https://mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-omit-classes-from-schema) ## Realm Objects Unlike normal Java objects, which contain their own data, a Realm object doesn't contain data. Instead, Realm objects read and write properties directly to Realm Database. Instances of Realm objects can be either **managed** or **unmanaged**. * **Managed** objects are:  \n   * persisted in Realm Database  \n   * always up to date  \n   * thread-confined  \n   * generally more lightweight than the unmanaged version, as they take up less space on the Java heap.\n* **Unmanaged** objects are just like ordinary Java objects, since they are not persisted and never update automatically. You can move unmanaged objects freely across threads. You can convert between the two states using[realm.copyToRealm()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#copyToRealm-E-io.realm.ImportFlag...-)and [realm.copyFromRealm().](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#copyFromRealm-E-) ### RealmProxy The `RealmProxy` classes are the Realm SDK's way of ensuring that Realm objects don't contain any data themselves. Instead, each class's `RealmProxy` accesses data directly in the database.\n\n ### Realm Object Limitations Realm objects: * cannot contain fields that use the `final` or `volatile` modifiers (except for [inverse relationship](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/#std-label-java-inverse-relationship)fields).\n* cannot extend any object other than `RealmObject`.\n* must contain an empty constructor (if your class does not include any constructor, the automatically generated empty constructor will suffice) Naming limitations: * Class names cannot exceed 57 characters.\n* Class names must be unique within [realm modules](#std-label-java-modules)\n* Field names cannot exceed 63 characters. Size limitations: * `String` or `byte[]` fields cannot exceed 16 MB. Usage limitations: * Because Realm objects are live and can change at any time, their `hashCode()` value can change over time. As a result, you should not use `RealmObject` instances as a key in any map or set. ## Incremental Builds The bytecode transformer used by Realm supports incremental builds, but your application requires a full rebuild when adding or removing the following from a Realm object field: * an `@Ignore` annotation\n* the `static` keyword\n* the `transient` keyword You can perform a full rebuild with Build > Clean Projectand Build > Rebuild Project in these cases. ← [Relationships - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/relationships/ \"Previous Section\")[Schema Versions & Migrations - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/schema-versions-and-migrations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/fundamentals/application-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Application Services - Java SDK On this page * [Overview](#overview)\n* [The App Client](#the-app-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Calling Atlas Functions](#calling-atlas-functions)\n* [Accessing MongoDB](#accessing-mongodb) ## Overview Realm provides SDKs that help you connect your client apps to the Atlas App Services backend. The SDK provides the functionality needed to authenticate users with any of the built-in [authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), call backend [functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), and directly access a linked[MongoDB data source.](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) ## The App Client When using the SDK to access the App Services backend, you start with a App object. This object provides all other functionality related to App Services. Initialize the `App` object with the App ID, which you can[find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ## Tip ### See also:  To learn how to initialize the App client, see[Connect to an App Services backend.](https://mongodb.com/docs/realm/sdk/java/examples/connect-to-app-services-backend/#std-label-java-init-appclient) ## Authentication & User Management One of the most challenging aspects of client development is implementing a robust and secure authentication system. With the Realm SDKs, however, you can use any of the App Services authentication providers with very minimal backend setup or client-side code required. With the authentication APIs, you can implement the following functionality: * Creation of new user accounts\n* User log-in and log-out\n* Multiple users logged on at the same time on the same device\n* Linking user accounts from different providers\n* Providing custom user data ## Tip ### See also:  To learn how to set up authentication with different providers, see[Authenticate Users.](https://mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-authenticate) To learn how to manage multiple users, see [Multi-User Applications.](https://mongodb.com/docs/realm/sdk/java/advanced-guides/multi-user-applications/#std-label-java-multi-user-applications) To learn how to link user accounts, see [Link User Identities.](https://mongodb.com/docs/realm/sdk/java/advanced-guides/link-user-identities/#std-label-java-link-user-identities) To learn how to provide custom user data, see [Custom User Data.](https://mongodb.com/docs/realm/sdk/java/advanced-guides/custom-user-data/#std-label-java-custom-user-data) ## Calling Atlas Functions [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) enable you to define and execute server-side logic for your application. You can call these functions from your client applications via the Realm SDKs. These server-side functions can run under the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your collections. By using Functions, you provide a secure way for a variety of client applications to share complex functionality without having to reproduce that logic client-side. ## Tip ### See also:  To learn how to call Functions, see [Call a Function.](https://mongodb.com/docs/realm/sdk/java/examples/call-a-function/#std-label-java-call-a-function) ## Accessing MongoDB\n\n ## Tip ### See also:  To learn how to use the MongoDB APIs, see [Query MongoDB.](https://mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/#std-label-java-mongodb-data-access) ← [Schema Versions & Migrations - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/schema-versions-and-migrations/ \"Previous Section\")[Atlas Device Sync - Java SDK](https://mongodb.com/docs/realm/sdk/java/fundamentals/device-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/background-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync a Realm in the Background - Java SDK On this page * [Prerequisites](#prerequisites)\n* [Example](#example)\n* [Synchronization Logic](#synchronization-logic)\n* [Worker](#worker) If you need to sync data when your app isn't running, you can sync realms in a background process. ## Prerequisites To get started with background synchronization, you need to add the following dependencies to your Android application: * [androidx.work:work-runtime](https://developer.android.com/reference/androidx/work/package-summary), to enqueue jobs\n* [androidx.concurrent:concurrent-futures](https://developer.android.com/reference/androidx/concurrent/futures/package-summary), to return job results from a background worker ## Example Background sync requires two things: * synchronization logic\n* a scheduled job that periodically performs that logic. ### Synchronization Logic First, write the custom logic that synchronizes your realm. Treat this logic as a standalone connection to your backend. As a result, you'll need to: * initialize the Realm SDK\n* authenticate a user to open the realm You can use a user's cached credentials if the user recently used the app. Open the realm, then use [SyncSession.downloadAllServerChanges()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FdownloadAllServerChanges)and [SyncSession.uploadAllLocalChanges()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/mongodb/sync/SyncSession/#std-label-io%5Frealm%5Fmongodb%5Fsync%5FSyncSession%5FuploadAllLocalChanges)to synchronize the realm fully with the backend. You can execute this logic as a background process using a subclass of[ListenableWorker](https://developer.android.com/reference/androidx/work/ListenableWorker.html). Put your synchronization logic in the `startWork()` method of your worker: ### Worker To create a worker that periodically performs background sync: 1. Create a set of constraints that specify the conditions required for your worker.\n2. Specify how frequently your worker should execute.\n3. Enqueue your worker with the Android OS. Assign it a unique identifier so that you can update the job in the future. You can create the background sync job inside an Application subclass in your app to guarantee that the logic only executes once every time your application runs. Since synchronizing a realm uses data, you should consider only downloading changes in the background when the device is _not_: * low on battery\n* using a metered data source Use [Constraints](https://developer.android.com/reference/androidx/work/Constraints.Builder)to describe the environment where your background sync runs. Your repeat interval depends on how frequently data updates in the realm and how often users open your application. If the realm frequently updates throughout the day, consider setting a repeat interval of 1-3 hours. If the realm only updates a small number of times each day, it's best to set a higher repeat interval and only background sync once or twice a day. [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RealmObservableFactory/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Class RealmObservableFactory On this page * [io.realm.rx](#io.realm.rx)\n* [Constructors](#constructors)\n* [Method Summary](#method-summary)\n* [Inherited Methods](#inherited-methods)\n* [Constructor Detail](#constructor-detail)\n* [Method Detail](#method-detail)\n* [changesetsFrom](#changesetsfrom)\n* [equals](#equals)\n* [from](#from)\n* [hashCode](#hashcode) ## io.realm.rx [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) io.realm.rx.RealmObservableFactory **Implemented interfaces:** * [io.realm.rx.RxObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/#std-label-io%5Frealm%5Frx%5FRxObservableFactory) Factory class for creating Observables for RxJava (<=2.0.\\*). ## Tip ### See also:  * [Realm.asFlowable() ()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm%5FasFlowable%5F%5F)\n* [RealmObject.asFlowable()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject%5FasFlowable%5F%5F)\n* [RealmResults.asFlowable()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults%5FasFlowable%5F%5F)\n* [DynamicRealm.asFlowable()](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm%5FasFlowable%5F%5F)\n* **DynamicRealmObject.asFlowable()** ## Constructors | Constructor and Description                                                                                                                                                      |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [RealmObservableFactory](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory-1) (**boolean** emitFrozenObjects)Constructs the factory for creating Realm observables for RxJava. | ## Method Summary\n\n ## Inherited Methods * Methods inherited from class [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) : `getClass` , `hashCode` , `equals` , `clone` , `toString` , `notify` , `notifyAll` , `wait` , `wait` , `wait` , `finalize` ## Constructor Detail | public [RealmObservableFactory](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory-1) (**boolean** emitFrozenObjects)                                                                                            |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Constructs the factory for creating Realm observables for RxJava.**Parameters**emitFrozenObjects \\- true if all objects should be frozen before being returned to the user. false if they should be live objects. | ## Method Detail ### changesetsFrom | public **<any>** [changesetsFrom](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5FchangesetsFrom) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,[DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) object)                                                                                                                                                                                                                                             |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates an Observable for a [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . It should emit the initial object when subscribed to and on each subsequent update of the object it should emit the object + the [io.realm.ObjectChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ObjectChangeSet/#std-label-io%5Frealm%5FObjectChangeSet) that describes the update.Changeset observables do not support backpressure as a changeset depends on the state of the previous changeset. Handling backpressure should therefore be left to the user. |\n\n | public **<any>** [changesetsFrom](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5FchangesetsFrom) <**E** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,[io.realm.RealmList<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) list)                                                                                                                                                                                                                                                                                                                                             |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates an Observable for a [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) . It should emit the initial RealmList when subscribed to and on each subsequent update of the RealmList it should emit the RealmList + the [OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/#std-label-io%5Frealm%5FOrderedCollectionChangeSet) that describes the update.Changeset observables do not support backpressure as a changeset depends on the state of the previous changeset. Handling backpressure should therefor be left to users.**Returns**Rx observable that emit all updates + their changeset. |\n\n | public **<any>** [changesetsFrom](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5FchangesetsFrom) <**E** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,[io.realm.RealmResults<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) results)                                                                                                                                                                                                                                                                                                                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates an Observable for a [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) . It should emit the initial RealmResult when subscribed to and on each subsequent update of the RealmResults it should emit the RealmResults + the [OrderedCollectionChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/OrderedCollectionChangeSet/#std-label-io%5Frealm%5FOrderedCollectionChangeSet) that describes the update.Changeset observables do not support backpressure as a changeset depends on the state of the previous changeset. Handling backpressure should therefor be left to users.**Returns**Rx observable that emit all updates + their changeset. |\n\n ### equals | public **boolean** [equals](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5Fequals) ([Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) o) |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **Overrides**equals in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html)                                                                  | ### from | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5Ffrom) <**E** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,[io.realm.RealmQuery<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) query) |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a Single from a [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) . It should emit the query and then complete.A RealmQuery observable is cold.                                                                                                                      | | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5Ffrom) <**E** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,[io.realm.RealmQuery<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) query) |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a Single from a [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) . It should emit the query and then complete.A RealmQuery observable is cold.                                                                                                 |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5Ffrom) <**E** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,**E** object)                                                                                                                  |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a Flowable for a [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . It should emit the initial object when subscribed to and on each subsequent update of the object.RealmObject observables are hot as RealmObjects are automatically kept up to date. | | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5Ffrom) <**E** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,[io.realm.RealmList<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) list)                                                                                                                                                                    |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a Flowable for a [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) . It should emit the initial list when subscribed to and on each subsequent update of the RealmList.RealmList observables are hot as RealmLists are automatically kept up to date.Note: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) is currently not supported on RealmLists. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5Ffrom) <**E** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,[io.realm.RealmResults<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) results)                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a Flowable for a [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) . It should emit the initial RealmResult when subscribed to and on each subsequent update of the RealmResults.Realm observables are hot as RealmResults are automatically kept up to date.**Returns**Rx observable that emit all updates to the RealmResults. | | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5Ffrom) <**E** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,[io.realm.RealmResults<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) results)                                                                                      |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a Flowable for a [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) . It should emit the initial RealmResult when subscribed to and on each subsequent update of the RealmResults.RealmResults observables are hot as RealmResults are automatically kept up to date.**Returns**Rx observable that emit all updates to the RealmObject. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5Ffrom) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm)                                                                                                                                                                             |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates a Flowable for a [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) . It should emit the initial state of the Realm when subscribed to and on each subsequent update of the Realm.Realm flowables are hot as Realms are automatically kept up to date.**Returns**Rx observable that emit all updates to the Realm. | ### hashCode | public **int** [hashCode](#std-label-io%5Frealm%5Frx%5FRealmObservableFactory%5FhashCode) ()             |\n| -------------------------------------------------------------------------------------------------------- |\n| **Overrides**hashCode in class [Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html) | ← [Class ObjectChange](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/ObjectChange/ \"Previous Section\")[Interface RxObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RxObservableFactory/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Interface RxObservableFactory On this page * [io.realm.rx](#io.realm.rx)\n* [Method Summary](#method-summary)\n* [Method Detail](#method-detail)\n* [changesetsFrom](#changesetsfrom)\n* [from](#from) ## io.realm.rx Factory interface for creating Rx Observables for Realm classes. ## Method Summary\n\n ## Method Detail ### changesetsFrom | public **<any>** [changesetsFrom](#std-label-io%5Frealm%5Frx%5FRxObservableFactory%5FchangesetsFrom) ([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,[DynamicRealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealmObject/#std-label-io%5Frealm%5FDynamicRealmObject-1) object)                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates an Observable for a [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . It should emit the initial object when subscribed to and on each subsequent update of the object it should emit the object + the [io.realm.ObjectChangeSet](https://mongodb.com/docs/realm/sdk/java/api/io/realm/ObjectChangeSet/#std-label-io%5Frealm%5FObjectChangeSet) that describes the update.Changeset observables do not support backpressure as a changeset depends on the state of the previous changeset. Handling backpressure should therefore be left to the user.**Parameters**object \\- RealmObject to listen to changes for.realm \\- [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) instance object is coming from. |\n\n\n\n\n\n\n\n\n\n ### from | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRxObservableFactory%5Ffrom) <**E** \\>([DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) realm,[io.realm.RealmQuery<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) query)                                                                                      |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a Single from a [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) . It should emit the query and then complete.A RealmQuery observable is cold.**Parameters**query \\- RealmObject to listen to changes for.realm \\- [DynamicRealm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/DynamicRealm/#std-label-io%5Frealm%5FDynamicRealm) instance query is coming from. | | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRxObservableFactory%5Ffrom) <**E** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,[io.realm.RealmQuery<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) query)                                                                                                                |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a Single from a [RealmQuery](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmQuery/#std-label-io%5Frealm%5FRealmQuery) . It should emit the query and then complete.A RealmQuery observable is cold.**Type Parameters**E \\- type of query target**Parameters**query \\- RealmQuery to emit.realm \\- [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) instance query is coming from. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRxObservableFactory%5Ffrom) <**E** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,**E** object)                                                                                                                                                                                                                                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a Flowable for a [RealmObject](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmObject/#std-label-io%5Frealm%5FRealmObject-1) . It should emit the initial object when subscribed to and on each subsequent update of the object.RealmObject observables are hot as RealmObjects are automatically kept up to date.**Type Parameters**E \\- type of query target**Parameters**object \\- RealmObject to listen to changes for.realm \\- [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) instance object is coming from. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRxObservableFactory%5Ffrom) <**E** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,[io.realm.RealmList<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) list)                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Creates an Observable for a [RealmList](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmList/#std-label-io%5Frealm%5FRealmList-1) . It should emit the initial list when subscribed to and on each subsequent update of the RealmList.RealmList observables are hot as RealmLists are automatically kept up to date.Note: [io.realm.RealmChangeListener](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmChangeListener/#std-label-io%5Frealm%5FRealmChangeListener) is currently not supported on RealmLists.**Type Parameters**E \\- type of query target**Parameters**list \\- RealmObject to listen to changes for.realm \\- [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) instance list is coming from. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRxObservableFactory%5Ffrom) <**E** \\>([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm,[io.realm.RealmResults<E>](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) results)                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a Flowable for a [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) . It should emit the initial RealmResult when subscribed to and on each subsequent update of the RealmResults.RealmResults observables are hot as RealmResults are automatically kept up to date.**Type Parameters**E \\- type of RealmObject**Parameters**results \\- [RealmResults](https://mongodb.com/docs/realm/sdk/java/api/io/realm/RealmResults/#std-label-io%5Frealm%5FRealmResults) to listen to changes for.realm \\- [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) instance results are coming from.**Returns**Rx observable that emit all updates to the RealmObject. |\n\n | public **<any>** [from](#std-label-io%5Frealm%5Frx%5FRxObservableFactory%5Ffrom) ([Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) realm)                                                                                                                                                                                                                                                                                                               |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Creates a Flowable for a [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) . It should emit the initial state of the Realm when subscribed to and on each subsequent update of the Realm.Realm flowables are hot as Realms are automatically kept up to date.**Parameters**realm \\- [Realm](https://mongodb.com/docs/realm/sdk/java/api/io/realm/Realm/#std-label-io%5Frealm%5FRealm) to listen to changes for.**Returns**Rx observable that emit all updates to the Realm. | ← [Class RealmObservableFactory](https://mongodb.com/docs/realm/sdk/java/api/io/realm/rx/RealmObservableFactory/ \"Previous Section\")[Upgrade from Stitch to Realm - Java SDK](https://mongodb.com/docs/realm/sdk/java/migrate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/custom-user-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Custom User Data - Java SDK On this page * [Read a User's Custom Data](#read-a-user-s-custom-data)\n* [Create a User's Custom Data Document](#create-a-user-s-custom-data-document)\n* [Update a User's Custom Data](#update-a-user-s-custom-data) You can read arbitrary data about your application users, known as custom user data, directly within your java application. For example, you might store a user's preferred language, date of birth, or local timezone. To learn more about custom user data, see [Enable Custom User Data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ## Important To use custom user data, you must first [Enable Custom User Data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-enable-custom-user-data-procedure) ## Read a User's Custom Data You can read the custom user data of a currently logged in user through that user's `User` object. You cannot edit custom user data through a `User` object. To edit custom user data, see[Update Custom User Data](#std-label-java-update-custom-user-data). To access the data, call the[User.customData()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/User.html#getCustomData--)method on the `User` object of a logged in user: ## Warning ### Custom Data May Be Stale Atlas App Services does not dynamically update the value of[User.customData()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/User.html#getCustomData--)immediately when underlying data changes. Instead, App Services fetches the most recent version of custom user data whenever a user refreshes their [access token](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions), which occurs during most SDK operations that contact the App Services back end. Realm refreshes access tokens every 30 minutes, so custom user data can be stale for no more than 30 minutes. If you require the most recent version of custom user data, use the[User.refreshCustomData()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/User.html#refreshCustomData--) method to request the latest version of a user's custom data. ## Create a User's Custom Data Document ## Tip To create, update, or delete custom user data, you will need the following information from your custom user data configuration: * the custom user data cluster\n* the custom user data database\n* the custom user data collection in which custom user data documents are stored\n* the user ID field used to map custom user data documents to users (via user ID) You can find this information in the App Services UI on theApp Users page under the Custom User Data tab. To create custom user data for a user, create a MongoDB document in the custom user data collection. The user ID field of the document should contain the the user's user ID. The following example uses[MongoDB Data Access](https://mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/#std-label-java-mongodb-data-access) to insert a document containing the user ID of the currently logged in user and a`favoriteColor` value into the custom user data collection: You can add any number of arbitrary fields and values to the custom user data document when you create it. The user ID field is the only requirement for the document to become available on the `User` object as custom user data. ## Update a User's Custom Data\n\n To update a user's custom user data with MongoDB Data Access, edit the MongoDB document whose user ID field contains the user ID of the user. ## Tip To determine a user's ID, access the `User.id` property or find the user in the App Services UI on the App Users page under the Users tab. The following example uses [MongoDB Data Access](https://mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/#std-label-java-mongodb-data-access) to update the `favoriteColor` field of the the document containing the user ID of the currently logged in user in the custom user data collection: ← [Multi-User Applications - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/multi-user-applications/ \"Previous Section\")[Manual Client Reset Data Recovery - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/manual-client-reset-data-recovery/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/debugging/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Debugging - Java SDK On this page * [Android Studio Debugging](#android-studio-debugging)\n* [NDK Debugging](#ndk-debugging) ## Android Studio Debugging ## Important The Android Studio debugger can provide misleading values for Realm object fields. For correct values, you can watch accessor values instead, or use the Realm object`toString()` method to see the latest field values. This section details information you should keep in mind when debugging Realm applications with Android Studio to avoid incorrect value reporting. When you watch a Realm object, you'll see values displayed in the object's fields. These values are incorrect because the field values themselves are not used. This is because Realm creates a [proxy object](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-realm-proxy) behind the scenes, overriding the getters and setters to access the persisted data in the realm. To see the correct values, add a watch on the accessors. See the image below: ![When using the Android Studio debugger, accessors display the correct field value, while fields show outdated information.](https://mongodb.com/docs/realm/images/android-studio-debugging.png) In the image above, the debugger has stopped on line `113`. There are three watch values: * The `person` variable\n* The `person.getName()` accessor\n* The `person.getAge()` accessor The code from lines `107` to `111` alters the `person` instance by changing the name and age in a write transaction. On line `113`, the `person` watch instance reports incorrect values for the _field_ watch values. The watch values that use the _accessors_ report values that are correct. ## NDK Debugging The Realm Java SDK library contains native code. Debugging NDK crashes can be cumbersome, as the default stack trace provides minimal information. We recommend you use a crash reporting tool such as[Crashlytics](http://www.crashlytics.com/). This gives you the ability to track native errors and gather other valuable information. We can help with your issues faster if you have this information. To enable NDK crash reporting in Crashlytics for your project, add the following to the root of your application`build.gradle` file: `| crashlytics {  |\n| -------------- |\n| enableNdk true |\n| }              | ` ## Note The values `androidNdkOut` and `androidNdkLibsOut` are not needed. ← [Testing - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/testing/ \"Previous Section\")[Link User Identities - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/link-user-identities/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/threading/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Threading - Java SDK On this page * [Three Rules to Keep in Mind](#three-rules-to-keep-in-mind)\n* [Communication Across Threads](#communication-across-threads)\n* [Intents](#intents)\n* [Frozen Objects](#frozen-objects)\n* [Refreshing Realms](#refreshing-realms)\n* [Realm's Threading Model in Depth](#realm-s-threading-model-in-depth)\n* [Compared and Contrasted with Git](#compared-and-contrasted-with-git)\n* [Internal Structure](#internal-structure)\n* [Summary](#summary) To make your Android apps fast and responsive, you must balance the computing time needed to lay out the visuals and handle user interactions with the time needed to process your data and run your business logic. Typically, app developers spread this work across multiple threads: the main or UI thread for all of the user interface-related work, and one or more background threads to compute heavier workloads before sending it to the UI thread for presentation. By offloading heavy work to background threads, the UI thread can remain highly responsive regardless of the size of the workload. ## Three Rules to Keep in Mind Realm enables simple and safe multithreaded code when you follow these three rules: Avoid writes on the UI thread if you write on a background thread: You can [write](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/#std-label-java-realm-database-writes) to a realm from any thread, but there can be only one writer at a time. Consequently, write transactions block each other. A write on the UI thread may result in your app appearing unresponsive while it waits for a write on a background thread to complete. If you are using[Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), avoid writing on the UI thread as Sync writes on a background thread. Don't pass live objects, collections, or realms to other threads: Live objects, collections, and realm instances are**thread-confined**: that is, they are only valid on the thread on which they were created. Practically speaking, this means you cannot pass live instances to other threads. However, Realm Database offers several mechanisms for[sharing objects across threads.](#std-label-java-communication-across-threads) Don't lock to read: Realm Database's [Multiversion Concurrency Control (MVCC)](#std-label-java-mvcc) architecture eliminates the need to lock for read operations. The values you read will never be corrupted or in a partially-modified state. You can freely read from realms on any thread without the need for locks or mutexes. Unnecessarily locking would be a performance bottleneck since each thread might need to wait its turn before reading. ## Communication Across Threads Live objects, collections, and realms are **thread-confined**. If you need to work with the same data across multiple threads, you should open the same realm on multiple threads as separate realm instances. The Java SDK [consolidates underlying connections across threads where possible](https://mongodb.com/docs/realm/sdk/java/fundamentals/realms/#std-label-java-realm-lifecycle) to make this pattern more efficient. When you need to communicate across threads, you have several options depending on your use case:\n\n ### Intents [Managed](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/#std-label-java-managed-objects) `RealmObject` instances are not thread-safe or `Parcelable`, so you cannot pass them between activities or threads via an `Intent`. Instead, you can pass an object identifier, like a [primary key](https://mongodb.com/docs/realm/sdk/java/fundamentals/object-models-and-schemas/#std-label-java-primary-key-fundamentals), in the `Intent` extras bundle, and then open a new realm instance in the separate thread to query for that identifier. Alternatively, you can [freeze](#std-label-java-frozen-objects) Realm objects. ## Tip ### See also:  You can find working examples in the [Passing Objects](https://github.com/realm/realm-java/blob/master/examples/threadExample/src/main/java/io/realm/examples/threads/PassingObjectsFragment.java)portion of the [Java SDK Threading Example](https://github.com/realm/realm-java/tree/master/examples/threadExample). The example shows you how to pass IDs and retrieve a `RealmObject`in common Android use cases. ### Frozen Objects Live, thread-confined objects work fine in most cases. However, some apps -- those based on reactive, event stream-based architectures, for example -- need to send immutable copies across threads. In this case, you can **freeze** objects, collections, and realms. Freezing creates an immutable view of a specific object, collection, or realm that still exists on disk and does not need to be deeply copied when passed around to other threads. You can freely share a frozen object across threads without concern for thread issues. Frozen objects are not live and do not automatically update. They are effectively snapshots of the object state at the time of freezing. When you freeze a realm all child objects and collections also become frozen. You can't modify frozen objects, but you can read the primary key from a frozen object, query a live realm for the underlying object, and then update that live object instance. Frozen objects remain valid for as long as the realm that spawned them stays open. Avoid closing realms that contain frozen objects until all threads are done working with those frozen objects. ## Warning ### Frozen Object Exceptions When working with frozen objects, an attempt to do any of the following throws an exception: * Opening a write transaction on a frozen realm.\n* Modifying a frozen object.\n* Adding a change listener to a frozen realm, collection, or object. Once frozen, you cannot unfreeze an object. You can use `isFrozen()` to check if an object is frozen. This method is always thread-safe. To freeze an object, collection, or realm, use the[freeze()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmObject.html#freeze--) method: ## Important ### Frozen Objects and Realm Size Frozen objects preserve an entire copy of the realm that contains them at the moment they were frozen. As a result, freezing a large number of objects can cause a realm to consume more memory and storage than it might have without frozen objects. If you need to separately freeze a large number of objects for long periods of time, consider copying what you need out of the realm instead. ## Refreshing Realms When you open a realm, it reflects the most recent successful write commit and remains on that version until it is **refreshed**. This means that the realm will not see changes that happened on another thread until the next refresh. Realms on any event loop thread (including the UI thread) automatically refresh themselves at the beginning of that thread's loop. However, you must manually refresh realm instances that are tied to non-looping threads or that have auto-refresh disabled. To refresh a realm, call[Realm.refresh():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/Realm.html#refresh--) ## Tip ### Refresh on Write Realms also automatically refresh after completing a write transaction. ## Realm's Threading Model in Depth Realm Database provides safe, fast, lock-free, and concurrent access across threads with its [Multiversion Concurrency Control (MVCC)](https://en.wikipedia.org/wiki/Multiversion%5Fconcurrency%5Fcontrol)architecture. ### Compared and Contrasted with Git\n\n * Commits, which are atomic writes.\n* Branches, which are different versions of the commit history. Similarly, Realm Database has atomically-committed writes in the form of [transactions](https://mongodb.com/docs/realm/sdk/java/examples/read-and-write-data/#std-label-java-realm-database-writes). Realm Database also has many different versions of the history at any given time, like branches. Unlike Git, which actively supports distribution and divergence through forking, a realm only has one true latest version at any given time and always writes to the head of that latest version. Realm Database cannot write to a previous version. This makes sense: your data should converge on one latest version of the truth. ### Internal Structure A realm is implemented using a [B+ tree](https://en.wikipedia.org/wiki/B%2B%5Ftree) data structure. The top-level node represents a version of the realm; child nodes are objects in that version of the realm. The realm has a pointer to its latest version, much like how Git has a pointer to its HEAD commit. Realm Database uses a copy-on-write technique to ensure[isolation](https://en.wikipedia.org/wiki/Isolation%5F%28database%5Fsystems%29) and[durability](https://en.wikipedia.org/wiki/Durability%5F%28database%5Fsystems%29). When you make changes, Realm Database copies the relevant part of the tree for writing, then commits the changes in two phases: * Write changes to disk and verify success.\n* Set the latest version pointer to point to the newly-written version. This two-step commit process guarantees that even if the write failed partway, the original version is not corrupted in any way because the changes were made to a copy of the relevant part of the tree. Likewise, the realm's root pointer will point to the original version until the new version is guaranteed to be valid. ## Example The following diagram illustrates the commit process: ![Realm Database copies the relevant part of the tree for writes, then replaces the latest version by updating a pointer.](https://mongodb.com/docs/realm/images/mvcc-diagram.png) click to enlarge 1. The realm is structured as a tree. The realm has a pointer to its latest version, V1.\n2. When writing, Realm Database creates a new version V2 based on V1\\. Realm Database makes copies of objects for modification (A 1, C 1), while links to unmodified objects continue to point to the original versions (B, D).\n3. After validating the commit, Realm Database updates the realm's pointer to the new latest version, V2\\. Realm Database then discards old nodes no longer connected to the tree. Realm Database uses zero-copy\\` techniques like memory mapping to handle data. When you read a value from the realm, you are virtually looking at the value on the actual disk, not a copy of it. This is the basis for[live objects](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/#std-label-java-live-object). This is also why a realm head pointer can be set to point to the new version after the write to disk has been validated. ## Summary * Realm enables simple and safe multithreaded code when you follow three rules:  \n   * Avoid writes on the UI thread if you write on background threads or use [Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync)  \n   * Don't pass live objects to other threads.  \n   * Don't lock to read.\n* In order to see changes made on other threads in your realm instance, you must manually **refresh** realm instances that do not exist on \"loop\" threads or that have auto-refresh disabled.\n* For apps based on reactive, event-stream-based architectures, you can**freeze** objects, collections, and realms in order to pass copies around efficiently to different threads for processing.\n* Realm Database's multiversion concurrency control (MVCC) architecture is similar to Git's. Unlike Git, Realm Database has only one true latest version for each realm.\n* Realm Database commits in two stages to guarantee isolation and durability.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/encryption/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Encrypt a Realm - Java SDK On this page * [Overview](#overview)\n* [Considerations](#considerations)\n* [Storing & Reusing Keys](#storing---reusing-keys)\n* [Performance Impact](#performance-impact)\n* [Encryption and Atlas Device Sync](#encryption-and-atlas-device-sync)\n* [Accessing an Encrypted Realm from Multiple Processes](#accessing-an-encrypted-realm-from-multiple-processes)\n* [Example](#example)\n* [Generate and Store an Encryption Key](#generate-and-store-an-encryption-key)\n* [Access an Existing Encryption Key](#access-an-existing-encryption-key)\n* [Open an Encrypted Realm](#open-an-encrypted-realm) ## Overview You can encrypt your realms to ensure that the data stored to disk can't be read outside of your application. You encrypt the realm database file on disk with AES-256 + SHA-2 by supplying a 64-byte encryption key when [opening a realm.](https://mongodb.com/docs/realm/sdk/java/examples/open-and-close-a-realm/#std-label-java-open-a-local-realm) Realm transparently encrypts and decrypts data with standard[AES-256 encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) using the first 256 bits of the given 512-bit encryption key. Realm uses the other 256 bits of the 512-bit encryption key to validate integrity using a [hash-based message authentication code (HMAC).](https://en.wikipedia.org/wiki/HMAC) ## Warning Do not use cryptographically-weak hashes for realm encryption keys. For optimal security, we recommend generating random rather than derived encryption keys. ## Considerations The following are key impacts to consider when encrypting a realm. ### Storing & Reusing Keys You **must** pass the same encryption key to [RealmConfiguration.Builder.encryptionKey()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/RealmConfiguration.Builder.html#encryptionKey-byte:A-) each time you open the realm. If you don't provide a key or specify the wrong key for an encrypted realm, the Realm SDK throws an error. Apps should store the encryption key in the[Android KeyStore](https://developer.android.com/training/articles/keystore.html) so that other apps cannot read the key. ### Performance Impact Reads and writes on encrypted realms can be up to 10% slower than unencrypted realms. ### Encryption and Atlas Device Sync You can encrypt a [synced realm.](https://mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/#std-label-java-sync-data) Realm only encrypts the data on the device and stores the data unencrypted in your Atlas data source. Any users with authorized access to the Atlas data source can read the data, but the following still applies: * Users must have the correct read [permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read the synced data.\n* Data stored in Atlas is always encrypted at a volume (disk) level.\n* The transfer between client and server is always fully encrypted. You can also enable [Customer Key Management](https://www.mongodb.com/docs/atlas/security-kms-encryption/)to encrypt stored Atlas data using your cloud provider's key (e.g. AWS KMS, Azure Key Vault, Google Cloud KMS).\n\n ### Accessing an Encrypted Realm from Multiple Processes You cannot open the same encrypted realm from multiple processes. Attempting to do so will throw the following error:`Encrypted interprocess sharing is currently unsupported.` If multiple processes need to access a realm simultaneously, use an unencrypted realm. ## Example The following steps describe the recommended way to use the[Android KeyStore](https://developer.android.com/training/articles/keystore.html) for encryption with Realm: 1. Generate an asymmetric RSA key that Android can securely store and retrieve using the Android KeyStore.  \n## Note  \n### Android Version M and Above: Keystore Security  \nVersions M and above require user PIN or fingerprint to unlock the KeyStore.\n2. Generate a symmetric key (AES) you can use to encrypt the realm.\n3. Encrypt the symmetric AES key using your private RSA key.\n4. Store the encrypted AES key on filesystem (in a`SharedPreferences`, for example). When you need to use your encrypted realm: 1. Retrieve your encrypted AES key.\n2. Decrypt your encrypted AES key using the public RSA key.\n3. Use the decrypted AES key in the `RealmConfiguration` to open the encrypted realm. ## Tip ### See also:  For an end-to-end example of storing and reusing encryption keys, see the [store\\_password](https://github.com/realm/realm-java/tree/feature/example/store%5Fpassword/examples/StoreEncryptionPassword) example project, which demonstrates the fingerprint API. ### Generate and Store an Encryption Key The following code demonstrates how to securely generate and store an encryption key for a realm: ### Access an Existing Encryption Key The following code demonstrates how to access and decrypt a securely stored encryption key for a realm: ### Open an Encrypted Realm The following code demonstrates how to open an encrypted realm with the [encryptionKey()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncConfiguration.Builder.html#encryptionKey-byte:A-)method: ← [Advanced Guides - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/ \"Previous Section\")[Threading - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/threading/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/testing/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Testing - Java SDK On this page * [Integration Tests](#integration-tests)\n* [Application Context](#application-context)\n* [Looper Thread](#looper-thread)\n* [Delay Test Execution While Async Calls Complete](#delay-test-execution-while-async-calls-complete)\n* [Testing Backend](#testing-backend)\n* [Testing Atlas Cluster](#testing-atlas-cluster)\n* [Full Example](#full-example)\n* [Unit Tests](#unit-tests)\n* [Full Example](#full-example-1) You can test your application using unit tests or integration tests.**Unit tests** only assess the logic written in your application's code.**Integration tests** assess your application logic, database queries and writes, and calls to your application's backend, if you have one. Unit tests run on your development machine using the JVM, while integration tests run on a physical or emulated Android device. You can run integration tests by communicating with actual instances of Realm Database or an App backend using Android's built-in instrumented tests. Android uses specific file paths and folder names in Android projects for unit tests and instrumented tests: | Test Type          | Path                 |\n| ------------------ | -------------------- |\n| Unit Tests         | /app/src/test        |\n| Instrumented Tests | /app/src/androidTest | Because the SDK uses C++ code via Android Native for data storage, unit testing requires you to entirely mock interactions with Realm Database. Prefer integration tests for logic that requires extensive interaction with the database. ## Integration Tests This section shows how to integration test an application that uses the Realm SDK. It covers the following concepts in the test environment: * acquiring an application context\n* executing logic on a `Looper` thread\n* how to delay test execution while asynchronous method calls complete Applications that use Sync or a backend App also require (not covered here): * a separate App backend for testing, with separate user accounts and data\n* a separate Atlas cluster containing test-only data ### Application Context To initialize the SDK, you'll need to provide an application or activity[context](https://developer.android.com/reference/android/content/Context). This isn't available by default in Android integration tests. However, you can use Android's built-in testing [ActivityScenario](https://developer.android.com/reference/androidx/test/core/app/ActivityScenario)class to start an activity in your tests. You can use any activity from your application, or you can create an empty activity just for testing. Call `ActivityScenario.launch()` with your activity class as a parameter to start the simulated activity. Next, use the `ActivityScenario.onActivity()` method to run a lambda on the simulated activity's main thread. In this lambda, you should call the `Realm.init()` function to initialize the SDK with your activity as a parameter. Additionally, you should save the parameter passed to your lambda (the newly created instance of your activity) for future use. Because the `onActivity()` method runs on a different thread, you should [block your test from executing further](#std-label-java-testing-delay-while-async) until this initial setup completes. The following example uses an `ActivityScenario`, an empty testing activity, and a `CountDownLatch` to demonstrate how to set up an environment where you can test your Realm application: ### Looper Thread Realm Database functionality such as[Live objects](https://mongodb.com/docs/realm/sdk/java/fundamentals/live-queries/#std-label-java-live-object) and change notifications only work on [Looper](https://developer.android.com/reference/android/os/Looper) threads. Threads configured with a `Looper` object pass events over a message loop coordinated by the `Looper`. Test functions normally don't have a `Looper` object, and configuring one to work in your tests can be very error-prone.\n\n ### Delay Test Execution While Async Calls Complete Because the SDK uses asynchronous calls for common operations such as database queries, authentication, and function calls, tests need a way to wait for those async calls to complete. Otherwise, your tests will exit before your asynchronous (or multi-threaded) calls run. This example uses Java's built-in [CountDownLatch](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/CountDownLatch.html). Follow these steps to use a `CountDownLatch` in your own tests: 1. Instantiate a `CountDownLatch` with a count of 1.\n2. After running the async logic your test needs to wait for, call that`CountDownLatch` instance's `countDown()` method.\n3. When you need to wait for async logic, add a `try`/`catch` block that handles an `InterruptedException`. In that block, call that `CountDownLatch` instance's `await()` method.\n4. Pass a timeout interval and unit to `await()`, and wrap the call in a `Assert.assertTrue()` assertion. If the logic takes too long, the `await()` call times out, returning false and failing the test. The following example demonstrates the use of a `CountDownLatch` to wait for authentication and opening a realm asynchronously on a separate thread: ### Testing Backend Applications that use an App backend should not connect to the production backend for testing purposes for the following reasons: * you should always keep test users and production users separate for security and privacy reasons\n* tests often require a clean initial state, so there's a good chance your tests will include a setup or teardown method that deletes all users or large chunks of data You can use [environments](https://www.mongodb.com/docs/atlas/app-services/reference/config/environments/#std-label-appconfig-environment) to manage separate apps for testing and production. ### Testing Atlas Cluster Applications that use Sync or [MongoDB queries](https://mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/#std-label-java-mongodb-data-access) may read, write, update, or delete data stored in connected Atlas clusters. For security purposes, you shouldn't store production data and testing data on the same cluster. Additionally, tests may require schema changes before those changes are gracefully handled in your production application. As a result, you should use a separate Atlas cluster when testing your application. ### Full Example The following example shows a full Junit instrumented `androidTest`example running Realm Database in integration tests: ## Tip ### See also:  See the [Realm Documentation Examples App](https://github.com/mongodb/docs-realm/tree/master/examples/java) for an example of integration testing the SDK locally and with a live backend. ## Unit Tests To unit test Realm applications that use Realm, you must [mock](https://en.wikipedia.org/wiki/Mock%5Fobject) Realm Database (and your application backend, if you use one). Use the following libraries to mock SDK functionality: * [Robolectric](http://robolectric.org/)\n* [PowerMock](https://powermock.github.io/)\n* [Mockito](https://site.mockito.org/) To make these libraries available for unit testing in your Android project, add the following to the `dependencies` block of your application`build.gradle` file:\n\n ` ## Note ### Version Compatibility Mocking the SDK in unit tests requires Robolectric, Mockito, and Powermock because the SDK uses Android Native C++ method calls to interact with Realm Database. Because the frameworks required to override these method calls can be delicate, you should use the versions listed above to ensure that your mocking is successful. Some recent version updates (particularly Robolectric version 4.2+) can break compiliation of unit tests using the SDK. To configure your unit tests to use Robolectric, PowerMock, and Mockito with the SDK, add the following annotations to each unit test class that mocks the SDK: Then, bootstrap Powermock globally in the test class: Next, mock the components of the SDK that might query native C++ code so we don't hit the limitations of the test environment: Once you've completed the setup required for mocking, you can start mocking components and wiring up behavior for your tests. You can also configure PowerMockito to return specific objects when new objects of a type are instantiated, so even code that references the default realm in your application won't break your tests: After mocking a realm, you'll have to configure data for your test cases. See the full example below for some examples of how you can provide testing data in unit tests. ### Full Example The following example shows a full JUnit `test`example mocking Realm Database in unit tests. This example tests an activity that performs some basic Realm Database operations. The tests use mocking to simulate those operations when that activity is started during a unit test: ## Tip ### See also:  See the [Unit Testing Example App](https://github.com/realm/realm-java/tree/master/examples/unitTestExample)for an example of unit testing an application that uses Realm. ← [Threading - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/threading/ \"Previous Section\")[Debugging - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/debugging/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/link-user-identities/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Link User Identities - Java SDK On this page * [Example](#example) Realm provides [many authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)to log users into your app. Each provider creates a unique user identity. Realm lets you merge multiple credentials into one user identity. Credentials must be linked prior to logging a user in. Once credentials are used to login a user, you cannot link that credential anymore. Also, you cannot link multiple email/password credentials together. ## Example Consider an application that offers [anonymous login](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication), which allows users to explore the app without registering. If a user wants to continue using the application, they can create a permanent account by using another authentication provider. Realm creates a new `User` object. The app can then link the new identity with the current user. ## Note Depending on how you have configured email/password authentication, there may be additional steps (confirming the email address, for example) before the new account is created and can be linked. You link identities using[linkCredentials()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/User.html#linkCredentials-io.realm.mongodb.Credentials-)or [linkCredentialsAsync()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/User.html#linkCredentialsAsync-io.realm.mongodb.Credentials-io.realm.mongodb.App.Callback-). This links the new user identity to the logged-in [User](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/User.html) object. ← [Debugging - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/debugging/ \"Previous Section\")[Multi-User Applications - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/multi-user-applications/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Users - React Native SDK ← [Query MongoDB - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/query-mongodb/ \"Previous Section\")[Create and Delete Users - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/create-and-delete-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - React Native SDK ← [Use Realm React](https://mongodb.com/docs/realm/sdk/react-native/use-realm-react/ \"Previous Section\")[Realm Database - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/manual-client-reset-data-recovery/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manual Client Reset Data Recovery - Java SDK On this page * [Example](#example)\n* [Track Updates to Objects](#track-updates-to-objects)\n* [Track Successful Syncs](#track-successful-syncs)\n* [Manual Recovery with Last Updated Time and Last Synced Time](#manual-recovery-with-last-updated-time-and-last-synced-time)\n* [Alternative Implementations](#alternative-implementations) ## Important ### Manual Recovery is Manual Manual recovery requires significant amounts of code, schema concessions, and custom conflict resolution logic. If your application can accommodate losing unsynced data during a client reset, try the[discard unsynced changes](https://mongodb.com/docs/realm/sdk/java/examples/reset-a-client-realm/#std-label-java-discard-unsynced-changes)client reset strategy instead. ## Warning ### Avoid Making Breaking Schema Changes in Production Do not expect to recover all unsynced data after a breaking schema change. The best way to preserve user data is to never make a breaking - also called destructive - schema change at all. ## Important ### Breaking Schema Changes Require an App Schema Update After a breaking schema change: * All clients must perform a client reset.\n* You must update client models affected by the breaking schema change. The **manually recover unsynced changes** client reset strategy gives developers the opportunity to recover data already written to the client realm file but not yet synced to the backend. The following steps demonstrate the process at a high level:\n\n To handle client resets with the \"manually recover unsynced changes\" strategy, pass an instance of [ManuallyRecoverUnsyncedChangesStrategy](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/ManuallyRecoverUnsyncedChangesStrategy.html) to the [defaultSyncClientResetStrategy()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/AppConfiguration.Builder.html#defaultSyncClientResetStrategy%28io.realm.mongodb.sync.DiscardUnsyncedChangesStrategy%29)builder method when you instantiate your `App`. Your`ManuallyRecoverUnsyncedChangesStrategy` instance must implement the following methods: * `onClientReset()`: called when the SDK receives a client reset error from the backend. The following example implements this strategy: ## Note ### handleManualReset() Implementation This client reset example calls a separate method that handles the specific logic of the client reset. Continue reading the sections below for an [example implementation.](#std-label-java-manual-recovery-implementation) The specifics of manual recovery depend heavily upon your application and your schema. However, there are a few techniques that can help with most manual recoveries. The following example implementation demonstrates one method of recovering unsynced changes from a backup realm. ## Example This example adds a \"Last Updated Time\" to each object model to track when each object last changed. We'll watch the realm for the \"Last Synced Time\" to determine when the realm last uploaded its state to the backend. Then, we can find objects that were deleted, created, or updated since the last sync with the backend, and copy that data from the backup realm to the new realm. ### Track Updates to Objects Ordinarily, there is no way to detect when a Realm object was last modified. This makes it difficult to determine which changes were synced to the backend. By adding a timestamp to your Realm object classes and updating that timestamp to the current time whenever a change occurs, you can keep track of when objects were changed: ### Track Successful Syncs Just knowing when objects were changed isn't enough to recover data during a client reset. You also need to know when the realm last completed a sync successfully. This example implementation uses a singleton object called `LastSynced` in the realm, paired with an upload progress listener, to record whenever a realm finishes syncing successfully. You can use [SyncSession.addUploadProgressListener()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/SyncSession.html#addUploadProgressListener%28io.realm.mongodb.sync.ProgressMode,io.realm.mongodb.sync.ProgressListener%29)to listen for upload progress events in your `App`. Implement`onChange()` to handle these events. Call[Progress.isTransferComplete()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/Progress.html#isTransferComplete%28%29) to check if the upload has completed. When `isTransferComplete()` returns true, all clientside updates, inserts, and deletes in the realm have successfully synced to the backend, and you can update the `LastSynced` time to the current time. To prevent`LastSynced` from looping on updates to the `LastSynced` time, don't update the `LastSynced` time if it's been less than, say, 10ms since you last updated the time. Register your progress listener with [ProgressMode.INDEFINITELY](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/sync/ProgressMode.html#INDEFINITELY) to subscribe your listener to all future upload progress events, instead of just the current upload's progress events. ### Manual Recovery with Last Updated Time and Last Synced Time Now that you've recorded update times for all objects in your application as well as the last time your application completed a sync, it's time to implement the manual recovery process. This example handles two main recovery operations: * restoring unsynced inserts and updates from the backup realm\n* deleting objects from the new realm that were previously deleted from the backup realm You can follow along with the implementation of these operations in the code samples below. ## Note\n\n This example keeps track of the last time each _object_ was updated. As a result, the recovery operation overwrites the entire object in the new realm if any field was updated after the last successful sync of the backup realm. This could overwrite fields updated by other clients with old data from this client. If your realm objects contain multiple fields containing important data, consider keeping track of the last updated time of each _field_ instead, and recovering each field individually. ## Alternative Implementations Other possible implementations include: * **Overwrite the entire backend with the backup state**: with no \"last updated time\" or \"last synced time\", `insertOrUpdate()`all objects from the backup realm into the new realm. There is no way to recovered unsynced deletions with this approach. This approach overwrites all data written to the backend by other clients since the last sync. Recommended for applications where only one user writes to each realm.\n* **Track changes by field**: Instead of tracking a \"last updated time\" for every _object_, track the \"last updated time\" for every _field_. Update fields individually using this logic to avoid overwriting field writes from other clients with old data. Recommended for applications with many fields per-object where conflicts must be resolved at the field level.\n* **Track updates separately from objects**: Instead of tracking a \"last updated time\" in the schema of each object, create another model in your schema called `Updates`. Every time any field in any object (besides `Updates`) updates, record the primary key, field, and time of the update. During a client reset, \"re-write\" all of the `Update` events that occurred after the \"last synced time\" using the latest value of that field in the backup realm. This approach should replicate all unsynced local changes in the new realm without overwriting any fields with stale data. However, storing the collection of updates could become expensive if your application writes frequently. Recommended for applications where adding \"lastUpdated\" fields to object models is undesirable. ← [Custom User Data - Java SDK](https://mongodb.com/docs/realm/sdk/java/advanced-guides/custom-user-data/ \"Previous Section\")[Troubleshooting - Java SDK](https://mongodb.com/docs/realm/sdk/java/troubleshooting/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - React Native SDK MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Build using Mac Catalyst](https://mongodb.com/docs/realm/sdk/react-native/integrations/mac-catalyst/ \"Previous Section\")[Upgrade from Stitch to Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/migrate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Data Between Devices - React Native SDK ← [Create & Manage User API Keys - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/manage-user-api-keys/ \"Previous Section\")[Atlas Device Sync Overview - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/java/advanced-guides/multi-user-applications/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Multi-User Applications - Java SDK On this page * [User Account States](#user-account-states)\n* [Add a New User to the Device](#add-a-new-user-to-the-device)\n* [List All Users on the Device](#list-all-users-on-the-device)\n* [Remove a User from the Device](#remove-a-user-from-the-device)\n* [Change the Active User](#change-the-active-user) The Realm SDK allows multiple [users](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) to be logged in to an app simultaneously on a given device. Realm client applications run in the context of a single active user even if multiple users are logged in simultaneously. You can quickly switch between authenticated users without requiring them to log in again. ## Warning **Any logged in user may become the active user without re-authenticating.**Depending on your app, this may be a security vulnerability. For example, a user on a shared device may switch to a coworker's logged in account without providing their credentials or requiring their explicit permission. If your application requires stricter authentication, avoid switching between users and prefer to explicitly log the active user out before authenticating another user. ## User Account States When a user first logs in through a Realm SDK on a given device or browser, the SDK saves the user's information and keeps track of the user's state on the device. The user's data remains on the device, even if they log out, unless you actively [remove the user.](#std-label-java-remove-a-user-from-the-device) The following states describe an on-device user at any given time: * **Authenticated:** any user that has logged in on the device and has not logged out or had its session revoked.  \n   * **Active**: a single authenticated user that is currently using the app on a given device. The SDK associates this user with outgoing requests and Atlas App Services evaluates data access permissions and runs functions in this user's context. See [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) for more information.  \n   * **Inactive**: all authenticated users that are not the current active user. You can [switch the active user](#std-label-java-change-the-active-user) to a currently inactive user at any time.\n* **Logged Out:** any user that authenticated on the device but has since logged out or had its session revoked. The following diagram shows how users within a Realm client app transition between states when certain events occur: ![A diagram the outlines the different states a user can be in: logged out, logged in and active, & logged in and inactive.](https://mongodb.com/docs/realm/images/multi-user.png) ### Add a New User to the Device The Realm SDK automatically adds users to a device when they log in for the first time on that device. When a user logs in, they immediately become the application's [active user.](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) ### List All Users on the Device You can access a list of all [user accounts](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) that are stored on the device. This list includes all users that have logged in to the client app on a given device regardless of whether they are currently authenticated. ### Remove a User from the Device To remove all information about a user from a device, use [user.remove()](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/User.html#remove--)or [user.removeAsync():](https://www.mongodb.com/docs/realm-sdks/java/latest/io/realm/mongodb/User.html#removeAsync-io.realm.mongodb.App.Callback-) ### Change the Active User You can quickly switch an app's [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) to another logged in user at any time.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/react-native/app-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # App Services - React Native SDK ← [Bundle a Realm File - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/bundle/ \"Previous Section\")[App Services Overview - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/migrate/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Upgrade from Stitch to Realm - React Native SDK On this page * [Overview](#overview)\n* [New Features](#new-features)\n* [Changes](#changes) ## Overview If you have an existing app built with the Stitch SDK, you should migrate your app to use the new Realm SDK. While much of the application logic and flow of information hasn't changed, there are a few changes to how it connects to the Atlas App Services backend. ## Note This page presents how to migrate from the MongoDB Stitch React Native SDK to the Realm JS SDK, to build React Native applications. If you are looking to use the Realm JS SDK to build Node.js applications, check out the [Upgrade from Stitch to Realm Node.js](https://mongodb.com/docs/realm/sdk/node/migrate/#std-label-node-migrating-from-stitch-to-realm) page. If you are looking to build web apps, consider our [Upgrade from Stitch to Realm Web](https://mongodb.com/docs/realm/web/migrate/#std-label-web-migrating-from-stitch-to-realm) page. ## New Features * The Realm JS SDK now includes Realm Database, which includes local object storage and the ability to synchronize document changes across devices over the internet. ## Changes\n\n ← [Telemetry - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/telemetry/ \"Previous Section\")[Realm Swift SDK](https://mongodb.com/docs/realm/sdk/swift/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/integrations/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Integrations - React Native SDK * [Build using Mac Catalyst](https://mongodb.com/docs/realm/sdk/react-native/integrations/mac-catalyst/) ← [Debugging with Flipper - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/test-and-debug/debugging-with-flipper/ \"Previous Section\")[Build using Mac Catalyst](https://mongodb.com/docs/realm/sdk/react-native/integrations/mac-catalyst/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm for React Native On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Installation](#installation)\n* [Create a React Native Project](#create-a-react-native-project)\n* [Install Realm with npm](#install-realm-with-npm)\n* [Enable Hermes (optional)](#enable-hermes--optional-)\n* [Resolve CocoaPods Dependencies](#resolve-cocoapods-dependencies)\n* [Enable TypeScript (optional)](#enable-typescript--optional-)\n* [Install the Realm React Library](#install-the-realm-react-library)\n* [Run the App](#run-the-app)\n* [Create a React Native Project](#create-a-react-native-project-1)\n* [Install Realm Using NPM](#install-realm-using-npm)\n* [Link the Realm Native Module](#link-the-realm-native-module)\n* [Confirm the Link Step (Android)](#confirm-the-link-step--android-)\n* [Enable TypeScript (optional)](#enable-typescript--optional--1)\n* [Run the App](#run-the-app-1)\n* [Import Realm](#import-realm) ## Overview The Realm React Native SDK enables development of [React Native](https://facebook.github.io/react-native/)applications using the JavaScript and [TypeScript](https://www.typescriptlang.org/) languages. React Native enables you to build cross-platform iOS and Android apps with a single codebase using the [React](https://reactjs.org/) framework. ## Prerequisites Before getting started, ensure your development environment meets the following prerequisites: * Follow the [official React Native CLI Quickstart instructions](https://reactnative.dev/docs/environment-setup) to set up your environment.\n* React Native v0.64.0 or later. Please consult the [compatibility chart](https://github.com/realm/realm-js/blob/master/COMPATIBILITY.md) to determine which version of Realm is compatible. ## Important ### Using Realm with Expo [Expo](https://docs.expo.dev/) now supports Realm with the Expo SDK version 44\\. To use Realm with Expo, upgrade to [Expo SDK version 44](https://docs.expo.dev/workflow/upgrading-expo-sdk-walkthrough/). Consult the [compatibility chart](https://github.com/realm/realm-js/blob/master/COMPATIBILITY.md) to determine which version of the Expo SDK is compatible Realm. ## Note ### Realm JS version 10.6.0 Supports Mac Catalyst For [React Native version 0.64 and below](https://reactnative.dev/versions), building your Realm React Native application requires additional steps in order to [build your application when using Mac Catalyst.](https://mongodb.com/docs/realm/sdk/react-native/integrations/mac-catalyst/) ## Installation Select the tab below that corresponds to your React Native version. Follow the steps to create a React Native project and add the Realm React Native SDK to it. ## Import Realm Add the following line to the top of your source files where you want to use Realm: `| import Realm from \"realm\"; |\n| -------------------------- | ` ← [Realm React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/ \"Previous Section\")[Quick Start - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/quick-start/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/bootstrap-with-expo/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Bootstrap with Expo - React Native SDK On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Setup](#setup)\n* [Initialize the Template](#initialize-the-template)\n* [Explore The File Structure](#explore-the-file-structure)\n* [Build and Run the Application](#build-and-run-the-application)\n* [Deploying Your Application](#deploying-your-application) ## Overview The [Realm Expo template](https://www.npmjs.com/package/@realm/expo-template-ts)provides a fully working React Native application that you can use to bootstrap your app development project with Realm. This documentation covers how to initialize and work with the Realm Expo template. The Realm Expo template uses: * [Expo](https://docs.expo.dev/), a framework to develop, build and deploy React Native applications quickly.\n* [Realm React](https://www.npmjs.com/package/@realm/react), an NPM package that provides an easy-to-use API to perform common Realm operations, such as querying or writing to a realm and listening to realm objects. ## Prerequisites * [Node.js version 12 LTS or greater](https://nodejs.org/en/about/releases/) ## Setup Next, before you initialize the template, you must install the [expo cli](https://docs.expo.dev/workflow/expo-cli/) by running the following command: `| npm install -g expo-cli |\n| ----------------------- | ` ## Initialize the Template To initialize a React Native application using the Realm Expo template use the Expo CLI. ## Explore The File Structure The relevant files are as follows:\n\n ## Build and Run the Application To run your application on an [Android emulator](https://developer.android.com/studio/run/emulator), run the following command from your application root: ```shell expo run:android \n``` To run your application on an [iOS simulator](https://developer.apple.com/documentation/xcode/running-your-app-in-the-simulator-or-on-a-device), run the following command from your application root: ```shell expo run:ios \n``` When the application builds, you will see something similar to the following image: ![Realm Expo Template on an iOS Simulator](https://mongodb.com/docs/realm/images/realm-expo-template.png) When you run the commands above, the Expo [dev-client](https://docs.expo.dev/development/getting-started/) will start automatically. If you close your Expo `dev-client` and want to restart it without waiting for the native build process again, you can simply run: ```shell expo start --dev-client \n``` However, if you made any [changes to the native code](https://docs.expo.dev/workflow/customizing/), you will have to re-run `expo run:ios` or `expo run:android` to rebuild your native iOS/Android app. ## Deploying Your Application To deploy your application, we recommend using the [Expo Application Services (EAS)](https://docs.expo.dev/eas/), a suite of deeply integrated cloud services for Expo and React Native apps. EAS allows you to compile and [sign](https://en.wikipedia.org/wiki/Code%5Fsigning) your App, upload your app to the Apple App Store or Google Play Store with a single CLI command, and push bug fixes or small changes directly to app users. Alternatively, read the [Expo Distribution Overview](https://docs.expo.dev/distribution/introduction/) guide to learn how to create native builds, deploy to app stores, avoid common app store rejections, and manage different release environments. ← [Quick Start - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/quick-start/ \"Previous Section\")[Use Realm React](https://mongodb.com/docs/realm/sdk/react-native/use-realm-react/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/test-and-debug/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Testing - React Native SDK On this page * [Overview](#overview)\n* [Clean Up Tests](#clean-up-tests) ## Overview You can test the Realm React Native SDK with popular React Native testing libraries like [Jest](https://jestjs.io/), [Jasmine](https://jasmine.github.io/), and [Mocha.](https://mochajs.org/) ## Tip ### See also:  [Official React Native Testing Documentation](https://reactnative.dev/docs/testing-overview) ### Clean Up Tests When testing the Realm React Native SDK, you must close realms with[Realm.close()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#close) after you're done with them to prevent memory leaks. You should also delete the realm file with [Realm.deleteFile()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.deleteFile)during clean up to keep your tests idempotent. The below example uses the Jest testing framework. It uses Jest's built-in `beforeEach()`and `afterEach()` hooks for test set up and tear down, respectively. `| const config = {                    |\n| ----------------------------------- |\n| schema: [Car],                      |\n| };                                  |\n| let realm;                          |\n| beforeEach(async () => {            |\n| realm = await Realm.open(config);   |\n| });                                 |\n| afterEach(() => {                   |\n| if (!realm.isClosed) {              |\n| realm.close();                      |\n| }                                   |\n| if (config) {                       |\n| Realm.deleteFile(config);           |\n| }                                   |\n| });                                 |\n| test(\"Close a Realm\", async () => { |\n| expect(realm.isClosed).toBe(false); |\n| realm.close();                      |\n| expect(realm.isClosed).toBe(true);  |\n| });                                 | ` ← [Test & Debug - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/test-and-debug/ \"Previous Section\")[Debugging with Flipper - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/test-and-debug/debugging-with-flipper/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - React Native SDK On this page * [Overview](#overview)\n* [Import Realm](#import-realm)\n* [Define Your Object Model](#define-your-object-model)\n* [Open a Realm](#open-a-realm)\n* [Create Realm Objects](#create-realm-objects)\n* [Find, Sort, and Filter Objects](#find--sort--and-filter-objects)\n* [Modify an Object](#modify-an-object)\n* [Delete an Object](#delete-an-object)\n* [Watch a Collection](#watch-a-collection)\n* [Close a Realm](#close-a-realm)\n* [Add Device Sync (Optional)](#add-device-sync--optional-)\n* [Prerequisites](#prerequisites)\n* [Initialize the App](#initialize-the-app)\n* [Authenticate a User](#authenticate-a-user)\n* [Define an Object Model](#define-an-object-model)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Next: Check out the Template Apps and Tutorial](#next--check-out-the-template-apps-and-tutorial) ## Overview This page contains information to quickly get Realm Database integrated into your app. If you haven't already, [install the Realm React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/install/#std-label-react-native-install) ## Import Realm At the top of your source files where you want to use Realm, add the following line to import the SDK. `| import Realm from \"realm\"; |\n| -------------------------- | ` ## Define Your Object Model Your application's [object model](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-schemas) defines the data that you can store within Realm Database. To define a Realm object type, create a schema object that specifies the type's`name` and `properties`. The type name must be unique among object types in a realm. The following code shows how to define an object model for a `Task` object. In this example: * The `primaryKey` is the `_id` of type `int`. Another common type used for primary keys is [ObjectId.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#objectId)\n* The `name` field is required.\n* The `status` and `owner_id` fields are optional, denoted by the question mark immediately after the data type. ```javascript const TaskSchema = {   name: \"Task\",   properties: {     _id: \"int\",     name: \"string\",     status: \"string?\",     owner_id: \"string?\",   },   primaryKey: \"_id\", }; \n``` ## Open a Realm To open a realm, pass a [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object to [Realm.open().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open) ```javascript const realm = await Realm.open({   path: \"realm-files/myrealm\",   schema: [TaskSchema], }); \n``` ## Create Realm Objects Once you have opened a realm, you can create [objects](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-types) in it. All writes must occur within a [write transaction.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/write-transactions/#std-label-react-native-write-transactions) ```javascript // Add a couple of Tasks in a single, atomic transaction let task1, task2; realm.write(() => {   task1 = realm.create(\"Task\", {     _id: 1,     name: \"go grocery shopping\",\n\n   });   task2 = realm.create(\"Task\", {     _id: 2,     name: \"go exercise\",     status: \"Open\",   });   console.log(`created two tasks: ${task1.name} & ${task2.name}`); }); // use task1 and task2 \n``` ## Find, Sort, and Filter Objects The following code demonstrates how to: * Query for all instances of the \"Task\" object type.\n* Filter the query to retrieve only the tasks that are \"Open\".\n* Sort the tasks by the name in an ascending order. ```javascript // query realm for all instances of the \"Task\" type. const tasks = realm.objects(\"Task\"); console.log(`The lists of tasks are: ${tasks.map((task) => task.name)}`); // filter for all tasks with a status of \"Open\" const openTasks = tasks.filtered(\"status = 'Open'\"); console.log(   `The lists of open tasks are: ${openTasks.map(     (openTask) => openTask.name   )}` ); // Sort tasks by name in ascending order const tasksByName = tasks.sorted(\"name\"); console.log(   `The lists of tasks in alphabetical order are: ${tasksByName.map(     (taskByName) => taskByName.name   )}` ); \n``` ## Modify an Object As with writes, any changes to a Realm object must occur within a[Write transaction](https://mongodb.com/docs/realm/sdk/react-native/realm-database/write-transactions/#std-label-react-native-write-transactions) block. To modify an object, you update the object properties: In the following example, an application developer updates `task1` from the[Create Realm Objects](#std-label-react-native-quickstart-local-create-realm-objects)example above. The developer begins progress on the \"go grocery shopping task\" and sets `task1` to \"InProgress\". ```javascript realm.write(() => {   task1.status = \"InProgress\"; }); \n``` ## Delete an Object You can delete an object by calling the [realm.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#delete) method within a write transaction block: In the following example, an application developer deletes `task1` from the[Create Realm Objects](#std-label-react-native-quickstart-local-create-realm-objects)example above. ```javascript realm.write(() => {   // Delete the task from the realm.   realm.delete(task1);   // Discard the reference.   task1 = null; }); \n``` ## Watch a Collection You can [watch a realm, collection, or object for changes](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-change-notifications) by registering event handlers with the[Realm.addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#addListener) [Object.addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#addListener) [Collection.addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#addListener)methods. In the following example, an application developer watches for changes to the`Task` collection. ```javascript // Define the collection notification listener function listener(tasks, changes) {   // Update UI in response to deleted objects   changes.deletions.forEach((index) => {     // Deleted objects cannot be accessed directly,     // but we can update a UI list, etc. knowing the index.     console.log(`A task was deleted at the ${index} index`);   });   // Update UI in response to inserted objects   changes.insertions.forEach((index) => {     let insertedTasks = tasks[index];     console.log(       `insertedTasks: ${JSON.stringify(insertedTasks, null, 2)}`     );     // ...   });\n\n   // `newModifications` contains object indexes from after they were modified   changes.newModifications.forEach((index) => {     let modifiedTask = tasks[index];     console.log(`modifiedTask: ${JSON.stringify(modifiedTask, null, 2)}`);     // ...   }); } // Observe collection notifications. tasks.addListener(listener); \n``` ## Close a Realm Call the [realm.close()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#close) method when done with a realm instance to avoid memory leaks. ```javascript // Remember to close the realm realm.close(); \n``` ## Add Device Sync (Optional) This section illustrates how to authenticate with an Anonymous User and open a Flexible Sync realm to sync data between devices. ### Prerequisites * [An App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) enabled in the App Services UI\n* [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) enabled with [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)on and an `owner_id` field in the Queryable Fields section ### Initialize the App To use App Services features, such as authentication and sync, you must first access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id)in the App Services UI. ```javascript // Initialize your App. const app = new Realm.App({   id: \"<yourAppId>\", }); \n``` ### Authenticate a User To authenticate and log in a user, call [App.logIn()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#logIn). When [anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) is enabled, users can immediately log into your app without providing any identifying information: ```javascript // Initialize your App. const app = new Realm.App({   id: \"<yourAppId>\", }); // Authenticate an anonymous user. await app.logIn(Realm.Credentials.anonymous()); \n``` ### Define an Object Model Object models for synced realms work the same way as [local-only Realms](#std-label-react-native-quickstart-local-define-an-object-model). Define your object model just as you would for a local-only Realm. ```javascript const TaskSchema = {   name: \"Task\",   properties: {     _id: \"int\",     name: \"string\",     status: \"string?\",     owner_id: \"string?\",   },   primaryKey: \"_id\", }; \n``` ### Open a Synced Realm After you have initialized your App, authenticated a user, and defined your object model, you can create a [SyncConfiguration.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration)\n\n Additionally, you need at least one subscription before you can read from or write to the realm. Use `Configuration.sync.initialSubscriptions` to define the initial subscription set when the Realm file is first opened. ```javascript // Initialize your App. const app = new Realm.App({   id: \"<yourAppId>\", }); // Authenticate an anonymous user. await app.logIn(Realm.Credentials.anonymous()); // Define an object model const TaskSchema = {   name: \"Task\",   properties: {     _id: \"int\",     name: \"string\",     status: \"string?\",     progressMinutes: \"int?\",     owner: \"string?\",     dueDate: \"date?\",   },   primaryKey: \"_id\", }; // Create a `SyncConfiguration` object. const config = {   schema: [TaskSchema],   sync: {     // Use the previously-authenticated anonymous user.     user: app.currentUser,     // Set flexible sync to true to enable sync.     flexible: true,     // Define initial subscriptions to start syncing data as soon as the     // realm is opened.     initialSubscriptions: {       update: (subs, realm) => {         subs.add(           // Get objects that match your object model, then filter them           // the `owner_id` queryable field           realm.objects(\"Task\").filtered(`owner_id = ${app.currentUser.id}`)         );       },     },   }, }; const realm = await Realm.open(config); \n``` The syntax to [read](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/read/#std-label-react-native-read-objects), [update](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/update/#std-label-react-native-update-objects), and [watch for changes](https://mongodb.com/docs/realm/sdk/react-native/realm-database/react-to-changes/#std-label-react-native-react-to-changes) on a synced realm is identical to the syntax for non-synced realms above. While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. ## Next: Check out the Template Apps and Tutorial Check out the [template app](https://www.mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) to experiment with another quick way to start coding with the Realm React Native SDK. The React Native SDK template, labeled `react-native.todo.flex`, is a premade application that integrates Realm Database and Atlas Device Sync into a customizable android app. Alternatively, if you are interested in a guided experience, you can read our[Realm React Native SDK tutorial](https://www.mongodb.com/docs/atlas/app-services/tutorial/react-native/#std-label-react-native-tutorial) that expands on the template app. ← [Install Realm for React Native](https://mongodb.com/docs/realm/sdk/react-native/install/ \"Previous Section\")[Bootstrap with Expo - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/bootstrap-with-expo/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/custom-user-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Custom User Data - React Native SDK On this page * [Overview](#overview)\n* [Write to Custom User Data with a MongoClient](#write-to-custom-user-data-with-a-mongoclient)\n* [Output](#output)\n* [Read Custom User Data](#read-custom-user-data)\n* [Output](#output-1)\n* [Complete Example](#complete-example)\n* [Summary](#summary) ## Overview You can read arbitrary data about your application users, known as custom user data, directly within your React Native application. For example, you might store a user's preferred language, date of birth, or local timezone. You can write to the Custom User Data object via a[mongoClient.](https://mongodb.com/docs/realm/sdk/react-native/app-services/query-mongodb/#std-label-react-native-mongodb-data-access) The code examples in this page use the following [user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) on which the custom\\_data field has not yet been set.\n\n ` ## Important To use custom user data, you must first [Enable Custom User Data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-enable-custom-user-data-procedure) ## Write to Custom User Data with a MongoClient ## Note To modify the custom data field from a client or user function, write permission to the collection in which custom data is stored must be configured. If you prefer to restrict client write access to custom data from your application, you can still modify the object from a[system function.](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) Using standard CRUD operations through the [MongoDB Atlas service](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources), a user's custom data can be accessed. The following example updates the user's custom data to alter the user's `favoriteColor` to pink. ```javascript // A user must be logged in to use a mongoClient const user = await app.logIn(credentials); const mongo = user.mongoClient(\"<atlas service name>\"); const collection = mongo.db(\"<database name>\").collection(\"<collection name>\"); const filter = {   userID: user.id, // Query for the user object of the logged in user }; const updateDoc = {   $set: {     favoriteColor: \"pink\", // Set the logged in user's favorite color to pink   }, }; const result = await collection.updateOne(filter, updateDoc); console.log(result); \n``` ### Output ``` { matchedCount: 1, modifiedCount: 1 } \n``` ## Read Custom User Data ## Warning ### Custom Data May Be Stale App Services does not dynamically update a user's custom data if the underlying document changes. Instead, App Services fetches a new copy of the data whenever a user refreshes their access token, such as when they log in. This may mean that the custom data won't immediately reflect changes, e.g. updates from an authentication Trigger. If the token is not refreshed, the SDK waits 30 minutes and then refreshes it on the next call to the backend, so custom user data could be stale for up to 30 minutes plus the time until the next SDK call to the backend occurs. If you have updated your custom user data within the last 30 minutes, use the [refreshCustomData()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#refreshCustomData) method on the user object. ```javascript const customUserData = await user.refreshCustomData() console.log(customUserData); \n``` If you have not recently updated your custom user data, use the user object's [customData](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#customData) field. ## Note The `customData` field of the user object is read-only from a React Native application. ```javascript const customUserData = user.customData console.log(customUserData); \n``` ### Output ``` {   \"_id\":\"5f233a3ac49aca916792de1d\",   \"description\":\"a test document for user test@test.com\",   \"userID\":\"5f1f298f757611faec901d0f\",   \"favoriteColor\":\"pink\" } \n``` ## Complete Example ```javascript const Realm = require(\"realm\"); const appId = \"<your-realm-app-id>\"; // Set App ID here. const appConfig = {   id: appId,   timeout: 1000, }; async function run() {   let user;   try {     const app = new Realm.App(appConfig);     const credentials = Realm.Credentials.emailPassword(       \"test@test.com\",       \"<password>\"     );     // A user must be logged in to use a mongoClient     const user = await app.logIn(credentials);     console.log(user.id);     const mongo = user.mongoClient(\"<atlas service name>\");     const collection = mongo.db(\"<database name>\").collection(\"<collection name>\");\n\n       userID: user.id, // Query for the user object of the logged in user     };     const updateDoc = {       $set: {         favoriteColor: \"pink\", // Set the logged in user's favorite color to pink       },     };     const result = await collection.updateOne(filter, updateDoc);     console.log(result);     const customUserData = await user.refreshCustomData();     console.log(customUserData);   } finally {     user.logOut();   } } run().catch(console.dir); \n``` ## Summary * You can use custom user data to store information about your application users.\n* The custom user data field of the user object is read-only, and can only be modified to by performing CRUD operations through the Atlas service. ← [Authenticate Users - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/ \"Previous Section\")[Manage Email/Password Users - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/manage-email-password-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/use-realm-react/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Use Realm React On this page * [Overview](#overview)\n* [Setup Realm React](#setup-realm-react)\n* [Create a Realm Context](#create-a-realm-context)\n* [Setup](#setup)\n* [Using the Realm Provider](#using-the-realm-provider)\n* [Usage](#usage)\n* [Dynamically Update the Realm Configuration](#dynamically-update-the-realm-configuration)\n* [Use Realm Provider Hooks](#use-realm-provider-hooks)\n* [useRealm](#userealm)\n* [useObject](#useobject)\n* [useQuery](#usequery)\n* [Using the App Provider](#using-the-app-provider)\n* [useApp](#useapp)\n* [Using the User Provider](#using-the-user-provider)\n* [useUser](#useuser)\n* [Summary](#summary) ## Overview [Realm React](https://www.npmjs.com/package/@realm/react) is an npm package that provides an easy-to-use API to perform common Realm operations, such as querying or writing to a realm and listening to realm objects. Realm React helps you avoid creating boilerplate code, such as creating your own listeners and state management. Realm React provides access to Realm database through a set of hooks that update React state when the Realm data changes. This means that components using these hooks will re-render on any changes to data in the realm. ## Note ### Using Realm React with Realm JS Version 11 To use [Realm JS version 11.0.0](https://github.com/realm/realm-js/releases/tag/v11.0.0) or higher with [Realm React](https://www.npmjs.com/package/@realm/react), you must upgrade to version [0.4.0](https://github.com/realm/realm-js/blob/master/packages/realm-react/CHANGELOG.md#040-2022-10-18)or higher. ## Setup Realm React To set up Realm React, you can either start from scratch with a new application using the [Realm Expo template](https://github.com/expo/examples/tree/master/with-realm)or install Realm React for an existing [React Native application](https://reactnative.dev/docs/environment-setup#creating-a-new-application). ## Create a Realm Context The `createRealmContext()` method creates a [React Context](https://reactjs.org/docs/context.html) object for a realm with a given [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration). The `Context` object contains the following: * A [Context Provider](https://reactjs.org/docs/context.html#contextprovider) component that wraps around a component and provides any of its child components with access to the hooks.\n* Various pre-built [Hooks](https://reactjs.org/docs/hooks-intro.html) that you can use to access the opened realm, query the realm, etc. ### Setup We recommend creating a file where you will define a Realm object type, a Realm configuration, and create a Realm `Context`. At the top of the file, import Realm and the `createRealmContext()` method. `| import {Realm, createRealmContext} from '@realm/react'; |\n| ------------------------------------------------------- | ` Next, define a Object Schema using a JavaScript class. The `Task`class below contains the following: * A `generate()` method that returns a `Task` insertion object that automatically sets computed values, such as `_id` and `createdAt`. This insertion can be forwarded to `realm.create` to perform an insertion\n* A `schema` property that defines this Object Schema. Read the [Define a Realm Object Schema](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-define-a-realm-object-schema) documentation to learn more. ```\n\n   _id!: Realm.BSON.ObjectId;   description!: string;   isComplete!: boolean;   createdAt!: Date;   // the Task.generate() method creates Task objects with fields with default values   static generate(description: string) {     return {       _id: new Realm.BSON.ObjectId(),       description,       isComplete: false,       createdAt: new Date(),     };   }   // To use a class as a Realm object type, define the object schema on the static property \"schema\".   static schema = {     name: 'Task',     primaryKey: '_id',     properties: {       _id: 'objectId',       description: 'string',       isComplete: {type: 'bool', default: false},       createdAt: 'date',     },   }; } \n``` Finally, create a `Realm.Configuration` object and set its `schema` property to the classes you have created. Pass the configuration object to the`createRealmContext()` method. Export the return value of`createRealmContext()`, so you can use the `Context` object in other files. ``` const config = {   schema: [Task], }; export default createRealmContext(config); \n``` ## Using the Realm Provider Wrap the component needing access to Realm Database, typically the top layer of your application, with the `RealmProvider` component included in the`Context` object, which was returned from `createRealmContext`. The`RealmProvider` provides child components access to the configured Realm through the hooks included in the `Context` object. ## Tip ### Choosing Which Components to Wrap inside the Realm Provider For simple use-cases, you may want to wrap your entire application in the`RealmProvider` component, such as the example below. For additional security, you may only want to give access to the opened realm to specific screens, or after the user has logged-in. ### Usage Import the `Context` object that you created. In the example below, the`Context` object is called `TaskContext` since it refers to the Realm `Context` of the Task. You can [Destructure](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring%5Fassignment#object%5Fdestructuring)the `TaskContext` object to get its `RealmProvider`. ``` import TaskContext from './models/Task'; const {RealmProvider} = TaskContext; \n``` Wrap the `RealmProvider` around the component that you want to give access to the configured realm. In the example below, we give the entire app access to the realm by wrapping the `RealmProvider` around the `App` component, which renders the application. ``` function AppWrapper() {   return (     <RealmProvider>       <App />     </RealmProvider>   ); } \n``` ### Dynamically Update the Realm Configuration You can dynamically update the Realm configuration by setting[props](https://reactjs.org/docs/components-and-props.html) on the `RealmProvider`component. The props you set on the `RealmProvider` will overwrite any property passed into `createRealmContext()`. In the following example, we update the RealmProvider with a [sync configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) and a `fallback`property that is used to render a temporary `LoadingSpinner` component while waiting for Device Sync to open: ``` function AppWrapper() {   const syncConfig = {     user: app?.currentUser,     partitionValue: 'ExpoTemplate',   };   return (     <RealmProvider sync={syncConfig} fallback={() => <LoadingSpinner />}>       <App />     </RealmProvider>   ); } \n``` ## Use Realm Provider Hooks Once you have wrapped your component with your `RealmProvider`, your component and its child components will have access to the `useRealm()`,`useObject()`, and `useQuery()` hooks.\n\n ``` import TaskContext, {Task} from './models/Task'; const {useRealm, useQuery, useObject} = TaskContext; \n``` ### useRealm The `useRealm()` hook returns the opened realm instance. The `handleAddTask()` method of the `App` component writes to the realm returned by the `useRealm()` hook in the following example. ``` const realm = useRealm(); const handleAddTask = useCallback(   (description: string): void => {     if (!description) {       return;     }     realm.write(() => {       realm.create('Task', Task.generate(description));     });   },   [realm], ); \n``` The [Realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) call invokes the `Task.generate()` method defined in the `Task` class. This method instantiates a JavaScript object with default values for the `_id`, `isComplete`, and`createdAt` properties. ## Tip ### See also:  Read the [Write Transactions](https://mongodb.com/docs/realm/sdk/react-native/realm-database/write-transactions/#std-label-react-native-write-transactions) documentation to learn more about modifying Realm data. ### useObject The `useObject()` hook returns a Realm object for a given[primary key](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/primary-key/#std-label-react-native-primary-keys). You can invoke it with the class model definition (this will add types to the returned object in TypeScript) or the class name as a string and the primary key. The `useObject()` method returns null if the object doesn't exist or you have deleted it. The hook will automatically subscribe to updates and re-render the component using the hook on any change to the object. In the following example, the `useObject()` hook retrieves a `Task` object, and its description is rendered in the UI. ``` const SampleTask = ({_id}) => {   const myTask = useObject(Task, _id);   return (     <View>       <Text>Task: {myTask?.description} </Text>     </View>   ); }; \n``` ### useQuery The `useQuery()` hook returns a collection of realm objects of a given type. Like `useObject`, it is either invoked with the Object Schema class or the model name as a string. The `useQuery()` method subscribes to updates to any objects in the collection and re-renders the component using it on any change to the query results. In the following example, of a `TaskList` component, The `Task`class is passed to the `useQuery()` and the tasks are set as a `data` prop of a [FlatList](https://reactnative.dev/docs/flatlist) component. ``` function TaskList({onToggleTaskStatus, onDeleteTask}) {   const tasks = useQuery(Task);   return (     <View style={styles.listContainer}>       <FlatList         data={tasks}         keyExtractor={task => task._id.toString()}         renderItem={({item}) => (           <TaskItem             description={item.description}             isComplete={item.isComplete}             onToggleStatus={() => onToggleTaskStatus(item)}             onDelete={() => onDeleteTask(item)}           />         )}       />     </View>   ); } \n``` ## Tip\n\n ## Using the App Provider To use Realm features such as authentication and sync, use the`AppProvider` to initiate a new [Realm.App](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html). Wrap the`AppProvider` outside of the `RealmProvider` and any components which need access to the [useApp](#std-label-react-native-use-app-hook) hook. ``` import { AppProvider } from '@realm/react' function AppWrapper() {   return (     <AppProvider id={appId}>       <RealmProvider>         <App />       </RealmProvider>     </AppProvider>   ); } \n``` ### useApp The `useApp()` hook provides access to the [Realm.App](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html)instance. In the following example, we call `useApp()` within a `LoginComponent`, and then use the app instance to log in with email/password authentication. ``` import {useApp} from '@realm/react'; function LoginComponent({}) {   const [email, setEmail] = useState('');   const [password, setPassword] = useState('');   const app = useApp();   const signIn = async () => {     const credentials = Realm.Credentials.emailPassword(email, password);     await app.logIn(credentials);   };   // ... } \n``` ## Using the User Provider The `UserProvider` provides a [Realm user](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html) for its child components to access. The `UserProvider`: * contains an optional `fallback` property that renders a Login component when the user has not authenticated.\n* renders its child components only if the user is logged in or has no fallback property. In the following example, we pass a Login component to the fallback property of`UserProvider`. Once the user has logged in, the Login component disappears from the view, and the `App` is rendered. We wrap the `App` in a`RealmProvider` with a sync configuration to give the `App` access to a synced realm. If the user logs out, the application falls back to the Login component. ``` import { AppProvider, UserProvider } from '@realm/react' const AppWrapper = () => {   return (     <AppProvider id={appId}>       <UserProvider fallback={LoginComponent}>         {/* After login, user will be automatically populated in realm configuration */}         <RealmProvider           sync={{partitionValue: 'SamplePartition'}}>           <App />         </RealmProvider>       </UserProvider>     </AppProvider>   ); }; \n``` ## Note ### The User is Automatically Set for the Sync Configuration When the `UserProvider` wraps the `RealmProvider`, the `RealmProvider`automatically sets the logged-in user for your sync configuration. This means you do not need to specify your user in your sync configuration object. ### useUser The `useUser()` hook provides access to the logged-in user. In the following example, we call `useApp()` within a `SampleTask`component and display the logged-in user's `_id`. ``` import {useUser} from '@realm/react'; const SampleTask = ({_id}) => {   // Access the logged in user using the useUser hook   const user = useUser();   const myTask = useObject(Task, _id);   return (     <View>       <Text>         The task {myTask?.description} was created by user id: {user?.id}       </Text>     </View>   ); }; \n``` ## Summary\n\n ← [Bootstrap with Expo - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/bootstrap-with-expo/ \"Previous Section\")[Realm Database - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/create-and-delete-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create and Delete Users - React Native SDK On this page * [Create a User](#create-a-user)\n* [Delete a User](#delete-a-user) ## Create a User For most [authentication methods](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), Realm automatically creates a [user account](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) the first time a user authenticates. The only exception is email/password authentication. When you use email/password authentication, you must [register](https://mongodb.com/docs/realm/sdk/react-native/manage-users/manage-email-password-users/#std-label-react-native-register-new-user) and [confirm](https://mongodb.com/docs/realm/sdk/react-native/manage-users/manage-email-password-users/#std-label-react-native-complete-confirmation) a user before the user can authenticate to a Realm application. ## Delete a User _New in version 10.13.0_. Call the [App.deleteUser()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#deleteUser) on a user object to delete the user's account from your Realm application. This deletes the account from the server in addition to clearing local data. `| await app.deleteUser(app.currentUser); |\n| -------------------------------------- | ` To use your app in the future, the user must sign up for a new account. They can use the same credentials (depending on the authentication provider), but will not have the same User ID as their deleted account. ## Important ### Deleting All User Data Deleting a user only deletes the [user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects), which may contain associated metadata from the associated auth provider. This does not delete [custom user data](https://mongodb.com/docs/realm/sdk/react-native/manage-users/custom-user-data/#std-label-react-native-access-custom-user-data)or other user data that your app stores in a linked collection or external services. Use the [Authentication Trigger DELETE event](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-event-operation-types)to programmatically clean up other data when you delete a user. For example, you can delete the user's data from your custom user data collection or another service. Apple [requires that you disclose data retention and deletion policies](https://developer.apple.com/app-store/review/guidelines/#5.1.1) to your application customers and give them a way to request user data deletion. If you collect additional user data, you must implement your own methods or processes to delete that data. ← [Manage Users - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/ \"Previous Section\")[Authenticate Users - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/link-user-identities/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Link User Identities - React Native SDK ## Overview Realm provides [many authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)to log users into your app. Each provider creates a unique user identity. Realm lets you merge multiple credentials into one user identity. ## Example Consider an application that offers [anonymous login](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication). This allows users to explore the app without registering. If users like the application, they create permanent accounts. They sign up with SSO or email/password authentication. By default, this creates a new `User` object. The app must link the new identity with the original User. You can link identities using `linkUser(credentials:Credentials)`. This links authentication providers to a logged-in `User` object. ← [Multi-User Applications - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/multi-user-applications/ \"Previous Section\")[Create & Manage User API Keys - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/manage-user-api-keys/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/manage-email-password-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Email/Password Users - React Native SDK On this page * [Register a New User Account](#register-a-new-user-account)\n* [Confirm a New User's Email Address](#confirm-a-new-user-s-email-address)\n* [Complete a User Confirmation](#complete-a-user-confirmation)\n* [Retry User Confirmation Methods](#retry-user-confirmation-methods)\n* [Resend a Confirmation Email](#resend-a-confirmation-email)\n* [Retry a User Confirmation Function](#retry-a-user-confirmation-function)\n* [Reset a User's Password](#reset-a-user-s-password)\n* [Send a Password Reset Email](#send-a-password-reset-email)\n* [Call a Password Reset Function](#call-a-password-reset-function)\n* [Complete a Password Reset](#complete-a-password-reset) ## Register a New User Account To register a new email/password user, pass the user's email address and desired password to [EmailPasswordAuth.registerUser()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#registerUser). The email address must not be associated with another email/password user and the password must be between 6 and 128 characters. ## Note ### Confirm New Users You must [confirm a new user's email address](#std-label-react-native-confirm-user) before they can log in to your app. ## Confirm a New User's Email Address New users must confirm that they own their email address before they can log in to your app unless the provider is configured to [automatically confirm new users.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-automatically-confirm-users) ### Complete a User Confirmation You need a valid `token` and `tokenId` for a registered user in order to confirm them and allow them to log in. These values are available in different places depending on the provider configuration: * If the provider is set to [send a confirmation email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-confirmation-email), the `token` and `tokenId` values are included as query parameters in the Email Confirmation URL.\n* If the provider is set to [run a confirmation function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-confirmation-function), the `token` and `tokenId` values are passed to the function as arguments. To confirm a registered user, pass a valid `token` and `tokenId` to[EmailPasswordAuth.confirmUser().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#confirmUser) ## Retry User Confirmation Methods The SDK provides methods to resend user confirmation emails or retry custom confirmation methods. ### Resend a Confirmation Email If the provider is configured to [send a confirmation email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-confirmation-email), Atlas App Services automatically sends a confirmation email when a user registers. The email contains a link to the configured Email Confirmation URL with a token that is valid for 30 minutes after the email is sent. If a user did not receive the initial email or didn't click the confirmation link in time, you can use the SDK to send a new confirmation email to the user. To send a new confirmation email to a user, pass their email address to[EmailPasswordAuth.resendConfirmationEmail().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#resendConfirmationEmail) ### Retry a User Confirmation Function\n\n ## Reset a User's Password ### Send a Password Reset Email To [send a password reset email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-password-reset-email) (if the provider is configured to do so), call[EmailPasswordAuth.sendResetPasswordEmail()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#sendResetPasswordEmail). The email contains a link to the configured Password Reset URL. ### Call a Password Reset Function To [run a password reset function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function) (if the provider is configured to do so), pass the user's email address, new password, and any additional function arguments to[EmailPasswordAuth.callResetPasswordFunction().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#callResetPasswordFunction) ### Complete a Password Reset Once a user requests a password reset, either by [sending a password reset email](#std-label-react-native-send-password-reset-email) or [calling a password reset function](#std-label-react-native-call-password-reset-function), Realm generates a pair of unique`token` and `tokenId` values that they can use to complete the password reset within 30 minutes of the initial request. To complete the password reset, pass the `token`, `tokenId`, and new password to [EmailPasswordAuth.resetPassword().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#resetPassword) ← [Custom User Data - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/custom-user-data/ \"Previous Section\")[Multi-User Applications - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/multi-user-applications/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/test-and-debug/testing/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Testing - React Native SDK On this page * [Overview](#overview)\n* [Clean Up Tests](#clean-up-tests) ## Overview You can test the Realm React Native SDK with popular React Native testing libraries like [Jest](https://jestjs.io/), [Jasmine](https://jasmine.github.io/), and [Mocha.](https://mochajs.org/) ## Tip ### See also:  [Official React Native Testing Documentation](https://reactnative.dev/docs/testing-overview) ### Clean Up Tests When testing the Realm React Native SDK, you must close realms with[Realm.close()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#close) after you're done with them to prevent memory leaks. You should also delete the realm file with [Realm.deleteFile()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.deleteFile)during clean up to keep your tests idempotent. The below example uses the Jest testing framework. It uses Jest's built-in `beforeEach()`and `afterEach()` hooks for test set up and tear down, respectively. `| const config = {                    |\n| ----------------------------------- |\n| schema: [Car],                      |\n| };                                  |\n| let realm;                          |\n| beforeEach(async () => {            |\n| realm = await Realm.open(config);   |\n| });                                 |\n| afterEach(() => {                   |\n| if (!realm.isClosed) {              |\n| realm.close();                      |\n| }                                   |\n| if (config) {                       |\n| Realm.deleteFile(config);           |\n| }                                   |\n| });                                 |\n| test(\"Close a Realm\", async () => { |\n| expect(realm.isClosed).toBe(false); |\n| realm.close();                      |\n| expect(realm.isClosed).toBe(true);  |\n| });                                 | ` ← [Test & Debug - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/test-and-debug/ \"Previous Section\")[Debugging with Flipper - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/test-and-debug/debugging-with-flipper/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/manage-user-api-keys/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create & Manage User API Keys - React Native SDK On this page * [Create a User API Key](#create-a-user-api-key)\n* [Look up a User API Key](#look-up-a-user-api-key)\n* [Enable or Disable an API Key](#enable-or-disable-an-api-key)\n* [Delete an API Key](#delete-an-api-key) ## Create a User API Key To create a new [user API key](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication-user-api-key), pass a name that's unique among all of the user's API keys to[ApiKeyAuth.create().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#create) ## Important You cannot create a user API key for a [server API key](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication-server-api-key) or an [anonymous user.](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) ## Warning ### Store the API Key Value The SDK only returns the value of the user API key when you create it. Make sure to store the `key` value securely so that you can use it to log in. If you lose or do not store the `key` value there is no way to recover it. You will need to create a new user API key. ## Look up a User API Key To get an array that lists all of a user's API keys, call[ApiKeyAuth.fetchAll().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#fetchAll) To find a specific API key, pass the key's `_id` to[ApiKeyAuth.fetch().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#fetch) ## Enable or Disable an API Key To enable or disable a user API key, pass the key's `_id` to[ApiKeyAuth.enable()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#enable) or[ApiKeyAuth.disable()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#disable). When a key is disabled, it cannot be used to log in on behalf of the user. ## Delete an API Key To permanently delete a user API, pass the key's `_id` to[ApiKeyAuth.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#delete). Deleted keys cannot be recovered. ← [Link User Identities - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/link-user-identities/ \"Previous Section\")[Sync Data Between Devices - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/pause-or-resume-sync-session/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Pause or Resume a Sync Session - React Native SDK On this page * [Overview](#overview)\n* [When to Pause a Sync Session](#when-to-pause-a-sync-session) ## Overview Opening a synced realm starts a [sync session](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html). You can pause and resume the sync session on the realm. Pausing a sync session only pauses that realm's sync session. If you have more than one open realm, pause does not affect the sync sessions for other realms. To pause synchronization, use the [syncSession.pause()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#~pause) method. To resume synchronization, use the[syncSession.resume()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#~resume) method.\n\n ` ### When to Pause a Sync Session For most applications, there is no need to manually pause and resume a sync session. However, there are a few circumstances under which you may want to pause or suspend a sync session: * You only want to sync after the user takes a specific action\n* You only want to sync during a certain time of the day\n* You don't want to attempt to sync when there is poor network connectivity\n* You want to explicitly force a sync session to connect In the case of poor network connectivity, continually trying to establish a network connection can drain the user's device battery. The case of explicitly forcing a sync session to connect is most commonly related to being offline for some time. The sync client attempts to connect, and upon failure, goes into exponential backoff. After being offline for a long time, the client may not immediately reconnect. Pausing and resuming the sync session explicitly forces the connection. When you do pause a sync session, keep these things in mind: * If the client may be offline longer than the [client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), the client will be unable to resume syncing and must perform a [client reset.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets)\n* Pausing a sync session pauses it in both directions. Changes that your app makes on the device do not sync with the backend, _and_ changes to the data in the backend or on other devices do not sync to the device. There is no way to pause only uploads or pause only downloads.\n* Do not pause a sync session if you want a client to permanently stop syncing with the backend. To permanently stop syncing, copy the contents of the synced realm into a non-synced realm, and use the non-synced realm in the client. _Do not_ pause sync to stop syncing for indefinite time periods or time ranges in months and years. The functionality is not designed or tested for these use cases. You could encounter a range of issues when using it this way. ← [Manage Flexible Sync Subscriptions - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/flexible-sync/ \"Previous Section\")[Check Upload & Download Progress for a Sync Session - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/check-upload-download-progress/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate Users - React Native SDK On this page * [Log In](#log-in)\n* [User Sessions](#user-sessions)\n* [Anonymous User](#anonymous-user)\n* [Email/Password User](#email-password-user)\n* [API Key User](#api-key-user)\n* [Custom JWT User](#custom-jwt-user)\n* [Custom Function User](#custom-function-user)\n* [Facebook User](#facebook-user)\n* [Google User](#google-user)\n* [Apple User](#apple-user)\n* [Offline Login](#offline-login)\n* [Get a User Access Token](#get-a-user-access-token)\n* [Log a User Out](#log-a-user-out) ## Log In Realm provides an API for authenticating users using any enabled authentication provider. Instantiate a `Credentials` object and pass it to the`app.login()` method to authenticate a user login and create a `User`object. ### User Sessions Atlas App Services manages sessions with access tokens and refresh tokens. Client SDKs supply the logic to manage tokens, and provide them with requests. For web browsers, the JavaScript SDK stores these tokens in[HTML5 local storage](https://developer.mozilla.org/en-US/docs/Web/API/Web%5FStorage%5FAPI). ## Tip ### See also:  [User Sessions](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) ## Anonymous User The [Anonymous](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) provider allows users to log in to your application with temporary accounts that have no associated information. To log in, create an anonymous credential and pass it to `App.logIn()`: ## Email/Password User The [email/password](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) authentication provider allows users to log in to your application with an email address and a password. To log in, create an email/password credential with the user's email address and password and pass it to `App.logIn()`: ## API Key User The [API key](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication) authentication provider allows server processes to access your app directly or on behalf of a user. To log in with an API key, create an API Key credential with a server or user API key and pass it to `App.logIn()`: ## Custom JWT User The [Custom JWT](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) authentication provider allows you to handle user authentication with any authentication system that returns a [JSON web token.](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-json-web-tokens) To log in, create a Custom JWT credential with a JWT from the external system and pass it to `App.logIn()`: ## Custom Function User The [Custom Function](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication) authentication provider allows you to handle user authentication by running a [function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) that receives a payload of arbitrary information about a user. To log in with the custom function provider, create a Custom Function credential with a payload object and pass it to `App.logIn()`: ## Facebook User The [Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) authentication provider allows you to authenticate users through a Facebook app using their existing Facebook account. ## Important ### Enable the Facebook Auth Provider\n\n ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. You can use the [official Facebook SDK](https://developers.facebook.com/docs/facebook-login/overview)to handle the user authentication and redirect flow from a client application. Once authenticated, the Facebook SDK returns an access token that you can send to your React Native app and use to finish logging the user in to your app. ## Google User The [Google](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication) authentication provider allows you to authenticate users with their existing Google account. ## Note ### Enable the Google Auth Provider To authenticate a Google user, you must configure the [Google authentication provider.](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication) There is no official Sign in with Google integration with React Native. The simplest approach to integrating Sign in With Google into your React Native app with Realm authentication is to use a third-party library. The below example uses the library[React Native Google Sign In](https://github.com/react-native-google-signin/google-signin). You can also build your own solution using [Google Identity Services](https://developers.google.com/identity) to handle the user authentication and redirect flow from a client application. Regardless of implementation, you must retrieve an ID token from the Google Authorization server. Use that ID token to log into Realm. `` | // Get the Google OAuth 2.0 access token                   |\n| ---------------------------------------------------------- |\n| const idToken = getGoogleAccessToken();                    |\n| // Log the user in to your app                             |\n| const credentials = Realm.Credentials.google({ idToken }); |\n| app.logIn(credentials).then((user) => {                    |\n| console.log(`Logged in with id: ${user.id}`);              |\n| });                                                        |  `` ## Example ### Authenticate with Google in React Native This example uses the library[React Native Google Sign In](https://github.com/react-native-google-signin/google-signin). In addition to the React Native code, you must also set up additional configuration in your project's `ios` and `android` directories to use Sign in with Google. Refer to the package's documentation for[iOS-specific](https://github.com/react-native-google-signin/google-signin/blob/master/docs/ios-guide.md)and [Android-specific](https://github.com/react-native-google-signin/google-signin/blob/master/docs/android-guide.md)documentation. SignInWithGoogleButton.jsx ```javascript import { useState } from \"react\"; import {   GoogleSignin,   GoogleSigninButton,   statusCodes, } from \"@react-native-google-signin/google-signin\"; import Realm from \"realm\"; // Instantiate Realm app const realm = new Realm.App({   id: \"<Your App ID>\", }); // Configure Google Auth GoogleSignin.configure({   webClientId: \"<Your Web Client ID>\", }); export default function GoogleSignInButton() {   const [signinInProgress, setSigninInProgress] = useState(false);   const signIn = async () => {     setSigninInProgress(true);     try {       // Sign into Google       await GoogleSignin.hasPlayServices();\n\n       // use Google ID token to sign into Realm       const credential = Realm.Credentials.google({ idToken });       const user = await realm.logIn(credential);       console.log(\"signed in as Realm user\", user.id);     } catch (error) {       // handle errors       if (error.code === statusCodes.SIGN_IN_CANCELLED) {         // user cancelled the login flow       } else if (error.code === statusCodes.IN_PROGRESS) {         // operation (e.g. sign in) is in progress already       } else if (error.code === statusCodes.PLAY_SERVICES_NOT_AVAILABLE) {         // play services not available or outdated       } else {         // some other error happened       }     } finally {       setSigninInProgress(false);     }   };   // return Google Sign in button component   return (     <GoogleSigninButton       style={{ width: 192, height: 48 }}       size={GoogleSigninButton.Size.Wide}       color={GoogleSigninButton.Color.Dark}       onPress={signIn}       disabled={signinInProgress}     />   ); } \n``` ## Apple User The [Apple](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication) authentication provider allows you to authenticate users through Sign-in With Apple. ## Note ### Enable the Apple Auth Provider To authenticate an Apple user, you must configure the [Apple authentication provider.](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication) You can use the [official Sign in with Apple JS SDK](https://developer.apple.com/documentation/sign%5Fin%5Fwith%5Fapple/sign%5Fin%5Fwith%5Fapple%5Fjs) to handle the user authentication and redirect flow from a client application. Once authenticated, the Apple JS SDK returns an ID token that you can send to your React Native app and use to finish logging the user in to your app. ## Tip If you get a `Login failed` error saying that the `token contains an invalid number of segments`, verify that you're passing a UTF-8-encoded string version of the JWT. ## Offline Login When your Realm application authenticates a user, it caches the user's credentials. You can check for existing user credentials to bypass the login flow and access the cached user. Use this to open a realm offline. ## Note ### Initial login requires a network connection When a user signs up for your app, or logs in for the first time with an existing account on a client, the client must have a network connection. Checking for cached user credentials lets you open a realm offline, but only if the user has previously logged in while online. ```javascript // Log the user into the backend app. // The first time you login, the user must have a network connection. const getUser = async () => {   // Check for an existing user.   // If the user is offline but credentials are   // cached, this returns the existing user.   if (app.currentUser) return app.currentUser;   // If the device has no cached user credentials, log them in.   const credentials = Realm.Credentials.anonymous();   return await app.logIn(credentials); }; \n``` To learn how to use the cached user in the Sync Configuration and access a realm while offline, read the [Open a Synced Realm While Offline](https://mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/#std-label-react-native-open-synced-realm-offline) docs. ## Get a User Access Token\n\n You can access and refresh a logged in user's access token in the SDK from their`Realm.User` object, as in the following example: ## Log a User Out To log any user out, call the `User.logOut()` on their user instance. ## Warning When a user logs out, you can no longer read or write data in any synced realms that the user opened. As a result, any operation that has not yet completed before the initiating user logs out cannot complete successfully and will likely result in an error. Any data in a write operation that fails in this way will be lost. ← [Create and Delete Users - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/create-and-delete-users/ \"Previous Section\")[Custom User Data - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/custom-user-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/multi-user-applications/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Multi-User Applications - React Native SDK On this page * [User Account States](#user-account-states)\n* [Before You Begin](#before-you-begin)\n* [Add a New User to the Device](#add-a-new-user-to-the-device)\n* [List All Users on the Device](#list-all-users-on-the-device)\n* [Remove a User from the Device](#remove-a-user-from-the-device)\n* [Change the Active User](#change-the-active-user) The Realm SDK allows multiple [users](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) to be logged in to an app simultaneously on a given device. Atlas App Services client applications run in the context of a single active user even if multiple users are logged in simultaneously. You can quickly switch between authenticated users without requiring them to log in again. ## Important **Any logged-in user may become the active user without re-authenticating.**Depending on your app, this may be a security vulnerability. For example, a user on a shared device may switch to a coworker's logged in account without providing their credentials or requiring their explicit permission. If your application requires stricter authentication, avoid switching between users and prefer to explicitly log the active user out before authenticating another user. ## User Account States When a user first logs in through a Realm SDK on a device, the SDK saves the user's information and keeps track of the user's state on the device. The user's data remains on the device, even if they log out, unless you actively [remove the user.](#std-label-react-native-remove-a-user-from-the-device) The following states describe an on-device user at any given time: * **Authenticated:** any user that has logged in on the device and has not logged out or had its session revoked.  \n   * **Active**: a single authenticated user that is currently using the app on a given device. The SDK associates this user with outgoing requests and App Services evaluates data access permissions and runs functions in this user's context. See [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) for more information.  \n   * **Inactive**: all authenticated users that are not the current active user. You can [switch the active user](#std-label-react-native-change-the-active-user)to a currently inactive user at any time.\n* **Logged Out:** any user that authenticated on the device but has since logged out or had their session revoked. The following diagram shows how users within an App Services client app transition between states when certain events occur: ![A diagram the outlines the different states a user can be in: logged out, logged in and active, & logged in and inactive.](https://mongodb.com/docs/realm/images/multi-user.png) ## Before You Begin If you're using `@realm/react`, you must wrap any components that you want manage users with in the `AppProvider` component. Components wrapped with an `AppProviders`can use `useApp()` hook to access the [Realm.App](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html) client. For more information on using the `AppProvider` component and `useApp()` hook, refer to [Connect to an Atlas App Services App.](https://mongodb.com/docs/realm/sdk/react-native/app-services/connect-to-app-services-app/#std-label-react-native-connect-to-mongodb-realm-backend-app) ## Add a New User to the Device The Realm SDK automatically adds users to a device when they log in for the first time on that device. When a user logs in, they immediately become the application's [active user.](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user)\n\n ` ## List All Users on the Device You can access a list of all [user accounts](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) on the device with [Realm.App.allUsers](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#allUsers). This property includes an array all users that have logged in to the client app on a device. ```javascript // Get a list of all Users app.allUsers.forEach(user => {   console.log(`User with id ${user.id} is ${user.isLoggedIn ? \"logged in\" : \"logged out\"}`); }); \n``` ## Remove a User from the Device You can remove all information about a user from the device and automatically log the user out with [Realm.App.removeUser()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#removeUser). This method **does not** delete the user from the backend App. ```javascript // Remove the current user from the device const user = app.currentUser; await app.removeUser(user); // The user is no longer the active user if(app.currentUser) {   // The active user is now the logged in user (if there still is one) that was   // most recently active   assert(user.id !== app.currentUser.id) } // The user is no longer on the device assert(app.allUsers.find(({ id }) => id === user.id) === undefined); \n``` ## Change the Active User You can quickly switch an app's active user to another logged-in user at any time with [Realm.App.switchUser().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#switchUser) ```javascript // Get some logged-in users const authenticatedUsers = app.allUsers.filter(user => user.isLoggedIn); const user1 = authenticatedUsers[0]; const user2 = authenticatedUsers[1]; // Switch to user1 app.switchUser(user1); // The active user is now user1 assert(app.currentUser.id === user1.id); // Switch to user2 app.switchUser(user2); // The active user is now user2 assert(app.currentUser.id === user2.id); \n``` ← [Manage Email/Password Users - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/manage-email-password-users/ \"Previous Section\")[Link User Identities - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/link-user-identities/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/log-level/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Set the Client Log Level - React Native SDK On this page * [Overview](#overview) ## Overview You can set the realm Sync client [log level](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~LogLevel) by calling[Realm.App.Sync.setLogLevel()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#.setLogLevel) with your [Realm.App.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html) ## Example In the following example, an application developer sets the sync client log level to `\"debug\"`. `| Realm.App.Sync.setLogLevel(app, \"debug\"); |\n| ----------------------------------------- | ` ## Tip To diagnose and troubleshoot errors while developing your application, set the log level to `debug` or `trace`. For production deployments, decrease the log level for improved performance. ← [Check the Network Connection - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/network-connection/ \"Previous Section\")[Multiplex Sync Sessions - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/mutliplex-sync-sessions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/check-upload-download-progress/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Check Upload & Download Progress for a Sync Session - React Native SDK On this page * [Overview](#overview) ## Overview To check the upload and download progress for a sync session, add a progress notification using the [syncSession.addProgressNotification()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#.addProgressNotification) method. The `syncSession.addProgressNotification()` method takes in the following three parameters: * A `direction` parameter. Set to `\"upload\"` to register notifications for uploading data. Set to `\"download\"` to register notifications for downloading data.\n* A `mode` parameter. Set to `\"reportIndefinitely\"`for the notifications to continue until the callback is unregistered using[syncSession.removeProgressNotification()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#.removeProgressNotification). Set to `\"forCurrentlyOutstandingWork\"` for the notifications to continue until only the currently transferable bytes are synced.\n* A callback function parameter that has the arguments `transferred` and `transferable`.`transferred` is the current number of bytes already transferred.`transferable` is the total number of bytes already transferred plus the number of bytes pending transfer. ## Note Flexible Sync progress notifications are not yet fully supported. When using Flexible Sync, downloads only report notifications after changes are integrated. Partition-Based Sync provides ongoing notifications as changes progress downloading. Uploads report ongoing progress notifications for both Sync Modes. ## Example In the following example, an application developer registers a callback on the `syncSession` to listen for upload events indefinitely. The developer writes to the realm and then unregisters the `syncSession` notification callback.\n\n  `` ← [Pause or Resume a Sync Session - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/pause-or-resume-sync-session/ \"Previous Section\")[Check the Network Connection - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/network-connection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Open a Synced Realm - React Native SDK On this page * [Overview](#overview)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Open a Flexible Synced Realm](#open-a-flexible-synced-realm)\n* [Open a Partition-Based Synced Realm](#open-a-partition-based-synced-realm)\n* [Open a Synced Realm While Offline](#open-a-synced-realm-while-offline)\n* [Open Immediately with Background Sync](#open-immediately-with-background-sync)\n* [Open After Timeout with Background Sync](#open-after-timeout-with-background-sync)\n* [Copy Data and Open a New Realm](#copy-data-and-open-a-new-realm) ## Overview You can configure a realm to automatically synchronize data between many devices that each have their own local copy of the data. Synced realms use a different configuration than local-only realms and require an Atlas App Services backend to handle the synchronization process. Applications can always create, modify, and delete synced realm objects locally, even when offline. Whenever a network connection is available, the Realm SDK opens a connection to an application server and syncs changes to and from other clients. The [Atlas Device Sync protocol](https://www.mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-sync-protocol) and server-side operational transforms guarantee that all fully synced instances of a realm see exactly the same data, even if some changes occurred offline and/or were received out of order. ## Tip ### Learn How to Configure and Use Sync For more information on synced realms, including directions on how to set up sync in an App Services App, see [Atlas Device Sync Overview.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) ## Open a Synced Realm You can open a Synced realm with a Flexible Sync or Partition-Based Sync. If you have not yet decided or are unsure which to use, read the [Choose Your Sync Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-sync-modes) page. By default, Realm syncs all data from the server before returning. If you want to sync data in the background, read the [Open a Synced Realm While Offline](#std-label-react-native-open-synced-realm-offline) section. ### Open a Flexible Synced Realm To open a realm using Flexible Sync, call [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open). Pass in a [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration)object, which must include the `sync` property defining a[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) object. In the SyncConfiguration, you must include include a `user` and `flexible:true`. `| const realm = await Realm.open({  |\n| --------------------------------- |\n| schema: [TaskSchema, TeamSchema], |\n| sync: {                           |\n| user: app.currentUser,            |\n| flexible: true,                   |\n| },                                |\n| });                               | ` ## Important ### Flexible Sync Requires a Subscription\n\n ### Open a Partition-Based Synced Realm To open a realm with Partition-Based Sync, call [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open). Pass in a [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration)object, which must include the `sync` property defining a[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) object. In the SyncConfiguration, you must include include `user` and `partitionValue`. ```javascript const config = {   schema: [Car], // predefined schema   sync: {     user: app.currentUser, // already logged in user     partitionValue: \"myPartition\",   }, }; try {   const realm = await Realm.open(config);   realm.close(); } catch (err) {   console.error(\"failed to open realm\", err.message); } \n``` ## Open a Synced Realm While Offline When your Realm application authenticates a user, it caches the user's credentials. You can check for existing user credentials to bypass the login flow and access the cached user. Use this to open a realm offline. ## Note ### Initial login requires a network connection When a user signs up for your app, or logs in for the first time with an existing account on a client, the client must have a network connection. Checking for cached user credentials lets you open a realm offline, but only if the user has previously logged in while online. ```javascript // Log the user into the backend app. // The first time you login, the user must have a network connection. const getUser = async () => {   // Check for an existing user.   // If the user is offline but credentials are   // cached, this returns the existing user.   if (app.currentUser) return app.currentUser;   // If the device has no cached user credentials, log them in.   const credentials = Realm.Credentials.anonymous();   return await app.logIn(credentials); }; \n``` The following subsections show how to use background synchronization to access a realm while offline. To do this, use the cached user and an[OpenRealmBehaviorConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~OpenRealmBehaviorConfiguration) object. Within your Sync Configuration, set the optional `newRealmFileBehavior` and`existingRealmFileBehavior` fields to your `OpenRealmBehaviorConfiguration` object to enable background synchronization. ## Important ### Offline Login is Supported for Both Flexible and Partition-Based Sync Configurations You can open a realm immediately with background sync or after a timeout elapses using either Flexible and Partition-Based Sync. ### Open Immediately with Background Sync You may want to sync changes in the background to display partial data to the user while the synced realm downloads data from the server, preventing the user experience from being blocked. We recommend syncing changes in the background for applications in which the user's device may go offline. To sync changes in the background, open a synced realm synchronously. Create a [OpenRealmBehaviorConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~OpenRealmBehaviorConfiguration) object and set its`type` to `\"openImmediately\"`. Next, create a [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object, which must include the `sync` property defining a [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) object. Set this`OpenRealmBehaviorConfiguration` object as the value for the `newRealmFileBehavior` and `existingRealmFileBehavior` fields of the`SyncConfiguration`. ```javascript const openRealmBehaviorConfig = {   type: \"openImmediately\", }; const config = {   schema: [Car], // predefined schema   sync: {     user: await getUser(),     partitionValue: \"myPartition\",\n\n     existingRealmFileBehavior: openRealmBehaviorConfig,   }, }; \n``` ### Open After Timeout with Background Sync If you want to sync data but you're in an environment where it's uncertain if the user has an Internet connection, specify a `timeOut`. This automatically opens the realm when either: * the timeout period elapses.\n* the realm has completely downloaded. If the realm doesn't finish downloading before the timeout, the initial Sync continues in the background. ```javascript const openRealmBehaviorConfig = {   type: \"downloadBeforeOpen\",   timeOut: 1000,   timeOutBehavior: \"openLocalRealm\", }; const config = {   schema: [Car], // predefined schema   sync: {     user: await getUser(), // already logged in user     partitionValue: \"myPartition\",     existingRealmFileBehavior: openRealmBehaviorConfig,     newRealmFileBehavior: openRealmBehaviorConfig,   }, }; \n``` ## Copy Data and Open a New Realm _New in version 10.14.0_. To copy data from an existing realm to a new realm with different configuration options, pass the new configuration the[Realm.writeCopyTo()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#writeCopyTo) method. ## Note ### Partition-Based Sync Only This method only supports Partition-Based Sync. If your app uses Flexible Sync, you must manually iterate through the objects in one realm and copy them into the other realm. In the new realm's configuration, you _must_ specify the `path`. If you write the copied realm to a realm file that already exists, the data is written object by object. The copy operation replaces objects if there already exists objects for given primary keys. The schemas of the realm you copy and the realm you are writing to must be compatible for the copy operation to succeed. Only objects in the schemas of both configurations are copied over. The configuration change can include modifications to [SyncConfiguration:](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) * Local realm to synced realm\n* Synced Realm to local realm The configuration change can also include changes to `encryptionKey`property of the `Configuration`: * Encrypted realm to unencrypted realm\n* Unencrypted realm to encrypted realm ## Example ### Convert Local Realm to Synced Realm ```javascript const localConfig = {   schema: [Car],   path: \"localOnly.realm\", }; const localRealm = await Realm.open(localConfig); const syncedConfig = {   schema: [Car], // predefined schema   path: \"copyLocalToSynced.realm\", // must include in output configuration   sync: {     user: app.currentUser, // already logged in user     partitionValue: \"myPartition\",   }, }; localRealm.writeCopyTo(syncedConfig); const syncedRealm = await Realm.open(syncedConfig); \n``` You can also combine changes to configuration. For example, you can open a local encrypted realm as a synced unencrypted realm or a unencrypted synced realm as an encrypted synced realm. ## Example ### Convert Synced Encrypted to Local Unencrypted Realm ```javascript const encryptionKey = new Int8Array(64); // Create a secure key // ... store key ... const syncedEncryptedConfig = {   schema: [Car], // predefined schema   path: \"syncedEncrypted.realm\", // must include in output configuration   sync: {     user: app.currentUser, // already logged in user     partitionValue: \"myPartition\",   },   encryptionKey, }; const syncedEncryptedRealm = await Realm.open(syncedEncryptedConfig); const localUnencryptedConfig = {   schema: [Car], // predefined schema   path: \"copyLocalUnencrypted.realm\", // must include in output configuration }; syncedEncryptedRealm.writeCopyTo(localUnencryptedConfig); const localUnencryptedRealm = await Realm.open(syncedEncryptedConfig); \n``` ## Tip ### See also: \n\n ← [Atlas Device Sync Overview - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/overview/ \"Previous Section\")[Manage Flexible Sync Subscriptions - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/flexible-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/test-and-debug/debugging-with-flipper/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Debugging with Flipper - React Native SDK On this page * [Overview](#overview)\n* [Requirements](#requirements)\n* [Setup](#setup)\n* [Install the Flipper Desktop App](#install-the-flipper-desktop-app)\n* [Add Flipper to your React Native App](#add-flipper-to-your-react-native-app)\n* [Launch the Flipper Desktop App](#launch-the-flipper-desktop-app)\n* [Add the Realm Flipper Plugin to the Flipper Desktop App](#add-the-realm-flipper-plugin-to-the-flipper-desktop-app)\n* [Install Realm Flipper Plugin Device with NPM](#install-realm-flipper-plugin-device-with-npm)\n* [Import Realm Flipper Plugin in your Code](#import-realm-flipper-plugin-in-your-code) ## Overview To debug Realm apps built with React Native, use the Flipper Debugger. Flipper provides a way to visualize, inspect, and control your apps from a simple desktop interface. In addition to Flipper's intuitive interface, the [Realm Flipper Plugin](https://github.com/realm/realm-flipper-plugin) provides additional ways to inspect your Realm Database through: * Live Objects: See objects in real-time.\n* Schema Dependency Graph: View schemas and their relationships.\n* Make changes: Create, modify and delete objects\n* Query: Query the database using RQL ## Requirements * Using the [Hermes JS Engine](https://reactnative.dev/docs/hermes)\n* [Realm JS version 11.0](https://github.com/realm/realm-js/releases/tag/v11.0.0) or greater ## Setup 1 ### Install the Flipper Desktop App Follow the [Getting Started with Flipper](https://fbflipper.com/docs/getting-started/) guide to install Flipper for your operating system. 2 ### Add Flipper to your React Native App If you did not use `react-native init` to initialize your app, follow the manual setup guide(s) to add Flipper to your app: * [Manual Android Setup](https://fbflipper.com/docs/getting-started/react-native-android/)\n* [Manual iOS Setup](https://fbflipper.com/docs/getting-started/react-native-ios/) If you did use `react-native init` to initialize your app and are on React Native version `0.62` or greater, Flipper integration is supported out of the box. Otherwise, if you are on an earlier version of React Native, follow the [Automatic Setup](https://fbflipper.com/docs/getting-started/react-native/) guide. 3 ### Launch the Flipper Desktop App Launch your React Native mobile app and open the Flipper Desktop application. Your React Native app should be available in Flipper's App Inspect tab. ![Flipper Getting Started](https://mongodb.com/docs/realm/images/flipper-getting-started.png) 4 ### Add the Realm Flipper Plugin to the Flipper Desktop App Within the Flipper Desktop App, click the Plugin Manager tab on the left-hand side. When the Plugin Manager modal opens, select the Install Pluginsoption. Then search for the \"realm-flipper-plugin\" and install it. ![Add Realm Flipper Plugin](https://mongodb.com/docs/realm/images/add-realm-flipper-plugin.png) Click the red alert to reload the Flipper Desktop app and apply changes. ![Add Realm Flipper Plugin](https://mongodb.com/docs/realm/images/reload-flipper.png) 5 ### Install Realm Flipper Plugin Device with NPM [Realm Flipper Plugin Device](https://www.npmjs.com/package/realm-flipper-plugin-device) enables React Native applications to interact with Realm Flipper Plugin. Realm Flipper Plugin Device also requires the [React Native Flipper plugin](https://www.npmjs.com/package/react-native-flipper). To install both, run the following command: `| npm install realm-flipper-plugin-device react-native-flipper |\n| ------------------------------------------------------------ | ` If you are developing on iOS, run the following command to auto-link the `react-native-flipper` module with CocoaPods: ```shell\n\n pod install cd .. \n``` 6 ### Import Realm Flipper Plugin in your Code Import the `RealmPlugin` component `realm-flipper-plugin-device` package in the file in which you open a realm. ```javascript import RealmPlugin from 'realm-flipper-plugin-device'; \n``` Within your component's return statement, render your `RealmPlugin` and pass it the opened realm as a parameter. You can pass in multiple opened realms. ```javascript return (    <View>       <RealmPlugin realms={[realm]} /> {/* pass in the Realm to the plugin*/}       // ...    </View> ); \n``` Navigate back to the Realm Flipper Desktop app. Under theEnabled plugins, you should see the Realm plugin. If you don't see the Realm plugin enabled, click theDisabled dropdown and enable the `Realm Flipper Plugin` by tapping the \\+ Enable Plugin button. ![Enable Realm Flipper Plugin](https://mongodb.com/docs/realm/images/click-enable-plugin-flipper.png) You should see the following enabled `Realm Flipper Plugin`. ![View Enabled Realm Flipper Plugin](https://mongodb.com/docs/realm/images/view-enabled-flipper-plugin.png) Using the `Realm Flipper Plugin`, you can now: * create, modify and delete your realm objects\n* query the database using RQL\n* view schemas and their relationships using the Schema Dependency Graph ← [Testing - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/test-and-debug/testing/ \"Previous Section\")[Realm Integrations - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/integrations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/overview/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Atlas Device Sync Overview - React Native SDK On this page * [Overview](#overview)\n* [Flexible Sync](#flexible-sync)\n* [Group Updates for Improved Performance](#group-updates-for-improved-performance)\n* [Partition-Based Sync](#partition-based-sync) ## Overview Atlas Device Sync automatically synchronizes data between client applications and an [Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/#std-label-realm-cloud). When a client device is online, Sync asynchronously synchronizes data in a background thread between the device and your backend App. When you use Sync in your client application, your implementation must match the Sync Mode you select in your backend App configuration. The Sync Mode options are: * Flexible Sync\n* Partition-Based Sync You can only use one Sync Mode for your application. You cannot mix Partition-Based Sync and Flexible Sync within the same App. ## Tip ### See also:  [Configure and Enable Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) ## Flexible Sync When you select [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) for your backend App configuration, your client implementation must include subscriptions to queries on [queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields). Flexible Sync works by synchronizing data that matches query subscriptions you maintain in the client application. A subscription set contains a set of queries. Realm Flexible Sync returns documents matching those queries, where the user has the appropriate[permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read and/or read and write the documents. If documents match the query, but the client does not have the permission to read or write them, they do not sync to the client application. You can form queries using [Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Note Flexible Sync does not support all the query operators available in Realm Query Language and the SDK's query engine. See [Flexible Sync RQL Limitations](https://mongodb.com/docs/realm/realm-query-language/#std-label-flexible-sync-rql-limitations) for details. Subscription sets are based on a specific type of [Realm object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-types). You might have multiple subscriptions if you have many types of Realm objects. To use Flexible Sync in your client application, open a synced realm with a Flexible Sync configuration. Then, manage subscriptions to determine which documents to sync. ## Tip ### See also:  * Learn how to configure and open a realm using [Flexible Sync.](https://mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/#std-label-react-native-flexible-sync-open-realm)\n* Learn how to [Manage Flexible Sync Subscriptions](https://mongodb.com/docs/realm/sdk/react-native/sync-data/flexible-sync/#std-label-react-native-flexible-sync) ### Group Updates for Improved Performance Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change. ## Partition-Based Sync\n\n The partition value determines which data the client application can access. You pass in the partition value when you open a synced realm. ## Tip ### See also:  * Learn how to configure and open a realm using [Partition-Based Sync.](https://mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/#std-label-react-native-partition-sync-open-realm) ← [Sync Data Between Devices - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/ \"Previous Section\")[Open a Synced Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/mutliplex-sync-sessions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Multiplex Sync Sessions - React Native SDK On this page * [Overview](#overview) ## Overview Enable [session multiplexing](https://en.wikipedia.org/wiki/Session%5Fmultiplexing) to consolidate multiple sync sessions of a Realm app. Only use session multiplexing if you see errors about reaching the file descriptor limit, and you know you are using many sync sessions. To enable session multiplexing, call [Realm.App.Sync.enableSessionMultiplexing()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#.enableSessionMultiplexing) with your [Realm.App.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html) ## Example `| Realm.App.Sync.enableSessionMultiplexing(app); |\n| ---------------------------------------------- | ` ← [Set the Client Log Level - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/log-level/ \"Previous Section\")[Handle Sync Errors - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/handle-sync-errors/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/network-connection/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Check the Network Connection - React Native SDK On this page * [Overview](#overview) ## Overview To check the current state of the connection to the server, call the[syncSession.connectionState()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#.connectionState) method. ## Tip Realm's _offline-first_ design means that you generally don't need to check the current network connection state. That said, the`syncSession.connectionState()` method is available if your app needs to gets the current state of the connection to the server. `| var config = {                                         |\n| ------------------------------------------------------ |\n| schema: [DogSchema], // predefined schema              |\n| sync: {                                                |\n| user: app.currentUser,                                 |\n| partitionValue: \"MyPartitionValue\",                    |\n| },                                                     |\n| };                                                     |\n| let realm = await Realm.open(config);                  |\n| const syncSession = realm.syncSession;                 |\n| const connectionState = syncSession.connectionState(); | ` ← [Check Upload & Download Progress for a Sync Session - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/check-upload-download-progress/ \"Previous Section\")[Set the Client Log Level - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/log-level/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/handle-sync-errors/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Handle Sync Errors - React Native SDK On this page * [Overview](#overview) ## Overview While developing an application that uses Device Sync, you should set an error handler. This error handler will detect and respond to any failed sync-related API calls. Set an error handler by registering an error callback as part of the [SyncConfiguration.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) `| var config = {                            |\n| ----------------------------------------- |\n| schema: [DogSchema], // predefined schema |\n| sync: {                                   |\n| user: app.currentUser,                    |\n| partitionValue: \"MyPartitionValue\",       |\n| error: (_session, error) => {             |\n| (error) => {                              |\n| console.log(error.name, error.message);   |\n| };                                        |\n| },                                        |\n| },                                        |\n| };                                        |\n| const realm = await Realm.open(config);   | ` ## Tip For a list of common Device Sync errors and how to handle them, refer to[Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services Device Sync documentation. ## Note ### Client Reset Errors To learn more about handling client reset errors, read the [Reset a Client Realm](https://mongodb.com/docs/realm/sdk/react-native/sync-data/reset-a-client-realm/#std-label-react-native-client-resets) documentation. ← [Multiplex Sync Sessions - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/mutliplex-sync-sessions/ \"Previous Section\")[Reset a Client Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/reset-a-client-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/flexible-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Flexible Sync Subscriptions - React Native SDK On this page * [Overview](#overview)\n* [Subscribe to Queryable Fields](#subscribe-to-queryable-fields)\n* [Get Subscriptions](#get-subscriptions)\n* [Add a Query to the List Of Subscriptions](#add-a-query-to-the-list-of-subscriptions)\n* [Bootstrap the Realm with Initial Subscriptions](#bootstrap-the-realm-with-initial-subscriptions)\n* [Check the Status of Subscriptions](#check-the-status-of-subscriptions)\n* [Update Subscriptions with a New Query](#update-subscriptions-with-a-new-query)\n* [Remove Subscriptions](#remove-subscriptions)\n* [Remove a Subscription by Query](#remove-a-subscription-by-query)\n* [Remove a Subscription by Name](#remove-a-subscription-by-name)\n* [Remove a Subscription by Reference](#remove-a-subscription-by-reference)\n* [Remove All Subscriptions on an Object Type](#remove-all-subscriptions-on-an-object-type)\n* [Remove All Subscriptions](#remove-all-subscriptions)\n* [Flexible Sync RQL Limitations](#flexible-sync-rql-limitations)\n* [Unsupported Query Operators in Flexible Sync](#unsupported-query-operators-in-flexible-sync)\n* [List Queries](#list-queries)\n* [Embedded or Linked Objects](#embedded-or-linked-objects) ## Overview Flexible Sync uses subscriptions and permissions to determine which data to sync with your App. To use Flexible Sync in a React Native client: * [Configure Flexible Sync on the backend.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n* [Initialize the app](https://mongodb.com/docs/realm/sdk/react-native/app-services/connect-to-app-services-app/#std-label-react-native-app-client-configuration)\n* [Authenticate a user](https://mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-login-anonymous) in your client project.\n* [Open the synced Realm with a Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/#std-label-react-native-flexible-sync-open-realm)\n* [Add subscriptions to the client application](#std-label-react-native-sync-subscribe-to-queryable-fields) You can add, update, and remove query subscriptions to determine which data syncs to the client device. ## Note ### Flexible Sync Prerequisites Enabling Flexible Sync in your App requires a non-sharded Atlas cluster running [MongoDB 5.0 or greater](https://www.mongodb.com/docs/manual/release-notes/) ## Note ### Realm JS SDK Version Requirement In addition to the requirements above, you must use [Realm JS version 10.12.0](https://github.com/realm/realm-js/releases) or greater in order to use Flexible Sync in your React Native application. ## Important ### Flexible Sync Query Limitations You cannot use all queries with Flexible Sync subscriptions. Refer to the [Flexible Sync RQL Limitations documentation](#std-label-react-native-flexible-sync-rql-limitations)for information on which query types are not supported. ## Subscribe to Queryable Fields When configuring Flexible Sync on the backend, you specify which fields your client application can query. In the client application, use the`Subscriptions` API to manage a set of subscriptions to specific queries on queryable fields. You can: * Get a list of all subscriptions\n* Add subscriptions\n* Check subscription state\n* Update a subscription with a new query\n* Remove individual subscriptions or all subscriptions of a type\n\n A Realm subscription in JavaScript has: * A created and updated date\n* A name\n* An object type\n* A query string You can specify a string name for your subscription. If you do not give your subscription a name, the name is set to [null.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/null) When you create a subscription, Realm looks for data matching a query on a specific object type. In your Flexible Sync subscriptions, you can have subscriptions on several different object types or several queries on the same object type. ## Example In the following example, queries are created to subscribe to: * A filtered list of completed tasks that have taken over 120 `progressMinutes`\n* A filtered list of completed tasks Notice that queries that you subscribe to using Flexible Sync are syntactically the same as [querying a realm](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/read/#std-label-react-native-read-operations)and that the queries below will create an overlapping result set. `| const tasks = realm.objects(\"Task\");                |\n| --------------------------------------------------- |\n| const longRunningTasks = tasks.filtered(            |\n| 'status == \"completed\" && progressMinutes > 120'    |\n| );                                                  |\n| const bensTasks = tasks.filtered('owner == \"Ben\"'); | ` ## Important ### Object Links You must add both an object and its linked object to the subscription set to see a linked object. If your subscription results contain an object with a property that links to an object not contained in the results, the link appears to be null. There is no way to distinguish whether that property's value is legitimately null, or whether the object it links to exists but is out of view of the query subscription. ### Get Subscriptions When using a flexible synced realm, you can access a `SubscriptionSet`, a collection of subscriptions, through the [realm.subscriptions](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#subscriptions) property. ```javascript // get the SubscriptionSet for the realm const subscriptions = realm.subscriptions; \n``` You can use this `SubscriptionSet` to add queries to the list of subscriptions and update existing subscriptions, as shown in the examples below. ### Add a Query to the List Of Subscriptions Compose queries to add to your Flexible Sync subscriptions using the[query engine:](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/query-data/#std-label-react-native-client-query-engine) ```javascript const tasks = realm.objects(\"Task\"); const longRunningTasks = tasks.filtered(   'status == \"completed\" && progressMinutes > 120' ); const bensTasks = tasks.filtered('owner == \"Ben\"'); \n``` Add queries to your subscriptions list to sync the query's data. To do so, perform the following: 1. Create a transaction by passing a callback function to the[SubscriptionSet.update()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.SubscriptionSet.html#update)method of your `SubscriptionSet`. The callback function provides a [MutableSubscriptionSet](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html)as an argument.\n2. Within the callback function, call the[add()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#add)method on the `MutableSubscriptionSet` to add a query to the subscription. The following example shows how to subscribe to the queries created above. ```javascript await realm.subscriptions.update((mutableSubs) => {   mutableSubs.add(longRunningTasks, {\n\n   });   mutableSubs.add(bensTasks);   mutableSubs.add(realm.objects(\"Team\"), {     name: \"teamsSubscription\",     throwOnUpdate: true,   }); }); \n``` The `add()` method on the `MutableSubscriptionSet` takes a `query` and a[SubscriptionOptions](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#.SubscriptionOptions) object. The subscription options include: * a `name` string field\n* a `throwOnUpdate` boolean field. If `throwOnUpdate` is false or undefined, adding a subscription with an existing name will replace the existing query with the new query. However, if you set `throwOnUpdate` to true, adding a subscription with an existing name but a different query throws an exception. #### Bootstrap the Realm with Initial Subscriptions _New in version 10.18.0_. You must have at least one subscription before you can read from or write to a realm with Flexible Sync enabled. You can bootstrap a realm with an initial subscription set when you open it with a [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration)and Flexible Sync enabled. Include the `initialSubscriptions` field into the`SyncConfiguration`. Within the `initialSubscriptions` object, add an `update`field set to a callback in which you can subscribe to queries to bootstrap your application: ```javascript const config = {   sync: {     user: app.currentUser,     flexible: true,     initialSubscriptions: {       update: (subs, realm) => {         subs.add(           realm.objects(\"Team\").filtered(\"name == 'Developer Education'\")         );       },     },   }, }; const realm = await Realm.open(config); \n``` ### Check the Status of Subscriptions You can check the subscription state to see if the server has acknowledged the subscription and the device has downloaded the data locally. You can use subscription state to: * Trigger error handling\n* Show if the transaction is pending or has completed\n* Find out when a subscription set is superseded, and you should obtain a new instance of the subscription set to write a subscription change To the status of subscriptions, log the value of the subscription's[state.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.SubscriptionSet.html#state) ```javascript console.log(realm.subscriptions.state); // log the subscription state \n``` ## Note ### Subscription State \"Complete\" The subscription set state \"complete\" does not mean \"sync is done\" or \"all documents have been synced\". \"Complete\" means the following two things have happened: * The subscription has become the active subscription set that is currently being synchronized with the server.\n* The documents that matched the subscription _at the time the subscription was sent to the server_ are now on the local device. Note that this does not necessarily include all documents that currently match the subscription. The Realm SDK does not provide a way to check whether all documents that match a subscription have synced to the device. ### Update Subscriptions with a New Query You can update a named subscription with a new query. To update a subscriptions query, pass the new query and a subscription option with the name of the subscription that you want to update to the`MutableSubscriptionSet.add()` method. Like adding a new subscription, you must update a subscription within a transaction by calling`subscriptions.update()` method. In the following example, long-running tasks are re-defined to be any tasks that have taken more than 180 minutes. ```javascript realm.subscriptions.update((mutableSubs) => {   mutableSubs.add(     tasks.filtered('status == \"completed\" && progressMinutes > 180'),     {       name: \"longRunningTasksSubscription\",     }   ); }); \n``` ## Note Attempting to update a subscription that has the`SubscriptionOptions.throwOnUpdate` field set to true, throw an exception. ### Remove Subscriptions To remove subscriptions from the subscription set, you can:\n\n When you remove a subscription query, the server also removes synced data from the client device. #### Remove a Subscription by Query You can remove a specific subscription by query by executing a transaction on the subscriptions set. Pass the query to the [remove()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#remove) method on the`MutableSubscriptionSet` within a transaction. In the following example, the subscription to tasks with an owner named 'Ben' is removed from the subscriptions set. ```javascript realm.subscriptions.update((mutableSubs) => {   // remove a subscription with a specific query   mutableSubs.remove(tasks.filtered('owner == \"Ben\"')); }); \n``` #### Remove a Subscription by Name To remove a specific subscription by name, execute a transaction on the subscriptions set. Within the transaction, pass the name to the[removeByName()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#removeByName) method on the`MutableSubscriptionSet`. ```javascript realm.subscriptions.update((mutableSubs) => {   // remove a subscription with a specific name   mutableSubs.removeByName(\"longRunningTasksSubscription\"); }); \n``` #### Remove a Subscription by Reference If you have a reference to a subscription, you can remove that subscription. To do so, execute a transaction on the subscriptions set. Within the transaction, pass the reference variable to the [removeSubscription](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#removeSubscription) method on the`MutableSubscriptionSet`. ```javascript let subscriptionReference; realm.subscriptions.update((mutableSubs) => {   subscriptionReference = mutableSubs.add(realm.objects(\"Task\")); }); // later.. realm.subscriptions.removeSubscription(subscriptionReference); \n``` #### Remove All Subscriptions on an Object Type To remove all subscriptions on a specific object type, execute a transaction on the subscriptions set. Within the transaction, pass the object type as a string to the [removeByObjectType](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#removeByObjectType) method on the`MutableSubscriptionSet`. ```javascript realm.subscriptions.update((mutableSubs) => {   mutableSubs.removeByObjectType(\"Team\"); }); \n``` #### Remove All Subscriptions To remove all subscriptions from the subscriptions set, execute a transaction on the subscriptions set. Call the [removeAll()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#removeAll) method on the`MutableSubscriptionSet` within the transaction ```javascript realm.subscriptions.update((mutableSubs) => {   mutableSubs.removeAll(); }); \n``` ## Flexible Sync RQL Limitations Flexible Sync has some limitations when using RQL operators. When you write the [query subscription](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-flexible-sync-query-subscription)that determines which data to sync, the server does not support these query operators. However, you can still use the full range of RQL features to query the synced data set in the client application. ### Unsupported Query Operators in Flexible Sync | Operator Type       | Unsupported Operators          |\n| ------------------- | ------------------------------ |\n| Aggregate Operators | @avg, @count, @max, @min, @sum |\n| Query Suffixes      | DISTINCT, SORT, LIMIT          | Case insensitive queries (`[c]`) cannot use indexes effectively. As a result, case insensitive queries are not recommended, since they could lead to performance problems. Flexible Sync only supports `@count` for array fields. ### List Queries\n\n You can query a list of constants to see if it contains the value of a queryable field: ```javascript // Query a constant list for a queryable field value \"priority IN { 1, 2, 3 }\" \n``` If a queryable field has an array value, you can query to see if it contains a constant value: ```javascript // Query an array-valued queryable field for a constant value \"'comedy' IN genres\" \n``` ## Warning You **cannot** compare two lists with each other in a Flexible Sync query. Note that this is valid Realm Query Language syntax outside of Flexible Sync queries. ```javascript // Invalid Flexible Sync query. Do not do this! \"{'comedy', 'horror', 'suspense'} IN genres\" // Another invalid Flexible Sync query. Do not do this! \"ANY {'comedy', 'horror', 'suspense'} != ANY genres\" \n``` ### Embedded or Linked Objects Flexible Sync does not support querying on properties in Embedded Objects or links. For example, `obj1.field == \"foo\"`. ← [Open a Synced Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/ \"Previous Section\")[Pause or Resume a Sync Session - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/pause-or-resume-sync-session/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/app-services/connect-to-app-services-app/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Connect to an Atlas App Services App - React Native SDK ## Overview The App client is the interface to the App Services backend. It provides access to the [authentication functionality](https://mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-authenticate-users), [functions](https://mongodb.com/docs/realm/sdk/react-native/app-services/call-a-function/#std-label-react-native-call-a-function), and[sync management.](https://mongodb.com/docs/realm/sdk/react-native/sync-data/overview/#std-label-react-native-realm-sync) ## Access the App Client Pass the Realm App ID for your App, which you can [find in the Realm UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ## Configuration To set up your App client, pass a configuration object to an instance of `Realm.App`. ## Note `id` is a required field of the application configuration object. To see the full list of fields for the configuration object that `Realm.App` accepts as a parameter, view the [App Configuration Type Definitions.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#~AppConfiguration) ## Retrieve an Instance of the App Client To retrieve an instance of the App Client from anywhere in your application, call [Realm.App.getApp()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#getApp) and pass in your `App ID`. ← [App Services Overview - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/overview/ \"Previous Section\")[Call a Function - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/call-a-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/app-services/overview/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # App Services Overview - React Native SDK On this page * [Overview](#overview)\n* [The App Client](#the-app-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Calling Atlas Functions](#calling-atlas-functions)\n* [Accessing MongoDB](#accessing-mongodb) ## Overview Realm provides SDKs that help you connect your client apps to the Atlas App Services backend. The SDK provides the functionality needed to authenticate users with any of the built-in [authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), call backend [functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), and directly access a linked[MongoDB data source.](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) ## The App Client When using the SDK to access the App Services backend, you start with an App object. This object provides all other functionality related to App Services. The\\`\\`App\\`\\` object is[initialized](https://mongodb.com/docs/realm/sdk/react-native/app-services/connect-to-app-services-app/#std-label-react-native-connect-to-mongodb-realm-backend-app) with the App ID, which you can[find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ## Tip To learn how to initialize the App client, see[Connect to an Atlas App Services App - React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/app-services/connect-to-app-services-app/#std-label-react-native-connect-to-mongodb-realm-backend-app) ## Authentication & User Management One of the most challenging aspects of client development is implementing a robust and secure authentication system. With the Realm SDKs, however, you can use any of the App Services authentication providers with very minimal backend setup or client-side code required. With the authentication APIs, you can implement the following functionality: * Creation of new user accounts\n* User log-in and log-out\n* Multiple users logged on at the same time on the same device\n* Linking user accounts from different providers\n* Providing custom user data ## Tip To learn how to set up authentication with different providers, see[Authenticate Users - React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-authenticate-users) To learn how to manage multiple users, see [Multi-User Applications - React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/manage-users/multi-user-applications/#std-label-react-native-multi-user-applications) To learn how to link user accounts, see [Link User Identities - React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/manage-users/link-user-identities/#std-label-react-native-link-user-identities) To learn how to provide custom user data, see [Custom User Data - React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/manage-users/custom-user-data/#std-label-react-native-access-custom-user-data) ## Calling Atlas Functions [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) enable you to define and execute server-side logic for your application. You can call these functions from your client applications via the Realm SDKs. These server-side functions can run under the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your collections. By using Functions, you provide a secure way for a variety of client applications to share complex functionality without having to reproduce that logic client-side. ## Tip\n\n ## Accessing MongoDB The Realm SDKs include APIs for accessing a MongoDB Atlas instance directly. With these APIs, you can perform all of the standard CRUD operations from your client. For security, you configure server-side [data access rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules)to dynamically determine read & write permissions for every object that is accessed. ## Tip To learn how to use the MongoDB APIs, see [Query MongoDB.](https://mongodb.com/docs/realm/sdk/react-native/app-services/query-mongodb/#std-label-react-native-mongodb-data-access) ← [App Services - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/ \"Previous Section\")[Connect to an Atlas App Services App - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/connect-to-app-services-app/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/reset-a-client-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Reset a Client Realm - React Native SDK On this page * [Client Reset Modes](#client-reset-modes)\n* [Automatic vs. Manual Client Reset](#automatic-vs.-manual-client-reset)\n* [Client Reset with Recovery](#client-reset-with-recovery)\n* [Recover Unsynced Changes Mode](#recover-unsynced-changes-mode)\n* [Recover or Discard Unsynced Changes Mode](#recover-or-discard-unsynced-changes-mode)\n* [Manual Client Reset Fallback](#manual-client-reset-fallback)\n* [Discard Unsynced Changes Mode](#discard-unsynced-changes-mode)\n* [Discard Unsynced Changes after Breaking Schema Changes](#discard-unsynced-changes-after-breaking-schema-changes)\n* [Manual Mode](#manual-mode)\n* [Manual Data Recovery](#manual-data-recovery) A **client reset error** is a scenario where a client realm cannot sync data with the Atlas App Services backend. Clients in this state may continue to run and save data locally but cannot send or receive sync changesets until they perform a client reset. To learn about the causes of and modes for handling client resets, check out Device Sync [Client Resets in the App Services documentation.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) ## Client Reset Modes You can specify which **client reset mode** your app should use to restore the realm to a syncable state: * [Recover unsynced changes mode](#std-label-react-native-recover-unsynced-changes): When you choose this mode, the client attempts to recover unsynced changes. Choose this mode when you do not want to fall through to discard unsynced changes.\n* [Recover or discard unsynced changes mode](#std-label-react-native-recover-discard-unsynced-changes): The client first attempts to recover changes that have not yet synced. If the client cannot recover unsynced data, it falls through to discard unsynced changes but continues to automatically perform the client reset. Choose this mode when you want to enable automatic client recovery to fall back to discard unsynced changes.\n* [Discard unsynced changes mode](#std-label-react-native-discard-unsynced-changes): Restores the realm to a syncable state by discarding changes made since the last sync.\n* [Manual recovery mode](#std-label-react-native-manually-recover-unsynced-changes): Downloads a new copy of the realm, and moves the unsyncable realm to a backup. Migrate unsynced data from the backup copy of the realm to the new syncable copy. ## Automatic vs. Manual Client Reset The Realm SDKs provide client reset modes that automatically handle most client reset errors. Automatic client reset modes restore your local realm file to a syncable state without closing the realm or missing notifications. The following client reset modes support automatic client resets: * Recover unsynced changes mode\n* Recover or discard unsynced changes mode\n* Discard unsynced changes mode The differences between these modes are based on how they handle changes on the device that have not yet synced to the backend. Only manual recovery mode does not perform an automatic client reset. Choose recover unsynced changes mode to handle most client reset scenarios automatically. This attempts to recover unsynced changes when a client reset occurs. If your app requires specific client reset logic that can't be handled automatically, you may want or need to [add a manual client reset handler](#std-label-react-native-manually-recover-unsynced-changes)to the automatic client reset mode. ## Client Reset with Recovery _New in version 10.23.0_. Client Recovery is a feature that is enabled by default when you configure Device Sync. When Client Recovery is enabled, Realm Database automatically manages the client reset process in most cases. The client can recover unsynced changes when there are no schema changes, or non-breaking schema changes. To use Client Recovery, configure your realm with one of the following client reset modes: * Recover unsynced changes mode\n* Recover or discard unsynced changes\n\n * Objects created locally that were not synced before client reset are synced.\n* If an object is deleted on the server, but is modified on the recovering client, the delete takes precedence and the client discards the update.\n* If an object is deleted on the recovering client, but not the server, then the client applies the server's delete instruction.\n* In the case of conflicting updates to the same field, the client update is applied. For more information about configuring Client Recovery, refer to[Client Recovery](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-enable-or-disable-recovery-mode) in the App Services documentation. Client Recovery cannot succeed when your app makes breaking schema changes. A breaking change is a change that you can make in your server-side schema that requires additional action to handle. In this scenario, client reset falls back to a[manual error client reset fallback.](#std-label-react-native-manual-client-reset-fallback) For information on breaking vs. non-breaking schema changes, refer to[Breaking vs. Non-Breaking Change Quick Reference](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-breaking-change-quick-reference) in the App Services documentation. ### Recover Unsynced Changes Mode When you choose **recover unsynced changes** mode, the client attempts to recover unsynced changes with Client Recovery. Choose this mode when you do not want to fall through to discard unsynced changes. To handle client resets with the recover unsynced changes mode, pass a [ClientResetConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~ClientResetConfiguration)to the `clientReset` field of your[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration). Include these properties in the `ClientResetConfiguration`: * `mode`: Set to `\"recoverUnsyncedChanges\"`.\n* `onBefore`: Optional. Callback function invoked before the SDK executes this mode, when the SDK receives a client reset error from the backend. Provides a copy of the realm.\n* `onAfter`: Optional. Callback function invoked after the SDK successfully executes this mode. Provides instances of the realm before and after the client reset.\n* `onFallback`: Optional. Callback function which the SDK invokes only if the automatic recovery fails. For more information, refer to the[Manual Client Reset Fallback section.](#std-label-react-native-manual-client-reset-fallback) The following example implements recover unsynced changes mode:\n\n ` ### Recover or Discard Unsynced Changes Mode In **recover or discard unsynced changes** mode, the client first attempts to recover changes that have not yet synced. If the client cannot recover unsynced data, it falls through to discard unsynced changes but continues to automatically perform the client reset. Choose this mode when you want to enable automatic client recovery to fall back to discard unsynced changes. Do not use recover or discard unsynced changes mode if your application cannot lose local data that has not yet synced to the backend. To handle client resets with the recover or discard unsynced changes mode, pass a [ClientResetConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~ClientResetConfiguration)to the `clientReset` field of your[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration). Include these properties in the `ClientResetConfiguration`: * `mode`: Set to `\"recoverOrDiscardUnsyncedChanges\"`.\n* `onBefore`: Optional. Callback function invoked before the SDK executes this mode, when the SDK receives a client reset error from the backend. Provides a copy of the realm.\n* `onAfter`: Optional. Callback function invoked after the SDK successfully executes this mode. Provides instances of the realm before and after the client reset.\n* `onFallback()`: Optional. Callback function which the SDK invokes only if both the automatic recovery and and discarding changes fails. For more information, refer to the [Manual Client Reset Fallback section.](#std-label-react-native-manual-client-reset-fallback) The following example implements recover unsynced changes mode: ```js const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"recoverOrDiscardUnsyncedChanges\",       onBefore: (realm) => {         // This block could be used for custom recovery, reporting, debugging etc.       },       onAfter: (beforeRealm, afterRealm) => {         // This block could be used for custom recovery, reporting, debugging etc.       },       onFallback: (session, path) => {         // See below \"Manual Client Reset Fallback\" section for example       },     },   }, }; \n``` ### Manual Client Reset Fallback If the client reset with recovery cannot complete automatically, like when there are breaking schema changes, the client reset process falls through to a manual error handler. This may occur in either of the client reset with recovery modes, recover unsynced changes and recover or discard unsynced changes. You must provide a manual client reset implementation in the `SyncConfiguration.onFallback()` callback. `onFallback()` takes two arguments: * `session`: [Session](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html) object representing the state of the Device Sync session.\n* `path`: String with the path to the current realm database file. The following example demonstrates how you can manually handle this error case by discarding all unsynced changes: ```js // Must define `realm` at higher scope than `config` so it's accessible // from the `onFallback` callback let realm; const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"recoverOrDiscardUnsyncedChanges\", // or \"recoverUnsyncedChanges\"       // can also include `onBefore` and `onAfter` callbacks       onFallback: (_session, path) => {         try {           // Prompt user to perform a client reset immediately. If they don't,           // they won't receive any data from the server until they restart the app\n\n           const didUserConfirmReset = showUserAConfirmationDialog();           if (didUserConfirmReset) {             // Close and delete old realm from device             realm.close();             Realm.deleteFile(path);             // Perform client reset             Realm.App.Sync.initiateClientReset(app, path);             // Navigate the user back to the main page or reopen the             // the Realm and reinitialize the current page           }         } catch (err) {           // Reset failed. Notify user that they'll need to           // update the app         }       },     },   }, }; realm = await Realm.open(config); \n``` ## Discard Unsynced Changes Mode _New in version 10.11.0_. _Changed in version 10.23.0_: Mode renamed from \"discardLocal\" to \"discardUnsyncedChanges\". Both currently work, but in a future version, \"discardLocal\" will be removed. \"clientResetBefore\" and \"clientResetAfter\" callbacks renamed to \"onBefore\" and \"onAfter\", respectively. **Discard Unsynced Changes** mode permanently deletes all local unsynced changes made since the last successful sync. You might use this mode when your app requires client recovery logic that is not consistent with [automatic Client Recovery](#std-label-react-native-client-reset-recovery), or when you don't want to recover unsynced data. Do not use discard unsynced changes mode if your application cannot lose local data that has not yet synced to the backend. To handle client resets with the discard unsynced changes mode, pass a [ClientResetConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~ClientResetConfiguration)to the `clientReset` field of your[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration). Include these properties in the `ClientResetConfiguration`: * `mode`: Set to `\"discardUnsyncedChanges\"`.\n* `onBefore`: Optional. Callback function invoked before the SDK executes this mode, when the SDK receives a client reset error from the backend. Provides a copy of the realm.\n* `onAfter`: Optional. Callback function invoked after the SDK successfully executes this mode. Provides instances of the realm before and after the client reset. The following example implements discard unsynced changes mode: ```javascript const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"discardUnsyncedChanges\",       onBefore: (realm) => {         console.log(\"Beginning client reset for \", realm.path);       },       onAfter: (beforeRealm, afterRealm) => {         console.log(\"Finished client reset for\", beforeRealm.path);         console.log(\"New realm path\", afterRealm.path);       },     },   }, }; \n``` ### Discard Unsynced Changes after Breaking Schema Changes If your application experiences a breaking schema change, discard unsynced changes mode cannot handle the resulting client reset automatically. Instead, you must provide a manual client reset implementation in the SyncConfiguration `error()` callback. The following example demonstrates how you can manually handle this error case by discarding all unsynced changes: ```javascript // Once you have opened your Realm, you will have to keep a reference to it. // In the error handler, this reference is called `realm` async function handleSyncError(session, syncError) {\n\n     console.log(syncError);     try {       console.log(\"error type is ClientReset....\");       const path = realm.path; // realm.path will not be accessible after realm.close()       realm.close();       Realm.App.Sync.initiateClientReset(app, path);       // Download Realm from the server.       // Ensure that the backend state is fully downloaded before proceeding,       // which is the default behavior.       realm = await Realm.open(config);       realm.close();     } catch (err) {       console.error(err);     }   } else {     // ...handle other error types   } } const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"discardUnsyncedChanges\",       onBefore: (realm) => {         // NOT used with destructive schema changes         console.log(\"Beginning client reset for \", realm.path);       },       onAfter: (beforeRealm, afterRealm) => {         // Destructive schema changes do not hit this function.         // Instead, they go through the error handler.         console.log(\"Finished client reset for\", beforeRealm.path);         console.log(\"New realm path\", afterRealm.path);       },     },     error: handleSyncError, // invoked with destructive schema changes   }, }; \n``` ## Note ### Discard with Recovery If you'd like to attempt to recover unsynced changes, but but discard any changes that cannot be recovered, refer to the[recover or discard unsynced changes mode section.](#std-label-react-native-recover-discard-unsynced-changes) ## Manual Mode _Changed in version 10.23.0_: onManual callback added In **manual** mode, you define your own client reset handler. You might want to use a manual client reset handler if the Automatic Recovery logic does not work for your app and you can't discard unsynced local data. To handle client resets with manual mode, pass a [ClientResetConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~ClientResetConfiguration)to the `clientReset` field of your[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration). Include these properties in the `ClientResetConfiguration`: * `mode`: Set to `\"manual\"`.\n* `onManual`: Optional. Callback function invoked when the client reset occurs. Provides information about the sync session and the path to the current realm. If you don't set the `onManual` error handler, the client reset error falls back to the general sync error handler. ```js const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"manual\",       onManual: (session, path) => {         // handle manual client reset here       },     },   }, }; \n``` ### Manual Data Recovery To recover data from a manual client reset requires significant amounts of code, schema concessions, and custom conflict resolution logic. If you need to implement your own custom client reset logic, see the [Advanced Guide to Manual Client Reset Data Recovery.](https://mongodb.com/docs/realm/sdk/react-native/sync-data/client-reset-data-recovery/#std-label-react-native-advanced-manual-client-reset-data-recovery)\n\n",
  "https://www.mongodb.com/docs/realm/sdk/react-native/app-services/call-a-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call a Function - React Native SDK On this page * [Call a Function by Name](#call-a-function-by-name) The examples in this section demonstrate calling a simple Atlas Function named `sum` that takes two arguments, adds them, and returns the result: `| // sum: adds two numbers   |\n| -------------------------- |\n| exports = function(a, b) { |\n| return a + b;              |\n| };                         | ` ## Call a Function by Name ## Important Make sure to sanitize client data to protect against code injection when using Functions. To call a function, you can either pass its name and arguments to`User.callFunction()` or call the function as if it was a method on the[User.functions](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#functions) property. ## Note ### Link a MongoDB Atlas Data Source This example requires a Realm app with a linked[Atlas data source](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources). Replace`<appId>` in the code with your App ID, which you can find in the left navigation menu of the App Services UI. ```javascript // wrap the code below in an async function to 'await' for the promises to resolve const numA = 2; const numB = 3; const result = await user.functions.sum(numA, numB); const resultOfCallFunction = await user.callFunction(\"sum\", numA, numB); // alternate syntax to call a MongoDB Realm Function console.log(   `Using the \"functions.sum()\" method: the sum of ${numA} + ${numB} = ${result}` ); console.log(   `Using the \"callFunction()\" method: the sum of ${numA} + ${numB} = ${resultOfCallFunction}` ); \n``` When you run the code sample, your output should resemble the following: ``` Using the \"functions.sum()\" method: the sum of 2 + 3 = 5 Using the \"callFunction()\" method: the sum of 2 + 3 = 5 \n``` ← [Connect to an Atlas App Services App - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/connect-to-app-services-app/ \"Previous Section\")[Query MongoDB - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/query-mongodb/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/client-reset-data-recovery/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manual Client Reset Data Recovery - React Native SDK On this page * [Track Changes by Object Strategy](#track-changes-by-object-strategy)\n* [Example](#example)\n* [Include Last Updated Time in Your Schema](#include-last-updated-time-in-your-schema)\n* [Configure Realm to Use Manual Client Reset](#configure-realm-to-use-manual-client-reset)\n* [Track Synchronization in Separate Realm](#track-synchronization-in-separate-realm)\n* [Create Callback to Handle Client Reset](#create-callback-to-handle-client-reset)\n* [Alternative Strategies](#alternative-strategies) This page explains how to manually recover unsynced realm data after a client reset using the Manual Recovery client reset mode. Manual recovery requires significant amounts of code, schema concessions, and custom conflict resolution logic. You should only perform a manual recovery of unsynced realm data if you cannot lose unsynced data and the other automatic client reset methods do not meet your use case. For more information about the other available client reset modes, refer to[Reset a Client Realm.](https://mongodb.com/docs/realm/sdk/react-native/sync-data/reset-a-client-realm/#std-label-react-native-client-resets) The specifics of manual recovery depend heavily upon your application and your schema. However, there are a few techniques that can help with manual recoveries. The [Track Changes by Object Strategy section](#std-label-react-native-client-reset-track-changes-by-object) demonstrates one method of recovering unsynced changes during a client reset. ## Warning ### Avoid Making Breaking Schema Changes in Production Do not expect to recover all unsynced data after a breaking schema change. The best way to preserve user data is to never make a breaking schema change at all. ## Important ### Breaking Schema Changes Require an App Schema Update After a breaking schema change: * All clients must perform a client reset.\n* You must update client models affected by the breaking schema change. ## Track Changes by Object Strategy The **track changes by object** manual client reset data recovery strategy lets you recover data already written to the client realm file but not yet synced to the backend. In this strategy, you add a \"Last Updated Time\" to each object model to track when each object last changed. We'll watch the to determine when the realm last uploaded its state to the backend. When backend invokes a client reset, find objects that were deleted, created, or updated since the last sync with the backend. Then copy that data from the backup realm to the new realm. The following steps demonstrate implementing the process at a high level:\n\n ### Example This example demonstrates implementing the **track changes by object**manual client reset data recovery strategy. ## Note ### Limitations of This Example * This example only is for an application with a single realm containing a single Realm object type. For each additional object type, you'd need to add another sync listener as described in the[Track Synchronization in Separate Realm section.](#std-label-react-native-manual-client-reset-track-sync)\n* This example keeps track of the last time each _object_ was updated. As a result, the recovery operation overwrites the entire object in the new realm if any field was updated after the last successful sync of the backup realm. This could overwrite fields updated by other clients with old data from this client. If your realm objects contain multiple fields containing important data, consider keeping track of the last updated time of each _field_ instead, and recovering each field individually. For more information on other ways to perform a manual client reset with data recovery, refer to the [Alternative Strategies section.](#std-label-react-native-manual-client-reset-alternative-strategies) 1 #### Include Last Updated Time in Your Schema Add a new property to your Realm object schema to track the last time it was updated. Whenever you create or update a Realm object with the schema, include a timestamp with the update time. Ordinarily, there is no way to detect when a Realm object was last modified. This makes it difficult to determine which changes were synced to the backend. By adding a timestamp `lastUpdated` to your Realm object models and updating that timestamp to the current time whenever a change occurs, you can keep track of when objects were changed. `| const DogSchema = { |\n| ------------------- |\n| name: \"Dog\",        |\n| properties: {       |\n| name: \"string\",     |\n| age: \"int?\",        |\n| lastUpdated: \"int\", |\n| },                  |\n| };                  | ` 2 #### Configure Realm to Use Manual Client Reset In the realm's [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration), set the `clientReset` field to manual mode and include an `error` callback function. You'll define the error callback function in the[Create Callback to Handle Client Reset section.](#std-label-react-native-manual-client-reset-create-callback) ```javascript const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     partitionValue: \"MyPartitionValue\",     clientReset: {       mode: \"manual\",     },     error: handleSyncError, // callback function defined later   }, }; \n``` 3 #### Track Synchronization in Separate Realm Just knowing when objects were changed isn't enough to recover data during a client reset. You also need to know when the realm last completed a sync successfully. This example implementation uses a singleton object in a separate realm called `LastSynced`paired with a change listener to record when a realm finishes syncing successfully. Define your LastSynced Realm to track the latest time your realm synchronizes. ```javascript const LastSyncedSchema = {   name: \"LastSynced\",   properties: {     realmTracked: \"string\",     timestamp: \"int?\",   },   primaryKey: \"realmTracked\", }; const lastSyncedConfig = { schema: [LastSyncedSchema] }; const lastSyncedRealm = await Realm.open(lastSyncedConfig); lastSyncedRealm.write(() => {   lastSyncedRealm.create(\"LastSynced\", {     realmTracked: \"Dog\",   }); }); \n``` Register a change listener to subscribe to changes to the Dog collection. Only update the LastSynced object if the sync session is connected and all local changes have been synced with the server. ```javascript // Listens for changes to the Dogs collection realm.objects(\"Dog\").addListener(async () => {   // only update LastSynced if sync session is connected   // and all local changes are synced   if (realm.syncSession.isConnected()) {\n\n     lastSyncedRealm.write(() => {       lastSyncedRealm.create(\"LastSynced\", {         realmTracked: \"Dog\",         timestamp: Date.now(),       });     });   } }); \n``` 4 #### Create Callback to Handle Client Reset Now that you've recorded update times for all objects in your application as well as the last time your application completed a sync, it's time to implement the manual recovery process. This example handles two main recovery operations: * Restore unsynced inserts and updates from the backup realm\n* Delete objects from the new realm that were previously deleted from the backup realm You can follow along with the implementation of these operations in the code samples below. ```javascript async function handleSyncError(_session, error) {   if (error.name === \"ClientReset\") {     const realmPath = realm.path; // realm.path will not be accessible after realm.close()     realm.close(); // you must close all realms before proceeding     // pass your realm app instance and realm path to initiateClientReset()     Realm.App.Sync.initiateClientReset(app, realmPath);     // Redownload the realm     realm = await Realm.open(config);     const oldRealm = await Realm.open(error.config);     const lastSyncedTime = lastSyncedRealm.objectForPrimaryKey(       \"LastSynced\",       \"Dog\"     ).timestamp;     const unsyncedDogs = oldRealm       .objects(\"Dog\")       .filtered(`lastUpdated > ${lastSyncedTime}`);     // add unsynced dogs to synced realm     realm.write(() => {       unsyncedDogs.forEach((dog) => {         realm.create(\"Dog\", dog, \"modified\");       });     });     // delete dogs from synced realm that were deleted locally     const syncedDogs = realm       .objects(\"Dog\")       .filtered(`lastUpdated <= ${lastSyncedTime}`);     realm.write(() => {       syncedDogs.forEach((dog) => {         if (!oldRealm.objectForPrimaryKey(\"Dog\", dog._id)) {           realm.delete(dog);         }       });     });     // make sure everything syncs and close old realm     await realm.syncSession.uploadAllLocalChanges();     oldRealm.close();   } else {     console.log(`Received error ${error.message}`);   } } \n``` ## Alternative Strategies Possible alternate implementations include:\n\n ← [Reset a Client Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/sync-data/reset-a-client-realm/ \"Previous Section\")[Test & Debug - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/test-and-debug/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/crud/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - React Native SDK ← [Write Transactions - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/write-transactions/ \"Previous Section\")[CRUD - Create - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/open-and-close-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Open & Close a Realm - React Native SDK On this page * [Overview](#overview)\n* [Key Concept: Realm Files](#key-concept--realm-files)\n* [Open a Local Realm](#open-a-local-realm)\n* [Open an In Memory Realm](#open-an-in-memory-realm)\n* [Open an In-Memory Realm](#open-an-in-memory-realm-1)\n* [Close a Realm](#close-a-realm) ## Overview Realms are the core data structure used to organize data in Realm Database. At its core, a realm is a collection of the objects that you use in your application, called Realm objects, as well as additional metadata that describe the objects. This page details how to configure and open a realm using the React Native SDK. ## Key Concept: Realm Files Realm Database stores a binary encoded version of every object and type in a realm in a single `.realm` file. The file is located at a specific path that you define when you open the realm. ## Tip ### Implement Compacting in Your Production Application Every production application should implement a `shouldCompactOnLaunch`callback to periodically reduce the realm file size. ## Note ### Auxiliary Realm Files Realm Database creates additional files for each realm. To learn more about these files, see [Realm Database Internals.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/#std-label-react-native-realm-database) ## Warning ### Use Caution When Deleting Realm Files In some circumstances, such as a client reset scenario, you might need to delete a realm file and its auxiliary files. If you delete a realm file or any of its auxiliary files while one or more instances of the realm are open, you might corrupt the realm or disrupt [sync.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) You may safely delete these files when all instances of a realm are closed. Before you delete a realm file, make sure that you back up any important objects as you will lose all unsynced data in the realm. ## Open a Local Realm To open a local (non-synced) realm, pass a [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object to the asynchronous method [Realm.open().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open) ## Note ### Accessing the Default Realm Path If the `path` property is not specified in your `Configuration` object, the default path is used. You can access and change the default Realm path using the `Realm.defaultPath` global property.\n\n ` ## Open an In Memory Realm ### Open an In-Memory Realm To create a realm that runs entirely in memory without being written to a file, add `inMemory: true` to your [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object: ```javascript const realm = await Realm.open({   inMemory: true,   schema: [Car], }); \n``` ## Note In-memory realms may use disk space if memory is running low, but files created by an in-memory realm are deleted when you close the realm. ## Tip ### See also: Additional Ways to Configure a Realm * Learn how to [Open a Synced Realm](https://mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/#std-label-react-native-open-a-synced-realm)\n* Learn how to [Encrypt a Realm](https://mongodb.com/docs/realm/sdk/react-native/realm-database/encrypt/#std-label-react-native-encrypt-a-realm)\n* Learn how to [Bundle a Realm](https://mongodb.com/docs/realm/sdk/react-native/realm-database/bundle/#std-label-react-native-bundle-a-realm) ## Close a Realm It is important to remember to call the `close()` method when done with a realm instance to avoid memory leaks. ```javascript realm.close(); \n``` ← [Define an Asymmetric Object - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/asymmetric-object/ \"Previous Section\")[Write Transactions - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/write-transactions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/encrypt/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Encrypt a Realm - React Native SDK On this page * [Overview](#overview)\n* [Considerations](#considerations)\n* [Storing & Reusing Keys](#storing---reusing-keys)\n* [Performance Impact](#performance-impact)\n* [Encryption and Atlas Device Sync](#encryption-and-atlas-device-sync)\n* [Accessing an Encrypted Realm from Multiple Processes](#accessing-an-encrypted-realm-from-multiple-processes)\n* [Example](#example) ## Overview You can encrypt the realm database file on disk with AES-256 + SHA-2 by supplying a 64-byte encryption key when [opening a realm.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/open-and-close-a-realm/#std-label-react-native-open-a-local-realm) Realm transparently encrypts and decrypts data with standard[AES-256 encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) using the first 256 bits of the given 512-bit encryption key. Realm uses the other 256 bits of the 512-bit encryption key to validate integrity using a [hash-based message authentication code (HMAC).](https://en.wikipedia.org/wiki/HMAC) ## Warning Do not use cryptographically-weak hashes for realm encryption keys. For optimal security, we recommend generating random rather than derived encryption keys. ## Considerations The following are key impacts to consider when encrypting a realm. ### Storing & Reusing Keys You **must** pass the same encryption key every time you open the encrypted realm. If you don't provide a key or specify the wrong key for an encrypted realm, the Realm SDK throws an error. Apps should store the encryption key securely, typically in the target platform's secure key/value storage, so that other apps cannot read the key. ### Performance Impact Reads and writes on encrypted realms can be up to 10% slower than unencrypted realms. ### Encryption and Atlas Device Sync You can encrypt a [synced realm.](https://mongodb.com/docs/realm/sdk/react-native/sync-data/open-a-synced-realm/#std-label-react-native-open-a-synced-realm) Realm only encrypts the data on the device and stores the data unencrypted in your Atlas data source. Any users with authorized access to the Atlas data source can read the data, but the following still applies: * Users must have the correct read [permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read the synced data.\n* Data stored in Atlas is always encrypted at a volume (disk) level.\n* The transfer between client and server is always fully encrypted. You can also enable [Customer Key Management](https://www.mongodb.com/docs/atlas/security-kms-encryption/)to encrypt stored Atlas data using your cloud provider's key (e.g. AWS KMS, Azure Key Vault, Google Cloud KMS). If you need unique keys for each user of your application, you can use an OAuth provider or use one of the [Realm authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication)and an [authentication trigger](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-triggers)to create a 64-bit key and store that key in a [user object.](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) ### Accessing an Encrypted Realm from Multiple Processes You cannot open the same encrypted realm from multiple processes. Attempting to do so will throw the following error:`Encrypted interprocess sharing is currently unsupported.` If multiple processes need to access a realm simultaneously, use an unencrypted realm. ## Example The following code demonstrates how to generate an encryption key and open an encrypted realm:\n\n",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/write-transactions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Write Transactions - React Native SDK On this page * [Transaction Lifecycle](#transaction-lifecycle) A write transaction is a function that modifies objects in a realm. Write transactions let you create, modify, or delete Realm objects. They handle operations in a single, idempotent update. A transaction is_all or nothing_. Either: * All the operations in the transaction succeed, or;\n* If any operation fails, none of the operations complete. ## Important Every write operation must occur in a write transaction. ## Example Write transactions are callback functions that you pass to a realm instance. For examples of specific write operations, see[CRUD - Create - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/create/#std-label-react-native-create-objects) or [CRUD - Update - React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/update/#std-label-react-native-update-objects) `| const realm = await Realm.open();   |\n| ----------------------------------- |\n| realm.write(() => {                 |\n| const tesla = realm.create(\"Car\", { |\n| make: \"Tesla\",                      |\n| model: \"Model S\",                   |\n| year: 2020,                         |\n| miles: 12000                        |\n| })                                  |\n| const honda = realm.create(\"Car\", { |\n| make: \"Honda\",                      |\n| model: \"Civic\",                     |\n| year: 2018,                         |\n| miles: 30000                        |\n| })                                  |\n| })                                  | ` ## Transaction Lifecycle A given realm only processes one write transaction at a time. When you make a write transaction, the realm adds the transaction to a queue. The realm evaluates each transaction in the order it arrived. After processing a transaction, Realm Database either **commits** it or**cancels** it: * After a **commit**, the realm applies all operations in the transaction. Once applied, the realm automatically updates [live queries](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-live-queries). It notifies listeners of created, modified, and deleted objects.  \n## Note  \nWhen using [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), the SDK also queues the changes to send to Atlas App Services. The SDK sends these changes when a network is available.\n* Realm Database does not apply any operations in a **cancelled**transaction. Realm Database cancels a transaction if an operation fails or is invalid. ← [Open & Close a Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/open-and-close-a-realm/ \"Previous Section\")[CRUD - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/bundle/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Bundle a Realm File - React Native SDK On this page * [Procedure](#procedure)\n* [Create a Realm File to Bundle](#create-a-realm-file-to-bundle)\n* [Bundle the Realm File with your App](#bundle-the-realm-file-with-your-app)\n* [Open the Bundled Realm in your App](#open-the-bundled-realm-in-your-app)\n* [Bundle a Synchronized Realm](#bundle-a-synchronized-realm) Realm supports **bundling** realm files. When you bundle a realm file, you include a database and all of its data in your application download. This allows users to start applications for the first time with a set of initial data. For synced realms, bundling can avoid a lengthy initial download the first time a user opens your application. Instead, users must only download the synced changes that occurred since you generated the bundled file. ## Warning ### Does Not Apply to Expo Apps This procedure doesn't work for [React Native apps created with Expo.](https://mongodb.com/docs/realm/sdk/react-native/bootstrap-with-expo/#std-label-react-native-client-bootstrap-with-expo) ## Procedure Follow these steps to create and bundle a realm file for your React Native application. On a high level you: 1. Create a bundled realm file in a Node.js script.\n2. Copy the bundled realm to the iOS and/or Android builds for your application.\n3. Call `Realm.copyBundledRealmFiles()` before you open the bundled Realm in your React Native JavaScript code. ## Note ### Bundle Synchronized Realms SDK version 10.12.0 introduced the ability to bundle synchronized realms. Before version 10.12.0, you could only bundle local realms. For details on considerations and limitations when bundling a synchronized realm,[see the Bundle a Synchronized Realm section.](#std-label-react-native-bundle-synced-realm) 1 ### Create a Realm File to Bundle The easiest way to create a bundled realm for your React Native app is to write a separate Node.Js script to create the bundle.\n\n 2 ### Bundle the Realm File with your App Now that you have a copy of the realm that contains the initial data, add the bundled realm file to your production application. Where you place the bundled realm differs for iOS and Android builds. 3 ### Open the Bundled Realm in your App The realm is now bundled and will be included when a user downloads the app. To add the bundled realm file to your app's document directory, call[Realm.copyBundledRealmFiles()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.copyBundledRealmFiles)before you [open the realm.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/open-and-close-a-realm/#std-label-react-native-open-close-realm) `Realm.copyBundledRealmFiles()` adds all `*.realm` files from the application bundle to the application documents directory. This method doesn't override any existing files with the same name, so it's safe to call every time the app starts. Open the bundled realm with the same name and configuration that you specified when you initially created the bundled realm. Now that you have a copy of the realm included with your production application, you need to add code to use it. ```javascript Realm.copyBundledRealmFiles(); realm = await Realm.open({   schema: [Dog],   path: 'bundle.realm', }); \n``` ## Bundle a Synchronized Realm Generally, bundling a synchronized realm works the same as bundling a local-only realm. However, there are some limitations to bundling realms that use Device Sync. 1. You can only bundle fully synchronized realms. Make sure that the realm has fully synchronized with the server before bundling:  \n```javascript  \nconst config = {  \n  sync: {  \n    user: app.currentUser,  \n    partitionValue: app.currentUser.id,  \n  },  \n  schema: [Car],  \n};  \nconst realm = await Realm.open(config);  \n// create many changes  \nrealm.write(() => {  \n  for (let i = 0; i < 25; i++) {  \n    realm.create(\"Car\", {  \n      make: \"Toyota\",  \n      model: \"Prius\",  \n      miles: i,  \n      owner: app.currentUser.id,  \n    });  \n  }  \n});  \n// ensure synchronize all changes before copy  \nawait realm.syncSession.uploadAllLocalChanges();  \nawait realm.syncSession.downloadAllServerChanges();  \n// changes are synchronized -- we can copy the realm  \nrealm.writeCopyTo(__dirname + \"syncedCopy.realm\");  \n```\n2. When opening a bundled synchronized realm, you must use the same partition key that was used in the original realm. If you use a different partition key, the SDK throws an error when opening the bundled realm. ## Warning ### Synchronized Realm Bundling and Client Maximum Offline Time If your application has enabled [advanced backend compaction](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-advanced-backend-compaction) by configuring a[client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), users could experience a client reset the first time they open the bundled realm file. This can happen if: * the bundled realm file was generated more than**client maximum offline time** days before the user syncs the realm for the first time. Users experiencing a client reset download the full state of the realm from the application backend. This negates the advantages of bundling a realm file. To prevent client resets and preserve the advantages of realm file bundling:\n\n ← [Encrypt a Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/encrypt/ \"Previous Section\")[App Services - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Define a Realm Object Model - React Native SDK On this page * [Key Concept: Object Types & Schemas](#key-concept--object-types---schemas)\n* [Realm Schema](#realm-schema)\n* [Define a New Object Type](#define-a-new-object-type)\n* [Define Realm Object Types with JavaScript Classes](#define-realm-object-types-with-javascript-classes) ## Key Concept: Object Types & Schemas Every Realm object conforms to a specific **object type**, which is essentially a class that defines the properties and [relationships](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-client-relationships)for objects of that type using a pre-defined schema. Realm guarantees that all objects in a realm conform to the schema for their object type and validates objects whenever they're created, modified, or deleted. Realm objects are fundamentally similar to a common JavaScript object but they also bring along a few additional features like schema validation and [live queries](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-live-queries). The React Native SDK memory maps Realm objects directly to native JavaScript objects, which means there's no need to use a special data access library, such as an [ORM](https://en.wikipedia.org/wiki/Object-relational%5Fmapping). Instead, you can work with Realm objects as you would any other object. ### Realm Schema A **realm schema** is a list of valid [object schemas](#std-label-react-native-object-schemas) that a realm may contain. Every Realm object must conform to an object type that's included in its realm's schema. If a realm already contains data when you open it, Realm Database validates each object to ensure that an object schema was provided for its type and that it meets all of the constraints specified in the schema. ## Example A realm that contains basic data about books in libraries might use a schema like the following:\n\n ` ## Define a New Object Type To define a Realm object type, create a schema object that specifies the type's`name` and `properties`. The type name must be unique among object types in a realm. ```javascript const CarSchema = {   name: \"Car\",   properties: {     make: \"string\",     model: \"string\",     miles: \"int\",   } } \n``` ## Note Class names are limited to a maximum of 57 UTF-8 characters. You can then [open a realm](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-open-a-local-realm) using the Realm Object you have defined. ```javascript // Open a local realm file with a particular path & predefined Car schema try {   const realm = await Realm.open({     path: \"myrealm\",     schema: [Car],   }); } catch (err) {   console.error(\"Failed to open the realm\", err.message); } \n``` ## Note To learn the various types that a Realm Object Model accepts, how to specify optional fields, define relationships, embedded objects, primary keys, and more, check out the [Schemas](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/overview/#std-label-react-native-schemas-overview) section. ## Define Realm Object Types with JavaScript Classes You can define Realm object types with JavaScript classes. To use a class as an object type, define the object schema on the static property `schema`. ```javascript class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: { type: 'objectId', default: () => new Realm.BSON.ObjectId() },       make: \"string\",       model: \"string\",       miles: \"int?\",     },     primaryKey: '_id',   }; } \n``` Pass the class itself to the schema property of the [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object when opening a realm. You can then [read and write](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/) normally. ```javascript const realm = await Realm.open({   path: \"myrealm\",   schema: [Car], }); let car1; realm.write(() => {   car1 = realm.create(Car, {     make: \"Nissan\",     model: \"Sentra\",     miles: 1000,   }); }); \n``` ← [Realm Database - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/ \"Previous Section\")[Change an Object Model - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/change-an-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - React Native SDK On this page * [Register a Realm Change Listener](#register-a-realm-change-listener)\n* [Register a Collection Change Listener](#register-a-collection-change-listener)\n* [Register an Object Change Listener](#register-an-object-change-listener)\n* [Remove All Change Listeners](#remove-all-change-listeners) ## Register a Realm Change Listener To register a change listener for an entire realm, pass a callback function to the realm's [addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#addListener) method. Realm Database calls the listener asynchronously whenever an operation adds, changes, or removes objects in the realm. To remove a realm listener, pass the callback to the realm's [removeListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#removeListener) method. ## Tip ### Use Object & Collection Listeners for Change Details Realm Database does not pass any information about what changed to realm listener callback functions. If you need to know more information about what changed in an object or collection, use [object listeners](#std-label-react-native-object-listener) and [collection listeners.](#std-label-react-native-collection-listener) ## Tip ### Handling Exceptions Inside a Listener To handle exceptions thrown from a change listener, wrap your `addListener()` call within a [try...catch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch) statement.\n\n  `` ## Register a Collection Change Listener To register a change listener for a collection of Realm objects, pass a callback function to the collection's [addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#addListener) method. Realm Database calls the listener asynchronously when it's registered as well as whenever an operation adds, changes, or removes objects in the collection. To remove a collection listener, pass the callback to the collection's [removeListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#removeListener) method. ## Important ### Order Matters In collection notification handlers, always apply changes in the following order: deletions, insertions, then modifications. Handling insertions before deletions may result in unexpected behavior. ```javascript // You can define a listener for any collection of Realm objects const dogs = realm.objects(\"Dog\"); // Define a listener callback function for changes to any Dog function onDogsChange(dogs, changes) {   // Handle deleted Dog objects   changes.deletions.forEach((index) => {     // You cannot directly access deleted objects,     // but you can update a UI list, etc. based on the index.     console.log(`Looks like Dog #${index} has left the realm.`);   });   // Handle newly added Dog objects   changes.insertions.forEach((index) => {     const insertedDog = dogs[index];     console.log(`Welcome our new friend, ${insertedDog.name}!`);   });   // Handle Dog objects that were modified   changes.modifications.forEach((index) => {     const modifiedDog = dogs[index];     console.log(`Hey ${modifiedDog.name}, you look different!`);   }); } // Add the listener callback to the collection of dogs try {   dogs.addListener(onDogsChange); } catch (error) {   console.error(     `An exception was thrown within the change listener: ${error}`   ); } // Remember to remove the listener when you're done! dogs.removeListener(onDogsChange); \n``` ## Register an Object Change Listener To register a change listener on a specific Realm object, pass a callback function to the object's [addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#addListener) method. Realm Database calls the listener if any of the object's properties change or if someone deletes the object. To remove an object listener, pass the callback to the object's[removeListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#removeListener) method. ```javascript // Define a listener callback function for changes to a specific Dog function onDogChange(dog, changes) {   if (changes.deleted) {     console.log(`dog is deleted: ${changes.deleted}`);   } else {     changes.changedProperties.forEach((prop) => {       console.log(`* the value of \"${prop}\" changed to ${dog[prop]}`);     });   } } // You can define a listener for any Realm object try {   dog.addListener(onDogChange); } catch (error) {   console.error(     `An exception was thrown within the change listener: ${error}`   ); } // Remember to remove the listeners when you're done! dog.removeListener(onDogChange); \n``` ## Remove All Change Listeners To remove **all** listeners on a given realm, object, or collection instance, call the instance's `removeAllListeners()` function: * [Realm.removeAllListeners()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#removeAllListeners)\n* [Realm.Collection.removeAllListeners()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#removeAllListeners)\n* [Realm.Object.removeAllListeners()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#removeAllListeners) ```javascript\n\n realm.removeAllListeners(); // Remove all listeners from a collection dogs.removeAllListeners(); // Remove all listeners from an object dog.removeAllListeners(); \n``` ← [Query Data - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/query-data/ \"Previous Section\")[Encrypt a Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/encrypt/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/app-services/query-mongodb/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query MongoDB - React Native SDK On this page * [Use Cases](#use-cases)\n* [Prerequisites](#prerequisites)\n* [Connect to a Linked Cluster](#connect-to-a-linked-cluster)\n* [Read Operations](#read-operations)\n* [Find a Single Document](#find-a-single-document)\n* [Find Multiple Documents](#find-multiple-documents)\n* [Count Documents](#count-documents)\n* [Write Operations](#write-operations)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Update a Single Document](#update-a-single-document)\n* [Update Multiple Documents](#update-multiple-documents)\n* [Upsert Documents](#upsert-documents)\n* [Delete a Single Document](#delete-a-single-document)\n* [Delete Multiple Documents](#delete-multiple-documents)\n* [Real-time Change Notifications](#real-time-change-notifications)\n* [Watch for All Changes in a Collection](#watch-for-all-changes-in-a-collection)\n* [Watch for Specific Changes in a Collection](#watch-for-specific-changes-in-a-collection)\n* [Aggregation Operations](#aggregation-operations)\n* [Run an Aggregation Pipeline](#run-an-aggregation-pipeline) You can query data stored in MongoDB Atlas directly from your client application code by using the Realm React Native SDK's [MongoDB client](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm-MongoDB.html)with the [Query API](https://www.mongodb.com/docs/manual/tutorial/query-documents/). Atlas App Services provides data access [rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) on collections to securely retrieve results based on the logged-in user or the content of each document. ## Note ### Example Dataset The examples on this page use a MongoDB collection that describes inventory in a chain of plant stores. For more information on the collection schema and document contents, see [Example Data.](#std-label-react-native-mongodb-example-dataset) ## Use Cases There are a variety of reasons you might want to query a MongoDB data source. Working with data in your client via Atlas Device Sync is not always practical or possible. You might want to query MongoDB when: * The data set is large or the client device has constraints against loading the entire data set\n* You are [creating or updating custom user data](https://mongodb.com/docs/realm/sdk/react-native/manage-users/custom-user-data/#std-label-react-native-access-custom-user-data)\n* You are retrieving documents that are not modeled in Realm\n* Your app needs to access collections that don't have strict schemas\n* A non-Realm service generates collections that you want to access While not exhaustive, these are some common use cases for querying MongoDB directly. ## Prerequisites Before you can query MongoDB from your React Native application, you must set up MongoDB Data Access in your App Services App. To learn how to set up your backend App to let the Realm SDK query Atlas, refer to [Set Up MongoDB Data Access](https://www.mongodb.com/docs/atlas/app-services/mongodb/data-access/#std-label-client-data-access)in the App Services documentation. ## Example ### Example Data The examples on this page use the following MongoDB collection that describes various plants for sale in a chain of plant stores:\n\n ` Documents in the `plants` collection use the following schema: ## Connect to a Linked Cluster To access a linked cluster from your client application, pass the cluster name to [User.mongoClient()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#mongoClient). This returns a MongoDB service interface that you can use to access databases and collections in the cluster. ## Read Operations ### Find a Single Document To find a single document, pass a query that matches the document to[collection.findOne()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#findOne). If you do not pass a query, `findOne()` matches the first document it finds in the collection. The following snippet finds the document that describes \"venus flytrap\" plants in the[collection of documents that describe plants for sale in a group of stores:](#std-label-react-native-mongodb-example-dataset) ```js const venusFlytrap = await plants.findOne({ name: \"venus flytrap\" }); console.log(\"venusFlytrap\", venusFlytrap); \n``` HIDE OUTPUT `| {                                          |\n| ------------------------------------------ |\n| _id: ObjectId(\"5f87976b7b800b285345a8b4\"), |\n| name: \"venus flytrap\",                     |\n| sunlight: \"full\",                          |\n| color: \"white\",                            |\n| type: \"perennial\",                         |\n| _partition: \"Store 42\",                    |\n| }                                          | ` ### Find Multiple Documents To find multiple documents, pass a query that matches the documents to[collection.find()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#find). If you do not pass a query, `find()` matches all documents in the collection. The following snippet finds all documents that describe perennial plants in the[collection of documents that describe plants for sale in a group of stores:](#std-label-react-native-mongodb-example-dataset) ```js const perennials = await plants.find({ type: \"perennial\" }); console.log(\"perennials\", perennials); \n``` HIDE OUTPUT ```js [   { _id: ObjectId(\"5f87976b7b800b285345a8b4\"), name: 'venus flytrap', sunlight: 'full', color: 'white', type: 'perennial', _partition: 'Store 42' },   { _id: ObjectId(\"5f87976b7b800b285345a8b6\"), name: 'thai basil', sunlight: 'partial', color: 'green', type: 'perennial', _partition: 'Store 42' },   { _id: ObjectId(\"5f879f83fc9013565c23360e\"), name: 'lily of the valley', sunlight: 'full', color: 'white', type: 'perennial', _partition: 'Store 47' },   { _id: ObjectId(\"5f87a0defc9013565c233611\"), name: 'rhubarb', sunlight: 'full', color: 'red', type: 'perennial', _partition: 'Store 47' },\n\n   { _id: ObjectId(\"5f87a0dffc9013565c233613\"), name: 'daffodil', sunlight: 'full', color: 'yellow', type: 'perennial', _partition: 'Store 42' } ] \n``` ### Count Documents To count documents, pass a query that matches the documents to[collection.count()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#count). If you do not pass a query, `count()` counts all documents in the collection. The following snippet counts the number of documents in a [collection of documents that describe plants for sale in a group of stores:](#std-label-react-native-mongodb-example-dataset) ```js const numPlants = await plants.count(); console.log(`There are ${numPlants} plants in the collection`); \n``` HIDE OUTPUT ```js \"There are 9 plants in the collection\" \n``` ## Write Operations ### Insert a Single Document To insert a single document, pass it to [collection.insertOne().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#insertOne) The following snippet inserts a single document describing a \"lily of the valley\" plant into a [collection of documents that describe plants for sale in a group of stores:](#std-label-react-native-mongodb-example-dataset) ```js const result = await plants.insertOne({   name: \"lily of the valley\",   sunlight: \"full\",   color: \"white\",   type: \"perennial\",   _partition: \"Store 47\", }); console.log(result); \n``` HIDE OUTPUT ```js {   insertedId: \"5f879f83fc9013565c23360e\", } \n``` ### Insert Multiple Documents To insert multiple documents at the same time, pass them as an array to[collection.insertMany().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#insertMany) The following snippet inserts three documents describing plants into a[collection of documents that describe plants for sale in a group of stores:](#std-label-react-native-mongodb-example-dataset) ```js const result = await plants.insertMany([   {     name: \"rhubarb\",     sunlight: \"full\",     color: \"red\",     type: \"perennial\",     _partition: \"Store 47\",   },   {     name: \"wisteria lilac\",     sunlight: \"partial\",     color: \"purple\",     type: \"perennial\",     _partition: \"Store 42\",   },   {     name: \"daffodil\",     sunlight: \"full\",     color: \"yellow\",     type: \"perennial\",     _partition: \"Store 42\",   }, ]); console.log(result); \n``` HIDE OUTPUT ```js {   insertedIds: [     \"5f87a0defc9013565c233611\",     \"5f87a0dffc9013565c233612\",     \"5f87a0dffc9013565c233613\",   ], } \n``` ### Update a Single Document To update a single document, pass a query that matches the document and an update document to [collection.updateOne().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#updateOne) The following snippet updates a single document in a [collection of documents that describe plants for sale in a group of stores](#std-label-react-native-mongodb-example-dataset). This operation queries for a document where the`name` field contains the value \"petunia\" and changes the value of the first matched document's `sunlight` field to \"partial\": ```js const result = await plants.updateOne(   { name: \"petunia\" },   { $set: { sunlight: \"partial\" } } );\n\n \n``` HIDE OUTPUT ```js { matchedCount: 1, modifiedCount: 1 } \n``` ### Update Multiple Documents To update multiple documents simultaneously, pass a query that matches the documents and an update description to [collection.updateMany().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#updateMany) The following snippet updates multiple documents in a [collection of documents that describe plants for sale in a group of stores](#std-label-react-native-mongodb-example-dataset). This operation queries for documents where the`_partition` field contains the value \"Store 47\" and changes the value of the`_partition` field of each matching document to \"Store 51\": ```js const result = await plants.updateMany(   { _partition: \"Store 47\" },   { $set: { _partition: \"Store 51\" } } ); console.log(result); \n``` HIDE OUTPUT ```js { matchedCount: 3, modifiedCount: 3 } \n``` ### Upsert Documents To upsert a document, set the `upsert` option to `true` in your update operation. If the operation's query does not match any document in the collection, an upsert automatically inserts a single new document into the collection that matches the provided query document with the update applied to it. The following snippet updates a document in a [collection of documents that describe plants for sale in a group of stores](#std-label-react-native-mongodb-example-dataset)with an upsert operation. The query doesn't match any existing documents, so MongoDB automatically creates a new one. ```js const result = await plants.updateOne(   {     sunlight: \"full\",     type: \"perennial\",     color: \"green\",     _partition: \"Store 47\",   },   { $set: { name: \"sweet basil\" } },   { upsert: true } ); console.log(result); \n``` HIDE OUTPUT ```js {   matchedCount: 0,   modifiedCount: 0,   upsertedId: ObjectId(\"5f1f63055512f2cb67f460a3\"), } \n``` ### Delete a Single Document To delete a single document from a collection, pass a query that matches the document to [collection.deleteOne()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#deleteOne). If you do not pass a query or if the query matches multiple documents, then the operation deletes the first document it finds. The following snippet deletes one document in a [collection of documents that describe plants for sale in a group of stores](#std-label-react-native-mongodb-example-dataset). This operation queries for a document where the `color` field has a value of \"green\" and deletes the first document that matches the query: ```js const result = await plants.deleteOne({ color: \"green\" }); console.log(result); \n``` HIDE OUTPUT ```js { deletedCount: 1 } \n``` ### Delete Multiple Documents To delete multiple document from a collection, pass a query that matches the documents to [collection.deleteMany()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#deleteMany). If you do not pass a query,`deleteMany()` deletes all documents in the collection. The following snippet deletes all documents for plants that are in \"Store 51\" in a [collection of documents that describe plants for sale in a group of stores:](#std-label-react-native-mongodb-example-dataset) ```js const result = await plants.deleteMany({   _partition: \"Store 51\", }); console.log(result); \n``` HIDE OUTPUT ```js { deletedCount: 3 } \n``` ## Real-time Change Notifications\n\n ## Note `collection.watch()` returns an [async generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of#Iterating%5Fover%5Fasync%5Fgenerators)that allows you to asynchronously pull [change events](https://www.mongodb.com/docs/manual/reference/change-events/) for operations as they occur. ## Important ### Serverless Limitations You cannot watch for changes if the data source is an Atlas serverless instance. MongoDB serverless currently does not support change streams, which are used on watched collections to listen for changes. ### Watch for All Changes in a Collection To watch for all changes in a collection, call [collection.watch()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#watch) with no arguments: ```javascript for await (const change of plants.watch()) {   switch (change.operationType) {     case \"insert\": {       const { documentKey, fullDocument } = change;       console.log(`new document: ${documentKey}`, fullDocument);       break;     }     case \"update\": {       const { documentKey, fullDocument } = change;       console.log(`updated document: ${documentKey}`, fullDocument);       break;     }     case \"replace\": {       const { documentKey, fullDocument } = change;       console.log(`replaced document: ${documentKey}`, fullDocument);       break;     }     case \"delete\": {       const { documentKey } = change;       console.log(`deleted document: ${documentKey}`);       break;     }   } } \n``` ### Watch for Specific Changes in a Collection To watch for specific changes in a collection, pass a query that matches[change event](https://www.mongodb.com/docs/manual/reference/change-events/) fields to[collection.watch():](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#watch) ```javascript for await (const change of plants.watch({   filter: {     operationType: \"insert\",     \"fullDocument.type\": \"perennial\",   }, })) {   // The change event will always represent a newly inserted perennial   const { documentKey, fullDocument } = change;   console.log(`new document: ${documentKey}`, fullDocument); } \n``` ## Aggregation Operations Aggregation operations run all documents in a collection through a series of stages called an [aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/). Aggregation allows you to filter and transform documents, collect summary data about groups of related documents, and other complex data operations. ### Run an Aggregation Pipeline To execute an aggregation pipeline, pass an array of aggregation stages to[collection.aggregate()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#aggregate). Aggregation operations return the result set of the last stage in the pipeline. The following snippet groups all documents in the `plants` collection by their`type` value and aggregates a count of the number of each type: ```js const result = await plants.aggregate([   {     $group: {       _id: \"$type\",       total: { $sum: 1 },     },   },   { $sort: { _id: 1 } }, ]); console.log(result); \n``` HIDE OUTPUT ```js [   { _id: \"annual\", total: 1 },   { _id: \"perennial\", total: 5 }, ] \n``` #### Filter Documents\n\n ```javascript {   \"$match\": {     \"<Field Name>\": <Query Expression>,     ...   } } \n``` ## Example The following `$match` stage filters documents to include only those where the `type` field has a value equal to \"perennial\": ```js const perennials = await plants.aggregate([   { $match: { type: { $eq: \"perennial\" } } }, ]); console.log(perennials); \n``` VIEW OUTPUT #### Group Documents You can use the [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/) stage to aggregate summary data for one or more documents. MongoDB groups documents based on the expression defined in the `_id` field of the `$group` stage. You can reference a specific document field by prefixing the field name with a `$`. ```javascript {   \"$group\": {     \"_id\": <Group By Expression>,     \"<Field Name>\": <Aggregation Expression>,     ...   } } \n``` ## Example The following `$group` stage arranges documents by the value of their`type` field and calculates the number of plant documents that each unique `type` value appears in. ```js const result = await plants.aggregate([   {     $group: {       _id: \"$type\",       numItems: { $sum: 1 },     },   },   { $sort: { _id: 1 } }, ]); console.log(result); \n``` VIEW OUTPUT #### Project Document Fields You can use the [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) stage to include or omit specific fields from documents or to calculate new fields using[aggregation operators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). Projections work in two ways: * Explicitly include fields with a value of 1\\. This has the side-effect of implicitly excluding all unspecified fields.\n* Implicitly exclude fields with a value of 0\\. This has the side-effect of implicitly including all unspecified fields. These two methods of projection are mutually exclusive: if you explicitly include fields, you cannot explicitly exclude fields, and vice versa. ## Note The `_id` field is a special case: it is always included in every query unless explicitly specified otherwise. For this reason, you_can_ exclude the `_id` field with a `0` value while simultaneously including other fields, like `_partition`, with a `1`. Only the special case of exclusion of the `_id` field allows both exclusion and inclusion in one `$project` stage. ```javascript {   \"$project\": {     \"<Field Name>\": <0 | 1 | Expression>,     ...   } } \n``` ## Example The following `$project` stage omits the `_id` field, includes the `name` field, and creates a new field named `storeNumber`. The `storeNumber` is generated using two aggregation operators: 1. `$split` separates the `_partition` value into two string segments surrounding the space character. For example, the value \"Store 42\" split in this way returns an array with two elements: \"Store\" and \"42\".\n2. `$arrayElemAt` selects a specific element from an array based on the second argument. In this case, the value `1` selects the second element from the array generated by the `$split` operator since arrays index from `0`. For example, the value \\[\"Store\", \"42\"\\] passed to this operation would return a value of \"42\". ```js const result = await plants.aggregate([   {     $project: {       _id: 0,       name: 1,       storeNumber: {         $arrayElemAt: [{ $split: [\"$_partition\", \" \"] }, 1],       },     },   }, ]); console.log(result); \n``` VIEW OUTPUT #### Add Fields to Documents\n\n ```javascript { $addFields: { <newField>: <expression>, ... } } \n``` ## Note `$addFields` is similar to [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) but does not allow you to include or omit fields. ## Example The following `$addFields` stage creates a new field named`storeNumber` where the value is the output of two aggregate operators that transform the value of the `_partition` field. ```js const result = await plants.aggregate([   {     $addFields: {       storeNumber: {         $arrayElemAt: [{ $split: [\"$_partition\", \" \"] }, 1],       },     },   }, ]); console.log(result); \n``` VIEW OUTPUT #### Unwind Array Values You can use the [$unwind](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/) stage to transform a single document containing an array into multiple documents containing individual values from that array. When you unwind an array field, MongoDB copies each document once for each element of the array field but replaces the array value with the array element in each copy. ```javascript {   $unwind: {     path: <Array Field Path>,     includeArrayIndex: <string>,     preserveNullAndEmptyArrays: <boolean>   } } \n``` ## Example The following example uses the `$unwind` stage for each object's `type` and `color`combination. The aggregation pipeline has the following steps: 1. Use `$group` stage with `$addToSet` to create new documents for each `type` with a new field `colors` that contains an array of all the the colors for that flower type that occur in the collection.\n2. Use `$unwind` stage to create separate documents for each combination of type and color.\n3. Use `$sort` stage to sort the results in alphabetical order. ```js const result = await plants.aggregate([   { $group: { _id: \"$type\", colors: { $addToSet: \"$color\" } } },   { $unwind: { path: \"$colors\" } },   { $sort: { _id: 1, colors: 1 } }, ]); console.log(result); \n``` VIEW OUTPUT ← [Call a Function - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/app-services/call-a-function/ \"Previous Section\")[Manage Users - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/manage-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/mixed/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Mixed - React Native SDK On this page * [Overview](#overview)\n* [Realm Object Models](#realm-object-models)\n* [Create an Object With a Mixed Value](#create-an-object-with-a-mixed-value)\n* [Query for Objects with a Mixed Value](#query-for-objects-with-a-mixed-value) _New in version 10.5.0_. ## Overview The mixed data type is a realm property type that can hold any valid Realm data type except a collection. You can create collections (lists, sets, and dictionaries) of type `mixed`, but a `mixed` itself cannot be a collection. Properties using the mixed data type can also hold null values. ## Note The mixed data type is indexable, but you can't use it as a primary key. Because null is a permitted value, you can't declare a Mixed property as optional. ## Realm Object Models To [set a property of your object model](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-define-a-realm-object-schema) as `Mixed`, set the property's type to \"`mixed`\". `| const DogSchema = { |\n| ------------------- |\n| name: \"Dog\",        |\n| properties: {       |\n| name: \"string\",     |\n| birthDate: \"mixed\", |\n| },                  |\n| };                  | ` ## Create an Object With a Mixed Value Create an object with a mixed value by running the [realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) method within a write transaction. ```javascript realm.write(() => {   // create a Dog with a birthDate value of type string   realm.create(\"Dog\", { name: \"Euler\", birthDate: \"December 25th, 2017\" });   // create a Dog with a birthDate value of type date   realm.create(\"Dog\", {     name: \"Blaise\",     birthDate: new Date(\"August 17, 2020\"),   });   // create a Dog with a birthDate value of type int   realm.create(\"Dog\", {     name: \"Euclid\",     birthDate: 10152021,   });   // create a Dog with a birthDate value of type null   realm.create(\"Dog\", {     name: \"Pythagoras\",     birthDate: null,   }); }); \n``` ## Query for Objects with a Mixed Value Query for objects with a mixed value by running the[Collection.filtered()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#filtered) method and passing in a [filter](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/read/#std-label-react-native-filter-queries) for a non-mixed field. You can then print the value of the mixed property or the entire object itself. ```javascript // To query for Blaise's birthDate, filter for his name to retrieve the realm object. // Use dot notation to access the birthDate property. let blaiseBirthDate = realm.objects(\"Dog\").filtered(`name = 'Blaise'`)[0]   .birthDate; console.log(`Blaise's birth date is ${blaiseBirthDate}`); \n``` ← [Sets - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/sets/ \"Previous Section\")[UUID - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/uuid/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/default-value/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Define a Default Property Value - React Native SDK On this page * [Overview](#overview) ## Overview To define a default value, set the value of the property to an object with a`type` field and a `default` field. ## Example The following `Car` object schema specifies a default value of `0` for the `miles` property: `| const CarSchema = {                 |\n| ----------------------------------- |\n| name: \"Car\",                        |\n| properties: {                       |\n| make: \"string\",                     |\n| model: \"string\",                    |\n| miles: { type: \"int\", default: 0 }, |\n| },                                  |\n| };                                  | ` ← [Index a Property - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/index/ \"Previous Section\")[Remap a Property - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/remap/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/overview/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - React Native SDK On this page * [Database Internals](#database-internals)\n* [Native Database Engine](#native-database-engine)\n* [Realm Files](#realm-files)\n* [Copy-on-Write: The Secret Sauce of Data Versioning](#copy-on-write--the-secret-sauce-of-data-versioning)\n* [Memory Mapping](#memory-mapping)\n* [Compaction](#compaction)\n* [ACID Compliance](#acid-compliance)\n* [Features](#features)\n* [Queries](#queries)\n* [Encryption](#encryption)\n* [Indexes](#indexes)\n* [Schemas](#schemas)\n* [Persistent or In-Memory Realms](#persistent-or-in-memory-realms)\n* [Atlas Device Sync](#atlas-device-sync)\n* [Realm vs Other Databases](#realm-vs-other-databases)\n* [Live Queries](#live-queries)\n* [Live Objects](#live-objects)\n* [Collections](#collections)\n* [Change Notifications](#change-notifications) Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) This page explains some of the implementation details and inner workings of Realm Database and Device Sync. This page is for you if you are: * a developer interested in learning more about Realm Database\n* comparing Realm Database with competing databases\n* trying to understand how Realm Database works with Device Sync This explanation begins with a deep dive into database internals, continues with a high-level introduction to some of the features of Realm Database, and wraps up with some of the differences of working with Device Sync and the local version of Realm Database. ## Database Internals Realm Database uses a completely unique database engine, file format, and design. This section describes some of the high-level details of those choices. This section applies to both the device-local version of Realm Database as well as the networked Device Sync version. Differences between the local database and the synchronized database are explained in the Atlas Device Sync section. ### Native Database Engine Realm Database is an entire database written from scratch in C++, instead of building on top of an underlying database engine like SQLite. Realm Database's underlying storage layer uses[B+ trees](https://en.wikipedia.org/wiki/B%2B%5Ftree) to organize objects. As a result, Realm Database controls optimizations from the storage level all the way up to the access level. Realm Database stores data in **realms**: collections of heterogeneous realm objects. You can think of each realm as a database. Each object in a realm is equivalent to a row in a SQL database table or a MongoDB document. Unlike SQL, realms do not separate different object types into individual tables. Realm Database stores objects as groups of property values. We call this column-based storage. This means that queries or writes for individual objects can be slower than row-based storage equivalents when unindexed, but querying a single field across multiple objects or fetching multiple objects can be much faster due to spatial locality and in-CPU vector operations. Realm Database uses a [zero-copy](https://en.wikipedia.org/wiki/Zero-copy) design to make queries faster than an ORM, and often faster than raw SQLite. ### Realm Files Realm Database persists data in files saved on device storage. The database uses several kinds of file:\n\n Realm files contain object data with the following data structures: Groups, Tables, Cluster Trees, and Clusters. Realm Database organizes these data structures into a tree structure with the following form: * The top level, known as a Group, stores object metadata, a transaction log, and a collection of Tables.\n* Each class in the realm schema corresponds to a Table within the top-level Group.\n* Each Table contains a Cluster Tree, an implementation of a B+ tree.\n* Leaves on the Cluster Tree are called Clusters. Each contains a range of objects sorted by key value.\n* Clusters store objects as collections of columns.\n* Each column contains data for a single property for multiple instances of a given object. Columns are arrays of data with uniformly sized values.\n* Columns store data in one of the following sizes: 1, 2, 4, 8, 16, 32, or 64 bits. Each column uses one value size, determined by the largest value. Since pointers refer to memory addresses, objects written to persistent files cannot store references as pointers. Instead, realm files refer to data using the offset from the beginning of the file. We call this a ref. As Realm Database uses memory mapping to read and write data, database operations translate these refs from offsets to memory pointers when navigating database structures. ### Copy-on-Write: The Secret Sauce of Data Versioning Realm Database uses a technique called **copy-on-write**, which copies data to a new location on disk for every write operation instead of overwriting older data on disk. Once the new copy of data is fully written, the database updates existing references to that data. Older data is only garbage collected when it is no longer referenced or actively in use by a client application. Because of copy-on-write, older copies of data remain valid, since all of the references in those copies still point to other valid data. Realm Database leverages this fact to offer multiple versions of data simultaneously to different threads in client applications. Most applications tie data refreshes to the repaint cycle of the looper thread that controls the UI, since data only needs to refresh as often as the UI does. Longer-running procedures on background threads, such as large write operations, can work with a single version of data for a longer period of time before committing their changes. ### Memory Mapping Writes use [memory mapping](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) to avoid copying data back and forth from memory to storage. Accessors and mutators read and write to disk via memory mapping. As a result, object data is never stored on the stack or heap of your app. By default, data is memory-mapped as read-only to prevent accidental writes. Realm Database uses operating system level paging, trusting each operating system to implement memory mapping and persistence better than a single library could on its own. ### Compaction Realm Database automatically reuses free space that is no longer needed after database writes. However, realm files never shrink automatically, even if the amount of data stored in your realm decreases significantly. Compact your realm to optimize storage space and decrease file size if possible. You should compact your realms occasionally to keep them at an optimal size. You can do this manually, or by configuring your realms to compact on launch. However, Realm Database reclaims unused space for future writes, so compaction is only an optimization to conserve space on-device. ### ACID Compliance Realm Database guarantees that transactions are [ACID](https://en.wikipedia.org/wiki/ACID) compliant. This means that all committed write operations are guaranteed to be valid and that clients don't see transient states in the event of a system crash. Realm Database complies with ACID with the following design choices:\n\n ## Features Realm Database supports many popular database features. ### Queries You can query Realm Database using platform-native queries or a raw query language that works across platforms. ### Encryption Realm Database supports on-device realm encryption. Since memory mapping does not support encryption, encrypted realms use a simulated in-library form of memory mapping instead. ## Note Realm forbids opening the same encrypted realm from multiple processes. Attempting to do so will throw the error: \"Encrypted interprocess sharing is currently unsupported.\" ### Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time. ### Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, do not require a migration. After you increment the local schema version, you can begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. See your SDK's documentation for more information on migrations. ### Persistent or In-Memory Realms You can use Realm Database to store data persistently on disk, or ephemerally in memory. Ephemeral realms can be useful in situations where you don't need to persist data between application instances, such as when a user works in a temporary workspace. ## Atlas Device Sync Device Sync adds network synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. Device Sync relies on a worker client that communicates with your application backend in a dedicated thread in your application. Additionally, synced realms keep a history of changes to contained objects. Sync uses this history to resolve conflicts between client changes and backend changes. Applications that use Device Sync define their schema on the backend using[JSON Schema](https://json-schema.org/learn/getting-started-step-by-step.html). Client applications must match that backend schema to synchronize data. However, if you prefer to define your initial schema in your application's programming language, you can use [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to create a backend JSON Schema based on native SDK objects as you write your application. However, once your application is used for production purposes, you should alter your schema using JSON Schema on the backend. ## Realm vs Other Databases The Realm data model is similar to both relational and document databases but has distinct differences from both. To underscore these differences, it's helpful to highlight what a realm **is not**: A realm is not a single, application-wide database. Applications based on other database systems generally store all of their data in a single database. Apps often split data across multiple realms to organize data more efficiently and to enforce access controls. A realm is not a relational table. Normalized tables in relational databases only store one type of information, such as street addresses or items in a store inventory. A realm can contain any number of object types that are relevant to a given domain. A realm is not a collection of schemaless documents. Document databases don't necessarily enforce a strict schema for the data in each collection. While similar to documents in form, every Realm object conforms to a schema for a specific object type in the realm. An object cannot contain a property that is not described by its schema. ## Live Queries You can query a realm to find objects based on their type and the values of their properties. Objects and queries always reflect the latest state of an object and emit [notifications](#std-label-react-native-change-notifications) that can update your app whenever data changes. ## Tip ### Learn How to Define and Run Queries For code examples that show how to read and filter Realm objects with the React Native SDK, see [Read Operations.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/read/#std-label-react-native-read-operations) ### Live Objects\n\n ## Note ### Memory-mapped Realm Objects Realm can support live objects because it [memory-maps](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) objects in your application directly to data stored in the [realm file](https://mongodb.com/docs/realm/sdk/react-native/realm-database/open-and-close-a-realm/#std-label-react-native-realm-file) instead of a copy of the data stored in memory. ## Tip ### See also:  Learn how to [read data](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/read/#std-label-react-native-read-objects) from Realm Database. ### Collections A results collection represents all objects in a realm that match a query operation. In general you can work with a collection like a regular JavaScript array but collections don't actually hold matching Realm objects in memory. Instead they reference the matched objects, which themselves map directly to data in the realm file. ## Note ### Pagination & Limits Some queries only need to access a subset of all objects that match the query. Realm's lazy-loaded collections only fetch objects when you actually access them, so you do not need any special mechanism to limit query results. For example, if you only want to find 10 matching objects at a time (such as in a paged product catalog) you can just access ten elements of the results collection. To advance to the next page, access the next ten elements of the results collection starting at the index immediately following the last element of the previous page. ### Change Notifications Realm objects and collections always reflect the latest state of your data when you read them. Realm emits a change notification whenever the state of your data changes, which lets you reactively update your app in response to committed[write transaction.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/write-transactions/#std-label-react-native-write-transactions) You can register three types of notification listeners: * A **realm listener** fires whenever any object in a realm changes.\n* A **collection listener** fires whenever a specific query matches a new set of objects or when any matched object changes.\n* An **object listener** fires whenever a specific object is deleted or has one or more properties modified. ## Tip ### Learn How to React to Changes For code examples that show how to define, register, and clean up change notification listeners with the React Native SDK, see [React to Changes.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/react-to-changes/#std-label-react-native-react-to-changes) ## Tip ### See also:  To learn how to register change listeners, read the [react to changes](https://mongodb.com/docs/realm/sdk/react-native/realm-database/react-to-changes/#std-label-react-native-react-to-changes) documentation. ← [Realm Database - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/ \"Previous Section\")[Define a Realm Object Model - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/collections/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Collections - React Native SDK On this page * [Overview](#overview)\n* [Results](#results)\n* [Lists](#lists)\n* [Results are Lazily Evaluated](#results-are-lazily-evaluated)\n* [Collections are Live](#collections-are-live)\n* [Working With Collections](#working-with-collections)\n* [Limiting Query Results](#limiting-query-results)\n* [Pagination](#pagination)\n* [Summary](#summary) ## Overview Realm has several types to represent groups of objects, which we call **collections**. A collection is an object that contains zero or more instances of one [Realm type.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-types) You can filter and sort any collection using Realm Database's[query engine](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/query-data/#std-label-react-native-client-query-engine). Collections are[live](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-live-objects), so they always reflect the current state of the realm instance on the current thread. You can also listen for changes in the collection by subscribing to [collection notifications.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/react-to-changes/#std-label-react-native-register-a-collection-change-listener) ## Results A [Results](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Results.html) collection represents the lazily-evaluated results of a query operation. Results are immutable: you cannot add or remove elements to or from the results collection. Results have an associated query that determines their contents. ## Tip ### See also:  [Reads](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-realm-database-reads) ## Lists A [List](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.List.html) represents a [to-many relationship](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-to-many-relationship) between two Realm types. Lists are mutable: within a write transaction, you can add and remove elements to and from a list. Lists are not associated with a query and are declared as a property of an [object model.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-schemas) ## Tip ### See also:  [To-Many Relationships](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-to-many-relationship) ## Results are Lazily Evaluated Realm Database only runs a query when you request the results of that query. This lazy evaluation enables you to write elegant, highly-performant code for handling large data sets and complex queries. ## Collections are Live Like [live objects](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-live-objects), Realm collections are usually **live**: * Live results collections always reflect the current results of the associated query.\n* Live lists always reflect the current state of the relationship on the realm instance. A collection is **not** live when:\n\n Combined with [collection notifications](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-change-notifications), live collections enable reactive code. For example, suppose your view displays the results of a query. You can keep a reference to the results collection in your view class, then read the results collection as needed without having to refresh it or validate that it is up-to-date. ## Important ### Indexes may change Since results update themselves automatically, do not store the positional index of an object in the collection or the count of objects in a collection. The stored index or count value could be outdated by the time you use it. ## Working With Collections ### Limiting Query Results As a result of lazy evaluation, you do not need any special mechanism to limit query results with Realm Database. For example, if your query matches thousands of objects, but you only want to load the first ten, access only the first ten elements of the results collection. ### Pagination Thanks to lazy evaluation, the common task of pagination becomes quite simple. For example, suppose you have a results collection associated with a query that matches thousands of objects in your realm. You display one hundred objects per page. To advance to any page, simply access the elements of the results collection starting at the index that corresponds to the target page. ## Summary * A Realm **collection** is a homogenous container of zero or more instances of one[Realm type.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-types)\n* There are two main kinds of collection: **lists** and **results**. Lists define the [to-many relationships](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-to-many-relationship)of your Realm types, while results represent the lazily-loaded output of a [read operation.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-realm-database-reads)\n* Lazy evaluation of results collections means there is no need to design a special query to get limited or paginated results. Perform the query and read from the results collection as needed.\n* Data in Realm is _live_, which means that an object always reflects its most recent saved state. ← [Field Types - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/field-types/ \"Previous Section\")[Dictionaries - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/dictionaries/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/primary-key/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Specify a Primary Key - React Native SDK On this page * [Overview](#overview) ## Overview To specify a property as an object type's primary key, set the schema's`primaryKey` field to the property name. ## Note A **primary key** is a property that uniquely identifies an object. Realm Database automatically [indexes](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/index/#std-label-react-native-indexes)primary key properties, which allows you to efficiently read and modify objects based on their primary key. If an object type has a primary key, then all objects of that type must include the primary key property with a value that is unique among objects of the same type in a realm. An object type may have at most one primary key. You cannot change the primary key property for an object type after any object of that type is added to a realm and you cannot modify an object's primary key value. ## Example The following `Task` object schema specifies the `_id` property as its primary key. `| const TaskSchema = {   |\n| ---------------------- |\n| name: 'Task',          |\n| properties: {          |\n| _id: 'objectId',       |\n| _partition: 'string?', |\n| name: 'string',        |\n| status: 'string',      |\n| },                     |\n| primaryKey: '_id',     |\n| };                     | ` ← [Specify an Optional Property - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/optional/ \"Previous Section\")[Index a Property - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/index/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/change-an-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Change an Object Model - React Native SDK On this page * [Overview](#overview)\n* [Key Concept: Schema Version](#key-concept--schema-version)\n* [Key Concept: Migrations](#key-concept--migrations)\n* [Automatically Update Schema](#automatically-update-schema)\n* [Add a Property](#add-a-property)\n* [Delete a Property](#delete-a-property)\n* [Manually Migrate Schema](#manually-migrate-schema)\n* [Rename a Property](#rename-a-property)\n* [Modify a Property Type](#modify-a-property-type) ## Note ### Modify Schema Properties of a Synced Realm The following page demonstrates how to modify schema properties of a local realm. Learn how to [modify schema properties of a synced realm.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) ## Overview When you update your object schema, you must increment the schema version and perform a migration. If your schema update adds optional properties or removes properties, Realm Database can perform the migration automatically. You only need to increment the `schemaVersion`. For more complex schema updates, you must also manually specify the migration logic in a `migration` function. This might include changes such as: * Adding required properties that must be populated with default values\n* Combining fields\n* Renaming a field\n* Changing a field's type\n* Converting from an object to an embedded object ## Tip ### Bypass Migration During Development When developing or debugging your application, you may prefer to delete the realm instead of migrating it. Use the`deleteRealmIfMigrationNeeded` flag to delete the database automatically when a schema mismatch would require a migration. Never release an app to production with this flag set to `true`. ## Key Concept: Schema Version A **schema version** identifies the state of a [realm schema](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-realm-schema) at some point in time. Realm Database tracks the schema version of each realm and uses it to map the objects in each realm to the correct schema. Schema versions are ascending integers that you can optionally include in the realm configuration when you open a realm. If a client application does not specify a version number when it opens a realm then the realm defaults to version `0`. ## Important ### Increment Versions Monotonically [Migrations](#std-label-react-native-migrations) must update a realm to a higher schema version. Realm Database will throw an error if a client application opens a realm with a schema version that is lower than the realm's current version or if the specified schema version is the same as the realm's current version but includes different[object schemas.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-schemas) ## Key Concept: Migrations A **migration** is a function that updates a realm and any objects it contains from one [schema version](#std-label-react-native-schema-version) to a newer version. Migrations give you the flexibility to change your object schemas over time to accommodate new features and refactors. Whenever you open an existing realm with a schema version greater than the realm's current version, Realm runs a migration function that you define. The function has access to the realm's version number and incrementally updates objects in the realm to conform to the new schema. Realm automatically migrates certain changes, such as new and deleted properties, but does not automatically set values for new properties unless the updated object schema specifies a default value. You can define additional logic in the migration function to further customize property values. ## Automatically Update Schema ### Add a Property To add a property to a schema, add the new property to the object's class and set a `schemaVersion` of the [realm's configuration object.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) ## Example\n\n To migrate the realm to conform to the updated `Person` schema, the developer sets the realm's [schema version](#std-label-react-native-schema-version) to`2`. ### Delete a Property To delete a property from a schema, remove the property from the object's class and set a `schemaVersion` of the [realm's configuration object](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration). Deleting a property will not impact existing objects. ## Example A realm using schema version `1` has a `Dog` object type with a`weight` property. The developer decides to remove the property from the schema. To migrate the realm to conform to the updated `Dog` schema, the developer sets the realm's [schema version](#std-label-react-native-schema-version) to`2`. ## Manually Migrate Schema ### Rename a Property To rename an object property, change the property name in the object schema and then open the realm with an incremented [schema version](#std-label-react-native-schema-version) and a [migration](#std-label-react-native-migrations) function that updates existing objects to use the new property name. Migrations do not allow you to directly rename a property. Instead you can create a new property with the updated name, copy the value from the old property, and then delete the old property. ## Example A realm using schema version `1` has a `Person` object type. The original schema had a `firstName` and `lastName` field. The developer later decides that the `Person` class should use a combined `fullName`field and removes the separate `firstName` and `lastName` fields. To migrate the realm to conform to the updated `Person` schema, the developer sets the realm's [schema version](#std-label-react-native-schema-version) to`2` and defines a migration function to set the value of `fullName` based on the existing `firstName` and `lastName` properties. ## Important ### Synced Realms [Synced realms](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) only support non-breaking - also called additive - changes to ensure that older clients can sync with newer clients. Because full renames require you to delete the old property, you cannot rename a synchronized property without requiring a client reset. Instead, consider adding the renamed property without deleting the old property. Alternately, use[mapTo](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/remap/#std-label-react-native-remap-a-property) to store data using the existing internal name, but let your code use a different name. ### Modify a Property Type To modify a property's type, set the property type of the field that you wish to modify to the new data type. Then, set a `schemaVersion`, and a `migration`callback function of the [realm's configuration Object.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) ## Note [Synchronized realms](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) only support non-breaking changes, to ensure that older clients can sync with newer clients. This means that synchronized realms do not support modifying the type of a property of a schema. ## Example A realm using schema version `1` has a `Dog` object type. The original schema had an `_id` with a property type of `Object ID`. The developer later decides that the `Dog` class's `_id` field should be of type `string`, and updates the schema. To migrate the realm to conform to the updated `Dog` schema, the developer sets the realm's [schema version](#std-label-react-native-schema-version) to`2` and defines a migration function to convert the `Object ID` type to a`string` type. ← [Define a Realm Object Model - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/ \"Previous Section\")[Schemas Overview - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/asymmetric-object/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Define an Asymmetric Object - React Native SDK On this page * [Overview](#overview) ## Overview If you are using Flexible Sync and need to sync a collection unidirectionally from your device to your Atlas database, you can set the `asymmetric` property on your object schema. ## Example In the following example of a retail app, the client requires large amounts of invoice data to be recorded rapidly by store employees. The client specifies that invoice data does not need to be read after employees have recorded it. To satisfy this requirement, the application developer defines an invoice collection with its `asymmetric` property set to `true`. `| const InvoiceSchema = {                                                  |\n| ------------------------------------------------------------------------ |\n| name: \"Invoice\",                                                         |\n| // sync Invoice objects one way from your device to your Atlas database. |\n| asymmetric: true,                                                        |\n| primaryKey: \"_id\",                                                       |\n| properties: {                                                            |\n| _id: \"objectId\",                                                         |\n| item: \"string\",                                                          |\n| quantity: \"int\",                                                         |\n| price: \"int\",                                                            |\n| },                                                                       |\n| };                                                                       | ` ## Note ### Attempting to Read Asymmetric Sync Objects Asymmetric Sync objects cannot be read. If you attempt to query an Asymmetric Sync object, you will get the following error: \"Error: You cannot query an asymmetric class.\".\n\n ← [Embedded Objects - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/embedded-objects/ \"Previous Section\")[Open & Close a Realm - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/open-and-close-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/overview/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Schemas Overview - React Native SDK On this page * [Overview](#overview) ## Overview This section details how to specify the following schema properties within a Realm Object Model using the Realm React Native SDK: * [Field Types](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/field-types/)\n* [Collections](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/collections/)\n* [Dictionaries](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/dictionaries/)\n* [Sets](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/sets/)\n* [Mixed](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/mixed/)\n* [UUID](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/uuid/)\n* [Specify an Optional Property](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/optional/)\n* [Specify a Primary Key](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/primary-key/)\n* [Index a Property](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/index/)\n* [Define a Default Property Value](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/default-value/)\n* [Remap a Property](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/remap/)\n* [Relationships](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/)\n* [Embedded Objects](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/embedded-objects/)\n* [Define an Asymmetric Object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/asymmetric-object/) ← [Change an Object Model - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/change-an-object-model/ \"Previous Section\")[Schemas Overview - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/optional/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Specify an Optional Property - React Native SDK On this page * [Overview](#overview) ## Overview To mark a property as optional, append a question mark `?` to its type. ## Example The following schema defines a DogSchema with the optional property `breed`of type `string`. `| const DogSchema = { |\n| ------------------- |\n| name: \"Dog\",        |\n| properties: {       |\n| breed: \"string?\"    |\n| }                   |\n| };                  |\n|                     | ` ← [UUID - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/uuid/ \"Previous Section\")[Specify a Primary Key - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/primary-key/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/uuid/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # UUID - React Native SDK On this page * [Overview](#overview)\n* [Usage](#usage) _New in version 10.5.0_. ## Overview `UUID` (Universal Unique Identifier) is a 16-byte [unique value](https://en.wikipedia.org/wiki/Universally%5Funique%5Fidentifier). You can use `UUID` as an identifier for objects. `UUID` is [indexable](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/index/#std-label-react-native-indexes) and you can use it as a[primary key.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/primary-key/#std-label-react-native-primary-keys) ## Note ### Using UUID Instead of ObjectId In general, you can use `UUID` for any fields that function as a unique identifier. Using `UUID` might be particularly useful if you are migrating data not stored in MongoDB since it is likely that your object's unique identifiers are already of a `UUID` type. Alternatively, using `ObjectId`might be useful for a collection of data that already exists in MongoDB. ## Usage To define a property as a `UUID`, set its type to the string `\"uuid\"` in your [object model](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-schemas). Create a Realm object within a write transaction. To set any unique identifier properties of your object to a random value, call `new UUID()`. Alternatively, pass a string to `new UUID()` to set the unique identifier property to a specific value.\n\n ` ← [Mixed - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/mixed/ \"Previous Section\")[Specify an Optional Property - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/optional/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/field-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Field Types - React Native SDK Realm Database supports the following field data types: * `bool` maps to the JavaScript [Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Boolean) type\n* `int` maps to the JavaScript [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) type. Internally, Realm Database stores `int` with 64 bits.\n* `float` maps to the JavaScript [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) type. Internally, Realm Database stores `float` with 32 bits.\n* `double` maps to the JavaScript [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) type. Internally, Realm Database stores `double` with 64 bits.\n* `string` maps to the JavaScript [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String) type.\n* `decimal128` for high precision numbers.\n* `objectId` maps to BSON [ObjectId](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) type.\n* `data` maps to the JavaScript [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/ArrayBuffer) type.\n* `date` maps to the JavaScript [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date) type.\n* `list` maps to the JavaScript [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array) type. You can also specify that a field contains a list of primitive value type by appending `[]` to the type name.\n* `linkingObjects` is a special type used to define an inverse relationship.\n* `dictionary` used to manage a collection of unique String keys paired with values. The `Dictionary` data type is available in the [realm-js@10.5.0 release.](https://github.com/realm/realm-js/releases/tag/v10.5.0)\n* `set` is based on the JavaScript [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set) type. `Realm Set` is available in the [realm-js@10.5.0 release.](https://github.com/realm/realm-js/releases/tag/v10.5.0)\n* `mixed` is a property type that can hold different data types. The `Mixed` data type is available in the [realm-js@10.5.0 release.](https://github.com/realm/realm-js/releases/tag/v10.5.0)\n* `uuid` is a universally unique identifier from [Realm.BSON](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.BSON). The `UUID` data type is available in the [realm-js@10.5.0 release.](https://github.com/realm/realm-js/releases/tag/v10.5.0) ← [Schemas Overview - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/overview/ \"Previous Section\")[Collections - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/collections/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/dictionaries/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Dictionaries - React Native SDK On this page * [Overview](#overview)\n* [Realm Object Models](#realm-object-models)\n* [Create an Object with a Dictionary Value](#create-an-object-with-a--dictionary-value)\n* [Query for Objects with a Dictionary Property](#query-for-objects-with-a-dictionary-property)\n* [Add a Listener to a Dictionary](#add-a-listener-to-a-dictionary)\n* [Update a Dictionary](#update-a-dictionary)\n* [Delete Members of a Dictionary](#delete-members-of-a-dictionary) _New in version 10.5.0_. ## Overview You can use the `dictionary` data type to manage a collection of unique String keys paired with values. The `dictionary` data maps to the Javascript[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object) type. ## Realm Object Models To define a dictionary of mixed values in your schema, set the data type of your field to an empty object, `\"{}\"`. Alternatively, to create a dictionary with values of a specific type, add the data type before the brackets. For instance, `\"int{}\"` to specify that dictionary values must be integers or `\"string{}\"` to specify that dictionary values must be strings. `| const PersonSchema = { |\n| ---------------------- |\n| name: \"Person\",        |\n| properties: {          |\n| name: \"string\",        |\n| home: \"{}\",            |\n| },                     |\n| };                     | ` ## Create an Object with a Dictionary Value Create an object with a dictionary value by running the [realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) method within a write transaction. ```javascript let johnDoe; let janeSmith; realm.write(() => {   johnDoe = realm.create(\"Person\", {     name: \"John Doe\",     home: {       windows: 5,       doors: 3,       color: \"red\",       address: \"Summerhill St.\",       price: 400123,     },   });   janeSmith = realm.create(\"Person\", {     name: \"Jane Smith\",     home: {       address: \"100 northroad st.\",       yearBuilt: 1990,     },   }); }); \n``` ## Query for Objects with a Dictionary Property To filter a query, run [collection.filtered()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#filtered) to specify a subset of results based on the value(s) of one or more object properties. You can specify results based on the value of a dictionary's properties by using [bracket-notation.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors) You can also determine whether a results collection has a certain key or value by using `<dictionary>.@keys` or `<dictionary>.@values`. For instance, if you had a `Person` collection with a nested `home` dictionary, you could return all `Person` objects with a `home` with a `\"price\"` property by running the query: `home.@keys = \"price\"`. ```javascript // query for all Person objects const persons = realm.objects(\"Person\"); // run the `.filtered()` method on all the returned persons to  // find the house with the address \"Summerhill St.\" const summerHillHouse = persons.filtered(   `home['address'] = \"Summerhill St.\"` )[0].home;\n\n const peopleWithHousesWithAListedPrice = persons.filtered(   `home.@keys = \"price\" ` ); // find a house that has any field with a value of 'red' const redHouse = persons.filtered(`home.@values = \"red\" `)[0].home; \n``` ## Add a Listener to a Dictionary You can add a listener to a dictionary by running the[dictionary.addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.List.html#addListener) method. The`addListener` method's callback function has two parameters, the changed dictionary and an array of changes describing how the dictionary was changed. ## Note Learn more about [change notifications.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-change-notifications) ```javascript summerHillHouse.addListener((changedHouse, changes) => {   console.log(\"A change has occurred to the Summer Hill House object\"); }); \n``` ## Update a Dictionary To update a dictionary's properties, use dot notation or the `dictionary.put()` method. ```javascript realm.write(() => {   // use the `put()` method to update a field of a dictionary   summerHillHouse.put({ price: 400100 });   // alternatively, update a field of a dictionary through dot notation   summerHillHouse.color = \"brown\";   // update a dictionary by adding a field   summerHillHouse.yearBuilt = 2004; }); \n``` ## Delete Members of a Dictionary To delete members of a dictionary, use the `dictionary.remove()` method with an array of properties to remove from the dictionary. ```javascript realm.write(() => {   // remove the 'windows' and 'doors' field of the Summerhill House.   summerHillHouse.remove([\"windows\", \"doors\"]); }); \n``` ← [Collections - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/collections/ \"Previous Section\")[Sets - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/sets/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Relationships - React Native SDK On this page * [Overview](#overview)\n* [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationship](#inverse-relationship) ## Overview Realm allows you to define explicit relationships between the types of objects in an App. A relationship is an object property that references another Realm object type. You can define relationships by setting an object's property to another object type in the [property schema.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-realm-schema) Relationships are direct references to other objects in a realm. You don't need bridge tables or joins to define a relationship like you would in a relational database. Instead you can access related objects by reading and writing to the property that defines the relationship. Realm Database executes read operations lazily as they come in. Querying a relationship is just as performant as reading a regular property. There are three primary types of relationships between objects: * [One-to-One Relationship](#std-label-react-native-to-one-relationship)\n* [One-to-Many Relationship](#std-label-react-native-to-many-relationship)\n* [Inverse Relationship](#std-label-react-native-inverse-relationship) ## Note ### Realm vs Other Databases Objects often contain direct references to other objects. When working with objects and references, you often copy from database storage into application memory. This situation leaves the developer with a choice of what to copy into memory: * You can copy the entire referenced object ahead of time. This means that all referenced data is always available quickly, but can use up a lot of resources. Depending on the amount of available memory this may not be viable.\n* You can copy only a foreign key value for each object ahead of time that you can use to query the full object if it's needed. These referenced lookups are memory-efficient. However, they require more query code and too many lookups can slow your application down. Realm's query architecture avoids the tradeoff between memory usage and computational overhead. Instead, Realm queries can directly reference [related objects](#std-label-react-native-relationships) and their properties on disk. ## Tip ### See also:  With Device Sync, you can also [define your relationships](https://www.mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-define-a-relationship) in the App Services UI. ### To-One Relationship A **to-one** relationship means that an object is related to no more than one other object in an [object schema](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-schemas). To define a to-one relationship, specify the property type as the related Realm object type. ## Example An application could use the following object schemas to indicate that a Person may own a single Dog: `| const Person = {   |\n| ------------------ |\n| name: \"Person\",    |\n| properties: {      |\n| name: \"string\",    |\n| birthdate: \"date\", |\n| dog: \"Dog?\"        |\n| }                  |\n| };                 |\n| const Dog = {      |\n| name: \"Dog\",       |\n| properties: {      |\n| name: \"string\",    |\n| age: \"int\",        |\n| breed: \"string?\"   |\n| }                  |\n| };                 | ` ### To-Many Relationship\n\n ## Example An application could use the following object schemas to indicate that a Person may own multiple Dogs: ```javascript const Person = {   name: \"Person\",   properties: {     name: \"string\",     birthdate: \"date\",     dogs: \"Dog[]\"   } }; const Dog = {   name: \"Dog\",   properties: {     name: \"string\",     age: \"int\",     breed: \"string?\"   } }; \n``` ### Inverse Relationship An inverse relationship links an object back to any other objects that refer to it in a defined to-one or to-many relationship. Relationship definitions are unidirectional by default. You must explicitly define a property in the object's model as an inverse relationship. For example, the to-many relationship \"User has many Tasks\" does not automatically create the inverse relationship \"Task belongs to User\". If you don't specify the inverse relationship in the object model, you need to run a separate query to look up the user assigned to a task. To define an inverse relationship, define a `linkingObjects` property in your object model. `linkingObjects` specifies the object type and property name of the relationship that it inverts. You cannot manually set the value of an inverse relationship property. Realm Database automatically updates implicit relationships whenever you add or remove a related object. ## Example An application could use the following object schemas to indicate: 1. A User may be assigned many Tasks.\n2. Each Task should automatically keep track of which User it's assigned to. The User object's tasks property is defined as a to-many relationship with Task objects. It contains all of a given user's assigned tasks. The Task object's assignee property inverts this relationship. Assignee automatically updates to refer back to any User object that contains the Task in its tasks property. #### Dynamically Obtain an Inversely Linked Object You can dynamically retrieve an object with an inverse relationship without defining a `linkingObjects` type in its schema. Remove the`linkingObjects` type from your schema, so your schemas look like a standard**to-many** relationship. When you need to retrieve the linked object, call the[Realm.Object.linkingObjects()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#linkingObjects)query. ## Example In the following continuation from the inverse relationship example, we have removed the`assignee` field with type 'linkingObjects' from the Task schema. An application developer creates several users and task objects, and the application pushes the newly created tasks into a user's task field. To find the user who owns a specific task object, the developer calls the`task.linkingObjects()` method and passes the \"User\" class name and \"tasks\" field as parameters. ← [Remap a Property - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/remap/ \"Previous Section\")[Embedded Objects - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/embedded-objects/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/remap/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Remap a Property - React Native SDK On this page * [Overview](#overview) ## Overview To use a different property name in your code than is stored in Realm Database, set `mapTo` to the name of the property as it appears in your code. ## Example A developer opens a realm using the following `Dog` object schema. Realm Database stores each dog's first name with the snake case`first_name` property. The schema maps the property to `firstName` for objects used in JavaScript code. `| const DogSchema = {                                |\n| -------------------------------------------------- |\n| name: \"Dog\",                                       |\n| properties: {                                      |\n| _id: \"string\",                                     |\n| first_name: { type: 'string', mapTo: 'firstName' } |\n| },                                                 |\n| primaryKey: '_id'                                  |\n| };                                                 | ` ← [Define a Default Property Value - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/default-value/ \"Previous Section\")[Relationships - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/sets/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sets - React Native SDK On this page * [Overview](#overview)\n* [Realm Object Models](#realm-object-models)\n* [Create an Object With a Set](#create-an-object-with-a-set)\n* [Add Items to a Set](#add-items-to-a-set)\n* [Check if a Set has Specific Items](#check-if-a-set-has-specific-items)\n* [Check the Size of a Set](#check-the-size-of-a-set)\n* [Remove an Item from a Set](#remove-an-item-from-a-set)\n* [Remove all Items from a Set](#remove-all-items-from-a-set)\n* [Traverse a Set](#traverse-a-set) _New in version 10.5.0_. ## Overview A **Realm Set** is a special object that allows you to store a collection of unique values. **Realm Sets** are based on JavaScript[sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set), but can only contain values of a single type and can only be modified within a write transaction. Sets allow you to perform math operations such as finding the union, intersection, or difference between two sets. To learn more about performing these operations, see the MDN docs for [Implementing basic set operations.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set#implementing%5Fbasic%5Fset%5Foperations) ## Realm Object Models To define a property type as a `Realm Set`, specify the data type you want in the set, followed by `<>`. For instance, for a set made of integer values, specify `\"int<>\"`. `| const characterSchema = { |\n| ------------------------- |\n| name: \"Character\",        |\n| primaryKey: \"_id\",        |\n| properties: {             |\n| _id: \"objectId\",          |\n| name: \"string\",           |\n| levelsCompleted: \"int<>\", |\n| inventory: \"string<>\",    |\n| },                        |\n| };                        | ` ## Create an Object With a Set To create an object with a **Realm Set** property, you must create the object within a write transaction. When defining your Realm object, initialize the **Realm Set** by passing an empty array or an array with your initial values. ```javascript let playerOne, playerTwo; realm.write(() => {   playerOne = realm.create(\"Character\", {     _id: new BSON.ObjectId(),     name: \"PlayerOne\",     inventory: [\"elixir\", \"compass\", \"glowing shield\"],     levelsCompleted: [4, 9],   });   playerTwo = realm.create(\"Character\", {     _id: new BSON.ObjectId(),     name: \"PlayerTwo\",     inventory: [\"estus flask\", \"gloves\", \"rune\"],     levelsCompleted: [1, 2, 5, 24],   }); }); \n``` ## Add Items to a Set To add an item to a set, pass the new value to the `<Realm.Set>.add()` method within a write transaction. ```javascript realm.write(() => {   playerOne.inventory.add(\"hammer\");   playerOne.levelsCompleted.add(32); }); \n``` ## Check if a Set has Specific Items To determine if a set contains a particular value, pass the value to the `<Realm.Set>.has()` method. The`set.has()` method will return true if the set contains the value specified. ```javascript // check if playerTwo has completed level 3 by calling the `has()` method  // on the Realm Set object\n\n console.log(   `Is level three completed by playerTwo: ${playerTwoHasCompletedLevelThree}` ); \n``` ## Check the Size of a Set To discover how many items are in a set, you can check the set's `size` property. ```javascript // check how many items playerTwo has in his inventory through the `size`  // property of the Realm Set object const playerTwoInventorySize = playerTwo.inventory.size; console.log(`playerTwo has ${playerTwoInventorySize} inventory items`); \n``` ## Remove an Item from a Set To remove a specific value from a set, pass the value to the `<Realm.Set>.delete()` method within a write transaction. ```javascript realm.write(() => {   // remove the compass from playerOne's inventory by calling the    // `delete()` method of the Realm Set object within a write transaction   playerOne.inventory.delete(\"compass\"); }); \n``` ## Remove all Items from a Set To clear the set, run the `<Realm.Set>.clear()` method within a write transaction. ```javascript realm.write(() => {   // clear all data from the inventory slot of playerTwo by calling    // the `clear()` method of the Realm Set object in a write transaction   playerTwo.inventory.clear(); }); \n``` ## Traverse a Set To traverse a set, use the `<Realm.Set>.forEach()` method or alternative [iteration method.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set#iteration%5Fmethods) ```javascript playerOne.inventory.forEach((item) => {   console.log(item); }); \n``` ## Example ### Traversing a Set in Order The order of the **Realm Set** may be different from the order that the items were added. You can track the set order by updating an array when a new value is added. For example: ```javascript function updateSetAndOrderedSetArray(set, orderedArray, value) {   const oldSize = set.size;   set.add(value);   if (set.size > oldSize) {     orderedArray.push(value);   } } let playerOne; let levelsCompletedInOrder = []; const realm = await Realm.open({   schema: [characterSchema], }); realm.write(() => {   playerOne = realm.create(\"Character\", {     _id: new BSON.ObjectId(),     name: \"PlayerOne\",     inventory: [\"potion\", \"wand\", \"spell book\"],     levelsCompleted: [],   }); }); realm.write(() => {   updateSetAndOrderedSetArray(     playerOne.levelsCompleted,     levelsCompletedInOrder,     5   ); }); realm.write(() => {   updateSetAndOrderedSetArray(     playerOne.levelsCompleted,     levelsCompletedInOrder,     12   ); }); realm.write(() => {   updateSetAndOrderedSetArray(     playerOne.levelsCompleted,     levelsCompletedInOrder,     2   ); }); realm.write(() => {   updateSetAndOrderedSetArray(     playerOne.levelsCompleted,     levelsCompletedInOrder,     7   ); }); console.log(\"set ordered\", Array.from(playerOne.levelsCompleted)); // not necessarily [5, 12, 2, 7] console.log(\"insert ordered\", levelsCompletedInOrder); // [5, 12, 2, 7] // close the realm realm.close(); \n``` ← [Dictionaries - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/dictionaries/ \"Previous Section\")[Mixed - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/mixed/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/embedded-objects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Embedded Objects - React Native SDK On this page * [Overview](#overview)\n* [Realm Object Models](#realm-object-models)\n* [JSON Schema](#json-schema)\n* [Read and Write Embedded Objects](#read-and-write-embedded-objects)\n* [Create an Embedded Object](#create-an-embedded-object)\n* [Update an Embedded Object Property](#update-an-embedded-object-property)\n* [Overwrite an Embedded Object](#overwrite-an-embedded-object)\n* [Query a Collection on Embedded Object Properties](#query-a-collection-on-embedded-object-properties)\n* [Delete an Embedded Object](#delete-an-embedded-object) ## Overview An embedded object is a special type of [Realm object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-object-schemas)that models complex data about a specific object. Embedded objects are similar to [relationships](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-client-relationships), but they provide additional constraints and map more naturally to the denormalized [MongoDB document model.](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/) Realm enforces unique ownership constraints that treat each embedded object as nested data inside a single, specific parent object. An embedded object inherits the lifecycle of its parent object and cannot exist as an independent Realm object. This means that embedded objects cannot have a primary key and that Realm automatically deletes embedded objects if their parent object is deleted. ## Tip ### Embedded object types are reusable and composable You can use the same embedded object type in multiple parent object types, and you can embed objects inside other embedded objects. You can even recursively reference an embedded object type as an optional property in its own definition. ## Note ### Realm Uses Cascading Deletes for Embedded Objects When you delete a Realm object, Realm automatically deletes any embedded objects referenced by that object. Any objects that your application must persist after the deletion of their parent object should use [relationships](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-client-relationships)instead. ### Realm Object Models To define an embedded object, set `embedded`to `true`. You can reference an embedded object type from parent object types in the same way as you would define a relationship: ## Important Embedded objects cannot have a [primary key.](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/primary-key/#std-label-react-native-primary-keys)\n\n ` ### JSON Schema Embedded objects map to embedded documents in the parent type's [schema](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). This behavior differs from regular Realm objects, which map to their own MongoDB collection. ``` {   \"title\": \"Contact\",   \"bsonType\": \"object\",   \"required\": [\"_id\"],   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"name\": { \"bsonType\": \"string\" },     \"address\": {       \"title\": \"Address\",       \"bsonType\": \"object\",       \"properties\": {         \"street\": { \"bsonType\": \"string\" },         \"city\": { \"bsonType\": \"string\" },         \"country\": { \"bsonType\": \"string\" },         \"postalCode\": { \"bsonType\": \"string\" }       }     }   } } \n``` ``` {   \"title\": \"Business\",   \"bsonType\": \"object\",   \"required\": [\"_id\", \"name\", \"addresses\"],   \"properties\": {     \"_id\": \"objectId\",     \"name\": { \"bsonType\": \"string\" },     \"addresses\": {       \"bsonType\": \"array\",       \"items\": {         \"title\": \"Address\",         \"bsonType\": \"object\",         \"properties\": {           \"street\": { \"bsonType\": \"string\" },           \"city\": { \"bsonType\": \"string\" },           \"country\": { \"bsonType\": \"string\" },           \"postalCode\": { \"bsonType\": \"string\" }         }       }     }   } } \n``` ## Read and Write Embedded Objects ### Create an Embedded Object To create an embedded object, assign an instance of the embedded object to a parent object's property: ```javascript //   create an embedded address object const sydneyOrthodontics = {   street: \"42 Wallaby Way\",   city: \"Sydney\",   country: \"Australia\",   postalCode: \"2774\", }; realm.write(() => {   // create a contact object   realm.create(\"Contact\", {     _id: new BSON.ObjectId(),     name: \"Philip Sherman\",     address: sydneyOrthodontics, // embed the address in the contact object   }); }); \n``` ### Update an Embedded Object Property To update a property in an embedded object, modify the property in a write transaction: ```javascript // Find the contact with the address you want to update const harryPotter = realm   .objects(\"Contact\")   .filtered(\"name = 'Harry Potter'\")[0]; // modify the property of the embedded object in a write transaction realm.write(() => {   // update the embedded object directly through the contact   harryPotter.address.street = \"1 Hogwarts Ave\"; }); \n``` ### Overwrite an Embedded Object To overwrite an embedded object, reassign the embedded object property of a party to a new instance in a write transaction: ```javascript // create a new address const harryNewAddress = {   street: \"12 Grimmauld Place\",   city: \"London\",   country: \"UK\",   postalCode: \"E1 7AA\", }; realm.write(() => {   // overwrite the embedded object with the new address within a write transaction   harryPotter.address = harryNewAddress; }); \n``` ### Query a Collection on Embedded Object Properties Use dot notation to filter or sort a [collection](https://mongodb.com/docs/realm/sdk/react-native/realm-database/overview/#std-label-react-native-results-collections) of objects based on an embedded object property value: ## Note\n\n ```javascript const philipShermanAddress = realm   .objects(\"Contact\")   .filtered(\"name = 'Philip Sherman'\")[0].address.street; console.log(`Philip Sherman's address is ${philipShermanAddress}`); \n``` ### Delete an Embedded Object Realm Uses Cascading Deletes for Embedded Objects. To delete an embedded object, delete the embedded object's parent. ```javascript realm.write(() => {   // Deleting the contact will delete the embedded address of that contact   realm.delete(     realm.objects(\"Contact\").filtered(\"name = 'Philip Sherman'\")   ); }); \n``` ← [Relationships - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/ \"Previous Section\")[Define an Asymmetric Object - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/asymmetric-object/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/crud/update/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Update - React Native SDK On this page * [About the Examples on this Page](#about-the-examples-on-this-page)\n* [Update an Object](#update-an-object)\n* [Upsert an Object](#upsert-an-object)\n* [Bulk Update a Collection](#bulk-update-a-collection) ## About the Examples on this Page The examples on this page use the following schemas: `| const DogSchema = { |\n| ------------------- |\n| name: \"Dog\",        |\n| properties: {       |\n| name: \"string\",     |\n| owner: \"Person?\",   |\n| age: \"int?\",        |\n| },                  |\n| };                  | ` ```javascript const PersonSchema = {   name: \"Person\",   properties: {     name: \"string\",     age: \"int?\",   }, }; \n``` ## Update an Object You can add, modify, or delete properties of a Realm object inside of a write transaction in the same way that you would update any other JavaScript object. ```javascript // Open a transaction. realm.write(() => {   // Get a dog to update.   const dog = realm.objects(\"Dog\")[0];   // Update some properties on the instance.   // These changes are saved to the realm.   dog.name = \"Maximilian\";   dog.age += 1; }); \n``` ## Tip ### Update Related and Embedded Objects To update a property of an [embedded object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/embedded-objects/#std-label-react-native-embedded-objects) or a [related object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-client-relationships), modify the property with[dot-notation or bracket-notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors) as if it were in a regular, nested object. ## Upsert an Object To upsert an object, call [Realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) with the update mode set to `modified`. The operation either inserts a new object with the given primary key or updates an existing object that already has that primary key. ```javascript realm.write(() => {   // Add a new person to the realm. Since nobody with ID 1234   // has been added yet, this adds the instance to the realm.   person = realm.create(     \"Person\",     { _id: 1234, name: \"Joe\", age: 40 },     \"modified\"   );   // If an object exists, setting the third parameter (`updateMode`) to   // \"modified\" only updates properties that have changed, resulting in   // faster operations.   person = realm.create(     \"Person\",     { _id: 1234, name: \"Joseph\", age: 40 },     \"modified\"   ); }); \n``` ## Bulk Update a Collection To apply an update to a collection of objects, iterate through the collection (e.g. with [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)). In the loop, update each object individually: ```javascript realm.write(() => {   // Create someone to take care of some dogs.   const person = realm.create(\"Person\", { name: \"Ali\" });   // Find dogs younger than 2.   const puppies = realm.objects(\"Dog\").filtered(\"age < 2\");   // Loop through to update.   for (const puppy of puppies) {     // Give all puppies to Ali.     puppy.owner = person;   } }); \n``` ## Note ### Inverse Relationships\n\n ← [CRUD - Read - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/read/ \"Previous Section\")[CRUD - Delete - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/crud/create/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Create - React Native SDK On this page * [About the Examples on this Page](#about-the-examples-on-this-page)\n* [Create a New Object](#create-a-new-object) ## About the Examples on this Page The example on this page use the following schema: `| const DogSchema = { |\n| ------------------- |\n| name: \"Dog\",        |\n| properties: {       |\n| name: \"string\",     |\n| owner: \"Person?\",   |\n| age: \"int?\",        |\n| },                  |\n| };                  | ` ## Create a New Object To add an object to a realm, instantiate it as you would any other object and then pass it to [Realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) inside of a write transaction. If the realm's [schema](https://mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-realm-schema) includes the object type and the object conforms to the schema, then Realm stores the object, which is now _managed_ by the realm. ```javascript // Declare the variable that will hold the dog instance. let dog; // Open a transaction. realm.write(() => {   // Assign a newly-created instance to the variable.   dog = realm.create(\"Dog\", { name: \"Max\", age: 5 }); }); // use newly created dog object \n``` ← [CRUD - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/ \"Previous Section\")[CRUD - Read - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/read/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/index/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Index a Property - React Native SDK On this page * [Overview](#overview) ## Overview Realm supports indexing for string, integer, boolean, `Date`, `UUID`, and `ObjectId`properties. To define an index for a given property, set `indexed` to`true`. ## Note An **index** significantly increases the speed of certain read operations at the cost of slightly slower write times and additional storage and memory overhead. Realm Database stores indexes on disk, which makes your realm files larger. Each index entry is a minimum of 12 bytes. The ordering of the index entries supports efficient equality matches and range-based query operations. It's best to only add indexes when optimizing the read performance for specific situations. ## Example The following `Book` object schema defines an index on the `name`property. `| const BookSchema = {                     |\n| ---------------------------------------- |\n| name: \"Book\",                            |\n| properties: {                            |\n| name: { type: \"string\", indexed: true }, |\n| price: \"int\",                            |\n| },                                       |\n| };                                       | ` ← [Specify a Primary Key - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/primary-key/ \"Previous Section\")[Define a Default Property Value - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/default-value/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/crud/read/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Read - React Native SDK On this page * [About the Examples on this Page](#about-the-examples-on-this-page)\n* [Read Operations](#read-operations)\n* [Find a Specific Object by Primary Key](#find-a-specific-object-by-primary-key)\n* [Query an Object Type](#query-an-object-type)\n* [Filter Queries](#filter-queries)\n* [Sort Query Results](#sort-query-results) ## About the Examples on this Page The examples on this page use the following schema: `| const TaskSchema = {     |\n| ------------------------ |\n| name: \"Task\",            |\n| properties: {            |\n| _id: \"int\",              |\n| name: \"string\",          |\n| priority: \"int?\",        |\n| progressMinutes: \"int?\", |\n| },                       |\n| primaryKey: \"_id\",       |\n| };                       | ` ## Read Operations ### Find a Specific Object by Primary Key If you know the [primary key](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/primary-key/#std-label-react-native-primary-keys) for a given object, you can look it up directly with [Realm.objectForPrimaryKey().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#objectForPrimaryKey) ```javascript const myTask = realm.objectForPrimaryKey(\"Task\", 12342245); // search for a realm object with a primary key that is an int. \n``` ### Query an Object Type To query for objects of a given type in a realm, pass the type name to[Realm.objects().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#objects) Query operations return a collection of Realm objects that match the query as a [Realm.Results](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Results.html) object. A basic query matches all objects of a given type in a realm, but you can also apply a[filter](#std-label-react-native-filter-queries) to the collection to find specific objects. ```javascript // Query realm for all instances of the \"Task\" type. const tasks = realm.objects(\"Task\"); \n``` ### Filter Queries A **filter** selects a subset of results based on the value(s) of one or more object properties. Realm Database lets you filter data using[Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql), a string-based query language to constrain searches when retrieving objects from a realm. To filter a query, call [filtered()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#filtered) on the query results collection. Pass a Realm Query Language query as argument to `filtered()`. In the following example, we use the comparison operators to: * Find high priority tasks by comparing the value of the `priority` property value with a threshold number, above which priority can be considered high.\n* Find just-started or short-running tasks by seeing if the `progressMinutes`property falls within a certain range. ```javascript // retrieve the set of Task objects const tasks = realm.objects(\"Task\"); // filter for tasks with a high priority const highPriorityTasks = tasks.filtered(\"priority > 5\"); // filter for tasks that have just-started or short-running progress const lowProgressTasks = tasks.filtered(   \"1 <= progressMinutes && progressMinutes < 10\" ); console.log(   `Number of high priority tasks: ${highPriorityTasks.length} \\n`,\n\n ); \n``` ## Tip ### Filter on Related and Embedded Object Properties To filter a query based on a property of an [embedded object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/embedded-objects/#std-label-react-native-embedded-objects) or a [related object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-client-relationships), use dot-notation as if it were in a regular, nested object. ## Tip ### See also:  * [Realm Query Language Reference](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql)\n* [Query Data - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/query-data/#std-label-react-native-query-data) ### Sort Query Results A **sort** operation allows you to configure the order in which Realm Database returns queried objects. You can sort based on one or more properties of the objects in the results collection. Realm Database only guarantees a consistent order of results if you explicitly sort them. To sort a query, call the [sorted()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#sorted)method on the query results collection. ```javascript // retrieve the set of Task objects const tasks = realm.objects(\"Task\"); // Sort tasks by name in ascending order const tasksByName = tasks.sorted(\"name\"); // Sort tasks by name in descending order const tasksByNameDescending = tasks.sorted(\"name\", true); // Sort tasks by priority in descending order and then by name alphabetically const tasksByPriorityDescendingAndName = tasks.sorted([   [\"priority\", true],   [\"name\", false], ]); // Sort dogs by dog's owner's name. let dogsByOwnersName = realm.objects(\"Dog\").sorted(\"owner.name\"); \n``` To sort a query based on a property of an [embedded object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/embedded-objects/#std-label-react-native-embedded-objects) or a [related object](https://mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/relationships/#std-label-react-native-client-relationships), use dot-notation as if it were in a regular, nested object. ← [CRUD - Create - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/create/ \"Previous Section\")[CRUD - Update - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/update/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/crud/query-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query Data - React Native SDK On this page * [Examples on This Page](#examples-on-this-page)\n* [Construct a Query](#construct-a-query)\n* [Operators](#operators)\n* [Comparison Operators](#comparison-operators)\n* [Logical Operators](#logical-operators)\n* [String Operators](#string-operators)\n* [Aggregate Operators](#aggregate-operators)\n* [Collection Operators](#collection-operators)\n* [Summary](#summary) To filter data in your Realms, construct queries with Realm Query Language. For more information about syntax, usage and limitations, refer to the [Realm Query Language reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Examples on This Page The examples in this page use a simple data set for a task list app. The two Realm object types are `Project`and `Task`. A `Task` has a name, assignee's name, and completed flag. There is also an arbitrary number for priority (higher is more important) and a count of minutes spent working on it. A `Project` has zero or more`Tasks`. See the schema for these two classes, `Project` and`Task`: `| const TaskSchema = {    |\n| ----------------------- |\n| name: \"Task\",           |\n| properties: {           |\n| name: \"string\",         |\n| isComplete: \"bool\",     |\n| priority: \"int\",        |\n| progressMinutes: \"int\", |\n| assignee: \"string?\"     |\n| }                       |\n| };                      |\n| const ProjectSchema = { |\n| name: \"Project\",        |\n| properties: {           |\n| name: \"string\",         |\n| tasks: \"Task[]\"         |\n| }                       |\n| };                      | ` ## Construct a Query To filter data, pass a query made with Realm Query Language to[Realm.Results.filtered()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Results.html#filtered) ```js const tasks = realm.objects(\"Task\"); // Gets all tasks where the 'priority' property is 7 or more. const importantTasks = tasks.filtered(\"priority >= 7\"); \n``` ## Operators There are several types of operators available to filter a[Realm collection](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-results-collections). Filters work by **evaluating** an operator expression for every object in the collection being filtered. If the expression resolves to `true`, Realm Database includes the object in the results collection. An **expression** consists of one of the following: * The name of a property of the object currently being evaluated.\n* An operator and up to two argument expression(s).\n* A literal string, number, or date. ### Comparison Operators The most straightforward operation in a search is to compare values. Realm Query Language has standard comparison operators like `==`,`>`, `>=`, `in`, `<`, `<=`, and `!=`. For complete documentation on comparison operators, refer to the [Realm Query Language comparison operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-comparison-operators) The following example uses the query engine's comparison operators to:\n\n ```javascript const highPriorityTasks = tasks.filtered(\"priority > 5\"); const unassignedTasks = tasks.filtered(\"assignee == null\"); const lowProgressTasks = tasks.filtered(\"1 <= progressMinutes && progressMinutes < 10\"); const aliTasks = tasks.filtered(\"assignee == 'Ali'\"); console.log(   `Number of high priority tasks: ${highPriorityTasks.length}`,   `Number of unassigned tasks: ${unassignedTasks.length}`,   `Number of just-started or short-running tasks: ${lowProgressTasks.length}`,   `Number of tasks for Ali: ${aliTasks.length}` ); \n``` ### Logical Operators Create compound predicates using logical operators. Realm Query Language has standard logical operators like `AND`, `OR`, and `NOT`. For complete documentation on logical operators, refer to the [Realm Query Language logical operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-logical-operators) The following example uses Realm Query Language's logical operators to find all of Ali's completed tasks. We find all tasks where the `assignee` property value is equal to 'Ali' AND the `isComplete` property value is `true`. ```javascript console.log(   \"Number of Ali's complete tasks: \" +     tasks.filtered(\"assignee == 'Ali' && isComplete == true\").length ); \n``` ### String Operators You can compare string values using string operators like `==`, `beginsWith`,`contains`, and `endsWith`. You can also use the `LIKE` operator to search with regex-like wildcards. For complete documentation on string operators, refer to the [Realm Query Language string operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-string-operators) The following example uses Realm Query Language's string operators to find projects with a name starting with the letter 'e' and projects with names that contain 'ie'. ```javascript // Use [c] for case-insensitivity. console.log(   \"Projects that start with 'e': \" +     projects.filtered(\"name BEGINSWITH[c] 'e'\").length ); console.log(   \"Projects that contain 'ie': \" +     projects.filtered(\"name CONTAINS 'ie'\").length ); \n``` ### Aggregate Operators Traverse a [collection](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-results-collections) and reduce it to a single value with an aggregate operator. For complete documentation on aggregate operators, refer to the [Realm Query Language aggregate operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-aggregate-operators) The following examples uses aggregate operators to show different facets of the data: * `@avg` to show projects with average tasks priority above 5.\n* `@sum` to show long running projects. ```javascript console.log(   \"Number of projects with average tasks priority above 5: \" +     projects.filtered(\"tasks.@avg.priority > 5\").length ); console.log(   \"Number of long-running projects: \" +     projects.filtered(\"tasks.@sum.progressMinutes > 120\").length ); \n``` ### Collection Operators A **collection operator** uses rules to determine whether to pass each input collection object to the output collection by applying a given predicate to every element of a given list property of the object. For complete documentation on collection operators, refer to the [Realm Query Language collection operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-collection-operators) The following examples uses Realm Query Language's collection operators to find: * `ALL` for projects with no complete tasks.\n* `ANY` for projects with any top priority tasks. ```javascript console.log(   \"Number of projects with no complete tasks: \" +     projects.filtered(\"ALL tasks.isComplete == false\").length ); console.log(   \"Number of projects with any top priority tasks: \" +     projects.filtered(\"ANY tasks.priority == 10\").length ); \n``` ## Summary\n\n ← [CRUD - Delete - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/delete/ \"Previous Section\")[React to Changes - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/react-to-changes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/logging/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Logging - .NET SDK On this page * [Set the Client Log Level](#set-the-client-log-level)\n* [Customize the Logging Function](#customize-the-logging-function) ## Set the Client Log Level To control which messages are logged by the client logger, use[LogLevel:](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Logging.LogLevel.html) `| Logger.LogLevel = LogLevel.Debug; |\n| --------------------------------- | ` ## Tip To diagnose and troubleshoot errors while developing your application, set the log level to `debug` or `trace`. For production deployments, decrease the log level for improved performance. ## Customize the Logging Function To set a custom logger function, set [Logger.Default](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Logging.Logger.html) to a custom Logger function. ```csharp using Realms.Logging; Logger.LogLevel = LogLevel.All; // customize the logging function: Logger.Default = Logger.Function(message => {     // Do something with the message }); \n``` ← [Integrate Realm with Unity - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/unity/ \"Previous Section\")[Platform and Framework Compatibility - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/compatibility/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/crud/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Delete - React Native SDK On this page * [About the Examples on this Page](#about-the-examples-on-this-page)\n* [Delete an Object](#delete-an-object)\n* [Delete Multiple Objects](#delete-multiple-objects)\n* [Delete All Objects of a Specific Type](#delete-all-objects-of-a-specific-type)\n* [Delete All Objects in a Realm](#delete-all-objects-in-a-realm) ## About the Examples on this Page The examples on this page use the following schemas: `| const DogSchema = { |\n| ------------------- |\n| name: \"Dog\",        |\n| properties: {       |\n| name: \"string\",     |\n| owner: \"Person?\",   |\n| age: \"int?\",        |\n| },                  |\n| };                  | ` ```javascript const CatSchema = {   name: \"Cat\",   properties: {     name: \"string\",   }, }; \n``` ## Delete an Object To delete an object from a realm, pass the object to [Realm.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#delete) inside of a write transaction. ```javascript realm.write(() => {   // Delete the dog from the realm.   realm.delete(dog);   // Discard the reference.   dog = null; }); \n``` ## Important ### Do not use objects after delete You cannot access or modify an object after you have deleted it from a Realm. If you try to use a deleted object, Realm Database throws an error. ## Delete Multiple Objects To delete a collection of objects from a realm, pass the collection to[Realm.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#delete) inside of a write transaction. ```javascript realm.write(() => {   // Find dogs younger than 2 years old.   const puppies = realm.objects(\"Dog\").filtered(\"age < 2\");   // Delete the collection from the realm.   realm.delete(puppies); }); \n``` ## Delete All Objects of a Specific Type To delete all objects of a given object type from a realm, pass`Realm.objects(<ObjectType>)` to the [Realm.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#delete) method inside of a write transaction. ```javascript realm.write(() => {   // Delete all instances of Cat from the realm.   realm.delete(realm.objects(\"Cat\")); }); \n``` ## Delete All Objects in a Realm To delete **all** objects from the realm, call [Realm.deleteAll()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#deleteAll) inside of a write transaction. This clears the realm of all object instances but does not affect the realm's schema. ```javascript realm.write(() => {   // Delete all objects from the realm.   realm.deleteAll(); }); \n``` ## Tip ### Delete All In Development [Realm.deleteAll()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#deleteAll) is a useful method to quickly clear out your realm in the course of development. For example, rather than writing a migration to update objects to a new schema, it may be faster to delete and then re-generate the objects with the app itself. ← [CRUD - Update - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/update/ \"Previous Section\")[Query Data - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/query-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - .NET SDK MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Troubleshooting - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/troubleshooting/ \"Previous Section\")[Realm Node.js SDK](https://mongodb.com/docs/realm/sdk/node/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/realm-database/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - .NET SDK On this page * [Database Internals](#database-internals)\n* [Native Database Engine](#native-database-engine)\n* [Realm Files](#realm-files)\n* [Copy-on-Write: The Secret Sauce of Data Versioning](#copy-on-write--the-secret-sauce-of-data-versioning)\n* [Memory Mapping](#memory-mapping)\n* [Compaction](#compaction)\n* [ACID Compliance](#acid-compliance)\n* [Features](#features)\n* [Queries](#queries)\n* [Encryption](#encryption)\n* [Indexes](#indexes)\n* [Schemas](#schemas)\n* [Persistent or In-Memory Realms](#persistent-or-in-memory-realms)\n* [Atlas Device Sync](#atlas-device-sync)\n* [Realm vs Other Databases](#realm-vs-other-databases)\n* [Live Queries](#live-queries)\n* [Read Characteristics](#read-characteristics)\n* [Live Objects](#live-objects)\n* [Realm .NET SDK Examples](#realm-.net-sdk-examples) Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) This page explains some of the implementation details and inner workings of Realm Database and Device Sync. This page is for you if you are: * a developer interested in learning more about Realm Database\n* comparing Realm Database with competing databases\n* trying to understand how Realm Database works with Device Sync This explanation begins with a deep dive into database internals, continues with a high-level introduction to some of the features of Realm Database, and wraps up with some of the differences of working with Device Sync and the local version of Realm Database. ## Database Internals Realm Database uses a completely unique database engine, file format, and design. This section describes some of the high-level details of those choices. This section applies to both the device-local version of Realm Database as well as the networked Device Sync version. Differences between the local database and the synchronized database are explained in the Atlas Device Sync section. ### Native Database Engine Realm Database is an entire database written from scratch in C++, instead of building on top of an underlying database engine like SQLite. Realm Database's underlying storage layer uses[B+ trees](https://en.wikipedia.org/wiki/B%2B%5Ftree) to organize objects. As a result, Realm Database controls optimizations from the storage level all the way up to the access level. Realm Database stores data in **realms**: collections of heterogeneous realm objects. You can think of each realm as a database. Each object in a realm is equivalent to a row in a SQL database table or a MongoDB document. Unlike SQL, realms do not separate different object types into individual tables. Realm Database stores objects as groups of property values. We call this column-based storage. This means that queries or writes for individual objects can be slower than row-based storage equivalents when unindexed, but querying a single field across multiple objects or fetching multiple objects can be much faster due to spatial locality and in-CPU vector operations. Realm Database uses a [zero-copy](https://en.wikipedia.org/wiki/Zero-copy) design to make queries faster than an ORM, and often faster than raw SQLite. ### Realm Files\n\n * **realm files**, suffixed with \"realm\", e.g. `default.realm`: contain object data.\n* **lock files**, suffixed with \"lock\", e.g. `default.realm.lock`: keep track of which versions of data in a realm are actively in use. This prevents realm from reclaiming storage space that is still used by a client application.\n* **note files**, suffixed with \"note\", e.g. `default.realm.note`: enable inter-thread and inter-process notifications.\n* **management files**, suffixed with \"management\", e.g. `default.realm.management`: internal state management. Realm files contain object data with the following data structures: Groups, Tables, Cluster Trees, and Clusters. Realm Database organizes these data structures into a tree structure with the following form: * The top level, known as a Group, stores object metadata, a transaction log, and a collection of Tables.\n* Each class in the realm schema corresponds to a Table within the top-level Group.\n* Each Table contains a Cluster Tree, an implementation of a B+ tree.\n* Leaves on the Cluster Tree are called Clusters. Each contains a range of objects sorted by key value.\n* Clusters store objects as collections of columns.\n* Each column contains data for a single property for multiple instances of a given object. Columns are arrays of data with uniformly sized values.\n* Columns store data in one of the following sizes: 1, 2, 4, 8, 16, 32, or 64 bits. Each column uses one value size, determined by the largest value. Since pointers refer to memory addresses, objects written to persistent files cannot store references as pointers. Instead, realm files refer to data using the offset from the beginning of the file. We call this a ref. As Realm Database uses memory mapping to read and write data, database operations translate these refs from offsets to memory pointers when navigating database structures. ### Copy-on-Write: The Secret Sauce of Data Versioning Realm Database uses a technique called **copy-on-write**, which copies data to a new location on disk for every write operation instead of overwriting older data on disk. Once the new copy of data is fully written, the database updates existing references to that data. Older data is only garbage collected when it is no longer referenced or actively in use by a client application. Because of copy-on-write, older copies of data remain valid, since all of the references in those copies still point to other valid data. Realm Database leverages this fact to offer multiple versions of data simultaneously to different threads in client applications. Most applications tie data refreshes to the repaint cycle of the looper thread that controls the UI, since data only needs to refresh as often as the UI does. Longer-running procedures on background threads, such as large write operations, can work with a single version of data for a longer period of time before committing their changes. ### Memory Mapping Writes use [memory mapping](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) to avoid copying data back and forth from memory to storage. Accessors and mutators read and write to disk via memory mapping. As a result, object data is never stored on the stack or heap of your app. By default, data is memory-mapped as read-only to prevent accidental writes. Realm Database uses operating system level paging, trusting each operating system to implement memory mapping and persistence better than a single library could on its own. ### Compaction Realm Database automatically reuses free space that is no longer needed after database writes. However, realm files never shrink automatically, even if the amount of data stored in your realm decreases significantly. Compact your realm to optimize storage space and decrease file size if possible. You should compact your realms occasionally to keep them at an optimal size. You can do this manually, or by configuring your realms to compact on launch. However, Realm Database reclaims unused space for future writes, so compaction is only an optimization to conserve space on-device. ### ACID Compliance Realm Database guarantees that transactions are [ACID](https://en.wikipedia.org/wiki/ACID) compliant. This means that all committed write operations are guaranteed to be valid and that clients don't see transient states in the event of a system crash. Realm Database complies with ACID with the following design choices:\n\n ## Features Realm Database supports many popular database features. ### Queries You can query Realm Database using platform-native queries or a raw query language that works across platforms. ### Encryption Realm Database supports on-device realm encryption. Since memory mapping does not support encryption, encrypted realms use a simulated in-library form of memory mapping instead. ## Note Realm forbids opening the same encrypted realm from multiple processes. Attempting to do so will throw the error: \"Encrypted interprocess sharing is currently unsupported.\" ### Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time. ### Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, do not require a migration. After you increment the local schema version, you can begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. See your SDK's documentation for more information on migrations. ### Persistent or In-Memory Realms You can use Realm Database to store data persistently on disk, or ephemerally in memory. Ephemeral realms can be useful in situations where you don't need to persist data between application instances, such as when a user works in a temporary workspace. ## Atlas Device Sync Device Sync adds network synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. Device Sync relies on a worker client that communicates with your application backend in a dedicated thread in your application. Additionally, synced realms keep a history of changes to contained objects. Sync uses this history to resolve conflicts between client changes and backend changes. Applications that use Device Sync define their schema on the backend using[JSON Schema](https://json-schema.org/learn/getting-started-step-by-step.html). Client applications must match that backend schema to synchronize data. However, if you prefer to define your initial schema in your application's programming language, you can use [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to create a backend JSON Schema based on native SDK objects as you write your application. However, once your application is used for production purposes, you should alter your schema using JSON Schema on the backend. ## Realm vs Other Databases The Realm data model is similar to both relational and document databases but has distinct differences from both. To underscore these differences, it's helpful to highlight what a realm **is not**: A realm is not a single, application-wide database. Applications based on other database systems generally store all of their data in a single database. Apps often split data across multiple realms to organize data more efficiently and to enforce access controls. A realm is not a relational table. Normalized tables in relational databases only store one type of information, such as street addresses or items in a store inventory. A realm can contain any number of object types that are relevant to a given domain. A realm is not a collection of schemaless documents. Document databases don't necessarily enforce a strict schema for the data in each collection. While similar to documents in form, every Realm object conforms to a schema for a specific object type in the realm. An object cannot contain a property that is not described by its schema. ## Live Queries You can read back the data that you have [stored](https://mongodb.com/docs/realm/sdk/dotnet/crud/write-transactions/#std-label-dotnet-write-transactions) in Realm Database by finding, filtering, and sorting objects. To get the best performance from Realm as your app grows and your queries become more complex, design your app's data access patterns around a solid understanding of Realm Database read characteristics. ### Read Characteristics When you design your app's data access patterns around the following three key characteristics of reads in Realm Database, you can be confident you are reading data as efficiently as possible.\n\n ### Live Objects All Realm objects are **live objects**, which means they automatically update whenever they're modified. Realm emits a[notification event](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-react-to-changes) whenever any property changes. You can use live objects to work with object-oriented data natively without an [ORM](https://en.wikipedia.org/wiki/Object-relational%5Fmapping) tool. Live objects are direct proxies to the underlying stored data, which means that a live object doesn't directly contain data. Instead, a live object always references the most up-to-date data on disk and [lazy loads](https://en.wikipedia.org/wiki/Lazy%5Floading) property values when you access them from a[collection](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/#std-label-dotnet-client-collections). This means that a realm can contain many objects but only pay the performance cost for data that the application is actually using. Valid write operations on a live object automatically persist to the realm and propagate to any other synced clients. You do not need to call an update method, modify the realm, or otherwise \"push\" updates. ## Realm .NET SDK Examples * Each of the pages in the .NET SDK documentation contain example code showing a specific task.\n* The [Quick Start](https://mongodb.com/docs/realm/sdk/dotnet/quick-start/#std-label-dotnet-client-quick-start) contains content to get you developing a Realm app with minimal explanation.\n* The [.NET Tutorial](https://www.mongodb.com/docs/atlas/app-services/tutorial/dotnet/#std-label-dotnet-tutorial) starts with a template application t0 provide a complete, working application.\n* The [example applications](https://github.com/realm/realm-dotnet/tree/main/examples)provide examples for .NET that demonstrate how to use Realm features. ← [Realm .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/ \"Previous Section\")[Install Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/install/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/react-native/integrations/mac-catalyst/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Build using Mac Catalyst On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Update Your Build Phase Settings](#update-your-build-phase-settings)\n* [Update Your Podfile](#update-your-podfile)\n* [Activate and Test Catalyst in Your Project](#activate-and-test-catalyst-in-your-project) ## Overview This page details steps required for building your Realm application when using [Mac Catalyst](https://developer.apple.com/mac-catalyst/) with [React Native version 0.64 and below](https://reactnative.dev/versions). ## Note Version 10.6.0 and above of the Realm React Native SDK supports Mac Catalyst. ## Important Version 0.65 and above of React Native do not require these additional steps to build using Mac Catalyst. ## Tip ### See also:  [Install Realm for React Native](https://mongodb.com/docs/realm/sdk/react-native/install/#std-label-react-native-install) ## Procedure 1 ### Update Your Build Phase Settings Before you can use Mac Catalyst in your React Native application, you must specify the platform name. Click Build Phases in XCode, and within the Bundle React Native code and images tab, add the following to specify \"ios\" as the platform name. `| export PLATFORM_NAME=ios |\n| ------------------------ | ` 2 ### Update Your Podfile ## Note This is a temporary step that will not be necessary when the following Cocoapods issue is solved:[\\[Catalyst\\] Podspec Resource Bundle requires a development team](https://github.com/CocoaPods/CocoaPods/issues/8891) Currently, there is a [Cocoapods bug](https://github.com/CocoaPods/CocoaPods/issues/8891) that causes XCode to require a development team when building for Mac Catalyst. This bug prevents signing locally. As a workaround, you can alter your Podfile to fix your bundle target's signing certificate to sign to run locally. Replace the post-install script in your Podfile by removing the following lines: ``` post_install do |installer|   react_native_post_install(installer) end \n``` And copy the following lines where your previous post-install script was: ``` post_install do |installer|   react_native_post_install(installer)   installer.pods_project.targets.each do |target|     # Fix bundle targets' 'Signing Certificate' to 'Sign to Run Locally'     if target.respond_to?(:product_type) and target.product_type == \"com.apple.product-type.bundle\"       target.build_configurations.each do |config|         config.build_settings['CODE_SIGN_IDENTITY[sdk=macosx*]'] = '-'       end     end   end end \n``` 3 ### Activate and Test Catalyst in Your Project To test out Catalyst in your project, activate Mac in the generaltab of your XCode project workspace. To do this, click Mac in theDeployment Info section. Select \"Scale Interface to Match iPad\". This makes \"My Mac\" selectable, allowing you to run your application on your Mac. ![Activate your Mac in Xcode Project Workspace](https://mongodb.com/docs/realm/images/activate-my-mac-xcode-catalyst.png) ← [Realm Integrations - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/integrations/ \"Previous Section\")[Telemetry - React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/telemetry/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/crud/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - .NET SDK * [Create](https://mongodb.com/docs/realm/sdk/dotnet/crud/create/)\n* [Read](https://mongodb.com/docs/realm/sdk/dotnet/crud/read/)\n* [Filter and Sort Data](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/)\n* [Update](https://mongodb.com/docs/realm/sdk/dotnet/crud/update/)\n* [Delete](https://mongodb.com/docs/realm/sdk/dotnet/crud/delete/)\n* [Threading](https://mongodb.com/docs/realm/sdk/dotnet/crud/threading/)\n* [Transactions](https://mongodb.com/docs/realm/sdk/dotnet/crud/write-transactions/) ← [Data Binding - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-binding/ \"Previous Section\")[Create Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/realm-files/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Work with Realm Files - .NET SDK * [Configure & Open a Realm](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/realms/)\n* [Delete a Realm](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/delete-a-realm/)\n* [Bundle a Realm](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/bundle-a-realm/)\n* [Reduce Realm File Size](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/compact-realm/)\n* [Encrypt a Realm](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/encrypt-a-realm/) ← [Quick Start - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/quick-start/ \"Previous Section\")[Configure & Open a Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/realms/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Data Between Devices - .NET SDK ## Overview Atlas Device Sync automatically synchronizes data between client applications and an [Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/#std-label-realm-cloud). When a client device is online, Sync asynchronously synchronizes data in a background thread between the device and your backend App. When you use Sync in your client application, your implementation must match the Sync Mode you select in your backend App configuration. The Sync Mode options are: * Partition-Based Sync\n* Flexible Sync You can only use one Sync Mode for your application. You cannot mix Partition-Based Sync and Flexible Sync within the same App. ## Tip ### See also:  [Configure and Enable Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) ## Partition-Based Sync When you select [Partition-Based Sync](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync) for your backend App configuration, your client implementation must include a partition value. This is the value of the [partition key](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-key) field you select when you configure Partition-Based Sync. The partition value determines which data the client application can access. You pass in the partition value when you open a synced realm. ## Flexible Sync When you select [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) for your backend App configuration, your client implementation must include subscriptions to queries on [queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields). Flexible Sync works by synchronizing data that matches query subscriptions you maintain in the client application. A subscription set contains a set of queries. Realm Flexible Sync returns documents matching those queries, where the user has the appropriate[permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read and/or read and write the documents. If documents match the query, but the client does not have the permission to read or write them, they do not sync to the client application. You can form queries using [Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) or LINQ. ## Note Flexible Sync does not support all the query operators available in Realm Query Language and the SDK's query engine. See [Flexible Sync RQL Limitations](https://mongodb.com/docs/realm/realm-query-language/#std-label-flexible-sync-rql-limitations) for details. Subscription sets are based on a specific type of [Realm object](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects). You can have multiple subscriptions if you have many types of Realm objects. To use Flexible Sync in your client application, open a synced realm with a Flexible Sync configuration. Then, manage subscriptions to determine which documents to sync. ### Group Updates for Improved Performance Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change. ## Unidirectional Sync A special case of Flexible Sync is when you need your app to **send** data to Atlas, but not receive any updates. In this scenario, you can maximize sync performance by using[Asymmetric Sync](https://mongodb.com/docs/realm/sdk/dotnet/sync/asymmetric-sync/#std-label-dotnet-asymmetric-sync) to stream data from the client application to a Flexible Sync-enabled Atlas App Services App.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/compatibility/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Platform and Framework Compatibility - .NET SDK On this page * [Compatibility](#compatibility)\n* [Development Environments](#development-environments)\n* [Android Deployment](#android-deployment)\n* [Limitations](#limitations) ## Compatibility The following table shows which .NET version(s) you can use with Realm on your target platforms:\n\n ## Development Environments You can use the following development environments to build Realm apps with the .NET SDK: * Visual Studio 2015 Update 2 or higher for Windows\n* Visual Studio for Mac 7.0 or higher\n* Unity [2020.3.12f1 (LTS)](https://unity3d.com/get-unity/download/archive) ## Note The [Realm .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/) may be compatible with other versions of Unity, but `2020.3.12f1 (LTS)` is the version that the Realm team uses for testing and development. We recommend using this version to ensure your project works with Realm and that the install steps match the [Integrate Realm with Unity](https://mongodb.com/docs/realm/sdk/dotnet/unity/) documentation steps because Unity's UI often changes between versions. ## Android Deployment Due to some instruction set limitations, Realm does not support deploying Android apps to the `armeabi` ABI. Because default templates often have different ABI settings for Debug and Release modes, your app may throw a `System.TypeInitializationException` exception in Release mode but not when it was running in Debug mode. To avoid this, verify the ABI settings for both Debug and Release modes. To check and change the settings, follow the steps in the[Visual Studio CPU Architectures](https://docs.microsoft.com/en-us/xamarin/android/app-fundamentals/cpu-architectures)page. Unless you have a good reason to avoid linking other ABIs, we recommend checking all of the settings other than `armabi`: ![ABI settings](https://mongodb.com/docs/realm/images/ABI-settings.png) ## Limitations Realm has limits imposed to balance flexibility with performance. The SDK throws an exception during app initialization if the following limits are exceeded: * Class names can't exceed 57 bytes in length.\n* Property names can't exceed 63 bytes in length. In addition, for iOS apps, the total size of all open Realm files cannot be larger than the amount of memory your application is allowed to map in iOS. This varies per device, and depends on how fragmented the memory space on the device is. If you need to store more data than is allowed, you can split your data into multiple Realm files, open a realm only when needed, and close it when it is no longer needed. For more information, see [Open Radar 17119975](http://www.openradar.me/17119975). ← [Logging - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/logging/ \"Previous Section\")[Troubleshooting - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/troubleshooting/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm - .NET SDK On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Installation](#installation)\n* [Open the NuGet Package Manager](#open-the-nuget-package-manager)\n* [Add the Realm Package](#add-the-realm-package)\n* [Open the NuGet Package Manager](#open-the-nuget-package-manager-1)\n* [Add the Realm Package](#add-the-realm-package-1)\n* [Add the Realm Weaver to FodyWeavers.xml](#add-the-realm-weaver-to-fodyweavers.xml)\n* [Import Realm](#import-realm) ## Overview Realm's .NET SDK enables development of applications in C# for the .NET,[.NET MAUI](https://dotnet.microsoft.com/en-us/apps/maui),[UWP](https://docs.microsoft.com/en-us/windows/uwp/get-started/), [Xamarin](https://dotnet.microsoft.com/apps/xamarin), and [Unity](https://unity.com/) ecosystems. For more information about specific version support for .NET, .NET MAUI, UWP, and Xamarin, see [Platform and Framework Compatibility - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/compatibility/#std-label-dotnet-compatibility) ## Note Integrating the Realm .NET SDK with Unity has different prerequisites and install steps than the ones below. Learn how to [Integrate Realm with Unity.](https://mongodb.com/docs/realm/sdk/dotnet/unity/) ## Prerequisites Before getting started, ensure you have installed Visual Studio: * [Visual Studio](https://visualstudio.microsoft.com/downloads/) 2015 Update 2 or later.\n* [Visual Studio for Mac](https://visualstudio.microsoft.com/vs/mac/) 7.0 or later. ## Installation Follow these steps to add the Realm .NET SDK to your project. ## Important ### Install the SDK for all projects If you have a multi-platform solution, be sure to install the SDK for**all of the platform projects**, even if the given project doesn't contain any Realm-specific code. ## Import Realm Add the following line to the top of your source files to use Realm: `| using Realms; |\n| ------------- | ` ← [Realm Database - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/ \"Previous Section\")[Quick Start - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/quick-start/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/async-console/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Use Realm in a Console App - .NET SDK On this page * [Overview](#overview)\n* [Usage](#usage) ## Overview Realm instances and objects are bound to a[SynchronizationContext](https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext?view=net-5.0), which means that they can only be accessed on the same thread on which they are created. On platforms with a UI thread, the framework installs a`SynchronizationContext` on the main thread, allowing you to make reads and writes to the database with asynchronous calls. However, in console apps, there is no UI thread, and thus no`SynchronizationContext` installed. This means that if you `await` an asynchronous Task, a random thread is spun up from the thread pool, from which you can no longer access any previously-opened Realm instances. To be able to efficiently use Realm between asynchronous calls, you should install a `SynchronizationContext` \\- either one you implement yourself, or one provided in a 3rd party library. ## Usage In the following example, we have built a console app that uses the third-party[Nito.AsyncEx](https://github.com/StephenCleary/AsyncEx) package to provide an `AsyncContext`, under which we run our realm code:\n\n ` ← [Unidirectional Data Sync - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/asymmetric-sync/ \"Previous Section\")[Integrate Realm with Unity - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/unity/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Model Data - .NET SDK * [Define an Object Model](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/)\n* [Object Types and Schemas](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/)\n* [Supported Data Types](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/)\n* [Manually Define a Schema](https://mongodb.com/docs/realm/sdk/dotnet/model-data/manual-schema/)\n* [Relationships](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/)\n* [Change an Object Model](https://mongodb.com/docs/realm/sdk/dotnet/model-data/change-an-object-model/)\n* [Data Binding](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-binding/) ← [Encrypt a Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/encrypt-a-realm/ \"Previous Section\")[Object Models - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - .NET SDK On this page * [Import Realm](#import-realm)\n* [Define Your Object Model](#define-your-object-model)\n* [Open a Local Realm](#open-a-local-realm)\n* [Create, Read, Update, and Delete Objects](#create--read--update--and-delete-objects)\n* [Watch for Changes](#watch-for-changes)\n* [Add Device Sync (Optional)](#add-device-sync--optional-)\n* [Prerequisites](#prerequisites)\n* [Initialize the App](#initialize-the-app)\n* [Use Object Models with Sync](#use-object-models-with-sync)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm) This Quick Start demonstrates how to use Realm Database with the Realm .NET SDK. Before you begin, ensure you have [Installed the .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/install/#std-label-dotnet-install) ## Import Realm In the shared code project of your solution, go to Manage NuGet Packages. In the NuGet Package Manager, switch to the Browse tab and then search for **Realm**. Select the latest version of the Realm package, and then click Add Package. ![Adding Realm via Nuget](https://mongodb.com/docs/realm/images/add-realm-via-nuget.png) At the top of each C# file that uses Realm, add the following `using`statement: `| using Realms; |\n| ------------- | ` ## Define Your Object Model Your application's [object model](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects) defines the data that you can store within Realm Database and synchronize to and from App Services. ## Important ### Inheritance All Realm objects inherit from the[IRealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IRealmObject.html),[IEmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IEmbeddedObject.html), or[IAsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IAsymmetricObject.html)interface and should be declared `partial` classes. You can also derive from the[RealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmObject.html),[EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.EmbeddedObject.html), or[AsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.AsymmetricObject.html)base classes. However, in the future we may deprecate the base classes. You should use the interfaces for any new classes that you write. The following code shows how to define an object model for a `Item` object. In this example, we have marked the `Id` field as the Primary Key, marked the`Name` and `Status` properties as \"required\", and are using the `MapTo`attribute so we can use .NET-friendly casing on our property names when using Device Sync. ```csharp using MongoDB.Bson; using Realms; namespace Examples.Models {     public class Item : RealmObject     {         [PrimaryKey]         [MapTo(\"_id\")]         public ObjectId Id { get; set; } = ObjectId.GenerateNewId();         [MapTo(\"_partition\")]         [Required]         public string Partition { get; set; }         [MapTo(\"assignee\")]\n\n         [MapTo(\"name\")]         [Required]         public string Name { get; set; }         [MapTo(\"status\")]         [Required]         public string Status { get; set; }     } \n``` ## Open a Local Realm In a local-only Realm Database, you open a realm with either the[Realm.GetInstance()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FGetInstance%5FSystem%5FString%5F) or[Realm.GetInstanceAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FGetInstanceAsync%5FRealms%5FRealmConfigurationBase%5FSystem%5FThreading%5FCancellationToken%5F)method. Which method you use depends entirely on if and how you are using [asynchronous patterns](https://docs.microsoft.com/en-us/dotnet/csharp/async) in your app. The following code shows how to use `GetInstance()`: ```csharp var realm = Realm.GetInstance(); \n``` For more information, see: [Open a Realm.](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/realms/#std-label-dotnet-open-a-realm) ## Create, Read, Update, and Delete Objects Once you have opened a realm, you can create [objects](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects)in it. All writes must occur within a[Write transaction](https://mongodb.com/docs/realm/sdk/dotnet/crud/create/#std-label-dotnet-realm-database-writes) block. The following code shows how to create a new `Guitar` object. In it, we instantiate the `Guitar` class and then add the new guitar to the realm within a [Write()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FWrite%5F%5F1%5FSystem%5FFunc%5F%5F%5F0%5F%5F)block: ```csharp realm.Write(() => {     realm.Add(new Guitar()     {         Make = \"Gibson\",         Model = \"Les Paul Custom\",         Price = 649.99,         Owner = \"N. Young\"     }); }); \n``` You can retrieve a live [collection](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/#std-label-dotnet-client-collections) of all`Guitar` objects in the realm: ```csharp var allGuitars = realm.All<Guitar>(); \n``` You can filter the collection by using the[LINQ](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/)syntax: ```csharp var lessExpensiveGuitars = realm.All<Guitar>().Where(g => g.Price < 400); var guitarsSortedByMake = realm.All<Guitar>().OrderBy(g => g.Make); var specifiGuitarById = realm.Find<Guitar>(someGuitarId); \n``` To modify a realm object, update its properties in a write transaction block: ```csharp var davidsStrat = realm.All<Guitar>().FirstOrDefault(     g => g.Owner == \"D. Gilmour\"     && g.Make == \"Fender\"     && g.Model == \"Stratocaster\"); realm.Write(() => {\n\n }); \n``` Finally, you can delete a todo: ```csharp var mostExpensiveGuitar = realm.All<Guitar>()     .OrderByDescending(g => g.Price).First(); realm.Write(() => {     realm.Remove(mostExpensiveGuitar); }); \n``` ## Watch for Changes You can [watch a realm, collection, or object for changes](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-react-to-changes) with the[SubscribeForNotifications()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IRealmCollection-1.html#Realms%5FIRealmCollection%5F1%5FSubscribeForNotifications%5FRealms%5FNotificationCallbackDelegate%5F%5F0%5F%5F)method. Be sure to retain the notification token returned by `SubscribeForNotifications`as long as you want to continue watching for changes. When you are done, call the [Dispose()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FDispose) method: ```csharp var token = fido.Owners.SubscribeForNotifications((sender, changes, error) => {     if (error != null) return;     if (changes == null) return; }); token.Dispose(); \n``` ## Add Device Sync (Optional) If you want to sync Realm data across devices, you can set up an Atlas App Services App and enable Device Sync. For more information on what you can do with App Services, see: [Application Services - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/application-services/#std-label-dotnet-application-services) ### Prerequisites Before you can sync Realm data, you must: * [Create an App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* Enable and configure one or more [authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)\n* [Enable Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) with[Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) toggled to `On` and an unique field in the Queryable Fields section. In the following code, we have enabled anonymous authentication and are using the `ownerId` as the unique field in the Flexible Sync configuration. ### Initialize the App To use App Services features such as authentication and sync, access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) in the App Services UI. You then initialize your app: ```csharp app = App.Create(myRealmAppId); \n``` ### Use Object Models with Sync When using [Sync](#std-label-quick-start-sync), you can define your object models directly in code only if you enabled Sync with[Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) in the App Services UI. ## Note ### Get Schema from UI if Development Mode Disabled If you have enabled Sync but turned off Development Mode, you can copy and paste the object model definitions that App Services generated for you from the SDKs tab in the App Services UI. You must re-enable Development Mode if you want to make changes to the object model definition from client side code.\n\n ### Authenticate a User In this quick start, we are using [anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)to log in users without requiring them to provide any identifying information. After authenticating the user, you can open a realm for that user. ```csharp var user = await app.LogInAsync(Credentials.Anonymous()); \n``` You should also provide a way for the user to log out. The following code shows how to do this by calling `LogOutAsync()`: ```csharp await user.LogOutAsync(); \n``` The Realm .NET SDK provides many additional ways to authenticate, register, and link users. For other authentication providers, see: [Authenticate Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate) ### Open a Synced Realm Once you have [enabled Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) and authenticated a user, you can open a synced [realm](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/realms/#std-label-dotnet-realms). Use a `FlexibleSyncConfiguration`object to control the specifics of how your application synchronizes data with App Services. You then add a [Flexible Sync subscription](https://mongodb.com/docs/realm/sdk/dotnet/sync/flexible-sync/#std-label-dotnet-flexible-sync)that determines what data the user can query. ```csharp var config = new FlexibleSyncConfiguration(app.CurrentUser) {     PopulateInitialSubscriptions = (realm) =>     {         var myItems = realm.All<Item>().Where(n => n.OwnerId == myUserId);         realm.Subscriptions.Add(myItems);     } }; // The process will complete when all the user's items have been downloaded. var realm = await Realm.GetInstanceAsync(config); \n``` The syntax to read, write, and watch for notifications on a synced realm is identical to the syntax for non-synced realms above. While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. ← [Install Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/install/ \"Previous Section\")[Work with Realm Files - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/troubleshooting/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Troubleshooting - .NET SDK On this page * [Resolve a 'No Properties in Class' Exception](#resolve-a--no-properties-in-class--exception)\n* [Fody: 'An Unhandled Exception Occurred'](#fody---an-unhandled-exception-occurred-)\n* [Fody Weave Exceptions](#fody-weave-exceptions)\n* [Troubleshooting WriteAsync Issues](#troubleshooting-writeasync-issues) ## Resolve a 'No Properties in Class' Exception You may see a `System.InvalidOperationException` with the message \"No properties in class, has linker stripped it?\". There are three known causes of this exception: * You have no woven RealmObjects, probably because something went wrong with Fody. If this is the case, `RealmSchema` throws an exception. See[Fody Weave Exceptions](#std-label-fail-to-weave) for details on how to fix this.\n* A linker has stripped properties from one or more RealmObjects, and Realm thinks those properties don't exist. This can occur if you have your[Linker Behavior](https://docs.microsoft.com/en-us/xamarin/ios/deploy-test/linker?tabs=macos)set to `Link all assemblies` but have not used the `[Preserve(AllMembers = true)]`attribute on the class declaration. The linker only preserves class members that you have referenced explicitly in the code or marked with the`[Preserve(AllMembers = true)]` attribute. This means that if you want to persist a property in realm and it is not referenced anywhere in your code, the linker may remove it, causing a schema mismatch.\n* You are using a code obfuscation tool which is interfering with model name detection. Realm relies on class names to generate the schema, so if a code obfuscation tool has hidden those class names, schema generation fails. To solve this, set your code obfuscation tool to ignore your model classes. ## Fody: 'An Unhandled Exception Occurred' This common build failure is triggered when you have already built a project and then add a new `RealmObject` sub-class. Choosing toBuild or Run your project does not rebuild the project thoroughly enough to invoke the Fody Weaver. To fix this, choose to Rebuild your project. ## Fody Weave Exceptions You may see a warning in the build log about classes not having been woven. This indicates that the Fody weaving package is not properly installed. Here are some things to check: * First, check that the `FodyWeavers.xml` file contains an entry for Realm.\n* It is also possible that the installation of Fody has failed. Users have experienced this with Visual Studio 2015 and versions of NuGet Package Manager prior to version 3.2\\. To diagnose this, use a text editor to check that your`.csproj` has a line importing `Fody.targets`, such as:  \n`| <Import Project=\"..\\packages\\Fody.1.29.3\\build\\portable-net+sl+win+wpa+wp\\Fody.targets\"        |  \n| ---------------------------------------------------------------------------------------------- |  \n| Condition=\"Exists('..\\packages\\Fody.1.29.3\\build\\portable-net+sl+win+wpa+wp\\Fody.targets')\" /> |  \n` The easiest fix is to upgrade to a later version of NuGet Package Manager. If this doesn't work, there may be a problem with Fody and `Microsoft.Bcl.Build.targets`. Removing the following line from your .csproj file might help: ```shell <Import Project=\"..\\..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets\"  Condition=\"Exists('..\\..\\packages\\Microsoft.Bcl.Build.1.0.21\\build\\Microsoft.Bcl.Build.targets')\" /> \n``` ## Troubleshooting WriteAsync Issues\n\n For more information, see [Asynchronous Writes.](https://mongodb.com/docs/realm/sdk/dotnet/crud/threading/#std-label-dotnet-async-writes) ← [Platform and Framework Compatibility - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/compatibility/ \"Previous Section\")[Telemetry - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/telemetry/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/application-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Application Services - .NET SDK On this page * [Overview](#overview)\n* [The App Client](#the-app-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Calling Functions](#calling-functions)\n* [Accessing MongoDB](#accessing-mongodb) ## Overview Realm provides SDKs that help you connect your client apps to the Atlas App Services backend. The SDK provides the functionality needed to authenticate users with any of the built-in [authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), call backend [functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), and directly access a linked[MongoDB data source.](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) ## The App Client When using the SDK to access the App Services backend, you start with an App object. This object provides all other functionality related to App Services. The `App` object is[initialized](https://mongodb.com/docs/realm/sdk/dotnet/app-services/connect-to-app-services-backend/#std-label-dotnet-init-appclient) with the App ID, which you can[find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ## Tip To learn how to initialize the App client, see[Connect to an Atlas App Services Backend - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/app-services/connect-to-app-services-backend/#std-label-dotnet-init-appclient) ## Authentication & User Management One of the most challenging aspects of client development is implementing a robust and secure authentication system. With the Realm SDKs, however, you can use any of the authentication providers with very minimal backend setup or client-side code required. With the authentication APIs, you can implement the following functionality: * Creation of new user accounts\n* User log-in and log-out\n* Multiple users logged on at the same time on the same device\n* Linking user accounts from different providers\n* Providing custom user data ## Tip To learn how to set up authentication with different providers, see[Authenticate Users - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate) To learn how to manage multiple users, see [Multi-User Applications - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/#std-label-dotnet-multi-user) To learn how to link user accounts, see [Link User Identities - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/link-user-identities/#std-label-dotnet-link-user-identities) To learn how to provide custom user data, see [Custom User Data - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/#std-label-dotnet-custom-user-data) ## Calling Functions [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) enable you to define and execute server-side logic for your application. You can call these functions from your client applications via the Realm SDKs. These server-side functions can run under the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your collections. By using Functions, you provide a secure way for a variety of client applications to share complex functionality without having to reproduce that logic client-side. ## Tip To learn how to call functions, see [Call a Function.](https://mongodb.com/docs/realm/sdk/dotnet/app-services/call-a-function/#std-label-dotnet-call-a-function) ## Accessing MongoDB\n\n ## Tip To learn how to use the MongoDB APIs, see [Query MongoDB.](https://mongodb.com/docs/realm/sdk/dotnet/app-services/mongodb-remote-access/#std-label-dotnet-mongodb-data-access) ← [React to Changes - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/ \"Previous Section\")[Connect to an Atlas App Services Backend - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/app-services/connect-to-app-services-backend/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/work-with-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Work with Users - .NET SDK ## Overview When you use Atlas App Services to back your client app, you get access to a[user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects). You can use the .NET SDK to: * Create and delete users\n* Log users in and out\n* Create and update custom user data\n* Read user metadata from other login providers ## Create and Delete Users For all authentication providers other than email/password authentication, App Services automatically [creates a user object](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/create-and-delete-users/#std-label-dotnet-create-user)the first time a user authenticates. If a user authenticates via more than one method, you can [link these user identities](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/link-user-identities/#std-label-dotnet-link-user-identities)to a single user object. You can [delete user objects](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/create-and-delete-users/#std-label-dotnet-delete-user). Deleting a user object deletes metadata attached to the user object, but does not delete user-entered data from the backend or any [custom user data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data). To delete custom user data, see [Delete a User's Custom Data.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/#std-label-dotnet-delete-custom-user-data) ## Tip ### Apple Account Deletion Requirements Apple [requires that applications listed through its App Store](https://developer.apple.com/app-store/review/guidelines/#5.1.1) must give any user who creates an account the option to delete the account. Whether you use an authentication method where you must manually register a user, such as email/password authentication, or one that that automatically creates a user, such as Sign-In with Apple, you must implement [user account deletion](https://www.mongodb.com/docs/atlas/app-services/users/manage/#std-label-delete-user) by June 30, 2022. ## Log Users In and Out Use one or more [authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-auth-providers) to [log users in and out](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate) of your client app. You can: * Log users in with an existing third-party account, such as Apple, Facebook, or Google.\n* Create new user accounts with App Services email/password management, or your own custom function or custom JWT user management.\n* Enable anonymous users to let users access your App Services App without persisting user data. When you have a logged-in user, SDK methods enable you to: * [Open a synced realm](https://mongodb.com/docs/realm/sdk/dotnet/sync/configure-and-open-a-synced-realm/#std-label-dotnet-open-a-synced-realm) with the user's configuration object\n* [Run a backend function](https://mongodb.com/docs/realm/sdk/dotnet/app-services/call-a-function/#std-label-dotnet-call-a-function) as the logged-in user\n* [Log the user out](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-logout)\n* [Change the active user](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/#std-label-dotnet-change-the-active-user) in a multi-user application\n* [Remove a user](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/#std-label-dotnet-remove-a-user-from-the-device) from the device\n\n ### User Sessions App Services manages sessions with access tokens and refresh tokens. Client SDKs supply the logic to manage tokens, and provide them with requests. ## Tip ### See also:  [User Sessions](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) ## Read and Update Custom User Data You can [associate custom data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) with a user object, such as a preferred language or local timezone, and read it from your client application. A user object has a `customData` property that you can use to [access custom user data.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/#std-label-dotnet-read-custom-user-data) To [create](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/#std-label-dotnet-create-custom-user-data) and [update](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/#std-label-dotnet-update-custom-user-data) custom user data, you must access your MongoDB data source directly. App Services does not offer a SDK method to create or update this custom user data; it's a read-only property. ## Read User Metadata from Login Providers Some authentication providers enable developers to access user metadata, such as full name or email address. When you configure these metadata fields on the App Services application, you can read this medata from your client app. A user object has a `profile` property that you can use to [access user metadata.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/user-metadata/#std-label-dotnet-read-user-metadata) ← [Manage User API Keys - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/app-services/manage-user-api-keys/ \"Previous Section\")[Create and Delete Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/create-and-delete-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/realm-files/delete-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete a Realm - .NET SDK In some circumstances, such as a [client reset](https://mongodb.com/docs/realm/sdk/dotnet/sync/client-reset/#std-label-dotnet-client-resets)scenario, you might need to delete a realm file and its auxiliary files. If you are developing or debugging the app, you might manually delete the realm file, but doing so when the app is running and any realm instances are still open can cause data corruption. To delete a realm file while the app is running, you can use the[DeleteRealm(configuration)](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FDeleteRealm%5FRealms%5FRealmConfigurationBase%5F)method to safely do so. The following code demonstrates this: `| var config = new RealmConfiguration(\"FileWeThrowAway.realm\"); |\n| ------------------------------------------------------------- |\n| Realm.DeleteRealm(config);                                    |\n| var freshRealm = Realm.GetInstance(config);                   | ` ## Warning ### Use Caution When Deleting Realm Files If you delete a realm file or any of its auxiliary files while one or more instances of the realm are open, you might corrupt the realm or disrupt [sync.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) You may delete these files when all instances of a realm are closed. Before you delete a realm file, however, **be sure that you back up any important objects as you will lose all unsynced data in the realm**. ← [Configure & Open a Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/realms/ \"Previous Section\")[Bundle Realm Files - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/bundle-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/realm-files/compact-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Reduce Realm File Size - .NET SDK On this page * [Overview](#overview)\n* [Compaction Options](#compaction-options)\n* [Realm Configuration File](#realm-configuration-file)\n* [Realm.Compact() Method](#realm.compact---method)\n* [When to Compact a Realm](#when-to-compact-a-realm) ## Overview Over time, the storage space used by Realm might become fragmented and take up more space than necessary. To rearrange the internal storage and potentially reduce the file size, you can compact the realm file. ## Important ### File must not be in use Realm cannot compact a file that is in use. Be sure there are no open instances that use the file. Realm reduces the file size by writing a new (compact) version of the file, and then replacing the original with the newly-written file. Therefore, to compact, you must have free storage space equivalent to the original realm file size. ## Tip ### Implement Compacting in Your Production Application Every production application should implement [ShouldCompactOnLaunch](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfiguration.html#Realms%5FRealmConfiguration%5FShouldCompactOnLaunch)to periodically reduce the realm file size. For more information about compacting a realm, see: [When to Compact a Realm.](#std-label-dotnet-when-to-compact-a-realm) ## Compaction Options You can configure realm to automatically compact the database each time a realm is opened, or you can compact the file without first obtaining a realm instance. ### Realm Configuration File You can configure Realm to check the realm file each time it is opened by specifying a[ShouldCompactDelegate](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfiguration.ShouldCompactDelegate.html)in the configuration. The following code example shows how to do this:\n\n ` If the delegate returns `true` \\-- and the file is not in use -- the realm file is compacted prior to making the instance available. ### Realm.Compact() Method Alternatively, you can compact a realm file without first obtaining an instance to the realm by calling the[Compact()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FCompact%5FRealms%5FRealmConfigurationBase%5F)method. The following example shows how to do this: ```csharp config = new RealmConfiguration(\"my.realm\"); Realm.Compact(config); \n``` The `Compact` method will return true if the operation is successful. ## When to Compact a Realm Compacting a realm can be an expensive operation that can block the UI thread. Your application should not compact every time you open a realm. Instead, try to optimize compacting so your application does it just often enough to prevent the file size from growing too large. If your application runs in a resource-constrained environment, you may want to compact when you reach a certain file size or when the file size negatively impacts performance. These recommendations can help you start optimizing compaction for your application: * Set the max file size to a multiple of your average realm state size. If your average realm state size is 10MB, you might set the max file size to 20MB or 40MB, depending on expected usage and device constraints.\n* As a starting point, compact realms when more than 50% of the realm file size is no longer in use. Divide the currently used bytes by the total file size to determine the percentage of space that is currently used. Then, check for that to be less than 50%. This means that greater than 50% of your realm file size is unused space, and it is a good time to compact. After experimentation, you may find a different percentage works best for your application. These calculations might look like this in your delegate: ```csharp // Set a maxFileSize equal to 20MB in bytes var maxFileSize = 20 * 1024 * 1024; /* Check for the realm file size to be greater than the max file size,  * and the amount of bytes currently used to be less than 50% of the  * total realm file size */ return (totalBytes > (double)maxFileSize) ||    ((double)usedBytes / totalBytes > 0.5); \n``` Experiment with conditions to find the right balance of how often to compact realm files in your application. ← [Bundle Realm Files - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/bundle-a-realm/ \"Previous Section\")[Encrypt a Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/encrypt-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/realm-files/realms/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Configure & Open a Realm - .NET SDK On this page * [Key Concept: Realm Files](#key-concept--realm-files)\n* [Open a Realm Without Sync](#open-a-realm-without-sync)\n* [Local Realms](#local-realms)\n* [In-Memory Realms](#in-memory-realms)\n* [Scoping the Realm](#scoping-the-realm)\n* [Class Subsets](#class-subsets) A **realm** is a set of related objects that conform to a pre-defined schema. Realms may contain more than one type of data as long as a schema exists for each type. Every realm stores data in a separate realm file that contains a binary encoding of each object in the realm. You can automatically [synchronize a realm across multiple devices](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) and set up [reactive event handlers](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-client-notifications) that call a function any time an object in a realm is created, modified, or deleted. ## Key Concept: Realm Files Realm Database stores a binary encoded version of every object and type in a realm in a single `.realm` file. The file is located at the path that you define in the[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfiguration.html#Realms%5FRealmConfiguration%5F%5Fctor%5FSystem%5FString%5F)object when you open the realm, or in the default path if you do not specify a path. The default realm file is named `default.realm` and is located where the OS stores app-specific data. ## Tip ### Implement Compacting in Your Production Application Every production application should implement [ShouldCompactOnLaunch](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfiguration.html#Realms%5FRealmConfiguration%5FShouldCompactOnLaunch)to periodically reduce the realm file size. For more information about compacting a realm, see: [Reduce Realm File Size - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/compact-realm/#std-label-dotnet-compact-realm) ## Note ### Auxiliary Realm Files Realm Database creates additional files for each realm. To learn more about these files, see [Realm Database Internals.](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/#std-label-dotnet-realm-database) ## Open a Realm Without Sync The following sections describe how to open a realm file for local (non-sync) use. If you are interested in using Sync with your realm, see[Configure & Open a Synced Realm - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/sync/configure-and-open-a-synced-realm/#std-label-dotnet-configure-and-open-a-synced-realm) ### Local Realms When opening a local (non-synced) realm, pass a[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfiguration.html#Realms%5FRealmConfiguration%5F%5Fctor%5FSystem%5FString%5F)object to either `GetInstanceAsync()` or `GetInstance()`. The following example creates a `RealmConfiguration` object with a local file path, sets the`IsReadOnly` property to `true`, and then opens a local realm with that configuration information:\n\n ` ### In-Memory Realms With an[InMemoryConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.InMemoryConfiguration.html)object, you can create a realm that runs entirely in memory (that is, without the data written to disk.) The following example shows how to do this: ```csharp var config = new InMemoryConfiguration(\"some-identifier\"); var realm = Realm.GetInstance(config); \n``` In-memory realms might still use disk space if memory is running low, but all files created by an in-memory realm will be deleted when the realm is closed. When creating an in-memory realm, the identifier must be unique to all realms, including both in-memory and persisted realms. ## Important When an in-memory realm is disposed or garbage-collected, the data is lost. To keep an in-memory realm \"alive\" throughout your app's execution, be sure to hold a reference to realm. ## Scoping the Realm The realm instance implements `IDisposable` to ensure native resources are freed up. You should dispose of a realm object immediately after use, especially on background threads. The simplest way to do this is by declaring the realm object with a `using` statement, or wrapping the code that interacts with a realm in a `using (...)` statement: ```csharp config = new PartitionSyncConfiguration(\"myPart\", user); using (var realm = Realm.GetInstance(config)) {     var allItems = realm.All<Item>(); } \n``` If you require a realm object to be shared outside of a single method, be sure to manage its state by calling the[Dispose()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FDispose) method: ```csharp realm.Dispose(); \n``` ## Note As a general rule, you should dispose of the realm only on background threads, because disposing of a realm invalidates all objects associated with that instance. If you are data binding the realm objects on the main thread, for example, you should not call `Dispose()`. ## Class Subsets By default, all `RealmObject` classes are stored in a realm. In some scenarios, you may want to limit the classes that get stored, which you can do with the[Schema](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfigurationBase.html#Realms%5FRealmConfigurationBase%5FSchema)property of the `RealmConfiguration` object. The following code demonstrates how you specify two classes you want stored in the realm: ```csharp var config = new RealmConfiguration() {     Schema = new Type[]     {         typeof(AClassWorthStoring),         typeof(AnotherClassWorthStoring)     } }; \n``` ← [Work with Realm Files - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/ \"Previous Section\")[Delete a Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/delete-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - .NET SDK On this page * [Register a Realm Change Listener](#register-a-realm-change-listener)\n* [Watch for Collection Changes](#watch-for-collection-changes)\n* [Register a Collection Change Listener](#register-a-collection-change-listener)\n* [Unregister a Change Listener](#unregister-a-change-listener)\n* [Handle the CollectionChanged Event](#handle-the-collectionchanged-event)\n* [Register an Object Change Listener](#register-an-object-change-listener)\n* [Unregister a Change Listener](#unregister-a-change-listener-1) Realm's notification system allows you to watch for and react to changes in your data, independent of the writes that caused the changes. To observe changes, you create a notification handler for a Realm, a[managed collection](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/#std-label-dotnet-client-collections), or a Realm object that you want to watch. You can then add your specific app logic related to the change. Realm emits three kinds of notifications: * [Realm notifications](#std-label-dotnet-realm-notifications) whenever a specific Realm commits a write transaction.\n* [Collection notifications](#std-label-dotnet-collection-notifications) whenever any a managed collection changes, such as inserts, updates, and deletes of objects in the collection.\n* [Object notifications](#std-label-dotnet-object-notifications) whenever a specific Realm object changes. ## Note Notifications only work when your realm regularly refreshes. In the Main or UI thread of your application, realm refreshes happen automatically. On background threads, you need to handle this yourself by either calling [Realm.Refresh()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FRefresh) or installing a[SynchronizationContext](https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext)on the thread before opening the realm. The third-party library[Nito.AsyncEx.Context](https://www.nuget.org/packages/Nito.AsyncEx.Context/1.1.0)provides a `SynchronizationContext` implementation and a convenient API to install it. ## Register a Realm Change Listener You can register a notification handler on an entire realm. Realm invokes the notification handler whenever any write transaction on that realm is committed. The handler receives no specific information about the change. This is useful when you want to know that there has been a change but do not need to know specifically what change has occurred. Suppose you are building a real-time collaborative app and you want to have a counter that increases every time a change is made. In this scenario, you could subscribe to the realm notification handler and add the code that controls the indicator. `| // Observe realm notifications.                       |\n| ----------------------------------------------------- |\n| realm.RealmChanged += (sender, eventArgs) =>          |\n| {                                                     |\n| // The \"sender\" object is the realm that has changed. |\n| // \"eventArgs\" is reserved for future use.            |\n| // ... update UI ...                                  |\n| };                                                    | ` ## Watch for Collection Changes\n\n ### Register a Collection Change Listener You can register a notification handler on a specific collection within a realm. The collection can be of realm objects (like `realm.All<Person>()`) or a collection property on a realm object (like `house.Owners`, where \"Owners\" is of type `IList`). The handler receives a description of changes made to the collection since the last notification. Unlike realm-wide notifications, collection notifications contain detailed information about the change and provide the information you need to manage a list or other view that represents the collection in the UI. Realm emits an initial notification when a subscription is added. After the initial notification, Realm delivers notifications asynchronously whenever a write transaction adds, modifies, or removes objects in the collection. Specifically, the notification contains a [ChangeSet](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.ChangeSet.html)with 6 properties: * `DeletedIndices` is an `int[]` that contains the indices of the objects that were deleted.\n* `InsertedIndices` is an `int[]` that contains the indices of the objects that were inserted.\n* `ModifiedIndices` is an `int[]` that contains the _old_ indices of the objects that were modified. These indices indicate the position of the modified objects in the original collection before any deletions or insertions ocurred.\n* `NewModifiedIndices` is an `int[]` that represents the same entries as the`ModifiedIndices` property, but the indices represent the new locations in the collection after all changes have been accounted for.\n* `IsCleared` is a boolean set to `true` when a collection has been cleared by calling the `Clear()` method.\n* `Moved` is an array of [ChangeSet.Move](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.ChangeSet.Move.html)structs that contain the previous and new index of an object moved within the collection. To subscribe to collection notifications, call the[SubscribeForNotifications](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.CollectionExtensions.html#Realms%5FCollectionExtensions%5FSubscribeForNotifications%5F%5F1%5FSystem%5FCollections%5FGeneric%5FIDictionary%5FSystem%5FString%5F%5F%5F0%5F%5FRealms%5FNotificationCallbackDelegate%5FSystem%5FCollections%5FGeneric%5FKeyValuePair%5FSystem%5FString%5F%5F%5F0%5F%5F%5F)method. `SubscribeForNotifications` returns a subscription token which can be disposed at any time to stop receiving notifications on the collection. The following code shows how to observe a collection for changes. ```csharp // Watch for collection notifications. var subscriptionToken = realm.All<Dog>()     .SubscribeForNotifications((sender, changes, error) => {     if (error != null)     {         // Show error message         return;     }     if (changes == null)     {         // This is the case when the notification is called         // for the first time.         // Populate tableview/listview with all the items         // from `collection`         return;     }     // Handle individual changes     foreach (var i in changes.DeletedIndices)     {         // ... handle deletions ...     }     foreach (var i in changes.InsertedIndices)     {         // ... handle insertions ...     }     foreach (var i in changes.NewModifiedIndices)     {         // ... handle modifications ...     }     if (changes.IsCleared)     {         // A special case if the collection has been cleared:          // i.e., all items have been deleted by calling\n\n     } }); \n``` ## Important ### Order Matters In collection notification handlers, always apply changes in the following order: 1. deletions\n2. insertions\n3. modifications Handling insertions before deletions may result in unexpected behavior. ## Unregister a Change Listener To unregister a change listener, call `Dispose` on the token. The following code shows how to do this: ```csharp // Watch for collection notifications. // Call Dispose() when you are done observing the // collection. var token = realm.All<Dog>()     .SubscribeForNotifications((sender, changes, error) =>     {         // etc.     }); // When you no longer want to receive notifications: token.Dispose(); \n``` ### Handle the CollectionChanged Event Every Realm collection implements `INotifyCollectionChanged`, which allows you to use a collection directly in data-binding scenarios. Because collections implement`INotifyCollectionChanged`, another approach to monitoring collection changes is to handle the [CollectionChanged](https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.inotifycollectionchanged.collectionchanged)event and check for the type of [NotifyCollectionChangedAction.](https://learn.microsoft.com/en-us/dotnet/api/system.collections.specialized.notifycollectionchangedaction) ## Important ### Less Detailed Information The `CollectionChanged` event handler does not provide the same level of detail about changes as `SubscribeForNotifications` does. The following code shows you how to implement the `CollectionChanged` event handler: ```csharp {     // Subscribe to a query     realm.All<Dog>().AsRealmCollection().CollectionChanged +=         HandleCollectionChanged;     // Subscribe to a property collection     gracie.Owners.AsRealmCollection().CollectionChanged +=         HandleCollectionChanged;    ... } private void HandleCollectionChanged(object sender,     NotifyCollectionChangedEventArgs e) {     // Use e.Action to get the     // NotifyCollectionChangedAction type.     if (e.Action == NotifyCollectionChangedAction.Add)     {         // etc.     } } \n``` ## Register an Object Change Listener You can register a notification handler on a specific object within a realm so that the SDK notifies you when any of the object's properties change. The handler receives information about which field has changed. With the field name, you can get the new value. The following code shows how to observe an object for changes. ```csharp     var artist = realm.All<Person>()         .FirstOrDefault(p => p.Name == \"Elvis Presley\");     artist.PropertyChanged += (sender, eventArgs) =>     {         var changedProperty = eventArgs.PropertyName;         Debug.WriteLine(             $@\"New value set for 'artist':             '{changedProperty}' is now {artist.GetType()             .GetProperty(changedProperty).GetValue(artist)}\");     };     realm.Write(() =>     {         artist.Name = \"Elvis Costello\";     });     realm.Refresh(); } \n``` ## Unregister a Change Listener When you no longer want to receive notifications on a change listener, you unregister the handler. The code is the same for both a collection of realm objects and a collection property. The following code shows how to unregister a change listener on both: ```csharp // Unsubscribe from notifications on a // realm listener realm.RealmChanged -= OnRealmChanged; // Unsubscribe from notifications on a // collection of realm objects realm.All<Item>().AsRealmCollection()     .CollectionChanged -= OnItemsChangedHandler; // Unsubscribe from notifications on a // collection property items.AsRealmCollection().CollectionChanged -= OnItemsChangedHandler; \n```\n\n",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/user-metadata/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # User Metadata - .NET SDK On this page * [Read a User's Metadata](#read-a-user-s-metadata)\n* [Configure User Metadata](#configure-user-metadata)\n* [Update User Metadata](#update-user-metadata) ## Read a User's Metadata You can read the [user metadata](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) of a currently logged-in user through the [User](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html)object. You cannot edit user metadata through a `User` object. The `Profile` property on the `User` object returns a[UserProfile](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.UserProfile.html) object of a logged-in user. The following example shows how to get a user's email from the metatdata: `| var user = await app.LogInAsync(                                |\n| --------------------------------------------------------------- |\n| Credentials.EmailPassword(\"user1@example.com\", \"p@ssw0rd\"));    |\n| Console.WriteLine($\"The user's email is {user.Profile.Email}\"); | ` User metadata options vary depending on which provider you're using and[which metadata fields you enable.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-configure-user-metadata-on-the-backend) ## Warning ### User Metadata May Be Stale Atlas App Services fetches the most recent version of user metadata when a user logs in. If the user changes their email address or profile photo with a login provider, for example, those changes do not update in user metadata until the user logs in again. Because we cache credentials and enable you to bypass the login flow, user metadata may become stale unless you force the user to log in again. ## Configure User Metadata You can only read user metadata from the client app that you have configured on the App Services application. You can configure the [user metadata](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) you request from an authentication provider. You do this directly on the authentication provider's configuration. For more details on which metadata fields you can use, see the provider details: * OAuth 2.0 ([Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) & [Google)](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication)\n* [Custom JWT](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) You can change which metadata fields you have configured by [editing the provider's configuration.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-configure-user-metadata-on-the-backend) ## Update User Metadata User metadata that you access through the authentication provider is read-only data. You cannot update or edit user metadata that comes from this source. If you would like to give a user the option the update their metadata from within your client app, use [custom user data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data), instead. ← [Custom User Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/ \"Previous Section\")[Manage Email/Password Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/manage-email-password-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/unity/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Integrate Realm with Unity - .NET SDK On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Install](#install)\n* [Add NPM as a Scoped Registry](#add-npm-as-a-scoped-registry)\n* [Add Realm to the Project Manifest](#add-realm-to-the-project-manifest)\n* [Verify the Realm Dependency and Check for Updates](#verify-the-realm-dependency-and-check-for-updates)\n* [Download the Latest Realm .NET SDK Release](#download-the-latest-realm-.net-sdk-release)\n* [Add the Tarball to Your Projects Package Manager](#add-the-tarball-to-your-projects-package-manager)\n* [Import Realm](#import-realm)\n* [Using Realm in Your Unity Project](#using-realm-in-your-unity-project)\n* [dynamic Keyword Support](#dynamic-keyword-support)\n* [Managed Code Stripping](#managed-code-stripping)\n* [Using Realm While the Application is Quitting](#using-realm-while-the-application-is-quitting)\n* [Additional Examples](#additional-examples) ## Overview This page contains information on how to install and integrate Realm into your Unity project. ## Note ### Known Issue When Developing With Unity on Windows On Windows, if you are using Device Sync, your project may crash when running multiple instances of your project since multiple processes are attempting to access the same synced realm. If you are using a local realm, you are able to run multiple instances of your project without crashes. ## Prerequisites * Unity [2020.3.12f1 (LTS)](https://unity3d.com/get-unity/download/archive) ## Note The [Realm .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/) may be compatible with other versions of Unity, but `2020.3.12f1 (LTS)` is the version that the Realm team uses for testing and development. We recommend using this version to ensure your project works with Realm and that the install steps match the steps below since Unity's UI often changes between versions. ## Install Realm provides various ways to install the [Realm .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/) for use with Unity. Experienced Unity developers may find installing Realm manually with a tarball to be intuitive. However, we recommend installing the [Realm .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/) via npm since it provides [notifications of version updates through Unity's package manager](https://docs.unity3d.com/Packages/com.unity.package-manager-ui@2.0/manual/index.html#PackManUpdate). ## Import Realm [Create a C# script](https://docs.unity3d.com/Manual/CreatingAndUsingScripts.html) or use a C# script you have already created. Open that script in [Visual Studio](https://docs.microsoft.com/en-us/visualstudio/) or another text editor and add the following line to import your Realm package: `| using Realms; |\n| ------------- | ` ## Using Realm in Your Unity Project When developing with [Realm .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/), the API methods are the same regardless of whether you use Unity or another platform. However, since Unity has some [scripting restrictions](https://docs.unity3d.com/Manual/ScriptingRestrictions.html), you should keep the following additional considerations in mind when developing your project: ### `dynamic` Keyword Support\n\n ## Example The following example shows a portion of a code block for performing a[migration](https://mongodb.com/docs/realm/sdk/dotnet/model-data/change-an-object-model/#std-label-dotnet-migration-function) to illustrate the usage of the[DynamicAPI.](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.Dynamic.html) ```csharp var dynamicPeople = (IQueryable<RealmObject>)migration.OldRealm.All(\"Person\"); var personName = dynamicPeople.First().DynamicApi.Get<string>(\"Name\"); \n``` ### Managed Code Stripping Unity performs [managed code stripping](https://docs.unity3d.com/Manual/ManagedCodeStripping.html), discarding any unused code from a build to reduce binary size. This may lead to issues when deserializing [BSON](https://www.mongodb.com/docs/manual/reference/bson-types/) into C# classes. For platforms that use [IL2CPP](https://docs.unity3d.com/Manual/IL2CPP.html), such as iOS, managed code stripping is enabled by default. When working with BSON, use the [\\[Preserve\\] attribute](https://docs.unity3d.com/ScriptReference/Scripting.PreserveAttribute.html)to prevent managed code stripping on types properties that are only populated by the serializer. Since those properties use[reflection](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection), Unity cannot statically infer that the property setter is used. This means that unless you apply the `[Preserve] attribute`, Unity will strip those properties away. For examples of when you may perform BSON deserialization, check out the[Query MongoDB](https://mongodb.com/docs/realm/sdk/dotnet/app-services/mongodb-remote-access/) and[Call a Function](https://mongodb.com/docs/realm/sdk/dotnet/app-services/call-a-function/) documentation. ### Using Realm While the Application is Quitting The Realm .NET SDK cannot be accessed within the[AppDomain.DomainUnload Event](https://docs.microsoft.com/en-us/dotnet/api/system.appdomain.domainunload?view=net-5.0) or the [Application.quitting](https://docs.unity3d.com/ScriptReference/Application-quitting.html) event. This means you cannot write data to a Realm while the player application is quitting. If you need to store some data just before the app exits, consider using the[Application.wantsToQuit](https://docs.unity3d.com/ScriptReference/Application-wantsToQuit.html)event instead. ## Additional Examples The Realm community has created many projects that demonstrate the usage of the Realm .NET SDK. Check out the examples below that demonstrate the usage of the [Realm .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/) with Unity! ## Note The MongoDB Documentation team does not directly maintain these examples. * [MongoDB Devhub: Unity with Realm Articles](https://developer.mongodb.com/learn/?content=Articles&text=unity)\n* [MongoDB Youtube Channel: Getting Started with the Realm SDK for Unity](https://www.youtube.com/watch?v=df2qo8G2ZfU)\n* [MongoDB Youtube Channel: Build an Infinite Runner Game with Unity and the Realm Unity SDK](https://www.youtube.com/watch?v=8S0NuFwFazY)\n* [dodoTV42 Youtube Channel: How to SAVE and LOAD data in Unity3D with Realm SDK](https://www.youtube.com/watch?v=8jo%5FS02HLkI) ← [Use Realm in a Console App - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/async-console/ \"Previous Section\")[Logging - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/logging/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/realm-files/encrypt-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Encrypt a Realm - .NET SDK On this page * [Overview](#overview)\n* [Considerations](#considerations)\n* [Storing & Reusing Keys](#storing---reusing-keys)\n* [Performance Impact](#performance-impact)\n* [Encryption and Atlas Device Sync](#encryption-and-atlas-device-sync)\n* [Accessing an Encrypted Realm from Multiple Process](#accessing-an-encrypted-realm-from-multiple-process)\n* [Example](#example) ## Overview You can encrypt your realms to ensure that the data stored to disk can't be read outside of your application. You encrypt the realm database file on disk with AES-256 + SHA-2 by supplying a 64-byte encryption key when[opening the realm.](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/realms/#std-label-dotnet-open-a-realm) Realm transparently encrypts and decrypts data with standard[AES-256 encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) using the first 256 bits of the given 512-bit encryption key. Realm uses the other 256 bits of the 512-bit encryption key to validate integrity using a [hash-based message authentication code (HMAC).](https://en.wikipedia.org/wiki/HMAC) ## Warning Do not use cryptographically-weak hashes for realm encryption keys. For optimal security, we recommend generating random rather than derived encryption keys. ## Considerations The following are key impacts to consider when encrypting a realm. ### Storing & Reusing Keys You **must** pass the same encryption key every time you open the encrypted realm. If you don't provide a key or specify the wrong key for an encrypted realm, the Realm SDK throws an error. Apps should store the encryption key securely, typically in the target platform's secure key/value storage, so that other apps cannot read the key. For example, you can use[MAUI Secure Storage](https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/storage/secure-storage) or[Xamarin Secure Storage](https://docs.microsoft.com/en-us/xamarin/essentials/secure-storage) to simplify the access to underlying storage. Ultimately, it is the developer's responsibility to ensure that attackers cannot access the key. ### Performance Impact Reads and writes on encrypted realms can be up to 10% slower than unencrypted realms. ## Important The same encryption key must be supplied every time you obtain a Realm instance. If you don't provide a key, or specify the wrong key, for an encrypted Realm, you will get a[RealmFileAccessErrorException](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Exceptions.RealmFileAccessErrorException.html)when you call `GetInstance`. ### Encryption and Atlas Device Sync You can encrypt a [synced realm.](https://mongodb.com/docs/realm/sdk/dotnet/sync/#std-label-dotnet-sync) If you need unique keys for each user of your application, you can use an OAuth provider (such as [MAUI.Auth](https://learn.microsoft.com/en-us/dotnet/maui/platform-integration/communication/authentication)) and[Xamarin.Auth](https://docs.microsoft.com/en-us/xamarin/essentials/web-authenticator)), or use one of the[Realm Authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication) and an[Authentication Trigger](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-triggers)to create a 64-bit key and store that key in [a user object.](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) ## Accessing an Encrypted Realm from Multiple Process Realm forbids opening the same encrypted realm from multiple processes. Attempting to do so will throw the error: \"Encrypted interprocess sharing is currently unsupported.\" ## Example ## Warning\n\n The following code demonstrates how to generate an encryption key and open an encrypted realm: `| // Check if we already have a key stored in the platform's secure storage. |\n| -------------------------------------------------------------------------- |\n| // If we don't, generate a new one:                                        |\n| var encryptionKey = new byte[64];                                          |\n| using var rng = new RNGCryptoServiceProvider();                            |\n| rng.GetBytes(encryptionKey);                                               |\n| // Store the key securely to be used next time we want to open the Realm.  |\n| // Create configuration.                                                   |\n| var config = new RealmConfiguration                                        |\n| {                                                                          |\n| EncryptionKey = encryptionKey                                              |\n| };                                                                         |\n| // Open or create a realm with the encryption key.                         |\n| var realm = Realm.GetInstance(config);                                     | ` ← [Reduce Realm File Size - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/compact-realm/ \"Previous Section\")[Model Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/create-and-delete-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create and Delete Users - .NET SDK On this page * [Create a User](#create-a-user)\n* [Delete a User](#delete-a-user) ## Create a User For all [authentication methods](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) except email/password authentication, Atlas App Services automatically creates a[user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) the first time a user authenticates. When you use email/password authentication, you must first [register](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/manage-email-password-users/#std-label-dotnet-email-password-register-new-user) and [confirm](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/manage-email-password-users/#std-label-dotnet-email-password-confirm-user) a user before App Services creates the user object. ## Delete a User To delete a user, call the [DeleteUserFromServerAsync(User)](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.html#Realms%5FSync%5FApp%5FDeleteUserFromServerAsync%5FRealms%5FSync%5FUser%5F)method. This deletes the user from the server, and also deletes the user's local data, but does not delete any custom user data. To delete custom user data, see [Delete a User's Custom Data.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/#std-label-dotnet-delete-custom-user-data) ## Tip ### Apple Account Deletion Requirements Apple [requires that applications listed through its App Store](https://developer.apple.com/app-store/review/guidelines/#5.1.1) must give any user who creates an account the option to delete the account. Whether you use an authentication method where you must manually register a user, such as email/password authentication, or one that that automatically creates a user, such as Sign-In with Apple, you must implement [user account deletion](https://www.mongodb.com/docs/atlas/app-services/users/manage/#std-label-delete-user) by June 30, 2022. The following example shows how to delete a user account: `| await app.DeleteUserFromServerAsync(user); |\n| ------------------------------------------ | ` ← [Work with Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/work-with-users/ \"Previous Section\")[Authenticate Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/manage-email-password-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Email/Password Users - .NET SDK On this page * [Overview](#overview)\n* [Register a New User Account](#register-a-new-user-account)\n* [Confirm a New User's Email Address](#confirm-a-new-user-s-email-address)\n* [Reset a User's Password](#reset-a-user-s-password)\n* [Reset the Password on the Client](#reset-the-password-on-the-client)\n* [Call a Reset Function](#call-a-reset-function) ## Overview If you have enabled the [email/password provider](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) in your App, you can register a new account, confirm an email address, and reset a user's password in the client code. ## Register a New User Account To register a new user, pass a user-provided email and password to the[RegisterUserAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.EmailPasswordClient.html#Realms%5FSync%5FApp%5FEmailPasswordClient%5FRegisterUserAsync%5FSystem%5FString%5FSystem%5FString%5F)method: `| await app.EmailPasswordAuth.RegisterUserAsync(userEmail, \"sekrit\"); |\n| ------------------------------------------------------------------- | ` ## Confirm a New User's Email Address To confirm a newly-created user, pass a confirmation `token` and`tokenId` to the[ConfirmUserAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.EmailPasswordClient.html#Realms%5FSync%5FApp%5FEmailPasswordClient%5FConfirmUserAsync%5FSystem%5FString%5FSystem%5FString%5F)mehtod. ## Note ### Use Deep Links in Mobile Apps Mobile applications can handle email confirmation directly in the app by configuring [deep linking](https://developer.android.com/training/app-links/deep-linking.html)in Android, [universal links](https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html)in iOS, and/or [URI handlers](https://docs.microsoft.com/en-us/windows/uwp/launch-resume/web-to-app-linking) for the Universal Windows Platform (UWP). ```csharp await app.EmailPasswordAuth.ConfirmUserAsync(\"<token>\", \"<token-id>\"); \n``` ## Reset a User's Password To reset a user's password, first send the user a password reset email: ```csharp await app.EmailPasswordAuth.SendResetPasswordEmailAsync(userEmail); \n``` Password reset emails contain two values, `token` and `tokenId`. To complete the password reset flow, you can reset the user's password on the client or by calling a custom function on the backend. ### Reset the Password on the Client To reset the password on the client, your UI should prompt the user to enter a new password and the `token` and `tokenId` values. You pass these values to the[ResetPasswordAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.EmailPasswordClient.html#Realms%5FSync%5FApp%5FEmailPasswordClient%5FResetPasswordAsync%5FSystem%5FString%5FSystem%5FString%5FSystem%5FString%5F)method: ```csharp await app.EmailPasswordAuth.ResetPasswordAsync(     myNewPassword, \"<token>\", \"<token-id>\"); \n``` ## Note\n\n ### Call a Reset Function If you have defined a backend function to reset the user's password, you pass the user's email address and **new** password to the[CallResetPasswordFunctionAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.EmailPasswordClient.html#Realms%5FSync%5FApp%5FEmailPasswordClient%5FCallResetPasswordFunctionAsync%5FSystem%5FString%5FSystem%5FString%5FSystem%5FObject%5F%5F%5F)method. The function will likely require additional parameters, as shown below: ```csharp await app.EmailPasswordAuth.CallResetPasswordFunctionAsync(     userEmail, myNewPassword,     \"<security-question-1-answer>\",     \"<security-question-2-answer>\"); \n``` ← [User Metadata - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/user-metadata/ \"Previous Section\")[Multi-User Applications - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/realm-files/bundle-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Bundle Realm Files - .NET SDK On this page * [Create a Realm File for Bundling](#create-a-realm-file-for-bundling)\n* [Bundle a Realm File in Your Production Application](#bundle-a-realm-file-in-your-production-application)\n* [Open a Realm from a Bundled Realm File](#open-a-realm-from-a-bundled-realm-file) You might want to seed your mobile app with some initial data that will be available to users on the initial launch of the app. To do this, you: * Build a temporary realm app,\n* Make a copy of an existing realm (with only the data you want bundled), and then\n* Bundle the [Realm file](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/realms/#std-label-dotnet-realm-file) in your app's shared project. In your production app (the one that will use this bundled realm when first loading), you add a few lines of code to extract the realm and save it in the app data. The following sections provide more information on these steps. ## Important ### Bundling Synced Realms If your backend application has enabled [advanced backend compaction](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-advanced-backend-compaction) by configuring a[client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), users could experience a client reset the first time they open the bundled realm file. This can happen if the bundled realm file was generated more than **client maximum offline time** days before the user syncs the realm for the first time. Applications experiencing a client reset will download the full state of the realm from the application backend. This negates the advantages of bundling a realm file. To prevent client resets and preserve the advantages of realm file bundling: * Avoid using a client maximum offline time in applications that bundle a synchronized realm.\n* If your application does use a client maximum offline time, ensure that your application download always includes a recently synced realm file. Generate a new file each application version, and ensure that no version ever stays current for more than**client maximum offline time** number of days. ## Create a Realm File for Bundling 1. Create a new project with the same data models as your production app. Open an existing realm with the data you wish to bundle, or create a new one.\n2. Use the[WriteCopy()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FWriteCopy%5FRealms%5FRealmConfigurationBase%5F)method to make a copy of the realm to a new location and/or name. The following code demonstrates this. ## Bundle a Realm File in Your Production Application Now that you have a copy of the realm with the \"seed\" data in it, you need to bundle it with your production application. The process of bundling depends on whether you are building a mobile app or Unity app: ## Note ### Cross-Platform Compatibility Non-encrypted realm files are cross-platform compatible, which is why you can bundle the file in the shared project. ## Open a Realm from a Bundled Realm File Now that you have a copy of the realm included with your app, you need to add code to use it. The code you add depends on the type of app: ← [Delete a Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/delete-a-realm/ \"Previous Section\")[Reduce Realm File Size - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/realm-files/compact-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Custom User Data - .NET SDK On this page * [Overview](#overview)\n* [Read a User's Custom User Data](#read-a-user-s-custom-user-data)\n* [Create a User's Custom User Data Document](#create-a-user-s-custom-user-data-document)\n* [Update a User's Custom Data](#update-a-user-s-custom-data)\n* [Delete a User's Custom Data](#delete-a-user-s-custom-data) ## Overview You can store arbitrary custom user data about your users in realm. For example, you might store a user's preferred language, date of birth, or local timezone. Before writing and reading this data, you must enable custom user data in the backend. To learn more, see [Enable Custom User Data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ## Important To use custom user data, you must first [Enable Custom User Data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-enable-custom-user-data-procedure) To create, update, or delete custom user data, you will need the following information from your custom user data configuration: * The custom user data cluster\n* The custom user data database\n* The collection in which custom user data documents are stored\n* The user ID field used to map custom user data documents to users (via user ID) You can find this information in the App Services UI. In the left sidebar, clickApp Users, and then select the Custom User Data tab. ## Read a User's Custom User Data You retrieve custom user data by calling the[GetCustomData()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html#Realms%5FSync%5FUser%5FGetCustomData)method on the `User` object of a logged in user: `| await user.RefreshCustomDataAsync();                                |\n| ------------------------------------------------------------------- |\n| // Tip: define a class that represents the custom data              |\n| // and use the gerneic overload of GetCustomData<>()                |\n| var cud = user.GetCustomData<CustomUserData>();                     |\n| Console.WriteLine($\"User is cool: {cud.IsCool}\");                   |\n| Console.WriteLine($\"User's favorite color is {cud.FavoriteColor}\"); |\n| Console.WriteLine($\"User's timezone is {cud.LocalTimeZone}\");       | ` ## Warning ### Custom Data May Be Stale App Services does not dynamically update the value of the`CustomData` immediately when underlying data changes. Instead, App Services fetches the most recent version of custom user data whenever a user refreshes their [access token](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) or when you explicitly call the[RefreshCustomDataAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html#Realms%5FSync%5FUser%5FRefreshCustomDataAsync)method, which ensures your app has the latest custom user data. ## Create a User's Custom User Data Document\n\n ```csharp app = App.Create(myRealmAppId); user = await app.LogInAsync(Credentials.Anonymous()); mongoClient = user.GetMongoClient(\"mongodb-atlas\"); dbTracker = mongoClient.GetDatabase(\"tracker\"); cudCollection = dbTracker.GetCollection<CustomUserData>(\"user_data\"); var cud = new CustomUserData(user.Id) {     FavoriteColor = \"pink\",     LocalTimeZone = \"+8\",     IsCool = true }; var insertResult = await cudCollection.InsertOneAsync(cud); \n``` You may find it helpful to create a C# class (POCO) that represents the custom user data object. The SDK will serialize/deserialize this class to and from BSON when writing, reading, and updating properties. The example above uses the following class to map the properties: ```csharp public class CustomUserData {     public string _id { get; private set; }     public string _partition { get; private set; }     public string FavoriteColor { get; set; }     public string LocalTimeZone { get; set; }     public bool IsCool { get; set; }     public CustomUserData(string id, string partition = \"myPart\")     {         this._id = id;         this._partition = partition;     } } \n``` ## Update a User's Custom Data Updating custom user data uses the same code as writing. The following example finds and updates the data by using the[UpdateOneAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FUpdateOneAsync%5FSystem%5FObject%5FSystem%5FObject%5FSystem%5FBoolean%5F)method, and then refreshes the data to ensure the latest changes are available: ```csharp var updateResult = await cudCollection.UpdateOneAsync(     new BsonDocument(\"_id\", user.Id),     new BsonDocument(\"$set\", new BsonDocument(\"IsCool\", false))); await user.RefreshCustomDataAsync(); var cud = user.GetCustomData<CustomUserData>(); Console.WriteLine($\"User is cool: {cud.IsCool}\"); Console.WriteLine($\"User's favorite color is {cud.FavoriteColor}\"); Console.WriteLine($\"User's timezone is {cud.LocalTimeZone}\"); \n``` ## Delete a User's Custom Data Deleting custom user data uses the same approach as writing and updating. The following example finds and deletes the data by using the[DeleteOneAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FDeleteOneAsync%5FSystem%5FObject%5F)method: ```csharp var deleteResult = await cudCollection.DeleteOneAsync(     new BsonDocument(\"_id\", user.Id)); // The `DeletedCount` should be 1 Console.WriteLine(deleteResult.DeletedCount); // There should no longer be a custom user document for the user var customData = await cudCollection.FindOneAsync(     new BsonDocument(\"_id\", user.Id)); Console.WriteLine(customData == null); \n``` ← [Authenticate Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/ \"Previous Section\")[User Metadata - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/user-metadata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/link-user-identities/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Link User Identities - .NET SDK On this page * [Example](#example) Realm provides [many authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)to log users into your app. Each provider creates a unique user identity. Realm lets you merge multiple credentials into one user identity. ## Example Consider an application that offers [anonymous login](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication). This allows users to explore the app without registering. If users like the application, they create permanent accounts. They sign up with SSO or email/password authentication. By default, this creates a new `User` object. The app must link the new identity with the original User. You can link identities using the[LinkCredentialsAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html#Realms%5FSync%5FUser%5FLinkCredentialsAsync%5FRealms%5FSync%5FCredentials%5F). This links authentication providers to a logged-in[User](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html) object. `| // 1) A user logs on anonymously:                               |\n| --------------------------------------------------------------- |\n| var anonUser = await app.LogInAsync(Credentials.Anonymous());   |\n| // 2) They create some data, and then decide they want to save  |\n| //    it, which requires creating an Email/Password account.    |\n| // 3) We prompt the user to log in, and then use that info to   |\n| //    register the new EmailPassword user, and then generate an |\n| //    EmailPassword credential to link the existing anonymous   |\n| //    account:                                                  |\n| var email = \"caleb@example.com\";                                |\n| var password = \"shhhItsASektrit!\";                              |\n| await app.EmailPasswordAuth.RegisterUserAsync(                  |\n| email, password);                                               |\n| var officialUser = await anonUser.LinkCredentialsAsync(         |\n| Credentials.EmailPassword(email, password));                    | ` In the example above, we must first register the new [email/password](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) user before linking. If you are using any of the other [Auth Providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), this step is unnecessary. The following example uses [Google authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication) instead of EmailPassword: ```csharp var anonUser = await app.LogInAsync(Credentials.Anonymous()); var officialUser = await anonUser.LinkCredentialsAsync(\n\n \n``` ← [Multi-User Applications - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/ \"Previous Section\")[Sync Data Between Devices - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/convert-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Convert Between Non-Synced Realms and Synced Realms - .NET SDK On this page * [Overview](#overview)\n* [Convert a Non-Synced Realm to a Synced Realm](#convert-a-non-synced-realm-to-a-synced-realm)\n* [Convert a Synced Realm to a Non-Synced Realm](#convert-a-synced-realm-to-a-non-synced-realm) Realm does not have a direct mechanism to add sync to a non-synced realm, or to permanently stop Sync for a synced realm. However, the .NET SDK does provide a method that enables you to copy a realm file for use with a different configuration. With this method, you can easily duplicate a realm's data, which you can then open with a sync or non-sync configuration. This lets you indirectly add Sync to a non-synced realm, or permanently stop a realm from syncing. ## Overview Converting a realm from sync to non-sync (or vice versa), you do the following: 1. Open the existing realm,\n2. Create a configuration for the new realm,\n3. Call the[WriteCopy()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FWriteCopy%5FRealms%5FRealmConfigurationBase%5F)method on the existing realm to make a copy to the new realm. The details of these steps differs depending on which direction then copy is happening. The details are outlined in the sections that follow. ## Convert a Non-Synced Realm to a Synced Realm In the following code, we open a non-synced realm, create a new[FlexibleSyncConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.FlexibleSyncConfiguration.html)object and then copy the existing realm to the new realm. We then delete the existing realm and open the new realm. `| var existingConfig = new RealmConfiguration(\"example.realm\"); |\n| ------------------------------------------------------------- |\n| var existingRealm = Realm.GetInstance(existingConfig);        |\n| var app = App.Create(\"my-app-id\");                            |\n| var user = await app.LogInAsync(                              |\n| Credentials.EmailPassword(\"email@example.com\", \"password\"));  |\n| var syncConfig = new FlexibleSyncConfiguration(user);         |\n| existingRealm.WriteCopy(syncConfig);                          |\n| // You can now delete the nonsynced realm:                    |\n| Realm.DeleteRealm(existingConfig);                            |\n| // You can now use the synced realm:                          |\n| var syncedRealm = Realm.GetInstance(syncConfig);              | ` ## Convert a Synced Realm to a Non-Synced Realm\n\n ```csharp // Open the existing sycned realm var app = App.Create(\"my-app-id\"); var user = await app.LogInAsync(     Credentials.EmailPassword(\"email@example.com\", \"password\")); var syncedConfig = new FlexibleSyncConfiguration(user); var syncedRealm = await Realm.GetInstanceAsync(syncedConfig); // When copying a Synced realm, you must ensure // that there are no pending Sync operations. You do this // by calling WaitForUploadAsync() and WaitForDownloadAsync() // methods: var session = syncedRealm.SyncSession; await session.WaitForUploadAsync(); await session.WaitForDownloadAsync(); var nonSyncConfig = new RealmConfiguration(\"my.realm\"); syncedRealm.WriteCopy(nonSyncConfig); // You can now delete the synced realm: Realm.DeleteRealm(syncedConfig); // You can now use the nonsynced realm: var nonSyncedRealm = Realm.GetInstance(nonSyncConfig); \n``` ## Note ### Data Freshness Although we wait for the data to be synced between the device and Atlas, we cannot guarantee that other devices are not writing new data to Atlas at the same time. However, since we are converting our synced realm to a non-synced realm and will no longer need the data to be up-to-date with other devices, this shouldn't be an issue. ← [Check Upload and Download Progress - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/sync-progress/ \"Previous Section\")[Unidirectional Data Sync - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/asymmetric-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Multi-User Applications - .NET SDK On this page * [User Account States](#user-account-states)\n* [Add a New User to the Device](#add-a-new-user-to-the-device)\n* [List All Users on the Device](#list-all-users-on-the-device)\n* [Remove a User from the Device](#remove-a-user-from-the-device)\n* [Change the Active User](#change-the-active-user) The Realm SDK allows multiple [users](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) to be logged in to an app simultaneously on a given device. Realm client applications run in the context of a single active user even if multiple users are logged in simultaneously. You can quickly switch between authenticated users without requiring them to log in again. ## Important **Any logged in user may become the active user without re-authenticating.**Depending on your app, this may be a security vulnerability. For example, a user on a shared device may switch to a coworker's logged in account without providing their credentials or requiring their explicit permission. If your application requires stricter authentication, avoid switching between users and prefer to explicitly log the active user out before authenticating another user. ## User Account States When a user first logs in through a Realm SDK on a given device or browser, the SDK saves the user's information and keeps track of the user's state on the device. The user's data remains on the device, even if they log out, unless you actively [remove the user.](#std-label-dotnet-remove-user) The following states describe an on-device user at any given time: * **Authenticated:** any user that has logged in on the device and has not logged out or had its session revoked.  \n   * **Active**: a single authenticated user that is currently using the app on a given device. The SDK associates this user with outgoing requests and Atlas App Services evaluates data access permissions and runs functions in this user's context. See [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) for more information.  \n   * **Inactive**: all authenticated users that are not the current active user. You can [switch the active user](#std-label-dotnet-switch-user) to a currently inactive user at any time.\n* **Logged Out:** any user that authenticated on the device but has since logged out or had their session revoked. The following diagram shows how users within a Realm client app transition between states when certain events occur: ![A diagram the outlines the different states a user can be in: logged out, logged in and active, & logged in and inactive.](https://mongodb.com/docs/realm/images/multi-user.png) ### Add a New User to the Device The Realm SDK automatically adds users to a device when they log in for the first time on that device. When a user logs in, they immediately become the application's [active user.](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) `| var aimee = await app.LogInAsync(Credentials.EmailPassword(             |\n| ----------------------------------------------------------------------- |\n| \"aimee@example.com\", \"sekrit\"));                                        |\n| Assert.IsTrue(aimee.Id == app.CurrentUser.Id, \"aimee is current user\"); |\n| var elvis = await app.LogInAsync(Credentials.EmailPassword(             |\n| \"elvis@example.com\", \"sekrit2\"));                                       |\n| Assert.IsTrue(elvis.Id == app.CurrentUser.Id, \"elvis is current user\"); | ` ### List All Users on the Device\n\n ```csharp foreach (var user in app.AllUsers) {     Console.WriteLine($\"User {user.Id} is logged on via {user.Provider}\"); } Assert.AreEqual(2, app.AllUsers.Count()); \n``` ### Remove a User from the Device You can remove all information about a user from the device and automatically log the user out with a call to[RemoveUserAsync():](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.html#Realms%5FSync%5FApp%5FRemoveUserAsync%5FRealms%5FSync%5FUser%5F) ```csharp await app.RemoveUserAsync(elvis); var noMoreElvis = app.AllUsers.FirstOrDefault(u => u.Id == elvis.Id); Assert.IsNull(noMoreElvis); Console.WriteLine(\"Elvis has left the application.\"); \n``` ### Change the Active User You can switch an app's [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) to another logged in user by calling[SwitchUser():](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.html#Realms%5FSync%5FApp%5FSwitchUser%5FRealms%5FSync%5FUser%5F) ```csharp app.SwitchUser(aimee); Assert.IsTrue(aimee.Id == app.CurrentUser.Id, \"aimee is current user\"); \n``` ← [Manage Email/Password Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/manage-email-password-users/ \"Previous Section\")[Link User Identities - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/link-user-identities/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/add-sync-to-app/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Add Device Sync to an App - .NET SDK On this page * [Connect to the App Services backend](#connect-to-the-app-services-backend)\n* [Authenticate a user](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Use the Realm](#use-the-realm) 1 ## Connect to the App Services backend Pass the App ID for your App, which you can [find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) `| app = App.Create(myRealmAppId); |\n| ------------------------------- | ` 2 ## Authenticate a user [Authenticate a user](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate) in your client project. Here, we'll use [anonymous authentication.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-login-anonymous) ```csharp var user = await app.LogInAsync(Credentials.Anonymous()); \n``` 3 ## Open a Synced Realm To open the realm as a synced realm, you can specify whether a synced realm should download data before it opens. Here, we use a [Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/dotnet/sync/configure-and-open-a-synced-realm/#std-label-dotnet-flexible-sync-open-realm) and specify that the SDK should always download the most recent updates before opening the realm. We also [bootstrap the realm with an initial subscription.](https://mongodb.com/docs/realm/sdk/dotnet/sync/flexible-sync/#std-label-dotnet-sync-add-subscription) ```csharp var config = new FlexibleSyncConfiguration(app.CurrentUser) {     PopulateInitialSubscriptions = (realm) =>     {         var myItems = realm.All<Item>().Where(n => n.OwnerId == myUserId);         realm.Subscriptions.Add(myItems);     } }; // The process will complete when all the user's items have been downloaded. var realm = await Realm.GetInstanceAsync(config); \n``` ## Use the Realm The syntax to [read](https://mongodb.com/docs/realm/sdk/dotnet/crud/read/#std-label-dotnet-realm-database-reads), [write](https://mongodb.com/docs/realm/sdk/dotnet/crud/create/#std-label-dotnet-write-operations), and[watch for changes](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-react-to-changes) on a synced realm is identical to the syntax for non-synced realms. While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. The following code creates a new `Task` object and writes it to the realm: ```csharp var testItem = new Item {     Name = \"Do this thing\",     Status = ItemStatus.Open.ToString(),     Partition = \"myPart\" }; await realm.WriteAsync(() => {     realm.Add(testItem); }); \n``` ## Important ### When Using Sync, Avoid Synchronous Writes on the Main Thread Because Realm performs sync integrations on a background thread, if you do a synchronous write to your realm on the main thread, there's a small chance your UI could appear to hang as it waits for the background sync thread to finish a write transaction. Therefore, it's a best practice[not to do a synchronous write on the main thread when using Device Sync](https://mongodb.com/docs/realm/sdk/dotnet/crud/threading/#std-label-dotnet-threading-three-rules) and instead use asynchronous writes with `realm.WriteAsync`.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate Users - .NET SDK On this page * [Log In](#log-in)\n* [Anonymous User](#anonymous-user)\n* [Email/Password User](#email-password-user)\n* [API Key User](#api-key-user)\n* [Custom JWT User](#custom-jwt-user)\n* [Custom Function User](#custom-function-user)\n* [Facebook User](#facebook-user)\n* [Google User](#google-user)\n* [Apple User](#apple-user)\n* [Offline Login](#offline-login)\n* [Log a User Out](#log-a-user-out)\n* [Retrieve the Current User](#retrieve-the-current-user)\n* [Get a User Access Token](#get-a-user-access-token) The SDK provides an API for authenticating users using any enabled authentication provider. Instantiate a[Credentials](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Credentials.html)object and pass it to the[LogInAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.html#Realms%5FSync%5FApp%5FLogInAsync%5FRealms%5FSync%5FCredentials%5F)method to authenticate and obtain a [User](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html)instance. The `Credentials` class exposes factory methods that correspond to each of the authentication providers: Before you can authenticate a user, ensure you have: * [Created an App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* Enabled one or more [authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)\n* [Installed the .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/install/#std-label-dotnet-install) ## Log In ### Anonymous User If you have enabled [Anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) in the App Services UI, users can immediately log into your app without providing any identifying information. The following code shows how to do this: `| var user = await app.LogInAsync(Credentials.Anonymous()); |\n| --------------------------------------------------------- | ` ### Email/Password User If you have enabled [Email/Password authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication), you can log in using the following code: ```csharp var user = await app.LogInAsync(     Credentials.EmailPassword(\"caleb@example.com\", \"shhhItsASektrit!\")); \n``` ### API Key User If you have enabled [API Key authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication), you can log in using the following code: ```csharp var user = await app.LogInAsync(Credentials.ApiKey(apiKey)); \n``` ### Custom JWT User If you have enabled the [Custom JWT authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication), you can log in using the following code: ```csharp var user =     await app.LogInAsync(Credentials.JWT(jwt_token)); \n``` ### Custom Function User\n\n ```csharp var functionParameters = new {     username = \"caleb\",     password = \"shhhItsASektrit!\",     IQ = 42,     isCool = false }; var user =     await app.LogInAsync(Credentials.Function(functionParameters)); \n``` ### Facebook User The [Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) authentication provider allows you to authenticate users through a Facebook app using their existing Facebook account. ## Important ### Enable the Facebook Auth Provider To log a user in with their existing Facebook account, you must configure and enable the [Facebook authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication)for your application. ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. ```csharp var user =     await app.LogInAsync(Credentials.Facebook(facebookToken)); \n``` ### Google User If you have enabled [Google authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication), you can log in using the following code: ```csharp var user =     await app.LogInAsync(Credentials.Google(googleAuthCode, GoogleCredentialType.AuthCode)); \n``` ### Apple User If you have enabled [Sign-in with Apple authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication), you can log in using the following code: ```csharp var user =     await app.LogInAsync(Credentials.Apple(appleToken)); \n``` ## Tip If you get a `Login failed` error saying that the `token contains an invalid number of segments`, verify that you're passing a UTF-8-encoded string version of the JWT. ## Offline Login When your Realm application authenticates a user, it caches the user's credentials. You can check for existing user credentials to bypass the login flow and access the cached user. Use this to open a realm offline. ## Note ### Initial login requires a network connection When a user signs up for your app, or logs in for the first time with an existing account on a client, the client must have a network connection. Checking for cached user credentials lets you open a realm offline, but only if the user has previously logged in while online. The following example checks if there is a cached User object. If not, it logs the user in. Otherwise, it uses the cached credentials: ```csharp if (app.CurrentUser == null) {     // App must be online for user to authenticate     user = await app.LogInAsync(         Credentials.EmailPassword(\"caleb@mongodb.com\", \"shhhItsASektrit!\"));     config = new PartitionSyncConfiguration(\"_part\", user);     realm = await Realm.GetInstanceAsync(config); } else {     // This works whether online or offline     user = app.CurrentUser;     config = new PartitionSyncConfiguration(\"_part\", user);     realm = Realm.GetInstance(config); } \n``` ## Log a User Out Once logged in, you can log out by calling the `LogOutAsync()` method: ```csharp await user.LogOutAsync(); \n``` ## Warning When a user logs out, you can no longer read or write data in any synced realms that the user opened. As a result, any operation that has not yet completed before the initiating user logs out cannot complete successfully and will likely result in an error. Any data in a write operation that fails in this way will be lost. ## Retrieve the Current User\n\n ### Get a User Access Token When a user logs in, Atlas App Services creates an access token for the user that grants them access to your App. The Realm SDK automatically manages access tokens, refreshes them when they expire, and includes a valid access token for the current user with each request. If you send requests outside of the SDK (for example, through the GraphQL API) then you need to include the user's access token with each request, and manually refresh the token when it expires. You can access and refresh a logged in user's access token in the SDK from their`Realm.User` object, as in the following example: ```csharp // Returns a valid user access token to authenticate requests public async Task<string> GetValidAccessToken(User user) {     // An already logged in user's access token might be stale. To     // guarantee that the token is valid, refresh it.     await user.RefreshCustomDataAsync();     return user.AccessToken; } \n``` ← [Create and Delete Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/create-and-delete-users/ \"Previous Section\")[Custom User Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/sync-session/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Suspend or Resume a Sync Session - .NET SDK On this page * [When to Pause a Sync Session](#when-to-pause-a-sync-session) Opening a synced realm starts a Sync[Session](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Session.html). To pause synchronization for a specific session, you can call the[Stop()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Session.html#Realms%5FSync%5FSession%5FStop)method on the session. When you then call the[Start()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Session.html#Realms%5FSync%5FSession%5FStart)method on the paused session, the Sync session resumes. ## Note ### Each session is independent You must manually call the `Stop()` and `Start()` methods for each realm whose Sync session you want to pause and restart. The sync state of one session has no impact on other open sessions. The following code block demonstrates calling the `Stop()` and `Start()`methods: `| var session = realm.SyncSession; |\n| -------------------------------- |\n| session.Stop();                  |\n| //later...                       |\n| session.Start();                 | ` ## When to Pause a Sync Session For most applications, there is no need to manually pause and resume a sync session. However, there are a few circumstances under which you may want to pause or suspend a sync session: * You only want to sync after the user takes a specific action\n* You only want to sync during a certain time of the day\n* You don't want to attempt to sync when there is poor network connectivity\n* You want to explicitly force a sync session to connect In the case of poor network connectivity, continually trying to establish a network connection can drain the user's device battery. The case of explicitly forcing a sync session to connect is most commonly related to being offline for some time. The sync client attempts to connect, and upon failure, goes into exponential backoff. After being offline for a long time, the client may not immediately reconnect. Pausing and resuming the sync session explicitly forces the connection. When you do pause a sync session, keep these things in mind: * If the client may be offline longer than the [client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), the client will be unable to resume syncing and must perform a [client reset.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets)\n* Pausing a sync session pauses it in both directions. Changes that your app makes on the device do not sync with the backend, _and_ changes to the data in the backend or on other devices do not sync to the device. There is no way to pause only uploads or pause only downloads.\n* Do not pause a sync session if you want a client to permanently stop syncing with the backend. To permanently stop syncing, copy the contents of the synced realm into a non-synced realm, and use the non-synced realm in the client. _Do not_ pause sync to stop syncing for indefinite time periods or time ranges in months and years. The functionality is not designed or tested for these use cases. You could encounter a range of issues when using it this way. ← [Client Resets - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/client-reset/ \"Previous Section\")[Check Upload and Download Progress - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/sync-progress/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/handle-sync-errors/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Handle Sync Errors - .NET SDK On this page * [Set the Client Log Level](#set-the-client-log-level)\n* [Customize the Logging Function](#customize-the-logging-function) Device Sync represents errors via [SessionExceptions](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Exceptions.SessionException.html). In addition to the standard exception properties, you have access to an [ErrorCode](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Exceptions.ErrorCode.html)that contains information about the type of the error and allows you to have strongly typed handling logic. `| config.OnSessionError = (session, sessionException) =>               |\n| -------------------------------------------------------------------- |\n| {                                                                    |\n| switch (sessionException.ErrorCode)                                  |\n| {                                                                    |\n| case ErrorCode.InvalidCredentials:                                   |\n| // Tell the user they don't have permissions to work with that Realm |\n| break;                                                               |\n| case ErrorCode.Unknown:                                              |\n| // See https://www.mongodb.com/docs/realm-sdks/dotnet                |\n| // /latest/reference/Realms.Sync.Exceptions.ErrorCode.html           |\n| // for all of the error codes                                        |\n| break;                                                               |\n| }                                                                    |\n| };                                                                   | ` ## Note ### Additional Exception Information\n\n ## Tip For a list of common Device Sync errors and how to handle them, refer to[Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services Device Sync documentation. ## Set the Client Log Level To control which messages are logged by the client logger, use[LogLevel:](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Logging.LogLevel.html) ```csharp Logger.LogLevel = LogLevel.Debug; \n``` ## Tip To diagnose and troubleshoot errors while developing your application, set the log level to `debug` or `trace`. For production deployments, decrease the log level for improved performance. ## Customize the Logging Function To set a custom logger function, set [Logger.Default](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Logging.Logger.html) to a custom Logger function. ```csharp using Realms.Logging; Logger.LogLevel = LogLevel.All; // customize the logging function: Logger.Default = Logger.Function(message => {     // Do something with the message }); \n``` ← [Manage Flexible Sync Subscriptions- .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/flexible-sync/ \"Previous Section\")[Client Resets - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/client-reset/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/asymmetric-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Unidirectional Data Sync - .NET SDK On this page * [Overview](#overview)\n* [Sync Data Unidirectionally from a Client Application](#sync-data-unidirectionally-from-a-client-application) ## Overview _New in version 10.17.0_. You can use [Asymmetric Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) to stream data from a client application to a Flexible Sync-enabled Atlas App Services App. For example, you might want to sync data unidirectionally in IoT applications, such as a weather sensor sending data to the cloud. Asymmetric sync is also useful for writing other types of immutable data where you do not require conflict resolution, such as creating invoices from a retail app or logging application events. Asymmetric Sync is optimized to provide performance improvements for heavy client-side _insert-only_ workloads. ## Important You cannot query, modify, or delete Asymmetric objects from a client app. Because AsymmetricObject can not be modified by the client, the compiler will not let you add a subscription to an AsymmetricObject. The .NET SDK allows you to work with Asymmetric objects and standard Realm objects within the same realm. ## Sync Data Unidirectionally from a Client Application Before you set up Asymmetric sync, you need to understand the following rules: * The C# objects that you will sync with Atlas must derive from the[AsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.AsymmetricObject.html) class.\n* An object that derives from `AsymmetricObject` can contain[EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.EmbeddedObject.html) types, but not `RealmObject` types or other `AsymmetricObject` types.\n* `RealmObject` and `EmbeddedObject` types cannot contain `AsymmetricObject`types as properties.\n* Unidirectional Sync requires [Flexible Sync.](https://mongodb.com/docs/realm/sdk/dotnet/sync/flexible-sync/#std-label-dotnet-flexible-sync) The process for syncing data asymmetrically is the same as standard [bi-directional sync](https://mongodb.com/docs/realm/sdk/dotnet/quick-start/#std-label-dotnet-client-quick-start), as long as the rules above are followed. The following code shows creating an Asymmetric object and syncing it with the backend. It also shows to queries that generate errors.\n\n ` ← [Convert Between Non-Synced Realms and Synced Realms - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/convert-realm/ \"Previous Section\")[Use Realm in a Console App - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/async-console/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/flexible-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Flexible Sync Subscriptions- .NET SDK On this page * [Overview](#overview)\n* [Manage Your Subscriptions](#manage-your-subscriptions)\n* [Get Subscriptions](#get-subscriptions)\n* [Add a Query to the Set Of Subscriptions](#add-a-query-to-the-set-of-subscriptions)\n* [Bootstrap the Realm with Initial Subscriptions](#bootstrap-the-realm-with-initial-subscriptions)\n* [Add a Subscription](#add-a-subscription)\n* [Update Subscriptions with a New Query](#update-subscriptions-with-a-new-query)\n* [Remove Subscriptions](#remove-subscriptions)\n* [Remove a Subscription by Query](#remove-a-subscription-by-query)\n* [Remove a Subscription by Name](#remove-a-subscription-by-name)\n* [Remove All Subscriptions of a Class Name or Object Type](#remove-all-subscriptions-of-a-class-name-or-object-type)\n* [Remove All Subscriptions](#remove-all-subscriptions)\n* [Wait for Subscription Changes to Sync](#wait-for-subscription-changes-to-sync)\n* [Subscription State](#subscription-state)\n* [Flexible Sync RQL Limitations](#flexible-sync-rql-limitations)\n* [Unsupported Query Operators in Flexible Sync](#unsupported-query-operators-in-flexible-sync)\n* [List Queries](#list-queries)\n* [Embedded or Linked Objects](#embedded-or-linked-objects) ## Overview Flexible Sync uses subscriptions and permissions to determine which data to sync with your App. To use Flexible Sync in a .NET application: * [Configure Flexible Sync on the backend.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n* [Initialize the app](https://mongodb.com/docs/realm/sdk/dotnet/quick-start/#std-label-dotnet-quick-start-init-app)\n* [Authenticate a user](https://mongodb.com/docs/realm/sdk/dotnet/quick-start/#std-label-dotnet-quick-start-authenticate) in your client project.\n* [Open the synced Realm with a Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/dotnet/sync/configure-and-open-a-synced-realm/#std-label-dotnet-flexible-sync-open-realm)\n* [Add subscriptions to the client application](#std-label-dotnet-flexible-sync-manage-subscriptions) You can add, update, and remove query subscriptions to determine which data syncs to the client device. ## Note ### Flexible Sync Prerequisites Enabling Flexible Sync in your App requires a non-sharded Atlas cluster running [MongoDB 5.0 or greater](https://www.mongodb.com/docs/manual/release-notes/) ## Note ### Realm .NET SDK Version Requirement In addition to the requirements above, you must use [Realm .NET version 10.9.0](https://github.com/realm/realm-dotnet/releases) or greater in order to use Flexible Sync in your .NET client application. ## Important Flexible Sync does not support all the operators available in Realm Query Language. See [Flexible Sync RQL Limitations](#std-label-dotnet-flexible-sync-rql-limitations) for details. ## Manage Your Subscriptions When configuring Flexible Sync on the backend, you specify which fields your client application can query. In the client application, use the[subscriptions](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Subscription.html) API to manage a set of subscriptions to specific queries on queryable fields. You can:\n\n When the data matches the subscription, and the authenticated user has the appropriate permissions, Atlas App Services syncs the backend data with the client app. You can specify a string name for your subscription. If you do not give your subscription a name, the name is set to null. When you create a subscription, App Services looks for data matching a query on a specific object type. In your Flexible Sync subscriptions, you can have subscriptions on several different object types or several queries on the same object type. ## Important ### Object Links You must add both an object and its linked object to the subscription set to see a linked object. If your subscription results contain an object with a property that links to an object not contained in the results, the link appears to be nil. There is no way to distinguish whether that property's value is legitimately nil, or whether the object it links to exists but is out of view of the query subscription. ### Get Subscriptions When using flexible sync, you can access a[SubscriptionSet](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSet.html), a collection of subscriptions, through the [Realm.Subscriptions](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FSubscriptions) property. `| var subscriptions = realm.Subscriptions; |\n| ---------------------------------------- | ` You can use this subscriptions set to add queries to this list of subscriptions and update existing subscriptions, as shown in the examples below. ### Add a Query to the Set Of Subscriptions You must have at least one subscription before you can read from or write to the realm. You can create one or more initial subscriptions when you configure Flexible Sync, or you can add subscriptions after initialization. #### Bootstrap the Realm with Initial Subscriptions You can bootstrap a realm with an initial subscription set when you open it with a [FlexibleSyncConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.FlexibleSyncConfiguration.html). Set the[PopulateInitialSubscriptions](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.FlexibleSyncConfiguration.html#Realms%5FSync%5FFlexibleSyncConfiguration%5FPopulateInitialSubscriptions)parameter to a callback that is invoked when the realm is created. Add the queries you want to use to bootstrap the realm, as shown in the following example: ```csharp var config = new FlexibleSyncConfiguration(app.CurrentUser) {     PopulateInitialSubscriptions = (realm) =>     {         var myItems = realm.All<Item>().Where(n => n.OwnerId == myUserId);         realm.Subscriptions.Add(myItems);     } }; // The process will complete when all the user's items have been downloaded. var realm = await Realm.GetInstanceAsync(config); \n``` #### Add a Subscription To add a subscription to an existing `FlexibleSyncConfiguration`, You must perform all mutations on the subscriptions set within an update block. To create an update block, call the [SubscriptionSet.Update()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSet.html#Realms%5FSync%5FSubscriptionSet%5FUpdate%5FSystem%5FAction%5F). method. Within the delegate, call the [SubscriptionSet.Add()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSet.html#Realms%5FSync%5FSubscriptionSet%5FAdd%5F%5F1%5FSystem%5FLinq%5FIQueryable%5F%5F%5F0%5F%5FRealms%5FSync%5FSubscriptionOptions%5F)method on the `SubscriptionSet` to add a query to the subscription.\n\n Create the `query` argument using the [query engine.](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/#std-label-dotnet-client-query-engine) `SubscriptionOptions` contains additional configuration for your subscription: * a `Name` string field\n* a `UpdateExisting` boolean field. If `UpdateExisting` is true, adding a subscription with an existing name will replace the existing query with the new query. However, if you set `UpdateExisting` to false, adding a subscription with an existing name but a different query throws an exception. `UpdateExisting` defaults to true. ## Note ### Duplicate Subscriptions If you add a duplicate **unnamed** subscription with the same query, the SDK automatically removes it; adding an identical**named** subscription is a [no-op](https://en.wikipedia.org/wiki/NOP%5F%28code%29). Therefore, in both cases, duplicate subscriptions are ignored. You can add a single query, or batch multiple queries within a `SubscriptionSet.Update`block. Performing query updates is an expensive operation on the server. We strongly advise designing your application to minimize updates. You can do this by creating all subscriptions in a single update block the first time the user launches the app and batching any follow-up changes to the subscription set. In the example below, we subscribe to three queries. ```csharp realm.Subscriptions.Update(() => {     // subscribe to all long running tasks, and give the subscription the name 'longRunningTasksSubscription'     var longRunningTasksQuery = realm.All<Task>().Where(t => t.Status == \"completed\" && t.ProgressMinutes > 120 );     realm.Subscriptions.Add(longRunningTasksQuery, new SubscriptionOptions() { Name = \"longRunningTasks\" });     // subscribe to all of Ben's Task objects     realm.Subscriptions.Add(realm.All<Task>().Where(t => t.Owner == \"Ben\"));     // subscribe to all Teams, and give the subscription the name 'teamsSubscription' and throw an error if a new query is added to the team subscription     realm.Subscriptions.Add(realm.All<Team>(), new SubscriptionOptions() { Name = \"teams\", UpdateExisting = false });  }); \n``` ### Update Subscriptions with a New Query You can update a named subscription with a new query. To update a subscription's query, pass the new query and a subscription option with the name of the subscription that you want to update to the`SubscriptionSet.Add()` method. Like adding a new subscription, you must update a subscription within an update block by calling`SubscriptionSet.Update()` method. ## Note Updating an unnamed subscription is not possible. Alternatively, you can [delete the unnamed subscription](#std-label-dotnet-remove-subscriptions), and [create a new subscription](#std-label-dotnet-sync-add-subscription) with the desired query. In the following example, long running tasks are re-defined to be any tasks that have taken more than 130 minutes. ```csharp realm.Subscriptions.Update(() => {     var updatedLongRunningTasksQuery = realm.All<Task>().Where(t => t.Status == \"completed\" && t.ProgressMinutes > 130);     realm.Subscriptions.Add(updatedLongRunningTasksQuery, new SubscriptionOptions() { Name = \"longRunningTasks\" }); }); \n``` ## Note Attempting to update a subscription that has the `SubscriptionOptions.UpdateExisting` field set to false will throw an exception. ### Remove Subscriptions To remove subscriptions from the subscription set, you can: * Remove a single subscription with the given query\n* Remove a single subscription with the given name\n* Remove a single subscription with the given subscription\n* Remove all subscriptions of a specific type\n* Remove all subscriptions When you remove a subscription query, the server also removes synced data from the client device. #### Remove a Subscription by Query\n\n In the following example, the subscription to tasks with an owner named 'Ben' is removed from the subscriptions set. ```csharp realm.Subscriptions.Update(() => {     // remove a subscription by it's query     var query = realm.All<Task>().Where(t => t.Owner == \"Ben\");     realm.Subscriptions.Remove(query); }); \n``` #### Remove a Subscription by Name Within an update block, you can remove a specific subscription by name. Pass the name to the[Remove()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSet.html#Realms%5FSync%5FSubscriptionSet%5FRemove%5FSystem%5FString%5F)method on the `SubscriptionSet`. ```csharp realm.Subscriptions.Update(() => {     // remove a named subscription     var subscriptionName = \"longRunningTasksSubscription\";     realm.Subscriptions.Remove(subscriptionName); }); \n``` #### Remove All Subscriptions of a Class Name or Object Type Within an update block, you can remove remove all unnamed subscriptions of a class by passing the class name as a string to the[RemoveAll(\"ClassName\")](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSet.html#Realms%5FSync%5FSubscriptionSet%5FRemoveAll%5FSystem%5FString%5FSystem%5FBoolean%5F)method. The `RemoveAll()` method has an optional second argument that is a boolean, `removedName`, which also removes the named subscriptions if it is set to `true`. `removedName` is set to false by default. Alternatively, you can remove all unnamed subscriptions of an object type with [RemoveAll()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSet.html#Realms%5FSync%5FSubscriptionSet%5FRemoveAll%5F%5F1%5FSystem%5FBoolean%5F). The `RemoveAll<Type>()` method has an optional boolean `removedName` argument which also removes the named subscriptions if it is set to `true`. `removedName` is set to false by default. ```csharp realm.Subscriptions.Update(() => {     // remove all subscriptions of the \"Team\" Class Name      realm.Subscriptions.RemoveAll(\"Team\");     // Alernatively, remove all subscriptions of the \"Team\" object type     realm.Subscriptions.RemoveAll<Team>(); }); \n``` #### Remove All Subscriptions Within an update block, you can remove all unnamed subscriptions from the subscriptions set. Call the [RemoveAll()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSet.html#Realms%5FSync%5FSubscriptionSet%5FRemoveAll%5FSystem%5FBoolean%5F)method on the `SubscriptionSet`. The `RemoveAll()` method has an optional boolean `removedName` argument which also removes the named subscriptions if it is set to `true`. `removedName` is set to false by default. ```csharp realm.Subscriptions.Update(() => {     // remove all subscriptions, including named subscriptions     realm.Subscriptions.RemoveAll(true); }); \n``` ### Wait for Subscription Changes to Sync Mutating the subscription set within an update block is only one part of changing a subscription. After the local subscription change, the realm synchronizes with the server to resolve any updates to the data due to the subscription change. This could mean adding or removing data from the synced realm.\n\n An exception may occur if: * an unsupported query is subscribed to. Subscribing to an unsupported query will pause synchronization. To resume synchronization, [remove the unsupported query.](#std-label-dotnet-remove-subscriptions)\n* you are performing an invalid action, such as adding an object that does not match a subscription. This triggers a [client reset](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets): data is erased from the realm, and a new copy of the data is created without any subscriptions in the set. ```csharp // Wait for the server to acknowledge the subscription change and return all objects // matching the query try {     await realm.Subscriptions.WaitForSynchronizationAsync(); } catch (SubscriptionException ex) {     // do something in response to the exception or log it     Console.WriteLine($@\"The subscription set's state is Error and synchronization is paused:  {ex.Message}\"); } \n``` ### Subscription State Use the [SubscriptionSet.State](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSet.html#Realms%5FSync%5FSubscriptionSet%5FState)property to read the current state of the subscription set. The `Superseded` state is a [SubscriptionSetState](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SubscriptionSetState.html) that can occur when another thread updates a subscription on a different instance of the subscription set. If the state becomes `Superseded`, you must obtain a new instance of the subscription set before you can update it. ## Note ### Subscription State \"Complete\" The subscription set state \"complete\" does not mean \"sync is done\" or \"all documents have been synced\". \"Complete\" means the following two things have happened: * The subscription has become the active subscription set that is currently being synchronized with the server.\n* The documents that matched the subscription _at the time the subscription was sent to the server_ are now on the local device. Note that this does not necessarily include all documents that currently match the subscription. The Realm SDK does not provide a way to check whether all documents that match a subscription have synced to the device. ## Flexible Sync RQL Limitations Flexible Sync has some limitations when using RQL operators. When you write the [query subscription](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-flexible-sync-query-subscription)that determines which data to sync, the server does not support these query operators. However, you can still use the full range of RQL features to query the synced data set in the client application. ### Unsupported Query Operators in Flexible Sync | Operator Type       | Unsupported Operators          |\n| ------------------- | ------------------------------ |\n| Aggregate Operators | @avg, @count, @max, @min, @sum |\n| Query Suffixes      | DISTINCT, SORT, LIMIT          | Case insensitive queries (`[c]`) cannot use indexes effectively. As a result, case insensitive queries are not recommended, since they could lead to performance problems. Flexible Sync only supports `@count` for array fields. ### List Queries Flexible Sync supports querying lists using the `IN` operator. You can query a list of constants to see if it contains the value of a queryable field: ```javascript // Query a constant list for a queryable field value \"priority IN { 1, 2, 3 }\" \n``` If a queryable field has an array value, you can query to see if it contains a constant value: ```javascript // Query an array-valued queryable field for a constant value \"'comedy' IN genres\" \n``` ## Warning You **cannot** compare two lists with each other in a Flexible Sync query. Note that this is valid Realm Query Language syntax outside of Flexible Sync queries. ```javascript // Invalid Flexible Sync query. Do not do this! \"{'comedy', 'horror', 'suspense'} IN genres\" // Another invalid Flexible Sync query. Do not do this!\n\n \n``` ### Embedded or Linked Objects Flexible Sync does not support querying on properties in Embedded Objects or links. For example, `obj1.field == \"foo\"`. ← [Configure & Open a Synced Realm - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/configure-and-open-a-synced-realm/ \"Previous Section\")[Handle Sync Errors - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/handle-sync-errors/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/client-reset/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Client Resets - .NET SDK On this page * [Overview](#overview)\n* [Client Reset Strategies](#client-reset-strategies)\n* [Recover Unsynced Local Changes](#recover-unsynced-local-changes)\n* [RecoverOrDiscardUnsyncedChangesHandler](#recoverordiscardunsyncedchangeshandler)\n* [RecoverUnsyncedChangesHandler](#recoverunsyncedchangeshandler)\n* [Discard Unsynced Changes](#discard-unsynced-changes)\n* [Manual Recovery](#manual-recovery) ## Overview _New in version 10.17.0_. A client reset error is a scenario where a client realm cannot sync data with the application backend. Clients in this state may continue to run and save data locally but cannot send or receive sync changesets until they perform a client reset. The Realm SDKs provide methods to automatically handle client resets under most scenarios. ## Client Reset Strategies Client reset scenarios occur when the server's history is incompatible with the client's history. The most common causes of client resets are described in[Client Resets.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) In the .NET SDK, you can specify a client reset strategy in your [FlexibleSyncConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.FlexibleSyncConfiguration.html)and [PartitionSyncConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.PartitionSyncConfiguration.html). The [ClientResetHandler](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.SyncConfigurationBase.html#Realms%5FSync%5FSyncConfigurationBase%5FClientResetHandler)property can be set to one of the following:\n\n The following sections describe the different strategies for handling a client reset and how you can use each of the `ClientResetHandlers`. ### Recover Unsynced Local Changes In a client reset that does not involve a breaking schema change, the SDK integrates objects created locally that did not sync before the client reset. The following rules determine how conflicts are resolved when both the backend and the client make changes to the same object: * If an object is deleted on the server, but is modified on the recovering client, the delete takes precedence and the client discards the update.\n* If an object is deleted on the recovering client, but not the server, then the client applies the delete instruction.\n* In the case of conflicting updates to the same field, the client update is applied. ## Important ### Breaking Changes The recovery process cannot handle a breaking schema change. For example, if you make a non-additive change to one or more of your Realm object classes, the recovery process will fail. In this case, users will be required to update their client app. For more information on breaking changes, see [Breaking vs. Non-Breaking Change Quick Reference.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-breaking-change-quick-reference) There are two client reset handlers that try to automatically recover the unsycned local data: `RecoverOrDiscardUnsyncedChangesHandler` and `RecoverUnsyncedChangesHandler`. #### RecoverOrDiscardUnsyncedChangesHandler This is the default handler, as it provides the most robust recovery process. If the automatic recovery process fails, it falls back to the `DiscardLocalReset`strategy explained in the [Discard Unsynced Changes section](#std-label-dotnet-client-reset-discard-unsynced-changes). If that process fails, it falls back again to a manual reset strategy explained in the [Manual Recovery section](#std-label-dotnet-client-reset-manual-recovery). This handler provides the following callback methods: * [OnBeforeReset](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ErrorHandling.RecoverOrDiscardUnsyncedChangesHandler.html#Realms%5FSync%5FErrorHandling%5FRecoverOrDiscardUnsyncedChangesHandler%5FOnBeforeReset), which the SDK invokes prior to the client reset. You can use this callback to notify the user before the client reset begins.\n* [OnAfterRecovery](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ErrorHandling.RecoverOrDiscardUnsyncedChangesHandler.html#Realms%5FSync%5FErrorHandling%5FRecoverOrDiscardUnsyncedChangesHandler%5FOnAfterRecovery), which the SDK invokes if _and only if_ the automatic reset completes successfully. You can use it to notify the user that the client reset is complete.\n* [OnAfterDiscard](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ErrorHandling.RecoverOrDiscardUnsyncedChangesHandler.html#Realms%5FSync%5FErrorHandling%5FRecoverOrDiscardUnsyncedChangesHandler%5FOnAfterDiscard), which the SDK invokes only if the automatic client reset fails _and_ the discard local strategy succeeds. If the discard strategy fails, this callback is not invoked.\n* [ManualResetFallback](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ErrorHandling.DiscardUnsyncedChangesHandler.html), which the SDK invokes only if the automatic recovery and the discard strategy have failed. You implement this callback to handle the reset failure. Your logic here should be similar to that described for a[ManualRecoveryHandler.](#std-label-dotnet-client-reset-manual-recovery) The following example shows using each of these callbacks:\n\n ` #### RecoverUnsyncedChangesHandler Like the `RecoverOrDiscardUnsyncedChangesHandler`, this handler attempts to recover all unsynced local changes automatically. However, unlike`RecoverOrDiscardUnsyncedChangesHandler`, this handler does not fall back to a`DiscardUnsyncedChangesHandler` if the automatic recovery fails. Instead, it falls back to a manual reset strategy explained in the[Manual Recovery section](#std-label-dotnet-client-reset-manual-recovery). The handler provides the following callback methods: * [OnBeforeReset](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ErrorHandling.RecoverUnsyncedChangesHandler.html#Realms%5FSync%5FErrorHandling%5FRecoverUnsyncedChangesHandler%5FOnBeforeReset), which you can use to notify the user before the reset begins.\n* [OnAfterReset](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ErrorHandling.RecoverUnsyncedChangesHandler.html#Realms%5FSync%5FErrorHandling%5FRecoverUnsyncedChangesHandler%5FOnAfterReset), which you can use to notify the user when the reset has completed successfully.\n* [ManualResetFallback](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ErrorHandling.RecoverUnsyncedChangesHandler.html#Realms%5FSync%5FErrorHandling%5FRecoverUnsyncedChangesHandler%5FManualResetFallback), which you implement to handle a reset failure. Your logic here should be similar to that described for a[ManualRecoveryHandler.](#std-label-dotnet-client-reset-manual-recovery) The following example shows using each of these callbacks: ```csharp var conf = new FlexibleSyncConfiguration(user) {     ClientResetHandler = new RecoverUnsyncedChangesHandler     {         // The following callbacks are optional         OnBeforeReset = (beforeReset) =>         {             // Executed before the client reset begins             // Can be used to notify the user that a reset is going             // to happen         },         OnAfterReset = (beforeReset, afterReset) =>         {             // Executed after the client reset is complete             // Can be used to notify the user that the reset is done         },         ManualResetFallback = (err) =>         {             // Automatic reset failed; handle the reset manually here         }     } }; \n``` ### Discard Unsynced Changes This strategy **permanently deletes** all local unsynced changes made since the last successful sync. If you choose to use a`DiscardUnsyncedChangesHandler`, the SDK restores your local realm file to a syncable state without closing the realm and while keeping notifications fully working. If this process fails, it falls back to a manual reset strategy explained in the[Manual Recovery section](#std-label-dotnet-client-reset-manual-recovery). This handler provides the following callback methods:\n\n The following example shows how you might implement a`DiscardUnsyncedChangesHandler`: ```csharp {     var config = new FlexibleSyncConfiguration(user);     config.ClientResetHandler = new DiscardUnsyncedChangesHandler()     {         // The following callbacks are optional         OnBeforeReset = (beforeReset) =>         {             // Executed before the client reset begins             // Can be used to notify the user that a reset is going             // to happen         },         OnAfterReset = (beforeReset, afterReset) =>         {             // Executed after the client reset is complete             // Can be used to notify the user that the reset is done         },         ManualResetFallback = (err) =>         {             // Automatic reset failed; handle the reset manually here         }     };     var realm = await Realm.GetInstanceAsync(config); \n``` ### Manual Recovery In most cases, you should use one of the other strategies for client resets. For those infrequent cases where you need to customize your data recovery process, select the[ManualRecoveryHandler](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ErrorHandling.ManualRecoveryHandler.html#Realms%5FSync%5FErrorHandling%5FManualRecoveryHandler%5F%5Fctor%5FRealms%5FSync%5FErrorHandling%5FClientResetHandlerBase%5FClientResetCallback%5F)handler. ## Note ### Fallbacks While the manual strategy should only be used in edge cases, the other client reset handlers might fall back to a manual strategy. The logic you use in those handlers is similar to the logic described here. Within the `ManualRecoveryHandler`, you dispose the existing realm, and then call the [InitiateClientReset()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Exceptions.ClientResetException.html#Realms%5FSync%5FExceptions%5FClientResetException%5FInitiateClientReset)method. The following example demonstrates implementing the `ManualRecoveryHandler`: ```csharp private void SetupRealm() {     var config = new FlexibleSyncConfiguration(user);     config.ClientResetHandler =         new ManualRecoveryHandler(HandleClientResetError);     var realm = await Realm.GetInstanceAsync(config); } private void HandleClientResetError(ClientResetException clientResetException) {     Console.WriteLine($\"Client Reset requested: {clientResetException.Message}\");     // Prompt user to perform a client reset immediately. If they don't,     // they won't receive any data from the server until they restart the app     // and all changes they make will be discarded when the app restarts.     var didUserConfirmReset = ShowUserAConfirmationDialog();     if (didUserConfirmReset)     {         // Close the Realm before doing the reset. It must be          // deleted as part of the reset.         fsRealm.Dispose();         // perform the client reset         var didReset = clientResetException.InitiateClientReset();         if (didReset)         {             // Navigate the user back to the main page or reopen the             // the Realm and reinitialize the current page         }         else\n\n             // Reset failed - notify user that they'll need to             // update the app         }     } } \n``` ← [Handle Sync Errors - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/handle-sync-errors/ \"Previous Section\")[Suspend or Resume a Sync Session - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/sync-session/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/sync-progress/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Check Upload and Download Progress - .NET SDK On this page * [Monitor Sync Progress and Status](#monitor-sync-progress-and-status)\n* [Wait for Changes to be Uploaded or Downloaded](#wait-for-changes-to-be-uploaded-or-downloaded)\n* [Monitor Sync Progress](#monitor-sync-progress)\n* [Get Connection State Changes](#get-connection-state-changes) ## Monitor Sync Progress and Status You may want to know the status of Sync operations in your app. For example, you might want specific code to run only after all of the data is synced with App Services. You might also want to provide users with the status of Sync operations. You can set up your Sync session to wait for changes to be uploaded or downloaded. You can also configure your Sync session to notify when the Sync connection status changes. ### Wait for Changes to be Uploaded or Downloaded To asynchronously wait for your changes to be completed, get the sync session from the [Realms.Sync.SyncSession](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FSyncSession)property, and then call the [session.WaitForUploadAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Session.html#Realms%5FSync%5FSession%5FWaitForUploadAsync) or[session.WaitForDownloadAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Session.html#Realms%5FSync%5FSession%5FWaitForDownloadAsync)methods. For example: `| using Realms.Sync;                              |\n| ----------------------------------------------- |\n| var realm = Realm.GetInstance(config);          |\n| await realm.SyncSession.WaitForDownloadAsync(); | ` ### Monitor Sync Progress ## Note Flexible Sync progress notifications are not yet fully supported. When using Flexible Sync, downloads only report notifications after changes are integrated. Partition-Based Sync provides ongoing notifications as changes progress downloading. Uploads report ongoing progress notifications for both Sync Modes. To monitor Sync progress, get the sync session from the [Realms.Sync.SyncSession](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FSyncSession) property, then add a progress notification by calling the[session.GetProgressObservable()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Session.html#Realms%5FSync%5FSession%5FGetProgressObservable%5FRealms%5FSync%5FProgressDirection%5FRealms%5FSync%5FProgressMode%5F)method. The `session.GetProgressObservable` method takes in the following two parameters: * A [ProgressDirection](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ProgressDirection.html)parameter that can be set to `Upload` or `Download`.\n* A [ProgressMode](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.ProgressMode.html) parameter that can be set to `ReportIndefinitely`for the notifications to continue until the callback is unregistered, or`ForCurrentlyOutstandingWork` for the notifications to continue until only the currently transferable bytes are synced.\n\n ## Note The number of transferred and transferable bytes are only estimates. The Sync changesets are compressed with[gzip](https://www.gnu.org/software/gzip/) before transmitting, so the actual size of transmitted bytes will be smaller than the reported number of both transferable and transferred bytes. ## Example In the following example, we subscribe to a progress observable on the `session` to listen for upload events indefinitely. When this callback is triggered, it prints the number of transferred bytes and the number of transferable bytes to the console. ```csharp var session = realm.SyncSession; var token = session.GetProgressObservable(ProgressDirection.Upload,     ProgressMode.ReportIndefinitely)     .Subscribe(progress =>        {            Console.WriteLine($@\"transferred bytes:                 {progress.TransferredBytes}\");            Console.WriteLine($@\"transferable bytes:                 {progress.TransferableBytes}\");        }); \n``` Once you no longer wish to receive notifications, unregister the token by using`token.Dispose()` ## Note The SDK optimizes download speeds by combining multiple changesets into a single download message, up to 16 MB. Since the progress callback is only invoked once before and after a download message is processed, this means that you'll likely see `transferredBytes` change in increments of roughly 16 MB rather than continuously as the message is being downloaded. ## Get Connection State Changes To get the connection state of a [SyncSession](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FSyncSession), set an event handler on the [PropertyChanged](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Session.html#Realms%5FSync%5FSession%5FPropertyChanged)event. The event handler is a standard[.NET PropertyChangedEventHandler delegate](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.propertychangedeventhandler?view=net-6.0)that takes in a `sender` object and[PropertyChangedEventArgs](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.propertychangedeventargs?view=net-6.0)object. In the event handler, cast the sender to a `Session` object and check if the event argument's `PropertyName` property is `Session.ConnectionState`. You can then get the[ConnectionState](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.Session.html#Realms%5FSync%5FSession%5FConnectionState)value, which will be one of the following: * Connecting\n* Connected\n* Disconnected The following code demonstrates setting the event handler, casting the session object, and checking the Sync status: ```csharp public void SetupRealm() {     var appConfig = new AppConfiguration(myRealmAppId);     app = App.Create(appConfig);     user = app.LogInAsync(Credentials.Anonymous()).Result;     config = new PartitionSyncConfiguration(\"myPartition\", user);     try     {         var realm = Realm.GetInstance(config);         var session = realm.SyncSession;         session.PropertyChanged += SyncSessionPropertyChanged;         realm.Dispose();     }     catch (Exception ex)     {         Console.WriteLine(ex.Message);     } } private void SyncSessionPropertyChanged(object sender, PropertyChangedEventArgs e) {     if (e.PropertyName == nameof(Session.ConnectionState))     {         var session = (Session)sender;         var currentState = session.ConnectionState;         if (currentState == ConnectionState.Connecting)         {\n\n         }         if (currentState == ConnectionState.Connected)         {             //session is connected         }         if (currentState == ConnectionState.Disconnected)         {             //session has been disconnected         }     } } \n``` ← [Suspend or Resume a Sync Session - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/sync-session/ \"Previous Section\")[Convert Between Non-Synced Realms and Synced Realms - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/convert-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/sync/configure-and-open-a-synced-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Configure & Open a Synced Realm - .NET SDK On this page * [Key Concept: Synced Realms](#key-concept--synced-realms)\n* [Synced Realms vs. Non-Synced Realms](#synced-realms-vs.-non-synced-realms)\n* [Convert Between Synced and Non-Synced Realms](#convert-between-synced-and-non-synced-realms)\n* [Synced Realms](#synced-realms)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Open a Synced Realm with a Flexible Sync Configuration](#open-a-synced-realm-with-a-flexible-sync-configuration)\n* [Open a Partition-Based Sync Realm While Online](#open-a-partition-based-sync-realm-while-online)\n* [Open a Partition-Based Sync Realm While Offline](#open-a-partition-based-sync-realm-while-offline)\n* [Scoping the Realm](#scoping-the-realm)\n* [Class Subsets](#class-subsets) ## Key Concept: Synced Realms You can configure a realm to automatically synchronize data between many devices that each have their own local copy of the data. Synced realms use a different configuration than local-only realms and require an Atlas App Services backend to handle the synchronization process. Applications can always create, modify, and delete synced realm objects locally, even when offline. Whenever a network connection is available, the Realm SDK opens a connection to an application server and syncs changes to and from other clients. The [Atlas Device Sync protocol](https://www.mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-sync-protocol) and server-side operational transforms guarantee that all fully synced instances of a realm see exactly the same data, even if some changes occurred offline and/or were received out of order. ## Tip ### Learn How to Configure and Use Sync For more information on Device Sync, including directions on how to set up sync in an App Services app, see [Sync Data Between Devices - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/sync/#std-label-dotnet-realm-sync) ### Synced Realms vs. Non-Synced Realms Synced realms differ from non-synced local Realm Database in a couple of ways: * Synced realms attempt to sync changes with your backend App Services App, whereas non-synced realms do not.\n* Synced realms can be accessed by authenticated users, while non-synced realms have no concept of users or authentication. You can copy data from a non-synced Realm Database to a synced realm, and vice versa, but you cannot sync a non-synced Realm Database. ### Convert Between Synced and Non-Synced Realms Realm does not have a direct mechanism to add sync to a non-synced realm, or to permanently stop Sync for a synced realm. However, the .NET SDK does provide methods that enable you to copy a realm file for use with a different configuration. With these methods, you can easily duplicate a realm's data, which you can then open with a sync or non-sync configuration. This lets you indirectly add Sync to a non-synced realm, or permanently stop a realm from syncing. For more information, refer to [Convert Between Non-Synced Realms and Synced Realms - .NET SDK.](https://mongodb.com/docs/realm/sdk/dotnet/sync/convert-realm/#std-label-dotnet-convert-to-sync) ### Synced Realms To open a synced realm, you must have an authenticated[User](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html) object. To obtain an initial `User` instance, you need to authenticate against the Atlas App Services backend, which requires the device to be online the first time a user logs in. Once initial authentication has occurred, you can[retrieve an existing user](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-retrieve-current-user) while offline. ## Note\n\n ## Open a Synced Realm The typical flow for opening a synced realm involves: 1. [Authenticating the user.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate)\n2. Creating a sync configuration.\n3. Opening the user's synced realm with the configuration. At authentication, we cache user credentials in a `sync_metadata.realm`file on device. When you open a synced realm after authenticating, you can bypass the login flow and go directly to opening the synced realm, using the same sync configuration you already created. With cached credentials, you can: * Open a synced realm immediately with the data that is on the device. You can use this method offline or online.\n* Open a synced realm after downloading changes from your App. This requires the user to have an active internet connection. ### Open a Synced Realm with a Flexible Sync Configuration When you use Flexible Sync, pass the current user to a[FlexibleSyncConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.FlexibleSyncConfiguration.html)object to open a synced realm. `| var config = new FlexibleSyncConfiguration(app.CurrentUser); |\n| ------------------------------------------------------------ |\n| var realm = Realm.GetInstance(config);                       | ` ## Important ### Flexible Sync Requires a Subscription You can't use a Flexible Sync realm until you add at least one subscription. To learn how to add subscriptions, see: [Add a Query to the Set Of Subscriptions.](https://mongodb.com/docs/realm/sdk/dotnet/sync/flexible-sync/#std-label-dotnet-sync-add-subscription) ### Open a Partition-Based Sync Realm While Online The steps for opening a synced realm while online are: 1. Your app code walks the user through [authenticating.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate)\n2. Create a[PartitionSyncConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.PartitionSyncConfiguration.html)object that includes the [partition name](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-value) and the [User](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html) object.\n3. Open a synced realm by calling the[GetInstanceAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FGetInstanceAsync%5FRealms%5FRealmConfigurationBase%5FSystem%5FThreading%5FCancellationToken%5F)method, passing in the `PartitionSyncConfiguration` object. The following code demonstrates these steps: ```csharp user = await app.LogInAsync(     Credentials.EmailPassword(\"foo@foo.com\", \"foobar\")); config = new PartitionSyncConfiguration(\"myPart\", user); try {     realm = await Realm.GetInstanceAsync(config); } catch (RealmFileAccessErrorException ex) {     Console.WriteLine($@\"Error creating or opening the         realm file. {ex.Message}\"); } \n``` In the above example, the code shows how to open the realm _asynchronously_by calling `GetInstanceAsync()`. You can also open a realm _synchronously_by calling the[GetInstance()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FGetInstance%5FSystem%5FString%5F)method: ```csharp var synchronousRealm = await Realm.GetInstanceAsync(config); \n``` ## Tip ### See also: \n\n [Partition Strategies](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-strategies) ### Open a Partition-Based Sync Realm While Offline Once a user authenticates, the `User` object persists on the device until the user logs off. This allows your app to[retrieve an existing user](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-retrieve-current-user) and open a synced realm in an offline state. Changes that occur while offline will be synced by the SDK once the device reconnects to your App. The following code shows how to check if there is an existing `User` object. If none is found, it uses the process outlined about to obtain a user. If the device already has a `user`, it opens the synced realm with that user: ```csharp if (app.CurrentUser == null) {     // App must be online for user to authenticate     user = await app.LogInAsync(         Credentials.EmailPassword(\"caleb@mongodb.com\", \"shhhItsASektrit!\"));     config = new PartitionSyncConfiguration(\"_part\", user);     realm = await Realm.GetInstanceAsync(config); } else {     // This works whether online or offline     user = app.CurrentUser;     config = new PartitionSyncConfiguration(\"_part\", user);     realm = Realm.GetInstance(config); } \n``` ## Scoping the Realm The realm instance implements `IDisposable` to ensure native resources are freed up. You should dispose of a realm object immediately after use, especially on background threads. The simplest way to do this is by declaring the realm object with a `using` statement, or wrapping the code that interacts with a realm in a `using (...)` statement: ```csharp config = new PartitionSyncConfiguration(\"myPart\", user); using (var realm = Realm.GetInstance(config)) {     var allItems = realm.All<Item>(); } \n``` If you require a realm object to be shared outside of a single method, be sure to manage its state by calling the[Dispose()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FDispose) method: ```csharp realm.Dispose(); \n``` ## Note As a general rule, you should dispose of the realm only on background threads, because disposing of a realm invalidates all objects associated with that instance. If you are data binding the realm objects on the main thread, for example, you should not call `Dispose()`. ## Class Subsets By default, all `RealmObject` classes are stored in a realm. In some scenarios, you may want to limit the classes that get stored, which you can do with the[Schema](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfigurationBase.html#Realms%5FRealmConfigurationBase%5FSchema)property of the `RealmConfiguration` object. The following code demonstrates how you specify two classes you want stored in the realm: ```csharp var config = new RealmConfiguration() {     Schema = new Type[]     {         typeof(AClassWorthStoring),         typeof(AnotherClassWorthStoring)     } }; \n``` ← [Add Device Sync to an App - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/add-sync-to-app/ \"Previous Section\")[Manage Flexible Sync Subscriptions- .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/sync/flexible-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/manual-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manually Define a Schema - .NET SDK On this page * [Use the Schema Property](#use-the-schema-property) When Realm processes Realm objects, it generates a schema for each class based on the class properties. However, there may be times that you want to manually define the schema, and the .NET SDK provides a mechanism for doing so. ## Important ### Inheritance All Realm objects inherit from the[IRealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IRealmObject.html),[IEmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IEmbeddedObject.html), or[IAsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IAsymmetricObject.html)interface and should be declared `partial` classes. You can also derive from the[RealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmObject.html),[EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.EmbeddedObject.html), or[AsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.AsymmetricObject.html)base classes. However, in the future we may deprecate the base classes. You should use the interfaces for any new classes that you write. ## Use the Schema Property You use the[Schema](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfigurationBase.html#Realms%5FRealmConfigurationBase%5FSchema)property of the[RealmConfigurationBase](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfigurationBase.html)object to control how schemas are defined. The following code example shows three ways to do this, from easiest to most complex: automatic configuration, manual configuration, and a mix of both methods.\n\n  `` ← [Embedded Objects - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/embedded-objects/ \"Previous Section\")[Relationships - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-binding/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Data Binding - .NET SDK On this page * [Data Binding Examples](#data-binding-examples)\n* [Binding to a Single Realm Object](#binding-to-a-single-realm-object)\n* [Binding to a Realm Collection](#binding-to-a-realm-collection) In Xamarin and MAUI applications, data binding enables UI updates when an underlying object or collection changes, and vice versa. Realm objects and collections are [live](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/#std-label-dotnet-live-object) and update automatically to reflect data changes. This is because Realm objects implement[INotifyPropertyChanged](https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged)and Realm collections implement[INotifyCollectionChanged](https://docs.microsoft.com/en-us/dotnet/api/system.collections.specialized.inotifycollectionchanged). When you bind live collections and objects to your UI, both the UI and live objects and collections update at the same time. ## Note ### Compiled Bindings The Realm SDK does not support [Compiled Bindings.](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/app-fundamentals/data-binding/compiled-bindings) ## Data Binding Examples The following code snippets show both the C# and XAML for three typical data-binding use cases. They all use the following Realm objects:\n\n ` ## Note ### Avoid Using ToList() Because Realm collections are live, you should not call `ToList()` when obtaining a collection of Realm objects. Doing so forces loading the collection from memory, so the resulting collection is no longer a live object. ### Binding to a Single Realm Object In the following example, we create a public property of type `Employee`. Elsewhere in our class, we query our realm for the `Employee` with an \"EmployeeId\" of \"123\": ```csharp public Employee Employee123 { get; } ... Employee123 = realm.All<Employee>()     .FirstOrDefault(e => e.EmployeeId == \"123\"); \n``` In our XAML, we bind the Employee's `Name` property to a `Label` control's`Text` property: ``` <Label Text=\"{Binding Employee123.Name}\"/> \n``` ### Binding to a Realm Collection There are two types of collections we can bind to. First, we can bind to a collection of Realm objects. In this code example, we create a public`IEnumerable` of the `Employee` Realm object and then populate that collection with all of the objects in the Employees collection: ```csharp public IEnumerable<Employee> Employees { get; } ... Employees = realm.All<Employee>(); \n``` In the associated XAML file, we bind a `ListView` to the Employees`IEnumerable` to show a list of all Employees. In this case, we're listing each employee's \"EmployeeId\" value: ``` <ListView x:Name=\"listAllEmployees\" ItemsSource=\"{Binding Employees}\">    <ListView.ItemTemplate>           <DataTemplate>               <ViewCell>                 <Label Text=\"{Binding EmployeeId}\"/>             </ViewCell>         </DataTemplate>     </ListView.ItemTemplate> </ListView> \n``` We can also bind to a _collection property_ of a Realm object. In this example, we bind to the `Items` property of a specific `Employee`. The `Items`property on the `Employee` class is of type `IList<Item>`. ```csharp public Employee Employee123 { get; } ... IncompleteItems = Employee123.Items     .AsRealmQueryable()     .Where(i => i.IsComplete == false); \n``` ## Note Note that we are calling the [AsRealmQueryable()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.CollectionExtensions.html#Realms%5FCollectionExtensions%5FAsRealmQueryable%5F%5F1%5FSystem%5FCollections%5FGeneric%5FIList%5F%5F%5F0%5F%5F)method. This is required because we are filtering the collection. If we want to list all of the Items in the `Items` collection, we do not need to call`AsRealmQueryable()`. The XAML implementation is similar to the example above: ``` <ListView x:Name=\"listIncompleteItems\" ItemsSource=\"{Binding IncompleteItems}\">    <ListView.ItemTemplate>           <DataTemplate>               <ViewCell>                 <Label Text=\"{Binding Summary}\"/>             </ViewCell>         </DataTemplate>     </ListView.ItemTemplate> </ListView> \n``` ← [Change an Object Model - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/change-an-object-model/ \"Previous Section\")[CRUD - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Data Types - .NET SDK * [Field Types](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/field-types/)\n* [Collections](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/)\n* [Dictionaries](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/dictionaries/)\n* [Sets](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/sets/)\n* [RealmValue](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-value/)\n* [RealmInteger](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-integer/)\n* [Embedded Objects](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/embedded-objects/) ← [Object Models & Schemas - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/ \"Previous Section\")[Field Types - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/field-types/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Object Models & Schemas - .NET SDK On this page * [Object Types & Schemas](#object-types---schemas)\n* [Schemas](#schemas)\n* [Working with Realm Objects](#working-with-realm-objects) ## Object Types & Schemas Realm applications model data as objects composed of property-value pairs that each contain one or more primitive data types or other Realm objects. Realm objects are essentially the same as regular objects, but they inherit from[RealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmObject.html) or[EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.EmbeddedObject.html) and include additional features like[real-time updating data views](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/#std-label-dotnet-live-object) and reactive[change event handlers.](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-client-notifications) Every Realm object has an _object type_ that refers to the object's class. Objects of the same type share an [object schema](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-object-schema) that defines the properties and relationships of those objects. ### Schemas In C#, you typically define object schemas by using the C# class declarations. When Realm is initialized, it discovers the Realm objects defined in all assemblies that have been loaded and generates schemas accordingly. This is the simplest approach to defining a schema, and is generally the least error-prone. However, this approach includes all loaded Realm objects, and there may be cases where you only want to use [a subset of classes](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-omit-classes-from-schema), or to customize Realm object schemas. To do this, you can[programmatically define a schema.](https://mongodb.com/docs/realm/sdk/dotnet/model-data/manual-schema/#std-label-dotnet-manual-schema) ## Note .NET does not load an assembly until you reference a class in it, so if you define your object models in one assembly and instantiate Realm in another, be sure to call a method in the assembly that contains the object models _before_ initialization. Otherwise, Realm will not discover the objects when it first loads. ## Working with Realm Objects The following code block shows an object schema that describes a Dog. Every Dog object must include a `Name` and may optionally include the dog's `Age`, `Breed` and a list of people that represents the dog's `Owners`.\n\n ` ## Note To define a collection of objects within an object, use an `IList<T>` with only a getter. You do not need to initialize it in the constructor, as realm will generate a collection instance the first time the property is accessed. ## Note ### Further Examples The [CRUD - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/#std-label-dotnet-crud) section provides examples of creating, reading, updating, filtering, and deleting Realm objects. ← [Object Models - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/ \"Previous Section\")[Realm Data Types - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Relationships - .NET SDK On this page * [Define a Relationship Property](#define-a-relationship-property)\n* [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationship](#inverse-relationship)\n* [Summary](#summary) Realm allows you to define explicit relationships between the types of objects in an App. A relationship is an object property that references another Realm object rather than one of the primitive data types. You define relationships by setting the property type to another Realm class. ## Important ### Inheritance All Realm objects inherit from the[IRealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IRealmObject.html),[IEmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IEmbeddedObject.html), or[IAsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IAsymmetricObject.html)interface and should be declared `partial` classes. You can also derive from the[RealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmObject.html),[EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.EmbeddedObject.html), or[AsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.AsymmetricObject.html)base classes. However, in the future we may deprecate the base classes. You should use the interfaces for any new classes that you write. Relationships are direct references to other objects in a realm, which means that you don't need bridge tables or explicit joins to define a relationship like you would in a relational database. Instead, you can access related objects by reading and writing to the property that defines the relationship. Realm Database executes read operations lazily as they come in, so querying a relationship is just as performant as reading a regular property. ## Define a Relationship Property ## Tip ### See also:  With Device Sync, you can also [define your relationships](https://www.mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-define-a-relationship) in the App Services UI. ## Tip ### See also:  [Fundamentals: Relationships](#std-label-dotnet-client-relationships) There are three primary types of relationships between objects: * [To-One Relationship](#std-label-dotnet-to-one-relationship)\n* [To-Many Relationship](#std-label-dotnet-to-many-relationship)\n* [Inverse Relationship](#std-label-dotnet-inverse-relationship) ### To-One Relationship A **to-one** relationship means that an object is related in a specific way to no more than one other object. You define a to-one relationship for an object type in its [object schema](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-object-schema) by specifying a property where the type is the related Realm object type. ## Example An application could use the following object schemas to indicate that a Person may or may not own a single Dog by including it in its`dog` property:\n\n ` To query a direct relationship, you can use LINQ syntax. See the following example for how to query a one-to-one relationship: ```csharp var fidosPerson = realm.All<Person>().FirstOrDefault(p => p.Dog == dog); \n``` ### To-Many Relationship A **to-many** relationship means that an object is related in a specific way to multiple objects. You define a to-many relationship for an object type in its [object schema](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-object-schema) by specifying a property where the type is an `IList<T>` of the related Realm object type. ## Example An application could use the following object schemas to indicate that a Person may own multiple Dogs by including them in its `dog`property: ```csharp public class Person : RealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; }     public string Name { get; set; }     public DateTimeOffset Birthdate { get; set; }     public IList<Dog> Dogs { get; } } public class Dog : RealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; }     public string Name { get; set; }     public int Age { get; set; }     public string Breed { get; set; } } \n``` ## Note To define a collection of objects within an object, use an `IList<T>` with only a getter. You do not need to initialize it in the constructor, as realm will generate a collection instance the first time the property is accessed. ```csharp // To add items to the IList<T>: var person = new Person(); person.Dogs.Add(new Dog {     Name = \"Caleb\",     Age = 7,     Breed = \"mutt\" }); \n``` See the following example for how to query a one-to-many relationship: ```csharp var youngDogs = realm.All<Dog>().Where(d => d.Age == 1).OrderBy(dog => dog.Name).ToList(); \n``` ### Inverse Relationship An **inverse relationship** links an object back to any other objects that refer to it in a defined to-one or to-many relationship. Relationship definitions are unidirectional, so you must explicitly define a property in the object's model as an inverse relationship. For example, the to-many relationship \"a User has many Tasks\" does not automatically create the inverse relationship \"a Task belongs to one User\". If you don't specify the inverse relationship in the object model, you need to run a separate query to look up the user that is assigned to a given task. To define the inverse relationship, define a getter-only `IQueryable<T>` property in your object model, where `T` is the source type of the relationship, and then annotate this property with a[\\[Backlink(sourceProperty)\\]](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.BacklinkAttribute.html)attribute, where \"sourceProperty\" is the name of the property on the other side of the relationship. The following example shows how to do this with the \"User has many Tasks\" scenario: ```csharp public class User : RealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; } = ObjectId.GenerateNewId();     public string Name { get; set; }     [Backlink(nameof(Item.Assignee))]     public IQueryable<Item> Items { get; } } public class Item : RealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; } = ObjectId.GenerateNewId();     public string Text { get; set; }     public User Assignee { get; set; } } \n``` In this example, note that:\n\n This, then, allows us to query the Task collection to get all Tasks assigned to a specific User. To query the inverse relationship, you cannot use Linq. Instead, pass a string predicate. The following example shows how you could find all Users who have Tasks that contain the word \"oscillator\": ```csharp var oscillatorAssignees = realm.All<User>()     .Filter(\"Items.Text CONTAINS 'oscillator'\").ToList(); foreach (User u in oscillatorAssignees) {     Console.WriteLine(u.Name); } \n``` ## Summary * A **relationship** is an object property that allows an object to reference other objects of the same or another object type.\n* Relationships are direct references. You can access related objects directly through a relationship property without writing any type of join.\n* Realm Database supports to-one, to-many, and inverse relationships. ← [Manually Define a Schema - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/manual-schema/ \"Previous Section\")[Change an Object Model - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/change-an-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Collections - .NET SDK On this page * [Overview](#overview)\n* [Lists](#lists)\n* [Querying Lists](#querying-lists)\n* [Results Collections](#results-collections)\n* [Results are Lazily Evaluated](#results-are-lazily-evaluated)\n* [Working wth Collections](#working-wth-collections)\n* [Collections are Live](#collections-are-live)\n* [Limiting Query Results](#limiting-query-results)\n* [Pagination](#pagination)\n* [Summary](#summary) ## Overview One of the fundamental building blocks when working with any database is the **collection**. A Realm collection implements[IList<T>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ilist-1?view=net-5.0), and contains zero or more instances of a[Realm type](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects). Like a C# `List`, a Realm collection is homogenous (all objects in a collection are of the same type.) You can filter and sort any collection using Realm Database's[query engine](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/#std-label-dotnet-client-query-engine). Collections are[live](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/#std-label-dotnet-live-object), so they always reflect the current state of the realm instance on the current thread. You can also listen for changes in the collection by subscribing to [collection notifications.](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-collection-notifications) Realm Database has two kinds of collections: **Lists** and **Results**. ## Lists Realm objects can contain lists of any supported data type. You create a collection by defining a getter-only property of type[IList<T>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ilist-1?view=net-5.0), where `T` can be any data type (except other collections). Deleting an object from the database will remove it from any lists where it existed. Therefore, a list of objects will never contain null objects. However, lists of primitive types can contain null values. If you do not want to allow null values in a list, then either use non-nullable types in the list declaration (for example, use `IList<double>` instead of`IList<double?>`), or add the[\\[Required\\]](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-required-optional-property) attribute if the list contains nullable reference types, such as `string` or `byte[]`. ## Important ### Not Supported with Sync Local-only Realm Databases support collections of nullable (optional) values, but `Sync` does not. A **list** collection represents a [to-many relationship](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/#std-label-dotnet-to-many-relationship) between two Realm types. Lists are mutable: within a write transaction, you can add and remove elements on a list. ### Querying Lists\n\n ` ## Results Collections A **results** collection represents the lazily-evaluated results of a query operation. Unlike a List, results are immutable: you cannot add or remove elements on the results collection. This is because the contents of a results collection are determined by a query against the database. ### Results are Lazily Evaluated Realm Database only runs a query when you actually request the results of that query, e.g. by accessing elements of the results collection. This lazy evaluation enables you to write elegant, highly performant code for handling large data sets and complex queries. ## Working wth Collections ### Collections are Live Like [live objects](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/#std-label-dotnet-live-object), Realm collections are _usually_ live: * Live **results collections** always reflect the current results of the associated query.\n* Live **lists** always reflect the current state of the relationship on the realm instance. There are two cases, however, when a collection is **not** live: * The collection is unmanaged: a List property of a Realm object that has not been added to a realm yet or that has been copied from a realm.\n* The collection is [frozen.](https://mongodb.com/docs/realm/sdk/dotnet/crud/threading/#std-label-dotnet-frozen-objects) Combined with [collection notifications](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-collection-notifications), live collections enable clean, reactive code. For example, suppose your view displays the results of a query. You can keep a reference to the results collection in your view class, then read the results collection as needed without having to refresh it or validate that it is up-to-date. ## Important ### Indexes may change Since results update themselves automatically, do not store the positional index of an object in the collection or the count of objects in a collection. The stored index or count value could be outdated by the time you use it. ### Limiting Query Results As a result of lazy evaluation, you do not need any special mechanism to limit query results with Realm Database. For example, if your query matches thousands of objects, but you only want to load the first ten, simply access only the first ten elements of the results collection. ### Pagination Thanks to lazy evaluation, the common task of pagination becomes quite simple. For example, suppose you have a results collection associated with a query that matches thousands of objects in your realm. You display one hundred objects per page. To advance to any page, simply access the elements of the results collection starting at the index that corresponds to the target page. ## Summary * A Realm **collection** is a homogenous container of zero or more instances of one[Realm type.](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects)\n* Collections are [live](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/#std-label-dotnet-live-object) and therefore are auto-updating, unless you have [frozen](https://mongodb.com/docs/realm/sdk/dotnet/crud/threading/#std-label-dotnet-frozen-objects) them or they are not part of a realm.\n* Lazy evaluation of results collections means there is no need to design a special query to get limited or paginated results. Perform the query and read from the results collection as needed.\n* There are two main kinds of collection: **lists** and **results**. Lists define the [to-many relationships](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/#std-label-dotnet-to-many-relationship)of your Realm types, while results represent the lazily-loaded output of a [read operation.](https://mongodb.com/docs/realm/sdk/dotnet/crud/read/#std-label-dotnet-realm-database-reads) ← [Field Types - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/field-types/ \"Previous Section\")[Dictionaries - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/dictionaries/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/change-an-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Change an Object Model - .NET SDK On this page * [Overview](#overview)\n* [Schema Version](#schema-version)\n* [Migrate a Schema](#migrate-a-schema)\n* [Add a Property](#add-a-property)\n* [Delete a Property](#delete-a-property)\n* [Modify a Property Type or Rename a Property](#modify-a-property-type-or-rename-a-property)\n* [Migration Functions](#migration-functions) ## Overview A **migration** transforms an existing realm and its objects from its current [Realm Schema version](#std-label-dotnet-schema-version) to a newer one. Application data models typically change over time to accommodate new requirements and features. Migrations give you the flexibility to automatically update your existing application data whenever a client application upgrades to a newer version. Consider the following example, in which we have a `RealmObject`called \"Person\": `| public partial class Person : IRealmObject |\n| ------------------------------------------ |\n| {                                          |\n| [PrimaryKey]                               |\n| [MapTo(\"_id\")]                             |\n| public ObjectId Id { get; set; }           |\n| public string FullName { get; set; }       |\n| public int Age { get; set; }               |\n| }                                          | ` Suppose we now want to split up the `FullName` property into two separate properties, `FirstName` and `LastName`: ```csharp public partial class Person : IRealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; }     public string FirstName { get; set; }     public string LastName { get; set; }     public int Age { get; set; } } \n``` At this point, there is a mismatch between the model and any saved data, and an exception will be thrown when you try to open the realm. ## Schema Version The **schema version** identifies the state of a [Realm Schema](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-realm-schema) at some point in time. Realm Database tracks the schema version of each realm and uses it to map the objects in each realm to the correct schema. Schema versions are integers that you may include in the realm configuration when you open a realm. If a client application does not specify a version number when it opens a realm then the realm defaults to version `0`. ## Important ### Increment Versions Monotonically Migrations must update a realm to a higher schema version. Realm Database will throw an error if a client application opens a realm with a schema version that is lower than the realm's current version or if the specified schema version is the same as the realm's current version but includes different[object schemas.](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-object-schema) ## Migrate a Schema The following examples demonstrate how to add, delete, and modify properties in a schema. First, make the required schema change. Then, create a corresponding [migration function](#std-label-dotnet-migration-function) to move data from the original schema to the updated schema. ## Note ### Modify Schema Properties of a Synced Realm\n\n ## Note ### Versions Update on Realm Open Assume that each schema change in this example occurs after an application has used each version for some amount of time. New schema version numbers only apply once you open the realm with an updated schema and explicitly specify the new version number, so in order to get to version 3, you would first need to open the app with versions 1 and 2. A realm using schema version `1` has a `Person` object type: ```csharp public partial class Person : IRealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; }     public string FirstName { get; set; }     public int Age { get; set; } } \n``` ## Add a Property The following example adds a `LastName` property to the[original Person schema:](#std-label-dotnet-og-schema) ```csharp public partial class Person : IRealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; }     public string FirstName { get; set; }     public string LastName { get; set; }     public int Age { get; set; } } \n``` ## Delete a Property The following example uses a combined`FullName` property instead of the separate `FirstName` and`LastName` property in the [original Person schema:](#std-label-dotnet-og-schema) ```csharp public partial class Person : IRealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; }     public string FullName { get; set; }     public int Age { get; set; } } \n``` ## Modify a Property Type or Rename a Property The following example modifies the `Age` property in the[original Person schema](#std-label-dotnet-og-schema) by renaming it to `Birthday` and changing the type to `DateTimeOffset`: ```csharp public partial class Person : IRealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public ObjectId Id { get; set; }     public string FullName { get; set; }     public DateTimeOffset Birthday { get; set; } } \n``` ## Migration Functions ## Tip ### Bypass Migration During Development When developing or debugging your application, you may prefer to delete the realm instead of migrating it. Use the[ShouldDeleteIfMigrationNeeded](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmConfiguration.html#Realms%5FRealmConfiguration%5FShouldDeleteIfMigrationNeeded)flag to delete the database automatically when a schema mismatch would require a migration. Never release an app to production with this flag set to `true`. To migrate the realm to conform to the updated `Person` schema, set the realm's [schema version](#std-label-dotnet-schema-version) to`4` and define a migration function to set the value of`FullName` based on the existing `FirstName` and `LastName`properties and the value of `Birthday` based on `Age`: ```csharp 1 var config = new RealmConfiguration 2 { 3     SchemaVersion = 4, 4     MigrationCallback = (migration, oldSchemaVersion) => 5     { 6         var oldPeople = migration.OldRealm.DynamicApi.All(\"Person\"); 7         var newPeople = migration.NewRealm.All<Person>(); 8 9         // Migrate Person objects 10         for (var i = 0; i < newPeople.Count(); i++) 11         { 12             var oldPerson = oldPeople.ElementAt(i); 13             var newPerson = newPeople.ElementAt(i); 14 15             // Changes from version 1 to 2 (adding LastName) will occur automatically when Realm detects the change 16 17\n\n 18             // LastName doesn't exist in version 1 19             if (oldSchemaVersion < 2) 20             { 21                 newPerson.FullName = oldPerson.FirstName; 22             } 23             else if (oldSchemaVersion < 3) 24             { 25                 newPerson.FullName = $\"{oldPerson.FirstName} {oldPerson.LastName}\"; 26             } 27 28             // Migrate Person from version 3 to 4: replace Age with Birthday 29             if (oldSchemaVersion < 4) 30             { 31                 var birthYear = DateTimeOffset.UtcNow.Year - oldPerson.Age; 32                 newPerson.Birthday = new DateTimeOffset(birthYear, 1, 1, 0, 0, 0, TimeSpan.Zero); 33             } 34         } 35     } 36 }; 37 var realm = Realm.GetInstance(config); \n``` ## Note ### Unity does not support the dynamic keyword when using IL2CPP Unity has various [scripting restrictions](https://docs.unity3d.com/Manual/ScriptingRestrictions.html) and does not support the [dynamic keyword](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/using-type-dynamic)when using [IL2CPP](https://docs.unity3d.com/Manual/IL2CPP.html). Instead you can cast the Dynamic value to the type you want to use. In the following example, the retrieved `Person` objects are explicitly converted to an `IQueryable<RealmObject>`. ```csharp var people = (IQueryable<RealmObject>)migration.OldRealm.DynamicApi.All(\"Person\"); // store results of retrieved Person objects \n``` ← [Relationships - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/ \"Previous Section\")[Data Binding - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-binding/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-integer/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # RealmInteger - .NET SDK On this page * [Overview](#overview)\n* [Implementing a Counter](#implementing-a-counter) ## Overview Realm offers[RealmInteger](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmInteger-1.html) as a special integer type you can use as a logical counter. `RealmInteger<T>`exposes an additional API that can more clearly express intent and generate better conflict resolution steps when using Synchronized Realms. The type argument `<T>` can be of type `byte`, `short`, `int`, or `long`. The following example shows how to use a `RealmInteger` property that maps to an `int`: `| public partial class MyRealmClass : IRealmObject |\n| ------------------------------------------------ |\n| {                                                |\n| [PrimaryKey]                                     |\n| public int _id { get; set; }                     |\n| public RealmInteger<int> Counter { get; set; }   |\n| }                                                | ` ## Implementing a Counter Traditionally, you would implement a counter by reading a value, incrementing it, and then setting it (`myObject.Counter += 1`). This does not work well in an asynchronous situation like when two clients are offline. Consider the following scenario: * The realm object has a `counter` property of type `int`. It is currently set to a value of `10`.\n* Clients 1 and 2 both read the `counter` property (`10`) and each increments the value by `1`.\n* When each client regains connectivity and merges their changes, they expect a value of 11, and there is no conflict. However, the counter value should be`12`! When using a `RealmInteger`, however, you can call the `Increment()` and`Decrement()` methods, and to reset the counter, you set it to `0`, just as you would an `int`: ```csharp var myObject = realm.Find<MyRealmClass>(id); // myObject.Counter == 0 realm.Write(() => {     // Increment the value of the RealmInteger     myObject.Counter.Increment(); // 1     myObject.Counter.Increment(5); // 6     // Decrement the value of the RealmInteger     // Note the use of Increment with a negative number     myObject.Counter.Decrement(); // 5     myObject.Counter.Increment(-3); // 2     // Reset the RealmInteger     myObject.Counter = 0;     // RealmInteger<T> is implicitly convertable to T:     int bar = myObject.Counter; }); \n``` ## Important When you reset a `RealmInteger`, you may run into the offline merge issue described above. A `RealmInteger` is backed by traditional `integer` type, so no schema migration is required when changing a property type from `T` to`RealmInteger<T>`. ← [RealmValue - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-value/ \"Previous Section\")[Embedded Objects - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/embedded-objects/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/field-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Field Types - .NET SDK On this page * [Overview](#overview)\n* [.NET Types](#.net-types)\n* [MongoDB.Bson Types](#mongodb.bson-types)\n* [Guid and ObjectId Properties](#guid-and-objectid-properties)\n* [Using Decimal Values](#using-decimal-values)\n* [Realm-Specific Types](#realm-specific-types) ## Overview The .NET SDK supports three categories of data types: * [.NET types](#std-label-dotnet-dotnettypes)\n* [MongoDB.Bson types](#std-label-dotnet-bsontypes)\n* [Realm-Specific types](#std-label-dotnet-realmtypes) ## .NET Types Realm Database supports the following .NET data types and their nullable counterparts: * `bool`\n* `byte`\n* `short`\n* `int`\n* `long`\n* `float`\n* `double`\n* `decimal`\n* `char`\n* `string`\n* `byte[]`\n* `DateTimeOffset` (note: Realm converts `DateTimeOffset` values to UTC before storing in the database and does not store the timezone information. See [Issue #1835](https://github.com//realm/realm-dotnet/issues/1835) for more information.)\n* `Guid`\n* `IList<T>`, where T is any of the supported data types (see [Lists)](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/#std-label-dotnet-property-lists) ## Note The `byte`, `char`, `short`, `int`, and `long` types are all stored as 64 bit integer values within Realm Database. ## MongoDB.Bson Types * `ObjectId`\n* `Decimal128` ### Guid and ObjectId Properties _New in version 10.2.0-beta.1_. `MongoDB.Bson.ObjectId` is a MongoDB-specific 12-byte unique value, while the built-in .NET type `Guid` is a 16-byte universally-unique value. Both types are[indexable](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-index-field), and either can be used as a[Primary Key.](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-primary-key) ### Using Decimal Values Realm supports 128-bit decimal values with the `Decimal128` Bson type. When defining a decimal type, you can use the `Decimal128` Bson type or the .NET`decimal` type, even though it is only a 96-bit decimal. The SDK automatically converts between the two, although you risk losing precision or range. The following example shows how to use both the `Decimal128` Bson type and the .NET`decimal` type:\n\n ` ## Realm-Specific Types Any class that implements `RealmObject` or `EmbeddedObject` can contain a`RealmObject` subclass and/or an [Embedded Objects](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/embedded-objects/#std-label-dotnet-property-embedded)subclass. In addition, Realm Database supports the following custom types: * [Collections](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/)\n* [Dictionaries](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/dictionaries/)\n* [Sets](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/sets/)\n* [RealmInteger](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-integer/)\n* [RealmValue](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-value/) ← [Realm Data Types - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/ \"Previous Section\")[Collections - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/dictionaries/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Dictionaries - .NET SDK On this page * [Overview](#overview)\n* [Dictionary Types](#dictionary-types)\n* [Usage Example](#usage-example)\n* [Data Binding](#data-binding) _New in version 10.2.0_. ## Overview A Realm dictionary is an implementation of[IDictionary](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.idictionary-2?view=net-5.0)that has keys of type `String` and supports values of any[Realm type](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects) except[collections](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/#std-label-dotnet-client-collections). To define a dictionary, use a getter-only `IDictionary<string, TValue>` property, where `TValue` is any of the supported types. ## Dictionary Types A dictionary of objects can contain null objects. Likewise, dictionaries of primitive types can also contain null values. If you do not want to allow null values in a dictionary, then either use non-nullable types in the dictionary declaration (for example, use `IDictionary<string, double>`instead of `IDictionary<string, double?>`), or add the[\\[Required\\]](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-required-optional-property) attribute if the dictionary contains nullable reference types, such as `string` or `byte[]`. ## Important ### Nullable Values Not Supported with Sync Local-only Realm Databases support collections of nullable (optional) values, but `Sync` does not. The following code shows examples of dictionary types:\n\n ` ## Usage Example The following code shows how to create, write to, and read from Dictionaries using either a string query ([RQL](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/#std-label-dotnet-realm-query-language)) or LINQ. ```csharp var storeInventory = new Inventory() {     Id = ObjectId.GenerateNewId().ToString() }; storeInventory.Plants.Add(\"Petunia\", new Plant()); storeInventory.NullableIntDictionary.Add(\"random things\", 7); storeInventory.RequiredStringsDictionary.Add(\"foo\", \"bar\"); var storeInventory2 = new Inventory() {     Id = ObjectId.GenerateNewId().ToString() }; storeInventory2.RequiredStringsDictionary.Add(\"foo\", \"Bar\"); realm.Write(() => {     realm.Add(storeInventory);     realm.Add(storeInventory2); }); // Find all Inventory items that have \"Petunia\" // as a key in their Plants dictionary. var petunias = realm.All<Inventory>()     .Filter(\"Plants.@keys == 'Petunia'\"); // Find all Inventory items that have at least one value in their // IntDictionary that is larger than 5 using RQL var matchesMoreThanFive = realm.All<Inventory>()     .Filter(\"NullableIntDictionary.@values > 5\"); // Find all Inventory items where the RequiredStringsDictionary has a key // \"Foo\", and the value of that key contains the phrase \"bar\" // (case insensitive) var matches = realm.All<Inventory>()     .Filter(\"RequiredStringsDictionary['foo'] CONTAINS[c] 'bar'\"); // matches.Count() == 2 // Query the Plants dictionary of an Inventory object // for a specific plant var myStoreInventory = realm     .All<Inventory>().FirstOrDefault(); var petunia = myStoreInventory.Plants.AsRealmQueryable()     .Where(p => p.Name == \"Petunia\"); \n``` ## Data Binding Like other Realm collections, `IDictionary` implements `INotifyCollectionChanged`, so you can use it in data-binding scenarios (for example, when[watching for changes](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-react-to-changes)). ← [Collections - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/ \"Previous Section\")[Sets - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/sets/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-value/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # RealmValue - .NET SDK On this page * [Overview](#overview) _New in version 10.2.0_. ## Overview The `RealmValue` data type is a mixed data type, and can represent any other valid Realm data type except a collection. You can create collections (lists, sets, and dictionaries) of type `RealmValue`, but a `RealmValue`itself cannot be a collection: `| // CS0029 - Cannot implicitly convert type:        |\n| -------------------------------------------------- |\n| RealmValue myList = new List<Inventory>();         |\n| // These are valid uses of RealmValue:             |\n| var rvList = new List<RealmValue>();               |\n| var rvDict = new Dictionary<string, RealmValue>(); | ` ## Note You cannot create a nullable `RealmValue`. However, if you want a`RealmValue` property to contain a null value, you can use the special `RealmValue.Null` property. The following code demonstrates creating a `RealmValue` property in a class that inherits from `IRealmObject` and then setting and getting the value of that property: ```csharp public partial class MyRealmValueObject : IRealmObject {     [PrimaryKey]     [MapTo(\"_id\")]     public Guid Id { get; set; }     public RealmValue MyValue { get; set; }     // A nullable RealmValue property is *not supported*     // public RealmValue? NullableRealmValueNotAllowed { get; set; }     private void TestRealmValue()     {         var obj = new MyRealmValueObject();         // set the value to null:         obj.MyValue = RealmValue.Null;         // or an int...         obj.MyValue = 1;         // or a string...         obj.MyValue = \"abc\";         // Use RealmValueType to check the type:         if (obj.MyValue.Type == RealmValueType.String)         {             var myString = obj.MyValue.AsString();         }     } \n``` ← [Sets - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/sets/ \"Previous Section\")[RealmInteger - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-integer/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/embedded-objects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Embedded Objects - .NET SDK On this page * [Overview](#overview)\n* [Embedded Object Data Models](#embedded-object-data-models)\n* [Realm Object Models](#realm-object-models)\n* [JSON Schema](#json-schema)\n* [Read and Write Embedded Objects](#read-and-write-embedded-objects)\n* [Create an Embedded Object](#create-an-embedded-object)\n* [Update an Embedded Object Property](#update-an-embedded-object-property)\n* [Overwrite an Embedded Object](#overwrite-an-embedded-object)\n* [Query a Collection on Embedded Object Properties](#query-a-collection-on-embedded-object-properties) ## Overview An embedded object is a special type of [Realm object](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects) that models complex data about a specific object. Embedded objects are similar to [relationships](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/#std-label-dotnet-client-relationships), but they provide additional constraints and map more naturally to the denormalized [MongoDB document model.](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/) Realm enforces unique ownership constraints that treat each embedded object as nested data inside of a single, specific parent object. An embedded object inherits the lifecycle of its parent object and cannot exist as an independent Realm object. Realm automatically deletes embedded objects if their parent object is deleted or when overwritten by a new embedded object instance. ## Note ### Realm Uses Cascading Deletes for Embedded Objects When you delete a Realm object, Realm automatically deletes any embedded objects referenced by that object. Any objects that your application must persist after the deletion of their parent object should use [relationships](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/#std-label-dotnet-client-relationships)instead. ## Embedded Object Data Models You can define embedded object types using either Realm object models or a server-side document schema. Embedded object types are reusable and[composable](https://en.wikipedia.org/wiki/Composability) . You can use the same embedded object type in multiple parent object types and you can embed objects inside of other embedded objects. ## Important Embedded objects cannot have a primary key. ### Realm Object Models To define an embedded object, derive a class from `EmbeddedObject`. Use the syntax \"`<YourClass> : EmbeddedObject {}`\" to accomplish this. You can reference an embedded object type from parent object types in the same way as you would define a relationship. Consider the following example where the `Address` is an Embedded Object. Both the `Contact` and the `Business` classes reference the `Address` as an embedded object:\n\n ` ### JSON Schema Embedded objects map to embedded documents in the parent type's [schema](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). This behavior differs from regular Realm objects, which map to their own MongoDB collection. ``` {   \"title\": \"Contact\",   \"bsonType\": \"object\",   \"required\": [\"_id\"],   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"name\": { \"bsonType\": \"string\" },     \"address\": {       \"title\": \"Address\",       \"bsonType\": \"object\",       \"properties\": {         \"street\": { \"bsonType\": \"string\" },         \"city\": { \"bsonType\": \"string\" },         \"country\": { \"bsonType\": \"string\" },         \"postalCode\": { \"bsonType\": \"string\" }       }     }   } } \n``` ``` {   \"title\": \"Business\",   \"bsonType\": \"object\",   \"required\": [\"_id\", \"name\", \"addresses\"],   \"properties\": {     \"_id\": \"objectId\",     \"name\": { \"bsonType\": \"string\" },     \"addresses\": {       \"bsonType\": \"array\",       \"items\": {         \"title\": \"Address\",         \"bsonType\": \"object\",         \"properties\": {           \"street\": { \"bsonType\": \"string\" },           \"city\": { \"bsonType\": \"string\" },           \"country\": { \"bsonType\": \"string\" },           \"postalCode\": { \"bsonType\": \"string\" }         }       }     }   } } \n``` ## Read and Write Embedded Objects ### Create an Embedded Object To create an embedded object, assign an instance of the embedded object to a parent object's property: ```csharp var address = new Address() // Create an Address {     Street = \"123 Fake St.\",     City = \"Springfield\",     Country = \"USA\",     PostalCode = \"90710\" }; var contact = new Contact() // Create a Contact {     Name = \"Nick Riviera\",     Address = address // Embed the Address Object }; realm.Write(() => {     realm.Add(contact); }); \n``` ### Update an Embedded Object Property To update a property in an embedded object, modify the property in a write transaction: ```csharp var resultContact = realm.All<Contact>() // Find the First Contact (Sorted By Name)     .OrderBy(c => c.Name)     .FirstOrDefault(); // Update the Result Contact's Embedded Address Object's Properties realm.Write(() => {     resultContact.Address.Street = \"Hollywood Upstairs Medical College\";     resultContact.Address.City = \"Los Angeles\";     resultContact.Address.PostalCode = \"90210\"; }); \n``` ### Overwrite an Embedded Object To overwrite an embedded object, reassign the embedded object property of a party to a new instance in a write transaction: ```csharp var oldContact = realm.All<Contact>() // Find the first contact .OrderBy(c => c.Name) .FirstOrDefault(); var newAddress = new Address() // Create an Address {     Street = \"100 Main Street\",     City = \"Los Angeles\",     Country = \"USA\",     PostalCode = \"90210\" }; realm.Write(() => {     oldContact.Address = newAddress; }); \n``` ### Query a Collection on Embedded Object Properties\n\n ## Note It is not possible to query embedded objects directly. Instead, access embedded objects through a query for the parent object type. ```csharp // Find All Contacts with an Address of \"Los Angeles\" var losAngelesContacts = realm.All<Contact>()     .Filter(\"address.city == 'Los Angeles'\"); foreach (var contact in losAngelesContacts) {     Console.WriteLine(\"Los Angeles Contact:\");     Console.WriteLine(contact.Name);     Console.WriteLine(contact.Address.Street); } \n``` ← [RealmInteger - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-integer/ \"Previous Section\")[Manually Define a Schema - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/manual-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/app-services/connect-to-app-services-backend/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Connect to an Atlas App Services Backend - .NET SDK On this page * [Access the App Client](#access-the-app-client)\n* [Configuration](#configuration) The App client is the interface to the App Services backend. It provides access to the [authentication functionality](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate), [functions](https://mongodb.com/docs/realm/sdk/dotnet/app-services/call-a-function/#std-label-dotnet-call-a-function), and[sync management.](https://mongodb.com/docs/realm/sdk/dotnet/sync/#std-label-dotnet-sync) ## Access the App Client Pass the App ID for your App, which you can[find in the Realm UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) `| var myRealmAppId = \"<your_app_id>\"; |\n| ----------------------------------- |\n| var app = App.Create(myRealmAppId); | ` ## Configuration For granular control of your app connection, such as custom timeouts for connections and the log level, you can pass an[AppConfiguration](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.AppConfiguration.html)object to the[App.Create()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.App.html#Realms%5FSync%5FApp%5FCreate%5FRealms%5FSync%5FAppConfiguration%5F)method. The following example sets the LogLevel and the request timeout: ```csharp var appConfig = new AppConfiguration(myRealmAppId) {     //LogLevel = LogLevel.Debug,     DefaultRequestTimeout = TimeSpan.FromMilliseconds(1500) }; app = App.Create(appConfig); \n``` ## Note For most use cases, you only need your application's App ID to connect to Realm. The other settings demonstrated here are optional. ← [Application Services - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/application-services/ \"Previous Section\")[Call a Function - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/app-services/call-a-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Object Models - .NET SDK On this page * [Create an Object Model](#create-an-object-model)\n* [Object Schema](#object-schema)\n* [Property Annotations](#property-annotations)\n* [Primary Key](#primary-key)\n* [Indexes](#indexes)\n* [Required and Optional Properties](#required-and-optional-properties)\n* [Default Field Values](#default-field-values)\n* [Ignore a Property](#ignore-a-property)\n* [Rename a Property](#rename-a-property)\n* [Rename a Class](#rename-a-class)\n* [Custom Setters](#custom-setters)\n* [Omit Classes from your Realm Schema](#omit-classes-from-your-realm-schema)\n* [Data Binding and MVVM](#data-binding-and-mvvm) ## Create an Object Model Realm classes are regular C# classes that define the Realm schema. ## Important ### Inheritance All Realm objects inherit from the[IRealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IRealmObject.html),[IEmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IEmbeddedObject.html), or[IAsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IAsymmetricObject.html)interface and should be declared `partial` classes. You can also derive from the[RealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmObject.html),[EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.EmbeddedObject.html), or[AsymmetricObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.AsymmetricObject.html)base classes. However, in the future we may deprecate the base classes. You should use the interfaces for any new classes that you write. ## Note Class names are limited to a maximum of 57 UTF-8 characters. ### Object Schema An **object schema** is a configuration object that defines the properties and relationships of a Realm object. Realm client applications define object schemas with the native class implementation in their respective language using the Object Schema. Object schemas specify constraints on object properties such as the data type of each property and whether or not a property is required. Schemas can also define [relationships](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/#std-label-dotnet-client-relationships) between object types in a realm. Every App has a [App Services Schema](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-realm-schema)composed of a list of object schemas for each type of object that the realms in that application may contain. Realm guarantees that all objects in a realm conform to the schema for their object type and validates objects whenever they're created, modified, or deleted. ## Property Annotations Schema properties are standard C# properties on a `RealmObject`. There are several property annotations that you can use to more finely define how a Realm handles a specific property. ### Primary Key A **primary key** is a property that uniquely identifies an object. You can create a primary key with any of the following types (or their nullable counterparts): * `ObjectId`\n* `UUID`\n* `string`\n* `char`\n* `byte`\n* `short`\n* `int`\n* `long` You may define a primary key on a **single property** for an object type as part of the [object schema](#std-label-dotnet-object-schema). Realm Database automatically indexes primary key properties, which allows you to efficiently read and modify objects based on their primary key.\n\n ## Note Once you assign a property as a primary key, you cannot change it. The following example demonstrates how to designate a primary key in an object schema: `| public partial class Dog : IRealmObject |\n| --------------------------------------- |\n| {                                       |\n| [PrimaryKey]                            |\n| public string Name { get; set; }        |\n| public int Age { get; set; }            |\n| public Person Owner { get; set; }       |\n| }                                       | ` ## Tip ### See also:  * [Usage Examples: Find a Specific Object by Primary Key](https://mongodb.com/docs/realm/sdk/dotnet/crud/read/#std-label-dotnet-find-a-specific-object-by-primary-key) ### Indexes **Indexes** support the efficient execution of queries in Realm Database. Without indexes, Realm Database must perform a_collection scan_, i.e. scan every document in a collection, to select those documents that match a query. If an appropriate index exists for a query, Realm Database can use the index to limit the number of documents that it must inspect. Indexes are special data structures that store a small portion of a realm's data in an easy to traverse form. The index stores the value of a specific property ordered by the value of the property. The ordering of the index entries supports efficient equality matches and range-based query operations. Adding an index can speed up some queries at the cost of slightly slower write times and additional storage and memory overhead. Indexes require space in your realm file, so adding an index to a property will increase disk space consumed by your realm file. Each index entry is a minimum of 12 bytes. You can index properties with the following types: * `bool`\n* `byte`\n* `short`\n* `int`\n* `long`\n* `DateTimeOffset`\n* `char`\n* `string`\n* `ObjectId`\n* `UUID` To index a property, use the [\\[Indexed\\]](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IndexedAttribute.html)attribute: ```csharp public partial class Person : IRealmObject {     [Indexed]     public string Name { get; set; }     public IList<Dog> Dogs { get; } } \n``` ### Required and Optional Properties In C#, value types are implicitly non-nullable, but can be made optional by appending[?](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types). Reference types, such as `string` and `byte[]`, are implicitly nullable and can be made required by annotating them with the `[Required]` attribute. Properties of types that inherit from `IRealmObject` or `IEmbeddedObject` are special and can always be null. Applying `[Required]` on such a property will result in a compilation error. You can use the `[Required]` attribute as seen in the following example: ```csharp public partial class Person : IRealmObject {     [Required]     public string Name { get; set; }     public IList<Dog> Dogs { get; } } \n``` ### Default Field Values You can use the built-in language features to assign a default value to a property. In C#, you can assign a default value in the property declaration. ```csharp public partial class Person : IRealmObject {     public string Name { get; set; } = \"foo\"; } \n``` ## Note ### Default Values and Nullability\n\n ### Ignore a Property If you don't want to save a property in your model to a realm, you can ignore that property. A property is ignored by default if it is not autoimplemented or does not have a setter. Ignore a property from a Realm object model with the[\\[Ignored\\]](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.IgnoredAttribute.html) attribute: ```csharp // Rather than store an Image in Realm, // store the path to the Image... public string ThumbnailPath { get; set; } // ...and the Image itself can be // in-memory when the app is running: [Ignored] public Image Thumbnail { get; set; } \n``` ### Rename a Property By default, Realm Database uses the name defined in the model class to represent properties internally. In some cases you might want to change this behavior: * To make it easier to work across platforms, since naming conventions differ.\n* To change a property name in .NET without forcing a migration. Choosing an internal name that differs from the name used in model classes has the following implications: * Migrations must use the internal name when creating classes and properties.\n* Schema errors reported will use the internal name. Use the [\\[MapTo\\]](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.MapToAttribute.html)attribute to rename a property: ```csharp public partial class Person : IRealmObject {     [MapTo(\"moniker\")]     public string Name { get; set; } } \n``` ### Rename a Class By default, Realm Database uses the name defined in the model class to represent classes internally. In some cases you might want to change this behavior: * To support multiple model classes with the same simple name in different namespaces.\n* To make it easier to work across platforms, since naming conventions differ.\n* To use a class name that is longer than the 57 character limit enforced by Realm Database.\n* To change a class name in .NET without forcing a migration. Use the [\\[MapTo\\]](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.MapToAttribute.html)attribute to rename a class: ```csharp [MapTo(\"Human\")] public partial class Person : IRealmObject {     public string Name { get; set; } } \n``` ### Custom Setters Realm will not store a property with a custom setter. To use a custom setter, store the property value in a private property and then map that value to a public property with the custom setter. Realm will store the private property, while you modify its value via the public property. In the following code, the private `email` property is stored in the realm, but the public `Email` property, which provides validation, is not persisted: ```csharp // This property will be stored in the Realm private string email { get; set; } // Custom validation of the email property. // This property is *not* stored in Realm. public string Email {     get { return email; }     set     {         if (!value.Contains(\"@\")) throw new Exception(\"Invalid email address\");         email = value;     } } \n``` ## Omit Classes from your Realm Schema By default, your application's Realm Schema includes all classes that implement `IRealmObject` or `IEmbeddedObject`. If you only want to include a subset of these classes in your Realm Schema, you can update your configuration to include the specific classes you want: ```csharp // Declare your schema partial class LoneClass : IRealmObject {     public string Name { get; set; } } class AnotherClass {     private void SetUpMyRealmConfig()     {         // Define your config with a single class         var config = new RealmConfiguration(\"RealmWithOneClass.realm\");         config.Schema = new[] { typeof(LoneClass) };         // Or, specify multiple classes to use in the Realm         config.Schema = new[] { typeof(Dog), typeof(Cat) };     } } \n``` ## Data Binding and MVVM\n\n However, when you bind UI elements to a [RealmObject](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.RealmObject.html), this notification happens automatically, thus greatly simplifying your ViewModel code. You can also bind a UI element to a realm [Live Query](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/#std-label-dotnet-live-queries). For example, if you bind a[ListView](https://docs.microsoft.com/en-us/dotnet/api/xamarin.forms.listview?view=xamarin-forms)to a live query, then the list will update automatically when the results of the query change; you do not need to implement the `INotifyPropertyChange`interface. For example, if you bind a ListView to a query that returns all Product objects, the list of available products updates automatically when a product is added, changed, or removed from the realm: ```csharp // Somewhere in your ViewModel AllProducts = realm.All<Products>(); \n``` ``` <!-- Somewhere in your View --> <ListView ItemsSource=\"{Binding AllProducts}\"> \n``` ← [Model Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/ \"Previous Section\")[Object Models & Schemas - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/app-services/call-a-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call a Function - .NET SDK On this page * [Call a Function by Name](#call-a-function-by-name) The examples in this section demonstrate calling a [Realm Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions)named `sum` that takes two arguments, adds them, and returns the result: `| // sum: adds two numbers   |\n| -------------------------- |\n| exports = function(a, b) { |\n| return a + b;              |\n| };                         | ` ## Note ### Authenticate First You call Functions on a [User](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.html)object, so before calling any function, you must[authenticate a user.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate) ## Call a Function by Name ## Important Make sure to sanitize client data to protect against code injection when using Functions. To execute a function from the .NET SDK, use the[Functions.CallAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.User.FunctionsClient.html#Realms%5FSync%5FUser%5FFunctionsClient%5FCallAsync%5FSystem%5FString%5FSystem%5FObject%5F%5F%5F)method on the `User` object, passing in the name of the function as the first parameter and the arguments as the remaining parameters: ```csharp var bsonValue = await     user.Functions.CallAsync(\"sum\", 2, 40); // The result must now be cast to Int32: var sum = bsonValue.ToInt32(); // Or use the generic overloads to avoid casting the BsonValue: sum = await    user.Functions.CallAsync<int>(\"sum\", 2, 40); \n``` ## Note The `CallAsync()` method returns a single `BsonValue` object, which you can deserialize after calling the function or by using the the generic overload. Both of these approaches to deserialization are shown in the code above. A `BsonValue` object can hold a single primitive value (as shown in the example above), or hold a complete BSON document. If you have a class that maps to the returned object, you can deserialize to that class by using the generic overload. For example, the following code calls a function that returns an object from a collection of \"RealmTasks\". Since we know the shape of the returned object, we we can deserialize the`BsonValue` to a class that we have created, and then we have access to the properties and methods on that object: ```csharp var item = await user.Functions.CallAsync<MyClass>     (\"getItem\", \"5f7f7638024a99f41a3c8de4\"); var name = item.Name; \n``` ← [Connect to an Atlas App Services Backend - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/app-services/connect-to-app-services-backend/ \"Previous Section\")[Query MongoDB - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/app-services/mongodb-remote-access/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/sets/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sets - .NET SDK On this page * [Overview](#overview)\n* [Set Types](#set-types)\n* [Usage Example](#usage-example)\n* [Data Binding](#data-binding) _New in version 10.2.0_. ## Overview A Realm set, like the C#[HashSet<>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.hashset-1?view=net-5.0), is an implementation of[ICollection<>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icollection-1?view=net-5.0)and[IEnumerable<>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=net-5.0). It supports values of any[Realm type](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects) except [collections](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/#std-label-dotnet-client-collections). To define a set, use a getter-only `ISet<TValue>` property, where `TValue`is any of the supported types. Deleting an object from the database will remove it from any sets in which it existed. Therefore, a set of objects will never contain null objects. However, sets of primitive types can contain null values. If you do not want to allow null values in a set, then either use non-nullable types in the set declaration (for example, use `ISet<double>` instead of`ISet<double?>`), or add the[\\[Required\\]](https://mongodb.com/docs/realm/sdk/dotnet/model-data/define-object-model/#std-label-dotnet-required-optional-property) attribute if the set contains nullable reference types, such as `string` or `byte[]`. ## Important ### Not Supported with Sync Local-only Realm Databases support collections of nullable (optional) values, but `Sync` does not. ## Set Types The following code shows examples of set types:\n\n ` ## Usage Example The following code shows how to create, write to, and read from Sets. ```csharp var inventory = new Inventory(); inventory.PlantSet.Add(new Plant() { Name = \"Prickly Pear\" }); inventory.DoubleSet.Add(123.45); realm.Write(() => {     realm.Add<Inventory>(inventory); }); // convert the Plant Set to an IQueryable and apply a filter var pricklyPear = inventory.PlantSet.AsRealmQueryable()     .Where(p => p.Name == \"Prickly Pear\"); // Alternatively, apply a filter directly on the Plant Set  var pricklyPearPlants = inventory.PlantSet     .Filter(\"Name == 'Prickly Pear'\"); // Find all Inventory items that have at least one value in their // DoubleSet that is larger than 5 var moreThan100 = realm.All<Inventory>()     .Filter(\"DoubleSet.@values > 100\"); \n``` ## Data Binding Like other Realm collections, `ISet` implements `INotifyCollectionChanged`, so you can use it in data-binding scenarios (for example, when[watching for changes](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/#std-label-dotnet-react-to-changes)). ← [Dictionaries - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/dictionaries/ \"Previous Section\")[RealmValue - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/realm-value/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/app-services/manage-user-api-keys/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage User API Keys - .NET SDK On this page * [Create a User API Key](#create-a-user-api-key)\n* [Look up a User API Key](#look-up-a-user-api-key)\n* [Enable or Disable an API Key](#enable-or-disable-an-api-key)\n* [Delete an API Key](#delete-an-api-key) Application users can generate user API keys with the .NET SDK. You can allow devices or services to communicate with Atlas App Services on behalf of a user by associating a unique user API key with each device or service. User API keys are always associated with a user object created by another non-anonymous authentication provider. Each user can associate up to 20 user keys with their account. ## Note User API keys are not the same as **server API keys**, which allow a user or service to directly authenticate with App Services using the[API Key authentication provider](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-login-api-key). To learn more about server API keys, see [API Key Authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication) ## Create a User API Key ## Warning ### Store the API Key Value The SDK only returns the value of the user API key when you create it. Make sure to store the `key` value securely so that you can use it to log in. If you lose or do not store the `key` value there is no way to recover it. You will need to create a new user API key. `| var newKey = await user.ApiKeys.CreateAsync(\"someKeyName\");  |\n| ------------------------------------------------------------ |\n| Console.WriteLine($\"I created a key named {newKey.Name}. \" + |\n| $\"Is it enabled? {newKey.IsEnabled}\");                       | ` ## Look up a User API Key To get a single key: ```csharp var key = await user.ApiKeys.FetchAsync(ObjectId.Parse(\"00112233445566778899aabb\")); Console.WriteLine($\"I fetched the key named {key.Name}. \" +     $\"Is it enabled? {key.IsEnabled}\"); \n``` To get all keys: ```csharp var allKeys = await user.ApiKeys.FetchAllAsync(); foreach (var key in allKeys) {     Console.WriteLine($\"I fetched the key named {key.Name}. \" +         $\"Is it enabled? {key.IsEnabled}\"); } \n``` ## Enable or Disable an API Key ```csharp var key = await user.ApiKeys.FetchAsync(ObjectId.Parse(\"00112233445566778899aabb\")); if (!key.IsEnabled) {     // enable the key     await user.ApiKeys.EnableAsync(key.Id); } else {     // disable the key     await user.ApiKeys.DisableAsync(key.Id); } \n``` ## Delete an API Key ```csharp await user.ApiKeys.DeleteAsync(ObjectId.Parse(\"00112233445566778899aabb\")); \n``` ← [Query MongoDB - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/app-services/mongodb-remote-access/ \"Previous Section\")[Work with Users - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/work-with-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/app-services/mongodb-remote-access/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query MongoDB - .NET SDK On this page * [Use Cases](#use-cases)\n* [Prerequisites](#prerequisites)\n* [Setup](#setup)\n* [Example Data](#example-data)\n* [Mapping Classes](#mapping-classes)\n* [Create Documents](#create-documents)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Read Documents](#read-documents)\n* [Find a Single Document](#find-a-single-document)\n* [Find Multiple Documents](#find-multiple-documents)\n* [Count Documents in the Collection](#count-documents-in-the-collection)\n* [Update Documents](#update-documents)\n* [Update a Single Document](#update-a-single-document)\n* [Update Multiple Documents](#update-multiple-documents)\n* [Upsert Documents](#upsert-documents)\n* [Delete Documents](#delete-documents)\n* [Delete a Single Document](#delete-a-single-document)\n* [Delete Multiple Documents](#delete-multiple-documents)\n* [Aggregate Documents](#aggregate-documents)\n* [Group Documents in a Collection](#group-documents-in-a-collection)\n* [Filter Documents](#filter-documents)\n* [Project Data](#project-data) You can query data stored in MongoDB Atlas directly from your .NET application code by using the Realm .NET SDK's [MongoClient](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.html)with the [Query API](https://www.mongodb.com/docs/manual/tutorial/query-documents/). Atlas App Services provides data access [rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) on collections to securely retrieve results based on the logged-in user or the content of each document. The following actions enable access to a linked MongoDB Atlas cluster from a .NET application using the Realm .NET SDK. ## Note Each operation described on this page uses a **query** to match certain documents in the collection upon which the operation executes. When a filter matches multiple documents in a collection, they are returned in an [indeterminate order](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/#return-in-natural-order) unless you specify a sorting parameter. This means that if you do not specify a sort for the `findOne()`, `updateOne()`, or `deleteOne()`functions, your operation could match _any_ document that matches the query. For more information on sorting, see[cursor.sort().](https://www.mongodb.com/docs/manual/reference/method/cursor.sort/) ## Use Cases There are a variety of reasons you might want to query a MongoDB data source. Working with data in your client via Atlas Device Sync is not always practical or possible. You might want to query MongoDB when: * The data set is large or the client device has constraints against loading the entire data set\n* You are [creating or updating custom user data](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/custom-user-data/#std-label-dotnet-custom-user-data)\n* You are retrieving documents that are not modeled in Realm\n* Your app needs to access collections that don't have strict schemas\n* A non-Realm service generates collections that you want to access While not exhaustive, these are some common use cases for querying MongoDB directly. ## Prerequisites Before you can query MongoDB from your .NET application, you must set up MongoDB Data Access in your App Services App. To learn how to set up your backend App to let the Realm SDK query Atlas, refer to [Set Up MongoDB Data Access](https://www.mongodb.com/docs/atlas/app-services/mongodb/data-access/#std-label-client-data-access)in the App Services documentation. ## Setup\n\n `| mongoClient = user.GetMongoClient(\"mongodb-atlas\");                 |\n| ------------------------------------------------------------------- |\n| dbPlantInventory = mongoClient.GetDatabase(\"inventory\");            |\n| plantsCollection = dbPlantInventory.GetCollection<Plant>(\"plants\"); | ` ## Example Data The examples on this page use the following MongoDB collection that describes various plants for sale in a chain of plant stores: ```javascript { _id: ObjectId(\"5f87976b7b800b285345a8b4\"), name: \"venus flytrap\", sunlight: \"full\", color: \"white\", type: \"perennial\", _partition: \"Store 42\" }, { _id: ObjectId(\"5f87976b7b800b285345a8b5\"), name: \"sweet basil\", sunlight: \"partial\", color: \"green\", type: \"annual\", _partition: \"Store 42\" }, { _id: ObjectId(\"5f87976b7b800b285345a8b6\"), name: \"thai basil\", sunlight: \"partial\", color: \"green\", type: \"perennial\", _partition: \"Store 42\" }, { _id: ObjectId(\"5f87976b7b800b285345a8b7\"), name: \"helianthus\", sunlight: \"full\", color: \"yellow\", type: \"annual\", _partition: \"Store 42\" }, { _id: ObjectId(\"5f87976b7b800b285345a8b8\"), name: \"petunia\", sunlight: \"full\", color: \"purple\", type: \"annual\", _partition: \"Store 47\" } \n``` ### Mapping Classes When working with objects in MongoDB, you should create .NET classes (POCOs) that correspond to the BSON objects. This allows you to serialize and deserialize the objects directly, rather than working with generic `BsonDocument` objects. In all of the examples on this page, we are using the following `Plant` mapping class for this purpose: ```csharp public partial class Plant : IRealmObject {     [BsonElement(\"_id\")]     public ObjectId Id { get; set; } = ObjectId.GenerateNewId();     [BsonElement(\"name\")]     public string Name { get; set; }     [BsonElement(\"sunlight\")]     [BsonRepresentation(BsonType.String)]     public string Sunlight { get; set; }     [BsonElement(\"color\")]     [BsonRepresentation(BsonType.String)]     public string Color { get; set; }     [BsonElement(\"type\")]     [BsonRepresentation(BsonType.String)]     public string Type { get; set; }     [BsonElement(\"_partition\")]     public string Partition { get; set; } } public enum Sunlight {     Full,     Partial } public enum PlantColor {     White,     Green,     Yellow,     Purple } public enum PlantType {     Perennial,     Annual } \n``` ## Note If you choose to provide custom constructors, you must declare a public constructor with no arguments. For more information on using mapping classes, see[Mapping Classes](https://mongodb.github.io/mongo-csharp-driver/2.11/reference/bson/mapping/)in the MongoDB .NET Driver documentation. ## Create Documents\n\n ### Insert a Single Document You can insert a single document using[InsertOneAsync().](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FInsertOneAsync%5F%5F0%5F) The following snippet inserts a single document describing a \"Venus Flytrap\" plant into our \"plants\" collection: ```csharp var plant = new Plant {     Name = \"Venus Flytrap\",     Sunlight = Sunlight.Full.ToString(),     Color = PlantColor.White.ToString(),     Type = PlantType.Perennial.ToString(),     Partition = \"Store 42\" }; var insertResult = await plantsCollection.InsertOneAsync(plant); var newId = insertResult.InsertedId; \n``` ### Insert Multiple Documents You can insert multiple documents at the same time by using[InsertManyAsync().](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FInsertManyAsync%5FSystem%5FCollections%5FGeneric%5FIEnumerable%5F%5F0%5F%5F) The following snippet inserts four `Plant` objects into the \"plants\" collection by instantiating the objects, adding them to a `List<Plant>`, and passing that list to `InsertManyAsync()`: ```csharp var sweetBasil = new Plant {     Name = \"Sweet Basil\",     Sunlight = Sunlight.Partial.ToString(),     Color = PlantColor.Green.ToString(),     Type = PlantType.Annual.ToString(),     Partition = \"Store 42\" }; var thaiBasil = new Plant {     Name = \"Thai Basil\",     Sunlight = Sunlight.Partial.ToString(),     Color = PlantColor.Green.ToString(),     Type = PlantType.Perennial.ToString(),     Partition = \"Store 42\" }; var helianthus = new Plant {     Name = \"Helianthus\",     Sunlight = Sunlight.Full.ToString(),     Color = PlantColor.Yellow.ToString(),     Type = PlantType.Annual.ToString(),     Partition = \"Store 42\" }; var petunia = new Plant {     Name = \"Petunia\",     Sunlight = Sunlight.Full.ToString(),     Color = PlantColor.Purple.ToString(),     Type = PlantType.Annual.ToString(),     Partition = \"Store 47\" }; var listofPlants = new List<Plant> {     sweetBasil,     thaiBasil,     helianthus,     petunia }; var insertResult = await plantsCollection.InsertManyAsync(listofPlants); var newIds = insertResult.InsertedIds; \n``` ## Read Documents\n\n ### Find a Single Document The following example shows how to find a plant where the \"name\" property is \"petunia\": ```csharp var petunia = await plantsCollection.FindOneAsync(    new { name = \"Petunia\" },    null); \n``` ### Find Multiple Documents The following example shows how to find all plants where the \"type\" property is \"perennial\": ```csharp var allPerennials = await plantsCollection.FindAsync(     new { type = PlantType.Perennial.ToString() },     new { name = 1 }); \n``` ## Important We are using the third parameter of `FindAsync()`, which specifies the sort order. If you are querying for more than one document, you should include the sort order to ensure consistent results. ### Count Documents in the Collection The following example returns a count of all plants in the collection: ```csharp var allPlants = await plantsCollection.CountAsync(); \n``` ## Update Documents To update an existing document in the MongoDB datastore, you create a`BsonDocument` filter that defines the properties you want to search on, and then create a second `BsonDocument` that defines the properties you want to change. If you are updating only one document, you pass both objects to[UpdateOneAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FUpdateOneAsync%5FSystem%5FObject%5FSystem%5FObject%5FSystem%5FBoolean%5F). If you want to bulk update multiple documents, you call[UpdateManyAsync().](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FUpdateManyAsync%5FSystem%5FObject%5FSystem%5FObject%5FSystem%5FBoolean%5F) ### Update a Single Document The following code finds the plant whose \"name\" property is \"petunia\" and changes its \"sunlight\" property to \"partial\": ```csharp var updateResult = await plantsCollection.UpdateOneAsync(     new { name = \"Petunia\" },     new BsonDocument(\"$set\", new BsonDocument(\"sunlight\", Sunlight.Partial.ToString()))     ); \n``` ### Update Multiple Documents The following code finds all plants with a \"\\_partition\" value of \"store 47\" and changes them all to \"area 51\": ```csharp var filter = new { _partition = \"Store 47\" }; var updateDoc = new BsonDocument(\"$set\",     new BsonDocument(\"_partition\", \"Area 51\")); var updateResult = await plantsCollection.UpdateManyAsync(     filter, updateDoc); \n``` ### Upsert Documents Both [UpdateOneAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FUpdateOneAsync%5FSystem%5FObject%5FSystem%5FObject%5FSystem%5FBoolean%5F)and[UpdateManyAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FUpdateManyAsync%5FSystem%5FObject%5FSystem%5FObject%5FSystem%5FBoolean%5F)have an optional Boolean property that specifies whether the update should be an upsert (that is, if the document doesn't exist, it should be created). By default, no upsert is performed.\n\n ```csharp var filter = new BsonDocument()     .Add(\"name\", \"Pothos\")     .Add(\"type\", PlantType.Perennial.ToString())     .Add(\"sunlight\", Sunlight.Full.ToString()); var updateResult = await plantsCollection.UpdateOneAsync(     filter,     new BsonDocument(\"$set\", new BsonDocument(\"_partition\", \"Store 42\")),     upsert: true); /* The upsert will create the following object: {    \"name\": \"pothos\",    \"sunlight\": \"full\",    \"type\": \"perennial\",    \"_partition\": \"Store 42\" } */ \n``` ## Delete Documents The process for deleting documents is much the same as creating (or updating) documents: you create a `BsonDocument` that defines the properties you want to match on, and then call either[DeleteOneAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FDeleteOneAsync%5FSystem%5FObject%5F). or[DeleteManyAsync().](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FDeleteManyAsync%5FSystem%5FObject%5F) ### Delete a Single Document The following example deletes the first document it finds with a \"name\" property value of \"Thai Basil\": ```csharp var filter = new BsonDocument(\"name\", \"Thai Basil\"); var deleteResult = await plantsCollection.DeleteOneAsync(filter); \n``` ### Delete Multiple Documents The following example deletes all documents that have a \"type\" property value of \"annual\": ```csharp var filter = new BsonDocument(\"type\", PlantType.Annual); var deleteResult = await plantsCollection.DeleteManyAsync(filter); \n``` ## Aggregate Documents Aggregation operations run all documents in a collection through a series of data aggregation stages called an [aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/). Aggregation allows you to filter and transform documents, collect summary data about groups of related documents, and other complex data operations. Aggregation operations accept an array of aggregation stages as input, and return a [Task](https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1?view=netcore-3.1) that resolves to a collection of documents processed by the pipeline. ## Note Compass provides a utility for building aggregation pipelines and exporting them to C# and other languages. For more information, see[Aggregation Pipeline Builder](https://www.mongodb.com/docs/compass/master/aggregation-pipeline-builder). ### Group Documents in a Collection The .NET SDK supports aggregation on a collection with the[AggregateAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FAggregateAsync%5FSystem%5FObject%5F%5F%5F)method and its generic overload. The following example groups all documents in the plants collection by their `type` value, aggregates a count of the number of each type, and then sorts them in ascending order: ```csharp var groupStage =     new BsonDocument(\"$group\",         new BsonDocument         {             { \"_id\", \"$type\" },             { \"count\", new BsonDocument(\"$sum\", 1) }         }); var sortStage = new BsonDocument(\"$sort\",     new BsonDocument(\"_id\", 1)); var aggResult = await plantsCollection.AggregateAsync(groupStage, sortStage); foreach (var item in aggResult) {\n\n     var count = item[\"count\"];     Console.WriteLine($\"Plant type: {id}; count: {count}\"); } \n``` The example above builds the pipeline with a series of nested BsonDocuments, which can get complicated to write and debug. If you are already familiar with the [Query API](https://www.mongodb.com/docs/manual/tutorial/query-documents/), you can pass queries as a string the[BsonDocument\\_Parse()](https://mongodb.github.io/mongo-csharp-driver/2.11/apidocs/html/M%5FMongoDB%5FBson%5FBsonDocument%5FParse.htm)method. The following example performs the same aggregation as the preceding example: ```csharp var groupStep = BsonDocument.Parse(@\"   {     $group: {       _id: '$type',        count: {         $sum: 1       }     }   } \"); var sortStep = BsonDocument.Parse(\"{$sort: { _id: 1}}\"); aggResult = await plantsCollection.AggregateAsync(groupStep, sortStep); foreach (var item in aggResult) {     var id = item[\"_id\"];     var count = item[\"count\"];     Console.WriteLine($\"Id: {id}, Count: {count}\"); } \n``` ### Filter Documents You can use the [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) stage to filter documents using standard MongoDB [query syntax.](https://www.mongodb.com/docs/manual/tutorial/query-documents/) The following example shows how to filter documents when using Aggregation. Since we know that this aggregation pipeline returns a collection of `Plant`objects, we use the generic override of the[AggregateAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Sync.MongoClient.Collection-1.html#Realms%5FSync%5FMongoClient%5FCollection%5F1%5FAggregateAsync%5FSystem%5FObject%5F%5F%5F)method: ```csharp var matchStage = new BsonDocument(\"$match\",         new BsonDocument(\"type\",             new BsonDocument(\"$eq\",                 PlantType.Perennial))); // Alternate approach using BsonDocument.Parse(...) matchStage = BsonDocument.Parse(@\"{   $match: {     type: { $eq: '\" + PlantType.Perennial + @\"' }   }}\"); var sortStage = BsonDocument.Parse(\"{$sort: { _id: 1}}\"); var aggResult = await plantsCollection.AggregateAsync<Plant>(matchStage, sortStage); foreach (var plant in aggResult) {     Console.WriteLine($\"Plant Name: {plant.Name}, Color: {plant.Color}\"); } \n``` ### Project Data You can use the [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) stage to include or omit specific fields from documents or to calculate new fields using[aggregation operators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). Projections work in two ways: * Explicitly include fields with a value of 1\\. This has the side-effect of implicitly excluding all unspecified fields.\n* Implicitly exclude fields with a value of 0\\. This has the side-effect of implicitly including all unspecified fields. These two methods of projection are mutually exclusive: if you explicitly include fields, you cannot explicitly exclude fields, and vice versa. ## Note\n\n The following example shows how to use project when using Aggregation. In this example, we are: 1. Excluding the \"Id\" property,\n2. Including the \"Partition\", \"Type\", and \"Name\" properties,\n3. Creating a new property called \"storeNumber\", which is built by splitting the \\_partition value on the whitespace and returning only the second part. ```csharp var projectStage = new BsonDocument(\"$project\",     new BsonDocument     {         { \"_id\", 0 },         { \"_partition\", 1 },         { \"type\", 1 },         { \"name\", 1 },         { \"storeNumber\",             new BsonDocument(\"$arrayElemAt\",                 new BsonArray {                     new BsonDocument(\"$split\",                     new BsonArray                     {                         \"$_partition\",                         \" \"                     }), 1 }) }     }); var sortStage = BsonDocument.Parse(\"{$sort: { storeNumber: 1}}\"); var aggResult = await plantsCollection.AggregateAsync(projectStage, sortStage); foreach (var item in aggResult) {     Console.WriteLine($\"{item[\"name\"]} is in store #{item[\"storeNumber\"]}.\"); } \n``` The following shows how you can also build the `projectStage` by using the`BsonDocument.Parse()` method: ```csharp projectStage = BsonDocument.Parse(@\"     {       _id:0,       _partition: 1,       type: 1,       name: 1,       storeNumber: {         $arrayElemAt: [           { $split:[             '$_partition', ' '             ]           }, 1 ]       }     }\"); \n``` ← [Call a Function - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/app-services/call-a-function/ \"Previous Section\")[Manage User API Keys - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/app-services/manage-user-api-keys/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/crud/read/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Read Data - .NET SDK On this page * [Read from Realm Database](#read-from-realm-database)\n* [Find a Specific Object by Primary Key](#find-a-specific-object-by-primary-key)\n* [Query All Objects of a Given Type](#query-all-objects-of-a-given-type) ## Read from Realm Database A read from a realm generally consists of the following steps: * Get all [objects](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects) of a certain type from the realm.\n* Optionally, [filter](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/#std-label-dotnet-filter-results) the results using the [query engine.](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/#std-label-dotnet-client-query-engine)\n* Optionally, [sort](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/#std-label-dotnet-sort-results) the results. ## Note ### About the examples on this page The examples on this page use the data model of a project management app that has two Realm object types: `Project`and `Task`. A `Project` has zero or more `Tasks`. See the schema for these two classes, `Project` and`Task`, below: `| public class Task : RealmObject          |\n| ---------------------------------------- |\n| {                                        |\n| [PrimaryKey]                             |\n| public int Id {get; set; }               |\n| public string Name { get; set; }         |\n| public string Assignee { get; set; }     |\n| public bool IsComplete { get; set; }     |\n| public int Priority { get; set; }        |\n| public int ProgressMinutes { get; set; } |\n| }                                        |\n| public class Project : RealmObject       |\n| {                                        |\n| public string Name { get; set; }         |\n| public List<Task> Tasks { get; set; }    |\n| }                                        | ` ## Find a Specific Object by Primary Key You can also find a specific item by its primary key using the[Find](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FFind%5F%5F1%5FSystem%5FNullable%5FSystem%5FInt64%5F%5F)method, as shown in the following example: ```csharp // Object to be stored in the Realm instance var myTask = new Task {     Id = 1 }; realm.Write(() => {     realm.Add(myTask); }); // Other code... // Find specific object by primary key var obj = realm.Find<Task>(1); \n``` ## Query All Objects of a Given Type The first step of any read is to **get all objects** of a certain type in a realm. With this results collection, you can operate on all instances on a type or filter and sort to refine the results. ## Example\n\n ```csharp var projects = realm.All<Project>(); var tasks = realm.All<Task>(); \n``` ← [Create Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/create/ \"Previous Section\")[Filter and Sort Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/crud/write-transactions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Write Transactions - .NET SDK On this page * [Overview](#overview)\n* [Initiate a Transaction](#initiate-a-transaction)\n* [Check the Status of a Transaction](#check-the-status-of-a-transaction) ## Overview In addition to reading objects, you can **create**, **update** , and **delete**objects from a realm. Because these operations modify the state of the realm, we call them \"writes\", and all writes to Realm must be within a **transaction**. A transaction is a list of read and write operations that Realm treats as a single indivisible operation. In other words, a transaction is _all or nothing_: either all of the operations in the transaction succeed or none of the operations in the transaction take effect. **All writes must happen in a transaction.** A realm allows only one open transaction at a time. Realm blocks other writes on other threads until the open transaction is complete. Consequently, there is no race condition when reading values from the realm within a transaction. When you are done with your transaction, Realm either**commits** it or **cancels** it: * When Realm **commits** a transaction, Realm writes all changes to disk. For synced realms, the SDK queues the change for synchronization with Atlas App Services.\n* When Realm **cancels** a write transaction or an operation in the transaction causes an error, all changes are discarded (or \"rolled back\"). ### Initiate a Transaction The .NET SDK provides a simple API you can use for most writes. The[Write()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FWrite%5F%5F1%5FSystem%5FFunc%5F%5F%5F0%5F%5F) and[WriteAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FWriteAsync%5FSystem%5FAction%5FSystem%5FThreading%5FCancellationToken%5F) and methods wrap all commands into a single transaction and then commit the transaction. The `Write()` and `WriteAsync()` methods are shorthand for using the[BeginWrite()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FBeginWrite) and[Transaction.Commit()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Transaction.html#Realms%5FTransaction%5FCommit)methods, and their `Async` counterparts. In most cases, either of these two write methods will meet your needs. If you need finer control over the transaction, use `BeginWrite()` with one of these `Transaction` methods: * [Commit()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Transaction.html#Realms%5FTransaction%5FCommit)\n* [Dispose()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Transaction.html#Realms%5FTransaction%5FDispose)\n* [Rollback()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Transaction.html#Realms%5FTransaction%5FRollback) The following code shows how to use both approaches:\n\n ` ```csharp // Open a thread-safe transaction. var transaction = realm.BeginWrite(); // At this point, the TransactionState is \"Running\": // transaction.State == TransactionState.Running try {     // Perform a write op...     realm.Add(myDog);     // Do other work that needs to be included in     // this transaction     if (transaction.State == TransactionState.Running)     {         transaction.Commit();     } } catch (Exception ex) {     Console.WriteLine(ex.Message);     // Something went wrong; roll back the transaction     if (transaction.State != TransactionState.RolledBack &&         transaction.State != TransactionState.Committed)     {         transaction.Rollback();     }     transaction.Dispose(); } \n``` ## Note ### CancellationTokens As with most C# async methods, the[WriteAsync](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FWriteAsync%5FSystem%5FAction%5FSystem%5FThreading%5FCancellationToken%5F),[BeginWriteAsync](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FBeginWriteAsync%5FSystem%5FThreading%5FCancellationToken%5F), and [CommitAsync](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Transaction.html#Realms%5FTransaction%5FCommitAsync%5FSystem%5FThreading%5FCancellationToken%5F)methods can take a[CancellationToken](https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken?view=net-6.0)as a parameter, providing you with the option to cancel the operation before the process completes. ## Check the Status of a Transaction The SDK provides a [TransactionState](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Transaction.html#Realms%5FTransactionState)property with the current transaction status. You can use `TransactionState`to ensure you don't commit or rollback a transaction twice: ```csharp // Open a thread-safe transaction. var transaction = realm.BeginWrite(); // At this point, the TransactionState is \"Running\": // transaction.State == TransactionState.Running try {     // Perform a write op...     realm.Add(myDog);     // Do other work that needs to be included in     // this transaction     if (transaction.State == TransactionState.Running)     {         transaction.Commit();     } } catch (Exception ex) {     Console.WriteLine(ex.Message);     // Something went wrong; roll back the transaction     if (transaction.State != TransactionState.RolledBack &&         transaction.State != TransactionState.Committed)     {         transaction.Rollback();     }     transaction.Dispose(); } \n``` ← [Threading - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/threading/ \"Previous Section\")[React to Changes - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/react-to-changes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/crud/update/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Update Data - .NET SDK On this page * [Overview](#overview)\n* [Modify an Object](#modify-an-object)\n* [Upsert an Object](#upsert-an-object)\n* [Update a Collection](#update-a-collection) ## Overview Updates behave the same as other writes (like creating a new document). When updating documents, all writes must happen in a transaction. ## Example The following code shows how to run a transaction with the realm's write method. If the code in the callback throws an exception, Realm Database cancels the transaction. Otherwise, Realm Database commits the transaction. `| realm.Write(() =>                                         |\n| --------------------------------------------------------- |\n| {                                                         |\n| // Create someone to take care of some dogs.              |\n| var ali = new Person { Id = 1, Name = \"Ali\" };            |\n| realm.Add(ali);                                           |\n| // Find dogs younger than 2.                              |\n| var puppies = realm.All<Dog>().Where(dog => dog.Age < 2); |\n| // Loop through one by one to update.                     |\n| foreach (var puppy in puppies)                            |\n| {                                                         |\n| // Give all the puppies to Ali.                           |\n| puppy.Owner = ali;                                        |\n| }                                                         |\n| });                                                       | ` ## Modify an Object ## Example This code changes the dog's name to \"Wolfie\" and increments the age by 1: ```csharp // Open a thread-safe transaction. realm.Write(() => {     // Get a dog to update.     var dog = realm.All<Dog>().First();     // Update some properties on the instance.     // These changes are saved to the realm.     dog.Name = \"Wolfie\";     dog.Age += 1; }); \n``` ## Upsert an Object ## Example This code demonstrates how to upsert an object with realm. We create a new user named \"Drew\" and then update their name to \"Andy\" via upsert: ```csharp realm.Write(() => {     var drew = new Person { Id = 1234, Name = \"Drew\" };     // Add a new person to the realm. Since nobody with ID 1234\n\n     realm.Add(drew, update: true);     var andy = new Person { Id = 1234, Name = \"Andy\" };     // Judging by the ID, it's the same person, just with a different name.     // When `update` is true, you overwrite the original entry (i.e. Drew -> Andy).     realm.Add(andy, update: true); }); \n``` ## Update a Collection ## Example The following code demonstrates how to update a collection. Thanks to the [implicit inverse relationship](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/#std-label-dotnet-inverse-relationship) between the Dog's `owner` property and the Person's `dogs`property, Realm Database automatically updates Ali's list of dogs. ```csharp realm.Write(() => {     // Create someone to take care of some dogs.     var ali = new Person { Id = 1, Name = \"Ali\" };     realm.Add(ali);     // Find dogs younger than 2.     var puppies = realm.All<Dog>().Where(dog => dog.Age < 2);     // Loop through one by one to update.     foreach (var puppy in puppies)     {         // Give all the puppies to Ali.         puppy.Owner = ali;     } }); \n``` ← [Filter and Sort Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/filter/ \"Previous Section\")[Delete Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/crud/create/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create Data - .NET SDK On this page * [Overview](#overview)\n* [Create a New Object](#create-a-new-object) ## Overview When writing documents, all writes must happen in a transaction. ## Example The following code shows how to run a transaction with the realm's write method. If the code in the callback throws an exception, Realm Database cancels the transaction. Otherwise, Realm Database commits the transaction. `| realm.Write(() =>                                         |\n| --------------------------------------------------------- |\n| {                                                         |\n| // Create someone to take care of some dogs.              |\n| var ali = new Person { Id = 1, Name = \"Ali\" };            |\n| realm.Add(ali);                                           |\n| // Find dogs younger than 2.                              |\n| var puppies = realm.All<Dog>().Where(dog => dog.Age < 2); |\n| // Loop through one by one to update.                     |\n| foreach (var puppy in puppies)                            |\n| {                                                         |\n| // Give all the puppies to Ali.                           |\n| puppy.Owner = ali;                                        |\n| }                                                         |\n| });                                                       | ` ## Create a New Object ## Example This code demonstrates how to create an object with Realm Database: ```csharp // Open a thread-safe transaction. realm.Write(() => {     // Instantiate a class, as normal.     var dog = new Dog { Name = \"Max\", Age = 5 };     // Add the instance to the realm.     realm.Add(dog); }); \n``` ← [CRUD - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/ \"Previous Section\")[Read Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/read/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/crud/threading/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Threading - .NET SDK On this page * [Three Rules to Follow](#three-rules-to-follow)\n* [Communication Across Threads](#communication-across-threads)\n* [Refreshing Realms](#refreshing-realms)\n* [Asynchronous Writes](#asynchronous-writes)\n* [Frozen Objects](#frozen-objects)\n* [Realm's Threading Model in Depth](#realm-s-threading-model-in-depth)\n* [Compared and Contrasted with Git](#compared-and-contrasted-with-git)\n* [Internal Structure](#internal-structure)\n* [Summary](#summary) To make your C#/.NET apps fast and responsive, you must balance the computing time needed to lay out the visuals and handle user interactions with the time needed to process your data and run your business logic. Typically, app developers spread this work across multiple threads: the main or UI thread for all of the user interface-related work, and one or more background threads to compute heavier workloads before sending it to the UI thread for presentation. By offloading heavy work to background threads, the UI thread can remain highly responsive regardless of the size of the workload. But it can be notoriously difficult to write thread-safe, performant, and maintainable multithreaded code that avoids issues like deadlocking and race conditions. Realm aims to simplify this for you. ## Important ### SynchronizationContext Threads Throughout this page, we refer to the \"main thread\" (or \"UI thread\") and \"background threads\". To be more accurate, any mention of the main or UI thread refers to **any thread with a \\`\\`SynchronizationContext\\`\\`**, while those threads without a SynchronizationContext are considered background threads. ## Three Rules to Follow Before exploring Realm's tools for multithreaded apps, you need to understand and follow these three rules: Don't lock to read: Realm Database's [Multiversion Concurrency Control (MVCC)](#std-label-dotnet-mvcc)architecture eliminates the need to lock for read operations. The values you read will never be corrupted or in a partially-modified state. You can freely read from the same Realm file on any thread without the need for locks or mutexes. Unnecessarily locking would be a performance bottleneck since each thread might need to wait its turn before reading. Avoid synchronous writes on the UI thread: You can [write](https://mongodb.com/docs/realm/sdk/dotnet/crud/create/#std-label-dotnet-realm-database-writes) to a Realm file from any thread, but there can be only one writer at a time. Consequently, synchronous write transactions block each other. A synchronous write on the UI thread may result in your app appearing unresponsive while it waits for a write on a background thread to complete. If you are using [Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), avoid synchronous writes on the UI thread as Sync writes on a background thread. Instead, use `realm.WriteAsync`. Don't pass live objects, collections, or realms to other threads: Live objects, collections, and realm instances are**thread-confined**: that is, they are only valid on the thread on which they were created. Practically speaking, this means you cannot pass live instances to other threads. However, Realm Database offers several mechanisms for[sharing objects across threads.](#std-label-dotnet-communication-across-threads) ## Communication Across Threads To access the same Realm file from different threads, you must instantiate a realm instance on every thread that needs access. As long as you specify the same configuration, all realm instances will map to the same file on disk. One of the key rules when working with Realm Database in a multithreaded environment is that objects are thread-confined: **you cannot access the instances of a realm, collection, or object that originated on other threads.**Realm Database's [Multiversion Concurrency Control (MVCC)](#std-label-dotnet-mvcc)architecture means that there could be many active versions of an object at any time. Thread-confinement ensures that all instances in that thread are of the same internal version. When you need to communicate across threads, you have several options depending on your use case:\n\n ## Refreshing Realms On the main UI thread (or any thread with a run loop), Realm automatically refreshes objects at the start of every run loop iteration. Between run loop iterations, you will be working on the snapshot, so individual methods always see a consistent view and never have to worry about what happens on other threads. When you initially open a realm on a thread, its state will be the most recent successful write commit, and it will remain on that version until refreshed. If a thread has no run loop (which is generally the case in a background thread), then the[Realm.Refresh()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FRefresh)method must be called manually in order to advance the transaction to the most recent state. Realms are also refreshed when write transactions are committed with[Transaction.Commit().](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Transaction.html#Realms%5FTransaction%5FCommit) ## Note Failing to refresh Realms on a regular basis could lead to some transaction versions becoming \"pinned\", preventing Realm from reusing the disk space used by that version, leading to larger file sizes. ## Asynchronous Writes The [WriteAsync()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.Realm.html#Realms%5FRealm%5FWriteAsync%5FSystem%5FAction%5FRealms%5FRealm%5F%5F)method provides a simple way to offload the UI thread by performing writes in a background thread. When run on the UI thread, Realm creates a temporary realm instance that is passed to the Lambda function, performs the write, disposes of the temporary instance, and then calls `Realm.Refresh()` on the UI thread to update the realm. When `WriteAsync()` is run in a background thread, Realm forwards the call to `Write()` on the current background thread. ## Note In general, since realm writes are very fast, we recommend using the`Write()` method when only a few values change at a time (like responding to user interactions.) Conversely, the `WriteAsync()` method is useful in scenarios where there are hundreds or thousands of changes. For example, fetching objects from the network, or batch-updating multiple objects, can be time-consuming, and performing the changes synchronously might lead to interface jitters and a poor user experience. Using `WriteAsync()`prevents this. ## Frozen Objects Live, thread-confined objects work fine in most cases. However, some apps -- those based on reactive, event stream-based architectures, for example -- need to send immutable copies around to many threads for processing before ultimately ending up on the UI thread. Making a deep copy every time would be expensive, and Realm Database does not allow live instances to be shared across threads. In this case, you can **freeze** objects, collections, and realms. Freezing creates an immutable view of a specific object, collection, or realm that still exists on disk and does not need to be deeply copied when passed around to other threads. You can freely share a frozen object across threads without concern for thread issues. When working with frozen objects, an attempt to do any of the following throws an exception: * Opening a write transaction on a frozen realm.\n* Modifying a frozen object.\n* Adding a change listener to a frozen realm, collection, or object. Once frozen, it is not possible to unfreeze an object. You can use the `IsFrozen` method to check if the object is frozen. This method is always thread-safe. To modify a frozen object, query for it on an unfrozen realm, then modify it. Frozen objects are not live and do not automatically update. They are effectively snapshots of the object state at the time of freezing. When you freeze a realm, its child objects also become frozen. Frozen objects remain valid as long as the live realm that spawned them stays open. Therefore, avoid closing the live realm until all threads are done with the frozen objects. You can close frozen realm before the live realm is closed. ## Important ### On caching frozen objects Caching too many frozen objects can have a negative impact on the realm file size. \"Too many\" depends on your specific target device and the size of your Realm objects. If you need to cache a large number of versions, consider copying what you need out of the realm instead. ## Realm's Threading Model in Depth\n\n ### Compared and Contrasted with Git If you are familiar with a distributed version control system like [Git](https://git-scm.com/), you may already have an intuitive understanding of MVCC. Two fundamental elements of Git are: * Commits, which are atomic writes.\n* Branches, which are different versions of the commit history. Similarly, Realm Database has atomically-committed writes in the form of [transactions](https://mongodb.com/docs/realm/sdk/dotnet/crud/create/#std-label-dotnet-realm-database-writes). Realm Database also has many different versions of the history at any given time, like branches. Unlike Git, which actively supports distribution and divergence through forking, a realm only has one true latest version at any given time and always writes to the head of that latest version. Realm Database cannot write to a previous version. This makes sense: your data should converge on one latest version of the truth. ### Internal Structure A realm is implemented using a [B+ tree](https://en.wikipedia.org/wiki/B%2B%5Ftree) data structure. The top-level node represents a version of the realm; child nodes are objects in that version of the realm. The realm has a pointer to its latest version, much like how Git has a pointer to its HEAD commit. Realm Database uses a copy-on-write technique to ensure[isolation](https://en.wikipedia.org/wiki/Isolation%5F%28database%5Fsystems%29) and[durability](https://en.wikipedia.org/wiki/Durability%5F%28database%5Fsystems%29). When you make changes, Realm Database copies the relevant part of the tree for writing. Realm Database then commits the changes in two phases: * Realm Database writes changes to disk and verifies success.\n* Realm Database then sets its latest version pointer to point to the newly-written version. This two-step commit process guarantees that even if the write failed partway, the original version is not corrupted in any way because the changes were made to a copy of the relevant part of the tree. Likewise, the realm's root pointer will point to the original version until the new version is guaranteed to be valid. ## Example The following diagram illustrates the commit process: ![Realm Database copies the relevant part of the tree for writes, then replaces the latest version by updating a pointer.](https://mongodb.com/docs/realm/images/mvcc-diagram.png) click to enlarge 1. The realm is structured as a tree. The realm has a pointer to its latest version, V1.\n2. When writing, Realm Database creates a new version V2 based on V1\\. Realm Database makes copies of objects for modification (A 1, C 1), while links to unmodified objects continue to point to the original versions (B, D).\n3. After validating the commit, Realm Database updates the realm's pointer to the new latest version, V2\\. Realm Database then discards old nodes no longer connected to the tree. Realm Database uses zero-copy techniques like memory mapping to handle data. When you read a value from the realm, you are virtually looking at the value on the actual disk, not a copy of it. This is the basis for[live objects](https://mongodb.com/docs/realm/sdk/dotnet/realm-database/#std-label-dotnet-live-object). This is also why a realm head pointer can be set to point to the new version after the write to disk has been validated. ## Summary\n\n ← [Delete Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/delete/ \"Previous Section\")[Write Transactions - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/write-transactions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/realm-database/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - Swift SDK On this page * [Database Internals](#database-internals)\n* [Native Database Engine](#native-database-engine)\n* [Realm Files](#realm-files)\n* [Copy-on-Write: The Secret Sauce of Data Versioning](#copy-on-write--the-secret-sauce-of-data-versioning)\n* [Memory Mapping](#memory-mapping)\n* [Compaction](#compaction)\n* [ACID Compliance](#acid-compliance)\n* [Features](#features)\n* [Queries](#queries)\n* [Encryption](#encryption)\n* [Indexes](#indexes)\n* [Schemas](#schemas)\n* [Persistent or In-Memory Realms](#persistent-or-in-memory-realms)\n* [Atlas Device Sync](#atlas-device-sync)\n* [Realm vs Other Databases](#realm-vs-other-databases)\n* [Live Queries](#live-queries)\n* [Live Object](#live-object)\n* [Realm Swift SDK Examples](#realm-swift-sdk-examples)\n* [Examples by the Realm Engineering Team](#examples-by-the-realm-engineering-team)\n* [Community Examples](#community-examples) Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) This page explains some of the implementation details and inner workings of Realm Database and Device Sync. This page is for you if you are: * a developer interested in learning more about Realm Database\n* comparing Realm Database with competing databases\n* trying to understand how Realm Database works with Device Sync This explanation begins with a deep dive into database internals, continues with a high-level introduction to some of the features of Realm Database, and wraps up with some of the differences of working with Device Sync and the local version of Realm Database. ## Database Internals Realm Database uses a completely unique database engine, file format, and design. This section describes some of the high-level details of those choices. This section applies to both the device-local version of Realm Database as well as the networked Device Sync version. Differences between the local database and the synchronized database are explained in the Atlas Device Sync section. ### Native Database Engine Realm Database is an entire database written from scratch in C++, instead of building on top of an underlying database engine like SQLite. Realm Database's underlying storage layer uses[B+ trees](https://en.wikipedia.org/wiki/B%2B%5Ftree) to organize objects. As a result, Realm Database controls optimizations from the storage level all the way up to the access level. Realm Database stores data in **realms**: collections of heterogeneous realm objects. You can think of each realm as a database. Each object in a realm is equivalent to a row in a SQL database table or a MongoDB document. Unlike SQL, realms do not separate different object types into individual tables. Realm Database stores objects as groups of property values. We call this column-based storage. This means that queries or writes for individual objects can be slower than row-based storage equivalents when unindexed, but querying a single field across multiple objects or fetching multiple objects can be much faster due to spatial locality and in-CPU vector operations.\n\n ### Realm Files Realm Database persists data in files saved on device storage. The database uses several kinds of file: * **realm files**, suffixed with \"realm\", e.g. `default.realm`: contain object data.\n* **lock files**, suffixed with \"lock\", e.g. `default.realm.lock`: keep track of which versions of data in a realm are actively in use. This prevents realm from reclaiming storage space that is still used by a client application.\n* **note files**, suffixed with \"note\", e.g. `default.realm.note`: enable inter-thread and inter-process notifications.\n* **management files**, suffixed with \"management\", e.g. `default.realm.management`: internal state management. Realm files contain object data with the following data structures: Groups, Tables, Cluster Trees, and Clusters. Realm Database organizes these data structures into a tree structure with the following form: * The top level, known as a Group, stores object metadata, a transaction log, and a collection of Tables.\n* Each class in the realm schema corresponds to a Table within the top-level Group.\n* Each Table contains a Cluster Tree, an implementation of a B+ tree.\n* Leaves on the Cluster Tree are called Clusters. Each contains a range of objects sorted by key value.\n* Clusters store objects as collections of columns.\n* Each column contains data for a single property for multiple instances of a given object. Columns are arrays of data with uniformly sized values.\n* Columns store data in one of the following sizes: 1, 2, 4, 8, 16, 32, or 64 bits. Each column uses one value size, determined by the largest value. Since pointers refer to memory addresses, objects written to persistent files cannot store references as pointers. Instead, realm files refer to data using the offset from the beginning of the file. We call this a ref. As Realm Database uses memory mapping to read and write data, database operations translate these refs from offsets to memory pointers when navigating database structures. ### Copy-on-Write: The Secret Sauce of Data Versioning Realm Database uses a technique called **copy-on-write**, which copies data to a new location on disk for every write operation instead of overwriting older data on disk. Once the new copy of data is fully written, the database updates existing references to that data. Older data is only garbage collected when it is no longer referenced or actively in use by a client application. Because of copy-on-write, older copies of data remain valid, since all of the references in those copies still point to other valid data. Realm Database leverages this fact to offer multiple versions of data simultaneously to different threads in client applications. Most applications tie data refreshes to the repaint cycle of the looper thread that controls the UI, since data only needs to refresh as often as the UI does. Longer-running procedures on background threads, such as large write operations, can work with a single version of data for a longer period of time before committing their changes. ### Memory Mapping Writes use [memory mapping](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) to avoid copying data back and forth from memory to storage. Accessors and mutators read and write to disk via memory mapping. As a result, object data is never stored on the stack or heap of your app. By default, data is memory-mapped as read-only to prevent accidental writes. Realm Database uses operating system level paging, trusting each operating system to implement memory mapping and persistence better than a single library could on its own. ### Compaction Realm Database automatically reuses free space that is no longer needed after database writes. However, realm files never shrink automatically, even if the amount of data stored in your realm decreases significantly. Compact your realm to optimize storage space and decrease file size if possible. You should compact your realms occasionally to keep them at an optimal size. You can do this manually, or by configuring your realms to compact on launch. However, Realm Database reclaims unused space for future writes, so compaction is only an optimization to conserve space on-device. ### ACID Compliance Realm Database guarantees that transactions are [ACID](https://en.wikipedia.org/wiki/ACID) compliant. This means that all committed write operations are guaranteed to be valid and that clients don't see transient states in the event of a system crash. Realm Database complies with ACID with the following design choices:\n\n ## Features Realm Database supports many popular database features. ### Queries You can query Realm Database using platform-native queries or a raw query language that works across platforms. ### Encryption Realm Database supports on-device realm encryption. Since memory mapping does not support encryption, encrypted realms use a simulated in-library form of memory mapping instead. ## Note Realm forbids opening the same encrypted realm from multiple processes. Attempting to do so will throw the error: \"Encrypted interprocess sharing is currently unsupported.\" ### Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time. ### Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, do not require a migration. After you increment the local schema version, you can begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. See your SDK's documentation for more information on migrations. ### Persistent or In-Memory Realms You can use Realm Database to store data persistently on disk, or ephemerally in memory. Ephemeral realms can be useful in situations where you don't need to persist data between application instances, such as when a user works in a temporary workspace. ## Atlas Device Sync Device Sync adds network synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. Device Sync relies on a worker client that communicates with your application backend in a dedicated thread in your application. Additionally, synced realms keep a history of changes to contained objects. Sync uses this history to resolve conflicts between client changes and backend changes. Applications that use Device Sync define their schema on the backend using[JSON Schema](https://json-schema.org/learn/getting-started-step-by-step.html). Client applications must match that backend schema to synchronize data. However, if you prefer to define your initial schema in your application's programming language, you can use [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to create a backend JSON Schema based on native SDK objects as you write your application. However, once your application is used for production purposes, you should alter your schema using JSON Schema on the backend. ## Realm vs Other Databases The Realm data model is similar to both relational and document databases but has distinct differences from both. To underscore these differences, it's helpful to highlight what a realm **is not**: A realm is not a single, application-wide database. Applications based on other database systems generally store all of their data in a single database. Apps often split data across multiple realms to organize data more efficiently and to enforce access controls. A realm is not a relational table. Normalized tables in relational databases only store one type of information, such as street addresses or items in a store inventory. A realm can contain any number of object types that are relevant to a given domain. A realm is not a collection of schemaless documents. Document databases don't necessarily enforce a strict schema for the data in each collection. While similar to documents in form, every Realm object conforms to a schema for a specific object type in the realm. An object cannot contain a property that is not described by its schema. ## Live Queries You can read back the data that you have [stored](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-write-transactions) in Realm Database by finding, filtering, and sorting objects. You can optionally [section these results by a key path](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-ios-section-query-results), making it easier to populate sectioned tables.\n\n ### Live Object All Realm objects are **live objects**, which means they automatically update whenever they're modified. Realm emits a[notification event](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes) whenever any property changes. You can use live objects to work with object-oriented data natively without an [ORM](https://en.wikipedia.org/wiki/Object-relational%5Fmapping) tool. Live objects are direct proxies to the underlying stored data, which means that a live object doesn't directly contain data. Instead, a live object always references the most up-to-date data on disk and [lazy loads](https://en.wikipedia.org/wiki/Lazy%5Floading) property values when you access them from a[collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections). This means that a realm can contain many objects but only pay the performance cost for data that the application is actually using. Valid write operations on a live object automatically persist to the realm and propagate to any other synced clients. You do not need to call an update method, modify the realm, or otherwise \"push\" updates. ## Realm Swift SDK Examples Each of the pages in the Swift SDK documentation contain example code showing a specific task. The Quick Starts folder contains several example applications you can run to experiment with different ways of using Realm Database. Beyond the examples in this documentation, the Realm community has created many applications that demonstrate the usage of the Realm Swift SDK. ## Note These community examples are not part of the documentation, and may not be actively maintained or show the most up-to-date way of working with Realm. ### Examples by the Realm Engineering Team The [realm-swift example applications](https://github.com/realm/realm-swift/tree/master/examples) provide examples for both iOS and macOS that demonstrate how to use Realm features such as migrations and encryption. The examples also demonstrate how to combine Realm with common iOS concepts like `UITableViewController`. ### Community Examples * [Performing a Client Reset with Swift by \"pmanna-tse-realm\"](https://github.com/mongodb/realm-practice/tree/main/swift/RealmPractice) ← [Realm Swift SDK](https://mongodb.com/docs/realm/sdk/swift/ \"Previous Section\")[Install Realm for iOS, macOS, tvOS, and watchOS](https://mongodb.com/docs/realm/sdk/swift/install/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - Swift SDK MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Test and Debug - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/test-and-debug/ \"Previous Section\")[API Reference - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/api-reference/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/crud/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete Data - .NET SDK On this page * [Delete an Object](#delete-an-object)\n* [Delete Multiple Objects](#delete-multiple-objects)\n* [Delete an Object and its Dependent Objects](#delete-an-object-and-its-dependent-objects)\n* [Delete All Object of a Specific Type](#delete-all-object-of-a-specific-type)\n* [Delete All Objects in a Realm](#delete-all-objects-in-a-realm) ## Delete an Object ## Example The following code shows how to delete one object from its realm: `| realm.Write(() =>                      |\n| -------------------------------------- |\n| {                                      |\n| // Remove the instance from the realm. |\n| realm.Remove(dog);                     |\n| // Discard the reference.              |\n| dog = null;                            |\n| });                                    | ` ## Delete Multiple Objects ## Example The following code demonstrates how to delete a collection from a realm: ```csharp realm.Write(() => {     // Find dogs younger than 2 years old.     var puppies = realm.All<Dog>().Where(dog => dog.Age < 2);     // Remove the collection from the realm.     realm.RemoveRange(puppies); }); \n``` ## Delete an Object and its Dependent Objects Sometimes, you have [dependent objects](https://mongodb.com/docs/realm/sdk/dotnet/model-data/relationships/#std-label-dotnet-client-relationships) that you want to delete when you delete the parent object. We call this a **chaining delete**. Realm Database will not delete the dependent objects for you. If you do not delete the objects yourself, they will remain orphaned in your realm. Whether or not this is a problem depends on your application's needs. Currently, the best way to delete dependent objects is to iterate through the dependencies and delete them before deleting the parent object. ## Example The following code demonstrates how to perform a chaining delete by first deleting all of Ali's dogs, then deleting Ali: ```csharp realm.Write(() => {     // Remove all of Ali's dogs.     realm.RemoveRange(ali.Dogs);     // Remove Ali.     realm.Remove(ali); }); \n``` ## Delete All Object of a Specific Type Realm Database supports deleting all instances of a[Realm type](https://mongodb.com/docs/realm/sdk/dotnet/model-data/object-models-and-schemas/#std-label-dotnet-objects) from a realm. ## Example The following code demonstrates how to delete all Dog instances from a realm: ```csharp realm.Write(() => {     // Remove all instances of Dog from the realm.     realm.RemoveAll<Dog>(); }); \n``` ## Delete All Objects in a Realm It is possible to delete all objects from the realm. This does not affect the schema of the realm. This is useful for quickly clearing out your realm while prototyping. ## Example The following code demonstrates how to delete everything from a realm: ```csharp realm.Write(() => {     // Remove all objects from the realm.     realm.RemoveAll(); }); \n``` ← [Update Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/update/ \"Previous Section\")[Threading - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/threading/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/realm-files/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Work with Realm Files - Swift SDK * [Configure & Open a Realm](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/)\n* [Delete a Realm](https://mongodb.com/docs/realm/sdk/swift/realm-files/delete-a-realm/)\n* [Bundle a Realm](https://mongodb.com/docs/realm/sdk/swift/realm-files/bundle-a-realm/)\n* [Reduce Realm File Size](https://mongodb.com/docs/realm/sdk/swift/realm-files/compacting/)\n* [Encrypt a Realm](https://mongodb.com/docs/realm/sdk/swift/realm-files/encrypt-a-realm/)\n* [Build for tvOS](https://mongodb.com/docs/realm/sdk/swift/realm-files/tvos/) ← [Quick Start - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/quick-start/ \"Previous Section\")[Configure & Open a Realm - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/crud/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Swift SDK * [Create](https://mongodb.com/docs/realm/sdk/swift/crud/create/)\n* [Read](https://mongodb.com/docs/realm/sdk/swift/crud/read/)\n* [Update](https://mongodb.com/docs/realm/sdk/swift/crud/update/)\n* [Delete](https://mongodb.com/docs/realm/sdk/swift/crud/delete/)\n* [Threading](https://mongodb.com/docs/realm/sdk/swift/crud/threading/)\n* [Filter Data](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/) ← [Model Data with Device Sync - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/model-data-device-sync/ \"Previous Section\")[CRUD - Create - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Data Between Devices - Swift SDK * [Add Sync to an App](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/)\n* [Configure & Open a Synced Realm](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/)\n* [Manage Flexible Sync Subscriptions](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/)\n* [Write to a Synced Realm](https://mongodb.com/docs/realm/sdk/swift/sync/write-to-synced-realm/)\n* [Handle Sync Errors](https://mongodb.com/docs/realm/sdk/swift/sync/handle-sync-errors/)\n* [Sync Data in the Background](https://mongodb.com/docs/realm/sdk/swift/sync/background-sync/)\n* [Suspend or Resume a Sync Session](https://mongodb.com/docs/realm/sdk/swift/sync/sync-session/)\n* [Check Upload & Download Progress](https://mongodb.com/docs/realm/sdk/swift/sync/sync-progress/)\n* [Check the Network Connection](https://mongodb.com/docs/realm/sdk/swift/sync/network-connection/)\n* [Set the Client Log Level](https://mongodb.com/docs/realm/sdk/swift/sync/log-level/)\n* [Record Realm Events](https://mongodb.com/docs/realm/sdk/swift/sync/event-library/)\n* [Stream Data to Atlas](https://mongodb.com/docs/realm/sdk/swift/sync/stream-data-to-atlas/) ← [Manage User API Keys - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/manage-user-api-keys/ \"Previous Section\")[Add Device Sync to an App - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/api-reference/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # API Reference - Swift SDK ← [Telemetry - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/telemetry/ \"Previous Section\")[Application Services - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/application-services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/model-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Model Data - Swift SDK * [Define an Object Model](https://mongodb.com/docs/realm/sdk/swift/model-data/define-a-realm-object-model/)\n* [Change an Object Model](https://mongodb.com/docs/realm/sdk/swift/model-data/change-an-object-model/)\n* [Model Data with Device Sync](https://mongodb.com/docs/realm/sdk/swift/model-data/model-data-device-sync/) ← [Build for tvOS](https://mongodb.com/docs/realm/sdk/swift/realm-files/tvos/ \"Previous Section\")[Define a Realm Object Schema - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/define-a-realm-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database with SwiftUI QuickStart On this page * [Prerequisites](#prerequisites)\n* [Overview](#overview)\n* [Get Started](#get-started)\n* [Define Models](#define-models)\n* [Views and Observed Objects](#views-and-observed-objects)\n* [Integrate Atlas Device Sync](#integrate-atlas-device-sync)\n* [Authenticate Users with Atlas App Services](#authenticate-users-with-atlas-app-services)\n* [Complete Code](#complete-code) ## Prerequisites * Have Xcode 12.4 or later (minimum Swift version 5.3.1).\n* Create a new Xcode project using the SwiftUI \"App\" template with a minimum iOS target of 15.0.\n* [Install the Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/install/#std-label-ios-install) This SwiftUI app requires a minimum SDK version of 10.19.0. ## Overview ## Tip ### See also: Use Realm Database with SwiftUI This page provides a small working app to get you up and running with Realm and SwiftUI quickly. If you'd like to see additional examples, including more explanation about Realm's SwiftUI features, see:[SwiftUI - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/swiftui/#std-label-ios-swiftui-examples) This page contains all of the code for a working Realm and SwiftUI app. The app starts on the **ItemsView**, where you can edit a list of items: * Press the Add button on the bottom right of the screen to add randomly-generated items.\n* Press the Edit button on the top right to modify the list order, which the app persists in the realm.\n* You can also swipe to delete items. When you have items in the list, you can press one of the items to navigate to the **ItemDetailsView**. This is where you can modify the item name or mark it as a favorite: * Press the text field in the center of the screen and type a new name. When you press Return, the item name should update across the app.\n* You can also toggle its favorite status by pressing the heart toggle in the top right. ## Tip This guide optionally integrates with [Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync). See[Integrate Atlas Device Sync](#std-label-swiftui-integrate-with-sync) below. ### Get Started We assume you have created an Xcode project with the SwiftUI \"App\" template. Open the main Swift file and delete all of the code inside, including any `@main` `App` classes that Xcode generated for you. At the top of the file, import the Realm and SwiftUI frameworks: `| import RealmSwift |\n| ----------------- |\n| import SwiftUI    | ` ## Tip Just want to dive right in with the complete code? Jump to[Complete Code](#std-label-swiftui-complete-code) below. ### Define Models A common Realm data modeling use case is to have \"things\" and \"containers of things\". This app defines two related Realm object models: item and itemGroup. An item has two user-facing properties: * A randomly generated-name, which the user can edit.\n* An `isFavorite` boolean property, which shows whether the user \"favorited\" the item. An itemGroup contains items. You can extend the itemGroup to have a name and an association with a specific user, but that's out of scope of this guide. Paste the following code into your main Swift file to define the models: Because Flexible Sync does not automatically include linked objects, we must add `ownerId` to both objects. You can omit `ownerId` if you only want to use a local realm. ```swift /// Random adjectives for more interesting demo item names let randomAdjectives = [     \"fluffy\", \"classy\", \"bumpy\", \"bizarre\", \"wiggly\", \"quick\", \"sudden\",     \"acoustic\", \"smiling\", \"dispensable\", \"foreign\", \"shaky\", \"purple\", \"keen\",     \"aberrant\", \"disastrous\", \"vague\", \"squealing\", \"ad hoc\", \"sweet\" ] /// Random noun for more interesting demo item names\n\n     \"floor\", \"monitor\", \"hair tie\", \"puddle\", \"hair brush\", \"bread\",     \"cinder block\", \"glass\", \"ring\", \"twister\", \"coasters\", \"fridge\",     \"toe ring\", \"bracelet\", \"cabinet\", \"nail file\", \"plate\", \"lace\",     \"cork\", \"mouse pad\" ] /// An individual item. Part of an `ItemGroup`. final class Item: Object, ObjectKeyIdentifiable {     /// The unique ID of the Item. `primaryKey: true` declares the     /// _id member as the primary key to the realm.     @Persisted(primaryKey: true) var _id: ObjectId     /// The name of the Item, By default, a random name is generated.     @Persisted var name = \"\\(randomAdjectives.randomElement()!) \\(randomNouns.randomElement()!)\"     /// A flag indicating whether the user \"favorited\" the item.     @Persisted var isFavorite = false     /// Users can enter a description, which is an empty string by default     @Persisted var itemDescription = \"\"         /// The backlink to the `ItemGroup` this item is a part of.     @Persisted(originProperty: \"items\") var group: LinkingObjects<ItemGroup>         /// Store the user.id as the ownerId so you can query for the user's objects with Flexible Sync     /// Add this to both the `ItemGroup` and the `Item` objects so you can read and write the linked objects.     @Persisted var ownerId = \"\" } /// Represents a collection of items. final class ItemGroup: Object, ObjectKeyIdentifiable {     /// The unique ID of the ItemGroup. `primaryKey: true` declares the     /// _id member as the primary key to the realm.     @Persisted(primaryKey: true) var _id: ObjectId     /// The collection of Items in this group.     @Persisted var items = RealmSwift.List<Item>()         /// Store the user.id as the ownerId so you can query for the user's objects with Flexible Sync     /// Add this to both the `ItemGroup` and the `Item` objects so you can read and write the linked objects.     @Persisted var ownerId = \"\" } \n``` ### Views and Observed Objects The entrypoint of the app is the **ContentView** class that derives from`SwiftUI.App`. For now, this always displays the**LocalOnlyContentView**. Later, this will show the **SyncContentView**when Device Sync is enabled. ```swift /// The main screen that determines whether to present the SyncContentView or the LocalOnlyContentView. /// For now, it always displays the LocalOnlyContentView. @main struct ContentView: SwiftUI.App {     var body: some Scene {         WindowGroup {             LocalOnlyContentView()         }     } } \n``` ## Tip You can use a realm other than the default realm by passing an environment object from higher in the View hierarchy: ```swift LocalOnlyContentView()   .environment(\\.realmConfiguration, Realm.Configuration( /* ... */ )) \n``` The LocalOnlyContentView has an [@ObservedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedResults.html) itemGroups. This implicitly uses the default realm to load all itemGroups when the view appears. This app only expects there to ever be one itemGroup. If there is an itemGroup in the realm, the LocalOnlyContentView renders an **ItemsView** for that itemGroup. If there is no itemGroup already in the realm, then the LocalOnlyContentView displays a ProgressView while it adds one. Because the view observes the itemGroups thanks to the `@ObservedResults` property wrapper, the view immediately refreshes upon adding that first itemGroup and displays the ItemsView. ```swift /// The main content view if not using Sync. struct LocalOnlyContentView: View {     @State var searchFilter: String = \"\"     // Implicitly use the default realm's objects(ItemGroup.self)\n\n         var body: some View {         if let itemGroup = itemGroups.first {             // Pass the ItemGroup objects to a view further             // down the hierarchy             ItemsView(itemGroup: itemGroup)         } else {             // For this small app, we only want one itemGroup in the realm.             // You can expand this app to support multiple itemGroups.             // For now, if there is no itemGroup, add one here.             ProgressView().onAppear {                 $itemGroups.append(ItemGroup())             }         }     } } \n``` ## Tip Starting in SDK version 10.12.0, you can use an optional key path parameter with `@ObservedResults` to filter change notifications to only those occurring on the provided key path or key paths. For example: ``` @ObservedResults(MyObject.self, keyPaths: [\"myList.property\"]) \n``` The ItemsView receives the itemGroup from the parent view and stores it in an [@ObservedRealmObject](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedRealmObject.html)property. This allows the ItemsView to \"know\" when the object has changed regardless of where that change happened. The ItemsView iterates over the itemGroup's items and passes each item to an**ItemRow** for rendering as a list. To define what happens when a user deletes or moves a row, we pass the`remove` and `move` methods of the Realm[List](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/List.html) as the handlers of the respective remove and move events of the SwiftUI List. Thanks to the`@ObservedRealmObject` property wrapper, we can use these methods without explicitly opening a write transaction. The property wrapper automatically opens a write transaction as needed. ```swift /// The screen containing a list of items in an ItemGroup. Implements functionality for adding, rearranging, /// and deleting items in the ItemGroup. struct ItemsView: View {     @ObservedRealmObject var itemGroup: ItemGroup     /// The button to be displayed on the top left.     var leadingBarButton: AnyView?     var body: some View {         NavigationView {             VStack {                 // The list shows the items in the realm.                 List {                     ForEach(itemGroup.items) { item in                         ItemRow(item: item)                     }.onDelete(perform: $itemGroup.items.remove)                     .onMove(perform: $itemGroup.items.move)                 }                 .listStyle(GroupedListStyle())                     .navigationBarTitle(\"Items\", displayMode: .large)                     .navigationBarBackButtonHidden(true)                     .navigationBarItems(                         leading: self.leadingBarButton,\n\n                         trailing: EditButton())                 // Action bar at bottom contains Add button.                 HStack {                     Spacer()                     Button(action: {                         // The bound collection automatically                         // handles write transactions, so we can                         // append directly to it.                         $itemGroup.items.append(Item())                     }) { Image(systemName: \"plus\") }                 }.padding()             }         }     } } \n``` Finally, the **ItemRow** and **ItemDetailsView** classes use the`@ObservedRealmObject` property wrapper with the item passed in from above. These classes demonstrate a few more examples of how to use the property wrapper to display and update properties. ```swift /// Represents an Item in a list. struct ItemRow: View {     @ObservedRealmObject var item: Item     var body: some View {         // You can click an item in the list to navigate to an edit details screen.         NavigationLink(destination: ItemDetailsView(item: item)) {             Text(item.name)             if item.isFavorite {                 // If the user \"favorited\" the item, display a heart icon                 Image(systemName: \"heart.fill\")             }         }     } } /// Represents a screen where you can edit the item's name. struct ItemDetailsView: View {     @ObservedRealmObject var item: Item     var body: some View {         VStack(alignment: .leading) {             Text(\"Enter a new name:\")             // Accept a new name             TextField(\"New name\", text: $item.name)                 .navigationBarTitle(item.name)                 .navigationBarItems(trailing: Toggle(isOn: $item.isFavorite) {                     Image(systemName: item.isFavorite ? \"heart.fill\" : \"heart\")                 })         }.padding()     } } \n``` ## Tip `@ObservedRealmObject` is a frozen object. If you want to [modify the properties](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-modify-frozen-object) of an `@ObservedRealmObject`directly in a write transaction, you must `.thaw()` it first. At this point, you have everything you need to work with Realm Database and SwiftUI. Test it out and see if everything is working as expected. Read on to learn how to integrate this app with Device Sync. ## Integrate Atlas Device Sync\n\n * [Create an App Services App.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enable anonymous authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication-configuration)\n* [Enable Device Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync)  \n   1. Choose [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync)  \n   2. Specify a cluster and database.  \n   3. Turn on Development Mode.  \n   4. Use `ownerId` as the queryable field.  \n   5. Use these permissions:  \n   ```  \n   {  \n     \"rules\": {},  \n     \"defaultRoles\": [  \n       {  \n         \"name\": \"owner-read-write\",  \n         \"applyWhen\": {},  \n         \"read\": {  \n           \"ownerId\": \"%%user.id\"  \n         },  \n         \"write\": {  \n           \"ownerId\": \"%%user.id\"  \n         }  \n       }  \n     ]  \n   }  \n   ```  \n   6. Enable Sync, and deploy your application updates. ## Tip The Sync version of this app changes the app flow a bit. The first screen becomes the **LoginView**. When you press the Log in button, the app navigates to the ItemsView, where you see the synced list of items in a single itemGroup. At the top of the source file, initialize an optional [Realm app](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/App.html) with [your App ID:](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ```swift // MARK: Atlas App Services (Optional) // The App Services App. Change YOUR_APP_SERVICES_APP_ID_HERE to your App Services App ID. // If you don't have a App Services App and don't wish to use Sync for now, // you can change this to: //   let app: RealmSwift.App? = nil let app: RealmSwift.App? = RealmSwift.App(id: YOUR_APP_SERVICES_APP_ID_HERE) \n``` ## Tip You can change the app reference to `nil` to switch back to local-only (non-Device Sync) mode. Let's update the main ContentView to show the **SyncContentView** if the app reference is not `nil`: ```swift /// The main screen that determines whether to present the SyncContentView or the LocalOnlyContentView. @main struct ContentView: SwiftUI.App {     var body: some Scene {         WindowGroup {             // Using Sync?             if let app = app {                 SyncContentView(app: app)             } else {                 LocalOnlyContentView()             }         }     } } \n``` We define the SyncContentView below.\n\n This view has two possible states: * If the Realm app does not have a currently logged-in user, show the **LoginView**.\n* If the app does have a logged-in user, show the **OpenSyncedRealmView**. In this view, after confirming we have a user, we create a[flexibleSyncConfiguration()](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE25flexibleSyncConfigurationAC0B0V0F0VyF)that includes the `initialSubscriptions` parameter. We can use this parameter to [subscribe to queryable fields](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-ios-sync-subscribe-to-queryable-fields). These initial subscriptions search for data that matches the queries, and syncs that data to the realm. If no data matches the queries, the realm opens with an initial empty state. Your client application can only write objects that match the subscription query to a realm opened with a `flexibleSyncConfiguration`. Trying to write objects that don't match the query causes the app to perform a compensating write to undo the illegal write operation. ```swift /// This view observes the Realm app object. /// Either direct the user to login, or open a realm /// with a logged-in user. struct SyncContentView: View {     // Observe the Realm app object in order to react to login state changes.     @ObservedObject var app: RealmSwift.App     var body: some View {         if let user = app.currentUser {             // Create a `flexibleSyncConfiguration` with `initialSubscriptions`.             // We'll inject this configuration as an environment value to use when opening the realm             // in the next view, and the realm will open with these initial subscriptions.             let config = user.flexibleSyncConfiguration(initialSubscriptions: { subs in                 // Check whether the subscription already exists. Adding it more                 // than once causes an error.                 if let foundSubscriptions = subs.first(named: \"user_groups\") {                     // Existing subscription found - do nothing                     return                 } else {                     // Add queries for any objects you want to use in the app                     // Linked objects do not automatically get queried, so you                     // must explicitly query for all linked objects you want to include                     subs.append(QuerySubscription<ItemGroup>(name: \"user_groups\") {                         // Query for objects where the ownerId is equal to the app's current user's id                         // This means the app's current user can read and write their own data                         $0.ownerId == user.id                     })                     subs.append(QuerySubscription<Item>(name: \"user_items\") {                         $0.ownerId == user.id                     })\n\n             })             OpenSyncedRealmView()                 .environment(\\.realmConfiguration, config)         } else {             // If there is no user logged in, show the login view.             LoginView()         }     } } \n``` In our subscriptions, we're querying for `ItemGroup` and `Item` objects where the `ownerId` matches the logged-in user's `user.id`. Together with the permissions we used when we enabled Device Sync above, this means that the user can only read and write their own data. Flexible Sync does not automatically provide access to linked objects. Because of this, we must add subscriptions for both the `ItemGroup` and`Item` objects - we can't just query for one or the other and get the related objects. From here, we pass the flexibleSyncConfiguration to the OpenSyncedRealmView as a `realmConfiguration` using an environment object. This is the view responsible for opening a realm and working with the data. Sync uses this configuration to search for data that should sync to the realm. ```swift OpenSyncedRealmView()     .environment(\\.realmConfiguration, config) \n``` Once logged in, we open the realm asynchronously with the [AsyncOpen](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AsyncOpen.html) property wrapper. Because we've injected a `flexibleSyncConfiguration()` into the view as an environment value, the property wrapper uses this configuration to initiate Sync and download any matching data before opening the realm. If we had not provided a configuration, the property wrapper would create a default `flexibleSyncConfiguration()` for us, and we could [subscribe to queries](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-ios-sync-add-subscription)in `.onAppear`. ```swift // We've injected a `flexibleSyncConfiguration` as an environment value, // so `@AsyncOpen` here opens a realm using that configuration. @AsyncOpen(appId: YOUR_APP_SERVICES_APP_ID_HERE, timeout: 4000) var asyncOpen \n``` The OpenSyncedRealmView switches on the [AsyncOpenState enum](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/AsyncOpenState.html), which lets us show different views based on the state. In our example, we show a `ProgressView` while we're connecting to the App and the realm is syncing. We then open the realm, passing the `itemGroup` to the `ItemsView`, or show an`ErrorView` if we can't open the realm. ## Tip When opening a synced realm, use the [AsyncOpen](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AsyncOpen.html) property wrapper to always download synced changes before opening the realm, or the [AutoOpen](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AutoOpen.html) property wrapper to open a realm while syncing in the background. `AsyncOpen` requires the user to be online, while `AutoOpen` opens a realm even if the user is offline. This view has a few different states: * While connecting or waiting for login, show a `ProgressView`.\n* While downloading changes to the realm, show a `ProgressView` with a progress indicator.\n* When the realm opens, check for an itemGroup object. If one does not exist yet, create one. Then, show the ItemsView for the itemGroup in the realm. Provide a **LogoutButton** that the ItemsView can display on the top left of the navigation bar.\n* If there is an error loading the realm, show an error view containing the error. When you run the app and see the main UI, there are no items in the view. That's because we're using anonymous login, so this is the first time this specific user logs in. ```swift /// This view opens a synced realm. struct OpenSyncedRealmView: View {\n\n     // so `@AsyncOpen` here opens a realm using that configuration.     @AsyncOpen(appId: YOUR_APP_SERVICES_APP_ID_HERE, timeout: 4000) var asyncOpen         var body: some View {         // Because we are setting the `ownerId` to the `user.id`, we need         // access to the app's current user in this view.         let user = app?.currentUser         switch asyncOpen {         // Starting the Realm.asyncOpen process.         // Show a progress view.         case .connecting:             ProgressView()         // Waiting for a user to be logged in before executing         // Realm.asyncOpen.         case .waitingForUser:             ProgressView(\"Waiting for user to log in...\")         // The realm has been opened and is ready for use.         // Show the content view.         case .open(let realm):             ItemsView(itemGroup: {                 if realm.objects(ItemGroup.self).count == 0 {                     try! realm.write {                         // Because we're using `ownerId` as the queryable field, we must                         // set the `ownerId` to equal the `user.id` when creating the object                         realm.add(ItemGroup(value: [\"ownerId\":user!.id]))                     }                 }                 return realm.objects(ItemGroup.self).first!             }(), leadingBarButton: AnyView(LogoutButton())).environment(\\.realm, realm)             // The realm is currently being downloaded from the server.             // Show a progress view.         case .progress(let progress):             ProgressView(progress)         // Opening the Realm failed.         // Show an error view.         case .error(let error):             ErrorView(error: error)         }     } } \n``` In our subscriptions, we're querying for `ItemGroup` and `Item` objects where the `ownerId` matches the logged-in user's `user.id`. Together with the permissions we used when we created the Flexible Sync app above, this means that the user can only read and write their own data. Flexible Sync does not automatically provide access to linked objects. Because of this, we must add subscriptions for both the `ItemGroup` and`Item` objects - we can't just query for one or the other and get the related objects. With this in mind, we must also update the view here where we are creating a `ItemGroup` object. We must set the `ownerId` as the `user.id`of the logged-in user. ```swift ItemsView(itemGroup: {     if realm.objects(ItemGroup.self).count == 0 {         try! realm.write {             // Because we're using `ownerId` as the queryable field, we must             // set the `ownerId` to equal the `user.id` when creating the object\n\n         }     }     return realm.objects(ItemGroup.self).first! }(), leadingBarButton: AnyView(LogoutButton())).environment(\\.realm, realm) \n``` And we must also update the `ItemsView` to add `ownerId` when we create `Item` objects: ```swift // Action bar at bottom contains Add button. HStack {     Spacer()     Button(action: {         // The bound collection automatically         // handles write transactions, so we can         // append directly to it.         // Because we are using Flexible Sync, we must set         // the item's ownerId to the current user.id when we create it.         $itemGroup.items.append(Item(value: [\"ownerId\":user!.id]))     }) { Image(systemName: \"plus\") } }.padding() \n``` ### Authenticate Users with Atlas App Services The LoginView maintains some state in order to display an activity indicator or error. It uses a reference to the Realm app instance passed in from above to log in when the Log in anonymously button is clicked. ## Tip In the LoginView, you can implement [email/password authentication](https://mongodb.com/docs/realm/sdk/swift/users/manage-email-password-users/#std-label-ios-manage-email-password-users) or [another authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers). For simplicity, this example uses [Anonymous authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) Once login is complete, the LoginView itself doesn't need to do anything more. Because the parent view is observing the Realm app, it will notice when the user authentication state has changed and decide to show something other than the LoginView. ```swift /// Represents the login screen. We will have a button to log in anonymously. struct LoginView: View {     // Hold an error if one occurs so we can display it.     @State var error: Error?         // Keep track of whether login is in progress.     @State var isLoggingIn = false     var body: some View {         VStack {             if isLoggingIn {                 ProgressView()             }             if let error = error {                 Text(\"Error: \\(error.localizedDescription)\")             }             Button(\"Log in anonymously\") {                 // Button pressed, so log in                 isLoggingIn = true                 Task {                     do {                         let user = try await app!.login(credentials: .anonymous)                         // Other views are observing the app and will detect                         // that the currentUser has changed. Nothing more to do here.                         print(\"Logged in as user with id: \\(user.id)\")                     } catch {                         print(\"Failed to log in: \\(error.localizedDescription)\")\n\n                         self.error = error                         return                     }                 }             }.disabled(isLoggingIn)         }     } } \n``` The LogoutButton works just like the LoginView, but logs out instead of logging in: ```swift /// A button that handles logout requests. struct LogoutButton: View {     @State var isLoggingOut = false     var body: some View {         Button(\"Log Out\") {             guard let user = app!.currentUser else {                 return             }             isLoggingOut = true             Task {                 do {                     try await app!.currentUser!.logOut()                     // Other views are observing the app and will detect                     // that the currentUser has changed. Nothing more to do here.                 } catch {                     print(\"Error logging out: \\(error.localizedDescription)\")                 }             }         }.disabled(app!.currentUser == nil || isLoggingOut)     } } \n``` Once logged in, the app follows the same flow as the local-only version. ## Complete Code If you would like to copy and paste or examine the complete code with or without Device Sync, see below. ← [SwiftUI - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/swiftui/ \"Previous Section\")[Model Data- SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - Swift SDK On this page * [Import Realm](#import-realm)\n* [Define Your Object Model](#define-your-object-model)\n* [Open a Realm](#open-a-realm)\n* [Create, Read, Update, and Delete Objects](#create--read--update--and-delete-objects)\n* [Watch for Changes](#watch-for-changes)\n* [Add Device Sync (Optional)](#add-device-sync--optional-)\n* [Prerequisites](#prerequisites)\n* [Initialize the App](#initialize-the-app)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Realm](#open-a-realm-1) This Quick Start demonstrates how to use Realm Database with the Realm Swift SDK. Before you begin, ensure you have [Installed the Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/install/#std-label-ios-install) ## Tip ### See also:  If your app uses SwiftUI, check out the [SwiftUI Quick Start.](https://mongodb.com/docs/realm/sdk/swift/swiftui-tutorial/#std-label-ios-swiftui-quick-start) ## Import Realm Near the top of any Swift file that uses Realm, add the following import statement: `| import RealmSwift |\n| ----------------- | ` ## Define Your Object Model For a local-only Realm Database you can define your [object model](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-realm-objects) directly in code. In this quick start, you can remove`ownerId` unless you want to add the optional Device Sync. ```swift class Todo: Object {    @Persisted(primaryKey: true) var _id: ObjectId    @Persisted var name: String = \"\"    @Persisted var status: String = \"\"    @Persisted var ownerId: String    convenience init(name: String, ownerId: String) {        self.init()        self.name = name        self.ownerId = ownerId    } } \n``` ## Open a Realm In a local-only Realm Database, the simplest option to open a realm is to use the default realm with no configuration parameter: ```swift // Open the local-only default realm let realm = try! Realm() \n``` You can also specify a [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html)parameter to open a realm at a specific file URL, in-memory, or with a subset of classes. For more information, see: [Configure and Open a Realm.](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-open-a-local-realm) ## Create, Read, Update, and Delete Objects Once you have opened a realm, you can modify it and its [objects](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-realm-objects)in a [write transaction](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-write-transactions) block. To create a new Todo object, instantiate the Todo class and add it to the realm in a write block: ```swift let todo = Todo(name: \"Do laundry\", ownerId: user.id) try! realm.write {     realm.add(todo) } \n``` You can retrieve a live [collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections) of all todos in the realm: ```swift // Get all todos in the realm let todos = realm.objects(Todo.self) \n```\n\n ```swift let todosInProgress = todos.where {     $0.status == \"InProgress\" } print(\"A list of all todos in progress: \\(todosInProgress)\") \n``` To modify a todo, update its properties in a write transaction block: ```swift // All modifications to a realm must happen in a write block. let todoToUpdate = todos[0] try! realm.write {     todoToUpdate.status = \"InProgress\" } \n``` Finally, you can delete a todo: ```swift // All modifications to a realm must happen in a write block. let todoToDelete = todos[0] try! realm.write {     // Delete the Todo.     realm.delete(todoToDelete) } \n``` ## Watch for Changes You can [watch a realm, collection, or object for changes](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes) with the `observe` method. ```swift // Retain notificationToken as long as you want to observe let notificationToken = todos.observe { (changes) in     switch changes {     case .initial: break         // Results are now populated and can be accessed without blocking the UI     case .update(_, let deletions, let insertions, let modifications):         // Query results have changed.         print(\"Deleted indices: \", deletions)         print(\"Inserted indices: \", insertions)         print(\"Modified modifications: \", modifications)     case .error(let error):         // An error occurred while opening the Realm file on the background worker thread         fatalError(\"\\(error)\")     } } \n``` Be sure to retain the notification token returned by `observe` as long as you want to continue observing. When you are done observing, invalidate the token to free the resources: ```swift // Invalidate notification tokens when done observing notificationToken.invalidate() \n``` ## Add Device Sync (Optional) If you want to sync Realm data across devices, you can set up an Atlas App Services App and enable Device Sync. For more information on what you can do with App Services, see: [App Services - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/application-services/#std-label-ios-application-services) ### Prerequisites Before you can sync Realm data, you must: * [Create an App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enable anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)\n* [Enable Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) with [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) toggled to `On` and an `ownerId` field in the Queryable Fields section. ### Initialize the App To use App Services features such as authentication and sync, access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) in the App Services UI. ```swift let app = App(id: APP_ID) // Replace APP_ID with your Atlas App ID \n``` ### Authenticate a User In this quick start, you use [anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)to log in users without requiring them to provide any identifying information. After authenticating the user, you can open a realm for that user. ```swift do {\n\n     print(\"Successfully logged in user: \\(user)\")     await openSyncedRealm(user: user) } catch {     print(\"Error logging in: \\(error.localizedDescription)\") } \n``` The Realm Swift SDK provides many additional ways to authenticate, register, and link users. For other authentication providers, see: [Authenticate Users - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-authenticate-users) ### Open a Realm Once you have enabled Device Sync and authenticated a user, you can create a [Configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html) object and open the realm. You can then add a the [Flexible Sync subscription](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-swift-manage-flexible-sync-subscriptions) that determines what data the realm can read and write. Once you have a realm with a subscription, this example passes the realm and the user to another function where you can use the realm. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func openSyncedRealm(user: User) async {     do {         var config = user.flexibleSyncConfiguration()         // Pass object types to the Flexible Sync configuration         // as a temporary workaround for not being able to add a         // complete schema for a Flexible Sync app.         config.objectTypes = [Todo.self]         let realm = try await Realm(configuration: config, downloadBeforeOpen: .always)         // You must add at least one subscription to read and write from a Flexible Sync realm         let subscriptions = realm.subscriptions         try await subscriptions.update {             subscriptions.append(                 QuerySubscription<Todo> {                     $0.ownerId == user.id                 })         }         await useRealm(realm: realm, user: user)     } catch {         print(\"Error opening realm: \\(error.localizedDescription)\")     } } \n``` The syntax to [read](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-ios-read-operations), [write](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-write-operations), and [watch for changes](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes) on a synced realm is identical to the syntax for non-synced realms above. While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change. ← [Install Realm for iOS, macOS, tvOS, and watchOS](https://mongodb.com/docs/realm/sdk/swift/install/ \"Previous Section\")[Work with Realm Files - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/xcode-playgrounds/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Use Realm in Xcode Playgrounds On this page * [Prerequisites](#prerequisites)\n* [Create a Playground](#create-a-playground)\n* [Import Realm](#import-realm)\n* [Experiment with Realm](#experiment-with-realm)\n* [Managing the Realm File in Your Playground](#managing-the-realm-file-in-your-playground) ## Prerequisites You can only use Swift packages within Xcode projects that have at least one scheme and target. To use Realm in Xcode Playgrounds, you must first have an Xcode project where you have [Installed the Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/install/#std-label-ios-install) ## Create a Playground ## Tip ### See also: Other quick starts and tutorials For more guidance on getting started with Realm and Swift or SwiftUI, see any of these quick starts or tutorials: * [Quick Start](https://mongodb.com/docs/realm/sdk/swift/quick-start/#std-label-ios-client-quick-start)\n* [Quick Start with SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui-tutorial/#std-label-ios-swiftui-quick-start)\n* [iOS Tutorial](https://www.mongodb.com/docs/atlas/app-services/tutorial/swiftui/#std-label-ios-swift-tutorial) Within a project, go to File \\> New \\>Playground. Select the type of Playground you want. For this example, we've used a Blank iOS Playground. ![Screenshot of Xcode Playground iOS types with Blank selected](https://mongodb.com/docs/realm/images/xcode-playground-blank-ios.png) click to enlarge Name and save the playground in the root of your project. Be sure to add it to the project: ![Screenshot of the File Navigator with a Playground filename and the project selected](https://mongodb.com/docs/realm/images/xcode-playgrounds-create-in-project.png) click to enlarge You should see your new Playground in your Project navigator. ![Screenshot of a file named RealmPlayground.playground in the Xcode Project navigator](https://mongodb.com/docs/realm/images/xcode-playground-see-playground-in-project-navigator.png) click to enlarge ## Import Realm Add the following import statement to use Realm in the playground: `| import RealmSwift |\n| ----------------- | ` ## Experiment with Realm Experiment with Realm. For this example, we'll: * [Define a new Realm object type](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-a-new-object-type)\n* [Create a new object of that type and write it to realm](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-create-a-new-object)\n* [Query objects of the type, and filter them](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-ios-query-all-objects-of-a-given-type) ```swift class Drink: Object {     @Persisted var name = \"\"     @Persisted var rating = 0     @Persisted var source = \"\"     @Persisted var drinkType = \"\" } let drink = Drink(value: [\"name\": \"Los Cabellos\", \"rating\": 10, \"source\": \"AeroPress\", \"drinkType\": \"Coffee\"]) let realm = try! Realm(configuration: config) try! realm.write {     realm.add(drink) } let drinks = realm.objects(Drink.self) let coffeeDrinks = drinks.where {     $0.drinkType == \"Coffee\" } print(coffeeDrinks.first?.name) \n``` ## Managing the Realm File in Your Playground\n\n You can specify [Realm.configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html) details to open the file at a specific path, and delete the realm if it exists at the path. ```swift var config = Realm.Configuration() config.fileURL!.deleteLastPathComponent() config.fileURL!.appendPathComponent(\"playgroundRealm\") config.fileURL!.appendPathExtension(\"realm\") if Realm.fileExists(for: config) {     try Realm.deleteFiles(for: config)     print(\"Successfully deleted existing realm at path: \\(config.fileURL!)\") } else {     print(\"No file currently exists at path\") } \n``` Alternately, you can [open the realm in-memory only](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-open-an-in-memory-realm), or use the[deleteRealmIfMigrationNeeded](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV06deleteA17IfMigrationNeededSbvp)method to automatically delete a realm when migration is needed. ← [Stream Data to Atlas - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/stream-data-to-atlas/ \"Previous Section\")[Realm Web SDK](https://mongodb.com/docs/realm/web/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm for iOS, macOS, tvOS, and watchOS On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Installation](#installation)\n* [Import Realm](#import-realm)\n* [App Download File Size](#app-download-file-size)\n* [Troubleshooting](#troubleshooting)\n* [OS Support (Xcode 13)](#os-support--xcode-13-)\n* [OS Support (Xcode 14)](#os-support--xcode-14-)\n* [Async/Await Support](#async-await-support) ## Overview Realm's Swift SDK enables your iOS, macOS, tvOS, and watchOS applications to interact with Realm using either the Swift or Objective-C programming languages. This page details how to install Realm in your project and get started. ## Prerequisites Before getting started, ensure your development environment meets the following prerequisites: * [Xcode](https://developer.apple.com/xcode/) version 13.1 or higher.\n* When using Xcode 13, a target of iOS 9.0 or higher, macOS 10.9 or higher, tvOS 9.0 or higher, or watchOS 2.0 or higher.\n* If using Swift Package Manager with Xcode 13, target of iOS 11+ or macOS 10.10+ is required.\n* When using Xcode 14, a target of iOS 11.0 or higher, macOS 10.13 or higher, tvOS 11.0 or higher, or watchOS 4.0 or higher. ## Note There are special considerations when using Realm Database with tvOS. See [Build for tvOS](https://mongodb.com/docs/realm/sdk/swift/realm-files/tvos/#std-label-ios-tvos) for more information. ## Installation You can use `SwiftPM`, `CocoaPods`, or `Carthage` to add the Realm Swift SDK to your project. ## Import Realm Add the following line at the top of your source files to use Realm: ## App Download File Size Realm Database should only add around 5 to 8 MB to your app's download size. The releases we distribute are significantly larger because they include support for the iOS, watchOS and tvOS simulators, some debug symbols, and bitcode, all of which are stripped by the App Store automatically when apps are downloaded. ## Troubleshooting If you have build issues after using one of these methods to install Realm, see [our troubleshooting guidelines](https://mongodb.com/docs/realm/sdk/swift/test-and-debug/#std-label-ios-resolve-build-issues)for information about resolving those issues in realm. ## OS Support (Xcode 13) | Supported OS                                              | Realm Database | Realm Apps |\n| --------------------------------------------------------- | -------------- | ---------- |\n| iOS 9.0+ (iOS 11+ if using Swift Package Manager)         | X              | X          |\n| macOS 10.9+ (macOS 10.10+ if using Swift Package Manager) | X              | X          |\n| tvOS 9.0+                                                 | X              | X          |\n| watchOS 2.0+                                              | X              |            | ## OS Support (Xcode 14)\n\n ## Important There are special considerations when using Realm Database with tvOS. See [Build for tvOS](https://mongodb.com/docs/realm/sdk/swift/realm-files/tvos/#std-label-ios-tvos) for more information. ## Async/Await Support Starting with Realm Swift SDK Versions 10.15.0 and 10.16.0, many of the Realm APIs support the Swift async/await syntax. Projects must meet these requirements: | Swift SDK Version  | Swift Version Requirement | Supported OS |\n| ------------------ | ------------------------- | ------------ |\n| 10.25.0            | Swift 5.6                 | iOS 13.x     |\n| 10.15.0 or 10.16.0 | Swift 5.5                 | iOS 15.x     | If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ← [Realm Database - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-database/ \"Previous Section\")[Quick Start - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/quick-start/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/dotnet/crud/filter/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Filter and Sort Data - .NET SDK On this page * [LINQ Syntax](#linq-syntax)\n* [Comparison Operators](#comparison-operators)\n* [Logical Operators](#logical-operators)\n* [String Operators](#string-operators)\n* [Unsupported LINQ Operators](#unsupported-linq-operators)\n* [Realm Query Language](#realm-query-language)\n* [Aggregate Operators](#aggregate-operators)\n* [Sort Query Results](#sort-query-results) To filter data in your realm, use the Realm Database query engine. There are two ways to use the query engine with the .NET SDK: * [LINQ Syntax](#std-label-dotnet-linq-syntax)\n* [Realm Query Language](#std-label-dotnet-realm-query-language) You should use LINQ syntax for querying when possible, as it aligns with .NET conventions. ## Note ### About the examples on this page The examples in this page use a simple data set for a task list app. The two Realm object types are `Project`and `Task`. A `Task` has a name, assignee's name, and completed flag. There is also an arbitrary number for priority -- higher is more important -- and a count of minutes spent working on it. A `Project` has zero or more`Tasks`. See the schema for these two classes, `Project` and`Task`, below:\n\n ` ## LINQ Syntax Realm Database's query engine implements standard [LINQ](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq-queries)syntax. See the scope of LINQ implemented on the [LINQ Support page.](https://realm.io/docs/dotnet/latest/api/linqsupport.html) There are several operators available to filter a[Realm collection](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/#std-label-dotnet-client-collections) with LINQ. Filters work by evaluating an operator expression for every object in the collection being filtered. If the expression resolves to `true`, realm includes the object in the results collection. An expression consists of one of the following: * The name of a property of the object currently being evaluated\n* An operator\n* A value of any type used by realm (string, date, number, boolean, etc.) ## Note Currently, the Realm .NET SDK does not support all of the LINQ operators. Refer to the [Unsupported LINQ Operators](#std-label-dotnet-unsupported-linq) section for a list of those unsupported operators. ### Comparison Operators Value comparisons\n\n ## Example The following example uses the query engine's comparison operators to: * Find high priority tasks by comparing the value of the `priority` property value with a threshold number, above which priority can be considered high.\n* Find just-started or short-running tasks by seeing if the `progressMinutes`property falls within a certain range.\n* Find unassigned tasks by finding tasks where the `assignee` property is equal to `null`.\n* Find tasks assigned to specific teammates Ali or Jamie by seeing if the`assignee` property is in a list of names. ```csharp var highPri = items.Where(i => i.Priority > 5); var quickItems = items.Where(i =>     i.ProgressMinutes >= 1 &&     i.ProgressMinutes < 15); var unassignedItems = items.Where(i =>     i.Assignee == null); var AliOrJamieItems = items.Where(i =>    i.Assignee == \"Ali\" ||    i.Assignee == \"Jamie\"); \n``` ### Logical Operators You can use the logical operators listed in the following table to make compound predicates: | Operator | Description                                                             |\n| -------- | ----------------------------------------------------------------------- |\n| &&       | Evaluates to true if both left-hand and right-hand expressions aretrue. |\n| !        | Negates the result of the given expression.                             |\n| \\||      | Evaluates to true if either expression returns true.                    | ## Example We can use the query language's logical operators to find all of Ali's completed tasks. That is, we find all tasks where the `assignee` property value is equal to 'Ali' AND the `isComplete` property value is `true`: ```csharp var completedItemsForAli = items     .Where(i => i.Assignee == \"Ali\" && i.IsComplete); \n``` ### String Operators You can compare string values using the string operators listed in the following table. Regex-like wildcards allow more flexibility in search.\n\n ## Example The following examples use the query engine's string operators to find tasks: ```csharp // Note: In each of the following examples, you can replace the // Where() method with First(), FirstOrDefault(), // Single(), SingleOrDefault(), // Last(), or LastOrDefault(). // Get all items where the Assignee's name starts with \"E\" or \"e\" var ItemssStartWithE = items.Where(i => i.Assignee.StartsWith(\"E\",     StringComparison.OrdinalIgnoreCase)); // Get all items where the Assignee's name ends wth \"is\" // (lower case only) var endsWith = items.Where(t =>     t.Assignee.EndsWith(\"is\", StringComparison.Ordinal)); // Get all items where the Assignee's name contains the // letters \"ami\" in any casing var itemsContains = items.Where(i => i.Assignee.Contains(\"ami\",      StringComparison.OrdinalIgnoreCase)); // Get all items that have no assignee var null_or_empty = items.Where(i => string.IsNullOrEmpty(i.Assignee)); \n``` ## Important ### Case Comparisons When evaluating strings, the second parameter in all functions _except_ `Like`must be either `StringComparison.OrdinalIgnoreCase` or`StringComparison.Ordinal`. For the `Like()` method, the second parameter is a boolean value (where \"true\" means \"case sensitive\"). ### Unsupported LINQ Operators The following LINQ operators are not currently supported by the Realm .NET SDK:\n\n ## Realm Query Language You can also use [Filter()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.CollectionExtensions.html?q=Filter)to query realms using [Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language). Realm Query Language is a string-based query language to access the query engine. ```csharp var elvisProjects = projects.Filter(\"Items.Assignee == 'Elvis'\"); \n``` You should use [.NET LINQ syntax](#std-label-dotnet-linq-syntax) for queries, unless your requirements extend beyond LINQ's current capabilities. Realm Query Language is able to perform operations that LINQ syntax is not, such as [aggregation.](#std-label-dotnet-realm-query-language-aggregation) ## Tip ### See also: Realm Query Language Examples You can also find useful Realm Query Language examples on the following pages: * [iOS Query Examples](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-client-query-engine)\n* [Node.js Query Engine](https://mongodb.com/docs/realm/sdk/node/examples/query-data/#std-label-node-client-query-engine) ### Aggregate Operators Aggregate operators traverse a[collection](https://mongodb.com/docs/realm/sdk/dotnet/model-data/data-types/collections/#std-label-dotnet-client-collections) and reduce it to a single value. Note that aggregations use the[Filter()](https://www.mongodb.com/docs/realm-sdks/dotnet/latest/reference/Realms.CollectionExtensions.html?q=Filter)method, which can be used to create more complex queries that are currently unsupported by the LINQ provider. `Filter()` supports SORT and DISTINCT clauses in addition to filtering. For more information on the available aggregate operators, refer to the[Realm Query Language aggregate operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-aggregate-operators) The following examples show different ways to aggregate data: ```csharp // Get all projects with an average Item priorty > 5: var avgPriority = projects.Filter(     \"Items.@avg.Priority > 5\"); // Get all projects where all Items are high-priority: var highPriProjects = projects.Filter(     \"Items.@min.Priority > 5\"); // Get all projects with long-running Items: var longRunningProjects = projects.Filter(     \"Items.@sum.ProgressMinutes > 100\"); \n``` ## Sort Query Results A **sort** operation allows you to configure the order in which Realm Database returns queried objects. You can sort based on one or more properties of the objects in the results collection. Realm Database only guarantees a consistent order of results when the results are sorted. ## Example The following code sorts the projects by name in reverse alphabetical order (i.e. \"descending\" order). ```csharp var projectsSorted = projects.OrderByDescending(p => p.Name); \n``` ← [Read Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/read/ \"Previous Section\")[Update Data - .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/crud/update/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/work-with-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Users - Swift SDK On this page * [Overview](#overview)\n* [Create and Delete Users](#create-and-delete-users)\n* [Log Users In and Out](#log-users-in-and-out)\n* [User Sessions](#user-sessions)\n* [Read and Update Custom User Data](#read-and-update-custom-user-data)\n* [Read User Metadata from Login Providers](#read-user-metadata-from-login-providers) ## Overview When you use Atlas App Services to back your client app, you get access to a[user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects). Use Swift SDK methods with this user object to conveniently: * Create and delete users\n* Log users in and out\n* Create and update custom user data\n* Read user metadata from social login providers ## Create and Delete Users For all authentication providers other than email/password authentication, App Services automatically [creates a user object](https://mongodb.com/docs/realm/sdk/swift/users/create-and-delete-users/#std-label-ios-create-user)the first time a user authenticates. If a user authenticates via more than one method, you can [link these user identities](https://mongodb.com/docs/realm/sdk/swift/users/link-user-identities/#std-label-ios-link-user-identities)to a single user object. You can [delete user objects](https://mongodb.com/docs/realm/sdk/swift/users/create-and-delete-users/#std-label-ios-delete-user). Deleting a user object deletes metadata attached to the user object, but does not delete user-entered data from the backend. ## Tip ### Apple Account Deletion Requirements Apple [requires that applications listed through its App Store](https://developer.apple.com/app-store/review/guidelines/#5.1.1) must give any user who creates an account the option to delete the account. Whether you use an authentication method where you must manually register a user, such as email/password authentication, or one that that automatically creates a user, such as Sign-In with Apple, you must implement [user account deletion](https://www.mongodb.com/docs/atlas/app-services/users/manage/#std-label-delete-user) by June 30, 2022. ## Log Users In and Out Use one or more [authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-auth-providers) to [log users in and out](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-authenticate-users) of your client app. You can: * Log users in with an existing social account, such as Apple, Facebook, or Google.\n* Create new user accounts with App Services email/password management, or your own custom function or custom JWT user management.\n* Enable anonymous users to let users access your App Services App without persisting user data. When you have a logged-in user, SDK methods enable you to: * [Open a synced realm](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-ios-login-and-open-realm) with the user's configuration object\n* [Run a backend function](https://mongodb.com/docs/realm/sdk/swift/app-services/call-a-function/#std-label-ios-call-a-function) as the logged-in user\n* [Log the user out](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-logout)\n* [Change the active user](https://mongodb.com/docs/realm/sdk/swift/users/multi-user-applications/#std-label-ios-change-the-active-user) in a multi-user application\n* [Remove a user](https://mongodb.com/docs/realm/sdk/swift/users/multi-user-applications/#std-label-ios-remove-a-user-from-the-device) from the device\n\n ### User Sessions App Services manages sessions with access tokens and refresh tokens. Client SDKs supply the logic to manage tokens, and provide them with requests. The Swift SDK stores these tokens in the[Keychain](https://developer.apple.com/documentation/security/keychain%5Fservices). ## Tip ### See also:  [User Sessions](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) ## Read and Update Custom User Data You can [associate custom data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) with a user object, such as a preferred language or local timezone, and read it from your client application. A user object has a `customData` property that you can use to [access custom user data.](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/#std-label-ios-read-a-users-custom-data) To [create](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/#std-label-ios-create-a-users-custom-data-document) and [update](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/#std-label-ios-update-a-users-custom-data) custom user data, you must access your MongoDB data source directly. App Services does not offer a SDK method to create or update this custom user data; it's a read-only property. ## Read User Metadata from Login Providers Some authentication providers enable developers to access user metadata, such as full name or email address. When you configure these metadata fields on the App Services application, you can read this medata from your client app. A user object has a `profile` property that you can use to [access user metadata.](https://mongodb.com/docs/realm/sdk/swift/users/user-metadata/#std-label-ios-read-user-metadata) ← [Query MongoDB - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/ \"Previous Section\")[Create and Delete Users - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/create-and-delete-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swift-concurrency/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Swift Concurrency - Swift SDK On this page * [Realm Concurrency Caveats](#realm-concurrency-caveats)\n* [Suspending Execution with Await](#suspending-execution-with-await)\n* [Async/Await APIs](#async-await-apis)\n* [Perform Background Writes](#perform-background-writes)\n* [Tasks and TaskGroups](#tasks-and-taskgroups)\n* [Actor Isolation](#actor-isolation)\n* [Errors Related to Concurrency Code](#errors-related-to-concurrency-code) Swift's concurrency system provides built-in support for writing asynchronous and parallel code in a structured way. For a detailed overview of the Swift concurrency system, refer to the [Swift Programming Language Concurrency topic.](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html) ## Realm Concurrency Caveats As you implement concurrency features in your app, consider this caveat about Realm's threading model and Swift concurrency threading behaviors. ### Suspending Execution with Await Anywhere you use the Swift keyword `await` marks a possible suspension point in the execution of your code. With Swift 5.7, once your code suspends, subsequent code might not execute on the same thread. This means that anywhere you use `await` in your code, the subsequent code could be executed on a different thread than the code that precedes or follows it. This is inherently incompatible with Realm's [live object paradigm](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-live-object). Live objects, collections, and realm instances are**thread-confined**: that is, they are only valid on the thread on which they were created. Practically speaking, this means you cannot pass live instances to other threads. However, Realm Database offers several mechanisms for [sharing objects across threads](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-communication-across-threads). These mechanisms typically require your code to do some explicit handling to safely pass data across threads. You can use some of these mechanisms, such as [frozen objects](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-frozen-objects) or the [@ThreadSafe property wrapper](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-thread-safe-reference), to safely use Realm objects and instances across threads with the `await` keyword. You can also avoid threading-related issues by marking any asynchronous Realm code with`@MainActor` to ensure your apps always execute this code on the main thread. As a general rule, keep in mind that using Realm in an `await` context_without_ incorporating threading protection may yield inconsistent behavior. Sometimes, the code may succeed. In other cases, it may throw an error related to writing on an incorrect thread. ## Async/Await APIs Many Realm Swift APIs that involve working with [an Atlas App Services app](https://mongodb.com/docs/realm/sdk/swift/application-services/#std-label-ios-application-services) or a [synchronized realm](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-ios-synced-realm) are compatible with Swift's async/await syntax. For examples, check out:\n\n Realm does not provide Swift async/await support for reading or writing objects. However, the Realm Swift SDK does provide an API to safely perform background writes without requiring you to use threading protection. For more information, refer to **Perform Background Writes** below. If you have specific feature requests related to Swift async/await APIs, check out the [MongoDB Feedback Engine for Realm](https://feedback.mongodb.com/forums/923521-realm). The Realm Swift SDK team plans to continue to develop concurrency-related features based on community feedback and Swift concurrency evolution. ### Perform Background Writes A commonly-requested use case for asynchronous code is to perform write operations in the background without blocking the main thread. While the Realm Swift SDK does not currently support an async/await API for this, it does have an API specifically for performing background writes: `writeAsync`. This API allows you to add, update, or delete objects in the background without using frozen objects or passing a thread-safe reference. With this API, waiting to obtain the write lock and committing a transaction occur in the background. The write block itself runs on the calling thread. This provides thread-safety without requiring you to manually handle frozen objects or passing references across threads. However, while the write block itself is executed, this does block new transactions on the calling thread. This means that a large write using the `writeAsync` API could block small, quick writes while it executes. For more information, including a code example, refer to: [Perform a Background Write.](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-async-write) ## Tasks and TaskGroups Swift concurrency provides APIs to manage [Tasks](https://developer.apple.com/documentation/swift/task)and [TaskGroups](https://developer.apple.com/documentation/swift/taskgroup). The [Swift concurrency documentation](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html)defines a task as a unit of work that can be run asynchronously as part of your program. Task allows you to specificially define a unit of asynchronous work. TaskGroup lets you define a collection of Tasks to execute as a unit under the parent TaskGroup. Tasks and TaskGroups provide the ability to yield the thread to other important work or to cancel a long-running task that could be blocking other operations. To get these benefits, you might be tempted to use Tasks and TaskGroups to manage realm writes in the background. However, the thread-confined constraints described in [Suspending Execution with Await](#std-label-swift-suspend-execution-with-await) above apply in the Task context. If your Task contains `await` points, subsequent code might run or resume on a different thread and violate Realm's thread confinement. You must annotate functions that you run in a Task context with `@MainActor`to ensure code that accesses Realm only runs on the main thread. This negates some of the benefits of using Tasks, and may mean this is not a good design choice for apps that use Realm unless you are using Tasks solely for networking activities like managing users. ## Actor Isolation Actor isolation provides the perception of confining Realm access to a dedicated actor, and therefore seems like a safe way to manage Realm access in an asynchronous context. However, using Realm in a non-`@MainActor` async function is currently not supported. In Swift 5.6, this would often work by coincidence. Execution after an`await` would continue on whatever thread the awaited thing ran on. Using `await Realm()` in an async function would result in the code following that running on the main thread until your next call to an actor-isolated function. Swift 5.7 instead hops threads whenever changing actor isolation contexts. An unisolated async function always runs on a background thread instead. If you have code which uses `await Realm()` and works in 5.6, marking the function as `@MainActor` will make it work with Swift 5.7\\. It will function how it did - unintentionally - in 5.6. The Swift SDK team is working on improving support for actor isolation. If you have specific feature requests related to actor isolation, check the status of similar feature requests or leave feedback through the[MongoDB Feedback Engine for Realm](https://feedback.mongodb.com/forums/923521-realm). ## Errors Related to Concurrency Code\n\n To avoid threading-related issues in code that uses Swift concurrency features: * Do not change execution contexts when accessing a realm. If you open a realm on the main thread to provide data for your UI, annotate subsequent functions where you access the realm asynchronously with `@MainActor` to ensure it always runs on the main thread. Remember that `await` marks a suspension point that could change to a different thread.\n* Use the `writeAsync` API to [perform a background write](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-async-write). This manages realm access in a thread-safe way without requiring you to write specialized code to do it yourself. This is a special API that outsources aspects of the write process - where it is safe to do so - to run in an async context. You do not use this method with Swift's`async/await` syntax - use this method synchronously in your code.\n* If you want to explicitly write concurrency code where accessing a realm is done in a thread-safe way, you can explicitly [pass instances across threads](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-thread-safe-reference) or use [frozen objects](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-frozen-objects) where applicable to avoid threading-related crashes. This does require a good understanding of Realm's threading model, as well as being mindful of Swift concurrency threading behaviors. ← [Use Realm with SwiftUI Previews](https://mongodb.com/docs/realm/sdk/swift/swiftui/swiftui-previews/ \"Previous Section\")[Test and Debug - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/test-and-debug/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/application-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Application Services - Swift SDK On this page * [Overview](#overview)\n* [The App Client](#the-app-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Calling Functions](#calling-functions)\n* [Accessing MongoDB](#accessing-mongodb)\n* [Sync Data](#sync-data)\n* [Partition-Based Sync](#partition-based-sync)\n* [Flexible Sync](#flexible-sync)\n* [Group Updates for Improved Performance](#group-updates-for-improved-performance) ## Overview Realm SDKs let you connect your client apps to the App Services backend. The SDKs provide the functionality needed to authenticate users with any of the built-in [authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), call backend [functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), and directly access a linked [MongoDB data source](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources). You can also use an Atlas App Services App to [sync data between devices.](#std-label-ios-realm-sync) ## The App Client When using the SDK to access the App Services backend, you start with a App object. This object provides all other functionality related to App Services. The `App` object is[initialized](https://mongodb.com/docs/realm/sdk/swift/app-services/connect-to-app-services-backend/#std-label-ios-init-appclient) with the App ID, which you can [find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ## Tip To learn how to initialize the App client, see[Connect to an Atlas App Services backend - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/app-services/connect-to-app-services-backend/#std-label-ios-init-appclient) ## Authentication & User Management One of the most challenging aspects of client development is implementing a robust and secure authentication system. With the Realm SDKs, however, you can use any of the App Services authentication providers with very minimal backend setup or client-side code required. With the authentication APIs, you can implement the following functionality: * Creation of new user accounts\n* User log-in and log-out\n* Multiple users logged on at the same time on the same device\n* Linking user accounts from different providers\n* Providing custom user data ## Tip To learn how to set up authentication with different providers, see[Authenticate Users - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-authenticate-users) To learn how to manage multiple users, see [Multi-User Applications - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/users/multi-user-applications/#std-label-ios-multi-user-applications) To learn how to link user accounts, see [Link User Identities - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/users/link-user-identities/#std-label-ios-link-user-identities) To learn how to provide custom user data, see [Custom User Data - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/#std-label-ios-custom-user-data) ## Calling Functions [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) enable you to define and execute server-side logic for your application. You can call these Functions from your client applications via the Realm SDKs. These server-side functions can run under the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your collections. By using Functions, you provide a secure way for a variety of client applications to share complex functionality without having to reproduce that logic client-side. ## Tip\n\n ## Accessing MongoDB The Realm SDKs include APIs for accessing a MongoDB Atlas instance directly. With these APIs, you can perform all of the standard CRUD operations from your client. For security, you configure server-side [data access rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules)to dynamically determine read & write permissions for every object that is accessed. ## Tip To learn how to use the MongoDB APIs, see [Query MongoDB.](https://mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/#std-label-ios-mongodb-data-access) ## Sync Data Atlas Device Sync automatically synchronizes data between client applications and an [App Services backend](https://www.mongodb.com/docs/atlas/app-services/#std-label-realm-cloud). When a client device is online, Sync asynchronously synchronizes data in a background thread between the device and your backend App. When you use Sync in your client application, your implementation must match the Sync Mode you select in your backend App configuration. The Sync Mode options are: * Partition-Based Sync\n* Flexible Sync You can only use one Sync Mode for your application. You cannot mix Partition-Based Sync and Flexible Sync within the same App. ## Tip ### See also:  [Configure and Enable Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) ### Partition-Based Sync When you select [Partition-Based Sync](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync) for your backend App configuration, your client implementation must include a partition value. This is the value of the [partition key](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-key) field you select when you configure Partition-Based Sync. The partition value determines which data the client application can access. You pass in the partition value when you open a synced realm. ### Flexible Sync _New in version 10.22.0_. When you select [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) for your backend App configuration, your client implementation must include subscriptions to queries on [queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields). Flexible Sync works by synchronizing data that matches query subscriptions you maintain in the client application. A subscription set contains a set of queries. Flexible Sync returns documents matching those queries, where the user has the appropriate[permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read and/or read and write the documents. If documents match the query, but the client does not have the permission to read or write them, they do not sync to the client application. You can form queries using [Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Note Flexible Sync does not support all the query operators available in Realm Query Language and the SDK's query engine. See [Flexible Sync RQL Limitations](https://mongodb.com/docs/realm/realm-query-language/#std-label-flexible-sync-rql-limitations) for details. Subscription sets are based on a specific type of [Realm object](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-realm-objects). You might have multiple subscriptions if you have many types of Realm objects. To use Flexible Sync in your client application, open a synced realm with a Flexible Sync configuration. Then, manage subscriptions to determine which documents to sync. ### Group Updates for Improved Performance\n\n ← [API Reference - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/api-reference/ \"Previous Section\")[Connect to an Atlas App Services backend - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/app-services/connect-to-app-services-backend/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/test-and-debug/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Test and Debug - Swift SDK On this page * [Testing](#testing)\n* [Test Using a Default Realm](#test-using-a-default-realm)\n* [Injecting Realm Instances](#injecting-realm-instances)\n* [Simplify Testing with Class Projections](#simplify-testing-with-class-projections)\n* [Test Targets](#test-targets)\n* [Debugging](#debugging)\n* [Debug Using Realm Studio](#debug-using-realm-studio)\n* [LLDB](#lldb)\n* [Resolve Build Issues](#resolve-build-issues)\n* [Reset the Cocoapods Integration State](#reset-the-cocoapods-integration-state)\n* [Clean the Xcode Build Folder](#clean-the-xcode-build-folder)\n* [Reset Carthage-managed Dependency State](#reset-carthage-managed-dependency-state)\n* [Clean the Xcode Build Folder](#clean-the-xcode-build-folder-1)\n* [Issues Opening Realm Before Loading the UI](#issues-opening-realm-before-loading-the-ui) ## Testing ### Test Using a Default Realm The easiest way to use and test Realm Database-backed applications is to use the default realm. To avoid overriding application data or leaking state between tests, set the default realm to a new file for each test. `| // A base class which each of your Realm-using tests should inherit from rather |\n| ------------------------------------------------------------------------------- |\n| // than directly from XCTestCase                                                |\n| class TestCaseBase: XCTestCase {                                                |\n| override func setUp() {                                                         |\n| super.setUp()                                                                   |\n| // Use an in-memory Realm identified by the name of the current test.           |\n| // This ensures that each test can't accidentally access or modify the data     |\n| // from other tests or the application itself, and because they're in-memory,   |\n| // there's nothing that needs to be cleaned up.                                 |\n| Realm.Configuration.defaultConfiguration.inMemoryIdentifier = self.name         |\n| }                                                                               |\n| }                                                                               | ` ### Injecting Realm Instances\n\n For example, suppose your app has a method to `GET` a user profile from a JSON API. You want to test that the local profile is properly created: ```swift // Application Code func updateUserFromServer() {     let url = URL(string: \"http://myapi.example.com/user\")     URLSession.shared.dataTask(with: url!) { data, _, _ in         let realm = try! Realm()         createOrUpdateUser(in: realm, with: data!)     } } public func createOrUpdateUser(in realm: Realm, with data: Data) {     let object = try! JSONSerialization.jsonObject(with: data) as? [String: String]     try! realm.write {         realm.create(User.self, value: object, update: .modified)     } } // Test Code let realmPath = URL(fileURLWithPath: \"...\") func testThatUserIsUpdatedFromServer() {     let config = Realm.Configuration(fileURL: realmPath)     let testRealm = try! Realm(configuration: config)     let jsonData = \"{\\\"email\\\": \\\"help@realm.io\\\"}\".data(using: .utf8)!     // In our test, we're passing in the testRealm. This is where we'd     // pass in our \"real\" realm in the application code above.     createOrUpdateUser(in: testRealm, with: jsonData)     XCTAssertEqual(testRealm.objects(User.self).first!.email, \"help@realm.io\",                    \"User was not properly updated from server.\") } \n``` ### Simplify Testing with Class Projections _New in version 10.21.0_. If you want to work with a subset of an object's properties for testing, you can [create a class projection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-a-class-projection). A class projection is a model abstraction where you can pass through, rename, or exclude realm object properties. While this feature simplifies view model implementation, it also simplifies testing with Realm Database. ## Example This example uses [the object models](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-class-projection-object-model)and the [class projection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-a-class-projection) from the[Define and Use Class Projections page.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-and-use-class-projections) In this example, we create a realm object using the full object model. Then, we view retrieve the object as a class projection, working with only a subset of its properties. With this class projection, we don't need to access or account for properties that we don't need to test. ```swift func testWithProjection() {     let realm = try! Realm()     // Create a Realm object, populate it with values     let jasonBourne = Person(value: [\"firstName\": \"Jason\",                                                        \"lastName\": \"Bourne\",                                                        \"address\": [                                                         \"city\": \"Zurich\",\n\n     try! realm.write {         realm.add(jasonBourne)     }     // Retrieve all class projections of the given type `PersonProjection`     // and filter for the first class projection where the `firstName` property     // value is \"Jason\"     let person = realm.objects(PersonProjection.self).first(where: { $0.firstName == \"Jason\" })!     // Verify that we have the correct PersonProjection     XCTAssert(person.firstName == \"Jason\")     // See that `homeCity` exists as a projection property     // Although it is not on the object model     XCTAssert(person.homeCity == \"Zurich\")     // Change a value on the class projection     try! realm.write {         person.firstName = \"David\"     }     // Verify that the projected property's value has changed     XCTAssert(person.firstName == \"David\") } \n``` ### Test Targets Don't link the Realm Database framework directly to your test target. This can cause your tests to fail with an exception message \"Object type 'YourObject' is not managed by the Realm.\" Unlinking Realm Database from your test target should resolve this issue. Compile your model class files in your application or framework targets; don't add them to your unit test targets. Otherwise, those classes are duplicated when testing, which can lead to difficult-to-debug issues. Expose all the code that you need for testing to your unit test targets. Use the `public` access modifier or [@testable.](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/testing%5Fwith%5Fxcode/chapters/04-writing%5Ftests.html) Since you're using Realm Database as a dynamic framework, you'll need to make sure your unit test target can find Realm Database. Add the parent path to `RealmSwift.framework` to your unit test's \"Framework Search Paths\". ## Debugging ### Debug Using Realm Studio [Realm Studio](https://mongodb.com/docs/realm/studio/#std-label-realm-studio) enables you to open and edit local realms. It supports Mac, Windows and Linux. ### LLDB Debugging apps using Realm Database's Swift API must be done through the LLDB console. Although the LLDB script allows inspecting the contents of your realm variables in Xcode's UI, this doesn't yet work for Swift. Those variables will show incorrect data. Instead, use LLDB's `po`command to inspect the contents of data stored in a realm. ## Resolve Build Issues Some developers experience build issues after installing the Realm Swift SDK via CocoaPods or Carthage. Common causes of these issues include: * Installation issues:  \n   * Initial install failed  \n   * Using an unsupported version of the dependency manager\n* Build tool issues:  \n   * Build tools have stale caches  \n   * Updating build tool versions\n* Making changes to your project setup, such as:  \n   * Adding a new target  \n   * Sharing dependencies across targets A fix that often clears these issues is to delete derived data and clean the Xcode build folder. ## Issues Opening Realm Before Loading the UI You may open a realm and immediately see crashes with error messages related to properties being optional or required. Issues with your[object model](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-a-realm-object-schema) can cause these types of crashes. These errors occur after you open a realm, but before you get to the UI. Realm has a \"schema discovery\" phase when a realm opens on the device. At this time, Realm examines the schema for any objects that it manages. You can specify that a given realm should manage only a [subset of objects](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-provide-a-subset-of-classes-to-a-realm) in your application.\n\n To debug these crashes, check the [schema](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-a-realm-object-schema) you've defined. You can tell these are schema discovery issues because they occur before the UI loads. This means that no UI element is attempting to incorrectly use a property, and there aren't any objects in memory that could have bad data. If you get errors related to properties _after_ the UI loads, this is probably not due to invalid schema. Instead, those errors are likely a result of incorrect, wrongly-typed or missing data. ← [Swift Concurrency - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/swift-concurrency/ \"Previous Section\")[Telemetry - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/telemetry/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/realm-files/compacting/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Reduce Realm File Size - Swift SDK On this page * [Overview](#overview)\n* [Key Concept: Realm File Size](#key-concept--realm-file-size)\n* [Avoid Pinning Transactions](#avoid-pinning-transactions)\n* [Threading](#threading)\n* [Dispatch Queues](#dispatch-queues)\n* [How to Reduce Realm File Size](#how-to-reduce-realm-file-size)\n* [Compact a Realm Asynchronously](#compact-a-realm-asynchronously)\n* [Make a Compacted Copy](#make-a-compacted-copy)\n* [When to Reduce Realm File Size](#when-to-reduce-realm-file-size)\n* [Consider iOS File Size Limitations](#consider-ios-file-size-limitations)\n* [Summary](#summary) ## Overview The size of a Realm Database file is always larger than the total size of the objects stored within it. This architecture enables some of realm's great performance, concurrency, and safety benefits. Realm writes new data within unused space tracked inside file. In some situations, unused space may comprise a significant portion of a realm file. If file size grows large enough to negatively impact performance, you can compact the realm to reduce its file size. ## Tip ### Implement Compacting in Your Production Application Every production application should implement a [shouldCompactOnLaunch](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV21shouldCompactOnLaunchSbSi%5FSitcSgvp)callback to periodically reduce the realm file size. ## Key Concept: Realm File Size Generally, Realm Database takes less space on disk than a comparable SQLite database. Unexpected file growth may be related to Atlas App Services referring to outdated data. These factors can affect file size: * Pinning transactions\n* Threading\n* Dispatch Queues When you consider reducing the file size through compacting, there are a couple of things to keep in mind: * Compacting can be a resource-intensive operation\n* Compacting can block the UI thread Because of these factors, you probably don't want to compact a realm every time you open it, but instead want to consider [when to compact a realm](#std-label-ios-when-to-compact-a-realm). This varies based on your application's platform and usage patterns. When deciding when to compact, [consider iOS file size limitations.](#std-label-ios-platform-file-size-limitations) ### Avoid Pinning Transactions Realm ties read transaction lifetimes to the memory lifetime of realm instances. Avoid \"pinning\" old Realm transactions. Use auto-refreshing realms, and wrap the use of Realm APIs from background threads in explicit autorelease pools. ### Threading Realm updates the version of your data that it accesses at the start of a run loop iteration. While this gives you a consistent view of your data, it has file size implications. Imagine this scenario: * **Thread A**: Read some data from a realm, and then block the thread on a long-running operation.\n* **Thread B**: Write data on another thread.\n* **Thread A**: The version on the read thread isn't updated. Realm has to hold intermediate versions of the data, growing in file size with every write. To avoid this issue, call [invalidate()](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V10invalidateyyF)on the realm. This tells the realm that you no longer need the objects you've read so far. This frees realm from tracking intermediate versions of those objects. The next time you access it, realm will have the latest version of the objects. You can also use these two methods to compact your Realm:\n\n ## Tip ### See also:  [Advanced Guides: Threading](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-client-threading) ### Dispatch Queues When accessing Realm using [Grand Central Dispatch](https://developer.apple.com/documentation/dispatch), you may see similar file growth. A dispatch queue's autorelease pool may not drain immediately upon executing your code. Realm cannot reuse intermediate versions of the data until the dispatch pool deallocates the realm object. Use an explicit autorelease pool when accessing realm from a dispatch queue. ## How to Reduce Realm File Size Realm compacting works by: 1. Reading the entire contents of the realm file\n2. Writing the contents to a new file at a different location\n3. Replacing the original file If the file contains a lot of data, this can be an expensive operation. Use [shouldCompactOnLaunch()](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html)(Swift) or [shouldCompactOnLaunch](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMRealmConfiguration.html)(Objective-C) on a realm's configuration object to compact a realm. Specify conditions to execute this method, such as: * The size of the file on disk\n* How much free space the file contains For more information about the conditions to execute in the method, see:[When to Reduce Realm File Size.](#std-label-ios-when-to-compact-a-realm) ## Important ### Compacting may not occur Compacting cannot occur while a realm is being accessed, regardless of any configuration settings. ### Compact a Realm Asynchronously When you use the Swift async/await syntax to open a realm asynchronously, you can compact a realm in the background.\n\n ` Starting with Realm Swift SDK Versions 10.15.0 and 10.16.0, many of the Realm APIs support the Swift async/await syntax. Projects must meet these requirements: | Swift SDK Version  | Swift Version Requirement | Supported OS |\n| ------------------ | ------------------------- | ------------ |\n| 10.25.0            | Swift 5.6                 | iOS 13.x     |\n| 10.15.0 or 10.16.0 | Swift 5.5                 | iOS 15.x     | If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ### Make a Compacted Copy You can save a compacted (and optionally [encrypted](https://mongodb.com/docs/realm/sdk/swift/realm-files/encrypt-a-realm/#std-label-ios-encrypt-a-realm)) copy of a realm to another file location with the [Realm.writeCopy(toFile:encryptionKey:)](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V9writeCopy6toFile13encryptionKeyy10Foundation3URLV%5FAG4DataVSgtKF)method. The destination file cannot already exist. ## Important Avoid calling this method within a [write transaction](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-write-transactions). If called within a write transaction, this method copies the absolute latest data. This includes any**uncommitted** changes you made in the transaction before this method call. ## When to Reduce Realm File Size Compacting a realm can be an expensive operation that can block the UI thread. Your application should not compact every time you open a realm. Instead, try to optimize compacting so your application does it just often enough to prevent the file size from growing too large. If your application runs in a resource-constrained environment, you may want to compact when you reach a certain file size or when the file size negatively impacts performance. These recommendations can help you start optimizing compaction for your application: * Set the max file size to a multiple of your average realm state size. If your average realm state size is 10MB, you might set the max file size to 20MB or 40MB, depending on expected usage and device constraints.\n* As a starting point, compact realms when more than 50% of the realm file size is no longer in use. Divide the currently used bytes by the total file size to determine the percentage of space that is currently used. Then, check for that to be less than 50%. This means that greater than 50% of your realm file size is unused space, and it is a good time to compact. After experimentation, you may find a different percentage works best for your application. These calculations might look like this in your `shouldCompactOnLaunch`callback: ```swift // Set a maxFileSize equal to 20MB in bytes let maxFileSize = 20 * 1024 * 1024 // Check for the realm file size to be greater than the max file size, // and the amount of bytes currently used to be less than 50% of the // total realm file size return (realmFileSizeInBytes > maxFileSize) && (Double(usedBytes) / Double(realmFileSizeInBytes)) < 0.5 \n``` Experiment with conditions to find the right balance of how often to compact realm files in your application. ### Consider iOS File Size Limitations A large realm file can impact the performance and reliability of your app. Any single realm file cannot be larger than the amount of memory your application would be allowed to map in iOS. This limit depends on the device and on how fragmented the memory space is at that point in time. If you need to store more data, map it over multiple realm files. ## Summary\n\n ← [Bundle a Realm File - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/bundle-a-realm/ \"Previous Section\")[Encrypt a Realm - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/encrypt-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/realm-files/delete-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete a Realm File - Swift SDK On this page * [Delete a Realm File to Avoid Migration](#delete-a-realm-file-to-avoid-migration)\n* [Delete a Realm File](#delete-a-realm-file)\n* [Delete a Realm File During a Client Reset](#delete-a-realm-file-during-a-client-reset) In some cases, you may want to completely delete a realm file from disk. Realm avoids copying data into memory except when absolutely required. As a result, all objects managed by a realm have references to the file on disk. Before you can safely delete the file, you must ensure the deallocation of these objects: * All objects read from or added to the realm\n* All List and Results objects\n* All ThreadSafeReference objects\n* The realm itself ## Warning ### Don't delete files while realms are open If you delete a realm file or any of its auxiliary files while one or more instances of the realm are open, you might corrupt the realm or disrupt [sync.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) ## Delete a Realm File to Avoid Migration If you iterate rapidly as you develop your app, you may want to delete a realm file instead of migrating it when you make schema changes. The Realm configuration provides a [deleteRealmIfMigrationNeeded](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV06deleteA17IfMigrationNeededSbvp)parameter to help with this case. When you set this property to `true`, the SDK deletes the realm file when a migration would be required. Then, you can create objects that match the new schema instead of writing migration blocks for development or test data. `` | do {                                                                                          |\n| --------------------------------------------------------------------------------------------- |\n| // Delete the realm if a migration would be required, instead of migrating it.                |\n| // While it's useful during development, do not leave this set to `true` in a production app! |\n| let configuration = Realm.Configuration(deleteRealmIfMigrationNeeded: true)                   |\n| let realm = try Realm(configuration: configuration)                                           |\n| } catch {                                                                                     |\n| print(\"Error opening realm: \\(error.localizedDescription)\")                                   |\n| }                                                                                             |  `` ## Delete a Realm File In practice, there are two safe times to delete the realm file: 1. On application startup before ever opening the realm.\n2. After only having opened the realm within an explicit `autorelease` pool, which ensures deallocation of all of objects within it.\n\n When you use Device Sync, you may encounter a **client reset error**. During a client reset, your app must delete the local copy of the realm and download an updated version from the Atlas App Services backend. Because Synced realms are stored locally and can be used offline, deleting a Synced realm could lose data. If the client has written to the realm and the realm has not uploaded those changes, the client loses that data when you delete the Synced realm. The realm may be unable to upload changes when the client doesn't have a network connection for a long period of time, or in the event of a Sync error that requires you to restart Sync. For more details on how to handle this scenario, see [Client Reset.](https://mongodb.com/docs/realm/sdk/swift/sync/handle-sync-errors/#std-label-ios-client-reset) ← [Configure & Open a Realm - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/ \"Previous Section\")[Bundle a Realm File - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/bundle-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - Swift SDK On this page * [Register a Realm Change Listener](#register-a-realm-change-listener)\n* [Register a Collection Change Listener](#register-a-collection-change-listener)\n* [Register an Object Change Listener](#register-an-object-change-listener)\n* [Register a Key Path Change Listener](#register-a-key-path-change-listener)\n* [Realm Collections](#realm-collections)\n* [Write Silently](#write-silently)\n* [Stop Watching for Changes](#stop-watching-for-changes)\n* [Key-value Observation](#key-value-observation)\n* [Key-value Observation Compliance](#key-value-observation-compliance)\n* [Managed vs. Unmanaged KVO Considerations](#managed-vs.-unmanaged-kvo-considerations)\n* [Observing Realm Lists](#observing-realm-lists)\n* [React to Changes to a Class Projection](#react-to-changes-to-a-class-projection)\n* [Notification Delivery](#notification-delivery) ## Register a Realm Change Listener You can register a notification handler on an entire [realm](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-realms). Realm Database calls the notification handler whenever any write transaction involving that Realm is committed. The handler receives no information about the change. ## Register a Collection Change Listener You can register a notification handler on a collection within a realm. Realm Database notifies your handler: * After first retrieving the collection.\n* Whenever a write transaction adds, changes, or removes objects in the collection. Notifications describe the changes since the prior notification with three lists of indices: the indices of the objects that were deleted, inserted, and modified. ## Important ### Order Matters In collection notification handlers, always apply changes in the following order: deletions, insertions, then modifications. Handling insertions before deletions may result in unexpected behavior. Collection notifications provide a `change` parameter that reports which objects are deleted, added, or modified during the write transaction. This[RealmCollectionChange](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/RealmCollectionChange.html)resolves to an array of index paths that you can pass to a `UITableView`'s batch update methods. ## Important ### High-frequency updates This example of a collection change listener does not support high-frequency updates. Under an intense workload, this collection change listener may cause the app to throw an exception. ## Register an Object Change Listener You can register a notification handler on a specific object within a Realm. Realm Database notifies your handler: * When the object is deleted.\n* When any of the object's properties change. The handler receives information about what fields changed and whether the object was deleted. ## Register a Key Path Change Listener _New in version 10.12.0_. In addition to registering a notification handler on an [object](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/Object.html#/s:So16RealmSwiftObjectC0aB0E7observe8keyPaths2on%5FSo20RLMNotificationTokenCSaySSGSg%5FSo17OS%5Fdispatch%5FqueueCSgyAC0C6ChangeOyxGctSo13RLMObjectBaseCRbzlF)or [collection](https://www.mongodb.com/docs/realm-sdks/swift/latest/Protocols/RealmCollection.html#/s:10RealmSwift0A10CollectionP7observe8keyPaths2on%5FSo20RLMNotificationTokenCSaySSGSg%5FSo17OS%5Fdispatch%5FqueueCSgyAA0aC6ChangeOyxGctF), you can pass an optional string `keyPaths` parameter to specify the key path or key paths to watch. ## Example\n\n ` _New in version 10.14.0_. You can [observe](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/Object.html#/s:So16RealmSwiftObjectC0aB0E7observe8keyPaths2on%5FSo20RLMNotificationTokenCSays14PartialKeyPathCyxGG%5FSo17OS%5Fdispatch%5FqueueCSgyAC0C6ChangeOyxGctSo13RLMObjectBaseCRbzlF)a partially type-erased [PartialKeyPath](https://developer.apple.com/documentation/swift/partialkeypath)on [Objects](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/Object.html) or [RealmCollections.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Protocols/RealmCollection.html) ```swift objectNotificationToken = dog.observe(keyPaths: [\\Dog.favoriteToy, \\Dog.age], { change in \n``` When you specify `keyPaths`, _only_ changes to those`keyPaths` trigger notification blocks. Any other changes do not trigger notification blocks. ## Example Consider a `Dog` object where one of its properties is a list of`siblings`: ```swift class Dog: Object {     @Persisted var name = \"\"     @Persisted var siblings: List<Dog>     @Persisted var age: Int? } \n``` If you pass `siblings` as a `keyPath` to observe, any insertion, deletion, or modification to the `siblings` list would trigger a notification. However, a change to `someSibling.name` would not trigger a notification, unless you explicitly observed `[\"siblings.name\"]`. ## Note Multiple notification tokens on the same object which filter for separate key paths _do not_ filter exclusively. If one key path change is satisfied for one notification token, then all notification token blocks for that object will execute. ### Realm Collections When you observe key paths on the various collection types, expect these behaviors:\n\n ## Write Silently You can write to a realm _without_ sending a notification to a specific observer by passing the observer's notification token in an array to [realm.write(withoutNotifying:\\_:):](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V5write16withoutNotifying%5FxSaySo20RLMNotificationTokenCG%5FxyKXEtKlF) ## Tip ### See also:  [Key Concept: Interface-Driven Writes](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-interface-driven-writes) ## Stop Watching for Changes Observation stops when the token returned by an `observe` call becomes invalid. You can explicitly invalidate a token by calling its`invalidate()` method. ## Important ### Retain Tokens as Long as You Want to Observe Notifications stop if the token is in a local variable that goes out of scope. ## Key-value Observation ### Key-value Observation Compliance Realm Database objects are [key-value observing (KVO) compliant](https://developer.apple.com/documentation/swift/cocoa%5Fdesign%5Fpatterns/using%5Fkey-value%5Fobserving%5Fin%5Fswift)for most properties: * Almost all managed (non-ignored) properties on `Object` subclasses\n* The `invalidated` property on `Object` and `List` You cannot observe `LinkingObjects` properties via Key-value observation. ## Important You cannot add an object to a realm (with `realm.add(obj)` or similar methods) while it has any registered observers. ### Managed vs. Unmanaged KVO Considerations Observing the properties of unmanaged instances of `Object` subclasses works like any other dynamic property. Observing the properties of managed objects works differently. With realm-managed objects, the value of a property may change when: * You assign to it\n* The realm is refreshed, either manually with `realm.refresh()` or automatically on a runloop thread\n* You begin a write transaction after changes on another thread Realm applies changes made in the write transaction(s) on other threads at once. Observers see Key-value observation notifications at once. Intermediate steps do not trigger KVO notifications. ## Example Say your app performs a write transaction that increments a property from 1 to 10\\. On the main thread, you get a single notification of a change directly from 1 to 10\\. You won't get notifications for every incremental change between 1 and 10. Avoid modifying managed Realm objects from within`observeValueForKeyPath(_:ofObject:change:context:)`. Property values can change when not in a write transaction, or as part of beginning a write transaction. ### Observing Realm Lists Observing changes made to Realm `List` properties is simpler than`NSMutableArray` properties: * You don't have to mark `List` properties as dynamic to observe them.\n* You can call modification methods on `List` directly. Anyone observing the property that stores it gets a notification. You don't need to use `mutableArrayValueForKey(_:)`, although realm does support this for code compatibility. ## Tip ### See also:  Examples of using Realm with [ReactiveCocoa from Objective-C](https://github.com/realm/realm-swift/tree/master/examples/ios/objc/RACTableView), and [ReactKit from Swift.](https://github.com/realm/realm-swift/tree/v2.3.0/examples/ios/swift-2.2/ReactKit) ## React to Changes to a Class Projection Like other realm objects, you can [react to changes](#std-label-ios-react-to-changes)to a class projection. When you register a class projection change listener, you see notifications for changes made through the class projection object directly. You also see notifications for changes to the underlying object's properties that project through the class projection object. Properties on the underlying object that are not `@Projected` in the class projection do not generate notifications. This notification block fires for changes in:\n\n ```swift let realm = try! Realm() let projectedPerson = realm.objects(PersonProjection.self).first(where: { $0.firstName == \"Jason\" })! let token = projectedPerson.observe(keyPaths: [\"firstName\"], { change in     switch change {     case .change(let object, let properties):         for property in properties {             print(\"Property '\\(property.name)' of object \\(object) changed to '\\(property.newValue!)'\")         }     case .error(let error):         print(\"An error occurred: \\(error)\")     case .deleted:         print(\"The object was deleted.\")     } }) // Now update to trigger the notification try! realm.write {     projectedPerson.firstName = \"David\" } \n``` ## Notification Delivery If you don't need strict guarantees around when notifications are delivered, subscribe to a dispatch queue instead of the main thread. If your notification logic does need strict guarantees, use care in how you write things in your notification handlers. Otherwise, you may trigger this error: ``` Cannot register notification blocks from within write transactions. \n``` This issue occurs when you try to perform updates as a result of a notification, but the notification occurs while a write transaction is in progress. The observe function takes a dispatch queue. If that's set, Realm delivers notifications there instead of to the current thread. Realm's notification system promises that notifications for writes on different threads are always delivered synchronously as part of the refresh process. As long as you aren't performing writes on the current thread, you can rely on the guarantee that your app cannot see the value you read from an object change without receiving a notification about the change in between the reads. ← [Filter Data - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/ \"Previous Section\")[SwiftUI - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/swiftui/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/realm-files/encrypt-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Encrypt a Realm - Swift SDK On this page * [Overview](#overview)\n* [Considerations](#considerations)\n* [Storing & Reusing Keys](#storing---reusing-keys)\n* [Performance Impact](#performance-impact)\n* [Encryption and Atlas Device Sync](#encryption-and-atlas-device-sync)\n* [Accessing an Encrypted Realm from Multiple Processes](#accessing-an-encrypted-realm-from-multiple-processes)\n* [Example](#example) ## Overview You can encrypt the realm database file on disk with AES-256 + SHA-2 by supplying a 64-byte encryption key when [opening a realm.](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-open-a-local-realm) Realm transparently encrypts and decrypts data with standard[AES-256 encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) using the first 256 bits of the given 512-bit encryption key. Realm uses the other 256 bits of the 512-bit encryption key to validate integrity using a [hash-based message authentication code (HMAC).](https://en.wikipedia.org/wiki/HMAC) ## Warning Do not use cryptographically-weak hashes for realm encryption keys. For optimal security, we recommend generating random rather than derived encryption keys. ## Considerations The following are key impacts to consider when encrypting a realm. ### Storing & Reusing Keys You **must** pass the same encryption key every time you open the encrypted realm. If you don't provide a key or specify the wrong key for an encrypted realm, the Realm SDK throws an error. Apps should store the encryption key in the Keychain so that other apps cannot read the key. ### Performance Impact Reads and writes on encrypted realms can be up to 10% slower than unencrypted realms. ### Encryption and Atlas Device Sync You can encrypt a [synced realm.](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/#std-label-ios-sync-changes-between-devices) Realm only encrypts the data on the device and stores the data unencrypted in your Atlas data source. Any users with authorized access to the Atlas data source can read the data, but the following still applies: * Users must have the correct read [permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read the synced data.\n* Data stored in Atlas is always encrypted at a volume (disk) level.\n* The transfer between client and server is always fully encrypted. You can also enable [Customer Key Management](https://www.mongodb.com/docs/atlas/security-kms-encryption/)to encrypt stored Atlas data using your cloud provider's key (e.g. AWS KMS, Azure Key Vault, Google Cloud KMS). If you need unique keys for each user of your application, you can use an OAuth provider or use one of the [Realm authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication)and an [authentication trigger](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-triggers)to create a 64-bit key and store that key in a [user object.](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) ### Accessing an Encrypted Realm from Multiple Processes You cannot open the same encrypted realm from multiple processes. Attempting to do so will throw the following error:`Encrypted interprocess sharing is currently unsupported.` If multiple processes need to access a realm simultaneously, use an unencrypted realm. As an alternative, you can store data that you want to encrypt as`NSData` properties on realm objects. Then, you can encrypt and decrypt individual fields.\n\n ## Example The following code demonstrates how to generate an encryption key and open an encrypted realm: The following Swift example demonstrates how to store and retrieve a generated key from the Keychain:\n\n  `` ← [Reduce Realm File Size - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/compacting/ \"Previous Section\")[Build for tvOS](https://mongodb.com/docs/realm/sdk/swift/realm-files/tvos/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/realm-files/bundle-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Bundle a Realm File - Swift SDK On this page * [Overview](#overview)\n* [Create a Realm File for Bundling](#create-a-realm-file-for-bundling)\n* [Bundle a Realm File in Your Production Application](#bundle-a-realm-file-in-your-production-application)\n* [Open a Realm from a Bundled Realm File](#open-a-realm-from-a-bundled-realm-file) ## Note ### Bundle Synchronized Realms Swift SDK version 10.23.0 introduced the ability to bundle synchronized realms. Before version 10.23.0, you could only bundle local realms. Realm supports **bundling** realm files. When you bundle a realm file, you include a database and all of its data in your application download. This allows users to start applications for the first time with a set of initial data. For synced realms, bundling can avoid a lengthy initial download the first time a user opens your application. Instead, users need only download the synced changes that occurred since you generated the bundled file. ## Warning ### Synced Realm Bundling and Client Maximum Offline Time If your application has enabled [advanced backend compaction](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-advanced-backend-compaction) by configuring a[client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), users could experience a client reset the first time they open the bundled realm file. This can happen if: * the bundled realm file was generated more than**client maximum offline time** days before the user syncs the realm for the first time. Users experiencing a client reset download the full state of the realm from the application backend. This negates the advantages of bundling a realm file. To prevent client resets and preserve the advantages of realm file bundling: * Avoid using a client maximum offline time in applications that bundle a synchronized realm.\n* If your application does use a client maximum offline time, ensure that your application download always includes a recently synced realm file. Generate a new file each application version, and ensure that no version ever stays current for more than**client maximum offline time** number of days. ## Overview To create and bundle a realm file with your application: 1. [Create a realm file](#std-label-ios-create-a-realm-for-bundling) that contains the data you'd like to bundle.\n2. [Bundle the realm file](#std-label-ios-bundle-realm-file) in your production application.\n3. In your production application,[open the realm from the bundled asset file](#std-label-ios-open-a-realm-from-a-bundled-realm-file). For synced realms, you must supply the partition key. ## Create a Realm File for Bundling 1. Build a temporary realm app that shares the data model of your application.\n2. Open a realm and add the data you wish to bundle. If using a synchronized realm, allow time for the realm to fully sync.\n3. Use the [writeCopy(configuration:)](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V9writeCopy13configurationyAC13ConfigurationV%5FtKF)method to copy the realm to a new file: ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes.\n\n  `` [writeCopy(configuration: )](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V9writeCopy13configurationyAC13ConfigurationV%5FtKF)automatically compacts your realm to the smallest possible size before copying. ## Note ### Differences Between Synced Realms and Local-only Realms The above example uses a `SyncConfiguration` to configure a synchronized realm. To create a copy of a local realm, configure your realm with `RealmConfiguration` instead. ## Bundle a Realm File in Your Production Application Now that you have a copy of the realm that contains the initial data, bundle it with your production application. At a broad level, this entails: 1. Create a new project with the exact same data models as your production app. Open a realm and add the data you wish to bundle. Since realm files are cross-platform, you can do this in a macOS app.\n2. Drag the compacted copy of your realm file to your production app's Xcode Project Navigator.\n3. Go to your app target's Build Phases tab in Xcode. Add the realm file to the Copy Bundle Resources build phase.\n4. At this point, your app can access the bundled realm file. Find its path with [Bundle.main.path(forResource:ofType).](https://developer.apple.com/documentation/foundation/bundle/1410989-path) You can open the realm at the bundle path directly if the`readOnly` property is set to `true` on the[Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html). If you want to modify the bundled realm, first copy the bundled file to your app's Documents folder with setting `seedFilePath` with the URL of the bundled Realm on your Configuration. ## Tip See the [migration sample app](https://github.com/realm/realm-swift/tree/master/examples/ios/swift/Migration) for a complete working app that uses a bundled local realm. ## Open a Realm from a Bundled Realm File Now that you have a copy of the realm included with your production application, you need to add code to use it. Use the [seedFilePath](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV12seedFilePath10Foundation3URLVSgvp)method when configuring your realm to open the realm from the bundled file: ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift try await openBundledSyncedRealm() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func openBundledSyncedRealm() async throws {     let app = App(id: YOUR_APP_SERVICES_APP_ID)     // Log in an app user who will use the bundled realm     let user = try await app.login(credentials: Credentials.anonymous)     // Create a configuration for the app user's realm     // This should use the same partition value as the bundled realm     var newUserConfig = user.configuration(partitionValue: \"Partition You Want to Bundle\")     newUserConfig.objectTypes = [Todo.self]     // Find the path of the seed.realm file in your project     let realmURL = Bundle.main.url(forResource: \"seed\", withExtension: \".realm\")     print(\"The bundled realm URL is: \\(realmURL)\")     // When you use the `seedFilePath` parameter, this copies the     // realm at the specified path for use with the user's config     newUserConfig.seedFilePath = realmURL     // Open the synced realm, downloading any changes before opening it.     // This starts with the existing data in the bundled realm, but checks     // for any updates to the data before opening it in your application.\n\n     print(\"Successfully opened the bundled realm\")     // Read and write to the bundled realm as normal     let todos = realm.objects(Todo.self)     // There should be one todo whose owner is Daenerys because that's     // what was in the bundled realm.     var daenerysTodos = todos.where { $0.owner == \"Daenerys\" }     XCTAssertEqual(daenerysTodos.count, 1)     print(\"The bundled realm has \\(daenerysTodos.count) todos whose owner is Daenerys\")     // Write as usual to the realm, and see the object count increment     let todo = Todo(value: [\"name\": \"Banish Ser Jorah\", \"owner\": \"Daenerys\", \"status\": \"In Progress\"])     try realm.write {         realm.add(todo)     }     print(\"Successfully added a todo to the realm\")     daenerysTodos = todos.where { $0.owner == \"Daenerys\" }     XCTAssertEqual(daenerysTodos.count, 2) } \n``` ## Note ### Differences Between Synced Realms and Local-only Realms The above example uses a `SyncConfiguration` to configure a synchronized realm. To create a copy of a local realm, configure your realm with `Realm.Configuration` instead. ← [Delete a Realm File - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/delete-a-realm/ \"Previous Section\")[Reduce Realm File Size - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/compacting/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui-tutorial/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database with SwiftUI QuickStart On this page * [Prerequisites](#prerequisites)\n* [Overview](#overview)\n* [Get Started](#get-started)\n* [Define Models](#define-models)\n* [Views and Observed Objects](#views-and-observed-objects)\n* [Integrate Atlas Device Sync](#integrate-atlas-device-sync)\n* [Authenticate Users with Atlas App Services](#authenticate-users-with-atlas-app-services)\n* [Complete Code](#complete-code) ## Prerequisites * Have Xcode 12.4 or later (minimum Swift version 5.3.1).\n* Create a new Xcode project using the SwiftUI \"App\" template with a minimum iOS target of 15.0.\n* [Install the Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/install/#std-label-ios-install) This SwiftUI app requires a minimum SDK version of 10.19.0. ## Overview ## Tip ### See also: Use Realm Database with SwiftUI This page provides a small working app to get you up and running with Realm and SwiftUI quickly. If you'd like to see additional examples, including more explanation about Realm's SwiftUI features, see:[SwiftUI - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/swiftui/#std-label-ios-swiftui-examples) This page contains all of the code for a working Realm and SwiftUI app. The app starts on the **ItemsView**, where you can edit a list of items: * Press the Add button on the bottom right of the screen to add randomly-generated items.\n* Press the Edit button on the top right to modify the list order, which the app persists in the realm.\n* You can also swipe to delete items. When you have items in the list, you can press one of the items to navigate to the **ItemDetailsView**. This is where you can modify the item name or mark it as a favorite: * Press the text field in the center of the screen and type a new name. When you press Return, the item name should update across the app.\n* You can also toggle its favorite status by pressing the heart toggle in the top right. ## Tip This guide optionally integrates with [Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync). See[Integrate Atlas Device Sync](#std-label-swiftui-integrate-with-sync) below. ### Get Started We assume you have created an Xcode project with the SwiftUI \"App\" template. Open the main Swift file and delete all of the code inside, including any `@main` `App` classes that Xcode generated for you. At the top of the file, import the Realm and SwiftUI frameworks: `| import RealmSwift |\n| ----------------- |\n| import SwiftUI    | ` ## Tip Just want to dive right in with the complete code? Jump to[Complete Code](#std-label-swiftui-complete-code) below. ### Define Models A common Realm data modeling use case is to have \"things\" and \"containers of things\". This app defines two related Realm object models: item and itemGroup. An item has two user-facing properties: * A randomly generated-name, which the user can edit.\n* An `isFavorite` boolean property, which shows whether the user \"favorited\" the item. An itemGroup contains items. You can extend the itemGroup to have a name and an association with a specific user, but that's out of scope of this guide. Paste the following code into your main Swift file to define the models: Because Flexible Sync does not automatically include linked objects, we must add `ownerId` to both objects. You can omit `ownerId` if you only want to use a local realm. ```swift /// Random adjectives for more interesting demo item names let randomAdjectives = [     \"fluffy\", \"classy\", \"bumpy\", \"bizarre\", \"wiggly\", \"quick\", \"sudden\",     \"acoustic\", \"smiling\", \"dispensable\", \"foreign\", \"shaky\", \"purple\", \"keen\",     \"aberrant\", \"disastrous\", \"vague\", \"squealing\", \"ad hoc\", \"sweet\" ] /// Random noun for more interesting demo item names\n\n     \"floor\", \"monitor\", \"hair tie\", \"puddle\", \"hair brush\", \"bread\",     \"cinder block\", \"glass\", \"ring\", \"twister\", \"coasters\", \"fridge\",     \"toe ring\", \"bracelet\", \"cabinet\", \"nail file\", \"plate\", \"lace\",     \"cork\", \"mouse pad\" ] /// An individual item. Part of an `ItemGroup`. final class Item: Object, ObjectKeyIdentifiable {     /// The unique ID of the Item. `primaryKey: true` declares the     /// _id member as the primary key to the realm.     @Persisted(primaryKey: true) var _id: ObjectId     /// The name of the Item, By default, a random name is generated.     @Persisted var name = \"\\(randomAdjectives.randomElement()!) \\(randomNouns.randomElement()!)\"     /// A flag indicating whether the user \"favorited\" the item.     @Persisted var isFavorite = false     /// Users can enter a description, which is an empty string by default     @Persisted var itemDescription = \"\"         /// The backlink to the `ItemGroup` this item is a part of.     @Persisted(originProperty: \"items\") var group: LinkingObjects<ItemGroup>         /// Store the user.id as the ownerId so you can query for the user's objects with Flexible Sync     /// Add this to both the `ItemGroup` and the `Item` objects so you can read and write the linked objects.     @Persisted var ownerId = \"\" } /// Represents a collection of items. final class ItemGroup: Object, ObjectKeyIdentifiable {     /// The unique ID of the ItemGroup. `primaryKey: true` declares the     /// _id member as the primary key to the realm.     @Persisted(primaryKey: true) var _id: ObjectId     /// The collection of Items in this group.     @Persisted var items = RealmSwift.List<Item>()         /// Store the user.id as the ownerId so you can query for the user's objects with Flexible Sync     /// Add this to both the `ItemGroup` and the `Item` objects so you can read and write the linked objects.     @Persisted var ownerId = \"\" } \n``` ### Views and Observed Objects The entrypoint of the app is the **ContentView** class that derives from`SwiftUI.App`. For now, this always displays the**LocalOnlyContentView**. Later, this will show the **SyncContentView**when Device Sync is enabled. ```swift /// The main screen that determines whether to present the SyncContentView or the LocalOnlyContentView. /// For now, it always displays the LocalOnlyContentView. @main struct ContentView: SwiftUI.App {     var body: some Scene {         WindowGroup {             LocalOnlyContentView()         }     } } \n``` ## Tip You can use a realm other than the default realm by passing an environment object from higher in the View hierarchy: ```swift LocalOnlyContentView()   .environment(\\.realmConfiguration, Realm.Configuration( /* ... */ )) \n``` The LocalOnlyContentView has an [@ObservedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedResults.html) itemGroups. This implicitly uses the default realm to load all itemGroups when the view appears. This app only expects there to ever be one itemGroup. If there is an itemGroup in the realm, the LocalOnlyContentView renders an **ItemsView** for that itemGroup. If there is no itemGroup already in the realm, then the LocalOnlyContentView displays a ProgressView while it adds one. Because the view observes the itemGroups thanks to the `@ObservedResults` property wrapper, the view immediately refreshes upon adding that first itemGroup and displays the ItemsView. ```swift /// The main content view if not using Sync. struct LocalOnlyContentView: View {     @State var searchFilter: String = \"\"     // Implicitly use the default realm's objects(ItemGroup.self)\n\n         var body: some View {         if let itemGroup = itemGroups.first {             // Pass the ItemGroup objects to a view further             // down the hierarchy             ItemsView(itemGroup: itemGroup)         } else {             // For this small app, we only want one itemGroup in the realm.             // You can expand this app to support multiple itemGroups.             // For now, if there is no itemGroup, add one here.             ProgressView().onAppear {                 $itemGroups.append(ItemGroup())             }         }     } } \n``` ## Tip Starting in SDK version 10.12.0, you can use an optional key path parameter with `@ObservedResults` to filter change notifications to only those occurring on the provided key path or key paths. For example: ``` @ObservedResults(MyObject.self, keyPaths: [\"myList.property\"]) \n``` The ItemsView receives the itemGroup from the parent view and stores it in an [@ObservedRealmObject](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedRealmObject.html)property. This allows the ItemsView to \"know\" when the object has changed regardless of where that change happened. The ItemsView iterates over the itemGroup's items and passes each item to an**ItemRow** for rendering as a list. To define what happens when a user deletes or moves a row, we pass the`remove` and `move` methods of the Realm[List](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/List.html) as the handlers of the respective remove and move events of the SwiftUI List. Thanks to the`@ObservedRealmObject` property wrapper, we can use these methods without explicitly opening a write transaction. The property wrapper automatically opens a write transaction as needed. ```swift /// The screen containing a list of items in an ItemGroup. Implements functionality for adding, rearranging, /// and deleting items in the ItemGroup. struct ItemsView: View {     @ObservedRealmObject var itemGroup: ItemGroup     /// The button to be displayed on the top left.     var leadingBarButton: AnyView?     var body: some View {         NavigationView {             VStack {                 // The list shows the items in the realm.                 List {                     ForEach(itemGroup.items) { item in                         ItemRow(item: item)                     }.onDelete(perform: $itemGroup.items.remove)                     .onMove(perform: $itemGroup.items.move)                 }                 .listStyle(GroupedListStyle())                     .navigationBarTitle(\"Items\", displayMode: .large)                     .navigationBarBackButtonHidden(true)                     .navigationBarItems(                         leading: self.leadingBarButton,\n\n                         trailing: EditButton())                 // Action bar at bottom contains Add button.                 HStack {                     Spacer()                     Button(action: {                         // The bound collection automatically                         // handles write transactions, so we can                         // append directly to it.                         $itemGroup.items.append(Item())                     }) { Image(systemName: \"plus\") }                 }.padding()             }         }     } } \n``` Finally, the **ItemRow** and **ItemDetailsView** classes use the`@ObservedRealmObject` property wrapper with the item passed in from above. These classes demonstrate a few more examples of how to use the property wrapper to display and update properties. ```swift /// Represents an Item in a list. struct ItemRow: View {     @ObservedRealmObject var item: Item     var body: some View {         // You can click an item in the list to navigate to an edit details screen.         NavigationLink(destination: ItemDetailsView(item: item)) {             Text(item.name)             if item.isFavorite {                 // If the user \"favorited\" the item, display a heart icon                 Image(systemName: \"heart.fill\")             }         }     } } /// Represents a screen where you can edit the item's name. struct ItemDetailsView: View {     @ObservedRealmObject var item: Item     var body: some View {         VStack(alignment: .leading) {             Text(\"Enter a new name:\")             // Accept a new name             TextField(\"New name\", text: $item.name)                 .navigationBarTitle(item.name)                 .navigationBarItems(trailing: Toggle(isOn: $item.isFavorite) {                     Image(systemName: item.isFavorite ? \"heart.fill\" : \"heart\")                 })         }.padding()     } } \n``` ## Tip `@ObservedRealmObject` is a frozen object. If you want to [modify the properties](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-modify-frozen-object) of an `@ObservedRealmObject`directly in a write transaction, you must `.thaw()` it first. At this point, you have everything you need to work with Realm Database and SwiftUI. Test it out and see if everything is working as expected. Read on to learn how to integrate this app with Device Sync. ## Integrate Atlas Device Sync\n\n * [Create an App Services App.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enable anonymous authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication-configuration)\n* [Enable Device Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync)  \n   1. Choose [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync)  \n   2. Specify a cluster and database.  \n   3. Turn on Development Mode.  \n   4. Use `ownerId` as the queryable field.  \n   5. Use these permissions:  \n   ```  \n   {  \n     \"rules\": {},  \n     \"defaultRoles\": [  \n       {  \n         \"name\": \"owner-read-write\",  \n         \"applyWhen\": {},  \n         \"read\": {  \n           \"ownerId\": \"%%user.id\"  \n         },  \n         \"write\": {  \n           \"ownerId\": \"%%user.id\"  \n         }  \n       }  \n     ]  \n   }  \n   ```  \n   6. Enable Sync, and deploy your application updates. ## Tip The Sync version of this app changes the app flow a bit. The first screen becomes the **LoginView**. When you press the Log in button, the app navigates to the ItemsView, where you see the synced list of items in a single itemGroup. At the top of the source file, initialize an optional [Realm app](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/App.html) with [your App ID:](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ```swift // MARK: Atlas App Services (Optional) // The App Services App. Change YOUR_APP_SERVICES_APP_ID_HERE to your App Services App ID. // If you don't have a App Services App and don't wish to use Sync for now, // you can change this to: //   let app: RealmSwift.App? = nil let app: RealmSwift.App? = RealmSwift.App(id: YOUR_APP_SERVICES_APP_ID_HERE) \n``` ## Tip You can change the app reference to `nil` to switch back to local-only (non-Device Sync) mode. Let's update the main ContentView to show the **SyncContentView** if the app reference is not `nil`: ```swift /// The main screen that determines whether to present the SyncContentView or the LocalOnlyContentView. @main struct ContentView: SwiftUI.App {     var body: some Scene {         WindowGroup {             // Using Sync?             if let app = app {                 SyncContentView(app: app)             } else {                 LocalOnlyContentView()             }         }     } } \n``` We define the SyncContentView below.\n\n This view has two possible states: * If the Realm app does not have a currently logged-in user, show the **LoginView**.\n* If the app does have a logged-in user, show the **OpenSyncedRealmView**. In this view, after confirming we have a user, we create a[flexibleSyncConfiguration()](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE25flexibleSyncConfigurationAC0B0V0F0VyF)that includes the `initialSubscriptions` parameter. We can use this parameter to [subscribe to queryable fields](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-ios-sync-subscribe-to-queryable-fields). These initial subscriptions search for data that matches the queries, and syncs that data to the realm. If no data matches the queries, the realm opens with an initial empty state. Your client application can only write objects that match the subscription query to a realm opened with a `flexibleSyncConfiguration`. Trying to write objects that don't match the query causes the app to perform a compensating write to undo the illegal write operation. ```swift /// This view observes the Realm app object. /// Either direct the user to login, or open a realm /// with a logged-in user. struct SyncContentView: View {     // Observe the Realm app object in order to react to login state changes.     @ObservedObject var app: RealmSwift.App     var body: some View {         if let user = app.currentUser {             // Create a `flexibleSyncConfiguration` with `initialSubscriptions`.             // We'll inject this configuration as an environment value to use when opening the realm             // in the next view, and the realm will open with these initial subscriptions.             let config = user.flexibleSyncConfiguration(initialSubscriptions: { subs in                 // Check whether the subscription already exists. Adding it more                 // than once causes an error.                 if let foundSubscriptions = subs.first(named: \"user_groups\") {                     // Existing subscription found - do nothing                     return                 } else {                     // Add queries for any objects you want to use in the app                     // Linked objects do not automatically get queried, so you                     // must explicitly query for all linked objects you want to include                     subs.append(QuerySubscription<ItemGroup>(name: \"user_groups\") {                         // Query for objects where the ownerId is equal to the app's current user's id                         // This means the app's current user can read and write their own data                         $0.ownerId == user.id                     })                     subs.append(QuerySubscription<Item>(name: \"user_items\") {                         $0.ownerId == user.id                     })\n\n             })             OpenSyncedRealmView()                 .environment(\\.realmConfiguration, config)         } else {             // If there is no user logged in, show the login view.             LoginView()         }     } } \n``` In our subscriptions, we're querying for `ItemGroup` and `Item` objects where the `ownerId` matches the logged-in user's `user.id`. Together with the permissions we used when we enabled Device Sync above, this means that the user can only read and write their own data. Flexible Sync does not automatically provide access to linked objects. Because of this, we must add subscriptions for both the `ItemGroup` and`Item` objects - we can't just query for one or the other and get the related objects. From here, we pass the flexibleSyncConfiguration to the OpenSyncedRealmView as a `realmConfiguration` using an environment object. This is the view responsible for opening a realm and working with the data. Sync uses this configuration to search for data that should sync to the realm. ```swift OpenSyncedRealmView()     .environment(\\.realmConfiguration, config) \n``` Once logged in, we open the realm asynchronously with the [AsyncOpen](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AsyncOpen.html) property wrapper. Because we've injected a `flexibleSyncConfiguration()` into the view as an environment value, the property wrapper uses this configuration to initiate Sync and download any matching data before opening the realm. If we had not provided a configuration, the property wrapper would create a default `flexibleSyncConfiguration()` for us, and we could [subscribe to queries](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-ios-sync-add-subscription)in `.onAppear`. ```swift // We've injected a `flexibleSyncConfiguration` as an environment value, // so `@AsyncOpen` here opens a realm using that configuration. @AsyncOpen(appId: YOUR_APP_SERVICES_APP_ID_HERE, timeout: 4000) var asyncOpen \n``` The OpenSyncedRealmView switches on the [AsyncOpenState enum](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/AsyncOpenState.html), which lets us show different views based on the state. In our example, we show a `ProgressView` while we're connecting to the App and the realm is syncing. We then open the realm, passing the `itemGroup` to the `ItemsView`, or show an`ErrorView` if we can't open the realm. ## Tip When opening a synced realm, use the [AsyncOpen](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AsyncOpen.html) property wrapper to always download synced changes before opening the realm, or the [AutoOpen](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AutoOpen.html) property wrapper to open a realm while syncing in the background. `AsyncOpen` requires the user to be online, while `AutoOpen` opens a realm even if the user is offline. This view has a few different states: * While connecting or waiting for login, show a `ProgressView`.\n* While downloading changes to the realm, show a `ProgressView` with a progress indicator.\n* When the realm opens, check for an itemGroup object. If one does not exist yet, create one. Then, show the ItemsView for the itemGroup in the realm. Provide a **LogoutButton** that the ItemsView can display on the top left of the navigation bar.\n* If there is an error loading the realm, show an error view containing the error. When you run the app and see the main UI, there are no items in the view. That's because we're using anonymous login, so this is the first time this specific user logs in. ```swift /// This view opens a synced realm. struct OpenSyncedRealmView: View {\n\n     // so `@AsyncOpen` here opens a realm using that configuration.     @AsyncOpen(appId: YOUR_APP_SERVICES_APP_ID_HERE, timeout: 4000) var asyncOpen         var body: some View {         // Because we are setting the `ownerId` to the `user.id`, we need         // access to the app's current user in this view.         let user = app?.currentUser         switch asyncOpen {         // Starting the Realm.asyncOpen process.         // Show a progress view.         case .connecting:             ProgressView()         // Waiting for a user to be logged in before executing         // Realm.asyncOpen.         case .waitingForUser:             ProgressView(\"Waiting for user to log in...\")         // The realm has been opened and is ready for use.         // Show the content view.         case .open(let realm):             ItemsView(itemGroup: {                 if realm.objects(ItemGroup.self).count == 0 {                     try! realm.write {                         // Because we're using `ownerId` as the queryable field, we must                         // set the `ownerId` to equal the `user.id` when creating the object                         realm.add(ItemGroup(value: [\"ownerId\":user!.id]))                     }                 }                 return realm.objects(ItemGroup.self).first!             }(), leadingBarButton: AnyView(LogoutButton())).environment(\\.realm, realm)             // The realm is currently being downloaded from the server.             // Show a progress view.         case .progress(let progress):             ProgressView(progress)         // Opening the Realm failed.         // Show an error view.         case .error(let error):             ErrorView(error: error)         }     } } \n``` In our subscriptions, we're querying for `ItemGroup` and `Item` objects where the `ownerId` matches the logged-in user's `user.id`. Together with the permissions we used when we created the Flexible Sync app above, this means that the user can only read and write their own data. Flexible Sync does not automatically provide access to linked objects. Because of this, we must add subscriptions for both the `ItemGroup` and`Item` objects - we can't just query for one or the other and get the related objects. With this in mind, we must also update the view here where we are creating a `ItemGroup` object. We must set the `ownerId` as the `user.id`of the logged-in user. ```swift ItemsView(itemGroup: {     if realm.objects(ItemGroup.self).count == 0 {         try! realm.write {             // Because we're using `ownerId` as the queryable field, we must             // set the `ownerId` to equal the `user.id` when creating the object\n\n         }     }     return realm.objects(ItemGroup.self).first! }(), leadingBarButton: AnyView(LogoutButton())).environment(\\.realm, realm) \n``` And we must also update the `ItemsView` to add `ownerId` when we create `Item` objects: ```swift // Action bar at bottom contains Add button. HStack {     Spacer()     Button(action: {         // The bound collection automatically         // handles write transactions, so we can         // append directly to it.         // Because we are using Flexible Sync, we must set         // the item's ownerId to the current user.id when we create it.         $itemGroup.items.append(Item(value: [\"ownerId\":user!.id]))     }) { Image(systemName: \"plus\") } }.padding() \n``` ### Authenticate Users with Atlas App Services The LoginView maintains some state in order to display an activity indicator or error. It uses a reference to the Realm app instance passed in from above to log in when the Log in anonymously button is clicked. ## Tip In the LoginView, you can implement [email/password authentication](https://mongodb.com/docs/realm/sdk/swift/users/manage-email-password-users/#std-label-ios-manage-email-password-users) or [another authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers). For simplicity, this example uses [Anonymous authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) Once login is complete, the LoginView itself doesn't need to do anything more. Because the parent view is observing the Realm app, it will notice when the user authentication state has changed and decide to show something other than the LoginView. ```swift /// Represents the login screen. We will have a button to log in anonymously. struct LoginView: View {     // Hold an error if one occurs so we can display it.     @State var error: Error?         // Keep track of whether login is in progress.     @State var isLoggingIn = false     var body: some View {         VStack {             if isLoggingIn {                 ProgressView()             }             if let error = error {                 Text(\"Error: \\(error.localizedDescription)\")             }             Button(\"Log in anonymously\") {                 // Button pressed, so log in                 isLoggingIn = true                 Task {                     do {                         let user = try await app!.login(credentials: .anonymous)                         // Other views are observing the app and will detect                         // that the currentUser has changed. Nothing more to do here.                         print(\"Logged in as user with id: \\(user.id)\")                     } catch {                         print(\"Failed to log in: \\(error.localizedDescription)\")\n\n                         self.error = error                         return                     }                 }             }.disabled(isLoggingIn)         }     } } \n``` The LogoutButton works just like the LoginView, but logs out instead of logging in: ```swift /// A button that handles logout requests. struct LogoutButton: View {     @State var isLoggingOut = false     var body: some View {         Button(\"Log Out\") {             guard let user = app!.currentUser else {                 return             }             isLoggingOut = true             Task {                 do {                     try await app!.currentUser!.logOut()                     // Other views are observing the app and will detect                     // that the currentUser has changed. Nothing more to do here.                 } catch {                     print(\"Error logging out: \\(error.localizedDescription)\")                 }             }         }.disabled(app!.currentUser == nil || isLoggingOut)     } } \n``` Once logged in, the app follows the same flow as the local-only version. ## Complete Code If you would like to copy and paste or examine the complete code with or without Device Sync, see below. ← [SwiftUI - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/swiftui/ \"Previous Section\")[Model Data- SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/realm-files/tvos/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Build for tvOS On this page * [Overview](#overview)\n* [Avoid Storing Important User Data](#avoid-storing-important-user-data)\n* [Share Realm Files with TV Services Extensions](#share-realm-files-with-tv-services-extensions) ## Overview This page details considerations when using Realm Database on tvOS. ## Tip ### See also:  [Install Realm for iOS, macOS, tvOS, and watchOS](https://mongodb.com/docs/realm/sdk/swift/install/#std-label-ios-install) ## Avoid Storing Important User Data Avoid storing important user data in a realm on tvOS. Instead, it's best to treat Realm as a rebuildable cache. ## Note The reason for this has to do with where Realm writes its[Realm files](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-realm-file). On other Apple platforms, Realm writes its Realm files to the \"Documents\" directory. Because tvOS restricts writes to that directory, the default Realm file location on tvOS is instead `NSCachesDirectory`. tvOS can purge files in that directory at any time, so reliable long-term persistence is not possible. For cloud-backed persistence on tvOS, consider using [Device Sync.](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/#std-label-ios-sync-changes-between-devices) You can also use Realm as an initial data source by[bundling prebuilt Realm files](https://mongodb.com/docs/realm/sdk/swift/realm-files/bundle-a-realm/#std-label-ios-bundle-a-realm) in your app. Note that the [App Store guidelines](https://developer.apple.com/tvos/submit/) limit your app size to 4GB. ## Tip Browse our [tvOS examples](https://github.com/realm/realm-swift/tree/master/examples/tvos) for sample tvOS apps that demonstrate how to use Realm as an offline cache. ## Share Realm Files with TV Services Extensions To share a [Realm file](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-realm-file) between a tvOS app and a TV services extension such as [Top Shelf](https://developer.apple.com/design/human-interface-guidelines/tvos/overview/top-shelf/), use the`Library/Caches/` directory in the shared container for the application group: `| let fileUrl = FileManager.default                                                                   |\n| --------------------------------------------------------------------------------------------------- |\n| .containerURL(forSecurityApplicationGroupIdentifier: \"group.com.mongodb.realm.examples.extension\")! |\n| .appendingPathComponent(\"Library/Caches/default.realm\")                                             | ` ← [Encrypt a Realm - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/encrypt-a-realm/ \"Previous Section\")[Model Data - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/sync-realm-open-legacy/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Legacy Sync Open Methods - Swift SDK On this page * [Overview](#overview)\n* [Open A Synced Realm Offline](#open-a-synced-realm-offline)\n* [Open a Synced Realm for the First Time](#open-a-synced-realm-for-the-first-time)\n* [Authenticate a User](#authenticate-a-user)\n* [Log In and Open a Synced Realm with Data on the Device](#log-in-and-open-a-synced-realm-with-data-on-the-device)\n* [Log In and Download Changes Before Opening a Realm](#log-in-and-download-changes-before-opening-a-realm)\n* [Open a Synced Realm with Cached Credentials](#open-a-synced-realm-with-cached-credentials)\n* [Open a Synced Realm with Data on the Device](#open-a-synced-realm-with-data-on-the-device)\n* [Open a Synced Realm After Downloading Changes](#open-a-synced-realm-after-downloading-changes) ## Overview The examples on this page describe how to work with synced realms in Swift SDK versions prior to 10.15.0\\. Alternately, if you're building apps for iOS targets prior to 15.0, with Swift versions older than 5.5, or with Objective-C, you can use these methods and code examples to work with realms asynchronously. ## Note The `OpenBehavior` enum, and [the ability to specify whether to download data before opening a realm](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-ios-specify-download-behavior), do not apply to the legacy examples on this page. If you want to require downloading changes before opening a realm with this older syntax, you must use `asyncOpen`, which [always downloads changes before opening a realm.](#std-label-ios-open-synced-realm-after-sync) ## Tip ### See also:  If you're using Swift 5.5 with Swift SDK 10.15.0 or newer, see the[Sync Changes Between Devices page.](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/#std-label-ios-sync-changes-between-devices) ### Open A Synced Realm Offline You can work with synced realms offline if the user credentials are cached and you use the `Realm()` initializers to open the realms. If you use `asyncOpen` instead of initializers to open the realm, the user always has the most up-to-date data, but must have a network connection. ## Open a Synced Realm for the First Time ### Authenticate a User The first time a user opens a realm, you must authenticate the user. Upon this initial login, Realm caches login credentials. On subsequent opens, check for a logged-in user, and then open new realms. You can skip the login flow while you have a logged-in user. Depending on your business logic, you may also require the user to download data from App Services before opening a synced realm on device. ### Log In and Open a Synced Realm with Data on the Device ### Log In and Download Changes Before Opening a Realm ## Open a Synced Realm with Cached Credentials After you have authenticated a user and created a sync configuration to open a realm, you can open the same realm again using the sync configuration with cached credentials. You can use two different methods to open the synced realm, depending on your needs:\n\n ### Open a Synced Realm with Data on the Device You can use initializers to open the realm immediately, using the data that is on the device. If you want to open a synced realm offline, use this method. You must have a cached, logged-in user. ## Example Consider the example of a note-taking app. You might decide it's most important for your user to be able to quickly jot down a note. The user shouldn't have to wait while downloading changes that a family member made to a shared note. In this case, opening a realm with `init` gets the user to the UI right away, or while the user is offline. When the user has a network connection, changes sync in the background. In contrast, you might want a store inventory app to always check the server for changes before working with a realm. If you use stale data from the last time the realm was open on the device, the app data could reflect incorrect counts, inaccurate pricing data, or other out-of-date data issues. In that case, you'd want the app to download changes before letting the user work with the data. ## Note A synced realm is not interchangeable with a local Realm Database. If you want to sync a local Realm Database, you must [copy the content from the local realm to a synced realm](https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/local-to-sync/#std-label-copy-local-data-to-synced-realm). A local realm lives only on the device and never attempts to sync with the server. A synced realm contains additional Sync-related metadata, and consistently and persistently attempts to connect and sync data with the server. ### Open a Synced Realm After Downloading Changes In some apps, such as games, you might want the user to always have current data. Use `asyncOpen` to sync the realm with the App before opening it. ## Example Say a user plays a game on both an iPad and an iPhone. The user progresses three levels on the iPad. Later, the user opens the game on an iPhone. In this case, `asyncOpen` is a better way to open the realm. Loading with stale data would get the user into the game faster, but the user's data would be three levels out of sync. In contrast, if you had an app that allowed the user to record and save their favorite recipes, you might want to give them the option to create a new recipe without waiting to download updates, or even if they're offline. If you opened a synced realm with data on the device, the user could enter a new recipe, which would sync with the App when they next had a network connection. A common pattern is to open a realm with `asyncOpen` in the login flow, and then use `init` for subsequent opens. If you want users to only interact with the most up-to-date version of your data, you can exclusively use`asyncOpen`. This incurs the cost of additional loading time and prevents users from opening a realm while offline. [Welcome to the Realm Docs](https://mongodb.com/docs/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Configure & Open a Realm - Swift SDK On this page * [Key Concept: Realm Files](#key-concept--realm-files)\n* [In-Memory Realms](#in-memory-realms)\n* [Default Realm](#default-realm)\n* [Open a Realm Without Sync](#open-a-realm-without-sync)\n* [Open a Default Realm or Realm at a File URL](#open-a-default-realm-or-realm-at-a-file-url)\n* [Open an In-Memory Realm](#open-an-in-memory-realm)\n* [Close a Realm](#close-a-realm)\n* [Handle Errors When Accessing a Realm](#handle-errors-when-accessing-a-realm)\n* [Provide a Subset of Classes to a Realm](#provide-a-subset-of-classes-to-a-realm)\n* [Initialize Properties Using Realm APIs](#initialize-properties-using-realm-apis)\n* [Use Realm When the Device Is Locked](#use-realm-when-the-device-is-locked) A **realm** is the core data structure used to organize data in Realm Database. A realm is a collection of the objects that you use in your application, called Realm objects, as well as additional metadata that describe the objects. To learn how to define a Realm object, see[Define an Object Model.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-a-realm-object-schema) When you open a realm, you can pass a [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html) that specifies additional details about how to configure the realm file. This includes things like: * Pass a fileURL or in-memory identifier to customize how the realm is stored on device\n* Provide a logged-in user and Sync details to use Sync with the realm\n* Specify the realm use only a subset of your app's classes\n* Whether and when to compact a realm to reduce its file size\n* Pass an encryption key to encrypt a realm\n* Provide a schema version or migration block when making schema changes ## Tip ### See also:  This page covers how to open a realm file that does not [sync data](https://mongodb.com/docs/realm/sdk/swift/application-services/#std-label-ios-realm-sync). If you'd like to use Device Sync to sync data with other devices, see: [Configure & Open a Synced Realm.](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-ios-configure-and-open-a-synced-realm) ## Key Concept: Realm Files Realm Database stores a binary encoded version of every object and type in a realm in a single `.realm` file. The file is located at [a specific path](#std-label-ios-default-and-file-url-realm) that you can define when you open the realm. You can open, view, and edit the contents of these files with[Realm Studio.](https://mongodb.com/docs/realm/studio/#std-label-realm-studio) ## Tip ### See: Auxiliary Realm Files Realm Database creates additional files for each realm. To learn more about these files, see [Realm Database Internals](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-realm-database). Deleting these files has important implications. For more information about deleting `.realm` or auxiliary files, see:[Delete a Realm](https://mongodb.com/docs/realm/sdk/swift/realm-files/delete-a-realm/#std-label-swift-delete-a-realm) ### In-Memory Realms You can also open a realm entirely in memory, which does not create a `.realm`file or its associated auxiliary files. Instead the SDK stores objects in memory while the realm is open and discards them immediately when all instances are closed. ## Tip ### See: Open an In-Memory Realm\n\n ### Default Realm Calling [Realm()](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html) or[RLMRealm](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMRealm.html) opens the default realm. This method returns a realm object that maps to a file named`default.realm`. You can find this file: * iOS: in the Documents folder of your app\n* macOS: in the Application Support folder of your app ## Tip ### See: Open a Default Realm To open a default realm, see [Open a Default Realm or Realm at a File URL.](#std-label-ios-default-and-file-url-realm) ## Open a Realm Without Sync You can open a non-synced local realm with several different configuration options: * No configuration - i.e. default configuration\n* Specify a file URL for the realm\n* Open the realm only in memory, without saving a file to the file system\n* Copy a synced realm to use without Sync ### Open a Default Realm or Realm at a File URL ### Open an In-Memory Realm You can open a realm entirely in memory, which will not create a`.realm` file or its associated [auxiliary files](#std-label-ios-realm-file). Instead the SDK stores objects in memory while the realm is open and discards them immediately when all instances are closed. ## Important When all _in-memory_ realm instances with a particular identifier go out of scope, Realm Database deletes **all data** in that realm. To avoid this, hold onto a strong reference to any in-memory realms during your app's lifetime. ## Close a Realm There is no need to manually close a realm in Swift or Objective-C. When a realm goes out of scope and is removed from memory due to[ARC](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html), the realm is closed. ## Handle Errors When Accessing a Realm ## Provide a Subset of Classes to a Realm ## Tip ### Operating with Low Memory Constraints Some applications, such as watchOS apps and iOS app extensions, have tight constraints on their memory footprints. To optimize your data model for low-memory environments, open the realm with a subset of classes. ## Initialize Properties Using Realm APIs You might define properties whose values are initialized using Realm Database APIs. For example: `| class SomeSwiftType {                           |\n| ----------------------------------------------- |\n| let persons = try! Realm().objects(Person.self) |\n| // ...                                          |\n| }                                               | ` If this initialization code runs before you set up your Realm configurations, you might get unexpected behavior. For example, if you set a [migration](https://mongodb.com/docs/realm/sdk/swift/model-data/change-an-object-model/#std-label-ios-migrations) block for the default realm configuration in `applicationDidFinishLaunching()`, but you create an instance of `SomeSwiftType` before`applicationDidFinishLaunching()`, you might be accessing your realm before it has been correctly configured. To avoid such issues, consider doing one of the following: * Defer instantiation of any type that eagerly initializes properties using Realm Database APIs until after your app has completed setting up its realm configurations.\n* Define your properties using Swift's `lazy` keyword. This allows you to safely instantiate such types at any time during your application's lifecycle, as long as you do not attempt to access your `lazy` properties until after your app has set up its realm configurations.\n* Only initialize your properties using Realm APIs that explicitly take in user-defined configurations. You can be sure that the configuration values you are using have been set up properly before they are used to open realms. ## Use Realm When the Device Is Locked\n\n ``` open() failed: Operation not permitted \n``` To handle this, downgrade the file protection of the folder containing[the Realm files](#std-label-ios-realm-file). A less strict protection level like [NSFileProtectionCompleteUntilFirstUserAuthentication](https://developer.apple.com/documentation/foundation/nsfileprotectioncompleteuntilfirstuserauthentication)allows file access even when the device is locked. ## Tip If you reduce iOS file encryption, consider using Realm's[built-in encryption](https://mongodb.com/docs/realm/sdk/swift/realm-files/encrypt-a-realm/#std-label-ios-encrypt-a-realm) to secure your data instead. This example shows how to apply a less strict protection level to the parent directory of the default realm. ```swift let realm = try! Realm() // Get the realm file's parent directory let folderPath = realm.configuration.fileURL!.deletingLastPathComponent().path // Disable file protection for this directory after the user has unlocked the device once try! FileManager.default.setAttributes([FileAttributeKey.protectionKey: FileProtectionType.completeUntilFirstUserAuthentication],                                        ofItemAtPath: folderPath) \n``` Realm may create and delete auxiliary files at any time. Instead of downgrading file protection on the files, apply it to the parent folder. This way, the file protection applies to all relevant files regardless of creation time. ## Tip ### See also:  [Sync Data in the Background - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/background-sync/#std-label-ios-sync-changes-in-the-background) ← [Work with Realm Files - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/ \"Previous Section\")[Delete a Realm File - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/realm-files/delete-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/write-to-synced-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Write Data to a Synced Realm - Swift SDK On this page * [Overview](#overview)\n* [Determining What Data Syncs](#determining-what-data-syncs)\n* [App Services Configuration](#app-services-configuration)\n* [Client Data Model and Configuration](#client-data-model-and-configuration)\n* [What Data Syncs?](#what-data-syncs-)\n* [Write to a Synced Realm](#write-to-a-synced-realm)\n* [Successful Writes](#successful-writes)\n* [Compensating Writes](#compensating-writes)\n* [Writes that Don't Match the Query Subscription](#writes-that-don-t-match-the-query-subscription)\n* [Writes That Don't Match Permissions](#writes-that-don-t-match-permissions)\n* [Don't Write to a Synced Realm in an App Extension](#don-t-write-to-a-synced-realm-in-an-app-extension)\n* [Crashes Related to Opening a Synced Realm in Multiple Processes](#crashes-related-to-opening-a-synced-realm-in-multiple-processes)\n* [Alternatives to Writing to a Synced Realm in an App Extension](#alternatives-to-writing-to-a-synced-realm-in-an-app-extension)\n* [Pass Data On Disk](#pass-data-on-disk)\n* [Communicate Directly with the Backing Atlas Collection](#communicate-directly-with-the-backing-atlas-collection) ## Overview When writing data to a synced realm using Flexible Sync, you can use the same APIs as writing to a local realm. However, there are some differences in behavior to keep in mind as you develop your application. When you write to a synced realm, your write operations must match _both_of the following: * **The sync subscription query.**  \n   * If your write operation doesn't match the query in the subscription, the write reverts with a non-fatal compensating write error (ErrorCompensatingWrite).\n* **The permissions** in your App Services App.  \n   * If your try to write data that doesn't match the permissions expression, the write reverts with a non-fatal permission denied error. In the client, this shows as an error (ErrorCompensatingWrite). On the server, you can see more details about how the write was denied was by a write filter in the role.  \n   * To learn more about configuring permissions for your app, see[Role-based Permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-sync-rules) and the [Device Sync Permissions Guide](https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/#std-label-flexible-sync-permissions-guide) in the App Services documentation. ## Warning ### Multiprocess Sync is Not Supported Device Sync does not currently support opening or writing to a synced realm from more than one process. For more information, including suggested alternatives, refer to: [Don't Write to a Synced Realm in an App Extension.](#std-label-multiprocess-sync-not-supported) ## Determining What Data Syncs The data that you can write to a synced realm is the intersection of your Device Sync configuration, your permissions, and the Flexible Sync subscription query that you use when you open the realm. The examples on this page use the following configurations and models: ### App Services Configuration Device Sync is configured with the following queryable fields: * `_id` (always included)\n* `miles`\n* `ownerId` The App Services App has permissions configured to let users read and write only their own data:\n\n ` ### Client Data Model and Configuration The examples on this page use the following object model: ```swift class Item: Object {     @Persisted(primaryKey: true) var _id: ObjectId     @Persisted var ownerId: String     @Persisted var itemName: String     @Persisted var complexity: Int } \n``` Using that object model, the synced realm configuration syncs objects that match the subscription query where the `complexity` property's value is less than or equal to `4`: ```swift let app = App(id: YOUR_APP_ID_HERE) do {     let user = try await app.login(credentials: Credentials.anonymous)     do {         var flexSyncConfig = user.flexibleSyncConfiguration()         flexSyncConfig.objectTypes = [Item.self]         let realm = try await Realm(configuration: flexSyncConfig)         let subscriptions = realm.subscriptions         try await subscriptions.update {             subscriptions.append(                 QuerySubscription<Item>(name: \"simple-items\") {                  $0.complexity <= 4             })         }         print(\"Successfully opened realm: \\(realm)\")     } catch {         print(\"Failed to open realm: \\(error.localizedDescription)\")         // handle error     } } catch {     fatalError(\"Login failed: \\(error.localizedDescription)\") } \n``` ### What Data Syncs? The subscription query combined with the permissions mean that the synced realm only syncs objects where: * The `ownerId` matches the `user.id` of the logged-in user (from the permissions)\n* The `complexity` property's value is less than or equal to `4` (from the subscription query) Any object in the Atlas collection where the `ownerId` does not match the `user.id` of the logged-in user, or the `complexity` property's value is greater than `4`, cannot sync to this realm. ## Write to a Synced Realm Writes to Flexible Sync realms may broadly fall into one of two categories: * **Successful writes**: The written object matches both the query subscription and the user's permissions. The object writes successfully to the realm, and syncs successfully to the App Services backend and other devices.\n* **Compensating writes**: When the written object does not match the subscription query, or where the user does not have sufficient permissions to perform the write, Realm reverts the illegal write. ### Successful Writes When the write matches both the [permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-permissions) and the[Flexible Sync subscription query](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-swift-manage-flexible-sync-subscriptions) in the client, the Realm Swift SDK can successfully write the object to the synced realm. This object syncs with the App Services backend when the device has a network connection. ```swift // This write falls within the subscription query and complies // with the Device Sync permissions, so this write should succeed. do {     let learnRealm = Item()     learnRealm.ownerId = user.id     learnRealm.itemName = \"Learn Realm CRUD stuff\"     learnRealm.complexity = 3     try realm.write {         realm.add(learnRealm)     } } catch {     print(\"Failed to write to realm: \\(error.localizedDescription)\") } \n``` ### Compensating Writes In some cases, a write that initially appears to succeed is actually an illegal write. In these cases, the object writes to the database, but when the database syncs to the backend, Realm reverts the write in a non-fatal error operation called a compensating write. Compensating writes can occur when:\n\n In more detail, when you write data that is outside the bounds of a query subscription or does not match the user's permissions, the following occurs: 1. Because the client realm has no concept of \"illegal\" writes, the write initially succeeds until realm resolves the changeset with the App Services backend.\n2. Upon sync, the server applies the rules and permissions. The server determines that the user does not have authorization to perform the write.\n3. The server sends a revert operation, called a \"compensating write\", back to the client.\n4. The client's realm reverts the illegal write operation by deleting the illegal object from the realm. Any client-side writes to a given object between an illegal write to that object and the corresponding compensating write will be lost. In practice, this may look like an object being written to the realm, and then disappearing after the server sends the compensating write back to the client. To learn more about permission denied errors, compensating write errors and other Device Sync error types, refer to [Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services documentation. #### Writes that Don't Match the Query Subscription You can only write objects to a Flexible Sync realm if they match the subscription query. If you perform a write that does not match the subscription query, Realm initially writes the object, but then performs a compensating write. This is a non-fatal operation that reverts an illegal write that does not match the subscription query. In practice, this may look like the write succeeding, but then the object \"disappears\" when Realm syncs with the App Services backend and performs the compensating write. If you want to write an object that does not match the query subscription, you must open a different realm where the object matches the query subscription. Alternately, you could write the object to a [non-synced realm](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-swift-synced-realms-vs-non-synced-realms) that does not enforce permissions or subscription queries. There is no way to write an object to a Flexible Sync realm that does not match the query subscription. ##### Code Example Given the configuration for the Flexible Sync realm above, attempting to write this object does not match the query subscription: ```swift do {     let fixTheBug = Item()     fixTheBug.ownerId = user.id     fixTheBug.itemName = \"Fix the bug with the failing method\"     // The complexity of this item is `7`. This is outside the bounds     // of the subscription query, so this write triggers a compensating write.     fixTheBug.complexity = 7     try realm.write {         realm.add(fixTheBug)     } } catch {     print(\"Failed to write to realm: \\(error.localizedDescription)\") } \n``` ##### Client Error The error message in the client-side logs in this scenario is: ``` Sync: Connection[1]: Session[1]: Received: ERROR \"Client attempted a write that is outside of permissions or query filters; it has been reverted\" (error_code=231, try_again=true, error_action=Warning) \n``` ##### App Services Error The error message in the App Services logs in this scenario is: ``` \"FlexibleSync_Item\": {     \"63bdfc40f16be7b1e8c7e4b7\": \"write to \\\"63bdfc40f16be7b1e8c7e4b7\\\"     in table \\\"FlexibleSync_Item\\\" not allowed; object is outside of     the current query view\" } \n``` #### Writes That Don't Match Permissions Attempting to write to the client can also trigger a compensating write error when the object does not match the user's server-side write permissions. On the client, this type of write behaves the same as a write that doesn't match the query subscription. In practice, this may look like the write succeeding, but then the object \"disappears\" when Realm syncs with the App Services backend and performs the compensating write. ##### Code Example\n\n ```swift do {     let itemWithWrongOwner = Item()     // The `ownerId` of this item does not match the `user.id` of the logged-in     // user. The user does not have permissions to make this write, so     // it triggers a compensating write.     itemWithWrongOwner.ownerId = \"This string does not match the user.id\"     itemWithWrongOwner.itemName = \"Write code that generates a permission error\"     itemWithWrongOwner.complexity = 1     try realm.write {         realm.add(itemWithWrongOwner)     } } catch {     print(\"Failed to write to realm: \\(error.localizedDescription)\") } \n``` ##### Client Error The client error in this scenario is the same as when you attempt to write an object that is outside the query filter: ``` Sync: Connection[1]: Session[1]: Received: ERROR \"Client attempted a write that is outside of permissions or query filters; it has been reverted\" (error_code=231, try_again=true, error_action=Warning) \n``` ##### App Services Error The error message in the App Services logs provides some additional information to help you determine that it is a permissions issue, and not a query subscription issue. In this example, the error message shows that the the object does not match the user's role: ``` \"FlexibleSync_Item\": {     \"63bdfc40f16be7b1e8c7e4b8\": \"write to \\\"63bdfc40f16be7b1e8c7e4b8\\\"     in table \\\"FlexibleSync_Item\\\" was denied by write filter in role     \\\"owner-read-write\\\"\" } \n``` ## Don't Write to a Synced Realm in an App Extension If you are developing an app that uses App Extensions, such as a Share Extension, avoid writing to a synced realm in that extension. Device Sync supports opening a synced realm in at most one process. In practice, this means that if your app uses a synced realm in an App Extension, it may crash intermittently. ### Crashes Related to Opening a Synced Realm in Multiple Processes If you attempt to open a synced realm in a Share Extension or other App Extension, and that realm is not open in the main app, a write from a Share Extension may succeed. However, if the synced realm is already open in the main app, or is syncing data in the background, you may see a crash related to `Realm::MultiSyncAgents`. In this scenario, you may need to restart the device. ### Alternatives to Writing to a Synced Realm in an App Extension If you need to read from or write to a synced realm from an App Extension, there are a few recommended alternatives: * **Offline-first**: pass data on disk to or from the main app\n* **Always up-to-date**: communicate directly with the backing Atlas collection across a network connection #### Pass Data On Disk If offline-first functionality is the most important consideration for your app, you can pass data on disk to or from your main app. You could copy objects to a non-synced realm and read and share it between apps in an App Group. Or you could use an on-disk queue to send the data to or from the main app and only write to the synced realm from there. Then, regardless of the device's network connectivity, information can be shared any time to or from the App Extension. #### Communicate Directly with the Backing Atlas Collection If having the information always up-to-date across all devices is the most important consideration for your app, you can read or write data directly to or from the backing Atlas collection across the network. Depending on your needs, you may want to use one of these tools to communicate directly with Atlas:\n\n Then, any device that has a network connection is always getting the most up-to-date information, without waiting for the user to open your main app as in the option above. This option does require your user's device to have a network connection when using the App Extension. As a fallback, you could check for a network connection. Then, use the on-disk option above in the event that the user's device lacks network connectivity. ← [Manage Flexible Sync Subscriptions - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/ \"Previous Section\")[Handle Sync Errors - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/handle-sync-errors/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/background-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Data in the Background - Swift SDK On this page * [Sync Changes in the Background](#sync-changes-in-the-background) ## Sync Changes in the Background If you want your app to update data in the background (while the app is minimized), iOS requires you to implement [Background App Refresh](https://developer.apple.com/documentation/uikit/app%5Fand%5Fenvironment/scenes/preparing%5Fyour%5Fui%5Fto%5Frun%5Fin%5Fthe%5Fbackground/updating%5Fyour%5Fapp%5Fwith%5Fbackground%5Fapp%5Frefresh). Enabling Background App Refresh minimizes the time it takes for the user to see the most recent data; without Background App Refresh, Realm updates the data when the user launches the app, potentially resulting in noticeable lag. To use the realm while the device is locked, you must adjust the file protection settings. See[Use Realm When the Device Is Locked.](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-use-realm-when-the-device-is-locked) For an example of how to sync changes in the background using the SwiftUI `BackgroundTask` API, see: [Sync Data in the Background with SwiftUI.](https://mongodb.com/docs/realm/sdk/swift/swiftui/background-sync/#std-label-swiftui-background-sync) ← [Handle Sync Errors - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/handle-sync-errors/ \"Previous Section\")[Suspend or Resume a Sync Session - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/sync-session/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/log-level/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Set the Client Log Level - Swift SDK On this page * [Set the Client Log Level](#set-the-client-log-level)\n* [Set a Custom Logger](#set-a-custom-logger) ## Set the Client Log Level ## Tip See [RLMSyncLogLevel](https://www.mongodb.com/docs/realm-sdks/objc/latest/Enums/RLMSyncLogLevel.html) for a description of each available log level. Note that more logging can negatively affect performance. ## Tip To diagnose and troubleshoot errors while developing your application, set the log level to `debug` or `trace`. For production deployments, decrease the log level for improved performance. ## Set a Custom Logger You can pipe Device Sync logs to a custom logger by setting the `logger`property on the `SyncManager`. You must set this property before you open any synced realms. If you do not specify this property, the Realm Swift SDK outputs log strings to Apple System Logger. `| let app = App(id: YOUR_APP_SERVICES_APP_ID)                                                      |\n| ------------------------------------------------------------------------------------------------ |\n| // Access the sync manager for the app                                                           |\n| let syncManager = app.syncManager                                                                |\n| // Set the logger to provide debug logs                                                          |\n| syncManager.logLevel = .all                                                                      |\n| syncManager.logger = { logLevel, message in                                                      |\n| AnalyticsProvider.shared.logEvent(\"\\(logLevel) : \\(message)\", category: \"Engineering debugging\") |\n| }                                                                                                | ` ← [Check the Network Connection - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/network-connection/ \"Previous Section\")[Event Library - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/event-library/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/sync-session/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Suspend or Resume a Sync Session - Swift SDK On this page * [Suspend or Resume a Sync Session](#suspend-or-resume-a-sync-session)\n* [When to Pause a Sync Session](#when-to-pause-a-sync-session) ## Suspend or Resume a Sync Session Opening a synced realm starts a [SyncSession](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/SyncSession.html)for that realm. You can suspend and resume the sync session on the realm. Pausing a sync session only suspends that realm's sync session. If you have more than one open realm, suspend does not affect the sync sessions for other realms. ### When to Pause a Sync Session For most applications, there is no need to manually pause and resume a sync session. However, there are a few circumstances under which you may want to pause or suspend a sync session: * You only want to sync after the user takes a specific action\n* You only want to sync during a certain time of the day\n* You don't want to attempt to sync when there is poor network connectivity\n* You want to explicitly force a sync session to connect In the case of poor network connectivity, continually trying to establish a network connection can drain the user's device battery. The case of explicitly forcing a sync session to connect is most commonly related to being offline for some time. The sync client attempts to connect, and upon failure, goes into exponential backoff. After being offline for a long time, the client may not immediately reconnect. Pausing and resuming the sync session explicitly forces the connection. When you do pause a sync session, keep these things in mind: * If the client may be offline longer than the [client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), the client will be unable to resume syncing and must perform a [client reset.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets)\n* Pausing a sync session pauses it in both directions. Changes that your app makes on the device do not sync with the backend, _and_ changes to the data in the backend or on other devices do not sync to the device. There is no way to pause only uploads or pause only downloads.\n* Do not pause a sync session if you want a client to permanently stop syncing with the backend. To permanently stop syncing, copy the contents of the synced realm into a non-synced realm, and use the non-synced realm in the client. _Do not_ pause sync to stop syncing for indefinite time periods or time ranges in months and years. The functionality is not designed or tested for these use cases. You could encounter a range of issues when using it this way. ← [Sync Data in the Background - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/background-sync/ \"Previous Section\")[Check Upload and Download Progress - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/sync-progress/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Add Device Sync to an App - Swift SDK On this page * [Prerequisites](#prerequisites)\n* [Add Device Sync to a Client Application](#add-device-sync-to-a-client-application)\n* [Connect to the App Services backend](#connect-to-the-app-services-backend)\n* [Authenticate a user](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Use the Realm](#use-the-realm) ## Tip ### See also:  This page contains information about how to add Device Sync to an app. If you are looking for information about what Device Sync is and how it works, see: [App Services: Sync Data.](https://mongodb.com/docs/realm/sdk/swift/application-services/#std-label-ios-realm-sync) ## Prerequisites Before you can access a synced realm from the client, you must[Enable sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) in the Atlas App Services UI. During this process, you must [define queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields)that match fields in your schema. You also [define read and write permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) for app users. In this example, our model includes an `ownerId` field that maps to the`user.id` of the Flexible Sync user. `| class Todo: Object {                              |\n| ------------------------------------------------- |\n| @Persisted(primaryKey: true) var _id: ObjectId    |\n| @Persisted var name: String = \"\"                  |\n| @Persisted var ownerId: String                    |\n| @Persisted var status: String = \"\"                |\n| convenience init(name: String, ownerId: String) { |\n| self.init()                                       |\n| self.name = name                                  |\n| self.ownerId = ownerId                            |\n| }                                                 |\n| }                                                 | ` ## Add Device Sync to a Client Application 1 ### Connect to the App Services backend Pass the App ID for your App, which you can [find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ```swift let app = App(id: FLEX_SYNC_APP_ID) // Replace FLEX_SYNC_APP_ID with your Atlas App ID \n``` 2 ### Authenticate a user\n\n ```swift func login() async throws -> User {     // Authenticate with the instance of the app that points     // to your backend. Here, we're using anonymous login.     let user = try await app.login(credentials: Credentials.anonymous)     print(\"Successfully logged in user: \\(user)\")     return user } \n``` 3 ### Open a Synced Realm Open the realm as a [synced realm](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-ios-login-and-open-realm). You can specify whether a synced realm should download data before it opens. Here, we use a [Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-ios-flexible-sync-open-realm) and specify that the SDK should always download the most recent updates before opening the realm. We [bootstrap the realm with an initial subscription](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-ios-sync-add-initial-subscriptions). We also [specify the object types](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-provide-a-subset-of-classes-to-a-realm) that we want to include in this realm. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift @MainActor func openSyncedRealm(user: User) async {     do {         var config = user.flexibleSyncConfiguration(initialSubscriptions: { subs in             subs.append(                 QuerySubscription<Todo> {                     $0.ownerId == user.id                 })         })         // Pass object types to the Flexible Sync configuration         // as a temporary workaround for not being able to add a         // complete schema for a Flexible Sync app.         config.objectTypes = [Todo.self]         let realm = try await Realm(configuration: config, downloadBeforeOpen: .always)         useRealm(realm, user)     } catch {         print(\"Error opening realm: \\(error.localizedDescription)\")     } } \n``` ## Use the Realm The syntax to [read](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-ios-read-operations), [write](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-write-operations), and[watch for changes](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes) on a synced realm is identical to the syntax for non-synced realms. While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. The following code creates a new `Task` object and writes it to the realm: ```swift @MainActor func useRealm(_ realm: Realm, _ user: User) {     // Add some tasks     let todo = Todo(name: \"Do laundry\", ownerId: user.id)     try! realm.write {         realm.add(todo)     } } \n``` ## Important ### When Using Sync, Avoid Writes on the Main Thread\n\n Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change. ← [Sync Data Between Devices - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/ \"Previous Section\")[Configure & Open a Synced Realm - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/stream-data-to-atlas/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Stream Data to Atlas - Swift SDK On this page * [Overview](#overview)\n* [Sync Data Unidirectionally from a Client Application](#sync-data-unidirectionally-from-a-client-application)\n* [Define an AsymmetricObject](#define-an-asymmetricobject)\n* [Connect and Authenticate with an App Services App](#connect-and-authenticate-with-an-app-services-app)\n* [Open a Realm](#open-a-realm)\n* [Create Asymmetric Objects](#create-asymmetric-objects) ## Overview _New in version 10.29.0_. You can use [Asymmetric Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) to stream data from the client application to a Flexible Sync-enabled Atlas App Services App. You might want to sync data unidirectionally in IoT applications, such as a weather sensor sending data to the cloud. Asymmetric sync is also useful for writing other types of immutable data where you do not require conflict resolution, such as creating invoices from a retail app or logging application events. Asymmetric Sync is optimized to provide performance improvements for heavy client-side _insert-only_ workloads. ## Sync Data Unidirectionally from a Client Application 1 ### Define an AsymmetricObject You can data unidirectionally when that object is an`AsymmetricObject`. Define an AsymmetricObject by deriving from [AsymmetricObject:](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/AsymmetricObject.html) `| class WeatherSensor: AsymmetricObject {        |\n| ---------------------------------------------- |\n| @Persisted(primaryKey: true) var _id: ObjectId |\n| @Persisted var deviceId: String                |\n| @Persisted var temperatureInFahrenheit: Float  |\n| @Persisted var barometricPressureInHg: Float   |\n| @Persisted var windSpeedInMph: Int             |\n| }                                              | ` For more information on how to define an AsymmetricObject, including limitations when linking to other object types, see:[Define an AsymmetricObject.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-swift-define-asymmetric-object) 2 ### Connect and Authenticate with an App Services App To stream data from the client to your backend App, you must[connect to an App Services backend](https://mongodb.com/docs/realm/sdk/swift/app-services/connect-to-app-services-backend/#std-label-ios-init-appclient) and[authenticate a user.](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-authenticate-users) ```swift let app = App(id: INSERT_APP_ID_HERE) do {     let user = try await login()     await openSyncedRealm(user: user) } catch {     print(\"Error logging in: \\(error.localizedDescription)\") } func login() async throws -> User {     let user = try await app.login(credentials: .anonymous)     return user } \n``` Asymmetric Sync is a feature of Flexible Sync, so the App you connect to must use [Flexible Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) 3 ### Open a Realm\n\n ```swift @MainActor func openSyncedRealm(user: User) async {     do {         var asymmetricConfig = user.flexibleSyncConfiguration()         asymmetricConfig.objectTypes = [WeatherSensor.self]         let asymmetricRealm = try await Realm(configuration: asymmetricConfig)         await useRealm(asymmetricRealm, user)     } catch {         print(\"Error opening realm: \\(error.localizedDescription)\")     } } \n``` Unlike bidirectional Sync, Asymmetric Sync does not use a[Flexible Sync subscription.](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-swift-manage-flexible-sync-subscriptions) ## Tip ### Mixed Object and AsymmetricObject Types in Projects Generally, Realm expects that you do not mix `Object` and`AsymmetricObject` types within a project. If your project does contain both types, you must explicitly [pass a subset of classes in your Realm configuration](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-provide-a-subset-of-classes-to-a-realm) each time you open a Realm. You cannot query an AsymmetricObject or write it to a local realm, so AsymmetricObjects are incompatible with bi-directional Flexible Sync, Partition-Based Sync, or local Realm use. Automatic schema discovery means that unless you explicitly pass a subset of classes to a realm in a mixed project, opening a realm can throw an error related to trying to use an incompatible object type. 4 ### Create Asymmetric Objects Once you have an open Realm, you can create an `AsymmetricObject` inside a write transaction using [create(\\_ type:, value:).](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V6create%5F5valueyxm%5FyptSo0aB16AsymmetricObjectCRbzlF) ```swift @MainActor func useRealm(_ asymmetricRealm: Realm, _ user: User) async {     try! asymmetricRealm.write {         asymmetricRealm.create(WeatherSensor.self,                                value: [ \"_id\": ObjectId.generate(),                                         \"deviceId\": \"WX1278UIT\",                                         \"temperatureInFahrenheit\": 66.7,                                         \"barometricPressureInHg\": 29.65,                                         \"windSpeedInMph\": 2                                         ])     } } \n``` You cannot read these objects. Once created, they sync to the App Services backend and the linked Atlas database. ← [Event Library - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/event-library/ \"Previous Section\")[Use Realm in Xcode Playgrounds](https://mongodb.com/docs/realm/sdk/swift/xcode-playgrounds/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/network-connection/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Check the Network Connection - Swift SDK On this page * [Check the Network Connection](#check-the-network-connection) ## Check the Network Connection ## Tip Realm's _offline-first_ design means that you generally don't need to check the current network connection state. That said, the`connectionState` property is available if your app calls for some indication of connection state. ← [Check Upload and Download Progress - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/sync-progress/ \"Previous Section\")[Set the Client Log Level - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/log-level/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Flexible Sync Subscriptions - Swift SDK On this page * [Overview](#overview)\n* [About the Examples on This Page](#about-the-examples-on-this-page)\n* [Subscribe to Queryable Fields](#subscribe-to-queryable-fields)\n* [Add a Subscription](#add-a-subscription)\n* [Wait for Subscription Changes to Sync](#wait-for-subscription-changes-to-sync)\n* [Subscription Set State](#subscription-set-state)\n* [Update Subscriptions with a New Query](#update-subscriptions-with-a-new-query)\n* [Remove Subscriptions](#remove-subscriptions)\n* [Group Updates for Improved Performance](#group-updates-for-improved-performance)\n* [Flexible Sync RQL Limitations](#flexible-sync-rql-limitations)\n* [Unsupported Query Operators in Flexible Sync](#unsupported-query-operators-in-flexible-sync)\n* [List Queries](#list-queries)\n* [Embedded or Linked Objects](#embedded-or-linked-objects) ## Overview _New in version 10.22.0_. Flexible Sync uses subscriptions and permissions to determine which data to sync with your App. To use Flexible Sync in an iOS client: * [Configure Flexible Sync on the backend](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n* [Initialize the app](https://mongodb.com/docs/realm/sdk/swift/quick-start/#std-label-ios-quick-start-init-app)\n* [Authenticate a user](https://mongodb.com/docs/realm/sdk/swift/quick-start/#std-label-ios-quick-start-authenticate) in your client project.\n* [Open the synced Realm with a Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-ios-flexible-sync-open-realm)\n* [Add subscriptions to the client application](#std-label-ios-sync-subscribe-to-queryable-fields) You can add, update, and remove query subscriptions to determine which data syncs to the client device. If your app uses [Asymmetric Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) to unidirectionally sync [AsymmetricObjects](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/AsymmetricObject.html) via an Atlas App Services App, you cannot create subscriptions for those objects. ## Tip ### See also:  This page details how to manage subscriptions for Flexible Sync. For general information about using Device Sync with the Swift SDK, such as how to sync changes in the background or pause a sync session, see: [Sync Changes Between Devices.](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/#std-label-ios-sync-changes-between-devices) For information about setting up permissions for Flexible Sync, see:[Flexible Sync Rules & Permissions.](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) ## Tip Flexible Sync supports [Combine.](https://developer.apple.com/documentation/combine) ## Important Flexible Sync does not support all the operators available in Realm Query Language. See [Flexible Sync RQL Limitations](#std-label-swift-flexible-sync-rql-limitations) for details. ## About the Examples on This Page\n\n `| class Task: Object {                           |\n| ---------------------------------------------- |\n| @Persisted(primaryKey: true) var _id: ObjectId |\n| @Persisted var taskName: String                |\n| @Persisted var assignee: String?               |\n| @Persisted var completed: Bool                 |\n| @Persisted var progressMinutes: Int            |\n| @Persisted var dueDate: Date                   |\n| }                                              |\n| class Team: Object {                           |\n| @Persisted(primaryKey: true) var _id: ObjectId |\n| @Persisted var teamName: String                |\n| @Persisted var tasks: List<Task>               |\n| @Persisted var members: List<String>           |\n| }                                              | ` ## Subscribe to Queryable Fields When you configure Flexible Sync on the backend, you specify which fields your client application can query. In the client application, use the`subscriptions` API to manage a set of subscriptions to specific queries on queryable fields. You can: * Add subscriptions\n* React to subscription state\n* Update subscriptions with new queries\n* Remove individual subscriptions or all subscriptions for an object type Data matching the subscription, where the user has the appropriate permissions, syncs between devices and the backend application. You can specify an optional string name for your subscription. When you create a subscription, Realm looks for data matching a query on a specific object type. You can have multiple subscription sets on different object types. You can also have multiple queries on the same object type. ## Important ### Object Links You must add both an object and its linked object to the subscription set to see a linked object. If your subscription results contain an object with a property that links to an object not contained in the results, the link appears to be nil. There is no way to distinguish whether that property's value is legitimately nil, or whether the object it links to exists but is out of view of the query subscription. ## Example You can create a subscription with an explicit name. Then, you can search for that subscription by name to update or remove it. ```swift QuerySubscription<Task>(name: \"long-running-completed\") {     $0.completed == true && $0.progressMinutes > 120 } \n``` If you do not specify a `name` for a subscription, you can search for the subscription by the query string. ```swift QuerySubscription<Team> {    $0.teamName == \"Developer Education\" } \n``` ## Note ### Duplicate subscriptions Subscription names must be unique. Trying to append a subscription with the same name as an existing subscription throws an error. If you do not explicitly name a subscription, and instead subscribe to the same unnamed query more than once, Realm does not persist duplicate queries to the subscription set. If you subscribe to the same query more than once under different names, Realm persists both subscriptions to the subscription set. ### Add a Subscription Add a subscription in a subscriptions update block. You append each new subscription to the client's Realm subscriptions. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift let realm = try await getRealmWithSingleSubscription() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func getRealmWithSingleSubscription() async throws -> Realm {\n\n     let subscriptions = realm.subscriptions     try await subscriptions.update {        subscriptions.append(           QuerySubscription<Team> {              $0.teamName == \"Developer Education\"           })     }     return realm } \n``` You can add multiple subscriptions within a subscription update block, including subscriptions of different object types. ```swift let realm = try await getRealmWithMultipleSubscriptions() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func getRealmWithMultipleSubscriptions() async throws -> Realm {     let realm = try await Realm(configuration: flexSyncConfig)     let subscriptions = realm.subscriptions     try await subscriptions.update {         subscriptions.append(             QuerySubscription<Task>(name: \"completed-tasks\") {                  $0.completed == true         })         subscriptions.append(             QuerySubscription<Team> {               $0.teamName == \"Developer Education\"         })     }     return realm } \n``` #### Bootstrap the Realm with Initial Subscriptions _New in version 10.28.0_. You must have at least one subscription before you can read from or write to the realm. You can bootstrap a realm with an initial subscription set when you open it with the [flexibleSyncConfiguration()](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE25flexibleSyncConfigurationAC0B0V0F0VyF). Pass the `initialSubscriptions` parameter with the subscription queries you want to use to bootstrap the realm: ```swift var flexSyncConfig = user.flexibleSyncConfiguration(initialSubscriptions: { subs in     subs.append(         QuerySubscription<Team> {                $0.teamName == \"Developer Education\"             }) }) \n``` If your app needs to rerun this initial subscription every time the app starts, you can pass an additional parameter - `rerunOnOpen`. This is a bool that denotes whether the initial subscription should re-run every time the app starts. You might need to do this to re-run dynamic time ranges or other queries that require a re-computation of static variables for the subscription. In this example, we don't want users to be overwhelmed by irrelevant tasks, so we'll load only tasks due within the previous 7 days and the next 7 days. Tasks that were due more than a week ago are no longer relevant, and tasks that are due further out than the next week are also not relevant. With`rerunOnOpen` here, the query dynamically recalculates the relevant objects to sync based on the desired date range every time the app starts. ```swift // Set the date a week ago and the date a week from now, as those are the dates we'll use // in the Flexible Sync query. `rerunOnOpen` lets the app recalculate this query every // time the app opens. let secondsInAWeek: TimeInterval = 604800 let dateLastWeek = (Date.now - secondsInAWeek) let dateNextWeek = (Date.now + secondsInAWeek) var flexSyncConfig = user.flexibleSyncConfiguration(initialSubscriptions: { subs in     subs.append(         QuerySubscription<Task> {             $0.dueDate > dateLastWeek && $0.dueDate < dateNextWeek         }) }, rerunOnOpen: true) \n``` #### Subscribe to All Objects of a Specific Type\n\n For example, if you don't want to see a specific team, but instead want to subscribe to all the `Team` objects, you could do this: ```swift let realm = try await subscribeToObjectsOfAType() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func subscribeToObjectsOfAType() async throws -> Realm {     let realm = try await Realm(configuration: flexSyncConfig)     let subscriptions = realm.subscriptions     try await subscriptions.update {         subscriptions.append(QuerySubscription<Team>(name: \"all_teams\"))     }     XCTAssertEqual(subscriptions.count, 1) // :remove     return realm } \n``` #### Check for Existing Subscriptions Before Adding a Subscription If your application flow appends the same named subscription to the subscription set every time you run the application, this is disallowed. In this case, add a check for an existing subscription before appending it: ```swift let realm = try await checkAndAddSubscription() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func checkAndAddSubscription() async throws -> Realm {     let realm = try await Realm(configuration: flexSyncConfig)     let subscriptions = realm.subscriptions     let foundSubscription = subscriptions.first(named: \"user_team\")     try await subscriptions.update {         if foundSubscription != nil {             foundSubscription!.updateQuery(toType: Team.self, where: {                  $0.teamName == \"Developer Education\"             })         } else {             subscriptions.append(                 QuerySubscription<Team>(name: \"user_team\") {                   $0.teamName == \"Developer Education\"                })         }     }     return realm } \n``` ### Wait for Subscription Changes to Sync Updating the subscription set locally is only one component of changing a subscription. After the local subscription change, the realm synchronizes with the server to resolve any updates to the data due to the subscription change. This could mean adding or removing data from the synced realm. #### Pre Async/Await If your application does not use Swift's async/await feature, you can react to subscription changes syncing with the server using the `onComplete`block. This block is called after subscriptions are synchronized with the server. If you want to react to subscription state changes by redrawing a UI, for example, or taking another action based on changes to the data set, take those actions in `onComplete`. This is also where you can handle optional errors that occur during synchronization. ```swift let subscriptions = realm.subscriptions subscriptions.update({    subscriptions.append(       QuerySubscription<Task> {          $0.assignee == \"John Doe\"       }) }, onComplete: { error in // error is optional     if error == nil {        // Flexible Sync has updated data to match the subscription     } else {        // Handle the error     }  }) \n``` #### Async/Await If your application uses async/await, you don't need the `onComplete`block. The update executes asynchronously and throws an error if the update cannot complete successfully. ```swift @MainActor func changeSubscription() async throws {    let subscriptions = realm.subscriptions    try await subcriptions.update {       subscriptions.remove {          QuerySubscription<Task> {             $0.assignee == \"Joe Doe\"          }       }    } } \n```\n\n If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ### Subscription Set State Use the [SubscriptionSet.state](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncSubscriptionSet.html#/s:10RealmSwift19SyncSubscriptionSetV5stateAA0cD5StateOvp)property to read the current state of the subscription set. The `superseded` state is a [SyncSubscriptionState](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/SyncSubscriptionState.html#/s:10RealmSwift21SyncSubscriptionStateO8completeyA2CmF)that can occur when another thread updates a subscription on a different instance of the subscription set. If the state becomes `superseded`, you must obtain a new instance of the subscription set before you can update it. ## Note ### Subscription State \"Complete\" The subscription set state \"complete\" does not mean \"sync is done\" or \"all documents have been synced\". \"Complete\" means the following two things have happened: * The subscription has become the active subscription set that is currently being synchronized with the server.\n* The documents that matched the subscription _at the time the subscription was sent to the server_ are now on the local device. Note that this does not necessarily include all documents that currently match the subscription. The Realm SDK does not provide a way to check whether all documents that match a subscription have synced to the device. ### Update Subscriptions with a New Query You can update a subscription's query using `updateQuery`. In this example, we search for a subscription matching our query and then update it with a new query. ```swift let realm = try await getRealmWithUpdatedSubscriptions() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func getRealmWithUpdatedSubscriptions() async throws -> Realm {     let realm = try await Realm(configuration: flexSyncConfig)     let subscriptions = realm.subscriptions     try await subscriptions.update {         if let foundSubscription = subscriptions.first(ofType: Team.self, where: {             $0.teamName == \"Developer Education\"         }) {             foundSubscription.updateQuery(toType: Team.self, where: {                 $0.teamName == \"Documentation\"             })         }     }     return realm } \n``` You can also [search for a subscription by name](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncSubscriptionSet.html#/s:10RealmSwift19SyncSubscriptionSetV5first5namedAA0cD0VSgSS%5FtF). In this example, we search for a subscription query by name and then update it with a new query. ```swift let realm = try await getRealmWithUpdatedSubscriptionName() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func getRealmWithUpdatedSubscriptionName() async throws -> Realm {     let realm = try await Realm(configuration: flexSyncConfig)     let subscriptions = realm.subscriptions     let foundSubscription = subscriptions.first(named: \"user-team\")     try await subscriptions.update {         foundSubscription?.updateQuery(toType: Team.self, where: {              $0.teamName == \"Documentation\"         })     }     return realm } \n``` ### Remove Subscriptions To remove subscriptions, you can: * Remove a single subscription query\n* Remove all subscriptions to a specific object type\n* Remove all subscriptions When you remove a subscription query, Realm asynchronously removes the synced data that matched the query from the client device.\n\n You can remove a specific subscription query in a subscription update block using `remove`. Specify the query by name or use the query as a string to find the appropriate subscription query to remove. ```swift let realm = try await getRealmAfterRemovingSubscription() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func getRealmAfterRemovingSubscription() async throws -> Realm {     let realm = try await Realm(configuration: flexSyncConfig)     let subscriptions = realm.subscriptions     // Look for a specific subscription, and then remove it     let foundSubscription = subscriptions.first(named: \"docs-team\")     try await subscriptions.update {         subscriptions.remove(foundSubscription!)     }     // Or remove a subscription that you know exists without querying for it     try await subscriptions.update {         subscriptions.remove(named: \"existing-subscription\")     }     return realm } \n``` #### Remove All Subscriptions to an Object Type If you want to remove all subscriptions to a specific object type, use the`removeAll` method with `ofType` in a subscription update block. ```swift let realm = try await getRealmAfterRemovingAllSubscriptionsToAnObjectType() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func getRealmAfterRemovingAllSubscriptionsToAnObjectType() async throws -> Realm {     let realm = try await Realm(configuration: flexSyncConfig)     let subscriptions = realm.subscriptions     try await subscriptions.update {         subscriptions.removeAll(ofType: Team.self)     }     return realm } \n``` #### Remove All Subscriptions To remove all subscriptions from the subscription set, use the `removeAll`method in a subscription update block. ## Important If you remove all subscriptions and do not add a new one, you'll get an error. A realm opened with a flexible sync configuration needs at least one subscription to sync with the server. ```swift let realm = try await getRealmAfterRemovingAllSubscriptions() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func getRealmAfterRemovingAllSubscriptions() async throws -> Realm {     let realm = try await Realm(configuration: flexSyncConfig)     let subscriptions = realm.subscriptions     try await subscriptions.update {         subscriptions.removeAll()     }     return realm } \n``` ### Group Updates for Improved Performance Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change. ## Flexible Sync RQL Limitations Flexible Sync has some limitations when using RQL operators. When you write the [query subscription](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-flexible-sync-query-subscription)that determines which data to sync, the server does not support these query operators. However, you can still use the full range of RQL features to query the synced data set in the client application. ### Unsupported Query Operators in Flexible Sync | Operator Type       | Unsupported Operators          |\n| ------------------- | ------------------------------ |\n| Aggregate Operators | @avg, @count, @max, @min, @sum |\n| Query Suffixes      | DISTINCT, SORT, LIMIT          | Case insensitive queries (`[c]`) cannot use indexes effectively. As a result, case insensitive queries are not recommended, since they could lead to performance problems. Flexible Sync only supports `@count` for array fields. ### List Queries Flexible Sync supports querying lists using the `IN` operator.\n\n ```javascript // Query a constant list for a queryable field value \"priority IN { 1, 2, 3 }\" \n``` If a queryable field has an array value, you can query to see if it contains a constant value: ```javascript // Query an array-valued queryable field for a constant value \"'comedy' IN genres\" \n``` ## Warning You **cannot** compare two lists with each other in a Flexible Sync query. Note that this is valid Realm Query Language syntax outside of Flexible Sync queries. ```javascript // Invalid Flexible Sync query. Do not do this! \"{'comedy', 'horror', 'suspense'} IN genres\" // Another invalid Flexible Sync query. Do not do this! \"ANY {'comedy', 'horror', 'suspense'} != ANY genres\" \n``` ### Embedded or Linked Objects Flexible Sync does not support querying on properties in Embedded Objects or links. For example, `obj1.field == \"foo\"`. ← [Configure & Open a Synced Realm - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/ \"Previous Section\")[Write Data to a Synced Realm - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/write-to-synced-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/sync-progress/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Check Upload and Download Progress - Swift SDK On this page * [Check Upload & Download Progress for a Sync Session](#check-upload---download-progress-for-a-sync-session) ## Check Upload & Download Progress for a Sync Session ## Note Flexible Sync progress notifications are not yet fully supported. When using Flexible Sync, downloads only report notifications after changes are integrated. Partition-Based Sync provides ongoing notifications as changes progress downloading. Uploads report ongoing progress notifications for both Sync Modes. ← [Suspend or Resume a Sync Session - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/sync-session/ \"Previous Section\")[Check the Network Connection - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/network-connection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Configure & Open a Synced Realm - Swift SDK On this page * [Key Concept: Synced Realms](#key-concept--synced-realms)\n* [Synced Realms vs. Non-Synced Realms](#synced-realms-vs.-non-synced-realms)\n* [Convert Between Synced and Non-Synced Realms](#convert-between-synced-and-non-synced-realms)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Open a Synced Realm for Partition-Based Sync](#open-a-synced-realm-for-partition-based-sync)\n* [Open a Synced Realm for Flexible Sync](#open-a-synced-realm-for-flexible-sync)\n* [Open a Synced Realm as a Different Sync User](#open-a-synced-realm-as-a-different-sync-user)\n* [Open Non-Synced Realm as a Synced Realm](#open-non-synced-realm-as-a-synced-realm)\n* [Open a Synced Realm as a Non-Synced Realm](#open-a-synced-realm-as-a-non-synced-realm)\n* [Download Changes Before Open](#download-changes-before-open)\n* [Open a Synced Realm Offline](#open-a-synced-realm-offline) ## Key Concept: Synced Realms You can configure a realm to automatically synchronize data between many devices that each have their own local copy of the data. Synced realms use a different configuration than local-only realms and require an Atlas App Services backend to handle the synchronization process. Applications can always create, modify, and delete synced realm objects locally, even when offline. Whenever a network connection is available, the Realm SDK opens a connection to an application server and syncs changes to and from other clients. The [Atlas Device Sync protocol](https://www.mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-sync-protocol) and server-side operational transforms guarantee that all fully synced instances of a realm see exactly the same data, even if some changes occurred offline and/or were received out of order. ## Tip ### Learn How to Configure and Use Sync For more information on Device Sync, including directions on how to set up sync in an App Services app, see [Sync Data.](https://mongodb.com/docs/realm/sdk/swift/application-services/#std-label-ios-realm-sync) ### Synced Realms vs. Non-Synced Realms Synced realms differ from non-synced local Realm Database in a few ways: * Synced realms attempt to sync changes with your backend App Services App, whereas non-synced realms do not.\n* Synced realms can be accessed by authenticated users, while non-synced realms have no concept of users or authentication.\n* With synced realms, you can [specify the download behavior](#std-label-ios-specify-download-behavior) to download updates before opening a realm. However, requiring changes to download before opening the realm requires the user to be online. Non-synced realms can always be used offline. You can copy data from a non-synced Realm Database to a synced realm, and vice versa, but you cannot sync a non-synced Realm Database. For more information about how to configure and open a non-synced realm, refer to: [Configure & Open a Realm - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-configure-and-open-a-realm) ### Convert Between Synced and Non-Synced Realms Realm does not have a direct mechanism to add sync to a non-synced realm, or to permanently stop Sync for a synced realm. However, the Swift SDK does provide methods that enable you to copy a realm file for use with a different configuration. With these methods, you can easily duplicate a realm's data, which you can then open with a sync or non-sync configuration. This lets you indirectly add Sync to a non-synced realm, or permanently stop a realm from syncing. See:\n\n ## Open a Synced Realm ## Tip ### See also:  The examples on this page describe how to work with synced realms in Swift SDK versions newer than 10.15.0\\. For older SDK versions, or if you're building apps for iOS targets prior to 15.0, with Swift versions older than 5.5, see: [Legacy Sync Open Methods.](https://mongodb.com/docs/realm/sdk/swift/sync/sync-realm-open-legacy/#std-label-ios-realm-open-legacy) The typical flow for opening a synced realm involves: 1. [Authenticating the user.](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-authenticate-users)\n2. Creating a sync configuration.\n3. Opening the user's synced realm with the configuration. At authentication, we cache user credentials in a `sync_metadata.realm`file on device. When you open a synced realm after authenticating, you can bypass the login flow and go directly to opening the synced realm, using the same sync configuration you already created. With cached credentials, you can: * Open a synced realm immediately with the data that is on the device. You can use this method offline or online.\n* Open a synced realm after downloading changes from your App. This requires the user to have an active internet connection. ### Open a Synced Realm for Partition-Based Sync Initialize a synced realm with a [sync configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE13configuration14partitionValueAC0B0V13ConfigurationVx%5FtAC4BSONRzlF). This enables you to specify a partition value whose data should sync to the realm. ### Open a Synced Realm for Flexible Sync _New in version 10.22.0_. When you use Flexible Sync, use the `flexibleSyncConfiguration()`to open a synced realm. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes.\n\n  `` ## Important ### Flexible Sync Requires a Subscription If your app uses bidirectional, standard Device Sync, you can't use a Flexible Sync realm until you add at least one subscription. To learn how to add subscriptions, see: [Add a Subscription.](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-ios-sync-add-subscription) This does not apply to [Asymmetric Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync). You cannot create a subscription for an `AsymmetricObject`. ### Open a Synced Realm as a Different Sync User _New in version 10.23.0_. If you want to open a synced realm as a different Sync user, you can use the [writeCopy(configuration: )](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V9writeCopy13configurationyAC13ConfigurationV%5FtKF)method to make a copy of the synced realm for use with the new user's sync configuration. The example below creates a copy of the synced realm, with all of its existing data, that you can use with a different sync configuration. After you copy the realm for the new Sync user's configuration, you can open the copy as a synced realm for that user. ## Note ### Partition-Based Sync Only This method only supports Partition-Based Sync. If your app uses Flexible Sync, you must manually iterate through the objects in one realm and copy them into the other realm. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift try await convertSyncedRealmForAnotherUser() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func convertSyncedRealmForAnotherUser() async throws {     let app = App(id: YOUR_APP_SERVICES_APP_ID)         // Log in the user whose realm you want to use with another sync user     let frodoBaggins = try await app.login(credentials: Credentials.anonymous)     var frodoConfig = frodoBaggins.configuration(partitionValue: \"Some Partition Value\")     frodoConfig.objectTypes = [QsTask.self]         // Open the synced realm, and confirm it contains the data we want     // the other user to be able to access.     let frodoRealm = try await Realm(configuration: frodoConfig, downloadBeforeOpen: .always)         let frodoRealmTasks = frodoRealm.objects(QsTask.self)     let frodoSyncedTasks = frodoRealmTasks.where { $0.owner == \"Frodo\" }     XCTAssertEqual(frodoSyncedTasks.count, 3)     print(\"Successfully opened frodo's realm and it contains this many tasks: \\(frodoSyncedTasks.count)\")         // Log in as the user who will work with frodo's synced realm     let samwiseGamgee = try await app.login(credentials: Credentials.anonymous)     var samConfig = samwiseGamgee.configuration(partitionValue: \"Some Partition Value\")     samConfig.objectTypes = [QsTask.self]         // Specify an output directory for the copied realm     // We're using FileManager here for tested code examples.     guard let outputDir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return }         // Append a file name to complete the path     let copiedRealmFilePath = outputDir.appendingPathComponent(\"copied.realm\")         // Update the config file path to the path where you want to save the copied realm\n\n             // Make a copy of frodo's realm that uses sam's config     try frodoRealm.writeCopy(configuration: samConfig)         // Open sam's realm, and see that it contains the same data as frodo's realm     let samRealm = try await Realm(configuration: samConfig)     let samRealmTasks = samRealm.objects(QsTask.self)     var samSyncedTasks = samRealmTasks.where { $0.owner == \"Frodo\" }     print(\"Successfully opened sam's realm and it contains this many tasks: \\(samSyncedTasks.count)\")         XCTAssertEqual(frodoSyncedTasks.count, samSyncedTasks.count)         // Add a task to sam's realm     let task = QsTask(value: [\"name\": \"Keep an eye on that Gollum\", \"owner\": \"Sam\"])         try! samRealm.write {         samRealm.add(task)     }         // See that the new task reflects in sam's realm, but not frodo's     samSyncedTasks = samRealmTasks.where { $0.owner == \"Sam\" }     XCTAssertEqual(samSyncedTasks.count, 1)         let samTasksInFrodoRealm = frodoRealmTasks.where { $0.owner == \"Sam\" }     XCTAssertEqual(samTasksInFrodoRealm.count, 0) } \n``` ### Open Non-Synced Realm as a Synced Realm _New in version 10.23.0_. If you want a non-synced realm to start syncing with other devices and your App Services backend, you can use the [writeCopy(configuration: )](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V9writeCopy13configurationyAC13ConfigurationV%5FtKF)method to make a copy of the non-synced realm for use with a sync configuration. The example below creates a copy of a non-synced realm file, with all of its existing data, that you can use with a sync configuration. After you copy the realm for use with Sync, you can open the copy as a synced realm. Any changes you make to the synced realm will reflect in the synced realm file, and they will also propogate to other devices and the App Services backend. ## Note ### Partition-Based Sync Only This method only supports Partition-Based Sync. If your app uses Flexible Sync, you must manually iterate through the objects in one realm and copy them into the other realm. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift try await convertLocalRealmToSyncedRealm() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func convertLocalRealmToSyncedRealm() async throws {     let app = App(id: YOUR_APP_SERVICES_APP_ID)         // Log in the user whose realm you want to open as a synced realm     let syncUser = try await app.login(credentials: Credentials.anonymous)         // Create a configuration to open the sync user's realm     var syncConfig = syncUser.configuration(partitionValue: \"Your Partition Value\")     syncConfig.objectTypes = [QsTask.self]     // Prepare the configuration for the user whose local realm you     // want to convert to a synced realm     var localConfig = Realm.Configuration()     localConfig.objectTypes = [QsTask.self]         // For this example, add some data to the local realm     // before copying it. No need to do this if you're\n\n     let localRealm = addExampleData(config: localConfig)         // Create a copy of the local realm that uses the     // sync configuration. All the data that is in the     // local realm is available in the synced realm.     try! localRealm.writeCopy(configuration: syncConfig)         // Open the synced realm we just created from the local realm     let syncedRealm = try await Realm(configuration: syncConfig)         // Access the Task objects in the synced realm to see     // that we have all the data we expect     let syncedTasks = syncedRealm.objects(QsTask.self)     var frodoSyncedTasks = syncedTasks.where { $0.owner == \"Frodo\" }     XCTAssertEqual(frodoSyncedTasks.count, 3)     print(\"Synced realm opens and contains this many tasks: \\(frodoSyncedTasks.count)\")         // Add a new task to the synced realm, and see it in the task count     let task4 = QsTask(value: [\"name\": \"Send gift basket to Tom Bombadil\", \"owner\": \"Frodo\"])         try! syncedRealm.write {         syncedRealm.add(task4)     }         frodoSyncedTasks = syncedTasks.where { $0.owner == \"Frodo\" }     XCTAssertEqual(frodoSyncedTasks.count, 4)     print(\"After adding a task, the synced realm contains this many tasks: \\(frodoSyncedTasks.count)\")         // Open the local realm, and confirm that it still only contains 3 tasks     let openedLocalRealm = try await Realm(configuration: localConfig)     let localTasks = openedLocalRealm.objects(QsTask.self)     let frodoLocalTasks = localTasks.where { $0.owner == \"Frodo\" }     XCTAssertEqual(frodoLocalTasks.count, 3)     print(\"Local realm opens and contains this many tasks: \\(frodoLocalTasks.count)\")         XCTAssertNotEqual(frodoLocalTasks.count, frodoSyncedTasks.count)             /// Populate the local realm with some data that we'll use in the synced realm.     func addExampleData(config: Realm.Configuration) -> Realm {         // Prepare the configuration for the user whose local realm you         // want to convert to a synced realm         let localConfig = config         // Open the local realm, and populate it with some data before returning it         let localRealm = try! Realm(configuration: localConfig)                 let task1 = QsTask(value: [\"name\": \"Keep it secret\", \"owner\": \"Frodo\"])         let task2 = QsTask(value: [\"name\": \"Keep it safe\", \"owner\": \"Frodo\"])         let task3 = QsTask(value: [\"name\": \"Journey to Bree\", \"owner\": \"Frodo\"])                 try! localRealm.write {             localRealm.add([task1, task2, task3])         }         return localRealm     } } \n``` ### Open a Synced Realm as a Non-Synced Realm _New in version 10.23.0_. ## Tip\n\n If you want to permanently stop a realm from syncing to your App Services backend, you can use the [writeCopy(configuration: )](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V9writeCopy13configurationyAC13ConfigurationV%5FtKF)method to make a copy of a synced realm for use with a non-sync configuration. The example below creates a copy of the realm file, with all of its existing data, at a file URL you specify. This process removes the `realm_id` in the local realm. You must [increment the schema version as if you had deleted a property.](https://mongodb.com/docs/realm/sdk/swift/model-data/change-an-object-model/#std-label-ios-delete-a-property) After you copy the realm for use without Sync, you can open the copy as a non-synced realm. Any changes you make to the non-synced realm reflect only in the local realm file. No changes propogate to other devices or the App Services backend. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift try await convertSyncedRealmToLocalRealm() // Opening a realm and accessing it must be done from the same thread. // Marking this function as `@MainActor` avoids threading-related issues. @MainActor func convertSyncedRealmToLocalRealm() async throws {     let app = App(id: YOUR_APP_SERVICES_APP_ID)         // Log in the user whose realm you want to open as a local realm     let syncUser = try await app.login(credentials: Credentials.anonymous)         // Create a configuration to open the seed user's realm     var syncConfig = syncUser.configuration(partitionValue: \"Some Partition Value\")     syncConfig.objectTypes = [QsTask.self]         // Open the realm with the Sync user's config, downloading     // any remote changes before opening.     let syncedRealm = try await Realm(configuration: syncConfig, downloadBeforeOpen: .always)     print(\"Successfully opened realm: \\(syncedRealm)\")         // Verify the data we expect in the realm     // The synced realm we are copying contains 3 tasks whose owner is \"Frodo\"     let syncedTasks = syncedRealm.objects(QsTask.self)     var frodoSyncedTasks = syncedTasks.where { $0.owner == \"Frodo\" }     XCTAssertEqual(frodoSyncedTasks.count, 3)     print(\"Synced realm opens and contains this many tasks: \\(frodoSyncedTasks.count)\")         // Construct an output file path for the local Realm     guard let outputDir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return }         // Append a file name to complete the path     let localRealmFilePath = outputDir.appendingPathComponent(\"local.realm\")         // Construct a local realm configuration     var localConfig = Realm.Configuration()     localConfig.objectTypes = [QsTask.self]     localConfig.fileURL = localRealmFilePath         // `realm_id` will be removed in the local realm, so we need to bump     // the schema version.     localConfig.schemaVersion = 1         // Check to see if there is already a realm at the local realm file path. If there     // is already a realm there, delete it.     if Realm.fileExists(for: localConfig) {         try Realm.deleteFiles(for: localConfig)         print(\"Successfully deleted existing realm at path: \\(localRealmFilePath)\")     } else {\n\n     }         // Make a copy of the synced realm that uses a local configuration     try syncedRealm.writeCopy(configuration: localConfig)         // Try opening the realm as a local realm     let localRealm = try await Realm(configuration: localConfig)         // Verify that the copied realm contains the data we expect     let localTasks = localRealm.objects(QsTask.self)     var frodoLocalTasks = localTasks.where { $0.owner == \"Frodo\" }     XCTAssertEqual(frodoLocalTasks.count, 3)     print(\"Local realm opens and contains this many tasks: \\(frodoLocalTasks.count)\")         let task = QsTask(value: [\"name\": \"Send gift basket to Tom Bombadil\", \"owner\": \"Frodo\"])         try! localRealm.write {         localRealm.add(task)     }         frodoLocalTasks = localTasks.where { $0.owner == \"Frodo\" }     XCTAssertEqual(frodoLocalTasks.count, 4)     print(\"After adding a task, the local realm contains this many tasks: \\(frodoLocalTasks.count)\")         frodoSyncedTasks = syncedTasks.where { $0.owner == \"Frodo\" }     XCTAssertEqual(frodoSyncedTasks.count, 3)     print(\"After writing to local realm, synced realm contains this many tasks: \\(frodoSyncedTasks.count)\")         XCTAssertNotEqual(frodoLocalTasks.count, frodoSyncedTasks.count) } \n``` ## Download Changes Before Open _New in version 10.15.0_. When you open a synced realm with the Swift SDK, you can pass the`downloadBeforeOpen` parameter to specify whether to download the changeset from your App before opening the realm. This parameter accepts a case from the `OpenBehavior` enum: * `never`: Immediately open the realm on the device. Download changes in the background when the user has internet, but don't block opening the realm.\n* `always`: Check for changes every time you open the realm. Requires the user to have an active internet connection.\n* `once`: Download data before opening a realm for the first time, but open it without downloading changes on subsequent opens. This lets you populate a realm with initial data, but enables offline-first functionality on subsequent opens. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift func testSpecifyDownloadBehavior() async throws {     let app = App(id: YOUR_REALM_APP_ID)     let user = try await app.login(credentials: Credentials.anonymous)     let partitionValue = \"some partition value\"     var configuration = user.configuration(partitionValue: partitionValue)     let realm = try await Realm(configuration: configuration, downloadBeforeOpen: .always)     print(\"Successfully opened realm after downloading: \\(realm)\") } \n``` ## Open a Synced Realm Offline When your Realm application authenticates a user, it caches the user's credentials. You can check for existing user credentials to bypass the login flow and access the cached user. Use this to open a realm offline. ## Note ### Initial login requires a network connection When a user signs up for your app, or logs in for the first time with an existing account on a client, the client must have a network connection. Checking for cached user credentials lets you open a realm offline, but only if the user has previously logged in while online. You can only open a synced realm offline if you do not require your client app to `always` [download changes before opening the realm.](#std-label-ios-specify-download-behavior) ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift\n\n // The first time you login, the user must have a network connection. func getUser() async throws -> User {     // Check for an existing user.     // If the user is offline but credentials are     // cached, this returns the existing user.     if let user = app.currentUser {         return user     } else {         // If the device has no cached user         // credentials, log them in.         let app = App(id: YOUR_APP_SERVICES_APP_ID)         let loggedInUser = try await app.login(credentials: Credentials.anonymous)         return loggedInUser     } } let user = try await getUser() var configuration = user.configuration(partitionValue: \"Some Partition Value\") // Open a Realm with this configuration. // If you do not require the app to download updates // before opening the realm, the realm just opens, even if // offline. let realm = try await Realm(configuration: configuration) print(\"Successfully opened realm: \\(realm)\") \n``` ← [Add Device Sync to an App - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/ \"Previous Section\")[Manage Flexible Sync Subscriptions - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/event-library/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Event Library - Swift SDK On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Enable Event Recording](#enable-event-recording)\n* [Default Event Configuration](#default-event-configuration)\n* [Pass Parameters to Event Configuration](#pass-parameters-to-event-configuration)\n* [Update Event Metadata](#update-event-metadata)\n* [Record Events](#record-events)\n* [Interact with the Event Realm](#interact-with-the-event-realm)\n* [Record Read or Write Events](#record-read-or-write-events)\n* [Record Custom Events](#record-custom-events)\n* [Event Object Serialization](#event-object-serialization)\n* [JSON Object Serialization](#json-object-serialization)\n* [Customize Event Serialization](#customize-event-serialization)\n* [Event Realm File Size](#event-realm-file-size)\n* [Event Library Reference](#event-library-reference)\n* [Events](#events)\n* [Event Payload](#event-payload) ## Overview The Event Library enables you to track a user's activity while using a Sync-enabled mobile application. The Event Library can record read and write transactions. Developers can also configure custom events to record button presses, the data displayed in the UI, or other important details. When you use the Event Library, you can specify the events you want to record. This means opening two realms: * The user realm, where the user does the reading and writing in the client application\n* The event realm, where the Event Library records scoped and custom events The data from both realms syncs to your App Services App. The client user never interacts directly with the event realm or its data; and the event realm Sync user can even be different from the user realm. Because the Event Library generates a large amount of data: * The client device must have enough capacity to store the data\n* Expect Device Sync usage for the event realm to be higher than the reading and writing in the user realm\n* The App's backing Atlas cluster must have enough storage capacity to handle the data generated by the Event Library ## Before You Begin The Event Library stores data in an `AuditEvent` collection in your linked Atlas data source. Enable [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)in your App Services App to let Atlas create the collection and infer the schema from the uploaded events. ## Enable Event Recording To enable event recording, set the [Event.Configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV05eventC0AA05EventC0VSgvp)property on the [Realm.Configuration.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html) You can initialize the `EventConfiguration` in either of two ways: * Use the default-initialized configuration when you don't need to specify details\n* Pass additional parameters to customize the event configuration ### Default Event Configuration If you don't need to specify particular parameters, you can use the default-initialized `EventConfiguration`: `| var config = user.configuration(partitionValue: \"Some partition value\") |\n| ----------------------------------------------------------------------- |\n| config.eventConfiguration = EventConfiguration()                        | ` ### Pass Parameters to Event Configuration You can pass optional parameters to customize the `EventConfiguration`: * `metadata`: String dictionary of metadata fields to append to each event\n* `syncUser`: The user to use for syncing event realm(s). If nil, defaults to the user from the `Realm.Configuration`.\n* `partitionPrefix`: String prefix to append to the event partition value\n* `logger`: Custom logger to use for events. If nil, defaults to the logger from the user realm.\n* `errorHandler`: Custom error handler to use when opening the event realm. If nil, defaults to the error handler from the user realm. ```swift\n\n var config = user.configuration(partitionValue: \"Some partition value\") config.eventConfiguration = EventConfiguration(metadata: [\"username\": \"Jason Bourne\"], syncUser: eventSyncUser, partitionPrefix: \"event-\") \n``` ### Update Event Metadata You can update metadata even after you have started recording events. Use the `updateMetadata()` function to replace the metadata supplied in the event configuration with new values. If you update metadata while an event scope is active, the Event Library does not use the new metadata until the next event scope begins. ```swift var config = user.configuration(partitionValue: \"Some partition value\") config.eventConfiguration = EventConfiguration(metadata: [\"username\": \"Jason Bourne\"], syncUser: user, partitionPrefix: \"event-\") let realm = try! Realm(configuration: config) let events = realm.events! let updateUsernameScope = events.beginScope(activity: \"Update username\") // Call some function that updates the user's username updateUsername() updateUsernameScope.commit() // Update the metadata you supplied with the initial EventConfiguration events.updateMetadata([\"username\": \"John Michael Kane\"]) \n``` ## Record Events ### Interact with the Event Realm After you define your event configuration, you can invoke the event recording functionality with the new [events](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Events.html) property on a [realm](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html). This returns an `Event`instance tied to that realm. ```swift let realm = try! Realm(configuration: config) let events = realm.events! \n``` ### Record Read or Write Events _Changed in version 10.36.0_: endScope() deprecated for commit() and cancel(), new Scope object The Event Library records read and write events within the context of a scope. The scope is the period during which the Event Library watches for and records realm activities. You can set different scopes to record different types of events. For example, you might have scopes for specific user flows such as \"login\", different scopes for different screens, or different scopes for specific compliance-related activities. Use [beginScope(activity: \"some activity\")](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Events.html#/s:10RealmSwift6EventsV10beginScope8activityySS%5FtF)to begin recording a new event with the given activity name. This returns a [Scope](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Events/Scope.html) object, which you can use to later commit or cancel the scope. Beginning a scope records activities that occur within that scope as read or write events. * Read events: run queries and instantiate objects. When the scope ends, the event realm records these activities as read events.\n* Write events: modify objects. When the scope ends, the event realm records the initial state of the object, as well as the new values of any properties that change durign the scope of the event. Using `beginScope` to record an event opens the event realm if it is not already open. The SDK opens event realms on the background thread and reports errors to the error callback. ## Note ### Overlapping Event Scopes If more than one event scope is active simultaneously, generated events are recorded by all active scopes. When you're done recording events for a scope, use `commit()`to save events that occurred within the scope. When you end the recording, the Event Library saves the event to disk locally. Then, if the device has a network connection, the SDK asynchronously sends the data to the server. ```swift // Read event let readEventScope = events.beginScope(activity: \"read object\") let person = realm.objects(Person.self).first! print(\"Found this person: \\(person.name)\") readEventScope.commit() let mutateEventScope = events.beginScope(activity: \"mutate object\") // Write event try! realm.write {     // Change name from \"Anthony\" to \"Tony\"     person.name = \"Tony\" } mutateEventScope.commit() \n``` Alternately, you can `cancel()` an event scope. This stops recording events, and does not persist the events to disk or to the server. ```swift\n\n let person1 = realm.objects(Person.self).first! print(\"Found this person: \\(person1.name)\") eventScope.cancel() \n``` You can check whether a given scope is currently in progress using the`isActive` bool. This returns `true` if you have begun a scope that you have not yet committed or canceled. ```swift let readPersonScope = events.beginScope(activity: \"read object\") let person2 = realm.objects(Person.self).first! print(\"Found this person: \\(person2.name)\") if readPersonScope.isActive {     print(\"The readPersonScope is active\") } else {     print(\"The readPersonScope is no longer active\") } readPersonScope.cancel() \n``` You can pass an optional completion block to `commit()`when you finish recording. The SDK calls this block when the event data has been successfully persisted - not when the event realm upload has completed. ```swift let mutateScope = events.beginScope(activity: \"mutate object with completion\") // Write event try! realm.write {     // Add a userId     person.userId = \"tony.stark@starkindustries.com\" } mutateScope.commit(completion: { error in     if let error = error {         print(\"Error recording write event: \\(error.localizedDescription)\")         return     }     print(\"Successfully recorded a write event\") }) \n``` ### Record Custom Events The Event Library lets you record button clicks or other events that do not involve database reads and writes. Use [recordEvent](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Events.html#/s:10RealmSwift6EventsV11recordEvent8activity9eventType4data10completionySS%5FSSSgAIys5Error%5FpSgcSgtF)to record a custom event. This function takes these parameters: * `activity`: the activity name. This is an arbitrary string, such as \"user registration.\"\n* `eventType`: the type of event. This is an arbitrary string, such as \"pressed Submit button.\"\n* `data`: an optional data payload for the event.\n* `completion`: an optional completion handler. The Event Library calls this completion block once the event has been saved to the event realm, or if an error occurs. A nil error indicates success. A custom event doesn't have a scope like read and write events. Instead, recording a custom event is more analogous to firing a trigger. ```swift events.recordEvent(activity: \"event\", eventType: \"custom event\") \n``` ## Event Object Serialization ### JSON Object Serialization The Event Library converts each event object to a JSON object. Most[Realm Database types](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-supported-property-types) have an analogous JSON representation. For example, a Realm Database String property becomes a JSON String. This is how the Event Library represents the types that do not have a direct JSON analog:\n\n Non-embedded object links are encoded as the primary key of the target. In read events, if the link is followed, this expands to the full object. If the link is not followed, this remains a primary key. ### Customize Event Serialization You can customize JSON serialization for event objects. To customize the event payload, use the [CustomEventRepresentable](https://www.mongodb.com/docs/realm-sdks/swift/latest/Protocols/CustomEventRepresentable.html) protocol. When an object conforms to `CustomEventRepresentable`, the Event Library serializes objects by: * Constructing an accessor object\n* Calling `customEventRepresentation` on that accessor object\n* Serializing the result instead of the original object To conform to `CustomEventRepresentable`, your object must implement a[customEventRepresentation](https://www.mongodb.com/docs/realm-sdks/swift/latest/Protocols/CustomEventRepresentable.html#/c:@M@RealmSwift@objc%28pl%29RLMCustomEventRepresentable%28im%29customEventRepresentation)function that defines your customized serialization. ```swift // To customize event serialization, your object must // conform to the `CustomEventRepresentable` protocol. class Person: Object, CustomEventRepresentable {     @Persisted(primaryKey: true) var _id: ObjectId     @Persisted var name: String     @Persisted var employeeId: Int     @Persisted var userId: String?     convenience init(name: String, employeeId: Int) {         self.init()         self.name = name         self.employeeId = employeeId     }     // To conform to `CustomEventRepresentable`, your object     // must implement a `customEventRepresentation` func that     // defines your customized event serialization     func customEventRepresentation() -> String {         if employeeId == 0 {             return \"invalid json\"         }         return \"{\\\"int\\\": \\(employeeId)}\"     } } \n``` ## Event Realm File Size The event realm can grow quite large if the device is offline for an extended time. To compensate for this, the Event Library automatically splits event data into multiple partitions as needed. When a partition reaches its maximum size, the Event Library closes the event realm and automatically begins writing to a new partition. The Event Library checks whether the user has any unsynced partitions. If they do, the Event Library opens one, uploads the data, and then closes the file and deletes it. This repeats until the user has no unsynced partitions. ## Event Library Reference ### Events The `AuditEvent` collection where events are stored must have a schema defined on the server for the App receiving events. The schema must contain the following fields:\n\n ### Event Payload Each event contains a payload in the `data` property that captures the current state of the objects being read or written to. Payloads for custom events can be whatever the developer desires, including nil. ## Important Because the payload captures the current state of the objects being read or written to, this produces a very large amount of data. However, this must be done on the client rather than the server, as the exact data that the user views may never exist server-side. In practice, this means that the device must have the capacity to store a large amount of data if it goes offline. Additionally, Device Sync usage for the event realm may be much higher than for the reading and writing the user does in the user realm. ## Example In our [Record Events](#std-label-swift-event-library-record-events) examples above, these are the `data` payloads for the read and write events: Read Event Payload ``` {   \"type\":\"Person\",   \"value\": [{     \"_id\":\"62b38b3c10846041166f5deb\",     \"_partition\":\"\",     \"employeeId\":2,     \"name\":\"Anthony\",     \"userId\":null   }] } \n``` Write Event Payload ``` {   \"Person\": {     \"modifications\": [{       \"newValue\": {         \"name\":\"Tony\"       },       \"oldValue\":{         \"_id\":\"62b38b3c10846041166f5deb\",         \"_partition\":\"\",         \"employeeId\":2,         \"name\":\"Anthony\",         \"userId\":null       }     }]   } } \n``` ← [Set the Client Log Level - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/log-level/ \"Previous Section\")[Stream Data to Atlas - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/stream-data-to-atlas/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/users/user-metadata/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # User Metadata - Swift SDK On this page * [Read a User's Metadata](#read-a-user-s-metadata)\n* [Configure User Metadata](#configure-user-metadata)\n* [Update User Metadata](#update-user-metadata) ## Read a User's Metadata You can read the [user metadata](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) of a currently logged-in user through that user's `User` object. You cannot edit user metadata through a `User` object. To read the data, access the `profile` property on the `User` object of a logged-in user: `| // First, log in a user. Then, access user metadata           |\n| ------------------------------------------------------------- |\n| print(\"The logged-in user's email is: \\(user.profile.email)\") | ` User metadata options vary depending on which provider you're using and[which metadata fields you enable.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-configure-user-metadata-on-the-backend) ## Warning ### User Metadata May Be Stale Atlas App Services fetches the most recent version of user metadata when a user logs in. If the user changes their email address or profile photo with a login provider, for example, those changes do not update in user metadata until the user logs in again. Because we cache credentials and enable you to bypass the login flow, user metadata may become stale unless you force the user to log in again. ## Configure User Metadata You can only read user metadata from the client app that you have configured on the App Services application. You can configure the [user metadata](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) you request from an authentication provider. You do this directly on the authentication provider's configuration. For more details on which metadata fields you can use, see the provider details: * OAuth 2.0 ([Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) & [Google)](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication)\n* [Custom JWT](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) You can change which metadata fields you have configured by [editing the provider's configuration.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-configure-user-metadata-on-the-backend) ## Update User Metadata User metadata that you access through the authentication provider is read-only data. You cannot update or edit user metadata that comes from this source. If you would like to give a user the option the update their metadata from within your client app, use [custom user data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data), instead. ← [Custom User Data - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/ \"Previous Section\")[Manage Email/Password Users - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/manage-email-password-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/sync/handle-sync-errors/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Handle Sync Errors - Swift SDK On this page * [Handle Sync Errors](#handle-sync-errors)\n* [Client Reset](#client-reset)\n* [Automatic vs. Manual Client Reset](#automatic-vs.-manual-client-reset)\n* [Specify a Client Reset Mode](#specify-a-client-reset-mode)\n* [Handle Schema Changes](#handle-schema-changes)\n* [Recover Unsynced Changes](#recover-unsynced-changes)\n* [Discard Unsynced Changes](#discard-unsynced-changes)\n* [Manual Client Reset Mode](#manual-client-reset-mode)\n* [Manual Client Reset Fallback](#manual-client-reset-fallback) ## Handle Sync Errors While developing an application that uses Device Sync, you should set an error handler. This error handler will detect and respond to any failed sync-related API calls. ## Tip For a list of common Device Sync errors and how to handle them, refer to[Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services Device Sync documentation. ## Tip ### See also:  For information about setting a client log level, or customizing the logger, see [Set the Client Log Level - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/sync/log-level/#std-label-swift-set-client-log-level) ## Client Reset When using [Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), a **client reset** is an error recovery task that your client app must perform when a given synced realm on the server can no longer sync with the client realm. In this case, the client must reset its realm to a state that matches the server in order to restore the ability to sync. When this occurs, the unsyncable realm on the client may contain data that has not yet synced to the server. Realm SDKs can attempt to recover or discard that data during the client reset process. For more information about what might cause a client reset to occur, go to[Client Resets in the App Services documentation.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) ### Automatic vs. Manual Client Reset The Realm SDKs provide [client reset modes](#std-label-ios-specify-client-reset-mode)that automatically handle most client reset errors. Automatic client reset modes restore your local realm file to a syncable state without closing the realm or missing notifications. All the client reset modes except `.manual` perform an automatic client reset. The differences between the modes are based on how they handle changes on the device that have not yet synced to the backend. Choose `.recoverUnsyncedChanges` to handle most client reset scenarios automatically. This attempts to recover unsynced changes when a client reset occurs. In some cases, you may want or need to [set a manual client reset handler](#std-label-ios-manual-client-reset-handler). You may want to do this if your app requires specific client reset logic that can't be handled automatically. ### Specify a Client Reset Mode _Changed in version 10.32.0_: Client recovery added, discardLocal name changed The Swift SDK provides the option to specify a client reset mode in your [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncConfiguration.html). This is the [.clientResetMode](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncConfiguration.html#/s:10RealmSwift17SyncConfigurationV15clientResetModeAA06ClientfG0Ovp)property.\n\n  `` This property takes [an enum representing the different client reset modes:](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/ClientResetMode.html) * `.recoverUnsyncedChanges`\n* `.recoverOrDiscardUnsyncedChanges`\n* `.discardUnsyncedChanges`\n* `.manual` If you do not specify `.clientResetMode` in your configuration, the client reset mode defaults to `.recoverUnsyncedChanges`. You can specify a `before` and `after` block to execute during the automatic client reset process. You might use this to perform recovery logic that is important to your application. ```swift // A block called after a client reset error is detected, but before the // client recovery process is executed. // This block could be used for any custom logic, reporting, debugging etc. // This is one example, but your usage may vary. let beforeClientResetBlock: (Realm) -> Void = { before in     var recoveryConfig = Realm.Configuration()     recoveryConfig.fileURL = myRecoveryPath     do {        try before.writeCopy(configuration: recoveryConfig)         // The copied realm could be used later for recovery, debugging, reporting, etc.      } catch {             // handle error      } } // A block called after the client recovery process has executed. // This block could be used for custom recovery, reporting, debugging etc. // This is one example, but your usage may vary. let afterClientResetBlock: (Realm, Realm) -> Void = { before, after in     //     let res = after.objects(myClass.self)     //     if (res.filter(\"primaryKey == %@\", object.primaryKey).first != nil) {     //         // ...custom recovery logic...     //     } else {     //         // ...custom recovery logic...     //     }     // } } do {     let app = App(id: YOUR_APP_SERVICES_APP_ID)     let user = try await app.login(credentials: Credentials.anonymous)     var configuration = user.flexibleSyncConfiguration(clientResetMode:                                                         .recoverOrDiscardUnsyncedChanges(                                                             beforeReset: beforeClientResetBlock,                                                             afterReset: afterClientResetBlock)) } catch {     print(\"Error logging in user: \\(error.localizedDescription)\") } \n``` If your app has specific client recovery needs, you can specify the `.manual` client reset mode and set a [manual client reset handler](#std-label-ios-manual-client-reset-handler). You might do this if you have specific custom logic your app must perform during a client reset, or if the [client recovery rules](#std-label-ios-client-recovery-rules) do not work for your app. ## Note If your app uses Swift SDK version 10.24.2 or earlier, `.clientResetMode`is not an available property on the `SyncConfiguration`. ### Handle Schema Changes\n\n * The client can [recover unsynced changes](#std-label-ios-recover-unsynced-changes)when there are no schema changes, or non-breaking schema changes.\n* When you make breaking schema changes, the automatic client reset modes fall back to a manual error handler. You can set a [manual client reset error handler](#std-label-ios-client-reset-manual-fallback) for this case. Automatic client recovery cannot occur when your app makes breaking schema changes. For information on breaking vs. non-breaking schema changes, see[Breaking vs. Non-Breaking Change Quick Reference.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-breaking-change-quick-reference) ### Recover Unsynced Changes _New in version 10.32.0_. During a client reset, client applications can attempt to recover data in the local realm that has not yet synced to the backend. To recover unsynced changes, [Client Recovery](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-recover-unsynced-changes) must be [enabled in your App Services App](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-enable-or-disable-recovery-mode), as it is by default. If you want your app to recover changes that have not yet synced, set the [.clientResetMode](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncConfiguration.html#/s:10RealmSwift17SyncConfigurationV15clientResetModeAA06ClientfG0Ovp)in the [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncConfiguration.html) to one of: * `.recoverUnsyncedChanges`: When you choose this mode, the client attempts to recover unsynced changes. Choose this mode when you do not want to fall through to discard unsynced changes.\n* `.recoverOrDiscardUnsyncedChanges`: The client first attempts to recover changes that have not yet synced. If the client cannot recover unsynced data, it falls through to [discard unsynced changes](#std-label-ios-discard-local-changes) but continues to automatically perform the client reset. Choose this mode when you want to enable automatic client recovery to fall back to discard unsynced changes. ```swift // Specify the clientResetMode when you create the SyncConfiguration. // If you do not specify, this defaults to `.recoverUnsyncedChanges` mode. var configuration = user.flexibleSyncConfiguration(clientResetMode: .recoverUnsyncedChanges()) \n``` There may be times when the client reset operation cannot complete in recover unsynced changes mode, like when there are breaking schema changes or[Client Recovery](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-recover-unsynced-changes) is disabled in the Device Sync configuration. To handle this case, your app can implement a[manual client reset fallback.](#std-label-ios-client-reset-manual-fallback) #### Client Recovery Rules When Client Recovery is enabled, these rules determine how objects are integrated, including how conflicts are resolved when both the backend and the client make changes to the same object: * Objects created locally that were not synced before client reset are synced.\n* If an object is deleted on the server, but is modified on the recovering client, the delete takes precedence and the client discards the update.\n* If an object is deleted on the recovering client, but not the server, then the client applies the server's delete instruction.\n* In the case of conflicting updates to the same field, the client update is applied. ### Discard Unsynced Changes _Changed in version 10.32.0_: .discardLocal changed to .discardUnsyncedChanges\n\n Do not use discard unsynced changes mode if your application cannot lose local data that has not yet synced to the backend. To perform an automatic client reset that discards unsynced changes, set the [.clientResetMode](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncConfiguration.html#/s:10RealmSwift17SyncConfigurationV15clientResetModeAA06ClientfG0Ovp)in the [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncConfiguration.html) to`.discardUnsyncedChanges`. ```swift do {     let app = App(id: APP_ID)     let user = try await app.login(credentials: Credentials.anonymous)     var config = user.flexibleSyncConfiguration(clientResetMode: .discardUnsyncedChanges()) } catch {     print(\"Error logging in user: \\(error.localizedDescription)\") } \n``` ## Note ### Discard with Recovery If you'd like to attempt to recover unsynced changes, but but discard any changes that cannot be recovered, refer to the`.recoverOrDiscardUnsyncedChanges` documentation in [Recover Unsynced Changes.](#std-label-ios-recover-unsynced-changes) There may be times when the client reset operation cannot complete in discard unsynced changes mode, like when there are breaking schema changes. To handle this case, your app can implement a [manual client reset fallback.](#std-label-ios-client-reset-manual-fallback) ### Manual Client Reset Mode When you specify `.manual` for `.clientResetMode`, you should implement a manual client reset handler. In `.manual` mode, you define your own client reset handler. The handler can take an `ErrorReportingBlock`. We recommend using the[automatic client recovery modes](#std-label-ios-automatic-vs-manual-client-reset)when possible, and only choosing `.manual` mode if the automatic recovery logic is not suitable for your app. ```swift do {     let app = App(id: APP_ID)     let user = try await app.login(credentials: Credentials.anonymous)     var config = user.flexibleSyncConfiguration(clientResetMode: .manual()) } catch {     print(\"Error logging in user: \\(error.localizedDescription)\") } \n``` ## Tip If you are using an older version of the SDK, and want to see an example of how you might manually recover changes in a manual client reset, check out this [example on GitHub.](https://github.com/mongodb/realm-practice/blob/main/swift/RealmPractice/Classes/ViewController.swift#L286) ### Manual Client Reset Fallback If the client reset operation cannot complete automatically, like when there are breaking schema changes, the client reset process falls through to a manual error handler. This may occur in any of these automatic client reset modes: * `.recoverUnsyncedChanges`\n* `.recoverOrDiscardUnsyncedChanges`\n* `.discardUnsyncedChanges` ← [Write Data to a Synced Realm - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/write-to-synced-realm/ \"Previous Section\")[Sync Data in the Background - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/background-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/users/manage-email-password-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Email/Password Users - Swift SDK On this page * [Register a New User Account](#register-a-new-user-account)\n* [Confirm a New User's Email Address](#confirm-a-new-user-s-email-address)\n* [Retry User Confirmation Methods](#retry-user-confirmation-methods)\n* [Resend a User Confirmation Email](#resend-a-user-confirmation-email)\n* [Retry a User Confirmation Function](#retry-a-user-confirmation-function)\n* [Reset a User's Password](#reset-a-user-s-password)\n* [Send a Password Reset Email](#send-a-password-reset-email)\n* [Run a Password Reset Function](#run-a-password-reset-function)\n* [Email/Password User Methods with Completion Handlers](#email-password-user-methods-with-completion-handlers) When you have enabled the [email/password provider](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) in your Atlas App Services app, you can register a new account, confirm an email address, and reset a user's password from client code. _Changed in version 10.16.0_: Email/password user APIs add async/await support. Code examples on this page updated to async/await syntax. For an example of the older syntax, see: [Email/Password User Examples with Completion Handlers.](https://mongodb.com/docs/realm/sdk/swift/users/manage-email-password-users/#std-label-ios-manage-users-completion-handler-example) ## Register a New User Account ## Confirm a New User's Email Address ## Retry User Confirmation Methods The SDK provides methods to resend user confirmation emails or retry custom confirmation methods. ### Resend a User Confirmation Email Resend a [confirmation email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-confirmation-email). Email/password URLs expire after 30 minutes, so users who do not visit within that period will need new emails to confirm their accounts.\n\n ` ### Retry a User Confirmation Function _New in version 10.9.0_. Retry a [custom user confirmation function.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-confirmation-function) ```swift let app = App(id: YOUR_APP_SERVICES_APP_ID) let client = app.emailPasswordAuth let email = \"skroob@example.com\" // If Realm is set to run a custom confirmation function, // we can trigger that function to run again here. do {     try await client.retryCustomConfirmation(email)     // The custom confirmation function has been     // triggered to run again for the user.     print(\"Custom confirmation retriggered\") } catch {     print(\"Failed to retry custom confirmation: \\(error.localizedDescription)\") } \n``` ## Reset a User's Password To reset a user password in Device Sync, you can either: * Send a password reset email\n* Run a password reset function Select your preferred password reset method by going to: 1. Your Atlas App Services App\n2. Authentication\n3. Authentication Providers\n4. Email/Password \\- and press the EDIT button ### Send a Password Reset Email After you configure your App to [send a password reset email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-password-reset-email), you can call `sendResetPasswordEmail`with the user's email. App Services sends an email to the user that contains a unique URL. The user must visit this URL within 30 minutes to confirm the reset. ### Run a Password Reset Function When you configure your app to [run a password reset function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function), you'll define the function that should run when you call [callResetPasswordFunction()](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/EmailPasswordAuth.html#/s:So20RLMEmailPasswordAuthC10RealmSwiftE09callResetB8Function5email8password4args7Combine6FutureCyyts5Error%5FpGSS%5FSSSayAC7AnyBSONOGtF)from the SDK. This function can take a username, a password, and any number of additional arguments. You can use these arguments to specify details like security question answers or other challenges that the user should pass to successfully complete a password reset. You might prefer to use a custom password reset function when you want to define your own password reset flows. For example, you might send a custom password reset email from a specific domain, or through a service other than email. ## Tip ### See also:  For more information on how to define a custom password reset function in the Device Sync backend, including how to structure it and examples of implementing custom flows, see: [Run a Password Reset Function.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function) ```swift let app = App(id: YOUR_APP_SERVICES_APP_ID) let client = app.emailPasswordAuth let email = \"forgot.my.password@example.com\" let newPassword = \"mynewpassword12345\" // The password reset function takes any number of // arguments. You might ask the user to provide answers to // security questions, for example, to verify the user // should be able to complete the password reset. let args: [AnyBSON] = [] // This SDK call maps to the custom password reset // function that you define in the backend do {     try await client.callResetPasswordFunction(email: email, password: newPassword, args: args)     print(\"Password reset successful!\") } catch {     print(\"Password reset failed: \\(error.localizedDescription)\") } \n``` ## Email/Password User Methods with Completion Handlers\n\n ```swift let app = App(id: YOUR_APP_SERVICES_APP_ID) let client = app.emailPasswordAuth let email = \"skroob@example.com\" let password = \"password12345\" client.registerUser(email: email, password: password) { (error) in     guard error == nil else {         print(\"Failed to register: \\(error!.localizedDescription)\")         return     }     // Registering just registers. You can now log in.     print(\"Successfully registered user.\") } \n``` ← [User Metadata - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/user-metadata/ \"Previous Section\")[Multi-User Applications - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/multi-user-applications/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/users/create-and-delete-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create and Delete Users - Swift SDK On this page * [Create a User](#create-a-user)\n* [Delete a User](#delete-a-user)\n* [Delete Users with Async/Await](#delete-users-with-async-await)\n* [Delete Users with Completion Handlers](#delete-users-with-completion-handlers) ## Create a User For most [authentication methods](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), Atlas App Services automatically creates a [user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) the first time a user authenticates. The only exception is email/password authentication. When you use email/password authentication, you must [register](https://mongodb.com/docs/realm/sdk/swift/users/manage-email-password-users/#std-label-ios-register-a-new-user-account) and [confirm](https://mongodb.com/docs/realm/sdk/swift/users/manage-email-password-users/#std-label-ios-confirm-a-new-users-email-address) a user before the user can authenticate to an App Services App. ## Tip ### Apple Account Deletion Requirements Apple [requires that applications listed through its App Store](https://developer.apple.com/app-store/review/guidelines/#5.1.1) must give any user who creates an account the option to delete the account. Whether you use an authentication method where you must manually register a user, such as email/password authentication, or one that that automatically creates a user, such as Sign-In with Apple, you must implement [user account deletion](https://www.mongodb.com/docs/atlas/app-services/users/manage/#std-label-delete-user) by June 30, 2022. ## Delete a User _New in version 10.23.0_. You can call the [delete](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE6delete7Combine6FutureCyyts5Error%5FpGyF)method on a user object to delete the user object from your App. This deletes the object from the server in addition to clearing local data. ## Important Deleting a user only deletes the user object, which may contain associated[metadata](https://mongodb.com/docs/realm/sdk/swift/users/user-metadata/#std-label-ios-user-metadata). This does not delete [custom user data](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/#std-label-ios-custom-user-data) or user-entered data from your application. Apple [requires that you disclose data retention and deletion policies](https://developer.apple.com/app-store/review/guidelines/#5.1.1) to your application customers and give them a way to request user data deletion. If you collect additional user data, you must implement your own methods or processes to delete that data. ## Delete Users with Async/Await If your application uses [Apple's async/await syntax:](https://developer.apple.com/documentation/swift/swift%5Fstandard%5Flibrary/concurrency/updating%5Fan%5Fapp%5Fto%5Fuse%5Fswift%5Fconcurrency)\n\n  `` Starting with Realm Swift SDK Versions 10.15.0 and 10.16.0, many of the Realm APIs support the Swift async/await syntax. Projects must meet these requirements: | Swift SDK Version  | Swift Version Requirement | Supported OS |\n| ------------------ | ------------------------- | ------------ |\n| 10.25.0            | Swift 5.6                 | iOS 13.x     |\n| 10.15.0 or 10.16.0 | Swift 5.5                 | iOS 15.x     | If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ## Delete Users with Completion Handlers If your application does not use async/await: ```swift // Logging in using anonymous authentication creates a user object app.login(credentials: Credentials.anonymous) { [self] (result) in     switch result {     case .failure(let error):         fatalError(\"Login failed: \\(error.localizedDescription)\")     case .success(let user):         // Assign the user object to a variable to demonstrate user deletion         syncUser = user     } } // Later, after the user is loggedd in we have a user, // and the total users in the app = 1 XCTAssertNotNil(syncUser) XCTAssertEqual(app.allUsers.count, 1) // Call the `delete` method to delete the user syncUser!.delete { (error) in     XCTAssertNil(error) } // When you delete the user, the SyncSession is destroyed and // there is no current user. XCTAssertNil(app.currentUser) // Now that we've deleted the user, the app has no users. XCTAssertEqual(app.allUsers.count, 0) \n``` ← [Manage Users - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/work-with-users/ \"Previous Section\")[Authenticate Users - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/users/custom-user-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Custom User Data - Swift SDK On this page * [Read a User's Custom Data](#read-a-user-s-custom-data)\n* [Create a User's Custom Data Document](#create-a-user-s-custom-data-document)\n* [Update a User's Custom Data](#update-a-user-s-custom-data) ## Read a User's Custom Data You can read the [custom user data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) of a currently logged-in user through that user's `User` object. You cannot edit custom user data through a `User` object. To edit custom user data, see [Update Custom User Data](#std-label-ios-update-a-users-custom-data). To read the data, access the`customData` property on the `User` object of a logged-in user: ## Warning ### Custom Data May Be Stale Atlas App Services does not dynamically update the value of the client-side user custom data document immediately when underlying data changes. Instead, App Services fetches the most recent version of custom user data whenever a user refreshes their [access token](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions), which is used by most SDK operations that contact the App Services backend. If the token is not refreshed before its default 30 minute expiration time, the Swift SDK refreshes the token on the next call to the backend. Custom user data could be stale for up to 30 minutes plus the time until the next SDK call to the backend occurs. ## Note If you require the most recent version of custom user data, use the[refreshCustomDataWithCompletion](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMUser.html#/c:objc%28cs%29RLMUser%28im%29refreshCustomDataWithCompletion:)method to request the latest version of a user's custom data. ## Create a User's Custom Data Document To create custom user data for a user, create a MongoDB document in the custom user data collection. The user ID field of the document should contain the the user's user ID. ## Tip In the App Services UI, check the App Users page under theCustom User Data tab to find and configure custom user data settings, including: * The custom user data cluster, database, and collection\n* The user ID field used to map custom user data documents to users The following example uses [MongoDB Remote Access](https://mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/#std-label-ios-mongodb-remote-access) to insert a document containing the user ID of the currently logged in user and a `favoriteColor` value into the custom user data collection: You can add any number of arbitrary fields and values to the custom user data document when you create it. The user ID field is the only requirement for the document to become available on the `User` object as custom user data. ## Update a User's Custom Data You can update custom user data using [MongoDB Data Access](https://mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/#std-label-ios-mongodb-remote-access), [Atlas Device Sync](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/#std-label-ios-sync-changes-between-devices), [MongoDB Compass](https://www.mongodb.com/docs/compass/current/), or the [MongoDB Atlas Data Explorer.](https://www.mongodb.com/docs/atlas/data-explorer/) To update a user's custom user data with MongoDB Data Access, edit the MongoDB document whose user ID field contains the user ID of the user. The following example uses [MongoDB Data Access](https://mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/#std-label-ios-mongodb-remote-access) to update the `favoriteColor` field of the the document containing the user ID of the currently logged in user in the custom user data collection: ## Tip\n\n ← [Authenticate Users - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/ \"Previous Section\")[User Metadata - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/user-metadata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/users/manage-user-api-keys/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage User API Keys - Swift SDK On this page * [Create a User API Key](#create-a-user-api-key)\n* [Look up a User API Key](#look-up-a-user-api-key)\n* [Enable or Disable a User API Key](#enable-or-disable-a-user-api-key)\n* [Delete a User API Key](#delete-a-user-api-key) You can manage a user API key with a user's **API Key auth instance**, which you can access through the user's [apiKeysAuth](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMUser.html#/c:objc%28cs%29RLMUser%28py%29apiKeysAuth) property. ## Create a User API Key You can create a user API key with the API key auth instance's[createAPIKey](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMAPIKeyAuth.html#/c:objc%28cs%29RLMAPIKeyAuth%28im%29createAPIKeyWithName:completion:)method. ## Warning ### Store the API Key Value The SDK only returns the value of the user API key when you create it. Make sure to store the `key` value securely so that you can use it to log in. If you lose or do not store the `key` value there is no way to recover it. You will need to create a new user API key. ## Look up a User API Key You can look up a user API key with the API key auth instance's[fetchAPIKey](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMAPIKeyAuth.html#/c:objc%28cs%29RLMAPIKeyAuth%28im%29fetchAPIKey:completion:)method. ## Enable or Disable a User API Key You can enable or disable a user API key with the API key auth instance's [enableAPIKey](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMAPIKeyAuth.html#/c:objc%28cs%29RLMAPIKeyAuth%28im%29enableAPIKey:completion:)and [disableAPIKey](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMAPIKeyAuth.html#/c:objc%28cs%29RLMAPIKeyAuth%28im%29disableAPIKey:completion:)methods. ## Delete a User API Key You can delete a user API key with the API key auth instance's[deleteAPIKey](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMAPIKeyAuth.html#/c:objc%28cs%29RLMAPIKeyAuth%28im%29deleteAPIKey:completion:)method. ← [Link User Identities - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/link-user-identities/ \"Previous Section\")[Sync Data Between Devices - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/users/multi-user-applications/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Multi-User Applications - Swift SDK On this page * [User Account States](#user-account-states)\n* [Add a New User to the Device](#add-a-new-user-to-the-device)\n* [List All Users on the Device](#list-all-users-on-the-device)\n* [Change the Active User](#change-the-active-user)\n* [Remove a User from the Device](#remove-a-user-from-the-device) The Realm Swift SDK allows multiple [users](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) to be logged in to an app simultaneously on a given device. Client applications run in the context of a single active user even if multiple users are logged in simultaneously. You can quickly switch between authenticated users without requiring them to log in again. ## Important **Any logged in user may become the active user without re-authenticating.**Depending on your app, this may be a security vulnerability. For example, a user on a shared device may switch to a coworker's logged in account without providing their credentials or requiring their explicit permission. If your application requires stricter authentication, avoid switching between users and prefer to explicitly log the active user out before authenticating another user. ## User Account States When a user first logs in through Atlas App Services on a given device or browser, the Realm SDK saves the user's information and keeps track of the user's state on the device. The user's data remains on the device, even if they log out, unless you actively [remove the user.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE6remove7Combine6FutureCyyts5Error%5FpGyF) The following states describe an on-device user at any given time: * **Authenticated:** any user that has logged in on the device and has not logged out or had its session revoked.  \n   * **Active**: a single authenticated user that is currently using the app on a given device. The SDK associates this user with outgoing requests and App Services evaluates data access permissions and runs functions in this user's context. See [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) for more information.  \n   * **Inactive**: all authenticated users that are not the current active user. You can [switch the active user](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/#std-label-dotnet-switch-user) to a currently inactive user at any time.\n* **Logged Out:** any user that authenticated on the device but has since logged out or had their session revoked. The following diagram shows how users within a client app transition between states when certain events occur: ![A diagram the outlines the different states a user can be in: logged out, logged in and active, & logged in and inactive.](https://mongodb.com/docs/realm/images/multi-user.png) ### Add a New User to the Device The Realm SDK automatically adds users to a device when they log in for the first time on that device. When a user logs in, they immediately become the application's [active user.](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) ### List All Users on the Device You can access a list of all [user accounts](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) that are stored on the device. This list includes all users that have logged in to the app on a given device regardless of whether they are currently authenticated. ### Change the Active User You can change an app's [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) to another logged in user at any time with the following code: ### Remove a User from the Device You can remove all information about a user from the device and automatically log the user out.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/swift/model-data/define-a-realm-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Define a Realm Object Schema - Swift SDK * [Object Models](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/)\n* [Relationships](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/)\n* [Supported Types](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/) ← [Model Data - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/ \"Previous Section\")[Object Models - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/users/authenticate-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate Users - Swift SDK On this page * [Log In](#log-in)\n* [Anonymous User](#anonymous-user)\n* [Email/Password User](#email-password-user)\n* [API Key User](#api-key-user)\n* [Custom Function User](#custom-function-user)\n* [Custom JWT User](#custom-jwt-user)\n* [Facebook User](#facebook-user)\n* [Google User](#google-user)\n* [Apple User](#apple-user)\n* [Async/Await Login](#async-await-login)\n* [Offline Login](#offline-login)\n* [Get a User Access Token](#get-a-user-access-token)\n* [Log Out](#log-out) ## Log In ### Anonymous User If you have enabled [Anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)in the App Services UI, users can immediately log into your app without providing any identifying information. The following code shows how to do this: `| let anonymousCredentials = Credentials.anonymous                           |\n| -------------------------------------------------------------------------- |\n| app.login(credentials: anonymousCredentials) { (result) in                 |\n| switch result {                                                            |\n| case .failure(let error):                                                  |\n| print(\"Login failed: \\(error.localizedDescription)\")                       |\n| case .success(let user):                                                   |\n| print(\"Successfully logged in as user \\(user)\")                            |\n| // Now logged in, do something with user                                   |\n| // Remember to dispatch to main if you are doing anything on the UI thread |\n| }                                                                          |\n| }                                                                          | ` ### Email/Password User If you have enabled [Email/Password authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication), you can log in using the following code: ```swift let email = \"skroob@example.com\" let password = \"12345\" app.login(credentials: Credentials.emailPassword(email: email, password: password)) { (result) in     switch result {     case .failure(let error):\n\n     case .success(let user):         print(\"Successfully logged in as user \\(user)\")         // Now logged in, do something with user         // Remember to dispatch to main if you are doing anything on the UI thread     } } \n``` ### API Key User If you have enabled [API Key authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication), you can log in using the following code: ```swift let credentials = Credentials.userAPIKey(\"<api-key>\") app.login(credentials: credentials) { (result) in     switch result {     case .failure(let error):         print(\"Login failed: \\(error.localizedDescription)\")     case .success(let user):         print(\"Successfully logged in as user \\(user)\")         // Now logged in, do something with user         // Remember to dispatch to main if you are doing anything on the UI thread     } } \n``` ### Custom Function User If you have enabled the [Custom Function authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication), you can log in using the following code: ```swift let params: Document = [\"username\": \"bob\"] app.login(credentials: Credentials.function(payload: params)) { (result) in     switch result {     case .failure(let error):         print(\"Login failed: \\(error.localizedDescription)\")     case .success(let user):         print(\"Successfully logged in as user \\(user)\")         // Now logged in, do something with user         // Remember to dispatch to main if you are doing anything on the UI thread     } } \n``` ### Custom JWT User If you have enabled the [Custom JWT authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication), you can log in using the following code: ```swift let credentials = Credentials.jwt(token: \"<jwt>\") app.login(credentials: credentials) { (result) in     switch result {     case .failure(let error):         print(\"Login failed: \\(error.localizedDescription)\")     case .success(let user):         print(\"Successfully logged in as user \\(user)\")         // Now logged in, do something with user         // Remember to dispatch to main if you are doing anything on the UI thread     } } \n``` ### Facebook User The [Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) authentication provider allows you to authenticate users through a Facebook app using their existing Facebook account. ## Important ### Enable the Facebook Auth Provider To log a user in with their existing Facebook account, you must configure and enable the [Facebook authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication)for your application. ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. Follow the official [Facebook Login for iOS Quickstart](https://developers.facebook.com/docs/facebook-login/ios?sdk=cocoapods) to set up the authentication flow for your application. In the login completion handler, create an App Services Facebook credential with the logged in user's[access token string](https://developers.facebook.com/docs/facebook-login/access-tokens) and log the user into your App Services app.\n\n // This example demonstrates login logic for FBSDK version 13.x. If you're using // a different version of FBSDK, you'll need to adapt this example for your version. let loginManager = LoginManager() loginManager.logIn(permissions: [ .email ]) { loginResult in     switch loginResult {     case .success(let grantedPermissions, let declinedPermissions, let accessToken):         let credentials = Credentials.facebook(accessToken: accessToken!.tokenString)         app.login(credentials: credentials) { result in             DispatchQueue.main.async {                 switch result {                 case .failure(let error):                     print(\"Failed to log in to MongoDB Realm: \\(error)\")                 case .success(let user):                     print(\"Successfully logged in to MongoDB Realm using Facebook OAuth.\")                     // Now logged in, do something with user                     // Remember to dispatch to main if you are doing anything on the UI thread                 }             }         }     case .failed(let error):         print(\"Facebook login failed: \\(error)\")     case .cancelled:         print(\"The user cancelled the login flow.\")     } } \n``` ### Google User ## Important To log a user in with their existing Google account, you must configure and enable the [Google authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication) for your application. Follow the official [Google Sign-In for iOS Integration Guide](https://developers.google.com/identity/sign-in/ios/start-integrating) to set up the authentication flow for your application. In the sign-in completion handler, create an App Services Google credential and log the user into your App Services app. The value that you pass to the credential depends on whether or not you have[enabled OpenID Connect](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-openIdConnect) for the provider: * If OpenID Connect is enabled, pass the `id_token` [included in the Google OAuth response](https://developers.google.com/identity/sign-in/ios/backend-auth) to [Credentials.googleId(token:).](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/Credentials.html#/s:10RealmSwift11CredentialsO8googleIdyACSS%5FtcACmF)\n* If OpenID Connect is not enabled, pass the user's [server auth code](https://developers.google.com/identity/sign-in/ios/reference/Classes/GIDGoogleUser#serverauthcode) to[Credentials.google(serverAuthCode:).](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/Credentials.html#/s:10RealmSwift11CredentialsO6googleyACSS%5FtcACmF) ### Apple User If you have enabled [Sign-in with Apple authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication), you can log in using the following code: ```swift // Fetch IDToken via the Apple SDK let credentials = Credentials.apple(idToken: \"<token>\") app.login(credentials: credentials) { (result) in     switch result {\n\n         print(\"Login failed: \\(error.localizedDescription)\")     case .success(let user):         print(\"Successfully logged in as user \\(user)\")         // Now logged in, do something with user         // Remember to dispatch to main if you are doing anything on the UI thread     } } \n``` ## Tip If you get a `Login failed` error saying that the `token contains an invalid number of segments`, verify that you're passing a UTF-8-encoded string version of the JWT. ### Async/Await Login _New in version 10.15.0_. The async/await version of the [App.login](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/App.html#/s:So6RLMAppC10RealmSwiftE5login11credentials7Combine6FutureCySo7RLMUserCs5Error%5FpGAC11CredentialsO%5FtF)method asynchronously returns a User or Error. ```swift func login() async {     do {         let app = App(id: YOUR_APP_SERVICES_APP_ID)         // Authenticate with the instance of the app that points         // to your backend. Here, we're using anonymous login.         let user = try await app.login(credentials: Credentials.anonymous)         print(\"Successfully logged in user: \\(user)\")     } catch {         print(\"Failed to log in user: \\(error.localizedDescription)\")     } } \n``` Starting with Realm Swift SDK Versions 10.15.0 and 10.16.0, many of the Realm APIs support the Swift async/await syntax. Projects must meet these requirements: | Swift SDK Version  | Swift Version Requirement | Supported OS |\n| ------------------ | ------------------------- | ------------ |\n| 10.25.0            | Swift 5.6                 | iOS 13.x     |\n| 10.15.0 or 10.16.0 | Swift 5.5                 | iOS 15.x     | If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ## Offline Login When your Realm application authenticates a user, it caches the user's credentials. You can check for existing user credentials to bypass the login flow and access the cached user. Use this to open a realm offline. ## Note ### Initial login requires a network connection When a user signs up for your app, or logs in for the first time with an existing account on a client, the client must have a network connection. Checking for cached user credentials lets you open a realm offline, but only if the user has previously logged in while online. ```swift // Log the user into the backend app. // The first time you login, the user must have a network connection. func getUser() async throws -> User {     // Check for an existing user.     // If the user is offline but credentials are     // cached, this returns the existing user.     if let user = app.currentUser {         return user     } else {         // If the device has no cached user         // credentials, log them in.         let app = App(id: YOUR_APP_SERVICES_APP_ID)         let loggedInUser = try await app.login(credentials: Credentials.anonymous)         return loggedInUser     } } let user = try await getUser() var configuration = user.configuration(partitionValue: \"Some Partition Value\") // Open a Realm with this configuration. // If you do not require the app to download updates // before opening the realm, the realm just opens, even if // offline. let realm = try await Realm(configuration: configuration)\n\n \n``` ## Get a User Access Token The Realm SDK automatically manages access tokens, refreshes them when they expire, and includes a valid access token for the current user with each request. If you send requests outside of the SDK - for example, through the [GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) \\- then you must include the user's access token with each request. In this scenario, you must manually refresh the token when it expires. Access tokens expire after 30 minutes. You can call [.refreshCustomData()](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE17refreshCustomData7Combine6FutureCySDys11AnyHashableVypGs5Error%5FpGyF)on a logged-in user to refresh the user's auth session. Then, return the`.accessToken` as a string you can use in your code. You might use a function similar to this to fetch an access token: ```swift func getValidAccessToken(user: User) async throws -> String {     // An already logged in user's access token might be stale. To     // guarantee that the token is valid, refresh it if necessary.     try await user.refreshCustomData()     return user.accessToken! } \n``` Which requires a logged-in user: ```swift let app = App(id: YOUR_APP_SERVICES_APP_ID) let user = try await app.login(credentials: Credentials.anonymous) let accessToken = try await getValidAccessToken(user: user) \n``` ## Log Out Once logged in, you can log out: ## Warning When a user logs out, you can no longer read or write data in any synced realms that the user opened. As a result, any operation that has not yet completed before the initiating user logs out cannot complete successfully and will likely result in an error. Any data in a write operation that fails in this way will be lost. ```swift app.currentUser?.logOut { (error) in     // user is logged out or there was an error } \n``` ← [Create and Delete Users - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/create-and-delete-users/ \"Previous Section\")[Custom User Data - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/users/link-user-identities/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Link User Identities - Swift SDK On this page * [Overview](#overview)\n* [Example](#example)\n* [Async/Await Example](#async-await-example) ## Overview Atlas App Services provides [many authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)to log users into your app. Each provider creates a unique user identity. App Services and the Realm Swift SDK lets you merge multiple credentials into one user identity. ## Example Consider an application that offers [anonymous login](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication). This allows users to explore the app without registering. If users like the application, they create permanent accounts. They sign up with SSO or email/password authentication. By default, this creates a new `User` object. The app must link the new identity with the original User. You can link identities using `linkUser(credentials:Credentials)`. This links authentication providers to a logged-in `User` object. ## Async/Await Example _New in version 10.16.0_. The Realm Swift SDK provides an [async/await version of User.linkUser.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE8linkUser11credentials7Combine6FutureCyABs5Error%5FpGAC11CredentialsO%5FtF)\n\n ` Starting with Realm Swift SDK Versions 10.15.0 and 10.16.0, many of the Realm APIs support the Swift async/await syntax. Projects must meet these requirements: | Swift SDK Version  | Swift Version Requirement | Supported OS |\n| ------------------ | ------------------------- | ------------ |\n| 10.25.0            | Swift 5.6                 | iOS 13.x     |\n| 10.15.0 or 10.16.0 | Swift 5.5                 | iOS 15.x     | If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ← [Multi-User Applications - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/multi-user-applications/ \"Previous Section\")[Manage User API Keys - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/users/manage-user-api-keys/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/model-data/model-data-device-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Model Data with Device Sync - Swift SDK On this page * [Realm Object Models](#realm-object-models)\n* [JSON Schema](#json-schema)\n* [Realm Relationships](#realm-relationships)\n* [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationship](#inverse-relationship)\n* [Embedded Object Models](#embedded-object-models)\n* [Create Object Models and Schemas](#create-object-models-and-schemas) ## Realm Object Models To define a Realm object, derive a class from [Object](https://www.mongodb.com/docs/realm-sdks/swift/latest/Typealiases.html#/s:10RealmSwift6Objecta). The models that you define each map to their own collection in MongoDB Atlas. In this example, both`Dog` and `Person` would map to separate collections in MongoDB Atlas. `| class Dog: Object {                               |\n| ------------------------------------------------- |\n| @Persisted(primaryKey: true) var _id = ObjectId() |\n| @Persisted var name = \"\"                          |\n| @Persisted var age = 0                            |\n| }                                                 |\n| class Person: Object {                            |\n| @Persisted(primaryKey: true) var _id = ObjectId() |\n| @Persisted var name = \"\"                          |\n| }                                                 | ` ### JSON Schema When you have a corresponding schema in Atlas App Services, Device Sync automatically converts the Realm Swift data types to BSON as it syncs to Atlas. When the client device syncs the data down from App Services via Device Sync, the SDK converts BSON back to Swift objects. If you query for these objects by [accessing MongoDB Atlas data directly](https://mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/#std-label-ios-mongodb-remote-access) instead of using Device Sync to sync the data, you get the BSON data types. MongoDB Data Access does not automatically map to the Swift object equivalents. Dog Schema in App Services ``` {   \"title\": \"Dog\",   \"bsonType\": \"object\",   \"required\": [     \"_id\"   ],   \"properties\": {     \"_id\": {       \"bsonType\": \"objectId\"     },     \"name\": {       \"bsonType\": \"string\"     },     \"age\": {       \"bsonType\": \"long\"     }   } } \n``` Person Schema in App Services ``` {   \"title\": \"Person\",   \"bsonType\": \"object\",   \"required\": [     \"_id\"   ],   \"properties\": {     \"_id\": {       \"bsonType\": \"objectId\"     },     \"name\": {       \"bsonType\": \"string\"     }   } } \n``` ## Realm Relationships ### To-One Relationship\n\n ```swift class Dog: Object {    @Persisted(primaryKey: true) var _id = ObjectId()    @Persisted var name = \"\"    @Persisted var age = 0 } class Person: Object {    @Persisted(primaryKey: true) var _id = ObjectId()    @Persisted var name = \"\"    // To-one relationship    @Persisted var dog: Dog? } \n``` #### JSON Schema In the App Services schema, we see the new property translates to a field `dog`. The field is not in the `required` array because it is an optional property. Its type is an `objectId` which links to a specific `Dog` object in the separate `Dog` collection. The objectId is the primary key of the `Dog`model, so it's the field that links the two objects. Person with To-One Relationship to Dog ``` {   \"title\": \"Person\",   \"bsonType\": \"object\",   \"required\": [     \"_id\"   ],   \"properties\": {     \"_id\": {       \"bsonType\": \"objectId\"     },     \"dog\": {       \"bsonType\": \"objectId\"     },     \"name\": {       \"bsonType\": \"string\"     }   } } \n``` The `Dog` schema doesn't change. Because this is a to-one relationship, it's a one-way relationship; the `Dog` has no relationship back to `Person`. ## Tip ### See also:  For more information about to-one relationships, see: [Key Concept: To-One Relationship.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-one-relationship) ### To-Many Relationship Using the objects in the example above, consider a case where a `Person`can have many dogs. We can add a `dogs` property to our `Person` model that is a list of `Dog` objects. If the person has no dogs, this is an empty list. As the person gets dogs, we can create new dog objects and append them to the person's `dogs` list. ```swift class Dog: Object {    @Persisted(primaryKey: true) var _id = ObjectId()    @Persisted var name = \"\"    @Persisted var age = 0 } class Person: Object {    @Persisted(primaryKey: true) var _id = ObjectId()    @Persisted var name = \"\"    // To-many relationship - a person can have many dogs    @Persisted var dogs: List<Dog> } \n``` #### JSON Schema In the App Services schema, we see the new property translates to a field`dogs`. The type of this field is an array, the items in the array are of type `objectId`. This is because we defined the primary key on our `Dog` model as an `objectId`. This field is an array of the primary keys of all of the `Dog` objects related to the `Person` object. Person with To-Many Relationship to Dog ``` {   \"title\": \"Person\",   \"bsonType\": \"object\",   \"required\": [     \"_id\"   ],   \"properties\": {     \"_id\": {       \"bsonType\": \"objectId\"     },     \"name\": {       \"bsonType\": \"string\"     },     \"dogs\": {       \"bsonType\": \"array\",       \"items\": {         \"bsonType\": \"objectId\"       }     }   } } \n``` ## Tip ### See also:  For more information about to-many relationships, see: [Key Concept: To-Many Relationship.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-many-relationship) ### Inverse Relationship Using the objects in the example above, consider a case where the `Dog`object has an inverse relationship to the `Person` object. ```swift class Dog: Object {    @Persisted(primaryKey: true) var _id = ObjectId()    @Persisted var name = \"\"    @Persisted var age = 0\n\n    @Persisted(originProperty: \"dogs\") var person: LinkingObjects<Person> } class Person: Object {    @Persisted(primaryKey: true) var _id = ObjectId()    @Persisted var name = \"\"    // To-many relationship - a person can have many dogs    @Persisted var dogs: List<Dog> } \n``` #### JSON Schema In the App Services schema, we see that the `person` property that represents the inverse relationship to a `Person` from our `Dog`model is not present. You can't directly set the value of an inverse relationship, and that relationship does not exist in Atlas. However, Realm Database derives and updates those relationships for you in the client application based on your Realm object model. Dog with Inverse Relationship to Person ``` {   \"title\": \"Dog\",   \"bsonType\": \"object\",   \"required\": [     \"_id\"   ],   \"properties\": {     \"_id\": {       \"bsonType\": \"objectId\"     },     \"name\": {       \"bsonType\": \"string\"     },     \"age\": {       \"bsonType\": \"long\"     }   } } \n``` ## Tip ### See also:  For more information about inverse relationships, see: [Key Concept: Inverse Relationship.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-inverse-relationship) ### Embedded Object Models When you define an embedded object with the Realm Swift SDK, you derive a class from [EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/EmbeddedObject.html). You can reference an embedded object type from parent object types in the same way as you would define a relationship: ```swift class Person: Object {     @Persisted(primaryKey: true) var id = 0     @Persisted var name = \"\"     // To-many relationship - a person can have many dogs     @Persisted var dogs: List<Dog>     // Inverse relationship - a person can be a member of many clubs     @Persisted(originProperty: \"members\") var clubs: LinkingObjects<DogClub>     // Embed a single object.     // Embedded object properties must be marked optional.     @Persisted var address: Address?     convenience init(name: String, address: Address) {         self.init()         self.name = name         self.address = address     } } class DogClub: Object {     @Persisted var name = \"\"     @Persisted var members: List<Person>     // DogClub has an array of regional office addresses.     // These are embedded objects.     @Persisted var regionalOfficeAddresses: List<Address>     convenience init(name: String, addresses: [Address]) {         self.init()         self.name = name         self.regionalOfficeAddresses.append(objectsIn: addresses)     } } class Address: EmbeddedObject {     @Persisted var street: String?     @Persisted var city: String?     @Persisted var country: String?     @Persisted var postalCode: String? } \n``` #### JSON Schema Embedded objects map to embedded documents in the parent type's [schema](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). This behavior differs from regular Realm objects, which map to their own MongoDB collection. ``` {   \"title\": \"Person\",   \"bsonType\": \"object\",   \"required\": [\"id\"],   \"properties\": {     \"id\": { \"bsonType\": \"int\" },     \"name\": { \"bsonType\": \"string\" },     \"dogs\": {       \"bsonType\": \"array\",       \"items\": {         \"bsonType\": \"objectId\"       }     },\n\n       \"title\": \"Address\",       \"bsonType\": \"object\",       \"properties\": {         \"street\": { \"bsonType\": \"string\" },         \"city\": { \"bsonType\": \"string\" },         \"country\": { \"bsonType\": \"string\" },         \"postalCode\": { \"bsonType\": \"string\" }       }     }   } } \n``` ``` {   \"title\": \"DogClub\",   \"bsonType\": \"object\",   \"required\": [\"_id\", \"name\", \"addresses\"],   \"properties\": {     \"_id\": \"objectId\",     \"name\": { \"bsonType\": \"string\" },     \"members\": {       \"bsonType\": \"array\",       \"items\": {         \"bsonType\": \"objectId\"       }     },     \"addresses\": {       \"bsonType\": \"array\",       \"items\": {         \"title\": \"Address\",         \"bsonType\": \"object\",         \"properties\": {           \"street\": { \"bsonType\": \"string\" },           \"city\": { \"bsonType\": \"string\" },           \"country\": { \"bsonType\": \"string\" },           \"postalCode\": { \"bsonType\": \"string\" }         }       }     }   } } \n``` ## Create Object Models and Schemas To map between SDK object models and BSON data in Atlas, you must have a[schema in App Services](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/sync-schema-overview/#std-label-sync-schema-overview) that matches your[SDK object model](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-swift-object-models). There are a few ways you can generate matching schema and object models: * Create object models in the client application, and generate App Services schemas from them.\n* Create schemas in App Services, and generate Realm object models from them. If you are developing a new client application, you likely want to iterate on the data model in the client application. Enable [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) in App Services to have the backend infer and update the schema based on your client object models. Development Mode does not work with[breaking schema changes](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-destructive-changes-synced-schema), so you must[remove the existing schema](https://www.mongodb.com/docs/atlas/app-services/schemas/remove-a-schema/#std-label-remove-a-schema) from the server when you make breaking changes to the SDK data model. If you are developing a client application that works with data that already exists in Atlas, you can [generate a schema](https://www.mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) from that data. Then, you can [generate SDK object models](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/generate-sdk-object-models/#std-label-generate-sdk-object-models) from the server-side schema.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Model Relationships - Swift SDK On this page * [Key Concept: Relationships](#key-concept--relationships)\n* [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationship](#inverse-relationship)\n* [Declare Relationship Properties](#declare-relationship-properties)\n* [Define a To-One Relationship Property](#define-a-to-one-relationship-property)\n* [Define a To-Many Relationship Property](#define-a-to-many-relationship-property)\n* [Define an Inverse Relationship Property](#define-an-inverse-relationship-property)\n* [Define an Embedded Object Property](#define-an-embedded-object-property) ## Key Concept: Relationships Realm Database doesn't use bridge tables or explicit joins to define relationships as you would in a relational database. Realm Database handles relationships through embedded objects or reference properties to other Realm Database objects. You read from and write to these properties directly. This makes querying relationships as performant as querying against any other property. Realm Database supports **to-one**, **to-many**, and **inverse**relationships. ### To-One Relationship A **to-one** relationship means that an object relates to one other object. You define a to-one relationship for an object type in its object schema. Specify a property where the type is the related Realm object type. For example, a dog might have a to-one relationship with a favorite toy. ## Tip To learn how to define a to-one relationship, see[Define a To-One Relationship Property.](#std-label-ios-define-a-to-one-relationship-property) ### To-Many Relationship A **to-many** relationship means that an object relates to more than one other object. In Realm Database, a to-many relationship is a list of references to other objects. For example, a person might have many dogs. A [List](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/List.html) represents the [to-many relationship](#std-label-ios-to-many-relationship) between two Realm types. Lists are mutable: within a write transaction, you can add and remove elements to and from a list. Lists are not associated with a query and are usually declared as a property of an object model. ## Tip To learn how to define a to-many relationship, see[Define a To-Many Relationship Property.](#std-label-ios-define-a-to-many-relationship-property) ### Inverse Relationship Relationship definitions in Realm Database are unidirectional. An**inverse relationship** links an object back to an object that refers to it. You must explicitly define a property in the object's model as an inverse relationship. Inverse relationships can link back to objects in a to-one or to-many relationship. A [LinkingObjects](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/LinkingObjects.html) collection represents the [inverse relationship](#std-label-ios-inverse-relationship)between two Realm types. You cannot directly add or remove items from a LinkingObjects collection. Inverse relationships automatically update themselves with corresponding backlinks. You can find the same set of Realm objects with a manual query, but the inverse relationship field reduces boilerplate query code and capacity for error. For example, consider a task tracker with the to-many relationship \"User has many Tasks\". This does not automatically create the inverse relationship \"Task belongs to User\". To create the inverse relationship, add a User property on the Task that points back to the task's owner. When you specify the inverse relationship from task to user, you can query on that. If you don't specify the inverse relationship, you must run a separate query to look up the user to whom the task is assigned. ## Important You cannot manually set the value of an inverse relationship property. Instead, Realm Database updates implicit relationships when you add or remove an object in the relationship. Relationships can be many-to-one or many-to-many. So following inverse relationships can result in zero, one, or many objects. ## Tip\n\n ## Declare Relationship Properties ## Tip ### See also:  With Device Sync, you can also [define your relationships](https://www.mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-define-a-relationship) in the App Services UI. ### Define a To-One Relationship Property A **to-one** relationship maps one property to a single instance of another object type. For example, you can model a person having at most one companion dog as a to-one relationship. Setting a relationship field to null removes the connection between objects. Realm does not delete the referenced object, though, unless it is[an embedded object.](#std-label-ios-embedded-objects) ## Important ### To-one relationships must be optional When you declare a to-one relationship in your object model, it must be an optional property. If you try to make a to-one relationship required, Realm throws an exception at runtime. ## Tip ### See also:  For more information about to-one relationships, see: [Key Concept: To-One Relationship.](#std-label-ios-to-one-relationship) If your app uses Device Sync, see the [Model Data with Device Sync](https://mongodb.com/docs/realm/sdk/swift/model-data/model-data-device-sync/#std-label-swift-device-sync-to-one-relationship) page for information on how the to-one relationship in Swift object models translates to Atlas documents. ### Define a To-Many Relationship Property A **to-many** relationship maps one property to zero or more instances of another object type. For example, you can model a person having any number of companion dogs as a to-many relationship. ## Tip ### See also:  For more information about to-many relationships, see: [Key Concept: To-Many Relationship.](#std-label-ios-to-many-relationship) If your app uses Device Sync, see the [Model Data with Device Sync](https://mongodb.com/docs/realm/sdk/swift/model-data/model-data-device-sync/#std-label-swift-device-sync-to-many-relationship) page for information on how the to-many relationship in Swift object models translates to Atlas documents. ### Define an Inverse Relationship Property An **inverse relationship** property is an automatic backlink relationship. Realm Database automatically updates implicit relationships whenever an object is added or removed in a corresponding to-many list or to-one relationship property. You cannot manually set the value of an inverse relationship property. ## Tip ### See also:  For more information about inverse relationships, see: [Key Concept: Inverse Relationship.](#std-label-ios-inverse-relationship) If your app uses Device Sync, see the [Model Data with Device Sync](https://mongodb.com/docs/realm/sdk/swift/model-data/model-data-device-sync/#std-label-swift-device-sync-inverse-relationship) page for information on how the inverse relationship in Swift object models translates to Atlas documents. ### Define an Embedded Object Property An **embedded object** exists as nested data inside of a single, specific parent object. It inherits the lifecycle of its parent object and cannot exist as an independent Realm object. Realm automatically deletes embedded objects if their parent object is deleted or when overwritten by a new embedded object instance. ## Note ### Realm Uses Cascading Deletes for Embedded Objects When you delete a Realm object, any embedded objects referenced by that object are deleted with it. If you want the referenced objects to persist after the deletion of the parent object, your type should not be an embedded object at all. Use a regular [Realm object](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-a-new-object-type) with a [to-one relationship](#std-label-ios-define-a-to-one-relationship-property) instead. ## Tip ### See also:  If your app uses Device Sync, see the [Model Data with Device Sync](https://mongodb.com/docs/realm/sdk/swift/model-data/model-data-device-sync/#std-label-swift-device-sync-embedded-object-models) page for information on how embedded objects in Swift object models translate to Atlas documents.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/write/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Write Data - SwiftUI On this page * [Perform a Quick Write](#perform-a-quick-write)\n* [Update an Object's Properties](#update-an-object-s-properties)\n* [Update an ObservedResults Collection](#update-an-observedresults-collection)\n* [Append an Object to a List](#append-an-object-to-a-list)\n* [Use Create to Copy an Object Into the Realm](#use-create-to-copy-an-object-into-the-realm)\n* [Perform an Explicit Write](#perform-an-explicit-write) ## Perform a Quick Write In addition to performing writes inside a transaction block, the Realm Swift SDK offers a convenience feature to enable quick writes without explicitly performing a write transaction. When you use the `@ObservedRealmObject` or `@ObservedResults` property wrappers, you can implicitly open a write transaction. Use the `$` operator to create a two-way binding to the state object. Then, when you make changes to the bound object or collection, you initiate an implicit write. The Realm SwiftUI property wrappers work with [frozen data](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-frozen-objects) to provide thread safety. When you use `$` to create a two-way binding, the Realm Swift SDK manages thawing the frozen objects so you can write to them. ### Update an Object's Properties In this example, we create a two-way binding with one of the state object's properties. `$dog.favoriteToy` creates a binding to the model Dog object's `favoriteToy` property When the app user updates that field in this example, Realm Database opens an implicit write transaction and saves the new value to the database. `| struct EditDogDetails: View {                     |\n| ------------------------------------------------- |\n| @ObservedRealmObject var dog: Dog                 |\n|                                                   |\n| var body: some View {                             |\n| VStack {                                          |\n| Text(dog.name)                                    |\n| .font(.title2)                                    |\n| TextField(\"Favorite toy\", text: $dog.favoriteToy) |\n| }                                                 |\n| }                                                 |\n| }                                                 | ` ### Update an ObservedResults Collection\n\n ```swift struct DogsListView: View {     @ObservedResults(Dog.self) var dogs         var body: some View {         NavigationView {             VStack {                 // The list shows the dogs in the realm.                 List {                     ForEach(dogs) { dog in                         DogRow(dog: dog)                         // Because `$dogs` here accesses an ObservedResults                         // collection, we can remove the specific dog from the collection.                         // Regular Realm Results are immutable, but you can write directly                         // to an `@ObservedResults` collection.                     }.onDelete(perform: $dogs.remove)                 }.listStyle(GroupedListStyle())                     .navigationBarTitle(\"Dogs\", displayMode: .large)                     .navigationBarBackButtonHidden(true)                 // Action bar at bottom contains Add button.                 HStack {                     Spacer()                     Button(action: {                         // The bound collection automatically                         // handles write transactions, so we can                         // append directly to it. This example assumes                         // we have some values to populate the Dog object.                         $dogs.append(Dog(value: [\"name\":\"Bandido\"]))                     }) { Image(systemName: \"plus\") }                     .accessibilityIdentifier(\"addDogButton\")                 }.padding()             }         }     } } \n``` ## Note The `@ObservedResults` property wrapper is intended for use in a SwiftUI View. If you want to observe results in a view model, [register a change listener.](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes) ### Append an Object to a List When you have a two-way binding with an `@ObservedRealmObject` that has a list property, you can add new objects to the list. In this example, the `Person` object has a list property that forms a[to-many relationship](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-many-relationship) with one or more dogs. ```swift class Person: Object, ObjectKeyIdentifiable {    @Persisted(primaryKey: true) var _id: ObjectId    @Persisted var firstName = \"\"\n\n    ...    @Persisted var dogs: List<Dog> } \n``` When the user presses the `Save` button, this: * Creates a `Dog` object with the details that the user has entered\n* Appends the `Dog` object to the `Person` object's `dogs` list ```swift struct AddDogToPersonView: View {     @ObservedRealmObject var person: Person     @Binding var isInAddDogView: Bool     @State var name = \"\"     @State var breed = \"\"     @State var weight = 0     @State var favoriteToy = \"\"     @State var profileImageUrl: URL?     var body: some View {         Form {             TextField(\"Dog's name\", text: $name)             TextField(\"Dog's breed\", text: $breed)             TextField(\"Dog's weight\", value: $weight, format: .number)             TextField(\"Dog's favorite toy\", text: $favoriteToy)             TextField(\"Image link\", value: $profileImageUrl, format: .url)                             .keyboardType(.URL)                             .textInputAutocapitalization(.never)                             .disableAutocorrection(true)             Section {                 Button(action: {                     let dog = createDog(name: name, breed: breed, weight: weight, favoriteToy: favoriteToy, profileImageUrl: profileImageUrl)                     $person.dogs.append(dog)                     isInAddDogView.toggle()                 }) {                     Text(\"Save\")                 }                 Button(action: {                     isInAddDogView.toggle()                 }) {                     Text(\"Cancel\")                 }             }         }     } } \n``` ### Use Create to Copy an Object Into the Realm There may be times when you create a new object, and set one of its properties to an object that already exists in the realm. Then, when you go to add the new object to the realm, you see an error similar to: ```shell Object is already managed by another Realm. Use create instead to copy it into this Realm. \n``` When this occurs, you can use the [.create](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V6create%5F5value6updatexxm%5FypAC12UpdatePolicyOtSo0aB6ObjectCRbzlF)method to initialize the object, and use `modified: .update` to set its property to the existing object. ## Example Consider a version of the DoggoDB `Dog` model where the `favoriteToy`property isn't just a `String`, but is an optional `DogToy` object: ```swift class Dog: Object, ObjectKeyIdentifiable {\n\n    @Persisted var name = \"\"    ...    @Persisted var favoriteToy: DogToy?    ... } \n``` When your app goes to create a new `Dog` object, perhaps it checks to see if the `DogToy` already exists in the realm, and then set the `favoriteToy`property to the existing dog toy. When you go to append the new `Dog` to the `Person` object, you may see an error similar to: ```shell Object is already managed by another Realm. Use create instead to copy it into this Realm. \n``` The `Dog` object remains unmanaged until you append it to the `Person`object's `dogs` property. When the Realm Swift SDK checks the `Dog`object to find the realm that is currently managing it, it finds nothing. When you use the `$` notation to perform a quick write that appends the`Dog` object to the `Person` object, this write uses the realm it has access to in the view. This is a realm instance implicitly opened by the `@ObservedRealmObject` or `@ObservedResults` property wrapper. The existing `DogToy` object, however, may be managed by a different realm instance. To solve this error, use the [.create](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V6create%5F5value6updatexxm%5FypAC12UpdatePolicyOtSo0aB6ObjectCRbzlF)method when you initialize the `Dog` object, and use`modified: .update` to set its `favoriteToy` value to the existing object: ```swift // When working with an `@ObservedRealmObject` `Person`, this is a frozen object. // Thaw the object and get its realm to perform the write to append the new dog. let thawedPersonRealm = frozenPerson.thaw()!.realm! try! thawedPersonRealm.write {     // Use the .create method with `update: .modified` to copy the     // existing object into the realm     let dog = thawedPersonRealm.create(Dog.self, value:                                         [\"name\": \"Maui\",                                          \"favoriteToy\": wubba],                                        update: .modified)     person.dogs.append(dog) } \n``` ## Perform an Explicit Write In some cases, you may want or need to explicitly perform a write transaction instead of using the implicit `$` to perform a quick write. You may want to do this when: * You need to look up additional objects to perform a write\n* You need to perform a write to objects you don't have access to in the view If you pass an object you are observing with `@ObservedRealmObject` or`@ObservedResults` into a function where you perform an explicit write transaction that modifies the object, you must thaw it first. ```swift let thawedCompany = company.thaw()! \n``` You can access the realm that is managing the object or objects by calling`.realm` on the object or collection: ```swift let realm = company.realm!.thaw() \n``` Because the SwiftUI property wrappers use frozen objects, you must thaw the realm before you can write to it. ## Example Consider a version of the DoggoDB app where a `Company` object has a list of `Employee` objects. Each `Employee` has a list of`Dog` objects. But for business reasons, you also wanted to have a list of `Dog` objects available directly on the `Company` object, without being associated with an `Employee`. The model might look something like: ```swift class Company: Object, ObjectKeyIdentifiable {     @Persisted(primaryKey: true) var _id: ObjectId     @Persisted var companyName = \"\"     @Persisted var employees: List<Employee>\n\n } \n``` Consider a view where you have access to the `Company` object, but want to perform an explicit write to add an existing dog to an existing employee. Your function might look something like: ```swift // The `frozenCompany` here represents an `@ObservedRealmObject var company: Company` performAnExplicitWrite(company: frozenCompany, employeeName: \"Dachary\", dogName: \"Maui\") func performAnExplicitWrite(company: Company, employeeName: String, dogName: String) {     // Get the realm that is managing the `Company` object you passed in.     // Thaw the realm so you can write to it.     let realm = company.realm!.thaw()     // Thawing the `Company` object that you passed in also thaws the objects in its List properties.     // This lets you append the `Dog` to the `Employee` without individually thawing both of them.     let thawedCompany = company.thaw()!     let thisEmployee = thawedCompany.employees.where { $0.name == employeeName }.first!     let thisDog = thawedCompany.dogs.where { $0.name == dogName }.first!     try! realm.write {         thisEmployee.dogs.append(thisDog)     } } \n``` ← [Pass Realm Data Between SwiftUI Views](https://mongodb.com/docs/realm/sdk/swift/swiftui/pass-realm-data-between-views/ \"Previous Section\")[Filter Data - SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/filter-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/model-data/change-an-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Change an Object Model - Swift SDK On this page * [Overview](#overview)\n* [Key Concept: Schema Version](#key-concept--schema-version)\n* [Migrations](#migrations)\n* [Automatically Update Schema](#automatically-update-schema)\n* [Add a Property](#add-a-property)\n* [Delete a Property](#delete-a-property)\n* [Manually Migrate Schema](#manually-migrate-schema)\n* [Rename a Property](#rename-a-property)\n* [Modify Properties](#modify-properties)\n* [Convert from Object to EmbeddedObject](#convert-from-object-to-embeddedobject)\n* [Additional Migration Examples](#additional-migration-examples) ## Note ### Modify Schema Properties of a Synced Realm The following page demonstrates how to modify schema properties of a local realm. Learn how to [modify schema properties of a synced realm.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) ## Overview When you update your object schema, you must increment the schema version and perform a migration. ## Tip ### See also:  This page provides general Swift and Objective-C migration examples. If you are using Realm with SwiftUI, see the [SwiftUI-specific migration examples.](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/change-an-object-model/#std-label-swiftui-realm-migrations) If your schema update adds optional properties or removes properties, Realm Database can perform the migration automatically. You only need to increment the `schemaVersion`. For more complex schema updates, you must also manually specify the migration logic in a `migrationBlock`. This might include changes such as: * Adding required properties that must be populated with default values\n* Combining fields\n* Renaming a field\n* Changing a field's type\n* Converting from an object to an embedded object ## Tip ### Bypass Migration During Development When developing or debugging your application, you may prefer to delete the realm instead of migrating it. Use the[deleteRealmIfMigrationNeeded](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV06deleteA17IfMigrationNeededSbvp)flag to delete the database automatically when a schema mismatch would require a migration. Never release an app to production with this flag set to `true`. ## Key Concept: Schema Version A **schema version** identifies the state of a [Realm Schema](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-realm-schema) at some point in time. Realm Database tracks the schema version of each realm and uses it to map the objects in each realm to the correct schema. Schema versions are integers that you may include in the realm configuration when you open a realm. If a client application does not specify a version number when it opens a realm then the realm defaults to version `0`. ## Important ### Increment Versions Monotonically Migrations must update a realm to a higher schema version. Realm Database will throw an error if a client application opens a realm with a schema version that is lower than the realm's current version or if the specified schema version is the same as the realm's current version but includes different [object schemas.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-object-models-and-schemas) ### Migrations A **local migration** is a migration for a realm that does not automatically [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) with another realm. Local migrations have access to the existing Realm Schema, version, and objects and define logic that incrementally updates the realm to its new schema version. To perform a local migration you must specify a new schema version that is higher than the current version and provide a migration function when you open the out-of-date realm.\n\n ## Automatically Update Schema ### Add a Property Realm Database can automatically migrate added properties, but you must specify an updated schema version when you make these changes. ## Note Realm Database does not automatically set values for new required properties. You must use a migration block to set default values for new required properties. For new optional properties, existing records can have null values. This means you don't need a migration block when adding optional properties. ## Example A realm using schema version `1` has a `Person` object type that has first name, last name, and age properties: The developer decides that the `Person` class needs an `email` field and updates the schema. Realm Database automatically migrates the realm to conform to the updated `Person` schema. But the developer must set the realm's schema version to `2`. ### Delete a Property To delete a property from a schema, remove the property from the object's class and set a `schemaVersion` of the realm's configuration object. Deleting a property will not impact existing objects. ## Example A realm using schema version `1` has a `Person` object type that has first name, last name, and age properties: The developer decides that the `Person` does not need the `age` field and updates the schema. Realm Database automatically migrates the realm to conform to the updated `Person` schema. But the developer must set the realm's schema version to `2`. ## Tip SwiftUI developers may see an error that a migration is required when they add or delete properties. This is related to the lifecycle in SwiftUI. The Views are laid out, and then the `.environment` modifier sets the config. To resolve a migration error in these circumstances, pass`Realm.Configuration(schemaVersion: <Your Incremented Version>)`into the `ObservedResults` constructor. ## Manually Migrate Schema For more complex schema updates, Realm Database requires a manual migration for old instances of a given object to the new schema. ### Rename a Property To rename a property during a migration, use the[Migration.renameProperty(onType:from:to:)](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Migration.html#/s:10RealmSwift9MigrationV14renameProperty6onType4from2toySS%5FS2StF)method. Realm Database applies any new nullability or indexing settings during the rename operation. ## Example Rename `age` to `yearsSinceBirth` within a [migrationBlock.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV14migrationBlockyAA9MigrationV%5Fs6UInt64VtcSgvp) ### Modify Properties ## Tip You can use the [deleteRealmIfMigrationNeeded](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV06deleteA17IfMigrationNeededSbvp)method to delete the realm if it would require a migration. This can be useful during development when you need to iterate quickly and don't want to perform the migration. To define custom migration logic, set the [migrationBlock](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV14migrationBlockyAA9MigrationV%5Fs6UInt64VtcSgvp)property of the [Configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html) when [opening a realm.](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-configure-and-open-a-realm)\n\n ## Example A realm using schema version `1` has a `Person` object type that has separate fields for first and last names: The developer decides that the `Person` class should use a combined`fullName` field instead of the separate `firstName` and`lastName` fields and updates the schema. To migrate the realm to conform to the updated `Person` schema, the developer sets the realm's schema version to `2` and defines a migration function to set the value of `fullName` based on the existing `firstName` and `lastName` properties. Later, the developer decides that the `age` field should be of type `String`rather than `Int` and updates the schema. To migrate the realm to conform to the updated `Person` schema, the developer sets the realm's schema version to `3` and adds a conditional to the migration function so that the function defines how to migrate from any previous version to the new one. ## Tip ### Linear Migrations Avoid nesting or otherwise skipping `if (oldSchemaVersion < X)` statements in migration blocks. This ensures that all updates can be applied in the correct order, no matter which schema version a client starts from. The goal is to define migration logic which can transform data from any outdated schema version to match the current schema. ### Convert from Object to EmbeddedObject [Embedded objects](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-embedded-objects) cannot exist independently of a parent object. When changing an Object to an EmbeddedObject, the migration block must ensure that every embedded object has exactly one backlink to a parent object. Having no backlinks or multiple backlinks raises the following exceptions: `| At least one object does not have a backlink (data would get lost). |\n| ------------------------------------------------------------------- | ` ``` At least one object does have multiple backlinks. \n``` ## Tip ### See also:  [Define an Embedded Object Property](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-embedded-objects) ## Additional Migration Examples Please check out the additional migration examples on the[realm-swift repo.](https://github.com/realm/realm-swift/tree/master/examples/ios/swift/Migration) ← [Supported Types - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/ \"Previous Section\")[Model Data with Device Sync - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/model-data-device-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/filter-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Filter Data - SwiftUI On this page * [Observe in SwiftUI Views](#observe-in-swiftui-views)\n* [Search a Realm Collection](#search-a-realm-collection)\n* [Filter or Query a Realm with ObservedResults](#filter-or-query-a-realm-with-observedresults)\n* [Filter with an NSPredicate](#filter-with-an-nspredicate)\n* [Query with the Realm Type-Safe Query API](#query-with-the-realm-type-safe-query-api)\n* [Section Filtered Results](#section-filtered-results) ## Observe in SwiftUI Views The `@ObservedResults` property wrapper used in the examples on this page is intended for use in a SwiftUI View. If you want to observe results in a view model instead, [register a change listener.](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes) ## Search a Realm Collection _New in version 10.19.0_. The Realm Swift SDK allows you to extend [.searchable](https://developer.apple.com/documentation/swiftui/form/searchable%28text:placement:prompt:%29-6royb). When you use [ObservedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedResults.html)to query a realm, you can specify collection and keypath in the result set to mark it as searchable. The collection is the bound collection represented by your ObservedResults query. In this example, it is the `dogs` variable that represents the collection of all Dog objects in the realm. The keypath is the object property that you want to search. In this example, we search the dogs collection by dog name. The Realm Swift`.searchable` implementation only supports keypaths with `String` types.\n\n ` ## Filter or Query a Realm with ObservedResults The [@ObservedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedResults.html) property wrapper opens a realm and returns all objects of the specified type. However, you can filter or query `@ObservedResults` to use only a subset of the objects in your view. ## Tip ### See also:  For more information about the query syntax and types of queries that Realm supports, see: [Read - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-swift-crud-read) and [Filter Data - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-filter-data) ### Filter with an NSPredicate To filter `@ObservedResults` using the [NSPredicate Query API](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-nspredicate-query), pass an [NSPredicate](https://developer.apple.com/documentation/foundation/nspredicate) as an argument to `filter`: ```swift struct FilterDogsViewNSPredicate: View {     @ObservedResults(Dog.self, filter: NSPredicate(format: \"weight > 40\")) var dogs         var body: some View {         NavigationView {             // The list shows the dogs in the realm.             List {                 ForEach(dogs) { dog in                     DogRow(dog: dog)                 }             }         }     } } \n``` ### Query with the Realm Type-Safe Query API _New in version 10.24.0_: Use _where_ to perform type-safe queries on ObservedResults. To use `@ObservedResults` with the [Realm Type-Safe Query API](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-realm-swift-query-api), pass a query in a closure as an argument to`where`: ```swift struct FilterDogsViewTypeSafeQuery: View {     @ObservedResults(Dog.self, where: ( { $0.weight > 40 } )) var dogs         var body: some View {         NavigationView {             // The list shows the dogs in the realm.             List {                 ForEach(dogs) { dog in                     DogRow(dog: dog)                 }             }         }     } } \n``` ## Section Filtered Results _New in version 10.29.0_. The [@ObservedSectionedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedSectionedResults.html)property wrapper opens a realm and returns all objects of the specified type, divided into sections by the specified key path. Similar to`@ObservedResults` above, you can filter or query `@ObservedSectionedResults`to use only a subset of the objects in your view: ```swift @ObservedSectionedResults(Dog.self,                           sectionKeyPath: \\.firstLetter,                           where: ( { $0.weight > 40 } )) var dogs \n```\n\n",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/background-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Data in the Background with SwiftUI - Swift SDK On this page * [Overview](#overview)\n* [Enable Background Modes for Your App](#enable-background-modes-for-your-app)\n* [Add Background Modes Capability](#add-background-modes-capability)\n* [Select Background Modes](#select-background-modes)\n* [Update the Info.plist](#update-the-info.plist)\n* [Schedule a Background Task](#schedule-a-background-task)\n* [Create the Background Task](#create-the-background-task)\n* [Test Your Background Task](#test-your-background-task)\n* [Configure a Device to Run Your App](#configure-a-device-to-run-your-app)\n* [Set a Breakpoint](#set-a-breakpoint)\n* [Run the App](#run-the-app)\n* [Add or Change Data in Atlas](#add-or-change-data-in-atlas)\n* [Invoke the Background Task in LLDB](#invoke-the-background-task-in-lldb)\n* [Turn on Airplane Mode on the Device](#turn-on-airplane-mode-on-the-device)\n* [Open the App](#open-the-app) ## Overview You can use a SwiftUI [BackgroundTask](https://developer.apple.com/documentation/SwiftUI/BackgroundTask)to update a Synced realm when your app is in the background. This example demonstrates how to configure and perform background Syncing in an iOS app. You can follow along with the example on this page using the SwiftUI Device Sync Template App. To get your own copy of the SwiftUI Device Sync Template App, check out the [Device Sync SwiftUI tutorial](https://www.mongodb.com/docs/atlas/app-services/tutorial/swiftui/#std-label-swift-swiftui-tutorial) and go through the Prerequisitesand Start with the Template sections. ## Enable Background Modes for Your App To enable background tasks for your app: 1 ### Add Background Modes Capability Select your app Target, go to the Signing & Capabilitiestab, and click \\+ Capability to add the capability. ![Screenshot of Xcode with app Target selected, Signing & Capabilities tab open, and arrow pointing to add Capabilities.](https://mongodb.com/docs/realm/images/xcode-select-target-add-capability.png) click to enlarge Search for \"background\", and select Background Modes. 2 ### Select Background Modes Now you should see a Background Modes section in yourSigning & Capabilities tab. Expand this section, and click the checkboxes to enable Background fetch andBackground processing. 3 ### Update the Info.plist Go to your project's `Info.plist`, and add a new row for`Permitted background task scheduler identifiers`. If you are viewing raw keys and values, the key is`BGTaskSchedulerPermittedIdentifiers`. This field is an array. Add a new item to it for your background task identifier. Set the new item's value to the string you intend to use as the identifier for your background task. For example: `refreshTodoRealm`. ## Schedule a Background Task After enabling background processes for your app, you can start adding the code to the app to schedule and execute a background task. First, import`BackgroundTasks` in the files where you will write this code: `| import SwiftUI         |\n| ---------------------- |\n| import RealmSwift      |\n| import BackgroundTasks | ` Now you can add a scheduled background task. If you're following along via the Template App, you can update your `@main` view: ```swift @main struct realmSwiftUIApp: SwiftUI.App {   @Environment(\\.scenePhase) private var phase   var body: some Scene {     WindowGroup {     ContentView(app: realmApp)   }   .onChange(of: phase) { newPhase in     switch newPhase {     case .background: scheduleAppRefresh()     default: break     }   } } \n``` You can add an environment variable to store a change to the `scenePhase`:`@Environment(\\.scenePhase) private var phase`.\n\n Create the `scheduleAppRefresh()` function: ```swift func scheduleAppRefresh() {   let backgroundTask = BGAppRefreshTaskRequest(identifier: \"refreshTodoRealm\")   backgroundTask.earliestBeginDate = .now.addingTimeInterval(10)   try? BGTaskScheduler.shared.submit(backgroundTask) } \n``` This schedules the work to execute the background task whose identifier you added to the Info.plist above when you enabled Background Modes. In this example, the identifier `refreshTodoRealm` refers to this task. ## Create the Background Task Now that you've scheduled the background task, you need to create the background task that will run to update the synced realm. If you're following along with the Template App, you can add this`backgroundTask` to your `@main` view, after the `.onChange(of: phase)`: ```swift .onChange(of: phase) { newPhase in   switch newPhase {   case .background: scheduleAppRefresh()   default: break   } } .backgroundTask(.appRefresh(\"refreshTodoRealm\")) {   guard let user = realmApp.currentUser else {     return   }   let config = user.flexibleSyncConfiguration(initialSubscriptions: { subs in     if let foundSubscription = subs.first(named: \"user_tasks\") {       foundSubscription.updateQuery(toType: Item.self, where: {         $0.owner_id == user.id       })     } else {       subs.append(QuerySubscription<Item>(name: \"user_tasks\") {         $0.owner_id == user.id       })     }   }, rerunOnOpen: true)   await refreshSyncedRealm(config: config) } \n``` This background task first checks that your app has a logged-in user. If so, it sets a [.flexibleSyncConfiguration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE25flexibleSyncConfiguration15clientResetMode20initialSubscriptions11rerunOnOpenAC0B0V0F0VAC06ClienthI0O%5FyAC0E15SubscriptionSetVcSbtF)with a [subscription](https://mongodb.com/docs/realm/sdk/swift/sync/flexible-sync/#std-label-swift-manage-flexible-sync-subscriptions) the app can use to sync the realm. This is the same configuration used in the Template App's `ContentView`. However, to use it here you need access to it farther up the view hierarchy. You could refactor this to a function you can call from either view that takes a [User](https://www.mongodb.com/docs/realm-sdks/swift/latest/Typealiases.html#/s:10RealmSwift4Usera) as a parameter and returns a [Realm.configuration.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html) Finally, this task awaits the result of a function that actually syncs the realm. Add this function: ```swift func refreshSyncedRealm(config: Realm.Configuration) async {   do {     try await Realm(configuration: config, downloadBeforeOpen: .always)   } catch {     print(\"Error opening the Synced realm: \\(error.localizedDescription)\")   } } \n``` By opening this synced realm and using the `downloadBeforeOpen` parameter to specify that you want to download updates, you load the fresh data into the realm in the background. Then, when your app opens again, it already has the updated data on the device. ## Important Do not try to write to the realm directly in this background task. You may encounter threading-related issues due to Realm's thread-confined architecture. ## Test Your Background Task\n\n 1 ### Configure a Device to Run Your App To test that your background task is updating the synced realm in the background, you'll need a physical device running at minimum iOS 16\\. Your device must be configured to run in [Developer Mode](https://developer.apple.com/documentation/xcode/enabling-developer-mode-on-a-device). If you get an`Untrusted Developer` notification, go to Settings,General, and VPN & Device Management. Here, you can verify that you want to run the app you're developing. Once you can successfully run your app on your device, you can test the background task. 2 ### Set a Breakpoint Start by setting a breakpoint in your `scheduleAppRefresh()` function. Set the breakpoint _after_ the line where you submit the task to`BGTaskScheduler`. For this example, you might add a `print` line and set the breakpoint at the print line: ```swift func scheduleAppRefresh() {   let backgroundTask = BGAppRefreshTaskRequest(identifier: \"refreshTodoRealm\")   backgroundTask.earliestBeginDate = .now.addingTimeInterval(10)   try? BGTaskScheduler.shared.submit(backgroundTask)   print(\"Successfully scheduled a background task\") // Set a breakpoint here } \n``` 3 ### Run the App Now, run the app on the connected device. Create or sign into an account in the app. If you're using the SwiftUI Template App, create some Items. You should see the Items sync to the `Item` collection linked to your Atlas App Services app. Then, while leaving the app running in Xcode, send the app to the background on your device. You should see the console print \"Successfully scheduled a background task\" and then get an LLDB prompt. 4 ### Add or Change Data in Atlas While the app is in the background but still running in Xcode, Insert a new document in the relevant Atlas collection that should sync to the device. Alternately, change a value of an existing document that you created from the device. After successfully running the background task, you should see this data synced to the device from the background process. If you're using the SwiftUI Template App, you can find relevant documents in your Atlas cluster's `Item` collection. For more information on how to add or change documents in Atlas, see: [MongoDB Atlas: Create, View, Update, and Delete Documents.](https://www.mongodb.com/docs/atlas/atlas-ui/documents/) 5 ### Invoke the Background Task in LLDB Use this command to manually execute the background task in LLDB: ```shell e -l objc -- (void)[[BGTaskScheduler sharedScheduler] _simulateLaunchForTaskWithIdentifier:@\"refreshTodoRealm\"] \n``` If you have used a different identifier for your background task, replace`refreshTodoRealm` with your task's identifier. This causes the task to immediately begin executing. If successful, you should see something like: ```shell 2022-11-11 15:09:10.403242-0500 App[1268:196548] Simulating launch for task with identifier refreshTodoRealm 2022-11-11 15:09:16.530201-0500 App[1268:196811] Starting simulated task \n``` After you have kicked off the task, use the Continue program executionbutton in the Xcode debug panel to resume running the app. 6 ### Turn on Airplane Mode on the Device After waiting for the background task to complete, but before you open the app again, turn on Airplane Mode on the device. Make sure you have turned off WiFi. This ensures that when you open the app again, it doesn't start a fresh Sync and you see only the values that are now in the realm on the device. 7 ### Open the App Open the app on the device. You should see the updated data that you changed in Atlas. To verify the updates came through the background task, confirm you have successfully disabled the network. Create a new task using the app. You should see the task in the app, but it should not sync to Atlas. Alternately, you could create or change data in Atlas, but should not see it reflected on the device. This tells you that the network has successfully been disabled, and the updated data that you see came through the background task.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/model-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Model Data- SwiftUI * [Realm Object Models](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/define-a-realm-object-model/)\n* [Change an Object Model](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/change-an-object-model/) ← [Realm Database with SwiftUI QuickStart](https://mongodb.com/docs/realm/sdk/swift/swiftui-tutorial/ \"Previous Section\")[Realm Object Models - SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/define-a-realm-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/pass-realm-data-between-views/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Pass Realm Data Between SwiftUI Views On this page * [Pass Realm Objects to a View](#pass-realm-objects-to-a-view)\n* [Pass Environment Values](#pass-environment-values)\n* [Inject the Partition Value](#inject-the-partition-value)\n* [Inject an Opened Realm](#inject-an-opened-realm)\n* [Inject a Realm Configuration](#inject-a-realm-configuration) The Realm Swift SDK provides several ways to pass realm data between views: * Pass Realm Database objects to a view\n* Use environment injection to:  \n   * Inject a partition value into a view  \n   * Inject an opened realm into a view  \n   * Inject a realm configuration into a view ## Pass Realm Objects to a View When you use the `@ObservedRealmObject` or `@ObservedResults` property wrapper, you implicitly open a realm and retrieve the specified objects or results. You can then pass those objects to a view further down the hierarchy.\n\n  ``` ## Pass Environment Values [Environment](https://developer.apple.com/documentation/swiftui/environment) injection is a useful tool in SwiftUI development with Realm Database. Realm Database property wrappers provide different ways for you to work with environment values when developing your SwiftUI application. ### Inject the Partition Value If you are using [Partition-Based Sync](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync), you can use environment injection to pass the `.partitionValue` environment value. Inject this into a view where you perform the `@AsyncOpen` or`@AutoOpen`: ```swift // If there is a logged in user, pass the user ID as the // partitionValue to the view that opens a realm. OpenPartitionBasedSyncRealmView().environment(\\.partitionValue, user.id) \n``` Then, when you use the property wrapper to open a synced realm, leave the `partitionValue` an empty string. The property wrapper populates the value from the environment object passed in from above. ```swift // We can use an empty string as the partitionValue here because we're // injecting the user.id as an environment value from the LoginView. @AutoOpen(appId: YOUR_APP_SERVICES_APP_ID_HERE, partitionValue: \"\", timeout: 4000) var autoOpen \n``` ### Inject an Opened Realm You can inject a realm that you opened in another SwiftUI view into a view as an environment value. The property wrapper uses this passed-in realm to populate the view: ```swift ListView()    .environment(\\.realm, realm) \n``` ### Inject a Realm Configuration You can use a realm other than the default realm by passing a different configuration in an environment object. ```swift LocalOnlyContentView() .environment(\\.realmConfiguration, Realm.Configuration( /* ... */ )) \n``` ← [React to Changes - SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/react-to-changes/ \"Previous Section\")[Write Data - SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/write/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Object Models - Swift SDK On this page * [Key Concept: Object Types & Schemas](#key-concept--object-types---schemas)\n* [Realm Schema](#realm-schema)\n* [Model Inheritance](#model-inheritance)\n* [Swift Structs](#swift-structs)\n* [Key Concept: Properties](#key-concept--properties)\n* [Key Concept: View Models with Realm](#key-concept--view-models-with-realm)\n* [Define a New Object Type](#define-a-new-object-type)\n* [Declare Properties](#declare-properties)\n* [Persisted Property Attributes](#persisted-property-attributes)\n* [Objective-C Dynamic Property Attributes](#objective-c-dynamic-property-attributes)\n* [Specify an Optional/Required Property](#specify-an-optional-required-property)\n* [Specify a Primary Key](#specify-a-primary-key)\n* [Index a Property](#index-a-property)\n* [Ignore a Property](#ignore-a-property)\n* [Declare Enum Properties](#declare-enum-properties)\n* [Remap a Property Name](#remap-a-property-name)\n* [Define a Class Projection](#define-a-class-projection)\n* [About These Examples](#about-these-examples)\n* [How to Define a Class Projection](#how-to-define-a-class-projection)\n* [Define an Asymmetric Object](#define-an-asymmetric-object) ## Key Concept: Object Types & Schemas Realm Database applications model data as objects composed of field-value pairs that each contain one or more [supported](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-supported-property-types) data types. Realm objects are regular Swift or Objective-C classes, but they also bring a few additional features like [live queries](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-live-queries). The Swift SDK memory maps Realm objects directly to native Swift or Objective-C objects, which means there's no need to use a special data access library, such as an [ORM](https://en.wikipedia.org/wiki/Object-relational%5Fmapping). Instead, you can work with Realm objects as you would any other class instance. Every Realm object conforms to a specific **object type**, which is essentially a class that defines the [properties](#std-label-ios-client-properties)and [relationships](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-client-relationships) for objects of that type. Realm guarantees that all objects in a realm conform to the schema for their object type and validates objects whenever they're created, modified, or deleted. ## Example The following schema defines a `Dog` object type with a string name, optional string breed, date of birth, and primary key ID. ### Realm Schema A **realm schema** is a list of valid [object schemas](#std-label-ios-object-schemas) that a realm may contain. Every Realm object must conform to an object type that's included in its realm's schema. By default, the Swift SDK automatically adds all classes in your project that derive from [RLMObject](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMObject.html) or[RLMEmbeddedObject](https://www.mongodb.com/docs/realm-sdks/objc/latest/Classes/RLMEmbeddedObject.html) to the realm schema. ## Tip ### Configure Your Realm Schema To control which classes Realm adds to a realm schema, see[Provide a Subset of Classes to a Realm.](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-provide-a-subset-of-classes-to-a-realm)\n\n ## Tip ### Learn How to Work With a Realm For code examples that show how to configure and open a realm in the Swift SDK, see [Configure & Open a Realm - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-configure-and-open-a-realm) ### Model Inheritance You can subclass Realm Database models to share behavior between classes, but there are limitations. In particular, Realm does not allow you to: * Cast between polymorphic classes: subclass to subclass, subclass to parent, parent to subclass\n* Query on multiple classes simultaneously: for example, \"get all instances of parent class and subclass\"\n* Multi-class containers: `List` and `Results` with a mixture of parent and subclass ## Tip Check out the [code samples](https://github.com/realm/realm-swift/issues/1109#issuecomment-143834756) for working around these limitations. _New in version 10.10.0_: While you can't mix `@Persisted` and `@objc dynamic` property declarations within a class, you can mix the notation styles across base and subclasses. For example, a base class could have a `@Persisted var foo: Int` property, and a subclass could have an `@objc dynamic var bar = 0` property, with both persisted. However, the `@objc dynamic` property would be ignored if the `@Persisted` property were within the same base or subclass. ### Swift Structs Realm Database does not support Swift structs as models for a variety of reasons. Realm's design focuses on \"live\" objects. This concept is not compatible with value type structs. By design, Realm provides features that are incompatible with these semantics, such as: * [Live data](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-live-object)\n* [Reactive APIs](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes)\n* Low memory footprint of data\n* Good operation performance\n* [Lazy and cheap access to partial data](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-live-queries)\n* Lack of data serialization/deserialization\n* [Keeping potentially complex object graphs synchronized](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/#std-label-ios-sync-changes-between-devices) That said, it is sometimes useful to detach objects from their backing realm. This typically isn't an ideal design decision. Instead, developers use this as a workaround for temporary limitations in our library. You can use key-value coding to initialize an unmanaged object as a copy of a managed object. Then, you can work with that unmanaged object like any other [NSObject.](https://developer.apple.com/documentation/objectivec/nsobject) `| let standaloneModelObject = MyModel(value: persistedModelObject) |\n| ---------------------------------------------------------------- | ` ## Key Concept: Properties Your Realm object model is a collection of properties. On the most basic level, when you create your model, your declarations give Realm information about each property: * The data type and whether the property is optional or required\n* Whether Realm should store or ignore the property\n* Whether the property is a primary key or should be indexed Properties are also the mechanism for establishing [relationships](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-swift-client-relationships) between Realm object types. ## Key Concept: View Models with Realm _New in version 10.21.0_. You can work with a subset of your Realm Database object's properties by creating a class projection. A class projection is a class that passes through or transforms some or all of your Realm Database object's properties. Class projection enables you to build view models that use an abstraction of your object model. This simplifies using and [testing](https://mongodb.com/docs/realm/sdk/swift/test-and-debug/#std-label-ios-simplify-testing-with-class-projections) Realm Database objects in your application. With class projection, you can use a subset of your object's properties directly in the UI or transform them. When you use a class projection for this, you get all the benefits of Realm Database's live objects:\n\n ## Tip ### See also:  [Define a Class Projection](#std-label-ios-define-and-use-class-projections) ## Define a New Object Type ## Note Class names are limited to a maximum of 57 UTF-8 characters. ## Declare Properties When you declare the property attributes of a class, you can specify whether or not those properties should be managed by the realm. **Managed properties**are stored or updated in the database. **Ignored properties** are not stored to the database. You can mix managed and ignored properties within a class. The syntax to mark properties as managed or ignored varies depending on which version of the SDK you use. ### Persisted Property Attributes _New in version 10.10.0_: The `@Persisted` declaration style replaces the `@objc dynamic`,`RealmOptional`, and `RealmProperty` declaration notations from older versions of the SDK. For an older version of the SDK, see:[Objective-C Dynamic Property Attributes](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-objc-dynamic-property-attributes). Declare model properties that you want to store to the database as`@Persisted`. This enables them to access the underlying database data. When you declare any properties as `@Persisted` within a class, the other properties within that class are automatically ignored. If you mix `@Persisted` and `@objc dynamic` property declarations within a class definition, any property attributes marked as `@objc dynamic` will be ignored. ## Tip ### See also:  Our [Supported Property Types](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-supported-property-types)page contains a property declaration cheatsheet. ### Objective-C Dynamic Property Attributes _Changed in version 10.10.0_: This property declaration information is for versions of the SDK before 10.10.0. Declare dynamic Realm model properties in the Objective-C runtime. This enables them to access the underlying database data. You can either: * Use `@objc dynamic var` to declare individual properties\n* Use `@objcMembers` to declare a class. Then, declare individual properties with `dynamic var`. Use `let` to declare `LinkingObjects`, `List`, `RealmOptional` and`RealmProperty`. The Objective-C runtime cannot represent these generic properties. _Changed in version 10.8.0_: `RealmProperty` replaces `RealmOptional` ## Tip ### See also:  Our [Supported Property Types](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-supported-property-types)page contains a property declaration cheatsheet. ## Tip For reference on which types Realm Database supports for use as properties, see [Supported Property Types.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-supported-property-types) ## Note Property names are limited to a maximum of 63 UTF-8 characters. ### Specify an Optional/Required Property ### Specify a Primary Key You can designate a property as the **primary key** of your class. Primary keys allow you to efficiently [find](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-ios-find-a-specific-object-by-primary-key), update, and [upsert](https://mongodb.com/docs/realm/sdk/swift/crud/update/#std-label-ios-upsert-an-object) objects. Primary keys are subject to the following limitations: * You can define only one primary key per object model.\n* Primary key values must be unique across all instances of an object in a realm. Realm Database throws an error if you try to insert a duplicate primary key value.\n* Primary key values are immutable. To change the primary key value of an object, you must delete the original object and insert a new object with a different primary key value.\n* [Embedded objects](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-embedded-objects) cannot define a primary key. ### Index a Property\n\n Realm supports indexing for string, integer, boolean, `Date`, `UUID`,`ObjectId`, and `AnyRealmValue` properties. _New in version 10.8.0_: `UUID` and `AnyRealmValue` types ### Ignore a Property Ignored properties behave exactly like normal properties. They can't be used in queries and won't trigger Realm notifications. You can still observe them using [KVO.](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html) ## Tip Realm automatically ignores read-only properties. ### Declare Enum Properties ### Remap a Property Name _New in version 10.33.0_. You can map the public name of a property in your object model to a different private name to store in the realm. You might want to do this if your Device Sync schema property names use snake case, for example, while your project uses Swift-idiomatic camel case. Declare the name you want to use in your project as the `@Persisted`property on the object model. Then, pass a dictionary containing the public and private values for the property names via the`propertiesMapping()` function. In this example, `firstName` is the public property name we use in the code throughout the project to perform CRUD operations. Using the `propertiesMapping()`function, we map that to store values using the private property name`first_name` in the realm. If we write to a synced realm, the Sync schema sees the values stored using the private property name `first_name`. ```swift class Person: Object {     @Persisted var firstName = \"\"     @Persisted var lastName = \"\"         override class public func propertiesMapping() -> [String: String] {         [\"firstName\": \"first_name\",          \"lastName\": \"last_name\"]     } } \n``` ## Define a Class Projection ### About These Examples The examples in this section use a simple data set. The two Realm object types are `Person` and an embedded object `Address`. A `Person` has a first and last name, an optional `Address`, and a list of friends consisting of other `Person` objects. An `Address` has a city and country. See the schema for these two classes, `Person` and `Address`, below: ```swift class Person: Object {     @Persisted var firstName = \"\"     @Persisted var lastName = \"\"     @Persisted var address: Address?     @Persisted var friends = List<Person>() } class Address: EmbeddedObject {     @Persisted var city: String = \"\"     @Persisted var country = \"\" } \n``` ### How to Define a Class Projection _New in version 10.21.0_. Define a class projection by creating a class of type [Projection](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/Projection.html). Specify the [Object](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/Object.html)or [EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/EmbeddedObject.html) base whose properties you want to use in the class projection. Use the `@Projected`property wrapper to declare a property that you want to project from a`@Persisted` property on the base object. ## Note When you use a [List](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-list-collections) or a [MutableSet](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-mutableset-data-type) in a class projection, the type in the class projection should be [ProjectedCollection.](https://www.mongodb.com/docs/realm-sdks/swift/latest/) ```swift class PersonProjection: Projection<Person> {     @Projected(\\Person.firstName) var firstName // Passthrough from original object\n\n     @Projected(\\Person.friends.projectTo.firstName) var firstFriendsName: ProjectedCollection<String> // Collection mapping } \n``` When you define a class projection, you can transform the original `@Persisted`property in several ways: * Passthrough: the property is the same name and type as the original object\n* Rename: the property has the same type as the original object, but a different name\n* Keypath resolution: use keypath resolution to access properties of the original object, including embedded object properties\n* Collection mapping: Project [lists](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-list-collections) or[mutable sets](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-mutableset-data-type) of `Object` s or`EmbeddedObject` s as a collection of primitive values\n* Exclusion: when you use a class projection, the underlying object's properties that are not `@Projected` through the class projection are excluded. This enables you to watch for changes to a class projection and not see changes for properties that are not part of the class projection. ## Define an Asymmetric Object _New in version 10.29.0_. If your app uses Flexible Sync, you can use [Asymmetric Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) to sync an object unidirectionally from your device to the database linked to your Atlas App Services App. Define an asymmetric object by inheriting from [AsymmetricObject.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/AsymmetricObject.html) ```swift class WeatherSensor: AsymmetricObject {     @Persisted(primaryKey: true) var _id: ObjectId     @Persisted var deviceId: String     @Persisted var temperatureInFahrenheit: Float     @Persisted var barometricPressureInHg: Float     @Persisted var windSpeedInMph: Int } \n``` `AsymmetricObjects` broadly support the same property types as `Object`, with a few exceptions: * Asymmetric objects can only link to embedded objects  \n   * `Object` and `List<Object>` properties are not supported  \n   * `EmbeddedObject` and `List<EmbeddedObject>` are supported You cannot link to an `AsymmetricObject` from within an `Object`. Doing so throws an error. Asymmetric objects do not function in the same way as other Realm Objects. You cannot: * Add an asymmetric object to a realm\n* Remove an asymmetric object from a realm\n* Query an asymmetric object You can only create an Asymmetric object, which then syncs unidirectionally to the Atlas database linked to your App with Device Sync. For more information, see: [Create an Asymmetric Object.](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-swift-create-asymmetric-object) ← [Define a Realm Object Schema - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/define-a-realm-object-model/ \"Previous Section\")[Model Relationships - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/swiftui-previews/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Use Realm with SwiftUI Previews On this page * [Overview](#overview)\n* [Initialize an Object for a Detail View](#initialize-an-object-for-a-detail-view)\n* [Conditionally Use ObservedResults in a List View](#conditionally-use-observedresults-in-a-list-view)\n* [Create a Realm with Data for Previews](#create-a-realm-with-data-for-previews)\n* [Use an In-Memory Realm](#use-an-in-memory-realm)\n* [Delete SwiftUI Previews](#delete-swiftui-previews)\n* [Get Detailed Information about SwiftUI Preview Crashes](#get-detailed-information-about-swiftui-preview-crashes)\n* [Use a Synced Realm in Previews](#use-a-synced-realm-in-previews) ## Overview SwiftUI Previews are a useful tool during development. You can work with Realm data in SwiftUI Previews in a few ways: * Initialize individual objects to use in detail views\n* Conditionally use an array of objects in place of `@ObservedResults`\n* Create a realm that contains data for the previews SwiftUI Preview debugging can be opaque, so we also have a few tips to debug issue with persisting Realms within SwiftUI Previews. ### Initialize an Object for a Detail View In the simplest case, you can use SwiftUI Previews with one or more objects that use Realm properties you can set directly at initialization. You might want to do this when previewing a Detail view. Consider DoggoDB's`DogDetailView`:\n\n ` Create an extension for your model object. Where you put this extension depends on convention in your codebase. You may put it directly in the model file, have a dedicated directory for sample data, or use some other convention in your codebase. In this extension, initialize one or more Realm objects with `static let`: ```swift extension Dog {     static let dog1 = Dog(value: [\"name\": \"Lita\", \"breed\": \"Lab mix\", \"weight\": 27, \"favoriteToy\": \"Squeaky duck\", \"profileImageUrl\": \"https://www.corporaterunaways.com/images/2021/04/lita-768x768.jpeg\"])     static let dog2 = Dog(value: [\"name\": \"Maui\", \"breed\": \"English Springer Spaniel\", \"weight\": 42, \"favoriteToy\": \"Wubba\", \"profileImageUrl\": \"https://www.corporaterunaways.com/images/2021/04/maui_with_leaf-768x576.jpeg\"])     static let dog3 = Dog(value: [\"name\": \"Ben\", \"breed\": \"Border Collie mix\", \"weight\": 48, \"favoriteToy\": \"Frisbee\", \"profileImageUrl\": \"https://www.corporaterunaways.com/images/2012/03/ben-630x420.jpg\"])     } \n``` In this example, we [initialize objects with a value](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-initialize-an-object-with-a-value). You can only initialize objects with a value when your model contains properties that you can directly initialize. If your model object contains properties that are only mutable within a write transaction, such as a [List property](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-list-collections), you must instead [create a realm to use with your SwiftUI Previews.](#std-label-swift-create-a-realm-with-data) After you have initialized an object as an extension of your model class, you can use it in your SwiftUI Preview. You can pass the object directly to the View in the Preview: ```swift struct DogDetailView_Previews: PreviewProvider {     static var previews: some View {         NavigationView {             DogDetailView(dog: Dog.dog1)         }     } } \n``` ### Conditionally Use ObservedResults in a List View When you use [@ObservedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedResults.html)in a List view, this implicitly opens a realm and queries it. For this to work in a Preview, you need [a realm populated with data](#std-label-swift-create-a-realm-with-data). As an alternative, you can conditionally use a static array in Previews and only use the `@ObservedResults` variable when running the app. You could do this in multiple ways, but for the sake of making our code easier to read and understand, we'll create an `EnvironmentValue`that can detect whether the app is running in a Preview: ```swift import Foundation import SwiftUI public extension EnvironmentValues {    var isPreview: Bool {       #if DEBUG       return ProcessInfo.processInfo.environment[\"XCODE_RUNNING_FOR_PREVIEWS\"] == \"1\"       #else       return false       #endif    } } \n``` Then, we can use this as an environment value in our view, and conditionally change which variable we use based on whether or not we are in a Preview. This example builds on the [Dog extension we defined above](#std-label-swift-use-objects-in-a-detail-view). We'll create an `dogArray` as a `static let` in our Dog extension, and include the item objects we already created: ```swift static let dogArray = [dog1, dog2, dog3] \n```\n\n ```swift struct DogsView: View {    @Environment(\\.isPreview) var isPreview    @ObservedResults(Dog.self) var dogs    var previewDogs = Dog.dogArray    var body: some View {       NavigationView {          VStack {             List {                if isPreview {                   ForEach(previewDogs) { dog in                      DogRow(dog: dog)                   }                } else {                   ForEach(dogs) { dog in                      DogRow(dog: dog)                   }.onDelete(perform: $dogs.remove)                }             }             ... More View code \n``` This has the benefit of being lightweight and not persisting any data, but the downside of making the View code more verbose. If you prefer cleaner View code, you can create a realm with data that you use in the Previews. ### Create a Realm with Data for Previews In some cases, your only option to see realm data in a SwiftUI Preview is to create a realm that contains the data. You might do this when populating a property that can only be populated during a write transaction, rather than initialized directly with a value, such as a [List](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-list-collections) or [MutableSet](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-mutableset-data-type). You might also want to do this if your view relies on more complex object hierarchies being passed in from other views. However, using a realm directly does inject state into your SwiftUI Previews, which can come with drawbacks. Whether you're using Realm or Core Data, stateful SwiftUI Previews can cause issues like: * Seeing unexpected or duplicated data due to re-running the realm file creation steps repeatedly\n* Needing to perform a migration within the SwiftUI Preview when you make model changes\n* Potential issues related to changing state within views\n* Unexplained crashes or performance issues related to issues that are not surfaced in a visible way in SwiftUI Previews You can avoid or fix some of these issues with these tips: * [Use an in-memory realm, when possible (demonstrated in the example above)](#std-label-swiftui-preview-use-in-memory-realm)\n* [Manually delete all preview data from the command line to reset state](#std-label-swiftui-preview-delete-realm-from-preview)\n* [Check out diagnostic logs to try to troubleshoot SwiftUI Preview issues](#std-label-swiftui-preview-diagnose-crashes) You can create a static variable for your realm in your model extension. This is where you do the work to populate your realm. In our case, we create a `Person` and append some `Dog` objects to the `dogs`List property. This example builds on the example above where we [initialized a few Dog objects in an Dog extension.](#std-label-swift-use-objects-in-a-detail-view) We'll create a `Person` extension, and create a single `Person` object in that extension. Then, we'll create a `previewRealm` by adding the`Person` we just created, and appending the example `Dog` objects from the `Dog` extension. To avoid adding these objects more than once, we add a check to see if the Person already exists by querying for Person objects and checking that the count is 1\\. If the realm contains a Person, we can use it in our SwiftUI Preview. If not, we add the data. ```swift\n\n     var realm: Realm     let identifier = \"previewRealm\"     let config = Realm.Configuration(inMemoryIdentifier: identifier)     do {         realm = try Realm(configuration: config)         // Check to see whether the in-memory realm already contains a Person.         // If it does, we'll just return the existing realm.         // If it doesn't, we'll add a Person append the Dogs.         let realmObjects = realm.objects(Person.self)         if realmObjects.count == 1 {             return realm         } else {             try realm.write {                 realm.add(person)                 person.dogs.append(objectsIn: [Dog.dog1, Dog.dog2, Dog.dog3])             }             return realm         }     } catch let error {         fatalError(\"Can't bootstrap item data: \\(error.localizedDescription)\")     } } \n``` To use it in the SwiftUI Preview, our ProfileView code expects a Profile. This is a [projection of the Person object](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/define-a-realm-object-model/#std-label-swiftui-projection). In our Preview, we can get the realm, query it for the Profile, and pass it to the view: ```swift struct ProfileView_Previews: PreviewProvider {     static var previews: some View {         let realm = Person.previewRealm         let profile = realm.objects(Profile.self)         ProfileView(profile: profile.first!)     } } \n``` If you don't have a View that is expecting a realm object to be passed in, but instead uses `@ObservedResults` to query a realm or otherwise work with an existing realm, you can [inject the realm into the view as an environment value:](https://mongodb.com/docs/realm/sdk/swift/swiftui/pass-realm-data-between-views/#std-label-inject-realm-as-environment-value) ```swift struct SomeListView_Previews: PreviewProvider {    static var previews: some View {       SomeListView()          .environment(\\.realm, Person.previewRealm)    } } \n``` #### Use an In-Memory Realm When possible, use an [in-memory realm](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-open-an-in-memory-realm)to get around some of the state-related issues that can come from using a database within a SwiftUI Preview. Use the [inMemoryIdentifier](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV18inMemoryIdentifierSSSgvp)configuration property when you initialize the realm. ```swift static var previewRealm: Realm {    var realm: Realm    let identifier = \"previewRealm\"    let config = Realm.Configuration(inMemoryIdentifier: identifier)    do {       realm = try Realm(configuration: config)       // ... Add data to realm \n``` ## Note\n\n #### Delete SwiftUI Previews If you run into other SwiftUI Preview issues related to state, such as a failure to load a realm in a Preview due to migration being required, there are a few things you can do to remove cached Preview data. The Apple-recommended fix is to close Xcode and use the command line to delete all your existing SwiftUI Preview data. 1. Close Xcode.\n2. From your command line, run:  \n```shell  \nxcrun simctl --set previews delete all  \n``` It's possible that data may persist after running this command. This is likely due to Xcode retaining a reference due to something in the Preview and being unable to delete it. You can also try these steps to resolve issues: * Build for a different simulator\n* Restart the computer and re-run `xcrun simctl --set previews delete all`\n* Delete stored Preview data directly. This data is stored in`~/Library/Developer/Xcode/UserData/Previews`. #### Get Detailed Information about SwiftUI Preview Crashes If you have an unexplained SwiftUI Preview crash when using realm, first try running the application on the simulator. The error messaging and logs available for the simulator make it easier to find and diagnose issues. If you can debug the issue in the simulator, this is the easiest route. If you cannot replicate a SwiftUI Preview crash in the simulator, you can view crash logs for the SwiftUI Preview app. These logs are available in`~/Library/Logs/DiagnosticReports/`. These logs sometimes appear after a delay, so wait a few minutes after a crash if you don't see the relevant log immediately. ### Use a Synced Realm in Previews If your app uses Atlas Device Sync, you may wonder how to use a synced realm in your SwiftUI Previews. A better practice is to use static objects or a local realm that you populate with data for your SwiftUI Previews. In our example app, we can preview a view _associated_ with Device Sync - the LoginView - without needing to use a realm at all: ```swift struct LoginView_Previews: PreviewProvider {     static var previews: some View {         LoginView()     } } \n``` Since we're only viewing the static UI, we don't need to worry about the SyncContentView that contains the logic of whether to show the LoginView or go to the OpenSyncedRealmView. We can also skip previewing the OpenSyncedRealmView, because that just handles logic associated with opening a synced realm and populating it for the DogsView. So the next view we want to see in a Preview is the DogsView. Fortunately, with Realm, the code to work with the realm doesn't care whether the realm uses Device Sync or not - you work with the realm in the same way. So we can use the same local realm that we [created in the example above](#std-label-swift-create-a-realm-with-data) in the SwiftUI Preview. ```swift struct DogsView_Previews: PreviewProvider {     static var previews: some View {         let realm = Person.previewRealm         DogsView()             .environment(\\.realm, realm)     } } \n``` ← [Sync Data in the Background with SwiftUI - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/swiftui/background-sync/ \"Previous Section\")[Swift Concurrency - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/swift-concurrency/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - SwiftUI On this page * [Observe an Object](#observe-an-object)\n* [Observe Query Results](#observe-query-results)\n* [Sort Observed Results](#sort-observed-results)\n* [Observe Sectioned Results](#observe-sectioned-results)\n* [Observe App State](#observe-app-state) ## Observe an Object The Swift SDK provides the [@ObservedRealmObject](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedRealmObject.html) property wrapper that invalidates a view when an observed object changes. You can use this property wrapper to create a view that automatically updates itself when the observed object changes. `| struct DogDetailView: View {                    |\n| ----------------------------------------------- |\n| @ObservedRealmObject var dog: Dog               |\n|                                                 |\n| var body: some View {                           |\n| VStack {                                        |\n| Text(dog.name)                                  |\n| .font(.title2)                                  |\n| Text(\"\\(dog.name) is a \\(dog.breed)\")           |\n| AsyncImage(url: dog.profileImageUrl) { image in |\n| image.resizable()                               |\n| } placeholder: {                                |\n| ProgressView()                                  |\n| }                                               |\n| .aspectRatio(contentMode: .fit)                 |\n| .frame(width: 150, height: 150)                 |\n| Text(\"Favorite toy: \\(dog.favoriteToy)\")        |\n| }                                               |\n| }                                               |\n| }                                               | ` ## Observe Query Results\n\n ## Note The `@ObservedResults` property wrapper is intended for use in a SwiftUI View. If you want to observe results in a view model, [register a change listener.](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes) ```swift struct DogsView: View {     @ObservedResults(Dog.self) var dogs     /// The button to be displayed on the top left.     var leadingBarButton: AnyView?     var body: some View {         NavigationView {             VStack {                 // The list shows the dogs in the realm.                 // The ``@ObservedResults`` above implicitly opens a realm and retrieves                 // all the Dog objects. We can then pass those objects to views further down the                 // hierarchy.                 List {                     ForEach(dogs) { dog in                         DogRow(dog: dog)                     }.onDelete(perform: $dogs.remove)                 }.listStyle(GroupedListStyle())                     .navigationBarTitle(\"Dogs\", displayMode: .large)                     .navigationBarBackButtonHidden(true)                     .navigationBarItems(                         leading: self.leadingBarButton,                         // Edit button on the right to enable rearranging items                         trailing: EditButton())             }.padding()         }     } } \n``` ## Tip ### See also:  For more information about the query syntax and types of queries that Realm supports, see: [Read - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-swift-crud-read) and [Filter Data - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-filter-data) ### Sort Observed Results The [@ObservedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedResults.html)property wrapper can take a [SortDescriptor](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SortDescriptor.html) parameter to sort the query results. ```swift struct SortedDogsView: View {     @ObservedResults(Dog.self,                      sortDescriptor: SortDescriptor(keyPath: \"name\",                         ascending: true)) var dogs         var body: some View {         NavigationView {             // The list shows the dogs in the realm, sorted by name             List(dogs) { dog in                 DogRow(dog: dog)             }         }     } } \n``` ## Tip\n\n ### Observe Sectioned Results _New in version 10.29.0_. You can observe a results set that is divided into sections by a key generated from a property on the object. We've added a computed variable to the model that we don't persist; we just use this to section the results set. ```swift var firstLetter: String {     guard let char = name.first else {         return \"\"     }     return String(char) } \n``` Then, we can use the [@ObservedSectionedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedSectionedResults.html) property wrapper to observe the results set divided into sections based on the computed variable key. ```swift @ObservedSectionedResults(Dog.self,                           sectionKeyPath: \\.firstLetter) var dogs \n``` You might use these observed sectioned results to populate a List view divided by sections: ```swift struct SectionedDogsView: View {     @ObservedSectionedResults(Dog.self,                               sectionKeyPath: \\.firstLetter) var dogs     /// The button to be displayed on the top left.     var leadingBarButton: AnyView?     var body: some View {         NavigationView {             VStack {                 // The list shows the dogs in the realm, split into sections according to the keypath.                 List {                     ForEach(dogs) { section in                         Section(header: Text(section.key)) {                             ForEach(section) { dog in                                 DogRow(dog: dog)                             }                         }                     }                 }                 .listStyle(GroupedListStyle())                     .navigationBarTitle(\"Dogs\", displayMode: .large)                     .navigationBarBackButtonHidden(true)                     .navigationBarItems(                         leading: self.leadingBarButton,                         // Edit button on the right to enable rearranging items                         trailing: EditButton())             }.padding()         }     } } \n``` ## Observe App State If your app uses Atlas Device Sync, you can observe the [App](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/App.html) object to react to login state changes. This enables your app to perform operations while it has an `app.currentUser`, or direct the user to log in if there is no `app.currentUser`. Because Realm caches user credentials on the device, your app can work offline while it has an `app.currentUser`.\n\n /// This view observes the Realm app object. /// Either direct the user to login, or open a realm /// with a logged-in user. struct FlexibleSyncContentView: View {     // Observe the Realm app object in order to react to login state changes.     @ObservedObject var app: RealmSwift.App     var body: some View {         if let user = app.currentUser {             // Create a `flexibleSyncConfiguration` with `initialSubscriptions`.             // We'll inject this configuration as an environment value to use when opening the realm             // in the next view, and the realm will open with these initial subscriptions.             let config = user.flexibleSyncConfiguration(initialSubscriptions: { subs in                 let peopleSubscriptionExists = subs.first(named: \"people\")                 let dogSubscriptionExists = subs.first(named: \"dogs\")                 // Check whether the subscription already exists. Adding it more                 // than once causes an error.                 if (peopleSubscriptionExists != nil) && (dogSubscriptionExists != nil) {                     // Existing subscriptions found - do nothing                     return                 } else {                     // Add queries for any objects you want to use in the app                     // Linked objects do not automatically get queried, so you                     // must explicitly query for all linked objects you want to include.                     subs.append(QuerySubscription<Person>(name: \"people\"))                     subs.append(QuerySubscription<Dog>(name: \"dogs\"))                 }             })             OpenFlexibleSyncRealmView()                 .environment(\\.realmConfiguration, config)         } else {             // If there is no user logged in, show the login view.             LoginView()         }     } } \n``` ← [Configure and Open a Realm - SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/configure-and-open-realm/ \"Previous Section\")[Pass Realm Data Between SwiftUI Views](https://mongodb.com/docs/realm/sdk/swift/swiftui/pass-realm-data-between-views/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/configure-and-open-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Configure and Open a Realm - SwiftUI On this page * [Open a Realm with a Configuration](#open-a-realm-with-a-configuration)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Download Changes Before Opening a Synced Realm](#download-changes-before-opening-a-synced-realm)\n* [Open a Synced Realm Offline](#open-a-synced-realm-offline) The Swift SDK provides property wrappers to open a realm in a SwiftUI-friendly way. You can: * [Implicitly open a realm](#std-label-ios-open-realm-with-configuration-swiftui)with a `defaultConfiguration` or specify a different configuration. This works for both non-synced and synced realms.\n* [Always download changes before opening a synced realm](#std-label-swiftui-async-open-synced-realm), which times out when the user is offline.\n* [Open a synced realm even when a user is offline](#std-label-swiftui-auto-open-synced-realm). The realm may lack the most recent data. ## Open a Realm with a Configuration When you use [@ObservedRealmObject](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedRealmObject.html)or [@ObservedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedResults.html), these property wrappers implicitly open a realm and retrieve the specified objects or results. `| // Implicitly use the default realm's objects(Dog.self) |\n| ------------------------------------------------------- |\n| @ObservedResults(Dog.self) var dogs                     | ` ## Note The `@ObservedResults` property wrapper is intended for use in a SwiftUI View. If you want to observe results in a view model, [register a change listener.](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes) When you do not specify a configuration, these property wrappers use the[defaultConfiguration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV07defaultC0AEvpZ). You can [set the defaultConfiguration](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-default-and-file-url-realm)globally, and property wrappers across the app can use that configuration when they implicitly open a realm. You can provide alternative configurations that the property wrappers use to implicitly open the realm. You might want to do this when using multiple configurations in your app, as in cases where you have both a [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SyncConfiguration.html) and a local [Configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html). To do this, [create explicit configurations](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-configure-and-open-a-realm). Then, [use environment injection to pass the respective configurations to the views that need them](https://mongodb.com/docs/realm/sdk/swift/swiftui/pass-realm-data-between-views/#std-label-ios-swiftui-inject-realm-configuration). Passing a configuration to a view where property wrappers open a realm uses the passed configuration instead of the `defaultConfiguration`. ## Open a Synced Realm _New in version 10.12.0_. These SwiftUI property wrappers open synced realms and populate views. The main difference between these property wrappers is whether the user must be online:\n\n ### Download Changes Before Opening a Synced Realm Use the [@AsyncOpen](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AsyncOpen.html) property wrapper for apps that require up-to-date information from the server, such as game apps with live leaderboards that the user can play on multiple devices. This ensures the user is never using the app with stale data. This SwiftUI property wrapper initiates `Realm.asyncOpen()` for the current user. The property wrapper publishes states, represented by the [AsyncOpenState enum](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/AsyncOpenState.html#/s:10RealmSwift14AsyncOpenStateO5erroryACs5Error%5FpcACmF), which you can use to update the view. ## Example This example illustrates one way you might use `@AsyncOpen` to open a realm in a view. First, check for a user, or log them in. Then, attempt to open the realm, switching on the `AsyncOpenState`to display an appropriate view. When the realm opens successfully, inject it as an environment value to populate the view. ### Open a Synced Realm Offline Like `@AsyncOpen`, [@AutoOpen](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AutoOpen.html) attempts to download updates before opening the realm. However, if a network connection is not available, this method instead opens a realm with data on the device. Use this property wrapper for apps where it's not a problem for the user to work with potentially stale data, such as note-taking apps where users should be able to work with data on the device This SwiftUI property wrapper attempts to download updates before opening a realm for the current user. If there is no internet connection, this property wrapper instead returns the most up-to-date version of the local realm file for the given `appId` and Flexible Sync or Partition-Based Sync configuration. The property wrapper publishes states, represented by the [AsyncOpenState enum](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/AsyncOpenState.html#/s:10RealmSwift14AsyncOpenStateO5erroryACs5Error%5FpcACmF), which you can use to update the view. For a full example, see the `@AsyncOpen`code examples above. ← [Change an Object Model - SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/change-an-object-model/ \"Previous Section\")[React to Changes - SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/react-to-changes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/model-data/change-an-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Change an Object Model - SwiftUI On this page * [Overview](#overview)\n* [Use Migrated Data with SwiftUI](#use-migrated-data-with-swiftui)\n* [Set a Default Configuration](#set-a-default-configuration)\n* [Pass the Configuration Object as an Environment Object](#pass-the-configuration-object-as-an-environment-object)\n* [Explicitly Pass the Updated Configuration to a Realm SwiftUI Property Wrapper](#explicitly-pass-the-updated-configuration-to-a-realm-swiftui-property-wrapper) ## Note ### Modify Schema Properties of a Synced Realm The following page demonstrates how to modify schema properties of a local realm. Learn how to [modify schema properties of a synced realm.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) ## Overview When you update your object schema, you must increment the schema version and perform a migration. You might update your object schema between major version releases of your app. For information on how to actually perform the migration, see:[Change an Object Model.](https://mongodb.com/docs/realm/sdk/swift/model-data/change-an-object-model/#std-label-ios-modify-an-object-schema) This page focuses on how to use migrated data in SwiftUI Views. ## Use Migrated Data with SwiftUI To perform a migration: * Update your schema and write a migration block, if required\n* Specify a [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html)that uses this migration logic and/or updated schema version when you initialize your realm. From here, you have a few options to pass the configuration object. You can: * Set the configuration as the [default configuration](https://mongodb.com/docs/realm/sdk/swift/realm-files/configure-and-open-a-realm/#std-label-ios-default-and-file-url-realm). If you do not explicitly pass the configuration via environment injection or as a parameter, property wrappers use the default configuration.\n* Use environment injection to provide this configuration to the first view in your hierarchy that uses Realm\n* Explicitly provide the configuration to a Realm property wrapper that takes a configuration object, such as `@ObservedResults` or `@AsyncOpen`. ## Example For example, you might want to add a property to an existing object. We could add a `favoriteTreat` property to the `Dog` object in DoggoDB: `| @Persisted var favoriteTreat = \"\" |\n| --------------------------------- | ` After you add your new property to the schema, you must increment the schema version. Your `Realm.Configuration` might look like this: ```swift let config = Realm.Configuration(schemaVersion: 2) \n``` Declare this configuration somewhere that is accessible to the first view in the hierarchy that needs it. Declaring this above your `@main` app entrypoint makes it available everywhere, but you could also put it in the file where you first open a realm. ### Set a Default Configuration You can set a default configuration in a SwiftUI app the same as any other Realm Swift app. Set the default realm configuration by assigning a new Realm.Configuration instance to the [Realm.Configuration.defaultConfiguration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html#/s:10RealmSwift0A0V13ConfigurationV07defaultC0AEvpZ)class property. ```swift // Open the default realm let defaultRealm = try! Realm() // Open the realm with a specific file URL, for example a username let username = \"GordonCole\" var config = Realm.Configuration.defaultConfiguration config.fileURL!.deleteLastPathComponent() config.fileURL!.appendPathComponent(username) config.fileURL!.appendPathExtension(\"realm\") let realm = try! Realm(configuration: config) \n``` ### Pass the Configuration Object as an Environment Object\n\n ```swift .environment(\\.realmConfiguration, config) \n``` If your app uses either a local or a Synced realm, the first view in the hiearchy that opens a realm varies depending on whether you're using the app with or without Sync. Without sync, you can pass the realm configuration environment object directly to the `LocalOnlyContentView`: ```swift .environment(\\.realmConfiguration, config) \n``` Which opens a realm implicitly with: ```swift struct LocalOnlyContentView: View {     // Implicitly use the default realm's objects(Dog.self)     @ObservedResults(Dog.self) var dogs         var body: some View {         if dogs.first != nil {             // If dogs exist, go to the DogsView             DogsView()         } else {             // If there is no Dog object, add one here.             AddDogView()         }     } } \n``` However, when your app uses Sync, you the Realm explicitly using the`@AsyncOpen` or `@AutoOpen` property wrapper: ```swift /// This view opens a synced realm. struct OpenFlexibleSyncRealmView: View {     // We've injected a `flexibleSyncConfiguration` as an environment value,     // so `@AsyncOpen` here opens a realm using that configuration.     @AsyncOpen(appId: flexibleSyncAppId, timeout: 4000) var asyncOpen         var body: some View {         switch asyncOpen {         // Starting the Realm.asyncOpen process.         // Show a progress view.         case .connecting:             ProgressView()         // Waiting for a user to be logged in before executing         // Realm.asyncOpen.         case .waitingForUser:             ProgressView(\"Waiting for user to log in...\")         // The realm has been opened and is ready for use.         // Show the content view.         case .open(let realm):             // Do something with the realm             UseRealmView(realm: realm)         // The realm is currently being downloaded from the server.         // Show a progress view.         case .progress(let progress):             ProgressView(progress)         // Opening the Realm failed.         // Show an error view.         case .error(let error):             ErrorView(error: error)         }     } } \n``` So you must pass the environment object to the view that explicitly opens the realm. In this case, the `OpenFlexibleSyncRealmView`. The important thing to remember is to make sure to pass the`Realm.Configuration` that encompasses your migration logic to any view hierarchy that implicitly or explicitly opens a realm. ### Explicitly Pass the Updated Configuration to a Realm SwiftUI Property Wrapper You can explicitly pass the configuration object to a Realm SwiftUI property wrapper that takes a configuration object, such as `@ObservedResults`or `@AutoOpen`. In this case, you might pass it directly to `@ObservedResults`in our `DogsView`. ```swift // Use a `config` that you've passed in from above. @ObservedResults(Dog.self, configuration: config) var dogs \n```\n\n",
  "https://www.mongodb.com/docs/realm/sdk/swift/app-services/connect-to-app-services-backend/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Connect to an Atlas App Services backend - Swift SDK On this page * [Overview](#overview)\n* [Access the App Client](#access-the-app-client)\n* [Configuration](#configuration) ## Overview The App client is the interface to the App Services backend. It provides access to the [authentication functionality](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-authenticate-users), [functions](https://mongodb.com/docs/realm/sdk/swift/app-services/call-a-function/#std-label-ios-call-a-function), and[sync management.](https://mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/#std-label-ios-sync-changes-between-devices) ## Access the App Client Pass the App ID for your App, which you can [find in the Realm UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) `| let app = App(id: YOUR_APP_SERVICES_APP_ID) // replace YOUR_APP_SERVICES_APP_ID with your App ID |\n| ------------------------------------------------------------------------------------------------ | ` ## Configuration You can pass a configuration object to `RealmApp`: ```swift let configuration = AppConfiguration(    baseURL: \"https://realm.mongodb.com\", // Custom base URL    transport: nil, // Custom RLMNetworkTransportProtocol    localAppName: \"My App\",    localAppVersion: \"3.14.159\",    defaultRequestTimeoutMS: 30000 ) let app = App(id: \"my-app-services-app-id\", configuration: configuration) \n``` ← [Application Services - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/application-services/ \"Previous Section\")[Call a Function - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/app-services/call-a-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Supported Types - Swift SDK On this page * [Key Concept: Collection Types](#key-concept--collection-types)\n* [Results and Sectioned Results](#results-and-sectioned-results)\n* [Collections as Properties](#collections-as-properties)\n* [Collections are Live](#collections-are-live)\n* [Supported Property Types](#supported-property-types)\n* [Property Cheat Sheet](#property-cheat-sheet)\n* [Setting Default Values](#setting-default-values)\n* [Unique Identifiers](#unique-identifiers)\n* [Size Limitations](#size-limitations)\n* [AnyRealmCollection](#anyrealmcollection)\n* [Mutable Set](#mutable-set)\n* [Map/Dictionary](#map-dictionary)\n* [AnyRealmValue](#anyrealmvalue)\n* [Map Unsupported Types to Supported Types](#map-unsupported-types-to-supported-types)\n* [Declare Type Projections](#declare-type-projections)\n* [Conform to the Type Projection Protocol](#conform-to-the-type-projection-protocol)\n* [Use Type Projection in the Model](#use-type-projection-in-the-model) ## Key Concept: Collection Types Realm has several types to represent groups of objects, which we call **collections**. A collection is an object that contains zero or more instances of one [Realm type](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-realm-objects). Realm collections are **homogenous**: all objects in a collection are of the same type. You can filter and sort any collection using Realm Database's[query engine](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-client-query-engine). Collections are[live](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-live-object), so they always reflect the current state of the realm instance on the current thread. You can also listen for changes in the collection by subscribing to [collection notifications.](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-register-a-collection-change-listener) All collection types conform to the [RealmCollection](https://www.mongodb.com/docs/realm-sdks/swift/latest/Protocols/RealmCollection.html) protocol. This protocol inherits from[CollectionType](https://developer.apple.com/documentation/swift/collection), so you can use a Realm collection as you would any other standard library collections. Using the RealmCollection protocol, you can write generic code that can operate on any Realm collection: `| func operateOn<C: RealmCollection>(collection: C) {                     |\n| ----------------------------------------------------------------------- |\n| // Collection could be either Results or List                           |\n| print(\"operating on collection containing \\(collection.count) objects\") |\n| }                                                                       | ` ### Results and Sectioned Results The Swift SDK [Results](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Results.html) collection is a class representing objects retrieved from queries. A[Results](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Results.html) collection represents the lazily-evaluated results of a query operation. Results are immutable: you cannot add or remove elements to or from the results collection. Results have an associated query that determines their contents.\n\n For example, an app that includes a contact list might use SectionedResults to display a list of contacts divided into sections, where each section contains all the contacts whose first name starts with the given letter. The `ResultsSection` whose key is \"L\" would contain \"Larry\", \"Liam\", and \"Lisa\". ## Tip ### See also:  [Reads](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-realm-database-reads) ### Collections as Properties The Swift SDK also offers several collection types you can use as properties in your data model: 1. [List](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/List.html), a class representing[to-many relationships](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-many-relationship) in models.\n2. [LinkingObjects](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/LinkingObjects.html), a class representing [inverse relationships](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-inverse-relationship) in models.\n3. [MutableSet](#std-label-ios-mutableset-data-type), a class representing a [to-many relationship.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-many-relationship)\n4. [Map](#std-label-ios-map), a class representing an associative array of key-value pairs with unique keys.\n5. [AnyRealmCollection](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AnyRealmCollection.html), a [type-erased](https://en.wikipedia.org/wiki/Type%5Ferasure) class that can forward calls to a concrete Realm collection like Results, List or LinkingObjects. ### Collections are Live Like [live objects](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-live-object), Realm collections are usually **live**: * Live results collections always reflect the current results of the associated query.\n* Live lists always reflect the current state of the relationship on the realm instance. There are two cases when a collection is **not** live: * The collection is unmanaged. For example, a List property of a Realm object that has not been added to a realm yet or that has been copied from a realm is not live.\n* The collection is [frozen.](https://mongodb.com/docs/realm/sdk/swift/crud/threading/#std-label-ios-frozen-objects) Combined with [collection notifications](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-register-a-collection-change-listener), live collections enable clean, reactive code. For example, suppose your view displays the results of a query. You can keep a reference to the results collection in your view class, then read the results collection as needed without having to refresh it or validate that it is up-to-date. ## Important ### Results indexes may change Since results update themselves automatically, do not store the positional index of an object in the collection or the count of objects in a collection. The stored index or count value could be outdated by the time you use it. ## Supported Property Types ### Property Cheat Sheet ### Unique Identifiers _New in version 10.8.0_: `UUID` type `ObjectId` is a MongoDB-specific 12-byte unique value. `UUID` is a 16-byte globally-unique value. You can [index](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-index-a-property)both types, and use either as a [primary key.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-specify-a-primary-key) ## Note When declaring default values for `@Persisted` UUID or ObjectId property attributes, both of these syntax types are valid:\n\n However, the second will result in poorer performance. This is because the latter creates a new identifier that is never used any time an object is read from the realm, while the former only creates them when needed. `@Persisted var id: ObjectId` has equivalent behavior to `@objc dynamic var _id = ObjectId.generate()`. They both make random ObjectIds. `@Persisted var _id = ObjectId()` has equivalent behavior to `@objc dynamic var _id = ObjectId()`. They both make zero-initialized ObjectIds. ### Size Limitations Data and string properties cannot hold more than 16MB. To store larger amounts of data, either: * Break the data into 16MB chunks, or\n* Store data directly on the file system and store paths to the files in the realm. Realm throws a runtime exception if your app attempts to store more than 16MB in a single property. To avoid size limitations and a performance impact, it is best not to store large blobs, such as image and video files, directly in a realm. Instead, save the file to a file store and keep only the location of the file and any relevant metadata in the realm. ### AnyRealmCollection To store a collection as a property or variable without needing to know the concrete collection type, Swift's type system requires a type-erased wrapper like [AnyRealmCollection:](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/AnyRealmCollection.html) ```swift class ViewController { //    let collection: RealmCollection //                    ^ //                    error: protocol 'RealmCollection' can only be used //                    as a generic constraint because it has Self or //                    associated type requirements // //    init<C: RealmCollection>(collection: C) where C.ElementType == MyModel { //        self.collection = collection //    }     let collection: AnyRealmCollection<MyModel>     init<C: RealmCollection & _ObjcBridgeable>(collection: C) where C.ElementType == MyModel {         self.collection = AnyRealmCollection(collection)     } } \n``` ### Mutable Set _New in version 10.8.0_. A [MutableSet](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/MutableSet.html)collection represents a [to-many relationship](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-many-relationship)containing distinct values. A `MutableSet` supports the following types (and their optional versions): * Bool,\n* Int,\n* Int8,\n* Int16,\n* Int32,\n* Int64,\n* Float,\n* Double,\n* String,\n* Data,\n* Date,\n* Decimal128,\n* ObjectId Like Swift's [Set](https://developer.apple.com/documentation/swift/set), `MutableSet` is a generic type that is parameterized on the type it stores. Unlike[native Swift collections](https://developer.apple.com/documentation/swift/swift%5Fstandard%5Flibrary/collections), Realm mutable sets are reference types, as opposed to value types (structs). You can only call the `MutableSets` mutation methods during a write transaction. As a result, `MutableSets` are immutable if you open the managing realm as a read-only realm. You can filter and sort a `MutableSet` with the [same predicates](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-filter-data) as [Results](#std-label-ios-results-collections). Like other Realm collections, you can [register a change listener](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-register-a-collection-change-listener) on a `MutableSet`.\n\n ```swift class Dog: Object {     @Persisted var name = \"\"     @Persisted var currentCity = \"\"     @Persisted var citiesVisited: MutableSet<String> } \n``` ## Note When declaring default values for `@Persisted` MutableSet property attributes, both of these syntax types is valid: * `@Persisted var value: MutableSet<String>`\n* `@Persisted var value = MutableSet<String>()` However, the second will result in significantly worse performance. This is because the MutableSet is created when the parent object is created, rather than lazily as needed. ### Map/Dictionary _New in version 10.8.0_. The [Map](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/Map.html) is an associative array that contains key-value pairs with unique keys. Like Swift's [Dictionary](https://developer.apple.com/documentation/swift/dictionary),`Map` is a generic type that is parameterized on its key and value types. Unlike [native Swift collections](https://developer.apple.com/documentation/swift/swift%5Fstandard%5Flibrary/collections), Realm Maps are reference types (classes), as opposed to value types (structs). You can declare a Map as a property of an object: ```swift class Dog: Object {     @Persisted var name = \"\"     @Persisted var currentCity = \"\"     // Map of city name -> favorite park in that city     @Persisted var favoriteParksByCity: Map<String, String> } \n``` ## Note When declaring default values for `@Persisted` Map property attributes, both of these syntax types is valid: * `@Persisted var value: Map<String, String>`\n* `@Persisted var value = Map<String, String>()` However, the second will result in significantly worse performance. This is because the Map is created when the parent object is created, rather than lazily as needed. ### AnyRealmValue _New in version 10.8.0_. `AnyRealmValue` is a Realm property type that can hold different data types. Supported `AnyRealmValue` data types include: * Int\n* Float\n* Double\n* Decimal128\n* ObjectID\n* UUID\n* Bool\n* Date\n* Data\n* String\n* Object This [mixed data type](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/AnyRealmValue.html)is [indexable](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-index-a-property), but you can't use it as a[primary key](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-specify-a-primary-key). Because `null` is a permitted value, you can't declare an `AnyRealmValue` as optional. ```swift class Dog: Object {     @Persisted var name = \"\"     @Persisted var currentCity = \"\"     @Persisted var companion: AnyRealmValue } \n``` ## Map Unsupported Types to Supported Types _New in version 10.20.0_. You can use Type Projection to persist unsupported types as supported types in Realm Database. This enables you to work with Swift types that Realm does not support, but store them as types that Realm does support. You could store a URL as a `String`, for example, but read it from Realm and use it in your application as though it were a URL. ### Declare Type Projections To use type projection with Realm: 1. Use one of Realm's custom type protocols to map an unsupported data type to a type that Realm supports\n2. Use the projected types as @Persisted properties in the Realm object model #### Conform to the Type Projection Protocol You can map an unsupported data type to a [type that Realm supports](#std-label-ios-supported-property-types) using one of the Realm type projection protocols. The Swift SDK provides two type projection protocols: * CustomPersistable\n* FailableCustomPersistable\n\n Use [FailableCustomPersistable](https://www.mongodb.com/docs/realm-sdks/swift/latest/Protocols/FailableCustomPersistable.html)when it is possible for the conversion to fail. ```swift // Extend a type as a CustomPersistable if if is impossible for // conversion between the mapped type and the persisted type to fail. extension CLLocationCoordinate2D: CustomPersistable {     // Define the storage object that is persisted to the database.     // The `PersistedType` must be a type that Realm supports.     // In this example, the PersistedType is an embedded object.     public typealias PersistedType = Location     // Construct an instance of the mapped type from the persisted type.     // When reading from the database, this converts the persisted type to the mapped type.     public init(persistedValue: PersistedType) {         self.init(latitude: persistedValue.latitude, longitude: persistedValue.longitude)     }     // Construct an instance of the persisted type from the mapped type.     // When writing to the database, this converts the mapped type to a persistable type.     public var persistableValue: PersistedType {         Location(value: [self.latitude, self.longitude])     } } // Extend a type as a FailableCustomPersistable if it is possible for // conversion between the mapped type and the persisted type to fail. // This returns nil on read if the underlying column contains nil or // something that can't be converted to the specified type. extension URL: FailableCustomPersistable {     // Define the storage object that is persisted to the database.     // The `PersistedType` must be a type that Realm supports.     public typealias PersistedType = String     // Construct an instance of the mapped type from the persisted type.     // When reading from the database, this converts the persisted type to the mapped type.     // This must be a failable initilizer when the conversion may fail.     public init?(persistedValue: String) { self.init(string: persistedValue) }     // Construct an instance of the persisted type from the mapped type.     // When writing to the database, this converts the mapped type to a persistable type.     public var persistableValue: String { self.absoluteString } } \n``` ## Tip ### See also:  These are protocols modeled after Swift's built-in [RawRepresentable.](https://developer.apple.com/documentation/swift/rawrepresentable) ##### Supported PersistedTypes The `PersistedType` can use any of the primitive types that the[Swift SDK supports](#std-label-ios-supported-property-types). It can also be an [Embedded Object.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-embedded-objects) `PersistedType` cannot be an optional or a [collection](#std-label-ios-client-collections). However you can use the mapped type as an optional or collection property in your object model. ```swift extension URL: FailableCustomPersistable {    // The `PersistedType` cannot be an optional, so this is not a valid    // conformance to the FailableCustomPersistable protocol.    public typealias PersistedType = String?    ... } class Club: Object {    @Persisted var id: ObjectId    @Persisted var name: String    // Although the `PersistedType` cannot be optional, you can use the    // custom-mapped type as an optional in your object model.    @Persisted var url: URL? } \n``` #### Use Type Projection in the Model A type that conforms to one of the type projection protocols can be used with the `@Persisted` property declaration syntax introduced in Swift SDK version 10.10.0\\. It does not work with the `@objc dynamic` syntax. You can use projected types for: * Top-level types\n* Optional versions of the type\n* The types for a collection\n\n ```swift class Club: Object {     @Persisted var id: ObjectId     @Persisted var name: String     // Since we declared the URL as a FailableCustomPersistable,     // it must be optional.     @Persisted var url: URL?     // Here, the `location` property maps to an embedded object.     // We can declare the property as required.     // If the underlying field contains nil, this becomes     // a default-constructed instance of CLLocationCoordinate     // with field values of `0`.     @Persisted var location: CLLocationCoordinate2D } public class Location: EmbeddedObject {     @Persisted var latitude: Double     @Persisted var longitude: Double } \n``` When your model contains projected types, you can [create the object](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-create-a-new-object) with values using the persisted type, or by assigning to the field properties of an initialized object using the projected types. ```swift // Initialize objects and assign values let club = Club(value: [\"name\": \"American Kennel Club\", \"url\": \"https://akc.org\"]) let club2 = Club() club2.name = \"Continental Kennel Club\" // When assigning the value to a type-projected property, type safety // checks for the mapped type - not the persisted type. club2.url = URL(string: \"https://ckcusa.com/\")! club2.location = CLLocationCoordinate2D(latitude: 40.7509, longitude: 73.9777) \n``` ##### Type Projection in the Schema When you declare your type as conforming to a type projection protocol, you specify the type that should be persisted in realm. For example, if you map a custom type `URL` to a persisted type of `String`, a `URL`property appears as a `String` in the schema, and dynamic access to the property acts on strings. The schema does not directly represent mapped types. Changing a property from its persisted type to its mapped type, or vice versa, does not require a migration. ![Realm Studio screenshot showing the field types using persisted types.](https://mongodb.com/docs/realm/images/projected-types-persisted-types-in-schema.png) ← [Model Relationships - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/ \"Previous Section\")[Change an Object Model - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/model-data/change-an-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/app-services/call-a-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call a Function - Swift SDK On this page * [Call a Function by Name](#call-a-function-by-name)\n* [Async/Await Call a Function](#async-await-call-a-function) ## Call a Function by Name ## Important Make sure to sanitize client data to protect against code injection when using Functions. Consider an [Atlas App Services Function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) named`concatenate` that takes two arguments, concatenates them, and returns the result: `| // concatenate: concatenate two strings |\n| --------------------------------------- |\n| exports = function(a, b) {              |\n| return a + b;                           |\n| };                                      | ` To execute a function from the Swift SDK, use the `functions`object on the currently logged-in user. The `functions` object has dynamic members corresponding to functions. In this case, `functions.concatenate()` refers to the `concatenate`function. Pass a `BSONArray` of arguments. The trailing closure is the completion handler to call when the function call is complete. This handler is executed on a non-main global `DispatchQueue`. ## Async/Await Call a Function _New in version 10.16.0_. The Realm Swift SDK offers async/await versions of the `User.function`methods. ```swift func testAsyncCallFunction() async {     let app = App(id: YOUR_APP_SERVICES_APP_ID)     // ... log in ...     let user = app.currentUser!     do {         // The dynamic member name `concatenate` is directly associated with the         // function name. The first argument is the `BSONArray` of arguments to be         // provided to the function - in this case, a string that represents a         // username and a string that represents an email domain.         let concatenatedString = try await user.functions.concatenate([AnyBSON(\"john.smith\"), AnyBSON(\"@companyemail.com\")])         print(\"Called function 'concatenate' and got result: \\(concatenatedString)\")         assert(concatenatedString == \"john.smith@companyemail.com\")     } catch {         print(\"Function call failed: \\(error.localizedDescription)\")     } } \n``` Starting with Realm Swift SDK Versions 10.15.0 and 10.16.0, many of the Realm APIs support the Swift async/await syntax. Projects must meet these requirements: | Swift SDK Version  | Swift Version Requirement | Supported OS |\n| ------------------ | ------------------------- | ------------ |\n| 10.25.0            | Swift 5.6                 | iOS 13.x     |\n| 10.15.0 or 10.16.0 | Swift 5.5                 | iOS 15.x     | If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ← [Connect to an Atlas App Services backend - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/app-services/connect-to-app-services-backend/ \"Previous Section\")[Query MongoDB - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/swiftui/model-data/define-a-realm-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Object Models - SwiftUI On this page * [Concepts: Object Models and Relationships](#concepts--object-models-and-relationships)\n* [Key Concept: Binding the Object Model to the UI](#key-concept--binding-the-object-model-to-the-ui)\n* [Key Concept: Transforming Data for SwiftUI Views](#key-concept--transforming-data-for-swiftui-views)\n* [Define a New Object](#define-a-new-object)\n* [Define a Projection](#define-a-projection) ## Concepts: Object Models and Relationships Modeling data for SwiftUI builds on the same object model and relationship concepts in the Swift SDK. If you are unfamiliar with Realm Swift SDK data modeling concepts, see: [Object Models - Swift SDK.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-swift-object-models) ## Key Concept: Binding the Object Model to the UI The Model-View-ViewModel (MVVM) design pattern advocates creating a view model that abstracts the model from the View code. While you can certainly do that with Realm, the Swift SDK provides tools that make it easy to work directly with your data in SwiftUI Views. These tools include things like: * Property wrappers that create bindings to underlying observable objects\n* A class to project and transform underlying model objects for use in specific views ## Key Concept: Transforming Data for SwiftUI Views The Realm Swift SDK provides a special type of object, called a[Projection](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/Projection.html), to transform and work with subsets of your data. Consider a projection similar to a view model. It lets you pass through or transform the original object's properties in different ways: * Passthrough: The projection's property has the same name and type as the original object.\n* Rename: The projection's property has the same type as the original object, but a different name.\n* Keypath resolution: Use this to access specific properties of the projected Object.\n* Collection mapping: You can map some [collection types](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections) to a collection of primitive values.\n* Exclusion: All properties of the original Realm object not defined in the projection model. Any changes to those properties do not trigger a change notification when observing the projection. When you use a Projection, you get all the benefits of Realm Database's live objects: * The class-projected object live updates\n* You can observe it for changes\n* You can apply changes directly to the properties in write transactions ## Define a New Object You can define a Realm object by deriving from the[Object](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/Object.html) or[EmbeddedObject](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/EmbeddedObject.html)class. The name of the class becomes the table name in the realm, and properties of the class persist in the database. This makes it as easy to work with persisted objects as it is to work with regular Swift objects. The Realm SwiftUI documentation uses a model for a fictional app, DoggoDB. This app is a company directory of employees who have dogs. It lets people share a few details about their dogs with other employees. The data model includes a Person object, with a [to-many relationship](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-many-relationship) to that person's Dog objects. It also uses a special Realm Swift SDK data type, [PersistableEnum](https://www.mongodb.com/docs/realm-sdks/swift/latest/Protocols.html#/s:10RealmSwift15PersistableEnumP), to store information about the person's business unit.\n\n ` ## Tip ### See also:  For complete details about defining a Realm object model, see: * [Object Models](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-swift-object-models)\n* [Relationships](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-swift-model-relationships)\n* [Supported Data Types](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-swift-supported-types) ## Define a Projection Our fictional DoggoDB app has a user Profile view. This view displays some details about the person, but we don't need all of the properties of the `Person` model. We can create a [Projection](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/Projection.html) with only the details we want. We can also modify the `lastName` property to use just the first initial of the last name. ```swift class Profile: Projection<Person> {     @Projected(\\Person.firstName) var firstName // Passthrough from original object     @Projected(\\Person.lastName.localizedCapitalized.first) var lastNameInitial // Access and transform the original property     @Projected(\\Person.personId) var personId     @Projected(\\Person.businessUnit) var businessUnit     @Projected(\\Person.profileImageUrl) var profileImageUrl     @Projected(\\Person.dogs) var dogs } \n``` We can use this projection in the Profile view instead of the original`Person` object. Class projection works with SwiftUI property wrappers: * [ObservedRealmObject](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedRealmObject.html)\n* [ObservedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ObservedResults.html) ## Tip ### See also:  For a complete example of using a class projection in a SwiftUI application, see [the Projections example app.](https://github.com/realm/realm-cocoa/tree/master/examples#projections) ← [Model Data- SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/ \"Previous Section\")[Change an Object Model - SwiftUI](https://mongodb.com/docs/realm/sdk/swift/swiftui/model-data/change-an-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query MongoDB - Swift SDK On this page * [Overview](#overview)\n* [Use Cases](#use-cases)\n* [Prerequisites](#prerequisites)\n* [Example Data](#example-data)\n* [Async/Await Query MongoDB](#async-await-query-mongodb)\n* [Create Documents](#create-documents)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Read Documents](#read-documents)\n* [Find a Single Document](#find-a-single-document)\n* [Find Multiple Documents](#find-multiple-documents)\n* [Count Documents in the Collection](#count-documents-in-the-collection)\n* [Update Documents](#update-documents)\n* [Update a Single Document](#update-a-single-document)\n* [Update Multiple Documents](#update-multiple-documents)\n* [Upsert Documents](#upsert-documents)\n* [Delete Documents](#delete-documents)\n* [Delete a Single Document](#delete-a-single-document)\n* [Delete Multiple Documents](#delete-multiple-documents)\n* [Aggregate Documents](#aggregate-documents)\n* [Filter Documents](#filter-documents)\n* [Group Documents](#group-documents)\n* [Project Document Fields](#project-document-fields)\n* [Add Fields to Documents](#add-fields-to-documents)\n* [Unwind Array Values](#unwind-array-values) ## Overview You can query data stored in MongoDB directly from your client application code by using the Realm Swift SDK's [MongoClient](https://www.mongodb.com/docs/realm-sdks/swift/latest/Typealiases.html#/s:10RealmSwift11MongoClienta) with the [Query API](https://www.mongodb.com/docs/manual/tutorial/query-documents/). Atlas App Services provides data access [rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) on collections to securely retrieve results based on the logged-in user or the content of each document. ## Tip ### See also:  This page covers querying a MongoDB data source directly. To filter data you retrieve from Realm Database, see: [Filter Data.](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-client-query-engine) ## Use Cases There are a variety of reasons you might want to query a MongoDB data source. Working with data in your client via Atlas Device Sync is not always practical or possible. You might want to query MongoDB when: * The data set is large or the client device has constraints against loading the entire data set\n* You are [creating or updating custom user data](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/#std-label-ios-custom-user-data)\n* You are retrieving documents that are not modeled in Realm\n* Your app needs to access collections that don't have strict schemas\n* A non-Realm service generates collections that you want to access While not exhaustive, these are some common use cases for querying MongoDB directly. ## Prerequisites Before you can query MongoDB from your client application, you must set up MongoDB Data Access in your App Services App. To learn how to set up your backend App to let the Realm SDK query Atlas, refer to [Set Up MongoDB Data Access](https://www.mongodb.com/docs/atlas/app-services/mongodb/data-access/#std-label-client-data-access)in the App Services documentation. ## Example Data These examples operate on a MongoDB collection that describes coffee drinks in a chain of coffee shops. The documents represent objects with these properties:\n\n ` The complete code for each example includes logging in and instantiating a MongoDB collection handle before completing each operation. For brevity, these examples omit the login and collection handle code. However, each complete example looks like this: ```swift app.login(credentials: Credentials.anonymous) { (result) in     // Remember to dispatch back to the main thread in completion handlers     // if you want to do anything on the UI.     DispatchQueue.main.async {         switch result {         case .failure(let error):             print(\"Login failed: \\(error)\")         case .success(let user):             print(\"Login as \\(user) succeeded!\")             // Continue below         }         // mongodb-atlas is the cluster service name         let client = app.currentUser!.mongoClient(\"mongodb-atlas\")         // Select the database         let database = client.database(named: \"ios\")         // Select the collection         let collection = database.collection(withName: \"CoffeeDrinks\")         let drink: Document = [ \"name\": \"Bean of the Day\", \"beanRegion\": \"Timbio, Colombia\", \"containsDairy\": \"false\", \"partition\": \"Store 42\"]         let drink2: Document = [ \"name\": \"Maple Latte\", \"beanRegion\": \"Yirgacheffe, Ethiopia\", \"containsDairy\": \"true\", \"partition\": \"Store 42\"]         let drink3: Document = [ \"name\": \"Bean of the Day\", \"beanRegion\": \"San Marcos, Guatemala\", \"containsDairy\": \"false\", \"partition\": \"Store 47\"]         // Insert the documents into the collection         collection.insertMany([drink, drink2, drink3]) { result in             switch result {             case .failure(let error):                 print(\"Call to MongoDB failed: \\(error.localizedDescription)\")                 return             case .success(let objectIds):                 print(\"Successfully inserted \\(objectIds.count) new documents.\")             }         }     } } \n``` ## Async/Await Query MongoDB _New in version 10.16.0_. The Realm Swift SDK provides [async/await versions of the MongoCollection methods.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html) All of the methods on this page are compatible with the async/await syntax. This example illustrates that syntax for the `collection.insertOne()` method. You can see the completion handler version in [Insert a Single Document.](#std-label-ios-mongodb-insertOne) ```swift // This document represents a CoffeeDrink object let drink: Document = [ \"name\": \"Bean of the Day\", \"beanRegion\": \"Timbio, Colombia\", \"containsDairy\": \"false\", \"_partition\": \"Store 43\"] do {     // Use the async collection method to insert the document     let objectId = try await collection.insertOne(drink)     print(\"Successfully inserted a document with id: \\(objectId)\") } catch {     print(\"Call to MongoDB failed: \\(error.localizedDescription)\") } \n``` Starting with Realm Swift SDK Versions 10.15.0 and 10.16.0, many of the Realm APIs support the Swift async/await syntax. Projects must meet these requirements:\n\n If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ## Create Documents These code snippets demonstrate how to insert one or more documents into a MongoDB collection from a mobile application. These methods take one or more[documents](https://www.mongodb.com/docs/realm-sdks/swift/latest/Typealiases.html#/s:10RealmSwift8Documenta) and return a result. Success returns the [objectId](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/ObjectId.html) of the inserted document, or an array of objectIds in order when inserting multiple documents. ### Insert a Single Document You can insert a single document using [collection.insertOne().](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html#/s:So18RLMMongoCollectionC10RealmSwiftE9insertOneyySDySSAC7AnyBSONOSgG%5Fys6ResultOyAFs5Error%5FpGctF) This snippet inserts a single document describing a \"Bean of the Day\" coffee drink into a [collection of documents that describe coffee drinks for sale in a group of stores:](#std-label-ios-mongodb-example-dataset) ```swift // This document represents a CoffeeDrink object let drink: Document = [ \"name\": \"Bean of the Day\", \"beanRegion\": \"Timbio, Colombia\", \"containsDairy\": \"false\", \"_partition\": \"Store 43\"] // Insert the document into the collection collection.insertOne(drink) { result in     switch result {     case .failure(let error):         print(\"Call to MongoDB failed: \\(error.localizedDescription)\")         return     case .success(let objectId):         // Success returns the objectId for the inserted document         print(\"Successfully inserted a document with id: \\(objectId)\")     } } \n``` Running this snippet produces this output: ``` Successfully inserted a document with id: objectId(6108...) \n``` ### Insert Multiple Documents You can insert multiple documents using [collection.insertMany().](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html#/s:So18RLMMongoCollectionC10RealmSwiftE10insertManyyySaySDySSAC7AnyBSONOSgGG%5Fys6ResultOySayAFGs5Error%5FpGctF) This snippet inserts three documents describing coffee drinks into a[collection of documents that describe coffee drinks for sale in a group of stores:](#std-label-ios-mongodb-example-dataset) ```swift let drink: Document = [ \"name\": \"Bean of the Day\", \"beanRegion\": \"Timbio, Colombia\", \"containsDairy\": \"false\", \"_partition\": \"Store 42\"] let drink2: Document = [ \"name\": \"Maple Latte\", \"beanRegion\": \"Yirgacheffe, Ethiopia\", \"containsDairy\": \"true\", \"_partition\": \"Store 42\"] let drink3: Document = [ \"name\": \"Bean of the Day\", \"beanRegion\": \"San Marcos, Guatemala\", \"containsDairy\": \"false\", \"_partition\": \"Store 47\"] // Insert the documents into the collection collection.insertMany([drink, drink2, drink3]) { result in     switch result {     case .failure(let error):         print(\"Call to MongoDB failed: \\(error.localizedDescription)\")         return     case .success(let objectIds):         print(\"Successfully inserted \\(objectIds.count) new documents.\")     } } \n``` Running this snippet produces this output: ``` Successfully inserted 3 new documents. \n``` ## Read Documents\n\n ### Find a Single Document You can find a single document using [collection.findOneDocument().](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html#/s:So18RLMMongoCollectionC10RealmSwiftE15findOneDocument6filter7options7Combine6FutureCySDySSAC7AnyBSONOSgGSgs5Error%5FpGAM%5FSo14RLMFindOptionsCtF) This snippet finds a single document from a [collection of documents that describe coffee drinks for sale in a group of stores](#std-label-ios-mongodb-example-dataset), where the document's `name` field contains the string value \"Maple Latte\": ```swift let queryFilter: Document = [\"name\": \"Maple Latte\"] collection.findOneDocument(filter: queryFilter) { result in     switch result {     case .failure(let error):         print(\"Did not find matching documents: \\(error.localizedDescription)\")         return     case .success(let document):         print(\"Found a matching document: \\(document)\")     } } \n``` Running this snippet produces this output: ``` Found a matching document: Optional([    \"name\": Optional(RealmSwift.AnyBSON.string(\"Maple Latte\")),    \"_id\": Optional(RealmSwift.AnyBSON.objectId(60f5...)),    \"creamer\": Optional(RealmSwift.AnyBSON.string(\"true\")),    \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\")),    \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Yirgacheffe, Ethiopia\"))]) \n``` ### Find Multiple Documents You can find multiple documents using [collection.find().](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html#/s:So18RLMMongoCollectionC10RealmSwiftE4find6filter7Combine6FutureCySaySDySSAC7AnyBSONOSgGGs5Error%5FpGAL%5FtF) This snippet finds all documents in a [collection of documents that describe coffee drinks for sale in a group of stores](#std-label-ios-mongodb-example-dataset), where the document's `name` field contains the value \"Americano\": ```swift let queryFilter: Document = [\"name\": \"Americano\"] collection.find(filter: queryFilter) { result in     switch result {     case .failure(let error):         print(\"Call to MongoDB failed: \\(error.localizedDescription)\")         return     case .success(let documents):         print(\"Results: \")         for document in documents {             print(\"Coffee drink: \\(document)\")         }     } } \n``` Running this snippet produces this output: ``` Results: Coffee drink: [    \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\")),    \"creamer\": Optional(RealmSwift.AnyBSON.string(\"false\")),    \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Timbio, Colombia\")),    \"_id\": Optional(RealmSwift.AnyBSON.objectId(6102...)),    \"name\": Optional(RealmSwift.AnyBSON.string(\"Americano\"))] Coffee drink: [    \"creamer\": Optional(RealmSwift.AnyBSON.string(\"false\")),    \"name\": Optional(RealmSwift.AnyBSON.string(\"Americano\")),    \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 47\")),    \"_id\": Optional(RealmSwift.AnyBSON.objectId(6102...)),    \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"San Marcos, Guatemala\"))] \n``` ### Count Documents in the Collection\n\n This snippet counts the number of documents in a [collection of documents that describe coffee drinks for sale in a group of stores](#std-label-ios-mongodb-example-dataset), where the document's `name` field contains the value \"Bean of the Day\": ```swift let queryFilter: Document = [\"name\": \"Bean of the Day\"] collection.count(filter: queryFilter) { result in     switch result {     case .failure(let error):         print(\"Call to MongoDB failed: \\(error.localizedDescription)\")         return     case .success(let count):         print(\"Found this many documents in the collection matching the filter: \\(count)\")     } } \n``` Running this snippet produces this output: ``` Found this many documents in the collection matching the filter: 24 \n``` ## Update Documents These code snippets demonstrate how to update data stored in a MongoDB collection from a mobile application. Update operations use queries to specify which documents to update, and [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) to desribe how to mutate documents that match the query. Update operations return a result that resolves to an[UpdateResult](https://www.mongodb.com/docs/realm-sdks/swift/latest/Typealiases.html#/s:10RealmSwift12UpdateResulta)or `Error`. ### Update a Single Document You can update a single document using [collection.updateOneDocument().](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html#/s:So18RLMMongoCollectionC10RealmSwiftE17updateOneDocument6filter0E07Combine6FutureCySo15RLMUpdateResultCs5Error%5FpGSDySSAC7AnyBSONOSgG%5FAQtF) This snippet updates a single document in a [collection of documents that describe coffee drinks for sale in a group of stores](#std-label-ios-mongodb-example-dataset). This update operation queries for a document whose `name` field contains the value \"Bean of the Day\", and sets the`containsDairy` field to \"true\": ```swift let queryFilter: Document = [\"name\": \"Bean of the Day\", \"_partition\": \"Store 42\"] let documentUpdate: Document = [\"$set\": [\"containsDairy\": \"true\"]] collection.updateOneDocument(filter: queryFilter, update: documentUpdate) { result in     switch result {     case .failure(let error):         print(\"Failed to update document: \\(error.localizedDescription)\")         return     case .success(let updateResult):         if updateResult.matchedCount == 1 && updateResult.modifiedCount == 1 {             print(\"Successfully updated a matching document.\")         } else {             print(\"Did not update a document\")         }     } \n``` Running this snippet produces this output: ``` Successfully updated a matching document. \n``` ### Update Multiple Documents You can update multiple documents using [collection.updateManyDocuments().](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html#/s:So18RLMMongoCollectionC10RealmSwiftE19updateManyDocuments6filter0E07Combine6FutureCySo15RLMUpdateResultCs5Error%5FpGSDySSAC7AnyBSONOSgG%5FAQtF) This snippet updates multiple documents in a [collection of documents that describe coffee drinks for sale in a group of stores](#std-label-ios-mongodb-example-dataset). This update operation queries for documents where the `name` field contains the value \"Bean of the Day\", and changes the`containsDairy` field to \"true\": ```swift let queryFilter: Document = [\"name\": \"Bean of the Day\"] let documentUpdate: Document = [\"$set\": [\"containsDairy\": \"true\"]]\n\n     switch result {     case .failure(let error):         print(\"Failed to update document: \\(error.localizedDescription)\")         return     case .success(let updateResult):         print(\"Successfully updated \\(updateResult.modifiedCount) documents.\")     } } \n``` Running this snippet produces this output: ``` Successfully updated 24 documents. \n``` ### Upsert Documents If an update operation does not match any document in the collection, you can automatically insert a single new document into the collection that matches the update query by setting the `upsert` option to`true`. The following snippet updates a document in a [collection of documents that describe coffee drinks for sale in a group of stores](#std-label-ios-mongodb-example-dataset). If no document matches the query, it inserts a new document if no document. This operation queries for documents where the `name` field has a value of \"Bean of the Day\", and the `partition` field has a value of \"Store 55\". Because this snippet sets the `upsert` option to `true`, if no document matches the query, MongoDB creates a new document that includes both the query and specified updates: ```swift let queryFilter: Document = [\"name\": \"Bean of the Day\", \"_partition\": \"Store 55\"] let documentUpdate: Document = [\"name\": \"Bean of the Day\", \"beanRegion\": \"Yirgacheffe, Ethiopia\", \"containsDairy\": \"false\", \"_partition\": \"Store 55\"] collection.updateOneDocument(filter: queryFilter, update: documentUpdate, upsert: true) { result in     switch result {     case .failure(let error):         print(\"Failed to update document: \\(error.localizedDescription)\")         return     case .success(let updateResult):         if updateResult.objectId != nil {             print(\"Successfully upserted a document with id: \\(updateResult.objectId)\")         } else {             print(\"Did not upsert a document\")         }     } } \n``` Running this snippet produces this output: ``` Successfully upserted a document with id: Optional(6108...) \n``` ## Delete Documents These code snippets demonstrate how to delete documents that are stored in a MongoDB collection from a mobile application. Delete operations use a query to specify which documents to delete and return results that resolve to an `Int` count of deleted documents or `Error`. ### Delete a Single Document You can delete a single document from a collection using [collection.deleteOneDocument().](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html#/s:So18RLMMongoCollectionC10RealmSwiftE17deleteOneDocument6filter7Combine6FutureCySis5Error%5FpGSDySSAC7AnyBSONOSgG%5FtF) This snippet deletes one document in a [collection of documents that describe coffee drinks for sale in a group of stores](#std-label-ios-mongodb-example-dataset). This operation queries for a document where the `name` field has a value of \"Mocha\" and the `partition` field has a value of \"Store 17\", and deletes it. ```swift let queryFilter: Document = [\"name\": \"Mocha\", \"_partition\": \"Store 17\"] collection.deleteOneDocument(filter: queryFilter) { deletedResult in     switch deletedResult {     case .failure(let error):         print(\"Failed to delete a document: \\(error.localizedDescription)\")         return     case .success(let deletedResult):         print(\"Successfully deleted a document.\")     } } \n``` Running this snippet produces this output: ``` Successfully deleted a document. \n``` ### Delete Multiple Documents\n\n This snippet deletes all documents in a [collection of documents that describe coffee drinks for sale in a group of stores](#std-label-ios-mongodb-example-dataset) that match the query for documents whose `name` field contains the value \"Caramel Latte\": ```swift let filter: Document = [\"name\": \"Caramel Latte\"] collection.deleteManyDocuments(filter: filter) { deletedResult in     switch deletedResult {     case .failure(let error):         print(\"Failed to delete a document: \\(error.localizedDescription)\")         return     case .success(let deletedResult):         print(\"Successfully deleted \\(deletedResult) documents.\")     } } \n``` Running this snippet produces this output: ``` Successfully deleted 3 documents. \n``` ## Aggregate Documents Aggregation operations run all documents in a collection through a series of data aggregation stages called an [aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/). Aggregation allows you to filter and transform documents, collect summary data about groups of related documents, and other complex data operations. You can configure and run aggregation operations on a collection using[collection.aggregate().](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/MongoCollection.html#/s:So18RLMMongoCollectionC10RealmSwiftE9aggregate8pipeline7Combine6FutureCySaySDySSAC7AnyBSONOSgGGs5Error%5FpGAM%5FtF) An aggregation operation accepts a list of aggregation stages as input and returns a result that resolves to a collection of documents processed by the pipeline, or an `Error`. ### Filter Documents You can use the [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) stage to filter documents using standard MongoDB [query syntax:](https://www.mongodb.com/docs/manual/tutorial/query-documents/) This `$match` stage filters documents to include only those where the`partition` field has a value equal to \"Store 42\": ```swift let pipeline: [Document] = [[\"$match\": [\"partition\": [\"$eq\": \"Store 42\"]]]] collection.aggregate(pipeline: pipeline) { result in     switch result {     case .failure(let error):         print(\"Failed to aggregate: \\(error.localizedDescription)\")         return     case .success(let documents):         print(\"Successfully ran the aggregation:\")         for document in documents {             print(\"Coffee drink: \\(document)\")         }     } } \n``` Running this snippet produces this output: ``` Successfully ran the aggregation: Coffee drink: [    \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\")),    \"creamer\": Optional(RealmSwift.AnyBSON.string(\"false\")),    \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Timbio, Colombia\")),    \"_id\": Optional(RealmSwift.AnyBSON.objectId(6102...)),    \"name\": Optional(RealmSwift.AnyBSON.string(\"Americano\"))] Coffee drink: [    \"creamer\": Optional(RealmSwift.AnyBSON.string(\"false\")),    \"name\": Optional(RealmSwift.AnyBSON.string(\"Americano\")),    \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\")),    \"_id\": Optional(RealmSwift.AnyBSON.objectId(6102...)),    \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"San Marcos, Guatemala\"))] (...more results...) \n``` ### Group Documents\n\n This `$group` stage arranges documents by the value of their`partition` field, which in this case is the store number. It then calculates the number of coffee drink documents that contain that store number as the value of the `partition` field. In other words, we're calculating the number of coffee drinks for each store number. ```swift let pipeline: [Document] = [[\"$group\": [\"_id\": \"$partition\", \"numItems\": [\"$sum\": 1]]]] collection.aggregate(pipeline: pipeline) { result in     switch result {     case .failure(let error):         print(\"Failed to aggregate: \\(error.localizedDescription)\")         return     case .success(let results):         print(\"Successfully ran the aggregation.\")         for result in results {             print(result)         }     } } \n``` Running this snippet produces this output: ``` Successfully ran the aggregation. [\"numItems\": Optional(RealmSwift.AnyBSON.int64(6)), \"_id\": Optional(RealmSwift.AnyBSON.string(\"Store 43\"))] [\"numItems\": Optional(RealmSwift.AnyBSON.int64(16)), \"_id\": Optional(RealmSwift.AnyBSON.string(\"Store 42\"))] [\"_id\": Optional(RealmSwift.AnyBSON.string(\"Store 47\")), \"numItems\": Optional(RealmSwift.AnyBSON.int64(7))] (...more results...) \n``` ### Project Document Fields You can use the [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) stage to include or omit specific fields from documents or to calculate new fields using[aggregation operators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). Projections work in two ways: * Specify that you want to include fields by using a `1`. This has the side-effect of implicitly excluding all unspecified fields.\n* Specify that you want to exclude fields by using a `0`. This has the side-effect of implicitly including all unspecified fields. These two methods of projection are mutually exclusive. If you specify fields to include, you cannot also specify fields to exclude, and vice versa. ## Note The `_id` field is a special case: it is always included in every query unless explicitly specified otherwise. For this reason, you_can_ exclude the `_id` field with a `0` value while simultaneously including other fields, like `_partition`, with a `1`. Only the special case of exclusion of the `_id` field allows both exclusion and inclusion in one `$project` stage. The following `$project` stage omits the `_id` field, includes the `name` field, and creates a new field named `storeNumber`. The `storeNumber` is generated using two aggregation operators: 1. `$split` separates the `partition` value into two string segments surrounding the space character. For example, the value \"Store 42\" split in this way returns an array with two elements: \"Store\" and \"42\".\n2. `$arrayElemAt` selects a specific element from an array based on the second argument. In this case, the value `1` selects the second element from the array generated by the `$split` operator since arrays index from `0`. For example, the value \\[\"Store\", \"42\"\\] passed to this operation would return a value of \"42\". ```swift let pipeline: [Document] = [[\"$project\": [\"_id\": 0, \"name\": 1, \"storeNumber\": [\"$arrayElemAt\": [[\"$split\": [\"$partition\", \" \"]], 1]]]]] collection.aggregate(pipeline: pipeline) { result in     switch result {     case .failure(let error):         print(\"Failed to aggregate: \\(error.localizedDescription)\")         return     case .success(let results):         print(\"Successfully ran the aggregation.\")         for result in results {             print(result)         }     } } \n```\n\n ``` Successfully ran the aggregation. [\"name\": Optional(RealmSwift.AnyBSON.string(\"Maple Latte\")), \"storeNumber\": Optional(RealmSwift.AnyBSON.string(\"42\"))] [\"storeNumber\": Optional(RealmSwift.AnyBSON.string(\"42\")), \"name\": Optional(RealmSwift.AnyBSON.string(\"Americano\"))] [\"name\": Optional(RealmSwift.AnyBSON.string(\"Americano\")), \"storeNumber\": Optional(RealmSwift.AnyBSON.string(\"47\"))] (...more results...) \n``` ### Add Fields to Documents You can use the [$addFields](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/) stage to add new fields with calculated values using [aggregation operators.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/) ## Note `$addFields` is similar to [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) but does not allow you to include or omit fields. The following `$addFields` stage creates a new field named`storeNumber` where the value is the output of two aggregate operators that transform the value of the `partition` field. ```swift let pipeline: [Document] = [[\"$addFields\": [\"storeNumber\": [\"$arrayElemAt\": [[\"$split\": [\"$partition\", \" \"]], 1]]]]] collection.aggregate(pipeline: pipeline) { result in     switch result {     case .failure(let error):         print(\"Failed to aggregate: \\(error.localizedDescription)\")         return     case .success(let results):         print(\"Successfully ran the aggregation.\")         for result in results {             print(result)         }     } } \n``` Running this snippet produces this output: ``` Successfully ran the aggregation. [\"storeNumber\": Optional(RealmSwift.AnyBSON.string(\"42\")), \"creamer\": Optional(RealmSwift.AnyBSON.string(\"true\")), \"_id\": Optional(RealmSwift.AnyBSON.objectId(60f5f39f1eb0f39071acef87)), \"name\": Optional(RealmSwift.AnyBSON.string(\"Maple Latte\")), \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Yirgacheffe, Ethiopia\")), \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\"))] [\"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Yirgacheffe, Ethiopia\")), \"storeNumber\": Optional(RealmSwift.AnyBSON.string(\"42\")), \"_id\": Optional(RealmSwift.AnyBSON.objectId(6102b91aaa4f3fc37642119e)), \"name\": Optional(RealmSwift.AnyBSON.string(\"Maple Latte\")), \"creamer\": Optional(RealmSwift.AnyBSON.string(\"true\")), \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\"))] [\"creamer\": Optional(RealmSwift.AnyBSON.string(\"false\")), \"_id\": Optional(RealmSwift.AnyBSON.objectId(6102f577099eb9b818497908)), \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Timbio, Colombia\")), \"storeNumber\": Optional(RealmSwift.AnyBSON.string(\"42\")), \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\")), \"name\": Optional(RealmSwift.AnyBSON.string(\"Americano\"))] (...more results...) \n``` ### Unwind Array Values\n\n The following `$unwind` stage creates a new document for each element of the `items` array in each document. It also adds a field called `itemIndex` to each new document that specifies the element's position index in the original array: ```swift let pipeline: [Document] = [[\"$unwind\": [\"path\": \"$featuredInPromotions\", \"includeArrayIndex\": \"itemIndex\"]]] collection.aggregate(pipeline: pipeline) { result in     switch result {     case .failure(let error):         print(\"Failed to aggregate: \\(error.localizedDescription)\")         return     case .success(let results):         print(\"Successfully ran the aggregation.\")         for result in results {             print(\"Coffee drink: \\(result)\")         }     } } \n``` Consider this document that includes a `featuredInPromotions` array: ``` _id: 610802b44386a9ed3144447d, name: \"Maple Latte\", containsDairy:\"true\", partition:\"Store 42\", beanRegion: \"Yirgacheffe, Ethiopia\", featuredInPromotions: [    \"Spring into Spring\",    \"Tastes of Fall\",    \"Winter Delights\" ] \n``` If we apply the example `$unwind` stage to this document, the stage outputs the following three documents: ``` Successfully ran the aggregation. Coffee drink: [    \"featuredInPromotions\": Optional(RealmSwift.AnyBSON.string(\"Spring into Spring\")),    \"itemIndex\": Optional(RealmSwift.AnyBSON.int64(0)),    \"name\": Optional(RealmSwift.AnyBSON.string(\"Maple Latte\")),    \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Yirgacheffe, Ethiopia\")),    \"containsDairy\": Optional(RealmSwift.AnyBSON.string(\"true\")),    \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\")),    \"_id\": Optional(RealmSwift.AnyBSON.objectId(6108...))] Coffee drink: [    \"featuredInPromotions\": Optional(RealmSwift.AnyBSON.string(\"Tastes of Fall\")),    \"itemIndex\": Optional(RealmSwift.AnyBSON.int64(1)),    \"name\": Optional(RealmSwift.AnyBSON.string(\"Maple Latte\")),    \"containsDairy\": Optional(RealmSwift.AnyBSON.string(\"true\")),    \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Yirgacheffe, Ethiopia\")),    \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\")),    \"_id\": Optional(RealmSwift.AnyBSON.objectId(6108...))] Coffee drink: [    \"featuredInPromotions\": Optional(RealmSwift.AnyBSON.string(\"Winter Delights\")),    \"itemIndex\": Optional(RealmSwift.AnyBSON.int64(2)),    \"partition\": Optional(RealmSwift.AnyBSON.string(\"Store 42\")),    \"containsDairy\": Optional(RealmSwift.AnyBSON.string(\"true\")),    \"beanRegion\": Optional(RealmSwift.AnyBSON.string(\"Yirgacheffe, Ethiopia\")),    \"_id\": Optional(RealmSwift.AnyBSON.objectId(6108...)),    \"name\": Optional(RealmSwift.AnyBSON.string(\"Maple Latte\"))] \n``` You could then `$group` by the value of `featuredInPromotions` and `$sum`the number of coffee drinks in each promotion as in the [group documents example](#std-label-ios-mongodb-aggregate-group), or perform other calculations or transformations based on your data.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/swift/crud/update/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Update - Swift SDK On this page * [Update Realm Objects](#update-realm-objects)\n* [About The Examples On This Page](#about-the-examples-on-this-page)\n* [Update an Object](#update-an-object)\n* [Update Properties with Key-value Coding](#update-properties-with-key-value-coding)\n* [Upsert an Object](#upsert-an-object)\n* [Update a Map/Dictionary](#update-a-map-dictionary)\n* [Update a MutableSet Property](#update-a-mutableset-property)\n* [Update an AnyRealmValue Property](#update-an-anyrealmvalue-property)\n* [Update an Embedded Object Property](#update-an-embedded-object-property)\n* [Overwrite an Embedded Object](#overwrite-an-embedded-object)\n* [Update Properties through Class Projections](#update-properties-through-class-projections)\n* [Change Class Projection Properties](#change-class-projection-properties) ## Update Realm Objects Updates to Realm Objects must occur within write transactions. For more information about write trasactions, see: [Key Concept: Transactions.](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-write-transactions) ### About The Examples On This Page The examples on this page use the following models: ### Update an Object You can modify properties of a Realm object inside of a write transaction in the same way that you would update any other Swift or Objective-C object. ## Tip ### Update Related and Embedded Objects To update a property of an [embedded object](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-define-an-embedded-object-property) or a [related object](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-declare-relationship-properties), modify the property with dot-notation or bracket-notation as if it were in a regular, nested object. ### Update Properties with Key-value Coding `Object`, `Result`, and `List` all conform to[key-value coding](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/). This can be useful when you need to determine which property to update at runtime. Applying KVC to a collection is a great way to update objects in bulk. Avoid the overhead of iterating over a collection while creating accessors for every item. `| let realm = try! Realm()                           |\n| -------------------------------------------------- |\n| let allDogs = realm.objects(Dog.self)              |\n| try! realm.write {                                 |\n| allDogs.first?.setValue(\"Sparky\", forKey: \"name\")  |\n| // Move the dogs to Toronto for vacation           |\n| allDogs.setValue(\"Toronto\", forKey: \"currentCity\") |\n| }                                                  | ` You can also add values for embedded objects or relationships this way. In this example, we add a collection to an object's list property: ### Upsert an Object An **upsert** either inserts or updates an object depending on whether the object already exists. Upserts require the data model to have a[primary key.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-specify-a-primary-key) You can also partially update an object by passing the primary key and a subset of the values to update: ### Update a Map/Dictionary\n\n ```swift let realm = try! Realm() // Find the dog we want to update let wolfie = realm.objects(Dog.self).where {     $0.name == \"Wolfie\" }.first! print(\"Wolfie's favorite park in New York is: \\(wolfie.favoriteParksByCity[\"New York\"])\") XCTAssertTrue(wolfie.favoriteParksByCity[\"New York\"] == \"Domino Park\") // Update values for keys, or add values if the keys do not currently exist try! realm.write {     wolfie.favoriteParksByCity[\"New York\"] = \"Washington Square Park\"     wolfie.favoriteParksByCity.updateValue(\"A Street Park\", forKey: \"Boston\")     wolfie.favoriteParksByCity.setValue(\"Little Long Pond\", forKey: \"Seal Harbor\") } XCTAssertTrue(wolfie.favoriteParksByCity[\"New York\"] == \"Washington Square Park\") \n``` ### Update a MutableSet Property You can `insert` elements into a [MutableSet](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/MutableSet.html) during write transactions to add them to the property. If you are working with multiple sets, you can also insert or remove set elements contained in one set from the other set. Alternately, you can mutate a set to contain only the common elements from both. ```swift let realm = try! Realm() // Record a dog's name, current city, and store it to the cities visited. let dog = Dog() dog.name = \"Maui\" dog.currentCity = \"New York\" try! realm.write {     realm.add(dog)     dog.citiesVisited.insert(dog.currentCity) } // Update the dog's current city, and add it to the set of cities visited. try! realm.write {     dog.currentCity = \"Toronto\"     dog.citiesVisited.insert(dog.currentCity) } XCTAssertEqual(dog.citiesVisited.count, 2) // If you're operating with two sets, you can insert the elements from one set into another set. // The dog2 set contains one element that isn't present in the dog set. try! realm.write {     dog.citiesVisited.formUnion(dog2.citiesVisited) } XCTAssertEqual(dog.citiesVisited.count, 3) // Or you can remove elements that are present in the second set. This removes the one element // that we added above from the dog2 set. try! realm.write {     dog.citiesVisited.subtract(dog2.citiesVisited) } XCTAssertEqual(dog.citiesVisited.count, 2) // If the sets contain common elements, you can mutate the set to only contain those common elements. // In this case, the two sets contain no common elements, so this set should now contain 0 items. try! realm.write {     dog.citiesVisited.formIntersection(dog2.citiesVisited) } XCTAssertEqual(dog.citiesVisited.count, 0) \n``` ### Update an AnyRealmValue Property You can update an AnyRealmValue property through assignment, but you must specify the type of the value when you assign it. The Realm Swift SDK provides an [AnyRealmValue enum](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/AnyRealmValue.html) that iterates through all of the types the AnyRealmValue can store. ```swift let realm = try! Realm() // Get a dog to update let rex = realm.objects(Dog.self).where {     $0.name == \"Rex\" }.first! try! realm.write {     // As with creating an object with an AnyRealmValue, you must specify the     // type of the value when you update the property.     rex.companion = .object(Dog(value: [\"name\": \"Regina\"])) } \n``` ### Update an Embedded Object Property To update a property in an embedded object, modify the property in a write transaction. If the embedded object is null, updating an embedded object property has no effect. ### Overwrite an Embedded Object\n\n ## Update Properties through Class Projections ### Change Class Projection Properties You can make changes to a class projection's properties in a write transaction. ```swift // Retrieve all class projections of the given type `PersonProjection` // and filter for the first class projection where the `firstName` property // value is \"Jason\" let person = realm.objects(PersonProjection.self).first(where: { $0.firstName == \"Jason\" })! // Update class projection property in a write transaction try! realm.write {     person.firstName = \"David\" } \n``` ← [CRUD - Read - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/read/ \"Previous Section\")[CRUD - Delete - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/crud/read/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Read - Swift SDK On this page * [Key Concept: Read from Realm Database](#key-concept--read-from-realm-database)\n* [Read Characteristics](#read-characteristics)\n* [Limiting Query Results](#limiting-query-results)\n* [Pagination](#pagination)\n* [Read Realm Objects](#read-realm-objects)\n* [About The Examples On This Page](#about-the-examples-on-this-page)\n* [Find a Specific Object by Primary Key](#find-a-specific-object-by-primary-key)\n* [Query All Objects of a Given Type](#query-all-objects-of-a-given-type)\n* [Filter Queries Based on Object Properties](#filter-queries-based-on-object-properties)\n* [Filter on Object ID Properties](#filter-on-object-id-properties)\n* [Query a Relationship](#query-a-relationship)\n* [Query an Inverse Relationship](#query-an-inverse-relationship)\n* [Query a Collection on Embedded Object Properties](#query-a-collection-on-embedded-object-properties)\n* [Query a Map Property](#query-a-map-property)\n* [Query a MutableSet Property](#query-a-mutableset-property)\n* [Read and Query AnyRealmValue Property](#read-and-query-anyrealmvalue-property)\n* [Query a Custom Persistable Property](#query-a-custom-persistable-property)\n* [Sort Query Results](#sort-query-results)\n* [Section Query Results](#section-query-results)\n* [Aggregate Data](#aggregate-data)\n* [Chain Queries](#chain-queries)\n* [Query Class Projections](#query-class-projections) ## Key Concept: Read from Realm Database A read from a realm generally consists of the following steps: * Get all [objects](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-realm-objects) of a certain type from the realm.\n* Optionally, [filter](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-filter-data) the results.\n* Optionally, [sort](#std-label-ios-sort-query-results) the results.\n* Alternately, get all objects of a certain type, [divided into sections](#std-label-ios-section-query-results). As with regular results, you can filter and sort sectioned results. Query, filter, and sort operations return either a [results or SectionedResults collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-results-collections). These collections are live, meaning they always contain the latest results of the associated query. ### Read Characteristics When you design your app's data access patterns around the following three key characteristics of reads in Realm Database, you can be confident you are reading data as efficiently as possible. #### Results Are Not Copies Results to a query are not copies of your data: modifying the results of a query will modify the data on disk directly. This memory mapping also means that results are**live**: that is, they always reflect the current state on disk. See also: [Collections are Live.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-live-collections) #### Results Are Lazy Realm Database only runs a query when you actually request the results of that query. This lazy evaluation enables you to write elegant, highly performant code for handling large data sets and complex queries. You can [chain several filter and sort operations](#std-label-ios-chain-queries) without requiring extra work to process the intermediate state. #### References Are Retained\n\n A **direct reference**, or pointer, allows you to access a related object's properties directly through the reference. Other databases typically copy objects from database storage into application memory when you need to work with them directly. Because application objects contain direct references, you are left with a choice: copy the object referred to by each direct reference out of the database in case it's needed, or just copy the foreign key for each object and query for the object with that key if it's accessed. If you choose to copy referenced objects into application memory, you can use up a lot of resources for objects that are never accessed, but if you choose to only copy the foreign key, referenced object lookups can cause your application to slow down. Realm Database bypasses all of this using zero-copy live objects. Realm object accessors point directly into database storage using memory mapping, so there is no distinction between the objects in Realm Database and the results of your query in application memory. Because of this, you can traverse direct references across an entire realm from any query result. ### Limiting Query Results As a result of lazy evaluation, you do not need any special mechanism to limit query results with Realm Database. For example, if your query matches thousands of objects, but you only want to load the first ten, simply access only the first ten elements of the results collection. ### Pagination Thanks to lazy evaluation, the common task of pagination becomes quite simple. For example, suppose you have a results collection associated with a query that matches thousands of objects in your realm. You display one hundred objects per page. To advance to any page, simply access the elements of the results collection starting at the index that corresponds to the target page. ## Read Realm Objects ### About The Examples On This Page The examples on this page use the following models: ### Find a Specific Object by Primary Key ### Query All Objects of a Given Type ### Filter Queries Based on Object Properties A filter selects a subset of results based on the value(s) of one or more object properties. Realm Database provides a full-featured[query engine](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-client-query-engine) that you can use to define filters. ## Tip ### Filter on Related and Embedded Object Properties To filter a query based on a property of an [embedded object](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-define-an-embedded-object-property) or a [related object](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-declare-relationship-properties), use dot-notation as if it were in a regular, nested object. ### Filter on Object ID Properties The types in your predicate must match the types of the properties. Avoid comparing[ObjectId](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/ObjectId.html) properties to strings, as Realm Database does not automatically convert strings to ObjectIds. ### Query a Relationship You can query through a relationship the same way you would access a member of a regular Swift or Objective-C object. ### Query an Inverse Relationship You can query through an inverse relationship the same way you would access a member of a regular Swift or Objective-C object. ### Query a Collection on Embedded Object Properties Use dot notation to filter or sort a [collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections) of objects based on an embedded object property value: ## Note It is not possible to query embedded objects directly. Instead, access embedded objects through a query for the parent object type. ### Query a Map Property You can iterate and check the values of a realm [map](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/Map.html)as you would a standard [Dictionary:](https://developer.apple.com/documentation/swift/dictionary)\n\n ` ### Query a MutableSet Property You can query a [MutableSet](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/MutableSet.html) to check if it contains an element. If you are working with multiple sets, you can check for the intersection of two sets, or check whether one set is a subset of the other set. ```swift let realm = try! Realm() // Find dogs who have visited New York let newYorkDogs = realm.objects(Dog.self).where {     $0.citiesVisited.contains(\"New York\") } // Get some information about the cities they have visited for dog in newYorkDogs {     print(\"Cities \\(dog.name) has visited: \\(dog.citiesVisited)\") } // Check whether two dogs have visited some of the same cities. // Use \"intersects\" to find out whether the values of the two sets share common elements. let isInBothCitiesVisited = (dog.citiesVisited.intersects(dog2.citiesVisited)) print(\"The two dogs have visited some of the same cities: \\(isInBothCitiesVisited)\") // Prints \"The two dogs have visited some of the same cities: true\" // Or you can check whether a set is a subset of another set. In this example, // the first dog has visited \"New York\" and \"Toronto\", while dog2 has visited both of // those but also \"Toronto\" and \"Boston\". let isSubset = (dog.citiesVisited.isSubset(of: dog2.citiesVisited)) print(\"\\(dog.name)'s set of cities visited is a subset of \\(dog2.name)'s: \\(isSubset)\") // Prints \"Maui's set of cities visited is a subset of Lita's: true\" \n``` ### Read and Query AnyRealmValue Property When you read an AnyRealmValue property, check the value's type before doing anything with it. The Realm Swift SDK provides an [AnyRealmValue enum](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/AnyRealmValue.html) that iterates through all of the types the AnyRealmValue can store. ```swift let realm = try! Realm() let dogs = realm.objects(Dog.self) for dog in dogs {     // Verify the type of the ``AnyRealmProperty`` when attempting to get it. This     // returns an object whose property contains the matched type.     // If you only care about one type, check for that type.     if case let .string(companion) = dog.companion {         print(\"\\(dog.name)'s companion is: \\(companion)\")         // Prints \"Wolfie's companion is: Fluffy the Cat\"     }     // Or if you want to do something with multiple types of data     // that could be in the value, switch on the type.     switch dog.companion {     case .string:         print(\"\\(dog.name)'s companion is: \\(dog.companion)\")         // Prints \"Wolfie's companion is: string(\"Fluffy the Cat\")     case .object:         print(\"\\(dog.name)'s companion is: \\(dog.companion)\")         // Prints \"Fido's companion is: object(Dog { name = Spot })\"     case .none:         print(\"\\(dog.name) has no companion\")         // Prints \"Rex has no companion\" and \"Spot has no companion\"     default:         print(\"\\(dog.name)'s companion is another type.\")     } } \n``` You can [compare](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-filter-data-operators) these mixed value types: * Numeric: int, bool, float, double, decimal\n* Byte-based: string, binary\n* Time-based: timestamp, objectId When using the `AnyRealmValue` mixed data type, keep these things in mind:\n\n ### Query a Custom Persistable Property When you use [type projection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-type-projection) to map unsupported types to supported types, accessing those properties is often based on the persisted type. #### Queries on Realm Objects When working with projected types, queries operate on the persisted type. However, you can use the mapped types interchangeably with the persisted types in arguments in most cases. The exception is queries on embedded objects. ## Tip Projected types support [sorting and aggregates](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-filter-data) where the persisted type supports them. ```swift let akcClub = realm.objects(Club.self).where {     $0.name == \"American Kennel Club\" }.first! // You can use type-safe expressions to check for equality XCTAssert(akcClub.url == URL(string: \"https://akc.org\")!) let clubs = realm.objects(Club.self) // You can use the persisted property type in NSPredicate query expressions let akcByUrl = clubs.filter(\"url == 'https://akc.org'\").first! XCTAssert(akcByUrl.name == \"American Kennel Club\") \n``` #### Queries on Embedded Objects You can query embedded types on the supported property types within the object using memberwise equality. Object link properties support equality comparisons, but do not support memberwise comparisons. You can query embedded objects for memberwise equality on all primitive types. You cannot perform memberwise comparison on objects and collections. #### Dynamic APIs Because the schema has no concept of custom type mappings, reading data via any of the dynamic APIs gives the underlying persisted type. Realm does support writing mapped types via a dynamic API, and converts the projected type to the persisted type. The most common use of the dynamic APIs is migration. You can write projected types during migration, and Realm converts the projected type to the persisted type. However, reading data during a migration gives the underlying persisted type. ## Sort Query Results A sort operation allows you to configure the order in which Realm Database returns queried objects. You can sort based on one or more properties of the objects in the results collection. Realm Database only guarantees a consistent order of results if you explicitly sort them. ## Tip ### Sort on Related and Embedded Object Properties To sort a query based on a property of an [embedded object](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-define-an-embedded-object-property) or a [related object](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-declare-relationship-properties), use dot-notation as if it were in a regular, nested object. ## Note String sorting and case-insensitive queries are only supported for character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A', and 'Latin Extended B' (UTF-8 range 0-591). ## Section Query Results You can split results into individual sections. Each section corresponds to a key generated from a property on the object it represents. For example, you might add a computed variable to your object to get the first letter of the `name` property: ```swift // Computed variable that is not persisted, but only // used to section query results. var firstLetter: String {     return name.first.map(String.init(_:)) ?? \"\" } \n``` Then, you can create a [SectionedResults](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/SectionedResults.html)type-safe collection for that object, and use it to retrieve objects sectioned by that computed variable: ```swift var dogsByFirstLetter: SectionedResults<String, Dog> dogsByFirstLetter = realm.objects(Dog.self).sectioned(by: \\.firstLetter, ascending: true) \n``` You can get a count of the sections, get a list of keys, or access an individual[ResultSection](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ResultsSection.html) by index: ```swift let realm = try! Realm() var dogsByFirstLetter: SectionedResults<String, Dog>\n\n // You can get a count of the sections in the SectionedResults let sectionCount = dogsByFirstLetter.count // Get an array containing all section keys for objects that match the query. let sectionKeys = dogsByFirstLetter.allKeys // This example realm contains 4 dogs, \"Rex\", \"Wolfie\", \"Fido\", \"Spot\". // Prints [\"F\", \"R\", \"S\", \"W\"] print(sectionKeys) // Get a specific key by index position let sectionKey = dogsByFirstLetter[0].key // Prints \"Key for index 0: F\" print(\"Key for index 0: \\(sectionKey)\") // You can access Results Sections by the index of the key you want in SectionedResults. // \"F\" is the key at index position 0. When we access this Results Section, we get dogs whose name begins with \"F\". let dogsByF = dogsByFirstLetter[0] // Prints \"Fido\" print(dogsByF.first?.name) \n``` You can also section using a callback. This enables you to section a collection of primitives, or have more control over how the section key is generated. ```swift let realm = try! Realm() let results = realm.objects(Dog.self) let sectionedResults = results.sectioned(by: { String($0.name.first!) },                                          sortDescriptors: [SortDescriptor.init(keyPath: \"name\", ascending: true)]) let sectionKeys = sectionedResults.allKeys \n``` You can [observe](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-register-a-collection-change-listener) `SectionedResults` and `ResultsSection` instances, and both conform to[ThreadConfined.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Protocols/ThreadConfined.html) ## Aggregate Data You can use Realm's aggregation operators for sophisticated queries against list properties. ## Chain Queries Because [results are lazily evaluated](#std-label-ios-results-are-lazy), you can chain several queries together. Unlike traditional databases, this does not require a separate trip to the database for each successive query. ## Example To get a result set for tan dogs, and tan dogs whose names start with 'B', chain two queries like this: ## Query Class Projections To query for [class projections](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-define-a-class-projection) in a realm, pass the metatype instance `YourProjectionName.self` to[Realm.objects(\\_:)](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V7objectsyAA7ResultsVyxGxmSo0aB6ObjectCRbzlF). This returns a [Results](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Results.html) object representing all of the class projection objects in the realm. ```swift // Retrieve all class projections of the given type `PersonProjection` let people = realm.objects(PersonProjection.self) // Use projection data in your view print(people.first?.firstName) print(people.first?.homeCity) print(people.first?.firstFriendsName) \n``` ## Tip Don't do derived queries on top of class projection results. Instead, run a query against the Realm object directly and then project the result. If you try to do a derived query on top of class projection results, querying a field with the same name and type as the original object works, but querying a field with a name or type that isn't in the original object fails. ← [CRUD - Create - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/create/ \"Previous Section\")[CRUD - Update - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/update/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/crud/threading/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Threading - Swift SDK On this page * [Overview](#overview)\n* [Three Rules to Follow](#three-rules-to-follow)\n* [Perform a Background Write](#perform-a-background-write)\n* [Wait for Async Writes to Complete](#wait-for-async-writes-to-complete)\n* [Commit or Cancel an Async Write](#commit-or-cancel-an-async-write)\n* [Communication Across Threads](#communication-across-threads)\n* [Create a Serial Queue to use Realm on a Background Thread](#create-a-serial-queue-to-use-realm-on-a-background-thread)\n* [Pass Instances Across Threads](#pass-instances-across-threads)\n* [Use the Same Realm Across Threads](#use-the-same-realm-across-threads)\n* [Refreshing Realms](#refreshing-realms)\n* [Frozen Objects](#frozen-objects)\n* [Realm's Threading Model in Depth](#realm-s-threading-model-in-depth)\n* [Compared and Contrasted with Git](#compared-and-contrasted-with-git)\n* [Internal Structure](#internal-structure)\n* [Summary](#summary) ## Overview To make your iOS and tvOS apps fast and responsive, you must balance the computing time needed to lay out the visuals and handle user interactions with the time needed to process your data and run your business logic. Typically, app developers spread this work across multiple threads: the main or UI thread for all of the user interface-related work, and one or more background threads to compute heavier workloads before sending it to the UI thread for presentation. By offloading heavy work to background threads, the UI thread can remain highly responsive regardless of the size of the workload. But it can be notoriously difficult to write thread-safe, performant, and maintainable multithreaded code that avoids issues like deadlocking and race conditions. Realm aims to simplify this for you. ## Tip ### See also:  As of 10.26.0, Realm provides async write methods to perform background writes. See: [Perform a Background Write](#std-label-ios-async-write). With async write, you don't need to pass a [thread-safe reference](#std-label-ios-thread-safe-reference) or [frozen objects](#std-label-ios-frozen-objects)across threads. ## Three Rules to Follow Before exploring Realm's tools for multithreaded apps, you need to understand and follow these three rules: Don't lock to read: Realm Database's [Multiversion Concurrency Control (MVCC)](#std-label-ios-mvcc)architecture eliminates the need to lock for read operations. The values you read will never be corrupted or in a partially-modified state. You can freely read from the same Realm file on any thread without the need for locks or mutexes. Unnecessarily locking would be a performance bottleneck since each thread might need to wait its turn before reading. Avoid synchronous writes on the UI thread if you write on a background thread: You can write to a Realm file from any thread, but there can be only one writer at a time. Consequently, synchronous write transactions block each other. A synchronous write on the UI thread may result in your app appearing unresponsive while it waits for a write on a background thread to complete.[Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) writes on a background thread, so you should avoid synchronous writes on the UI thread with synced realms. Don't pass live objects, collections, or realms to other threads: Live objects, collections, and realm instances are**thread-confined**: that is, they are only valid on the thread on which they were created. Practically speaking, this means you cannot pass live instances to other threads. However, Realm Database offers several mechanisms for[sharing objects across threads.](#std-label-ios-communication-across-threads) ## Tip ### See also:  [Realms: File Size](https://mongodb.com/docs/realm/sdk/swift/realm-files/compacting/#std-label-ios-file-size) ## Perform a Background Write\n\n You can add, modify, or delete objects in the background using[writeAsync.](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V10writeAsync%5F10onCompletes6UInt32Vyyc%5Fys5Error%5FpSgcSgtF) With async write, you don't need to pass a [thread-safe reference](#std-label-ios-thread-safe-reference) or [frozen objects](#std-label-ios-frozen-objects)across threads. Instead, call `realm.writeAsync`. You can provide a completion block for the method to execute on the source thread after the write completes or fails. Things to consider when performing background writes: * Async writes block closing or invalidating the realm\n* You can explicitly commit or cancel transactions\n\n ` ### Wait for Async Writes to Complete The SDK provides a `Bool` to signal whether the realm is currently performing an async write. The[isPerformingAsynchronousWriteOperations](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V39isPerformingAsynchronousWriteOperationsSbvp)variable becomes `true` after a call to one of: * `writeAsync`\n* `beginAsyncWrite`\n* `commitAsyncWrite` It remains true until all scheduled async write operations have completed. While this is true, this blocks closing or [invalidating](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V10invalidateyyF) the realm. ### Commit or Cancel an Async Write To complete an async write, you or the SDK must call either: * [commitAsyncWrite](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V16commitAsyncWrite13allowGrouping%5Fs6UInt32VSb%5Fys5Error%5FpSgcSgtF)\n* [cancelAsyncWrite](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V16cancelAsyncWriteyys6UInt32VKF) When you use the `writeAsync` method, the SDK handles committing or canceling the transaction. This provides the convenience of the async write without the need to manually keep state tied to the scope of the object. However, while in the writeAsync block, you _can_ explicitly call`commitAsyncWrite` or `cancelAsyncWrite`. If you return without calling one of these methods, `writeAsync` either: * Commits the write after executing the instructions in the write block\n* Returns an error In either case, this completes the `writeAsync` operation. For more control over when to commit or cancel the async write transaction, use the `beginAsyncWrite` method. When you use this method, you must explicitly commit the transactions. Returning without committing an async write cancels the transaction. `beginAsyncWrite` returns an ID that you can pass to `cancelAsyncWrite`. `commitAsyncWrite` asynchronously commits a write transaction. This is the step that persists the data to the realm. `commitAsyncWrite` can take an `onComplete` block. . This block executes on the source thread once the commit completes or fails with an error. Calling `commitAsyncWrite` immediately returns. This allows the caller to proceed while the SDK performs the I/O on a background thread. This method returns an ID that you can pass to `cancelAsyncWrite`. This cancels the pending invocation of the completion block. It does not cancel the commit itself. You can group sequential calls to `commitAsyncWrite`. Batching these calls improves write performance; particularly when the batched transactions are small. To permit grouping transactions, set the `isGroupingAllowed`parameter to `true`. You can call `cancelAsyncWrite` on either `beginAsyncWrite` or`commitAsyncWrite`. When you call it on `beginAsyncWrite`, this cancels the entire write transaction. When you call it on `commitAsyncWrite`, this cancels only an `onComplete` block you may have passed to`commitAsyncWrite`. It does not cancel the commit itself. You need the ID of the `beginAsyncWrite` or the `commitAsyncWrite` you want to cancel. ## Communication Across Threads To access the same Realm file from different threads, you must instantiate a realm instance on every thread that needs access. As long as you specify the same configuration, all realm instances will map to the same file on disk. One of the key rules when working with Realm Database in a multithreaded environment is that objects are thread-confined: **you cannot access the instances of a realm, collection, or object that originated on other threads.**Realm Database's [Multiversion Concurrency Control (MVCC)](#std-label-ios-mvcc)architecture means that there could be many active versions of an object at any time. Thread-confinement ensures that all instances in that thread are of the same internal version.\n\n * To modify an object on two threads, [query](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-client-query-engine)for the object on both threads.\n* To react to changes made on any thread, use Realm Database's[notifications.](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-react-to-changes)\n* To see changes that happened on another thread in the current thread's realm instance, [refresh](#std-label-ios-refreshing-realms) your realm instance.\n* To send a fast, read-only view of the object to other threads,[\"freeze\"](#std-label-ios-frozen-objects) the object.\n* To keep and share many read-only views of the object in your app, copy the object from the realm.\n* To share an instance of a realm or specific object with another thread, share a [thread\\_safe\\_reference](#std-label-ios-thread-safe-reference) to the realm instance or object. ### Create a Serial Queue to use Realm on a Background Thread When using Realm on a background thread, create a serial queue. Realm Database does not support using realms in concurrent queues, such as the `global()`queue. ```swift // Initialize a serial queue, and // perform realm operations on it let serialQueue = DispatchQueue(label: \"serial-queue\") serialQueue.async {     let realm = try! Realm(configuration: .defaultConfiguration, queue: serialQueue)     // Do something with Realm on the non-main thread } \n``` ### Pass Instances Across Threads Instances of `Realm`, `Results`, `List`, and managed `Objects`are _thread-confined_. That means you may only use them on the thread where you created them. However, Realm provides a mechanism called**thread-safe references** that allows you to copy an instance created on one thread to another thread. #### Sendable Conformance _New in version 10.20.0_: @ThreadSafe wrapper and ThreadSafeReference conform to `Sendable` If you are using Swift 5.6 or higher, both the [@ThreadSafe property wrapper](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes.html#/s:10RealmSwift10ThreadSafeC) and[ThreadSafeReference](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ThreadSafeReference.html#/s:10RealmSwift19ThreadSafeReferenceV2toACyxGx%5Ftcfc)conform to [Sendable.](https://developer.apple.com/documentation/swift/sendable) #### Use the @ThreadSafe Wrapper _New in version 10.17.0_. You can pass thread-confined instances to another thread as follows: 1. Use the `@ThreadSafe` property wrapper to declare a variable that references the original object. By definition, `@ThreadSafe`\\-wrapped variables are always optional.\n2. Pass the `@ThreadSafe`\\-wrapped variable to the other thread.\n3. Use the `@ThreadSafe`\\-wrapped variable as you would any optional. If the referenced object is removed from the realm, the referencing variable becomes nil. ```swift let realm = try! Realm() let person = Person(name: \"Jane\") try! realm.write {     realm.add(person) } // Create thread-safe reference to person @ThreadSafe var personRef = person // @ThreadSafe vars are always optional. If the referenced object is deleted, // the @ThreadSafe var will be nullified. print(\"Person's name: \\(personRef?.name ?? \"unknown\")\") // Pass the reference to a background thread DispatchQueue(label: \"background\", autoreleaseFrequency: .workItem).async {     let realm = try! Realm()     try! realm.write {         // Resolve within the transaction to ensure you get the         // latest changes from other threads. If the person         // object was deleted, personRef will be nil.         guard let person = personRef else {             return // person was deleted         }\n\n     } } \n``` Another way to work with an object on another thread is to query for it again on that thread. But if the object does not have a [primary key](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-ios-find-a-specific-object-by-primary-key), it is not trivial to query for it. You can use the `@ThreadSafe` wrapper on any object, regardless of whether it has a primary key. ## Example The following example shows how to use `@ThreadSafe` on a function parameter. This is useful for functions that may run asynchronously or on another thread. ## Tip If your app accesses Realm in an `async/await` context, mark the code with `@MainActor` to avoid threading-related crashes. ```swift func someLongCallToGetNewName() async -> String {     return \"Janet\" } @MainActor func loadNameInBackground(@ThreadSafe person: Person?) async {     let newName = await someLongCallToGetNewName()     let realm = try! await Realm()     try! realm.write {         person?.name = newName     } } @MainActor func createAndUpdatePerson() async {     let realm = try! await Realm()         let person = Person(name: \"Jane\")     try! realm.write {         realm.add(person)     }     await loadNameInBackground(person: person) } await createAndUpdatePerson() \n``` #### Use ThreadSafeReference (Legacy Swift / Objective-C) Before Realm Swift SDK version 10.17.0 or in Objective-C, you can pass thread-confined instances to another thread as follows: 1. Initialize a [ThreadSafeReference](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/ThreadSafeReference.html) with the thread-confined object.\n2. Pass the reference to the other thread or queue.\n3. Resolve the reference on the other thread's realm by calling [Realm.resolve(\\_:)](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V7resolveyxSgAA19ThreadSafeReferenceVyxGAA0D8ConfinedRzlF). Use the returned object as normal. ## Important You must resolve a `ThreadSafeReference` exactly once. Otherwise, the source realm will remain pinned until the reference gets deallocated. For this reason, `ThreadSafeReference` should be short-lived. ```swift let person = Person(name: \"Jane\") let realm = try! Realm() try! realm.write {     realm.add(person) } // Create thread-safe reference to person let personRef = ThreadSafeReference(to: person) // Pass the reference to a background thread DispatchQueue(label: \"background\", autoreleaseFrequency: .workItem).async {     let realm = try! Realm()     try! realm.write {         // Resolve within the transaction to ensure you get the latest changes from other threads         guard let person = realm.resolve(personRef) else {             return // person was deleted         }         person.name = \"Jane Doe\"     } } \n``` Another way to work with an object on another thread is to query for it again on that thread. But if the object does not have a [primary key](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-ios-find-a-specific-object-by-primary-key), it is not trivial to query for it. You can use `ThreadSafeReference` on any object, regardless of whether it has a primary key. You can also use it with lists and results. The downside is that `ThreadSafeReference` requires some boilerplate. You must remember to wrap everything in a `DispatchQueue` with a properly-scoped `autoreleaseFrequency` so the objects do not linger on the background thread. So, it can be helpful to make a convenience extension to handle the boilerplate as follows: ```swift\n\n     func writeAsync<T: ThreadConfined>(_ passedObject: T, errorHandler: @escaping ((_ error: Swift.Error) -> Void) = { _ in return }, block: @escaping ((Realm, T?) -> Void)) {         let objectReference = ThreadSafeReference(to: passedObject)         let configuration = self.configuration         DispatchQueue(label: \"background\", autoreleaseFrequency: .workItem).async {             do {                 let realm = try Realm(configuration: configuration)                 try realm.write {                     // Resolve within the transaction to ensure you get the latest changes from other threads                     let object = realm.resolve(objectReference)                     block(realm, object)                 }             } catch {                 errorHandler(error)             }         }     } } \n``` This extension adds a `writeAsync()` method to the Realm class. This method passes an instance to a background thread for you. ## Example Suppose you made an email app and want to delete all read emails in the background. You can now do it with two lines of code. Note that the closure runs on the background thread and receives its own version of both the realm and passed object: ```swift let realm = try! Realm() let readEmails = realm.objects(Email.self).where {     $0.read == true } realm.writeAsync(readEmails) { (realm, readEmails) in     guard let readEmails = readEmails else {         // Already deleted         return     }     realm.delete(readEmails) } \n``` ### Use the Same Realm Across Threads You cannot share realm instances across threads. To use the same Realm file across threads, open a different realm instance on each thread. As long as you use the same[configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm/Configuration.html), all Realm instances will map to the same file on disk. ### Refreshing Realms When you open a realm, it reflects the most recent successful write commit and remains on that version until it is **refreshed**. This means that the realm will not see changes that happened on another thread until the next refresh. A realm on the UI thread -- more precisely, on any event loop thread -- automatically refreshes itself at the beginning of that thread's loop. However, you must manually refresh realm instances that do not exist on loop threads or that have auto-refresh disabled. ### Frozen Objects Live, thread-confined objects work fine in most cases. However, some apps -- those based on reactive, event stream-based architectures, for example -- need to send immutable copies around to many threads for processing before ultimately ending up on the UI thread. Making a deep copy every time would be expensive, and Realm Database does not allow live instances to be shared across threads. In this case, you can **freeze** and **thaw** objects, collections, and realms. Freezing creates an immutable view of a specific object, collection, or realm. The frozen object, collection, or realm still exists on disk, and does not need to be deeply copied when passed around to other threads. You can freely share the frozen object across threads without concern for thread issues. When you freeze a realm, its child objects also become frozen. Frozen objects are not live and do not automatically update. They are effectively snapshots of the object state at the time of freezing. Thawing an object returns a live version of the frozen object. When working with frozen objects, an attempt to do any of the following throws an exception: * Opening a write transaction on a frozen realm.\n* Modifying a frozen object.\n* Adding a change listener to a frozen realm, collection, or object.\n\n Frozen objects remain valid as long as the live realm that spawned them stays open. Therefore, avoid closing the live realm until all threads are done with the frozen objects. You can close frozen realm before the live realm is closed. ## Important ### On caching frozen objects Caching too many frozen objects can have a negative impact on the realm file size. \"Too many\" depends on your specific target device and the size of your Realm objects. If you need to cache a large number of versions, consider copying what you need out of the realm instead. #### Modify a Frozen Object To modify a frozen object, you must thaw the object. Alternately, you can query for it on an unfrozen realm, then modify it. Calling `thaw`on a live object, collection, or realm returns itself. Thawing an object or collection also thaws the realm it references. ```swift // Read from a frozen realm let frozenPeople = frozenRealm.objects(Person.self) // The collection that we pull from the frozen realm is also frozen assert(frozenPeople.isFrozen) // Get an individual person from the collection let frozenPerson = frozenPeople.first! // To modify the person, you must first thaw it // You can also thaw collections and realms let thawedPerson = frozenPerson.thaw() // Check to make sure this person is valid. An object is // invalidated when it is deleted from its managing realm, // or when its managing realm has invalidate() called on it. assert(thawedPerson?.isInvalidated == false) // Thawing the person also thaws the frozen realm it references assert(thawedPerson!.realm!.isFrozen == false) // Let's make the code easier to follow by naming the thawed realm let thawedRealm = thawedPerson!.realm! // Now, you can modify the todo try! thawedRealm.write {    thawedPerson!.name = \"John Michael Kane\" } \n``` #### Append to a Frozen Collection When you append to a frozen [collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections), you must thaw both the collection and the object that you want to append. In this example, we query for two objects in a frozen Realm: * A Person object that has a [List](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-list-collections) property of Dog objects\n* A Dog object We must thaw both objects before we can append the Dog to the Dog List collection on the Person. If we thaw only the Person object but not the Dog, Realm throws an error. The same rule applies when passing frozen objects across threads. A common case might be calling a function on a background thread to do some work instead of blocking the UI. ```swift // Get a copy of frozen objects. // Here, we're getting them from a frozen realm, // but you might also be passing them across threads. let frozenTimmy = frozenRealm.objects(Person.self).where {     $0.name == \"Timmy\" }.first! let frozenLassie = frozenRealm.objects(Dog.self).where {     $0.name == \"Lassie\" }.first! // Confirm the objects are frozen. assert(frozenTimmy.isFrozen == true) assert(frozenLassie.isFrozen == true) // Thaw the frozen objects. You must thaw both the object // you want to append and the collection you want to append it to. let thawedTimmy = frozenTimmy.thaw() let thawedLassie = frozenLassie.thaw() let realm = try! Realm() try! realm.write {     thawedTimmy?.dogs.append(thawedLassie!) } XCTAssertEqual(thawedTimmy?.dogs.first?.name, \"Lassie\") \n``` ## Realm's Threading Model in Depth Realm Database provides safe, fast, lock-free, and concurrent access across threads with its [Multiversion Concurrency Control (MVCC)](https://en.wikipedia.org/wiki/Multiversion%5Fconcurrency%5Fcontrol)architecture. ### Compared and Contrasted with Git If you are familiar with a distributed version control system like [Git](https://git-scm.com/), you may already have an intuitive understanding of MVCC. Two fundamental elements of Git are:\n\n Similarly, Realm Database has atomically-committed writes in the form of [transactions](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-write-transactions). Realm Database also has many different versions of the history at any given time, like branches. Unlike Git, which actively supports distribution and divergence through forking, a realm only has one true latest version at any given time and always writes to the head of that latest version. Realm Database cannot write to a previous version. This means your data converges on one latest version of the truth. ### Internal Structure A realm is implemented using a [B+ tree](https://en.wikipedia.org/wiki/B%2B%5Ftree) data structure. The top-level node represents a version of the realm; child nodes are objects in that version of the realm. The realm has a pointer to its latest version, much like how Git has a pointer to its HEAD commit. Realm Database uses a copy-on-write technique to ensure[isolation](https://en.wikipedia.org/wiki/Isolation%5F%28database%5Fsystems%29) and[durability](https://en.wikipedia.org/wiki/Durability%5F%28database%5Fsystems%29). When you make changes, Realm Database copies the relevant part of the tree for writing. Realm Database then commits the changes in two phases: * Realm Database writes changes to disk and verifies success.\n* Realm Database then sets its latest version pointer to point to the newly-written version. This two-step commit process guarantees that even if the write failed partway, the original version is not corrupted in any way because the changes were made to a copy of the relevant part of the tree. Likewise, the realm's root pointer will point to the original version until the new version is guaranteed to be valid. ## Example The following diagram illustrates the commit process: ![Realm Database copies the relevant part of the tree for writes, then replaces the latest version by updating a pointer.](https://mongodb.com/docs/realm/images/mvcc-diagram.png) click to enlarge 1. The realm is structured as a tree. The realm has a pointer to its latest version, V1.\n2. When writing, Realm Database creates a new version V2 based on V1\\. Realm Database makes copies of objects for modification (A 1, C 1), while links to unmodified objects continue to point to the original versions (B, D).\n3. After validating the commit, Realm Database updates the realm's pointer to the new latest version, V2\\. Realm Database then discards old nodes no longer connected to the tree. Realm Database uses zero-copy techniques like memory mapping to handle data. When you read a value from the realm, you are virtually looking at the value on the actual disk, not a copy of it. This is the basis for[live objects](https://mongodb.com/docs/realm/sdk/swift/realm-database/#std-label-ios-live-object). This is also why a realm head pointer can be set to point to the new version after the write to disk has been validated. ## Summary * Realm enables simple and safe multithreaded code when you follow three rules:  \n   * don't lock to read  \n   * avoid writes on the UI thread if you write on background threads or use [Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync)  \n   * don't pass live objects to other threads.\n* There is a proper way to share objects across threads for each use case.\n* In order to see changes made on other threads in your realm instance, you must manually **refresh** realm instances that do not exist on \"loop\" threads or that have auto-refresh disabled.\n* For apps based on reactive, event-stream-based architectures, you can**freeze** objects, collections, and realms in order to pass shallow copies around efficiently to different threads for processing.\n* Realm Database's multiversion concurrency control (MVCC) architecture is similar to Git's. Unlike Git, Realm Database has only one true latest version for each realm.\n* Realm Database commits in two stages to guarantee isolation and durability. ← [CRUD - Delete - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/delete/ \"Previous Section\")[Filter Data - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - Kotlin SDK ← [Quick Start - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/quick-start/ \"Previous Section\")[Realm Database Overview - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - Kotlin SDK MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Handle App Errors - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/errors/app/ \"Previous Section\")[Migrate from the Java SDK to the Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/migrate-from-java-sdk-to-kotlin-sdk/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync - Kotlin SDK ← [Serialization - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/serialization/ \"Previous Section\")[Sync Overview - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/sync/overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install - Kotlin SDK The Kotlin SDK supports two platforms, each with its own installation method: * [Android](https://mongodb.com/docs/realm/sdk/kotlin/install/android/#std-label-kotlin-install-android)\n* [Kotlin Multiplatform](https://mongodb.com/docs/realm/sdk/kotlin/install/kotlin-multiplatform/#std-label-kotlin-install-kotlin-multiplatform) ← [Realm Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/ \"Previous Section\")[Install (Android) - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/install/android/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Atlas App Services - Kotlin SDK ← [Subscribe to Queryable Fields - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/sync/subscribe/ \"Previous Section\")[Atlas App Services Overview - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/crud/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Delete - Swift SDK On this page * [Delete Realm Objects](#delete-realm-objects)\n* [About The Examples On This Page](#about-the-examples-on-this-page)\n* [Delete an Object](#delete-an-object)\n* [Delete Multiple Objects](#delete-multiple-objects)\n* [Delete an Object and Its Related Objects](#delete-an-object-and-its-related-objects)\n* [Delete All Objects of a Specific Type](#delete-all-objects-of-a-specific-type)\n* [Delete All Objects in a Realm](#delete-all-objects-in-a-realm)\n* [Delete Map Keys/Values](#delete-map-keys-values)\n* [Delete MutableSet Elements](#delete-mutableset-elements)\n* [Delete the Value of an AnyRealmValue](#delete-the-value-of-an-anyrealmvalue) ## Delete Realm Objects Deleting Realm Objects must occur within write transactions. For more information about write trasactions, see: [Key Concept: Transactions.](https://mongodb.com/docs/realm/sdk/swift/crud/create/#std-label-ios-write-transactions) If you want to delete the Realm file itself, see: [Delete a Realm.](https://mongodb.com/docs/realm/sdk/swift/realm-files/delete-a-realm/#std-label-swift-delete-a-realm) ## Important ### Do not use objects after delete You cannot access or modify an object after you have deleted it from a realm. If you try to use a deleted object, Realm Database throws an error. ### About The Examples On This Page The examples on this page use the following models: ### Delete an Object ### Delete Multiple Objects ### Delete an Object and Its Related Objects Sometimes, you want to delete related objects when you delete the parent object. We call this a **chaining delete**. Realm Database does not delete the related objects for you. If you do not delete the objects yourself, they remain orphaned in your realm. Whether or not this is a problem depends on your application's needs. The best way to delete dependent objects is to iterate through the dependencies and delete them before deleting the parent object. ### Delete All Objects of a Specific Type ### Delete All Objects in a Realm ### Delete Map Keys/Values You can delete [map](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/Map.html) entries in a few ways: * Use `removeObject(for:)` to remove the key and the value\n* If the dictionary's value is optional, you can set the value of the key to`nil` to keep the key.\n\n  `` ### Delete MutableSet Elements You can delete specific elements from a [MutableSet](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/MutableSet.html), or clear all of the elements from the set. If you are working with multiple sets, you can also remove elements in one set from the other set; see: [Update a MutableSet Property.](https://mongodb.com/docs/realm/sdk/swift/crud/update/#std-label-swift-update-mutableset-property) ```swift let realm = try! Realm() // Record a dog's name and list of cities he has visited. let dog = Dog() dog.name = \"Maui\" let dogCitiesVisited = [\"New York\", \"Boston\", \"Toronto\"] try! realm.write {     realm.add(dog)     dog.citiesVisited.insert(objectsIn: dogCitiesVisited) } XCTAssertEqual(dog.citiesVisited.count, 3) // Later... we decide the dog didn't really visit Toronto // since the plane just stopped there for a layover. // Remove the element from the set. try! realm.write {     dog.citiesVisited.remove(\"Toronto\") } XCTAssertEqual(dog.citiesVisited.count, 2) // Or, in the case where the person entered the data for // the wrong dog, remove all elements from the set. try! realm.write {     dog.citiesVisited.removeAll() } XCTAssertEqual(dog.citiesVisited.count, 0) \n``` ### Delete the Value of an AnyRealmValue To delete the value of an AnyRealmValue, set it to `.none`. ```swift let realm = try! Realm() // Wolfie's companion is \"Fluffy the Cat\", represented by a string. // Fluffy has gone to visit friends for the summer, so Wolfie has no companion. let wolfie = realm.objects(Dog.self).where {     $0.name == \"Wolfie\" }.first! try! realm.write {     // You cannot set an AnyRealmValue to nil; you must set it to `.none`, instead.     wolfie.companion = .none } \n``` ← [CRUD - Update - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/update/ \"Previous Section\")[Threading - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/threading/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/crud/create/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # CRUD - Create - Swift SDK On this page * [Key Concept: Transactions](#key-concept--transactions)\n* [Write Transactions](#write-transactions)\n* [Run a Transaction](#run-a-transaction)\n* [Key Concept: Interface-Driven Writes](#key-concept--interface-driven-writes)\n* [Create a New Object](#create-a-new-object)\n* [About The Examples On This Page](#about-the-examples-on-this-page)\n* [Create an Object](#create-an-object)\n* [Initialize Objects with a Value](#initialize-objects-with-a-value)\n* [Create an Object with JSON](#create-an-object-with-json)\n* [Create an Embedded Object](#create-an-embedded-object)\n* [Create an Object with a Map Property](#create-an-object-with-a-map-property)\n* [Create an Object with a MutableSet Property](#create-an-object-with-a-mutableset-property)\n* [Create an Object with an AnyRealmValue Property](#create-an-object-with-an-anyrealmvalue-property)\n* [Create an Asymmetric Object](#create-an-asymmetric-object)\n* [Copy an Object to Another Realm](#copy-an-object-to-another-realm) ## Key Concept: Transactions ### Write Transactions Realm Database uses a highly efficient storage engine to persist objects. You can **create** objects in a realm,**update** objects in a realm, and eventually **delete**objects from a realm. Because these operations modify the state of the realm, we call them writes. Realm handles writes in terms of **transactions**. A transaction is a list of read and write operations that Realm treats as a single indivisible operation. In other words, a transaction is _all or nothing_: either all of the operations in the transaction succeed or none of the operations in the transaction take effect. All writes must happen in a transaction. A realm allows only one open transaction at a time. Realm blocks other writes on other threads until the open transaction is complete. Consequently, there is no race condition when reading values from the realm within a transaction. When you are done with your transaction, Realm either**commits** it or **cancels** it: * When Realm **commits** a transaction, Realm writes all changes to disk. For synced realms, the SDK queues the change for synchronization with Atlas Device Sync.\n* When Realm **cancels** a write transaction or an operation in the transaction causes an error, all changes are discarded (or \"rolled back\"). ### Run a Transaction The Swift SDK represents each transaction as a callback function that contains zero or more read and write operations. To run a transaction, define a transaction callback and pass it to the realm's `write` method. Within this callback, you are free to create, read, update, and delete on the realm. If the code in the callback throws an exception when Realm runs it, Realm cancels the transaction. Otherwise, Realm commits the transaction immediately after the callback. ## Important ### Concurrency Concerns Since transactions block each other, it is best to avoid opening transactions on both the UI thread and a background thread. If you are using [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), avoid opening transactions on the UI thread altogether, as Realm processes synchronizations on a background thread. If a background transaction blocks your UI thread's transaction, your app may appear unresponsive. ## Example The following code shows how to run a transaction with the realm's write method. If the code in the callback throws an exception, Realm cancels the transaction. Otherwise, Realm commits the transaction. ## Key Concept: Interface-Driven Writes Realm always delivers notifications asynchronously, so they never block the UI thread. However, there are situations when the UI must reflect changes instantly. If you update the UI directly at the same time as the write, the eventual notification could double that update. This could lead to your app crashing due to inconsistent state between the UI and the backing data store. To avoid this, you can write without sending a notification to a specific handler. We call this type of transaction an **interface-driven write**. ## Example\n\n Interface-driven writes, also known as silent writes, are especially useful when using fine-grained collection notifications with a[synchronized realm](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) realm. While you use interface-driven writes for the current user's updates and update the UI immediately, the sync process can use standard notifications to update the UI. ## Tip ### See also:  [Write Silently](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/#std-label-ios-write-silently) ## Create a New Object ### About The Examples On This Page The examples on this page use the following models: ### Create an Object ### Initialize Objects with a Value You can initialize an object by passing an initializer value to[Object.init(value:)](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/Object.html#/s:So16RealmSwiftObjectC0aB0E5valueAByp%5Ftcfc). The initializer value can be a [key-value coding](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/)compliant object, a dictionary, or an array containing one element for each managed property. ## Note When using an array as an initializer value, you must include all properties in the same order as they are defined in the model. You can even initialize [related](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-client-relationships) or[embedded objects](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-embedded-objects) by nesting initializer values: #### Some Property Types are Only Mutable in a Write Transaction Some property types are only mutable in a write transaction. For example, you can instantiate an object with a [MutableSet](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-mutableset-data-type)property, but you can only set that property's value in a write transaction. You cannot initialize the object with a value for that property unless you do so inside a write transaction. ### Create an Object with JSON Realm does not directly support JSON, but you can use[JSONSerialization.jsonObject(with:options:)](https://developer.apple.com/documentation/foundation/jsonserialization/1415493-jsonobject) to convert JSON into a value that you can pass to[Realm.create(\\_:value:update:).](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V6create%5F5value6updatexxm%5FypAC12UpdatePolicyOtSo0aB6ObjectCRbzlF) Nested objects or arrays in the JSON map to [to-one](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-one-relationship) or [to-many relationships.](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-to-one-relationship) The JSON property names and types must match the destination[object schema](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-object-schemas) exactly. For example: * `float` properties must be initialized with float-backed `NSNumbers`.\n* `Date` and `Data` properties cannot be inferred from strings. Convert them to the appropriate type before passing to [Realm.create(\\_:value:update:).](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V6create%5F5value6updatexxm%5FypAC12UpdatePolicyOtSo0aB6ObjectCRbzlF)\n* Required properties cannot be `null` or missing in the JSON.\n\n ## Tip If your JSON schema doesn't exactly align with your Realm objects, consider using a third-party framework to transform your JSON. There are many model mapping frameworks that work with Realm. See a [partial list in the realm-swift repository.](https://github.com/realm/realm-swift/issues/694#issuecomment-144785299) ### Create an Embedded Object To create an embedded object, assign an instance of the embedded object to a parent object's property: ### Create an Object with a Map Property When you create an object that has a [map property](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/Map.html), you can set the values for keys in a few ways: * Set keys and values on the object and then add the object to the realm\n* Set the object's keys and values directly inside a write transaction\n* Use key-value coding to set or update keys and values inside a write transaction `| let realm = try! Realm()                                        |\n| --------------------------------------------------------------- |\n| // Record a dog's name and current city                         |\n| let dog = Dog()                                                 |\n| dog.name = \"Wolfie\"                                             |\n| dog.currentCity = \"New York\"                                    |\n| // Set map values                                               |\n| dog.favoriteParksByCity[\"New York\"] = \"Domino Park\"             |\n| // Store the data in a realm                                    |\n| try! realm.write {                                              |\n| realm.add(dog)                                                  |\n| // You can also set map values inside a write transaction       |\n| dog.favoriteParksByCity[\"Chicago\"] = \"Wiggly Field\"             |\n| dog.favoriteParksByCity.setValue(\"Bush Park\", forKey: \"Ottawa\") |\n| }                                                               | ` ### Create an Object with a MutableSet Property You can create objects that contain [MutableSet](https://www.mongodb.com/docs/realm-sdks/swift/latest/Classes/MutableSet.html) properties as you would any Realm object, but you can only mutate a MutableSet within a write transaction. This means you can only set the value(s) of a mutable set property within a write transaction. ```swift let realm = try! Realm() // Record a dog's name and current city let dog = Dog() dog.name = \"Maui\" dog.currentCity = \"New York\"\n\n // to the citiesVisited MutableSet try! realm.write {     realm.add(dog)     // You can only mutate the MutableSet in a write transaction.     // This means you can't set values at initialization, but must do it during a write.     dog.citiesVisited.insert(dog.currentCity) } // You can also add multiple items to the set. try! realm.write {     dog.citiesVisited.insert(objectsIn: [\"Boston\", \"Chicago\"]) } print(\"\\(dog.name) has visited: \\(dog.citiesVisited)\") \n``` ### Create an Object with an AnyRealmValue Property When you create an object with an [AnyRealmValue property](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-mixed-data-type), you must specify the type of the value you store in the property. The Realm Swift SDK provides an [AnyRealmValue enum](https://www.mongodb.com/docs/realm-sdks/swift/latest/Enums/AnyRealmValue.html) that iterates through all of the types the AnyRealmValue can store. Later, when you [read an AnyRealmValue](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-swift-read-anyrealmvalue-property), you must check the type before you do anything with the value. ```swift // Create a Dog object and then set its properties let myDog = Dog() myDog.name = \"Rex\" // This dog has no companion. // You can set the field's type to \"none\", which represents `nil` myDog.companion = .none // Create another Dog whose companion is a cat. // We don't have a Cat object, so we'll use a string to describe the companion. let theirDog = Dog() theirDog.name = \"Wolfie\" theirDog.companion = .string(\"Fluffy the Cat\") // Another dog might have a dog as a companion. // We do have an object that can represent that, so we can specify the // type is a Dog object, and even set the object's value. let anotherDog = Dog() anotherDog.name = \"Fido\" // Note: this sets Spot as a companion of Fido, but does not set // Fido as a companion of Spot. Spot has no companion in this instance. anotherDog.companion = .object(Dog(value: [\"name\": \"Spot\"])) // Add the dogs to the realm let realm = try! Realm() try! realm.write {     realm.add([myDog, theirDog, anotherDog]) } // After adding these dogs to the realm, we now have 4 dog objects. let dogs = realm.objects(Dog.self) XCTAssertEqual(dogs.count, 4) \n``` ## Create an Asymmetric Object _New in version 10.29.0_. You can only create an AsymmetricObject using [create(\\_ type:, value:)](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Realm.html#/s:10RealmSwift0A0V6create%5F5valueyxm%5FyptSo0aB16AsymmetricObjectCRbzlF). When you create an AsymmetricObject, it syncs unidirectionally via[Asymmetric Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) to the Atlas database linked to your Atlas App Services App. You cannot access an AsymmetricObject locally, add it to or remove it from a realm, or query for it. ```swift @MainActor func useRealm(_ asymmetricRealm: Realm, _ user: User) async {     try! asymmetricRealm.write {         asymmetricRealm.create(WeatherSensor.self,                                value: [ \"_id\": ObjectId.generate(),\n\n                                         \"temperatureInFahrenheit\": 66.7,                                         \"barometricPressureInHg\": 29.65,                                         \"windSpeedInMph\": 2                                         ])     } } \n``` You can create AsymmetricObjects for a realm initialized with a [Flexible Sync configuration](https://www.mongodb.com/docs/realm-sdks/swift/latest/Extensions/User.html#/s:So7RLMUserC10RealmSwiftE25flexibleSyncConfigurationAC0B0V0F0VyF). For more information, see: [Open a Synced Realm for Flexible Sync.](https://mongodb.com/docs/realm/sdk/swift/sync/configure-and-open-a-synced-realm/#std-label-ios-flexible-sync-open-realm) ## Copy an Object to Another Realm ## Important The `create` methods do not support handling cyclical object graphs. Do not pass in an object containing relationships involving objects that refer back to their parents, either directly or indirectly. ← [CRUD - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/ \"Previous Section\")[CRUD - Read - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/read/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/errors/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Handle Errors - Kotlin SDK On this page * [Example](#example) The Kotlin SDK uses a hierarchy of exceptions to help developers manage API call failures. There are two major categories of exceptions that your application should handle when using the Kotlin SDK: * **realm errors** occur when a read or write to realm database fails. These errors generate a[RealmException.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.exceptions/-realm-exception/index.html)\n* **app errors** occur when network communication with Atlas App Services fails. These errors generate an[AppException.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-app-exception/index.html) Some errors are _ephemeral_: they happen because of failures outside of the client or SDK's control. A failed login attempt due to a network error is an example of an ephemeral error. Other errors require logic fixes. Examples include: * writing to a realm outside of a write transaction\n* a failed login attempt due to incorrect credentials\n* deleting an object that does not exist When an ephemeral error occurs, you should retry the operation that caused the error. If the operation still fails when you retry it, investigate logic fixes. ## Example You can handle errors in the SDK with Kotlin's built-in[runCatching](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run-catching.html)API. Use the `onSuccess` and `onFailure` callbacks of the returned[Result](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/)to handle successful SDK API calls and error cases. The following example logs an anonymous user into an App. If the login attempt succeeds, we log the successful authentication attempt and transition the user to another screen. If the login attempt fails, we handle each potential error case individually: * If the user supplied invalid credentials, we log the attempt and display a popup toast encouraging the user to check their credentials.\n* If there was a problem with the network connection, we log the problem to the error log and display a popup toast encouraging the user to check their network connection and try again.\n* For all other errors, we log the problem to the error log and display a popup toast informing the user that the login attempt failed.\n\n ` ← [Call an Atlas Function - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/call-function/ \"Previous Section\")[Handle Realm Errors - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/errors/realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/sync/open-a-synced-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Open a Synced Realm - Kotlin SDK On this page * [Prerequisites](#prerequisites)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Configure a Synced Realm](#configure-a-synced-realm) ## Prerequisites Before you can access a synced realm from the client, you must: 1. [Enable sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) in the App Services UI.\n2. Install the sync distribution of the Kotlin SDK for [Android](https://mongodb.com/docs/realm/sdk/kotlin/install/android/#std-label-kotlin-install-android) or[Kotlin Multiplatform.](https://mongodb.com/docs/realm/sdk/kotlin/install/kotlin-multiplatform/#std-label-kotlin-install-kotlin-multiplatform)\n3. [Authenticate a user](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-authenticate) in your client project. ## Open a Synced Realm ## Configure a Synced Realm ← [Sync Overview - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/sync/overview/ \"Previous Section\")[Subscribe to Queryable Fields - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/sync/subscribe/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/swift/crud/filter-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Filter Data - Swift SDK On this page * [Overview](#overview)\n* [About the Examples on This Page](#about-the-examples-on-this-page)\n* [Realm Swift Query API](#realm-swift-query-api)\n* [Operators](#operators)\n* [Comparison Operators](#comparison-operators)\n* [Collections](#collections)\n* [Logical Operators](#logical-operators)\n* [String Operators](#string-operators)\n* [Aggregate Operators](#aggregate-operators)\n* [Set Operators](#set-operators)\n* [Subqueries](#subqueries)\n* [NSPredicate Queries](#nspredicate-queries)\n* [Expressions](#expressions)\n* [Dot Notation](#dot-notation)\n* [Substitutions](#substitutions)\n* [Operators](#operators-1)\n* [Comparison Operators](#comparison-operators-1)\n* [Logical Operators](#logical-operators-1)\n* [String Operators](#string-operators-1)\n* [Aggregate Operators](#aggregate-operators-1)\n* [Set Operators](#set-operators-1)\n* [Subqueries](#subqueries-1) ## Overview To filter data in your realm, you can leverage Realm Database's query engine. _New in version 10.19.0:_: Realm Swift Query API The [Realm Swift Query API](#std-label-ios-realm-swift-query-api) offers an idiomatic way for Swift developers to query data. Use Swift-style syntax to query Realm Database with the benefits of auto-completion and type safety. The Realm Swift Query API does not replace the NSPredicate Query API in newer SDK versions; instead, you can use either. For SDK versions prior to 10.19.0, or for Objective-C developers, Realm Database's query engine supports [NSPredicate Query.](#std-label-ios-nspredicate-query) ## About the Examples on This Page The examples in this page use a simple data set for a task list app. The two Realm object types are `Project`and `Task`. A `Task` has a name, assignee's name, and completed flag. There is also an arbitrary number for priority -- higher is more important -- and a count of minutes spent working on it. Finally, a `Task` can have one or more string `labels` and one or more integer `ratings`. A `Project` has zero or more `Tasks`. See the schema for these two classes, `Project` and`Task`, below: You can set up the realm for these examples with the following code: ## Realm Swift Query API _New in version 10.19.0_: For SDK versions older than 10.19.0, use the [NSPredicate query API.](https://mongodb.com/docs/realm/sdk/swift/crud/filter-data/#std-label-ios-nspredicate-query) You can build a filter with Swift-style syntax using the `.where` [Realm Database Swift query API:](https://www.mongodb.com/docs/realm-sdks/swift/latest/Structs/Query.html) `| let realmSwiftQuery = projects.where {                         |\n| -------------------------------------------------------------- |\n| ($0.tasks.progressMinutes > 1) && ($0.tasks.assignee == \"Ali\") |\n| }                                                              | ` This query API constructs an [NSPredicate](#std-label-ios-nspredicate-query)to perform the query. It gives developers a type-safe idiomatic API to use directly, and abstracts away the NSPredicate construction.\n\n In the examples on this page, we use the `$0` shorthand to reference the variable passed into the callback. ### Operators There are several types of operators available to query a[Realm collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections). Queries work by **evaluating** an operator expression for every object in the collection being queried. If the expression resolves to `true`, Realm Database includes the object in the results collection. #### Comparison Operators You can use Swift comparison operators with the Realm Swift Query API (`==`, `!=`, `>`, `>=`, `<`, `<=`). ## Example The following example uses the query engine's comparison operators to: * Find high priority tasks by comparing the value of the `priority` property value with a threshold number, above which priority can be considered high.\n* Find long-running tasks by seeing if the `progressMinutes` property is at or above a certain value.\n* Find unassigned tasks by finding tasks where the `assignee` property is equal to `null`. ```swift let highPriorityTasks = tasks.where {     $0.priority > 5 } print(\"High-priority tasks: \\(highPriorityTasks.count)\") let longRunningTasks = tasks.where {     $0.progressMinutes >= 120 } print(\"Long running tasks: \\(longRunningTasks.count)\") let unassignedTasks = tasks.where {     $0.assignee == nil } print(\"Unassigned tasks: \\(unassignedTasks.count)\") \n``` #### Collections You can query for values within a collection using the `.contains` operators. You can search for individual values by element, or search within a range. | Operator               | Description                                                                                                                                                 |\n| ---------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| .in(\\_ collection:)    | Evaluates to true if the property referenced by the expression contains an element in the given array.                                                      |\n| .contains(\\_ element:) | Equivalent to the IN operator. Evaluates to true if the property referenced by the expression contains the value.                                           |\n| .contains(\\_ range:)   | Equivalent to the BETWEEN operator. Evaluates to true if the property referenced by the expression contains a value that is within the range.               |\n| .containsAny(in: )     | Equivalent to the IN operator combined with the ANY operator. Evaluates to true if any elements contained in the given array are present in the collection. | ## Example * Find tasks where the `labels` MutableSet collection property contains \"quick win\".\n* Find tasks where the `progressMinutes` property is within a given range of minutes. ```swift let quickWinTasks = tasks.where {     $0.labels.contains(\"quick win\") } print(\"Tasks labeled 'quick win': \\(quickWinTasks.count)\") let progressBetween30and60 = tasks.where {     $0.progressMinutes.contains(30...60) } print(\"Tasks with progress between 30 and 60 minutes: \\(progressBetween30and60.count)\") \n```\n\n ```swift let quickWinOrBugTasks = tasks.where {     $0.labels.containsAny(in: [\"quick win\", \"bug\"]) } print(\"Tasks labeled 'quick win' or 'bug': \\(quickWinOrBugTasks.count)\") \n``` _New in version 10.23.0:_: The `IN` operator The Realm Swift Query API now supports the `IN` operator. Evaluates to `true` if the property referenced by the expression contains the value. ## Example Find tasks assigned to specific teammates Ali or Jamie by seeing if the `assignee` property is in a list of names. ```swift let taskAssigneeInAliOrJamie = tasks.where {     let assigneeNames = [\"Ali\", \"Jamie\"]     return $0.assignee.in(assigneeNames) } print(\"Tasks IN Ali or Jamie: \\(taskAssigneeInAliOrJamie.count)\") \n``` #### Logical Operators You can make compound queries using Swift logical operators (`&&`, `!`,`||`). ## Example We can use the query language's logical operators to find all of Ali's completed tasks. That is, we find all tasks where the `assignee` property value is equal to 'Ali' AND the `isComplete` property value is `true`: ```swift let aliComplete = tasks.where {     ($0.assignee == \"Ali\") && ($0.isComplete == true) } print(\"Ali's complete tasks: \\(aliComplete.count)\") \n``` #### String Operators You can compare string values using these string operators. Regex-like wildcards allow more flexibility in search. ## Note You can use the following options with string operators: * `.caseInsensitive` for case insensitivity.  \n```swift  \n$0.name.contains(\"f\", options: .caseInsensitive)  \n```\n* `.diacriticInsensitive` for diacritic insensitivity: Realm treats special characters as the base character (e.g. `é` \\-> `e`).  \n```swift  \n$0.name.contains(\"e\", options: .diacriticInsensitive)  \n```\n\n ## Example The following example uses the query engine's string operators to find: * Projects with a name starting with the letter 'e'\n* Projects with names that contain 'ie'\n* Projects with an `assignee` property whose value is similar to `Al?x`\n* Projects that contain e-like characters with diacritic insensitivity ```swift // Use the .caseInsensitive option for case-insensitivity. let startWithE = projects.where {     $0.name.starts(with: \"e\", options: .caseInsensitive) } print(\"Projects that start with 'e': \\(startWithE.count)\") let containIe = projects.where {     $0.name.contains(\"ie\") } print(\"Projects that contain 'ie': \\(containIe.count)\") let likeWildcard = tasks.where {     $0.assignee.like(\"Al?x\") } print(\"Tasks with assignees like Al?x: \\(likeWildcard.count)\") // Use the .diacreticInsensitive option for diacritic insensitivty: contains 'e', 'E', 'é', etc. let containElike = projects.where {     $0.name.contains(\"e\", options: .diacriticInsensitive) } print(\"Projects that contain 'e', 'E', 'é', etc.: \\(containElike.count)\") \n``` ## Note String sorting and case-insensitive queries are only supported for character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A', and 'Latin Extended B' (UTF-8 range 0-591). #### Aggregate Operators You can apply an aggregate operator to a collection property of a Realm object. Aggregate operators traverse a[collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections) and reduce it to a single value.\n\n ## Example We create a couple of filters to show different facets of the data: * Projects with average tasks priority above 5.\n* Projects that contain only low-priority tasks below 5.\n* Projects where all tasks are high-priority above 5.\n* Projects that contain more than 5 tasks.\n* Long running projects. ```swift let averageTaskPriorityAbove5 = projects.where {     $0.tasks.priority.avg > 5 } print(\"Projects with average task priority above 5: \\(averageTaskPriorityAbove5.count)\") let allTasksLowerPriority = projects.where {     $0.tasks.priority.max < 5 } print(\"Projects where all tasks are lower priority: \\(allTasksLowerPriority.count)\") let allTasksHighPriority = projects.where {     $0.tasks.priority.min > 5 } print(\"Projects where all tasks are high priority: \\(allTasksHighPriority.count)\") let moreThan5Tasks = projects.where {     $0.tasks.count > 5 } print(\"Projects with more than 5 tasks: \\(moreThan5Tasks.count)\") let longRunningProjects = projects.where {     $0.tasks.progressMinutes.sum > 100 } print(\"Long running projects: \\(longRunningProjects.count)\") \n``` #### Set Operators A **set operator** uses specific rules to determine whether to pass each input collection object to the output collection by applying a given query expression to every element of a given [list](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-list-collections) property of the object. ## Example Running the following queries in `projects` collections returns: * Projects where a set of string `labels` contains any of \"quick win\", \"bug\".\n* Projects where any element in a set of integer `ratings` is greater than 3. ```swift let projectsWithGivenLabels = projects.where {     $0.tasks.labels.containsAny(in: [\"quick win\", \"bug\"]) } print(\"Projects with quick wins: \\(projectsWithGivenLabels.count)\") let projectsWithRatingsOver3 = projects.where {     $0.tasks.ratings > 3 } print(\"Projects with any ratings over 3: \\(projectsWithRatingsOver3.count)\") \n``` ### Subqueries You can iterate through a collection property with another query using a subquery. To form a subquery, you must wrap the expression in parentheses and immediately follow it with the `.count` aggregator. ```swift (<query>).count > n \n``` If the expression does not produce a valid subquery, you'll get an exception at runtime. ## Example Running the following query on a `projects` collection returns projects with tasks that have not been completed by a user named Alex. ```swift let subquery = projects.where {             ($0.tasks.isComplete == false && $0.tasks.assignee == \"Alex\").count > 0 } print(\"Projects with incomplete tasks assigned to Alex: \\(subquery.count)\") \n``` ## NSPredicate Queries You can build a filter with NSPredicate: ### Expressions Filters consist of **expressions** in an NSPredicate. An expression consists of one of the following: * The name (keypath) of a property of the object currently being evaluated.\n* An operator and up to two argument expression(s).\n* A value, such as a string (`'hello'`) or a number (`5`). ### Dot Notation When referring to an object property, you can use **dot notation** to refer to child properties of that object. You can even refer to the properties of[embedded objects](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-embedded-objects) and [relationships](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-client-relationships) with dot notation.\n\n ``` workplace.address.zipcode == 10012 \n``` ### Substitutions You can use the following substitutions in your predicate format strings: * `%@` to specify values\n* `%K` to specify [keypaths](https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#grammar%5Fkey-path-expression) ### Operators There are several types of operators available to filter a[Realm collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections). Filters work by **evaluating** an operator expression for every object in the collection being filtered. If the expression resolves to `true`, Realm Database includes the object in the results collection. #### Comparison Operators The most straightforward operation in a search is to compare values. ## Important ### Types Must Match The type on both sides of the operator must be equivalent. For example, comparing an [ObjectId with string](https://mongodb.com/docs/realm/sdk/swift/crud/read/#std-label-ios-filter-object-id) will result in a precondition failure with a message like: ``` \"Expected object of type object id for property 'id' on object of type 'User', but received: 11223344556677889900aabb (Invalid value)\" \n``` You can compare any [numeric type](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-supported-property-types) with any other numeric type.\n\n ## Example The following example uses the query engine's comparison operators to: * Find high priority tasks by comparing the value of the `priority` property value with a threshold number, above which priority can be considered high.\n* Find long-running tasks by seeing if the `progressMinutes` property is at or above a certain value.\n* Find unassigned tasks by finding tasks where the `assignee` property is equal to `null`.\n* Find tasks assigned to specific teammates Ali or Jamie by seeing if the `assignee` property is in a list of names. #### Logical Operators You can make compound predicates using logical operators. | Operator | Description                                                              |\n| -------- | ------------------------------------------------------------------------ |\n| and&&    | Evaluates to true if both left-hand and right-hand expressions are true. |\n| not!     | Negates the result of the given expression.                              |\n| or\\||    | Evaluates to true if either expression returns true.                     | ## Example We can use the query language's logical operators to find all of Ali's completed tasks. That is, we find all tasks where the `assignee` property value is equal to 'Ali' AND the `isComplete` property value is `true`: #### String Operators You can compare string values using these string operators. Regex-like wildcards allow more flexibility in search. ## Note You can use the following modifiers with the string operators: * `[c]` for case insensitivity.\n* `[d]` for diacritic insensitivity: Realm treats special characters as the base character (e.g. `é` \\-> `e`).\n\n ## Example We use the query engine's string operators to find projects with a name starting with the letter 'e' and projects with names that contain 'ie': ## Note String sorting and case-insensitive queries are only supported for character sets in 'Latin Basic', 'Latin Supplement', 'Latin Extended A', and 'Latin Extended B' (UTF-8 range 0-591). #### Aggregate Operators You can apply an aggregate operator to a collection property of a Realm object. Aggregate operators traverse a[collection](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/supported-types/#std-label-ios-client-collections) and reduce it to a single value.\n\n ## Example We create a couple of filters to show different facets of the data: * Projects with average tasks priority above 5.\n* Long running projects. #### Set Operators A **set operator** uses specific rules to determine whether to pass each input collection object to the output collection by applying a given predicate to every element of a given [list](https://mongodb.com/docs/realm/sdk/swift/model-data/define-model/relationships/#std-label-ios-list-collections) property of the object. | Operator  | Description                                                                               |\n| --------- | ----------------------------------------------------------------------------------------- |\n| ALL       | Returns objects where the predicate evaluates to true for all objects in the collection.  |\n| ANY, SOME | Returns objects where the predicate evaluates to true for any objects in the collection.  |\n| NONE      | Returns objects where the predicate evaluates to false for all objects in the collection. | ## Example We use the query engine's set operators to find: * Projects with no complete tasks.\n* Projects with any top priority tasks. ### Subqueries You can iterate through a collection property with another query using the`SUBQUERY()` predicate function. `SUBQUERY()` has the following signature: ``` SUBQUERY(<collection>, <variableName>, <predicate>) \n``` * `collection`: the name of the list property to iterate through\n* `variableName`: a variable name of the current element to use in the subquery\n* `predicate`: a string that contains the subquery predicate. You can use the variable name specified by `variableName` to refer to the currently iterated element. ## Example Running the following filter on a `projects` collection returns projects with tasks that have not been completed by a user named Alex. ← [Threading - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/crud/threading/ \"Previous Section\")[React to Changes - Swift SDK](https://mongodb.com/docs/realm/sdk/swift/react-to-changes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/sync/overview/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Overview - Kotlin SDK On this page * [Overview](#overview)\n* [Partition-Based Sync](#partition-based-sync)\n* [Flexible Sync](#flexible-sync)\n* [Group Updates for Improved Performance](#group-updates-for-improved-performance) ## Overview Atlas Device Sync automatically synchronizes data between client applications and an [Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/#std-label-realm-cloud). When a client device is online, Sync asynchronously synchronizes data in a background thread between the device and your backend App. When you use Sync in your client application, your implementation must match the [Sync Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-sync-modes) you select in your backend App configuration. The Sync Mode options are: * Flexible Sync (recommended): lets you define a query in the client and sync only the objects that match the query.\n* Partition-Based Sync: documents in a synced cluster form a \"partition\" by having the same value for a field designated as \"partition key\". All documents in a partition have the same read/write permissions for a given user. You can only use one Sync Mode for your application. ## Tip ### See also:  [Configure and Enable Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) ## Partition-Based Sync When you select [Partition-Based Sync](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync) for your backend App configuration, your client implementation must include a partition value. This is the value of the [partition key](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-key) field you select when you configure Partition-Based Sync. The partition value determines which data the client application can access. You must provide a partition value when you open a synced realm. ## Flexible Sync When you select [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) for your backend App configuration, your client implementation must include subscriptions to queries on [queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields). Flexible Sync works by synchronizing data that matches query subscriptions you maintain in the client application. A subscription set contains a set of queries. Realm Flexible Sync returns documents matching those queries, where the user has the appropriate[permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read and/or read and write the documents. If documents match the query, but the client does not have the permission to read or write them, they do not sync to the client application. You can form queries using [Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Note Flexible Sync does not support all the query operators available in Realm Query Language and the SDK's query engine. See [Flexible Sync RQL Limitations](https://mongodb.com/docs/realm/realm-query-language/#std-label-flexible-sync-rql-limitations) for details. Subscription sets are based on object type. You might have multiple subscriptions if you have many types of Realm objects. To use Flexible Sync in your client application, open a synced realm with an initial set of subscriptions to determine which documents to sync. ### Group Updates for Improved Performance Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - Kotlin SDK On this page * [Define Your Object Model](#define-your-object-model)\n* [Open a Realm](#open-a-realm)\n* [Create, Read, Update, and Delete Objects](#create--read--update--and-delete-objects)\n* [Watch for Changes](#watch-for-changes)\n* [Close a Realm](#close-a-realm)\n* [Add Device Sync (Optional)](#add-device-sync--optional-)\n* [Prerequisites](#prerequisites)\n* [Initialize the App](#initialize-the-app)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Next: Check out the Template Apps and Tutorial](#next--check-out-the-template-apps-and-tutorial) This page contains information to quickly use Realm Database with the Kotlin SDK. The optional [Add Device Sync](#std-label-kotlin-client-quick-start-add-device-sync) section illustrates how to get Atlas Device Sync integrated into your application. Before you begin, ensure you have installed the Kotlin SDK for your platform. * [Install for Kotlin Multiplatform](https://mongodb.com/docs/realm/sdk/kotlin/install/kotlin-multiplatform/#std-label-kotlin-install-kotlin-multiplatform)\n* [Install for Android](https://mongodb.com/docs/realm/sdk/kotlin/install/android/#std-label-kotlin-install-android) ## Note ### Using this Quick Start with KMM If you're running this project in a fresh KMM template project, you can copy and paste the following snippets into the `Greeting.greeting()` method in the`commonMain` module. ## Define Your Object Model Your application's **data model** defines the structure of data stored within Realm Database. You can define your application's data model via Kotlin classes in your application code with[Realm Object Models.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-define-object-model) To define your application's data model, add a class definition to your application code. The example below illustrates the creation of an 'Item' model that represents Todo items in a Todo list app. `| class Item() : RealmObject {                 |\n| -------------------------------------------- |\n| @PrimaryKey                                  |\n| var _id: ObjectId = ObjectId.create()        |\n| var isComplete: Boolean = false              |\n| var summary: String = \"\"                     |\n| var owner_id: String = \"\"                    |\n| constructor(ownerId: String = \"\") : this() { |\n| owner_id = ownerId                           |\n| }                                            |\n| }                                            | ` ## Open a Realm\n\n ```kotlin val config = RealmConfiguration.create(schema = setOf(Item::class)) val realm: Realm = Realm.open(config) \n``` For more information on how to control the specifics of the[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html)you would like to open (e.g. name, location, schema version), refer to[Open & Close a Realm.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/#std-label-kotlin-open-a-realm) ## Create, Read, Update, and Delete Objects Once opened, you can create objects within a realm in a[write transaction block.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) To create a new `Item`, instantiate an instance of the`Item` class and add it to the realm in a write transaction block: ```kotlin realm.writeBlocking {     copyToRealm(Item().apply {         summary = \"Do the laundry\"         isComplete = false     }) } \n``` You can retrieve a collection of all Todo items in the realm with[query.find():](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/find.html) ```kotlin // all items in the realm val items: RealmResults<Item> = realm.query<Item>().find() \n``` You can also filter a collection to retrieve a more specific collection of objects: ```kotlin // items in the realm whose name begins with the letter 'D' val itemsThatBeginWIthD: RealmResults<Item> =     realm.query<Item>(\"summary BEGINSWITH $0\", \"D\")         .find() //  todo items that have not been completed yet val incompleteItems: RealmResults<Item> =     realm.query<Item>(\"isComplete == false\")         .find() \n``` Find more information about string Realm Database queries in [Filter Data.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/filter-data/#std-label-kotlin-filter-data) To modify a Todo item, update its properties in a write transaction block: ```kotlin // change the first item with open status to complete to show that the todo item has been done realm.writeBlocking {     findLatest(incompleteItems[0])?.isComplete = true } \n``` Finally, you can delete a Todo item by calling [mutableRealm.delete()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-mutable-realm/delete.html)in a write transaction block: ```kotlin // delete the first item in the realm realm.writeBlocking {     val writeTransactionItems = query<Item>().find()     delete(writeTransactionItems.first()) } \n``` ## Watch for Changes You can [watch a realm, collection, or object for changes](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/react-to-changes/#std-label-kotlin-react-to-changes) with the `observe` method. ## Important ### Serverless Limitations You cannot watch for changes if the data source is an Atlas serverless instance. MongoDB serverless currently does not support change streams, which are used on watched collections to listen for changes. In the following example, we listen for changes on all `Item` objects. ```kotlin\n\n val job = CoroutineScope(Dispatchers.Default).launch {     // create a Flow from the Item collection, then add a listener to the Flow     val itemsFlow = items.asFlow()     itemsFlow.collect { changes: ResultsChange<Item> ->         when (changes) {             // UpdatedResults means this change represents an update/insert/delete operation             is UpdatedResults -> {                 changes.insertions // indexes of inserted objects                 changes.insertionRanges // ranges of inserted objects                 changes.changes // indexes of modified objects                 changes.changeRanges // ranges of modified objects                 changes.deletions // indexes of deleted objects                 changes.deletionRanges // ranges of deleted objects                 changes.list // the full collection of objects             }             else -> {                 // types other than UpdatedResults are not changes -- ignore them             }         }     } } \n``` Later, when you're done observing, cancel the job to cancel the coroutine: ```kotlin job.cancel() // cancel the coroutine containing the listener \n``` ## Close a Realm To close a realm and all underlying resources, call [realm.close()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/close.html). The`close()` method blocks until all write transactions on the realm have completed. ```kotlin realm.close() \n``` ## Add Device Sync (Optional) This section illustrates how to authenticate with an Anonymous User, and open a Flexible Sync realm to begin syncing data between devices. ### Prerequisites The code snippets in this section require the following: * [A created App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enabled anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) in the App Services UI\n* [Enable Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) with [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) toggled on and an `owner_id` field in the Queryable Fields section ### Initialize the App To use App Services features such as authentication and sync, access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) in the App Services UI. ```kotlin val app = App.create(YOUR_APP_ID) \n``` ### Authenticate a User\n\n ```kotlin val credentials = Credentials.anonymous() val user = app.login(credentials) \n``` ### Open a Synced Realm Once you have initialized your Atlas App Services App, authenticated a user, and defined your object model, you can create a [SyncConfiguration.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-sync-configuration/index.html) If you have opened a local realm following the [Open a Realm](#std-label-kotlin-client-quick-start-open-a-local-realm) section above, replace the[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html) with the `SyncConfiguration` described below. Pass the authenticated user and the `Item` class to the [SyncConfiguration.Builder](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-sync-configuration/-builder/index.html)function to create a [Flexible Sync Configuration.](https://mongodb.com/docs/realm/sdk/kotlin/sync/overview/#std-label-kotlin-flexible-sync-fundamentals) ## Important ### Initial Subscriptions You need at least one subscription before you can read from or write to the realm. Use [initialSubscriptions](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-sync-configuration/-builder/initial-subscriptions.html)to define the initial subscription set when the Realm file is first opened. Pass the query you wish to subscribe to and a name for the subscription to the [add()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-mutable-subscription-set/add.html) function. The example below specifies a subscription named \"User's Items\" with all `Item` objects. ```kotlin // create a SyncConfiguration val config = SyncConfiguration.Builder(     user,     setOf(Item::class) ) // the SyncConfiguration defaults to Flexible Sync, if a Partition is not specified     .initialSubscriptions { realm ->         add(             realm.query<Item>(                 \"owner_id == $0\", // owner_id == the logged in user                 user.id             ),             \"User's Items\"         )     }     .build() val realm = Realm.open(config) \n``` ## Next: Check out the Template Apps and Tutorial Check out the [template app](https://www.mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) to experiment with another quick way to start coding with the Realm Kotlin SDK. The Kotlin SDK template, labeled `android.kotlin.todo.flex`, is a premade application that integrates Realm Database and Atlas Device Sync into a customizable android app.\n\n ← [Install (Kotlin Multiplatform) - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/install/kotlin-multiplatform/ \"Previous Section\")[Realm Database - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/install/android/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install (Android) - Kotlin SDK ## Prerequisites * [Android Studio](https://developer.android.com/studio/index.html) Bumblebee 2021.1.1 or higher.\n* JDK 11 or higher.\n* Kotlin Plugin for Android Studio, version 1.6.10 or higher.\n* An Android Virtual Device (AVD) using a supported CPU architecture. ## Tip ### Kotlin Plugin Version The Kotlin Multiplatform ecosystem frequently changes. If you experience any issues installing the SDK, check your Kotlin Plugin version, since outdated plugins can lead to difficult to debug errors. To see which versions of the Kotlin Plugin are compatible with the SDK, see the[realm-kotlin changelog.](https://github.com/realm/realm-kotlin/blob/master/CHANGELOG.md) ## Installation After updating the Gradle configuration, resolve the dependencies by clicking File \\>Sync Project with Gradle Files in the Android Studio menu bar. You can now use the Kotlin SDK in your application. ← [Install - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/install/ \"Previous Section\")[Install (Kotlin Multiplatform) - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/install/kotlin-multiplatform/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/sync/subscribe/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Subscribe to Queryable Fields - Kotlin SDK On this page * [Prerequisites](#prerequisites)\n* [Subscriptions](#subscriptions)\n* [Add a Subscription](#add-a-subscription)\n* [Wait for Subscription Changes to Sync](#wait-for-subscription-changes-to-sync)\n* [Subscription Set State](#subscription-set-state)\n* [Update Subscriptions with a New Query](#update-subscriptions-with-a-new-query)\n* [Remove Subscriptions](#remove-subscriptions)\n* [Remove a Single Subscription](#remove-a-single-subscription)\n* [Remove All Subscriptions to an Object Type](#remove-all-subscriptions-to-an-object-type)\n* [Remove All Subscriptions](#remove-all-subscriptions)\n* [Flexible Sync RQL Limitations](#flexible-sync-rql-limitations)\n* [Unsupported Query Operators in Flexible Sync](#unsupported-query-operators-in-flexible-sync)\n* [List Queries](#list-queries)\n* [Embedded or Linked Objects](#embedded-or-linked-objects) Flexible Sync uses subscriptions and permissions to determine which data to sync with your App. ## Prerequisites To use Flexible Sync in the SDK: * [Configure Flexible Sync on the backend](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n* [Authenticate a user](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-authenticate) in your client app.\n* [Open the synced Realm with a Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/kotlin/sync/open-a-synced-realm/#std-label-kotlin-open-a-synced-realm) You can add, update, and remove query subscriptions to determine which data syncs to the client device. ## Subscriptions When you configure Flexible Sync on the backend, you specify which fields your client application can query. In the client application, use the`subscriptions` API to manage a set of subscriptions to specific queries on queryable fields. You can construct queries with[Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Important Flexible Sync does not support all the operators available in Realm Query Language. See [Flexible Sync RQL Limitations](#std-label-kotlin-flexible-sync-rql-limitations) for details. You can: * Add subscriptions\n* React to subscription state\n* Update subscriptions with new queries\n* Remove individual subscriptions or all subscriptions for an object type Data matching the subscription, where the user has the appropriate permissions, syncs between clients and the backend application. You can specify an optional string name for your subscription. ## Tip ### Always Specify a Subscription Name Always specify a subscription name if your application uses multiple subscriptions. This makes your subscriptions easier to look up, update, and delete elsewhere in your app. When you create a subscription, Realm looks for data matching a query on a specific object type. You can create multiple subscription sets on different object types, and even query multiple times on the same object type. Subscription names must be unique. Adding a subscription with the same name as an existing subscription throws an error. ## Add a Subscription Add a subscription in a subscriptions update block. You append each new subscription to the client's Realm subscriptions.\n\n ` ## Important ### Object Links You must add both an object and its linked object to the subscription set to see a linked object. If your subscription results contain an object with a property that links to an object not contained in the results, the link appears to be null. There is no way to distinguish whether that property's value is legitimately null, or whether the object it links to exists but is out of view of the query subscription. ### Wait for Subscription Changes to Sync Writing an update to the subscription set locally is only one component of changing a subscription. After the local subscription change, the client synchronizes with the server to resolve any updates to the data due to the subscription change. This could mean adding or removing data from the synced realm. Use the [SynConfiguration.waitForInitialRemoteData()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-sync-configuration/-builder/wait-for-initial-remote-data.html)builder method to force your application to block until client subscription data synchronizes to the backend before opening the realm: ```kotlin // make an update to the list of subscriptions realm.subscriptions.update {     this.add(realm.query<Toad>(\"name == $0\", \"another name value\"), \"another subscription name\") } // wait for subscription to fully synchronize changes realm.subscriptions.waitForSynchronization(Duration.parse(\"10s\")) \n``` You can also use [SubscriptionSet.waitForSynchronization()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-subscription-set/wait-for-synchronization.html)to delay execution until subscription sync completes after instantiating a sync connection. ### Subscription Set State Use the [SubscriptionSet.state](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-subscription-set/index.html#-508547000%2FProperties%2F645295071)property to read the current state of the subscription set. `SUPERCEDED` (sic -- note alternate spelling) is a [SubscriptionSetState](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-subscription-set-state/index.html)that can occur when another thread writes a subscription on a different instance of the subscription set. If the state becomes `SUPERCEDED`, you must obtain a new instance of the subscription set before you can write to it. ## Note ### Subscription State \"Complete\" The subscription set state \"complete\" does not mean \"sync is done\" or \"all documents have been synced\". \"Complete\" means the following two things have happened: * The subscription has become the active subscription set that is currently being synchronized with the server.\n* The documents that matched the subscription _at the time the subscription was sent to the server_ are now on the local device. Note that this does not necessarily include all documents that currently match the subscription. The Realm SDK does not provide a way to check whether all documents that match a subscription have synced to the device. ## Update Subscriptions with a New Query\n\n ```kotlin // create an initial subscription named \"subscription name\" val config = SyncConfiguration.Builder(user, setOf(Toad::class))     .initialSubscriptions { realm ->         add(             realm.query<Toad>(                 \"name == $0\",                 \"name value\"             ),             \"subscription name\"         )     }     .build() val realm = Realm.open(config) // to update that subscription, add another subscription with the same name // it will replace the existing subscription realm.subscriptions.update {     this.add(         realm.query<Toad>(\"name == $0\", \"another name value\"),         \"subscription name\",         updateExisting = true     ) } \n``` You cannot update subscriptions created without a name. However, you can look up unnamed subscriptions by their query, remove them from the subscription set, then add a new subscription with an updated query: ```kotlin val subscription =     realm.subscriptions.findByQuery(         realm.query<Toad>(\"name == $0\", \"name value\")) if (subscription != null) {     realm.subscriptions.update {         this.remove(subscription)         this.add(             realm.query<Toad>(                 \"name == $0\",                 \"another name value\"             ),             \"subscription name\"         )     } } \n``` ## Remove Subscriptions To remove subscriptions, you can: * Remove a single subscription query\n* Remove all subscriptions to a specific object type\n* Remove all subscriptions When you remove a subscription query, Realm asynchronously removes the synced data that matched the query from the client device. ### Remove a Single Subscription You can remove a specific subscription query using [MutableSubscriptionSet.remove()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-mutable-subscription-set/remove.html). You can either look up the subscription by name, then pass the returned subscription to `remove()`, or pass the subscription name directly to`remove()`: ```kotlin // create an initial subscription named \"subscription name\" val config = SyncConfiguration.Builder(user, setOf(Toad::class))     .initialSubscriptions { realm ->         add(             realm.query<Toad>(                 \"name == $0\",                 \"name value\"             ),             \"subscription name\"         )     }     .build() val realm = Realm.open(config) // remove subscription by name realm.subscriptions.update {     this.remove(\"subscription name\") } \n``` ### Remove All Subscriptions to an Object Type If you want to remove all subscriptions to a specific object type, pass a class to the [MutableSubscriptionSet.removeAll()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-mutable-subscription-set/remove.html). method:\n\n // create an initial subscription named \"subscription name\" val config = SyncConfiguration.Builder(user, setOf(Toad::class))     .initialSubscriptions { realm ->         add(             realm.query<Toad>(                 \"name == $0\",                 \"name value\"             ),             \"subscription name\"         )     }     .build() val realm = Realm.open(config) // wait for synchronization to complete before editing subscriptions realm.subscriptions.waitForSynchronization(Duration.parse(\"10s\")) // remove all subscriptions to type Toad realm.subscriptions.update {     this.removeAll(Toad::class) } \n``` ### Remove All Subscriptions To remove all subscriptions from the subscription set, use[MutableSubscriptionSet.removeAll()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-mutable-subscription-set/remove-all.html). with no arguments: ## Warning If you remove all subscriptions and do not add a new one, you'll get an error. A realm opened with a flexible sync configuration needs at least one subscription to sync with the server. ```kotlin // create an initial subscription named \"subscription name\" val config = SyncConfiguration.Builder(user, setOf(Toad::class))     .initialSubscriptions { realm ->         add(             realm.query<Toad>(                 \"name == $0\",                 \"name value\"             ),             \"subscription name\"         )     }     .build() val realm = Realm.open(config) // remove all subscriptions realm.subscriptions.update {     this.removeAll() } \n``` ## Flexible Sync RQL Limitations Flexible Sync has some limitations when using RQL operators. When you write the [query subscription](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-flexible-sync-query-subscription)that determines which data to sync, the server does not support these query operators. However, you can still use the full range of RQL features to query the synced data set in the client application. ### Unsupported Query Operators in Flexible Sync | Operator Type       | Unsupported Operators          |\n| ------------------- | ------------------------------ |\n| Aggregate Operators | @avg, @count, @max, @min, @sum |\n| Query Suffixes      | DISTINCT, SORT, LIMIT          | Case insensitive queries (`[c]`) cannot use indexes effectively. As a result, case insensitive queries are not recommended, since they could lead to performance problems. Flexible Sync only supports `@count` for array fields. ### List Queries Flexible Sync supports querying lists using the `IN` operator. You can query a list of constants to see if it contains the value of a queryable field: ```javascript // Query a constant list for a queryable field value \"priority IN { 1, 2, 3 }\" \n``` If a queryable field has an array value, you can query to see if it contains a constant value: ```javascript // Query an array-valued queryable field for a constant value \"'comedy' IN genres\" \n``` ## Warning You **cannot** compare two lists with each other in a Flexible Sync query. Note that this is valid Realm Query Language syntax outside of Flexible Sync queries. ```javascript // Invalid Flexible Sync query. Do not do this!\n\n // Another invalid Flexible Sync query. Do not do this! \"ANY {'comedy', 'horror', 'suspense'} != ANY genres\" \n``` ### Embedded or Linked Objects Flexible Sync does not support querying on properties in Embedded Objects or links. For example, `obj1.field == \"foo\"`. ← [Open a Synced Realm - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/sync/open-a-synced-realm/ \"Previous Section\")[Atlas App Services - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/install/kotlin-multiplatform/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install (Kotlin Multiplatform) - Kotlin SDK ## Prerequisites * [Android Studio](https://developer.android.com/studio/index.html) Bumblebee 2021.1.1 or higher.\n* JDK 11 or higher.\n* Kotlin Plugin for Android Studio, version 1.6.10 or higher.\n* An Android Virtual Device (AVD) using a supported CPU architecture. Additionally, Kotlin Multiplatform projects require the following: * [Kotlin Multiplatform Mobile (KMM) Plugin](https://kotlinlang.org/docs/mobile/kmm-plugin-releases.html#release-details)for Android Studio, version 0.3.1 or higher.\n* A KMM App created using the \"KMM Application\" template in Android Studio. Follow the instructions in the [KMM documentation.](https://kotlinlang.org/docs/mobile/create-first-app.html) For more details on setting up your KMM environment, refer to the [official Kotlin Multiplatform documentation](https://kotlinlang.org/docs/multiplatform-mobile-setup.html). To verify your environment setup, follow Kotlin's [guide to checking your environment.](https://kotlinlang.org/docs/multiplatform-mobile-setup.html#check-your-environment) ## Installation ## Note ### Android Module Dependencies If you use any part of the SDK inside the Android module, add the SDK's compile-time dependency to your Android module `build.gradle.kts`: `| // If only using the local database               |\n| ------------------------------------------------- |\n| dependencies {                                    |\n| compileOnly(\"io.realm.kotlin:library-base:1.6.0\") |\n| }                                                 |\n| // If using Device Sync                           |\n| dependencies {                                    |\n| compileOnly(\"io.realm.kotlin:library-sync:1.6.0\") |\n| }                                                 | ` After updating the Gradle configuration, resolve the dependencies by clicking File \\>Sync Project with Gradle Files in the Android Studio menu bar. You can now use the Kotlin SDK in your application. ## Supported Target Environments Kotlin Multiplatform supports a [wide range of application environments](https://kotlinlang.org/docs/multiplatform-dsl-reference.html#targets). The SDK supports the following environments: * `android`\n* `iosArm64`\n* `iosSimulatorArm64`\n* `iosX64`\n* `jvm`\n* `macosArm64`\n* `macosX64` The SDK does not support the following environments: * `androidNativeArm32`\n* `androidNativeArm64`\n* `androidNativeX86`\n* `androidNativeX64`\n* `iosArm32`\n* `js`\n* `linuxArm32Hfp`\n* `linuxArm64`\n* `linuxMips32`\n* `linuxMipsel32`\n* `linuxX64`\n* `mingwX64`\n* `mingwX86`\n* `tvosArm64`\n* `tvosSimulatorArm64`\n* `tvosX64`\n* `wasm32`\n* `watchosArm32`\n* `watchosArm64`\n* `watchosSimulatorArm64`\n* `watchosX86`\n* `watchosX64`\n\n",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/link-credentials/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Link User Identities - Kotlin SDK On this page * [Example](#example) Realm provides [many authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)to log users into your app. Each provider creates a unique user identity. Realm lets you merge multiple credentials into one user identity. Credentials must be linked prior to logging a user in. Once credentials are used to login a user, you cannot link that credential anymore. Also, you cannot link multiple email/password credentials together. ## Example Consider an application that offers [anonymous login](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication), which allows users to explore the app without registering. If a user wants to continue using the application, they can create a permanent account by using another authentication provider. Realm creates a new `User` object. The app can then link the new identity with the current user. ## Note Depending on how you have configured email/password authentication, there may be additional steps (confirming the email address, for example) before the new account is created and can be linked. You link identities using[linkCredentials](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-user/link-credentials.html). This links the new user identity to the logged-in[User.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-user/index.html) `| val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID         |\n| ------------------------------------------------------------------------------- |\n| runBlocking { // use runBlocking sparingly -- it can delay UI interactions      |\n| val user = app.login(Credentials.anonymous()) // logs in with an anonymous user |\n| // registers an email/password user                                             |\n| app.emailPasswordAuth.registerUser(email, password)                             |\n| // links anonymous user with email/password credentials                         |\n| user.linkCredentials(Credentials.emailPassword(email, password));               |\n| }                                                                               | ` ← [Authenticate Users - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/ \"Previous Section\")[Manage User API Keys - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/manage-user-api-keys/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/connect-to-app-services-backend/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Connect to an Atlas App Services backend - Kotlin SDK On this page * [Access the App](#access-the-app)\n* [Configuration](#configuration) The `App` class is the interface to App Services. This class provides access to [authentication](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-authenticate) and Device Sync. ## Access the App Pass the App ID for your App, which you can [find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) `| val app = App.create(YOUR_APP_ID) |\n| --------------------------------- | ` ## Note You can create multiple `App` instances to connect to multiple Apps or to the same App with different configurations. All`App` instances that share the same App ID use the same underlying connection. ## Configuration For more granular control of the details of your app connection, such as custom timeouts for connections and keys for local encryption, use the [AppConfiguration.Builder](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app-configuration/-builder/index.html) to control details of your `App`: ```kotlin App.create(     AppConfiguration.Builder(YOUR_APP_ID)     .log(LogLevel.ALL)     .build()) \n``` ## Note For most use cases, you only need your application's App ID to connect to App Services. The other settings demonstrated here are optional. ← [Atlas App Services Overview - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/overview/ \"Previous Section\")[Register Users - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/register-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/delete-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete Users - Kotlin SDK You can call the `delete` method on a user object to delete the user object from your Atlas App Services App. This deletes the object from the server in addition to clearing local data. ## Important Deleting a user only deletes the user object, which may contain associated[metadata](https://mongodb.com/docs/realm/sdk/swift/users/user-metadata/#std-label-ios-user-metadata). This does not delete [custom user data](https://mongodb.com/docs/realm/sdk/swift/users/custom-user-data/#std-label-ios-custom-user-data) or user-entered data from your application. Apple [requires that you disclose data retention and deletion policies](https://developer.apple.com/app-store/review/guidelines/#5.1.1) to your application customers and give them a way to request user data deletion. If you collect additional user data, you must implement your own methods or processes to delete that data. _New in version 1.1.0_. `` | val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID                          |\n| ------------------------------------------------------------------------------------------------ |\n| runBlocking { // use runBlocking sparingly -- it can delay UI interactions                       |\n| val user = app.login(credentials)                                                                |\n| // use the user object ...                                                                       |\n| // later, delete the user object                                                                 |\n| user.delete() // regardless of which provider you used to login, you can logout using `delete()` |\n| }                                                                                                |  `` ← [Manage User API Keys - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/manage-user-api-keys/ \"Previous Section\")[Call an Atlas Function - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/call-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/overview/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Atlas App Services Overview - Kotlin SDK On this page * [Overview](#overview)\n* [The Realm App Client](#the-realm-app-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Device Sync](#device-sync)\n* [Call Atlas Functions](#call-atlas-functions) ## Overview You can connect your client apps to the Atlas App Services backend using the SDK. Backend functionality includes: * [Connect to a Realm App](https://mongodb.com/docs/realm/sdk/kotlin/app-services/connect-to-app-services-backend/)\n* [Register Users](https://mongodb.com/docs/realm/sdk/kotlin/app-services/register-users/)\n* [Authenticate Users](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/) ## The Realm App Client To connect to your App Services backend, start with an[App](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/index.html) object. This object provides all other functionality related to the backend. Initialize an App with the App ID, which you can[find in the Realm UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) To learn how to initialize the Realm App client, refer to[Connect to App Services.](https://mongodb.com/docs/realm/sdk/kotlin/app-services/connect-to-app-services-backend/#std-label-kotlin-connect-to-backend) [Create an App Services Account](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Fkotlin) ## Authentication & User Management One of the most challenging aspects of client development is implementing a robust and secure authentication system. With the Realm SDKs, however, you can use any of the Realm authentication providers with minimal backend setup and client-side code. With the authentication APIs, you can implement the following functionality: * Create new user accounts\n* User log in and log out\n* Multiple users logged on at the same time on the same device\n* Link user accounts from different providers\n* Store custom data for a particular user To learn how to set up authentication in your app, refer to[Authenticate Users.](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-authenticate) ## Device Sync Device Sync adds data synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. To get started with Sync, refer to [Device Sync.](https://mongodb.com/docs/realm/sdk/kotlin/sync/overview/#std-label-kotlin-realm-sync) ## Call Atlas Functions [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) let you define and execute server-side logic. You can call these Functions from your client applications via the Realm SDKs. These server-side functions can run in the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your data in Atlas. Using Functions provides a secure way for multiple client applications to share complex functionality without having to reproduce that logic client-side. To learn how to call an Atlas Function from your client app, refer to [Call a Function.](https://mongodb.com/docs/realm/sdk/kotlin/app-services/call-function/#std-label-kotlin-call-function)\n\n",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/manage-user-api-keys/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage User API Keys - Kotlin SDK On this page * [Create a User API Key](#create-a-user-api-key)\n* [Look up a User API Key](#look-up-a-user-api-key)\n* [Enable or Disable a User API Key](#enable-or-disable-a-user-api-key)\n* [Delete a User API Key](#delete-a-user-api-key) You can use the Kotlin SDK to create and manage [User API keys](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication-user-api-key) that allow devices or services to communicate with Realm on behalf of an existing user without requiring the user to re-authenticate. User API keys are associated with a user object created by another non-anonymous authentication provider. Each user can associate up to 20 user keys with their account. You can manage keys through the[user.apiKeyAuth](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-api-key-auth/index.html)interface. ## Tip User API keys are not the same as **server API keys**, which allow a user or service to directly authenticate with Realm using the[API Key authentication provider](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-login-api-key). To learn more about server API keys, refer to [API Key Authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication) ## Create a User API Key To create a new user API key, pass a unique key name to [ApiKeyAuth.create()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-api-key-auth/create.html). The created key will be associated with the logged-in user and can be used to interact with Realm on their behalf. You cannot create user API keys for anonymous users. ## Warning ### Store the API Key Value The SDK only returns the value of the user API key when you create it. Make sure to store the `key` value securely so that you can use it to log in. If you lose or do not store the `key` value there is no way to recover it. You will need to create a new user API key. `| val user = app.currentUser!!                |\n| ------------------------------------------- |\n| val provider = user.apiKeyAuth              |\n| // Create an API key for the logged-in user |\n| val key = provider.create(\"apiKeyName\")     | ` ## Look up a User API Key To get a list of all user API keys associated with the logged-in user, call[ApiKeyAuth.fetchAll().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-api-key-auth/fetch-all.html) To find a specific user API key for the logged-in user, pass the key's `id`to[ApiKeyAuth.fetch().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-api-key-auth/fetch.html) ```kotlin\n\n val provider = user.apiKeyAuth // Get all keys for the logged-in user val apiKeys = provider.fetchAll() // Get a specific key by its ID val apiKey = provider.fetch(key.id) \n``` ## Enable or Disable a User API Key You can enable or disable a key by calling[ApiKeyAuth.enable()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-api-key-auth/enable.html)or[ApiKeyAuth.disable()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-api-key-auth/disable.html)with the key's `id`. You cannot use disabled keys to log in on behalf of the user. ```kotlin val user = app.currentUser!! val provider = user.apiKeyAuth // ... fetch the key to enable or disable // Enable an API key that's currently disabled provider.enable(key.id) // Disable an API key that's currently enabled provider.disable(key.id) \n``` ## Delete a User API Key To permanently remove a specific user API key, pass the key's `id` to[ApiKeyAuth.delete()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-api-key-auth/delete.html). You cannot recover deleted keys or use them to log in on behalf of the user. ```kotlin val user = app.currentUser!! val provider = user.apiKeyAuth // ... fetch the key to delete // Delete the specified API key provider.delete(key.id) \n``` ← [Link User Identities - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/link-credentials/ \"Previous Section\")[Delete Users - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/delete-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/register-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Register Users - Kotlin SDK On this page * [Register a New User Account](#register-a-new-user-account) When you have enabled the [email/password provider](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) in your App, you can register a new account, confirm an email address, and reset a user's password from client code. ## Register a New User Account To register a new user, pass a user-provided email and password to[app.emailPasswordAuth.registerUser():](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-email-password-auth/register-user.html) `| val app: App = App.create(YOUR_APP_ID)                           |\n| ---------------------------------------------------------------- |\n| runBlocking {                                                    |\n| app.emailPasswordAuth.registerUser(email, password)              |\n| // once registered, you can log in with the user credentials     |\n| val user = app.login(Credentials.emailPassword(email, password)) |\n| Log.v(\"Successfully logged in ${user.id}\")                       |\n| }                                                                | ` ← [Connect to an Atlas App Services backend - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/connect-to-app-services-backend/ \"Previous Section\")[Authenticate Users - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate Users - Kotlin SDK On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Register a New User Account](#register-a-new-user-account)\n* [Log In](#log-in)\n* [Anonymous](#anonymous)\n* [Email/Password](#email-password)\n* [Custom JWT](#custom-jwt)\n* [API Key](#api-key)\n* [Custom Function](#custom-function)\n* [Google](#google)\n* [Facebook](#facebook)\n* [Apple](#apple)\n* [Get a User Access Token](#get-a-user-access-token)\n* [Log a User Out](#log-a-user-out)\n* [Retrieve Current User](#retrieve-current-user) ## Overview Atlas App Services provides an API for authenticating users using any enabled authentication provider. Instantiate a [Credentials](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-credentials/index.html)object and pass it to [app.login()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/login.html)to authenticate and create a [User](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-user/index.html)object for that user. Each authentication provider corresponds to a[static helper method](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-authentication-provider/index.html)used to instantiate `Credentials` objects for that authentication provider. ## Before You Begin 1. [Create an App Services App.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n2. Enable and configure one or more App Services [authentication providers.](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) ## Register a New User Account Realm registers accounts differently depending on the authentication provider: * You do not need to register anonymous users.\n* To register an email/password user, refer to [Register Users.](https://mongodb.com/docs/realm/sdk/kotlin/app-services/register-users/#std-label-kotlin-manage-email-password-users)\n* If you are using Google, Facebook, Apple, or Custom JWT authentication, registration is handled by these third-party services. ## Log In You can authenticate users with [app.login().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/login.html) If successful, `app.login()` returns a `User` object. In the event of a failure, `app.login()` throws an exception of type `AppException`.\n\n ### Anonymous The [anonymous authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)enables users to log in to your application with short-term accounts that store no persistent personal information. To log in with anonymous authentication, create an anonymous credential by calling[Credentials.anonymous()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-credentials/-companion/anonymous.html)and then pass the generated credential to[app.login().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/login.html) `| val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID    |\n| -------------------------------------------------------------------------- |\n| runBlocking { // use runBlocking sparingly -- it can delay UI interactions |\n| val user = app.login(Credentials.anonymous())                              |\n| }                                                                          | ` If you want more than one anonymous user, set `reuseExisting = false` when creating additional anonymous credentials. ```kotlin runBlocking {     // Logs in with anonymous user     val anonUser = app.login(Credentials.anonymous())     // Creates a new anonymous user     val otherAnonUser =         app.login(Credentials.anonymous(reuseExisting = false)) } \n``` ### Email/Password The [Email/Password authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication)enables users to log in to your application with an email username and a password. To log in with email/password authentication, create an email/password credential by calling [Credentials.emailPassword()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-credentials/-companion/email-password.html)with the user's email and password. Then pass the generated credential to [app.login().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/login.html) ```kotlin val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID runBlocking { // use runBlocking sparingly -- it can delay UI interactions     val user = app.login(Credentials.emailPassword(email, password)) } \n``` ### Custom JWT\n\n ```kotlin val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID runBlocking { // use runBlocking sparingly -- it can delay UI interactions     val user = app.login(Credentials.jwt(jwtToken)) } \n``` ### API Key The [API Key authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication)enables users to log in to your application with an API key generated automatically in the client SDK. To log in with API key authentication, create an email/password credential by calling [Credentials.apiKey()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-credentials/-companion/api-key.html)with the user's email and password. Then pass the generated credential to [app.login().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/login.html) ```kotlin val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID runBlocking { // use runBlocking sparingly -- it can delay UI interactions     val user = app.login(Credentials.apiKey(key)) } \n``` ### Custom Function If you have configured the[Custom Function authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication), you can log in using custom authentication logic handled by an Atlas Function. To log in with Custom Function authentication, pass your custom arguments as a payload to [Credentials.customFunction()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-credentials/-companion/custom-function.html). Then pass the generated credential to [app.login().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/login.html) ```kotlin val customCredentials = Credentials.customFunction(     payload = mapOf(\"username\" to \"bob\") ) // Pass the generated credential to app.login() val currentUser = app.login(customCredentials) \n``` ### Google To set up your application for Google User authentication: 1. In the [Google Cloud Platform console](https://console.cloud.google.com/apis/credentials), create an OAuth 2.0 client ID of type \"Web application\".\n2. Configure your backend App to use that client ID and the associated client secret.\n3. Enable OpenID Connect on the backend. Use Google's official [Sign-In for Android](https://developers.google.com/identity/sign-in/android)to authenticate Google users in your Android application. The following code implements this flow, starting with a method call to`loginWithGoogle()`: ```kotlin fun loginWithGoogle() {     val gso = GoogleSignInOptions         .Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)         .requestIdToken(\"YOUR WEB APPLICATION CLIENT ID FOR GOOGLE AUTH\")         .build()     val googleSignInClient = GoogleSignIn.getClient(activity, gso)     val signInIntent: Intent = googleSignInClient.signInIntent     val resultLauncher: ActivityResultLauncher<Intent> =\n\n         registerForActivityResult(ActivityResultContracts.StartActivityForResult())         { result ->             val task: Task<GoogleSignInAccount> =                 GoogleSignIn.getSignedInAccountFromIntent(result.data)             handleSignInResult(task)         }     resultLauncher.launch(signInIntent) } fun handleSignInResult(completedTask: Task<GoogleSignInAccount>) {     try {         if (completedTask.isSuccessful) {             val account: GoogleSignInAccount? = completedTask.getResult(ApiException::class.java)             val token: String = account?.idToken!!             val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID             runBlocking {                 val user = app.login(Credentials.google(token, GoogleAuthType.ID_TOKEN))             }         } else {             Log.e(\"AUTH\", \"Google Auth failed: ${completedTask.exception}\")         }     } catch (e: ApiException) {         Log.e(\"AUTH\", \"Failed to authenticate using Google OAuth: \" + e.message);     } } \n``` ## Tip ### See also:  * To learn more about Google Sign-In for Android, check out the official [Google Sign-In for Android Integration Guide.](https://developers.google.com/identity/sign-in/android/start-integrating)\n* KMM supports many environments, but this example shows sign-in on the Android platform. For information about signing into a Google account on Apple platforms, see the[Swift SDK Example.](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-login-google) ### Facebook The [Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) authentication provider allows you to authenticate users through a Facebook app using their existing Facebook account. ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. Follow the official [Facebook Login for Android Quickstart](https://developers.facebook.com/docs/facebook-login/android) to set up the authentication flow for your application. In the login completion handler, get the logged in user's access token from the Facebook [LoginResult](https://developers.facebook.com/docs/reference/android/current/class/LoginResult). Use the access token to create a Facebook credential by calling [Credentials.facebook()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-credentials/-companion/facebook.html)with the user's access token. Then pass the generated credential to [app.login().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/login.html) ```kotlin val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID FacebookSdk.setApplicationId(YOUR_FACEBOOK_SDK_APP_ID)\n\n val callbackManager = CallbackManager.Factory.create() LoginManager.getInstance().registerCallback(     callbackManager,     object : FacebookCallback<LoginResult> {         override fun onSuccess(loginResult: LoginResult) {             // Signed in successfully, forward credentials to MongoDB Realm.             val accessToken = loginResult.accessToken             runBlocking {                 val user = app.login(Credentials.facebook(accessToken.token))             }         }         override fun onCancel() {             Log.v(\"AUTH\", \"Cancelled Facebook login\")         }         override fun onError(exception: FacebookException) {             Log.e(\"AUTH\", \"Failed to authenticate with Facebook: ${exception.message}\")         }     }) \n``` ## Tip ### See also:  KMM supports many environments, but this example shows sign-in on the Android platform. For information about signing into a Facebook account on Apple platforms, see the[Swift SDK Example.](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-login-facebook) ### Apple The [Sign-in with Apple authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication)enables users to log in to your application with a custom token provided by Apple. To log in with Apple authentication, create an Apple credential by calling [Credentials.apple()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-credentials/-companion/apple.html)with the user's token. Then pass the generated credential to [app.login().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/login.html) ```kotlin val app: App = App.create(YOUR_APP_ID) // Replace this with your App ID runBlocking { // use runBlocking sparingly -- it can delay UI interactions     val user = app.login(Credentials.apple(idToken)) } \n``` ## Tip ### See also:  KMM supports many environments, but this example shows sign-in on the Android platform. For information about signing in with Apple on Apple platforms, see the[Swift SDK Example.](https://mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-login-apple) ## Get a User Access Token The Realm Kotlin SDK automatically manages access tokens, refreshes them when they expire, and includes a valid access token for the current user with each request. Tokens are removed after the user logs out. You can get the current access token for a logged-in user with the[user.accessToken](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-user/access-token.html)property: ```kotlin val token = user.accessToken \n``` If you send requests outside of the SDK (e.g. through the [GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api)), then you must include the user's access token with each request and manually refresh the token when it expires. Access tokens expire 30 minutes after a user logs in.\n\n ```kotlin // Gets the current refresh token for the user fun getRefreshToken(): String {     return user.refreshToken } \n``` ## Log a User Out ## Warning When a user logs out, you can no longer read or write data in any synced realms that the user opened. As a result, any operation that has not yet completed before the initiating user logs out cannot complete successfully and will likely result in an error. Any data in a write operation that fails in this way will be lost. You can log out any user, regardless of the authentication provider used to log in, using [user.logOut().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-user/log-out.html) The `user.logOut()` method: * Deletes locally stored user credentials from the device.\n* Immediately halts any synchronization to and from the user's realms. Because logging out halts synchronization, you should only log out after all local Realm updates have uploaded to the server. ```kotlin user.logOut() \n``` ## Retrieve Current User Once you have an authenticated user, you can retrieve the User object with the[App.currentUser](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-app/index.html#1060015050%2FProperties%2F645295071)property. The `currentUser` object is persisted in local storage, so even if the app shuts down after the initial authentication, you do not need to call`logIn` again (unless the user logged out). ```kotlin val user = app.currentUser \n``` ← [Register Users - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/register-users/ \"Previous Section\")[Link User Identities - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/app-services/link-credentials/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/errors/realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Handle Realm Errors - Kotlin SDK Realm errors occur when a database read or write fails for any reason. When possible, the SDK uses existing platform exceptions, like[IllegalArgumentException](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-argument-exception/index.html) or[IllegalStateException.](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-illegal-state-exception/index.html) Typically, these errors result from bad database logic, like a query missing an argument or attempting to write outside of a write transaction. However, these errors can be [ephemeral](https://mongodb.com/docs/realm/sdk/kotlin/errors/#std-label-kotlin-ephemeral-errors), so if there's no clear issue with the operation, try it again. ## Tip ### See also:  [RealmException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.exceptions/-realm-exception/index.html) ← [Handle Errors - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/errors/ \"Previous Section\")[Handle App Errors - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/errors/app/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/call-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call an Atlas Function - Kotlin SDK On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Call a Function](#call-a-function)\n* [Limitations](#limitations) ## Overview You can call an **Atlas Function** from a client application using the Realm Kotlin SDK. Functions are serverless JavaScript functions that let you define and execute server-side logic. These server-side Functions can run in the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your data in Atlas. For more information on configuring and writing Atlas Functions, refer to[Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) in the App Services documentation. ## Before You Begin 1. In an App Services App, [define an Atlas Function.](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-define-a-function)\n2. In your client project, [initialize the App client.](https://mongodb.com/docs/realm/sdk/kotlin/app-services/connect-to-app-services-backend/#std-label-kotlin-connect-to-backend)\n3. Then, [authenticate a user](https://mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-authenticate). Functions are accessed through the [User](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb/-user/index.html)object. ## Call a Function ## Important Make sure to sanitize client data to protect against code injection when using Functions. To call an Atlas Function from the Kotlin SDK, pass its name and all arguments to [Functions.call().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.ext/call.html) Consider an Atlas Function running in an App Services App named `sum` that takes two arguments, adds them, and returns the result: Atlas Function `| // Add two numbers         |\n| -------------------------- |\n| exports = function(a, b) { |\n| return a + b;              |\n| };                         | ` To call this Atlas Function from the Kotlin SDK: ```kotlin runBlocking {     val app: App = App.create(appID)     val user = app.login(credentials)     // Access the Atlas Function through the authenticated user     // Pass the Function name and all arguments     val response = user.functions.call<Int>(\"sum\", 1, 2)     print(response) // prints: 3 } \n``` ## Limitations Because the [Kotlin serialization engine](https://github.com/Kotlin/kotlinx.serialization/blob/master/docs/formats.md) does not yet support third-party libraries, there are limitations to the types you can pass as arguments and the types you can deserialize the results to in a called Function. You _cannot_ pass objects as arguments. The following are valid argument value types: * Primitives\n* Bson\n* MutableRealmInt\n* RealmUUID\n* ObjectId\n* RealmInstant\n* RealmAny\n* Array\n* Collection (List or Set)\n* Map The following are valid return value types: * Primitives\n* Bson\n* MutableRealmInt\n* RealmUUID\n* ObjectId\n* RealmInstant\n* RealmAny\n* BsonArray (for Array and Collection argument types)\n* BsonDocument (for Map argument types)\n\n",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Realm Database Files - Kotlin SDK * [Open & Close a Realm](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/)\n* [Delete a Realm](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/delete-a-realm/)\n* [Encrypt a Realm](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/encrypt-a-realm/)\n* [Bundle a Realm](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/bundle-a-realm/) ← [UUID - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/uuid/ \"Previous Section\")[Open a Realm - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/serialization/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Serialization - Kotlin SDK Serialization methods used by libraries that depend on reflection, such as[GSON](https://github.com/google/gson) do not work with the SDK by default. This is because the SDK compiler plugin injects a hidden field into object models, prefixed with `io_realm_kotlin_`. The SDK uses this hidden field to manage internal object state. Any library that relies on fields instead of getters and setters needs to ignore this hidden field. To use the SDK with external libraries such as GSON, exclude the hidden fields from serialization using a prefix match: `| var gson: Gson = GsonBuilder()                               |\n| ------------------------------------------------------------ |\n| .setExclusionStrategies(object: ExclusionStrategy {          |\n| override fun shouldSkipField(f: FieldAttributes?): Boolean = |\n| f?.name?.startsWith(\"io_realm_kotlin_\") ?: false             |\n| override fun shouldSkipClass(clazz: Class<*>?): Boolean =    |\n| false                                                        |\n| })                                                           |\n| .create()                                                    | ` ← [React to Changes - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/react-to-changes/ \"Previous Section\")[Sync - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/update/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Update - Kotlin SDK ← [Iteration - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/iteration/ \"Previous Section\")[Modify an Object - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/update/modify-an-object/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/frozen-arch/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Frozen Architecture - Kotlin SDK Unlike the other Realm SDKs, the Kotlin SDK does not provide live objects and collections that update simultaneously with underlying data. Instead, the Kotlin SDK works exclusively with **frozen objects**that can be passed between threads safely. ## Work with Frozen Objects Because frozen objects don't automatically update when data changes in your realm, they work a little differently from the live objects you may have used in other Realm SDKs. ### Access a Live Version of Frozen Object In order to modify objects, they must be live. You can convert a frozen object to a live object in a transaction with [mutableRealm.findLatest()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-mutable-realm/find-latest.html). Live objects are only accessible inside of a write transaction within a [write](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html)or [writeBlocking](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html)closure. Objects returned from a write closure become frozen objects when the write transaction completes. `| val sample: Sample? =                   |\n| --------------------------------------- |\n| realm.query<Sample>()                   |\n| .first().find()                         |\n| // delete one object synchronously      |\n| realm.writeBlocking {                   |\n| if (sample != null) {                   |\n| findLatest(sample)                      |\n| ?.also { delete(it) }                   |\n| }                                       |\n| }                                       |\n| // delete a query result asynchronously |\n| GlobalScope.launch {                    |\n| realm.write {                           |\n| query<Sample>()                         |\n| .first()                                |\n| .find()                                 |\n| ?.also { delete(it) }                   |\n| }                                       |\n| }                                       | ` ## Thread-safe Realms\n\n ### Access Changes To access changes to objects and collections, use[Coroutines](https://kotlinlang.org/docs/coroutines-overview.html)and the [Flow API](https://kotlinlang.org/docs/flow.html). Changes are thread-safe, so you can access them from any context. Notifications are handled on a dedicated internal notifier thread. Frozen objects now support change listeners. ```kotlin val config = RealmConfiguration.Builder(schema = setOf(Task::class))     .build() val realm = Realm.open(config) // fetch objects from a realm as Flowables CoroutineScope(Dispatchers.Main).launch {     val flow: Flow<ResultsChange<Task>> = realm.query<Task>().asFlow()     flow.collect { task ->         Log.v(\"Task: $task\")     } } // write an object to the realm in a coroutine CoroutineScope(Dispatchers.Main).launch {     realm.write {         copyToRealm(Task().apply { name = \"my task\"; status = \"Open\"})     } } \n``` ## Important ### Flows API Requires Kotlinx Coroutines To use the Flows API in your KMM project, install the[kotlinx.coroutines](https://github.com/Kotlin/kotlinx.coroutines#multiplatform)library. Just like in other Realm SDKs, write transactions implicitly advance your realm to the most recent version of data stored on disk. ## Tip ### See also:  For more information on notifications, refer to [React to Changes.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/react-to-changes/#std-label-kotlin-react-to-changes) ### Lazy Loading Realm objects are still lazy-loaded by default. This allows you to query large collections of objects without reading large amounts of data from disk. This also means that the first access to a field of an object will always return the most recent data. ← [Realm Database Overview - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/overview/ \"Previous Section\")[Define a Realm Object Model - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/errors/app/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Handle App Errors - Kotlin SDK On this page * [Service Errors](#service-errors)\n* [Connection Errors](#connection-errors)\n* [Bad Request Errors](#bad-request-errors)\n* [Auth Errors](#auth-errors)\n* [User Already Confirmed Errors](#user-already-confirmed-errors)\n* [User Not Found Errors](#user-not-found-errors)\n* [User Already Exists Errors](#user-already-exists-errors)\n* [Invalid Credentials Errors](#invalid-credentials-errors)\n* [Sync Errors](#sync-errors)\n* [Unrecoverable Sync Errors](#unrecoverable-sync-errors)\n* [Wrong Sync Type Errors](#wrong-sync-type-errors)\n* [Bad Flexible Sync Query Errors](#bad-flexible-sync-query-errors) App errors fall into two major categories: [ServiceException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-service-exception/index.html)and[SyncException.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-sync-exception/index.html) ## Service Errors Service errors occur when an Atlas App Services request fails at the HTTP level, i.e. the HTTP request returned, but the HTTP Status code was not 200 (OK). ## Tip ### See also:  [ServiceException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-service-exception/index.html) ### Connection Errors Connection errors happen when HTTP communication fails between the SDK and the App Services backend, ie. the HTTP request isn't able to receive a status code. Because these errors stem from network layers outside of the SDK's control, you should consider these errors [ephemeral](https://mongodb.com/docs/realm/sdk/kotlin/errors/#std-label-kotlin-ephemeral-errors). Retry the operation, then investigate the error if the retry fails. If the operation fails because the client device is offline, you can ask the app user to retry the operation when they reconnect to the internet. ## Tip ### See also:  [ConnectionException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-connection-exception/index.html) ### Bad Request Errors Bad request errors come from malformed App Services requests. When you get a bad request error: * Check the inputs for the operation.\n* Check your App logs for more information about what went wrong. ## Tip ### See also:  [BadRequestException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-bad-request-exception/index.html) ### Auth Errors Auth errors happen when a user account action, such as login, logout, or registration, fails. Usually, you'll get a more specific subtype that helps you identify a solution. ## Tip ### See also: \n\n #### User Already Confirmed Errors User already confirmed errors occur when you attempt to[confirm](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.auth/-email-password-auth/confirm-user.html)a user who you have already confirmed. When you get a user already confirmed error, it's best to not disrupt the application flow. Since the user is confirmed, you can safely proceed to log in. There is no need to retry confirmation. ## Tip ### See also:  [UserAlreadyConfirmedException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-user-already-confirmed-exception/index.html) #### User Not Found Errors User not found errors occur when the App Services backend cannot find a user with the supplied username. This is commonly caused by typos in email/password usernames. When you experience this error, prompt the user to re-enter their username and try again. ## Tip ### See also:  [UserNotFoundException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-user-not-found-exception/index.html) #### User Already Exists Errors User already exists errors occur when a client attempts to register a user with a username that is already in use in that App. When you experience this error, prompt users to: * use a different username\n* login with their existing username if they already have an account ## Tip ### See also:  [UserAlreadyExistsException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-user-already-exists-exception/index.html) #### Invalid Credentials Errors Invalid credential errors occur when a JWT, email/password, or API Key user login fails due to invalid credentials. Other authentication providers throw an [Auth Error](#std-label-kotlin-auth-errors) instead. ## Tip ### See also:  [InvalidCredentialsException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-invalid-credentials-exception/index.html) ## Sync Errors Sync errors occur when Device Sync fails. ## Tip ### See also:  [SyncException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-sync-exception/index.html) ## Tip For a list of common Device Sync errors and how to handle them, refer to[Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services Device Sync documentation. ### Unrecoverable Sync Errors Unrecoverable sync errors happen when Device Sync fails catastrophically. This usually means a bug in the client or connected App. When an unrecoverable sync error occurs, you should surface the problem to the end user. Let them know that Device Sync won't work until the problem is solved. It's best to send yourself an alert so you can check the backend App logs and fix the problem as soon as possible. ## Tip ### See also: \n\n ### Wrong Sync Type Errors Wrong sync type errors happen when the client and App use different sync protocols. The SDK supports two kinds of sync: [flexible sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) and [partition based](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-sync-partitions). sync. When a client connects to an App using a sync type that does not match the App's sync type, a wrong sync type error occurs. To recover from a wrong sync type error, update the client to use a sync type that matches the backend. This will most likely require the user to update to a new version of your app containing the fix. ## Tip ### See also:  [WrongSyncTypeException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-wrong-sync-type-exception/index.html) ### Bad Flexible Sync Query Errors Bad flexible sync query errors happen when you try to subscribe to a flexible sync query that is not supported by the App backend. This can happen when you: * query a field not specified as a **queryable field** in your flexible sync configuration\n* create a flexible sync query using operators unsupported by flexible sync To recover from a bad flexible sync query error, update your client to use a sync query compatible with your App configuration. This will most likely require the user to update to a new version of your app containing the fix. ## Tip ### See also:  [BadFlexibleSyncQueryException](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.exceptions/-bad-flexible-sync-query-exception/index.html) ← [Handle Realm Errors - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/errors/realm/ \"Previous Section\")[Telemetry - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/telemetry/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/read/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Read - Kotlin SDK ← [Create a New Object - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/create/create-a-new-object/ \"Previous Section\")[Find Object by Primary Key - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/find-object-by-primary-key/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Write Transactions - Kotlin SDK On this page * [Run a Transaction](#run-a-transaction) Realm Database uses a highly efficient storage engine to persist objects. You can **create** objects in a realm,**update** objects in a realm, and eventually **delete**objects from a realm. Because these operations modify the state of the realm, we call them writes. Realm handles writes in terms of **transactions**. A transaction is a list of read and write operations that Realm treats as a single indivisible operation. In other words, a transaction is _all or nothing_: either all of the operations in the transaction succeed or none of the operations in the transaction take effect. ## Note All writes must happen in a transaction. A realm allows only one open write transaction at a time. Realm blocks other writes on other threads until the open transaction is complete. Consequently, there is no race condition when reading values from the realm within a transaction. When you are done with your transaction, Realm either**commits** it or **cancels** it: * When Realm **commits** a transaction, Realm writes all changes to disk. For synced realms, the SDK queues the change for synchronization with the backend.\n* When Realm **cancels** a write transaction or an operation in the transaction causes an error, all changes are discarded (or \"rolled back\"). ## Run a Transaction Realm represents each transaction as a callback function that contains zero or more read and write operations. To run a transaction, define a transaction callback and pass it to the realm's `write` method. Within this callback, you are free to create, read, update, and delete on the realm. If the code in the callback throws an exception when Realm runs it, Realm cancels the transaction. Otherwise, Realm commits the transaction immediately after the callback. ## Example The following code shows how to run a transaction with[write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html)or [writeBlocking()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html). If the code in the callback throws an exception, Realm cancels the transaction. Otherwise, Realm commits the transaction.\n\n ` ← [Bundle a Realm - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/bundle-a-realm/ \"Previous Section\")[Create - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/create/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create - Kotlin SDK ← [Write Transactions - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/ \"Previous Section\")[Create a New Object - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/create/create-a-new-object/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/overview/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database Overview - Kotlin SDK On this page * [Database Internals](#database-internals)\n* [Native Database Engine](#native-database-engine)\n* [Realm Files](#realm-files)\n* [Copy-on-Write: The Secret Sauce of Data Versioning](#copy-on-write--the-secret-sauce-of-data-versioning)\n* [Memory Mapping](#memory-mapping)\n* [Compaction](#compaction)\n* [ACID Compliance](#acid-compliance)\n* [Features](#features)\n* [Queries](#queries)\n* [Indexes](#indexes)\n* [Schemas](#schemas)\n* [Atlas Device Sync](#atlas-device-sync) Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) This page explains some of the implementation details and inner workings of Realm Database and Device Sync. This page is for you if you are: * a developer interested in learning more about Realm Database\n* comparing Realm Database with competing databases\n* trying to understand the difference between Realm Database and Device Sync This explanation begins with a deep dive into database internals, continues with a high-level introduction to some of the features of Realm Database, and wraps up with some of the differences between Device Sync and the local version of Realm Database. ## Database Internals Realm Database uses a completely unique database engine, file format, and design. This section describes some of the high-level details of those choices. This section applies to both the device-local version of Realm Database as well as the networked Device Sync version. Differences between the local database and the synchronized database are explained in the Atlas Device Sync section. ### Native Database Engine Realm Database is an entire database written from scratch in C++, instead of building on top of an underlying database engine like SQLite. Realm Database's underlying storage layer uses[B+ trees](https://en.wikipedia.org/wiki/B%2B%5Ftree) to organize objects. As a result, Realm Database controls optimizations from the storage level all the way up to the access level. Realm Database stores data in **realms**: collections of heterogeneous realm objects. You can think of each realm as a database. Each object in a realm is equivalent to a row in a SQL database table or a MongoDB document. Unlike SQL, realms do not separate different object types into individual tables. Realm Database stores objects as groups of property values. We call this column-based storage. This means that queries or writes for individual objects can be slower than row-based storage equivalents when unindexed, but querying a single field across multiple objects or fetching multiple objects can be much faster due to spatial locality and in-CPU vector operations. Realm Database uses a [zero-copy](https://en.wikipedia.org/wiki/Zero-copy) design to make queries faster than an ORM, and often faster than raw SQLite. ### Realm Files Realm Database persists data in files saved on device storage. The database uses several kinds of file:\n\n Realm files contain object data with the following data structures: Groups, Tables, Cluster Trees, and Clusters. Realm Database organizes these data structures into a tree structure with the following form: * The top level, known as a Group, stores object metadata, a transaction log, and a collection of Tables.\n* Each class in the realm schema corresponds to a Table within the top-level Group.\n* Each Table contains a Cluster Tree, an implementation of a B+ tree.\n* Leaves on the Cluster Tree are called Clusters. Each contains a range of objects sorted by key value.\n* Clusters store objects as collections of columns.\n* Each column contains data for a single property for multiple instances of a given object. Columns are arrays of data with uniformly sized values.\n* Columns store data in one of the following sizes: 1, 2, 4, 8, 16, 32, or 64 bits. Each column uses one value size, determined by the largest value. Since pointers refer to memory addresses, objects written to persistent files cannot store references as pointers. Instead, realm files refer to data using the offset from the beginning of the file. We call this a ref. As Realm Database uses memory mapping to read and write data, database operations translate these refs from offsets to memory pointers when navigating database structures. ### Copy-on-Write: The Secret Sauce of Data Versioning Realm Database uses a technique called **copy-on-write**, which copies data to a new location on disk for every write operation instead of overwriting older data on disk. Once the new copy of data is fully written, the database updates existing references to that data. Older data is only garbage collected when it is no longer referenced or actively in use by a client application. Because of copy-on-write, older copies of data remain valid, since all of the references in those copies still point to other valid data. Realm Database leverages this fact to offer multiple versions of data simultaneously to different threads in client applications. Most applications tie data refreshes to the repaint cycle of the looper thread that controls the UI, since data only needs to refresh as often as the UI does. Longer-running procedures on background threads, such as large write operations, can work with a single version of data for a longer period of time before committing their changes. ### Memory Mapping Writes use [memory mapping](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) to avoid copying data back and forth from memory to storage. Accessors and mutators read and write to disk via memory mapping. As a result, object data is never stored on the stack or heap of your app. By default, data is memory-mapped as read-only to prevent accidental writes. Realm Database uses operating system level paging, trusting each operating system to implement memory mapping and persistence better than a single library could on its own. ### Compaction Realm Database automatically reuses free space that is no longer needed after database writes. However, realm files never shrink automatically, even if the amount of data stored in your realm decreases significantly. Compact your realm to optimize storage space and decrease file size if possible. You should compact your realms occasionally to keep them at an optimal size. You can do this manually, or by configuring your realms to compact on launch. However, Realm Database reclaims unused space for future writes, so compaction is only an optimization to conserve space on-device. ### ACID Compliance Realm Database guarantees that transactions are [ACID](https://en.wikipedia.org/wiki/ACID) compliant. This means that all committed write operations are guaranteed to be valid and that clients don't see transient states in the event of a system crash. Realm Database complies with ACID with the following design choices:\n\n ## Features Realm Database supports many popular database features. ### Queries You can query Realm Database using platform-native queries or a raw query language that works across platforms. ### Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time. ### Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, happen automatically. However, your SDK may require you to increase the local schema version to begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. See your SDK's documentation for more information on migrations. ## Atlas Device Sync Device Sync adds network synchronization between an Atlas App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. Device Sync relies on a worker client that communicates with your application backend in a dedicated thread in your application. Additionally, synced realms keep a history of changes to contained objects. Sync uses this history to resolve conflicts between client changes and backend changes. Applications that use Device Sync define their schema on the backend using[JSON Schema](https://json-schema.org/learn/getting-started-step-by-step.html). Client applications must match that backend schema to synchronize data. However, if you prefer to define your initial schema in your application's programming language, you can use [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to create a backend JSON Schema based on native SDK objects as you write your application. However, once your application is used for production purposes, you should alter your schema using JSON Schema on the backend. ← [Realm Database - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/ \"Previous Section\")[Frozen Architecture - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/frozen-arch/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete - Kotlin SDK ← [Update a Collection - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/update/update-collection/ \"Previous Section\")[Delete an Object - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-an-object/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Schemas - Kotlin SDK ← [Change an Object Model - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/change-an-object-model/ \"Previous Section\")[Supported Types - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/supported-types/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/migrate-from-java-sdk-to-kotlin-sdk/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Migrate from the Java SDK to the Kotlin SDK On this page * [Overview](#overview)\n* [Kotlin SDK Architecture](#kotlin-sdk-architecture)\n* [Opening Realms](#opening-realms)\n* [Realm Object Models](#realm-object-models)\n* [Relationships](#relationships)\n* [One-to-One](#one-to-one)\n* [One-to-Many](#one-to-many)\n* [Schema Types](#schema-types)\n* [Writes](#writes)\n* [Async](#async)\n* [Sync](#sync)\n* [Queries](#queries)\n* [Filters](#filters)\n* [Sort, Distinct, Limit](#sort--distinct--limit)\n* [Deletes](#deletes)\n* [Notifications](#notifications)\n* [Threading](#threading)\n* [Migrations](#migrations)\n* [What Next?](#what-next-) ## Note ### What is the Kotlin SDK? The Kotlin SDK is a new Realm client SDK built entirely with the Kotlin programming language. The Kotlin SDK uses an entirely different codebase from the Java SDK. It is designed specifically to take advantage of Kotlin language features such as coroutines and suspend functions. The Java SDK also supports some of these features, as well as Android applications written in Kotlin. But the[Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/#std-label-kotlin-intro) is more Kotlin-idiomatic than the Java SDK. ## Overview The Java SDK and the Kotlin SDK differ in many ways. On this page, you'll find a high-level comparison of most of the ways the SDKs differ. ## Kotlin SDK Architecture The Java SDK provided live objects, queries, and realms that automatically update when underlying data changes. The Kotlin SDK still provides this live interface in write transactions, but otherwise relies on a new frozen architecture that makes Realm objects easier to work with. Here are some of the main differences between the Java SDK architecture and the Kotlin SDK architecture: * **Frozen by default**: All objects are now frozen. Unlike live objects, frozen objects do not automatically update after database writes. You can still access live objects within a write transaction, but passing a live object out of a write transaction freezes the object.\n* **Thread-safety**: All realm instances, objects, query results, and collections can now be transferred across threads.\n* **Singleton**: You now only need one instance of each realm.[No need to open and close realms on individual threads.](#std-label-kotlin-migration-threading) ## Tip ### See also:  [Frozen Architecture in the Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/frozen-arch/#std-label-kotlin-frozen-architecture) ## Opening Realms The Java SDK automatically detects Realm Object Models defined in your application, and uses all of them in the schema of opened realms unless you specify otherwise. The Kotlin SDK requires you to manually specify the Realm Object Models to use in your realm schema. Additionally: * The Kotlin SDK does not provide the ability to set and access a default realm in your application. Since you can now share realms, objects, and results across threads, you can rely on a global singleton instead.\n* The Java SDK used `RealmConfiguration.Builder().build()` to generate instances of `RealmConfiguration`. With the Kotlin SDK, use the [RealmConfiguration.create()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/-companion/create.html)companion method `RealmConfiguration` instead.\n* The Java SDK used the static `Realm.getInstance()` method to open a realm with a given config. With the Kotlin SDK, use the static`Realm.open()` method instead.\n\n Kotlin SDK `| val config = RealmConfiguration.Builder( |\n| ---------------------------------------- |\n| setOf(Frog::class, Sample::class))       |\n| .name(REALM_NAME)                        |\n| .deleteRealmIfMigrationNeeded()          |\n| .directory(PATH)                         |\n| .encryptionKey(KEY)                      |\n| .build()                                 |\n| val realm = Realm.open(config)           |\n| Log.v(\"Successfully opened realm:\" +     |\n| realm.configuration.name                 |\n| )                                        | ` ## Tip ### See also:  [Open & Close a Realm](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/#std-label-kotlin-open-and-close-a-realm) ## Realm Object Models In the Java SDK, you declare Realm object models in one of two ways: * extend `RealmObject`\n* implement `RealmModel` The Kotlin SDK uses default methods in the `RealmObject` interface instead. With the Kotlin SDK, inherit from `RealmObject` to declare a Realm object model. Annotations work the same way they did in java for fields with special properties, such as ignored fields, primary keys, and indexes. ## Tip ### See also:  [Supported Schemas Types](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/supported-types/#std-label-kotlin-supported-types) ## Relationships Both the Java and Kotlin SDKs declare relationships through Realm object fields: ### One-to-One ### One-to-Many With the Java SDK, you could define one-to-many relationships with fields of type `RealmList`. The Kotlin SDK still uses fields of type `RealmList`, but you should instantiate `RealmList`instances with the [realmListOf()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.ext/realm-list-of.html) companion method. ## Schema Types With the Java SDK, you needed to use the `@Required` annotation to make lists of primitives non-nullable in realm object models. The Kotlin SDK makes lists of primitives non-nullable by default. Use the`?` operator to make a list of primitives nullable. ## Writes The Kotlin SDK introduces new names for the methods that write to realms. ### Async With the Java SDK, you could write asynchronously to a realm with`realm.executeTransactionAsync()`. The Kotlin SDK uses the suspend function [realm.write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) instead. ### Sync With the Java SDK, you could write synchronously to a realm with`realm.executeTransaction()`. The Kotlin SDK uses[realm.writeBlocking():](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html) ## Tip ### See also: \n\n ## Queries There are several differences between queries in the Java SDK and queries in the Kotlin SDK: * With the Java SDK, you can query objects in realms using a fluent interface or [Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql) (RQL). The Kotlin SDK only uses RQL.\n* The Java SDK uses `realm.where()`to query realms, whereas the Kotlin SDK uses [realm.query().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.ext/query.html)\n* With the Java SDK, you could query asynchronously with`realmQuery.findAllAsync()` and `realmQuery.findFirstAsync()`. In the Kotlin SDK, query asynchronously with[realmQuery.asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/as-flow.html). Once you have a flow of results, you can [collect](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html)the results.\n* With the Java SDK, you could query synchronously with`realmQuery.findAll()` and `realmQuery.findFirst()`. In the Kotlin SDK, query synchronously with[realmQuery.find().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/find.html) ### Filters ### Sort, Distinct, Limit ## Tip ### See also:  * [Filter Data - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/filter-data/#std-label-kotlin-filter-data)\n* [Sort Queries - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/sort-queries/#std-label-kotlin-sort-queries) ## Deletes In both SDKs, you can only delete live objects. The Kotlin SDK provides[mutableRealm.findLatest()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-mutable-realm/find-latest.html)to access a live version of any frozen object. In a write transaction, you can directly query for live objects and delete them without using`findLatest()`. ## Tip ### See also:  * [Delete all Objects of a Type](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-all-objects-of-a-type/#std-label-kotlin-delete-all-objects-of-a-type)\n* [Delete Multiple Objects](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-multiple-objects/#std-label-kotlin-delete-multiple-objects)\n* [Delete an Object](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-an-object/#std-label-kotlin-delete-an-object) ## Notifications In both SDKs, you can subscribe to change to collections of results. With the Java SDK, you could receive notifications whenever realm results changed with the following interfaces: * `realmResults.addChangeListener()`\n* RxJava through `asFlowable()`\n* Kotlin Extensions with `toFlow()`\n\n ## Threading With the Java SDK, realms, Realm objects, and results cannot be passed between threads. The Kotlin SDK freezes these objects by default, making them thread-safe. Unlike the live objects used by the Java SDK, the frozen objects found in the Kotlin SDK do not automatically update when underlying data changes. With the Kotlin SDK, you must use notifications to subscribe to updates instead. ## Tip ### See also:  [Frozen Architecture](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/frozen-arch/#std-label-kotlin-frozen-architecture) ## Migrations With the Java SDK, migrations were a manual process. The Kotlin SDK automates migrations, but also gives you access to a similar dynamic realm interface for custom tweaks to migration logic. ## What Next? Now that you understand the differences between the Java SDK and the Kotlin SDK, check out the rest of the [Kotlin SDK documentation.](https://mongodb.com/docs/realm/sdk/kotlin/#std-label-kotlin-intro) ← [Telemetry - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/telemetry/ \"Previous Section\")[Realm .NET SDK](https://mongodb.com/docs/realm/sdk/dotnet/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Define a Realm Object Model - Kotlin SDK On this page * [Overview](#overview)\n* [Object Types & Schemas](#object-types---schemas)\n* [Realm Schema](#realm-schema)\n* [Define a New Object Type](#define-a-new-object-type)\n* [Property Annotations](#property-annotations)\n* [Required and Optional Properties](#required-and-optional-properties)\n* [Default Field Values](#default-field-values)\n* [Specify a Primary Key](#specify-a-primary-key)\n* [Map a Property to a Different Name](#map-a-property-to-a-different-name)\n* [Ignore Properties from Realm Schema](#ignore-properties-from-realm-schema)\n* [Index Properties](#index-properties)\n* [Define Relationship Properties](#define-relationship-properties) ## Overview Realm applications model data as objects composed of field-value pairs that each contain one or more data types or other Realm objects. The Kotlin SDK memory maps Realm objects directly to native Kotlin objects, so there's no need to use a special data access library. You define your application's data model via regular Kotlin classes declared in your application code object. To learn about how to make changes to your Realm objects after defining your Realm object model, refer to[Change an Object Model.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/change-an-object-model/#std-label-kotlin-change-object-model) ## Object Types & Schemas Realm objects are regular Kotlin classes, and you can work with them as you would any other class instance. * Every Realm object has an **object type** that refers to the object's class.\n* Objects of the same type share an **object schema**, which defines the properties and [relationships](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/relationships/#std-label-kotlin-relationships) for objects of that type. You define object schemas by using Kotlin class declarations. ## Example The following schema defines a `Car` object type with`make`, `model`, and `miles` properties: `| class Car : RealmObject { |\n| ------------------------- |\n| var make: String = \"\"     |\n| var model: String = \"\"    |\n| var miles: Int = 0        |\n| }                         | ` ### Realm Schema A **realm schema** is a list of valid object schemas that a realm may contain. Every Realm object must conform to an object type that's included in its realm's schema. If a realm already contains data when you open it, Realm Database validates each object to ensure that an object schema was provided for its type and that it meets all of the constraints specified in the schema. ## Define a New Object Type To define a Realm object type: 1. Create a uniquely named Kotlin class that implements the[RealmObject](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-object/index.html)or[EmbeddedRealmObject](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-embedded-realm-object/index.html)interface.\n2. Add fields to your class. You can add any [supported data types](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/supported-types/#std-label-kotlin-supported-types) as a field in your class.\n3. Add any property annotations to give Realm additional information about a property, including whether Realm should ignore the property or should be indexed. ```kotlin // Defines a `Cat` object type // with several properties class Cat : RealmObject {\n\n     var color: String? = null     var age: Int = 0 } \n``` ## Note Class names are limited to a maximum of 57 UTF-8 characters. Once you've defined your object model, you can pass the class to the `schema`property of the[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html)when you [open the realm.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/#std-label-kotlin-open-a-realm) ```kotlin val config = RealmConfiguration.Builder(     schema = setOf(Cat::class) // Pass the defined class as the object schema )     .build() val realm = Realm.open(config) \n``` ## Property Annotations Use annotations to add functionality to properties in your Realm object models. ### Required and Optional Properties In Kotlin, value types are implicitly non-nullable. You can make properties optional (nullable) using the built-in `?` Kotlin operator. ```kotlin class Cat : RealmObject {     @PrimaryKey     var _id: ObjectId = ObjectId() // Primary key     @Index     var name: String = \"\" // Indexed property     var color: String? = null // Optional property     var age: Int = 0 // 0 is default value     @Ignore     var tempId: Int = 0 // Ignored property     @PersistedName(\"latin_name\") // Remapped property     var species: String? = null } \n``` ### Default Field Values You can assign a default value to a property in the property declaration. ```kotlin class Cat : RealmObject {     @PrimaryKey     var _id: ObjectId = ObjectId() // Primary key     @Index     var name: String = \"\" // Indexed property     var color: String? = null // Optional property     var age: Int = 0 // 0 is default value     @Ignore     var tempId: Int = 0 // Ignored property     @PersistedName(\"latin_name\") // Remapped property     var species: String? = null } \n``` ### Specify a Primary Key You can specify a property as the object type's primary key. The primary key is a unique identifier for an object in a realm. To specify a property as a primary key, use the `@PrimaryKey` annotation. For more information, refer to [Primary Keys.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/primary-key/#std-label-kotlin-primary-keys) ```kotlin class Cat : RealmObject {     @PrimaryKey     var _id: ObjectId = ObjectId() // Primary key     @Index     var name: String = \"\" // Indexed property     var color: String? = null // Optional property     var age: Int = 0 // 0 is default value     @Ignore     var tempId: Int = 0 // Ignored property     @PersistedName(\"latin_name\") // Remapped property     var species: String? = null } \n``` ### Map a Property to a Different Name To persist a field under a different property name, use the `@PersistedName` annotation. This is useful when you open a Realm across different bindings where code style conventions can differ. For more information, refer to [Remap a Property.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/remap/#std-label-kotlin-remap-a-property) ```kotlin class Cat : RealmObject {     @PrimaryKey     var _id: ObjectId = ObjectId() // Primary key     @Index     var name: String = \"\" // Indexed property     var color: String? = null // Optional property     var age: Int = 0 // 0 is default value     @Ignore     var tempId: Int = 0 // Ignored property\n\n     var species: String? = null } \n``` ### Ignore Properties from Realm Schema By default, Realm manages properties defined in your Realm object model. * **Managed properties** are stored or updated in the database.\n* **Ignored properties** are _not_ stored to the database. You can mix managed and ignored properties within a class. To ignore a property, use the `@Ignore` annotation. For more information, refer to [Ignore a Field.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/ignore/#std-label-kotlin-ignore) ```kotlin class Cat : RealmObject {     @PrimaryKey     var _id: ObjectId = ObjectId() // Primary key     @Index     var name: String = \"\" // Indexed property     var color: String? = null // Optional property     var age: Int = 0 // 0 is default value     @Ignore     var tempId: Int = 0 // Ignored property     @PersistedName(\"latin_name\") // Remapped property     var species: String? = null } \n``` ### Index Properties To create an index on a property, use the `@Index` annotation. For more information, refer to [Index a Field.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/index/#std-label-kotlin-indices) ```kotlin class Cat : RealmObject {     @PrimaryKey     var _id: ObjectId = ObjectId() // Primary key     @Index     var name: String = \"\" // Indexed property     var color: String? = null // Optional property     var age: Int = 0 // 0 is default value     @Ignore     var tempId: Int = 0 // Ignored property     @PersistedName(\"latin_name\") // Remapped property     var species: String? = null } \n``` ## Define Relationship Properties You can define relationships between Realm objects in your schema. The Realm Kotlin SDK supports to-one relationships, to-many relationships, inverse relationships, and embedding objects within other objects. To learn more about how to define relationships in your Realm object schema, refer to [Relationships.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/relationships/#std-label-kotlin-relationships) ← [Frozen Architecture - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/frozen-arch/ \"Previous Section\")[Change an Object Model - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/change-an-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Open a Realm - Kotlin SDK On this page * [Open a Realm](#open-a-realm)\n* [Open a Local-Only Realm](#open-a-local-only-realm)\n* [Open an In-Memory Realm](#open-an-in-memory-realm)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Close a Realm](#close-a-realm)\n* [Copy Data into a New Realm](#copy-data-into-a-new-realm) ## Open a Realm Use[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html)to control the specifics of your realm that you would like to open. When you open the realm, you must provide a list of[object schemas](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-define-a-new-object-type) as an argument. A **realm schema** is a list of valid object schemas that a realm may contain. Every Realm object must conform to an object type that's included in its realm's schema. If a realm already contains data when you open it, Realm Database validates each object to ensure that an object schema was provided for its type and that it meets all of the constraints specified in the schema. ### Open a Local-Only Realm To open a realm that only persists data locally, create a[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html) with[RealmConfiguration.Builder](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/-builder/index.html)and pass the resulting `RealmConfiguration` to[Realm.open():](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/-companion/open.html) `| val config = RealmConfiguration.Builder(setOf(Frog::class))     |\n| --------------------------------------------------------------- |\n| .build()                                                        |\n| val realm = Realm.open(config)                                  |\n| Log.v(\"Successfully opened realm: ${realm.configuration.name}\") | ` ### Open an In-Memory Realm\n\n ```kotlin val config = RealmConfiguration.Builder(setOf(Frog::class))     .inMemory()     .build() val realm = Realm.open(config) Log.v(\"Successfully opened an in memory realm\") \n``` ### Open a Synced Realm To open a realm that synchronizes data with Atlas using Device Sync, refer to [Open a Synced Realm.](https://mongodb.com/docs/realm/sdk/kotlin/sync/open-a-synced-realm/#std-label-kotlin-open-a-synced-realm) ## Close a Realm You close a realm with [realm.close()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/close.html). The `close()` method blocks until all write transactions on the realm have completed. ```kotlin realm.close() \n``` ## Warning It's important to close your realm instance to free resources. Failing to close realms can lead to an `OutOfMemoryError`. ## Copy Data into a New Realm To copy data from an existing realm to a new realm with different configuration options, pass the new configuration to the[Realm.writeCopyTo()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-copy-to.html)method. For example, you might copy data as a way to backup a local realm or to convert a synced realm to a local realm. You can copy data to a realm that uses the same configuration: * Local realm to local realm\n* In-memory realm to in-memory realm\n* Synced realm to synced realm You can copy data to a realm that uses different sync configurations: * Local realm to Partition-Based Sync realm\n* Synced realm to local realm ## Warning You _cannot_ copy data from a local realm to a Flexible Sync realm. You can also combine changes to the configuration. For example, you can copy data from an unencrypted, in-memory synced realm to an encrypted local realm. Some additional considerations to keep in mind while using`Realm.writeCopyTo()`: * The destination file cannot already exist.\n* Copying a realm is not allowed within a write transaction or during a [migration.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/change-an-object-model/#std-label-kotlin-migrations)\n* When using [Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), you must sync all local changes with the server before the copy is written. This ensures that the file can be used as a starting point for a newly installed application. Realm throws an error if there are pending uploads.  \nYou can use [uploadAllLocalChanges()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-sync-session/upload-all-local-changes.html)and [downloadAllServerChanges()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-sync/-realm%20-kotlin%20-s-d-k%20-%20-sync/io.realm.kotlin.mongodb.sync/-sync-session/download-all-server-changes.html)to ensure all sync processes are completed. ## Example ### Copy Data from Flexible Sync Realm to Local Realm ```kotlin // Instantiate the synced realm with your App ID val app = App.create(YOUR_APP_ID) runBlocking {     val user = app.login(Credentials.anonymous())     // Create the synced realm configuration     val syncConfig = SyncConfiguration.Builder(user, setOf(Toad::class))         .initialSubscriptions { realm ->\n\n                 realm.query<Toad>(\"name == $0\", \"name value\"),                 \"subscription name\"             )         }         .build()     // Open the synced realm and add data to it     val syncRealm = Realm.open(syncConfig)     Log.v(\"Successfully opened realm: ${syncRealm.configuration}\")     syncRealm.write {         this.copyToRealm(Toad().apply {             name = \"Kermit\"         })     }     // Wait for write to sync     syncRealm.syncSession.uploadAllLocalChanges(30.seconds)     // Create the local realm     val localConfig = RealmConfiguration.Builder(setOf(Toad::class))         .name(\"local.realm\")         .build()     // Copy data from synced realm to the new realm     syncRealm.writeCopyTo(localConfig)     // Close the synced realm when you're done copying     syncRealm.close()     // Open the new local realm     val localRealm = Realm.open(localConfig)     // Copied Toad object is available in the new realm     val toad: Toad =         localRealm.query<Toad>().find().first()     Log.v(\"Copied Toad: ${toad.name}\")     localRealm.close() } \n``` You can also [include a new encryption key](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/encrypt-a-realm/#std-label-kotlin-encrypt-a-realm)in the copied realm's configuration or remove the encryption key from the new configuration. ## Example ### Copy Data from Unencrypted to Encrypted Realm ```kotlin runBlocking {     // Create the unencrypted realm     val unencryptedConfig = RealmConfiguration.Builder(setOf(Toad::class))         .name(\"unencrypted.realm\")         .build()     // Open the realm and add data to it     val unencryptedRealm = Realm.open(unencryptedConfig)     unencryptedRealm.write {         this.copyToRealm(Toad().apply {             name = \"Kermit\"         })     }     // ... Generate encryption key ...     // Create the encrypted realm     val encryptedConfig = RealmConfiguration.Builder(setOf(Toad::class))         .name(\"encrypted.realm\")         .encryptionKey(getEncryptionKey())         .build()     // Copy data from `unencryptedRealm` to the new realm     // Data is encrypted as part of the copy process     unencryptedRealm.writeCopyTo(encryptedConfig)     // Close the original realm when you're done copying     unencryptedRealm.close()     // Open the new encrypted realm     val encryptedRealm = Realm.open(encryptedConfig)     // Copied Toad object is available in the new realm     val toad: Toad =         encryptedRealm.query<Toad>().find().first()     Log.v(\"Copied Toad: ${toad.name}\")     encryptedRealm.close() } \n``` ## Example ### Copy Data from In-Memory to Local Realm ```kotlin runBlocking {     // Create the in-memory realm     val inMemoryConfig = RealmConfiguration.Builder(setOf(Toad::class))         .name(\"inMemory.realm\")         .inMemory()         .build()\n\n     val inMemoryRealm = Realm.open(inMemoryConfig)     inMemoryRealm.write {         this.copyToRealm(Toad().apply {             name = \"Kermit\"         })     }     // Create the local realm     val localConfig = RealmConfiguration.Builder(setOf(Toad::class))         .name(\"local.realm\")         .build()     // Copy data from `inMemoryRealm` to the new realm     inMemoryRealm.writeCopyTo(localConfig)     // Close the original realm when you're done copying     inMemoryRealm.close()     // Open the new local realm     val localRealm = Realm.open(localConfig)     // Copied Toad object is available in the new realm     val toad: Toad =         localRealm.query<Toad>().find().first()     Log.v(\"Copied Toad: ${toad.name}\")     localRealm.close() } \n``` ← [Manage Realm Database Files - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/ \"Previous Section\")[Delete a Realm - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/delete-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - Kotlin SDK On this page * [Register a Query Change Listener](#register-a-query-change-listener)\n* [Register a RealmObject Change Listener](#register-a-realmobject-change-listener)\n* [Register a RealmList Change Listener](#register-a-realmlist-change-listener)\n* [Unsubscribe a Change Listener](#unsubscribe-a-change-listener) Any modern app should be able to react when data changes, regardless of where that change originated. When a user adds a new item to a list, you may want to update the UI, show a notification, or log a message. When someone updates that item, you may want to change its visual state or fire off a network request. Finally, when someone deletes the item, you probably want to remove it from the UI. Realm's notification system allows you to watch for and react to changes in your data, independent of the writes that caused the changes. The frozen architecture of the Kotlin SDK makes notifications even more important. Because the Kotlin SDK doesn't have live objects that update automatically, you'll use notifications to keep your UI and data layer in sync. You can subscribe to changes on the following events: * [Query on collection](#std-label-kotlin-query-change-listener)\n* [Realm object](#std-label-kotlin-realm-object-change-listener)\n* [Realm collections (e.g. list)](#std-label-kotlin-realm-list-change-listener) ## Example ### About the Examples on This Page The examples in this page use two Realm object types, `Character` and`Fellowship`:\n\n ` The examples have this sample data: ```kotlin val config = RealmConfiguration.Builder(setOf(Fellowship::class, Character::class))     .name(realmName)     .build() val realm = Realm.open(config) val frodo = Character(\"Frodo\", \"Hobbit\", 51) val samwise = Character(\"Samwise\", \"Hobbit\", 39) val aragorn = Character(\"Aragorn\", \"Dúnedain\", 87) val legolas = Character(\"Legolas\", \"Elf\", 2931) val gimli = Character(\"Gimli\", \"Dwarf\", 140) val gollum = Character(\"Gollum\", \"Hobbit\", 589) val fellowshipOfTheRing = Fellowship(     \"Fellowship of the Ring\",     realmListOf(frodo, samwise, aragorn, legolas, gimli)) realm.writeBlocking{     this.copyToRealm(fellowshipOfTheRing)     this.copyToRealm(gollum) // not in fellowship } realm.close() \n``` ## Register a Query Change Listener You can register a notification handler on any query within a Realm. First, create a Kotlin Flow from the query with [asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/as-flow.html). Next, use the `collect()` method to handle events on that Flow. Events of type `UpdatedResults` record all changes to the objects matching the query using the following properties:\n\n ```kotlin // Listen for changes on whole collection val characters = realm.query(Character::class) // flow.collect() is blocking -- run it in a background context val job = CoroutineScope(Dispatchers.Default).launch {     // create a Flow from that collection, then add a listener to the Flow     val charactersFlow = characters.asFlow()     val subscription = charactersFlow.collect { changes: ResultsChange<Character> ->         when (changes) {             // UpdatedResults means this change represents an update/insert/delete operation             is UpdatedResults -> {                 changes.insertions // indexes of inserted objects                 changes.insertionRanges // ranges of inserted objects                 changes.changes // indexes of modified objects                 changes.changeRanges // ranges of modified objects                 changes.deletions // indexes of deleted objects                 changes.deletionRanges // ranges of deleted objects                 changes.list // the full collection of objects             }             else -> {                 // types other than UpdatedResults are not changes -- ignore them             }         }     } } // Listen for changes on RealmResults val hobbits = realm.query(Character::class, \"species == 'Hobbit'\") val hobbitJob = CoroutineScope(Dispatchers.Default).launch {     val hobbitsFlow = hobbits.asFlow()     val hobbitsSubscription = hobbitsFlow.collect { changes: ResultsChange<Character> ->         // ... all the same data as above     } } \n``` ## Register a RealmObject Change Listener You can register a notification handler on a specific object within a realm. Realm notifies your handler when any of the object's properties change. To register a change listener on a single object, obtain a [RealmSingleQuery](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-single-query/index.html)with `realm.query.first()`. Generate a Flow from that query with [asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/as-flow.html). The handler receives a `SingleQueryChange` object that communicates object changes using the following subtypes:\n\n ```kotlin // query for the specific object you intend to listen to val frodo = realm.query(Character::class, \"name == 'Frodo'\").first() // flow.collect() is blocking -- run it in a background context val job = CoroutineScope(Dispatchers.Default).launch {     val frodoFlow = frodo.asFlow()     frodoFlow.collect { changes: SingleQueryChange<Character> ->         when (changes) {             is UpdatedObject -> {                 changes.changedFields // the changed properties                 changes.obj // the object in its newest state                 changes.isFieldChanged(\"name\") // check if a specific field changed in value             }             is DeletedObject -> {                 // if the object has been deleted                 changes.obj // returns null for deleted objects -- always reflects newest state             }         }     } } \n``` ## Register a RealmList Change Listener You can register a notification handler on a list of `RealmObjects` within another `RealmObject`. Realm notifies your handler when any of the list items change. First, create a Kotlin Flow from the list with [asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-list/as-flow.html). Next, use the `collect()` method to handle events on that Flow. Events of type `UpdatedList` record all changes to the list using the following properties:\n\n ## Important You can only apply a change listener to a `RealmList<T as RealmObject>`. ```kotlin // query for the specific object you intend to listen to val fellowshipOfTheRing = realm.query(Fellowship::class, \"name == 'Fellowship of the Ring'\").first().find()!! val members = fellowshipOfTheRing.members // flow.collect() is blocking -- run it in a background context val job = CoroutineScope(Dispatchers.Default).launch {     val membersFlow = members.asFlow()     membersFlow.collect { changes: ListChange<Character> ->         when (changes) {             is UpdatedList -> {                 changes.insertions // indexes of inserted objects                 changes.insertionRanges // ranges of inserted objects                 changes.changes // indexes of modified objects                 changes.changeRanges // ranges of modified objects                 changes.deletions // indexes of deleted objects                 changes.deletionRanges // ranges of deleted objects                 changes.list // the full collection of objects             }             is DeletedList -> {                 // if the list was deleted             }         }     } } \n``` ## Unsubscribe a Change Listener Unsubscribe from your change listener when you no longer want to receive notifications on updates to the data it's watching. To unsubscribe a change listener, [cancel the enclosing coroutine.](https://kotlinlang.org/docs/cancellation-and-timeouts.html) ```kotlin // query for the specific object you intend to listen to val fellowshipOfTheRing = realm.query(Fellowship::class, \"name == 'Fellowship of the Ring'\").first().find()!! val members = fellowshipOfTheRing.members // flow.collect() is blocking -- run it in a background context val job = CoroutineScope(Dispatchers.Default).launch {     val membersFlow = members.asFlow()     membersFlow.collect { changes: ListChange<Character> ->         // change listener stuff in here     } } job.cancel() // cancel the coroutine containing the listener \n``` ← [Delete All Objects of a Type - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-all-objects-of-a-type/ \"Previous Section\")[Serialization - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/serialization/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/delete-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete a Realm - Kotlin SDK On this page * [Overview](#overview)\n* [Delete a Realm File to Avoid Migration](#delete-a-realm-file-to-avoid-migration) ## Overview In some circumstances, such as a [client reset scenario](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets), you might need to delete a realm file and its auxiliary files. This is often useful during development to quickly reset your environment. However, doing so when you are running your app and realm instances are still open can cause data corruption or disrupt [Atlas Device Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) To avoid losing data and disrupting Device Sync, you can delete these files when all instances of a realm are closed. Before you delete a realm file,**be sure that you back up any important objects, as you will lose all unsynced data in the realm**. To safely delete a realm file while the app is running, you can use the[Realm.deleteRealm()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/-companion/delete-realm.html)method. The following code demonstrates this: `| // You must close a realm before deleting it |\n| -------------------------------------------- |\n| realm.close()                                |\n| // Delete the realm                          |\n| Realm.deleteRealm(config)                    | ` ## Delete a Realm File to Avoid Migration If you iterate rapidly as you develop your app, you may want to delete a realm file instead of migrating it when you make schema changes. The Realm configuration provides a [deleteRealmIfMigrationNeeded](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html#-910115110%2FProperties%2F-1651551339)parameter to help with this case. When you use `deleteRealmIfMigrationNeeded`, Realm Database deletes the realm file if a migration is required. Then, you can create objects that match the new schema instead of writing migration blocks for development or test data. ```kotlin val config = RealmConfiguration.Builder(setOf(Frog::class))     .deleteRealmIfMigrationNeeded()     .build() val realm = Realm.open(config) Log.v(\"Successfully opened realm: ${realm.configuration.name}\") \n``` ← [Open a Realm - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/ \"Previous Section\")[Encrypt a Realm - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/encrypt-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/encrypt-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Encrypt a Realm - Kotlin SDK On this page * [Overview](#overview)\n* [Considerations](#considerations)\n* [Storing & Reusing Keys](#storing---reusing-keys)\n* [Performance Impact](#performance-impact)\n* [Encryption and Atlas Device Sync](#encryption-and-atlas-device-sync)\n* [Example](#example) ## Overview You can encrypt your realms to ensure that the data stored to disk can't be read outside of your application. You encrypt the realm database file on disk with AES-256 + SHA-2 by supplying a 64-byte encryption key when[opening the realm.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/#std-label-kotlin-open-and-close-a-realm) Realm transparently encrypts and decrypts data with standard[AES-256 encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) using the first 256 bits of the given 512-bit encryption key. Realm uses the other 256 bits of the 512-bit encryption key to validate integrity using a [hash-based message authentication code (HMAC).](https://en.wikipedia.org/wiki/HMAC) ## Warning Do not use cryptographically-weak hashes for realm encryption keys. For optimal security, we recommend generating random rather than derived encryption keys. ## Considerations The following are key impacts to consider when encrypting a realm. ### Storing & Reusing Keys You **must** pass the same encryption key every time you open the encrypted realm. If you don't provide a key or specify the wrong key for an encrypted realm, the Realm SDK throws an error. Apps should store the encryption key securely, typically in the target platform's secure key/value storage, so that other apps cannot read the key. For example, you can use the [Android Keystore system](https://developer.android.com/training/articles/keystore) or Apple's[Keychain](https://developer.apple.com/documentation/security/certificate%5Fkey%5Fand%5Ftrust%5Fservices/keys/storing%5Fkeys%5Fin%5Fthe%5Fkeychain). It is the developer's responsibility to ensure that attackers cannot access the key. ### Performance Impact Reads and writes on encrypted realms can be up to 10% slower than unencrypted realms. ### Encryption and Atlas Device Sync You can encrypt a [synced realm.](https://mongodb.com/docs/realm/sdk/kotlin/sync/open-a-synced-realm/#std-label-kotlin-open-a-synced-realm) Realm only encrypts the data on the device and stores the data unencrypted in your Atlas data source. Any users with authorized access to the Atlas data source can read the data, but the following still applies: * Users must have the correct read [permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read the synced data.\n* Data stored in Atlas is always encrypted at a volume (disk) level.\n* The transfer between client and server is always fully encrypted. You can also enable [Customer Key Management](https://www.mongodb.com/docs/atlas/security-kms-encryption/)to encrypt stored Atlas data using your cloud provider's key (e.g. AWS KMS, Azure Key Vault, Google Cloud KMS). If you need unique keys for each user of your application, you can use an OAuth provider or use one of the [Realm authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication)and an [authentication trigger](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-triggers)to create a 64-bit key and store that key in a [user object.](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) ## Example ## Warning\n\n The following code demonstrates how to generate an encryption key and open an encrypted realm:\n\n ` ← [Delete a Realm - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/delete-a-realm/ \"Previous Section\")[Bundle a Realm - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/bundle-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-multiple-objects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete Multiple Objects - Kotlin SDK To delete multiple objects from a realm at the same time: 1. Open a write transaction with [realm.write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) or[realm.writeBlocking().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html)\n2. Query the transaction's mutable realm for the objects you want to delete with [realm.query()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html). Specify the object type as a type parameter passed to `query()`. Filter the set of returned objects by specifying a query.\n3. Delete the set of [RealmResults](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-results/index.html)returned by the query with [realmResults.delete().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-results/delete.html) `| realm.write {                                                                |\n| ---------------------------------------------------------------------------- |\n| // fetch 7 frogs of the bullfrog species from the realm                      |\n| val frogs: RealmResults<Frog> =                                              |\n| this.query<Frog>(\"species == 'bullfrog' LIMIT(7)\").find()                    |\n| // call delete on the results of a query to delete those objects permanently |\n| delete(frogs)                                                                |\n| }                                                                            | ` ## Note You can only delete objects from a realm within a[write transaction.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/#std-label-kotlin-write-transactions) ← [Delete an Object - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-an-object/ \"Previous Section\")[Delete All Objects of a Type - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-all-objects-of-a-type/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/change-an-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Change an Object Model - Kotlin SDK On this page * [Overview](#overview)\n* [Schema Version](#schema-version)\n* [Migration](#migration)\n* [Automatically Update Schema](#automatically-update-schema)\n* [Add a Property](#add-a-property)\n* [Delete a Property](#delete-a-property)\n* [Manually Migrate Schema](#manually-migrate-schema)\n* [Modify a Property](#modify-a-property)\n* [Other Migration Tasks](#other-migration-tasks) ## Note ### Modify Schema Properties of a Synced Realm The following page demonstrates how to modify schema properties of a local realm. Learn how to [modify schema properties of a synced realm.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) ## Overview You can make changes to your object schema after you[create your Realm object model](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-define-object-model). Depending on the type of changes you make to the schema, the changes can be automatically applied or require a manual update to the new schema. * Realm will automatically update a Realm [object schema](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-object-schema) when you add or delete a property from a Realm object model. You only need to update the schema version.\n* For all other schema changes, you must manually migrate old instances of a given object to the new schema. ## Tip ### Bypass Migration During Development When developing or debugging your application, you may prefer to [delete the realm](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/delete-a-realm/#std-label-kotlin-delete-to-avoid-migration) instead of migrating it. Use the[deleteRealmIfMigrationNeeded](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/-builder/delete-realm-if-migration-needed.html)flag to delete the database automatically when a schema mismatch would require a migration. Never release an app to production with this flag set to `true`. ## Schema Version A **schema version** identifies the state of a[realm schema](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-realm-schema) at some point in time. Realm Database tracks the schema version of each realm and uses it to map the objects in each realm to the correct schema. Schema versions are ascending integers that you can optionally include in the realm configuration when you [open a realm](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/#std-label-kotlin-open-a-realm). If a client application does not specify a version number when it opens a realm, then the realm defaults to version `0`. ## Important ### Increment Versions Monotonically Migrations must update a realm to a higher schema version. Realm Database will throw an error if a client application opens a realm with a schema version that is lower than the realm's current version or if the specified schema version is the same as the realm's current version but includes different object schemas. ## Migration Schema updates are called **migrations** in Realm Database. A migration updates a realm and any objects it contains from one schema version to a newer version. Whenever you open an existing realm with a schema version greater than the realm's current version, you can provide a **migration function** that defines any additional logic needed for the schema update. For example: * Setting property values\n* Combining or splitting fields\n* Renaming a field\n* Changing a field's type\n\n A **local migration** is a migration for a realm that does _not_automatically [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) with another realm. ## Note To modify schema properties of a synced realm, refer to[Update a Data Model](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) in the Atlas Device Sync documentation. ## Automatically Update Schema If your schema update adds or removes properties, Realm Database can perform the migration automatically. You only need to increment the `schemaVersion`. ### Add a Property To add a property to a schema: 1. Add the new property to the `RealmObject` definition.\n2. Set the schema version through the [RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html) builder. Realm automatically sets values for new properties if the updated object schema specifies a default value. If the updated object schema does not specify a default value, you must manually set values for the new property through a [migration function.](#std-label-kotlin-other-migration-tasks) ## Example A realm using schema version `1` has a `Person` object type with first name, last name, and age properties: `| // Realm schema version 1    |\n| ---------------------------- |\n| class Person : RealmObject { |\n| var firstName: String = \"\"   |\n| var lastName: String = \"\"    |\n| var age: Int = 0             |\n| }                            | ` The developer adds an `email` field to the `Person` class: ```kotlin // Realm schema version 2 class Person : RealmObject {     var firstName: String = \"\"     var lastName: String = \"\"     var age: Int = 0     var email: String? = null } \n``` To change the realm to conform to the updated `Person` schema, the developer sets the realm's schema version to `2`: ```kotlin val config = RealmConfiguration.Builder(     schema = setOf(Person::class) )     .schemaVersion(2) // Sets the new schema version to 2     .build() val realm = Realm.open(config) \n``` ### Delete a Property To delete a property from a schema: 1. Remove the property from the object's class.\n2. Set the schema version through the[RealmConfiguration](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html) builder. Deleting a property will not impact existing objects. ## Example A realm using schema version `2` has a `Person` object type with first name, last name, age, and email properties: ```kotlin // Realm schema version 2 class Person : RealmObject {     var firstName: String = \"\"     var lastName: String = \"\"     var age: Int = 0     var email: String? = null } \n``` The developer removes the `age` field from the `Person` class: ```kotlin // Realm schema version 3 class Person : RealmObject {     var firstName: String = \"\"     var lastName: String = \"\"     // var age: Int = 0     var email: String? = null } \n``` To change the realm to conform to the updated `Person` schema, the developer sets the realm's schema version to `3`: ```kotlin val config = RealmConfiguration.Builder(     schema = setOf(Person::class) )     .schemaVersion(3) // Sets the new schema version to 3     .build() val realm = Realm.open(config) \n``` ## Manually Migrate Schema\n\n When you open the realm with the updated schema, you must do the following in the[RealmConfiguration:](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html) * Increment the `schemaVersion` property.\n* Define the migration logic using the [migrationContext.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.migration/-automatic-schema-migration/-migration-context/index.html) ### Modify a Property To modify an object property (e.g. rename, merge, split, or change property type): 1. Change the property or properties in the object schema.\n2. Open the realm with an incremented schema version and a migration function that maps the existing objects to use the new properties. In the following example, the schema is updated to change a property type, merge two properties into a new property, and rename an existing property: ```kotlin // Realm schema version 1 (oldObject) class Person : RealmObject {     var _id: ObjectId = ObjectId()     var firstName: String = \"\"     var lastName: String = \"\"     var age: Int = 0 } // Realm schema version 2 (newObject) class Person : RealmObject {     var _id: String = \"\" // change property type     var fullName: String = \"\" // merge firstName and lastName properties     var yearsSinceBirth: Int = 0 // rename property } \n``` Then, the migration function defines the migration logic to map data between the modified properties in the old object schema and the new object schema: ```kotlin // Use the configuration builder to open the realm with the newer schema version // and define the migration logic between your old and new realm objects val config = RealmConfiguration.Builder(     schema = setOf(Person::class) )     .schemaVersion(2) // Set the new schema version to 2     .migration(AutomaticSchemaMigration {         it.enumerate(className = \"Person\") { oldObject: DynamicRealmObject, newObject: DynamicMutableRealmObject? ->             newObject?.run {                 // Change property type                 set(                     \"_id\",                     oldObject.getValue<ObjectId>(fieldName = \"_id\").toString()                 )                 // Merge properties                 set(                     \"fullName\",                     \"${oldObject.getValue<String>(fieldName = \"firstName\")} ${oldObject.getValue<String>(fieldName = \"lastName\")}\"                 )                 // Rename property                 set(                     \"yearsSinceBirth\",                     oldObject.getValue<String>(fieldName = \"age\")                 )             }         }     })     .build() val realm = Realm.open(config) \n``` ## Note\n\n ### Other Migration Tasks To perform other realm schema migrations, use the following properties of the `AutomaticSchemaMigration.MigrationContext` interface: * [oldRealm](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.migration/-automatic-schema-migration/-migration-context/old-realm.html): The realm as it existed before the migration with the previous schema version. The [dynamic API](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.dynamic/index.html) lets you find Realm objects by a string representation of their class name.\n* [newRealm](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.migration/-automatic-schema-migration/-migration-context/new-realm.html): The realm as it exists after the migration using the new schema version. Any objects obtained from `oldRealm` and `newRealm`are valid only in the scope of the migration function. By the end of the migration, you must migrate all data affected by the schema update from the old realm to the new realm. Any data affected by the schema update that is not migrated will be lost. ```kotlin val config = RealmConfiguration.Builder(     schema = setOf(Person::class) )     .schemaVersion(2)     .migration(AutomaticSchemaMigration { migrationContext ->         val oldRealm = migrationContext.oldRealm // old realm using the previous schema         val newRealm = migrationContext.newRealm // new realm using the new schema         // Dynamic query for all Persons in old realm         val oldPersons = oldRealm.query(className = \"Person\").find()         for (oldPerson in oldPersons) {             // Get properties from old realm             val firstName: String = oldPerson.getValue(                 propertyName = \"firstName\", String::class             )             // Get objects from old realm as dynamic realm objects             val pet: DynamicRealmObject? = oldPerson.getObject(                 propertyName = \"pets\"             )         }         // Get migrated objects from the new realm as mutable objects         val oldPerson: DynamicMutableRealmObject? =             newRealm.findLatest(oldPersons[0])         oldPerson?.let {             it.set(\"fullName\", \"Crow T. Robot\")         }         // Create an object in the new realm and set property values         val newPerson = newRealm.copyToRealm(             DynamicMutableRealmObject.create(                 type = \"Person\",                 mapOf(                     \"_id\" to \"123456\",                     \"fullName\" to \"Tom Servo\",                     \"yearsSinceBirth\" to 33,\n\n             )         )     })     .build() val realm = Realm.open(config) \n``` ← [Define a Realm Object Model - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/ \"Previous Section\")[Schemas - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-an-object/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete an Object - Kotlin SDK To delete an object from a realm: 1. Open a write transaction with [realm.write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) or[realm.writeBlocking().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html)\n2. Query the transaction's mutable realm for the object you want to delete with [realm.query()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html). Specify the object type as a type parameter passed to `query()`. Filter the set of returned objects by specifying a query. To ensure your query returns the correct object, filter with unique identifying information such as a primary key value.\n3. Pass the set of [RealmResults](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-results/index.html)returned by the query to [mutableRealm.delete()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-mutable-realm/delete.html) `| realm.write {                                                             |\n| ------------------------------------------------------------------------- |\n| // fetch the frog by primary key value, passed in as argument number 0    |\n| val frog: Frog =                                                          |\n| this.query<Frog>(\"_id == $0\", PRIMARY_KEY_VALUE).find().first()           |\n| // call delete on the results of a query to delete the object permanently |\n| delete(frog)                                                              |\n| }                                                                         | ` ## Note You can only delete objects from a realm within a[write transaction.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/#std-label-kotlin-write-transactions) ← [Delete - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/ \"Previous Section\")[Delete Multiple Objects - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-multiple-objects/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/timestamps/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Timestamps - Kotlin SDK You cannot store Kotlin's built-in `Date` or `Instant` types in Realm Database. Instead, use the[RealmInstant](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-instant/index.html)type, which stores time information as a UNIX epoch timestamp. If you need timestamp data in a form other than `RealmInstant`, you can add conversion code to your model class based on the following example:\n\n  `` ← [Supported Types - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/supported-types/ \"Previous Section\")[Primary Keys - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/primary-key/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/create/create-a-new-object/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create a New Object - Kotlin SDK Instantiate Realm objects as you would any other object. In a transaction, you can add the object to the realm if the realm's schema includes the object type. When you add an instance to the realm, it becomes_managed_ by that realm. To persist a new object to a realm: 1. Instantiate a new object instance with the class constructor. You can use an [apply block](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html)to configure multiple properties at once.\n2. Open a write transaction with [realm.write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) or[realm.writeBlocking().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html)\n3. Pass the new object instance to [copyToRealm()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-mutable-realm/copy-to-realm.html)to persist the object data to the realm. This method returns a**managed** instance of the object. You can modify the persisted object through the returned instance. `| realm.write {                   |\n| ------------------------------- |\n| this.copyToRealm(Frog().apply { |\n| name = \"Kermit\"                 |\n| age = 45                        |\n| species = \"Green\"               |\n| owner = \"Jim\"                   |\n| })                              |\n| }                               | ` ## Note You can only insert new objects into a realm within a[write transaction.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/#std-label-kotlin-write-transactions) ← [Create - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/create/ \"Previous Section\")[Read - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/bundle-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Bundle a Realm - Kotlin SDK On this page * [Overview](#overview)\n* [Bundle a Local Realm](#bundle-a-local-realm)\n* [Create a Realm File for Bundling](#create-a-realm-file-for-bundling)\n* [Bundle a Realm File in Your Production Application](#bundle-a-realm-file-in-your-production-application)\n* [Open a Realm from a Bundled Realm File](#open-a-realm-from-a-bundled-realm-file)\n* [Bundle a Synced Realm](#bundle-a-synced-realm)\n* [Create a Realm File for Bundling a Synced Realm](#create-a-realm-file-for-bundling-a-synced-realm)\n* [Bundle a Synced Realm File in your Production Application](#bundle-a-synced-realm-file-in-your-production-application)\n* [Open a Realm from a Bundled Synced Realm File](#open-a-realm-from-a-bundled-synced-realm-file) ## Overview Realm supports bundling realm database files. When you bundle a realm file, you include a database and all of its data in your application download. This allows you to seed your mobile app with some initial data that will be available to users on the initial launch of the app. ## Tip ### Consider Initial Data Callback You can also add data to your realm the first time an application opens it using [InitialDataCallback.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-initial-data-callback/index.html) ## Bundle a Local Realm To bundle a local realm, perform the following: 1 ### Create a Realm File for Bundling Create a new project with the same [Realm object schema](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-object-schema) as your production app. [Open an existing realm](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/open-and-close-a-realm/#std-label-kotlin-open-a-realm) with the data you wish to bundle, or create a new realm. If using an existing realm, copy the realm to a new file with the[writeCopyTo()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-copy-to.html) method. This method also automatically compacts your realm to the smallest possible size before copying. Get the path to the realm file using[Realm.configuration.path.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-configuration/index.html#422583608%2FProperties%2F-1651551339)\n\n ` 2 ### Bundle a Realm File in Your Production Application Now that you have a copy of the realm that contains the initial data, you need to bundle it with your production application. Save a copy of the realm file to your application's assets folder. In Android Studio, you can do this using the [Device File Explorer.](https://developer.android.com/studio/debug/device-file-explorer) The assets folder location depends on your app type: * For an Android app: `/<app name>/src/main/assets`\n* For a KMM app: `/<app name>/shared/src/main/assets` If your application does not already contain an asset folder, you can manually create it. ## Tip ### Create Asset Folder in Android Studio To create an asset folder in Android Studio, right-click the top-level application folder (`<app name>` or `<app name>/shared`) and selectNew > Folder > Assets Folder in the menu. 3 ### Open a Realm from a Bundled Realm File Now that you have a copy of the realm included with your app, add code to use it. ```kotlin // Open the bundled realm from the assets folder val bundledConfig = RealmConfiguration.Builder(schema = setOf(Item::class))     .directory(\"src/main/assets\")     .name(\"bundled.realm\")     .build() val bundledRealm = Realm.open(bundledConfig) // Read and write to the bundled realm as normal bundledRealm.writeBlocking {     copyToRealm(Item().apply {         summary = \"Add another Item to the realm\"         isComplete = true     }) } \n``` ## Bundle a Synced Realm Bundling a synced realm reduces the size of the data that users must download when using a synced realm. When you bundle a realm with your application, the only data users must download is any changes that have occurred since preparing the bundled realm. However, two conditions may cause users to be unable to use your bundled realm: * If the date when you bundled the realm is older than your [client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time)setting, Realm does not have the complete change set required to update the bundled realm to a syncable state. In this case, users will receive a [client reset](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) and must re-download the entire realm, negating the benefit of bundling the realm.\n* An app user does not have the necessary server-side permissions to view the data included in the bundle. If a user doesn't have permission to view this data, it is removed from the device when the realm syncs with Atlas, negating the benefit of bundling the realm. If you cannot guarantee that your bundled realm was prepared more recently than the client maximum offline time setting or that the app user will have permissions to view the data included the bundled realm, there is no benefit to bundling a synced realm. If your application uses [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync), you can populate your application with data using sync subscriptions as an alternative to bundling a synced realm. subscriptions, you do not need to be concerned with data being older than the client maximum online time while taking advantage of Flexible Sync's [trimming](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-trimming) feature. To learn more about using sync subscriptions, refer to[Subscriptions.](https://mongodb.com/docs/realm/sdk/kotlin/sync/subscribe/#std-label-kotlin-subscriptions) To bundle a synced realm, perform the following: 1 ### Create a Realm File for Bundling a Synced Realm [Open a synced realm.](https://mongodb.com/docs/realm/sdk/kotlin/sync/open-a-synced-realm/#std-label-kotlin-open-a-synced-realm)\n\n Create a new version of the synced realm using [writeCopyTo()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-copy-to.html) . You _must_ use `writeCopyTo()` to bundle a synced realm. This method removes metadata that associates the realm with the user, which allows other users to open the realm file as well. Get the path to the copied realm file using[Realm.configuration.path.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-configuration/index.html#422583608%2FProperties%2F-1651551339) ```kotlin runBlocking {     val app = App.create(YOUR_APP_ID)     // Login with user that has the server-side permissions     // of the users of the bundled realm     val user = app.login(credentials)     // Create a SyncConfiguration to open the existing synced realm     val originalConfig = SyncConfiguration.Builder(user, setOf(Item::class))         .name(\"original.realm\")         // Add a subscription that matches the data being added         // and your app's backend permissions         .initialSubscriptions{ realm ->             add(                 realm.query<Item>(\"summary == $0\", \"summary value\"), \"subscription name\")         }         .build()     val originalRealm = Realm.open(originalConfig)     originalRealm.writeBlocking {         // Add seed data to the synced realm         copyToRealm(Item().apply {             summary = \"Do the laundry\"             isComplete = false         })         // Verify the data in the existing realm         // (this data should also be in the bundled realm we open later)         val originalItems: RealmResults<Item> = originalRealm.query<Item>().find()         for(item in originalItems) {             Log.v(\"My Item: ${item.summary}\")         }     }     // IMPORTANT: Sync all changes with server before copying the synced realm     originalRealm.syncSession.uploadAllLocalChanges(30.seconds)     originalRealm.syncSession.downloadAllServerChanges(30.seconds)     // Create a SyncConfiguration for the bundled copy with a file name     val copyConfig = SyncConfiguration.Builder(user, setOf(Item::class))         .name(\"bundled.realm\")         .build()     // Copy the synced realm with writeCopyTo()     originalRealm.writeCopyTo(copyConfig)     // Get the path to the copy you just created     Log.v(\"Bundled realm location: ${copyConfig.path}\")     originalRealm.close() } \n``` 2 ### Bundle a Synced Realm File in your Production Application Follow the steps outlined in the above **Bundle a Realm File in Your Production Application** procedure for bundling a local realm. 3 ### Open a Realm from a Bundled Synced Realm File Follow the steps outlined in the above **Open a Realm from a Bundled Realm File**procedure for bundling a local realm.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-all-objects-of-a-type/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete All Objects of a Type - Kotlin SDK To delete all objects of a type from a realm: 1. Open a write transaction with [realm.write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) or[realm.writeBlocking().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html)\n2. Query the transaction's mutable realm for all objects of that type with [realm.query()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html). Specify the object type as a type parameter passed to `query()`.\n3. Delete the set of [RealmResults](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-results/index.html)returned by the query with [mutableRealm.delete().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-mutable-realm/index.html#-181441016%2FFunctions%2F-1651551339) `| realm.write {                                                                |\n| ---------------------------------------------------------------------------- |\n| // fetch all frogs from the realm                                            |\n| val frogs: RealmResults<Frog> = this.query<Frog>().find()                    |\n| // call delete on the results of a query to delete those objects permanently |\n| delete(frogs)                                                                |\n| }                                                                            | ` ## Note You can only delete objects from a realm within a[write transaction.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/#std-label-kotlin-write-transactions) ← [Delete Multiple Objects - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/delete-multiple-objects/ \"Previous Section\")[React to Changes - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/react-to-changes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/primary-key/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Primary Keys - Kotlin SDK To define a primary key for an object type, use the [@PrimaryKey](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types.annotations/-primary-key/index.html)annotation: `| class Lizard : RealmObject {   |\n| ------------------------------ |\n| @PrimaryKey                    |\n| val _id: ObjectId = ObjectId() |\n| }                              | ` Realm Database treats fields marked with the `@PrimaryKey` annotation as primary keys for their corresponding [object schema](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-object-schema). The primary key is a unique identifier for an object in a realm. No other objects of the same type may share an object's primary key. Important aspects of primary keys: * You can define only one primary key per object schema.\n* You cannot change the primary key field for an object type after adding any object of that type to a realm.\n* Primary key values must be unique across all instances of an object in a realm. Attempting to insert a duplicate primary key value results in an error.\n* Primary key values are immutable. To change the primary key value of an object, you must delete the original object and insert a new object with a different primary key value.\n* Primary keys are nullable. `null` can only be the primary key of one object in a collection.\n* Realm automatically indexes primary keys, so you can efficiently read and modify objects based on their primary key. You can create a primary key with any of the following types: * `String`\n* `Byte`\n* `Char`\n* `Short`\n* `Int`\n* `Long`\n* `ObjectId`\n* `RealmUUID` ← [Timestamps - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/timestamps/ \"Previous Section\")[Ignore a Field - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/ignore/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/supported-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Supported Types - Kotlin SDK On this page * [Updating Strings and Byte Arrays](#updating-strings-and-byte-arrays) Realm Database supports the following field data types: * `String`\n* `Byte`\n* `Char`\n* `Short`\n* `Int`\n* `MutableRealmInt`, which behaves like a `Long` but also supports `increment`and `decrement` methods that implement a conflict-free replicated data type. For more information, see [MutableRealmInt.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-mutable-realm-int/index.html)\n* `Long`\n* `Boolean`\n* `Double`\n* `Float`\n* `Decimal128`\n* `ObjectId`\n* `RealmInstant`\n* Any `RealmObject` subclass\n* `RealmList<T>`, where T is any of the supported data types or a[RealmObject](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-object/index.html). Lists of `RealmObject` cannot have null elements. All other types of `RealmList<T>` can be nullable (`RealmList<T?>`).\n* `RealmSet<T>`, where T is any of the supported data types or a[RealmObject](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-object/index.html). Sets of `RealmObject` cannot have null elements. All other types of `RealmSet<T>` can be nullable (`RealmSet<T?>`).\n* `RealmUUID`\n* `BacklinksDelegate<T>`, a [backlinks](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.ext/backlinks.html)delegate used to define an inverse relationship between[RealmObjects.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-object/index.html) ## Note ### Importing ObjectId in the Realm Kotlin SDK version 1.5.x or Higher With the [Realm Kotlin Kotlin version 1.5.0](https://github.com/realm/realm-kotlin/blob/main/CHANGELOG.md#150-2022-11-11) you must import`ObjectId` from [org.mongodb.kbson.ObjectId](https://github.com/mongodb/kbson). If you were using an older SDK version and wish to upgrade, replace your old import statements as [io.realm.kotlin.types.ObjectId](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/#-1137254501%2FClasslikes%2F-1651551339)has been deprecated. Realm Database stores all non-decimal numeric types as `Long` values. Similarly, Realm Database stores all decimal numeric types as `Double`values.\n\n ## Updating Strings and Byte Arrays Since Realm Database operates on fields as a whole, it's not possible to directly update individual elements of strings or byte arrays. Instead, you'll need to read the whole field, make your modification to individual elements, and then write the entire field back again in a transaction block. ← [Schemas - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/ \"Previous Section\")[Timestamps - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/timestamps/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/ignore/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Ignore a Field - Kotlin SDK To prevent a field from persisting in Realm Database or being included in the `RealmObject` [object schema](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-object-schema), use the[@Ignore](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types.annotations/-ignore/index.html)annotation: `| class ShoppingCart : RealmObject { |\n| ---------------------------------- |\n| val _id: ObjectId = ObjectId()     |\n| @Ignore                            |\n| val items: List<String> = listOf() |\n| }                                  | ` Ignored properties behave exactly like normal properties, but they are not stored to the database. They can't be used in queries and don't trigger Realm notifications. ← [Primary Keys - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/primary-key/ \"Previous Section\")[Index a Field - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/index/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/relationships/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Relationships - Kotlin SDK On this page * [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationships](#inverse-relationships) A relationship is an object property that references another Realm object. Relationships are direct references to other objects in a realm, which means that you don't need bridge tables or explicit joins to define a relationship like you would in a relational database. Instead, you can access related objects by reading and writing to the property that defines the relationship. Realm Database executes read operations lazily, so querying objects with relationship fields doesn't slow queries. There are two primary types of relationships between objects: * To-One Relationship\n* To-Many Relationship ## Tip ### One-to vs. Many-to Relationships In Realm Database, there is no way to limit object references from other objects within the same realm. As a result, there is no way to restrict a relationship to \"one to one/one to many\" instead of \"many to one/many to many\". You can define relationships in your object schema using the following types: * `RealmObject`\n* `RealmList <? extends RealmObject>` You can also embed one Realm object directly within another to create a nested data structure. Embedded objects are similar to relationships but have additional constraints. For more information, refer to [Embedded Objects.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/embedded-objects/#std-label-kotlin-embedded-objects) ## To-One Relationship A to-one relationship means that an object is related to no more than one other object. Setting a relationship field to `null`removes the connection between objects, but Realm Database does not delete the referenced object. To set up a many-to-one or one-to-one relationship, create a field whose type is a Realm object in your application: `| class SushiPlatter : RealmObject { |\n| ---------------------------------- |\n| val _id: ObjectId = ObjectId()     |\n| val name: String = \"\"              |\n| val fish: Fish? = null             |\n| }                                  | ` Each `Sushi` references either zero `Fish` instances or one other`Fish` instance. Nothing prevents multiple Frog instances from referencing the same Frog as a best friend; the distinction between a many-to-one and a one-to-one relationship is up to your application. ## To-Many Relationship A to-many relationship means that an object is related in a specific way to multiple objects. You can create a relationship between one object and any number of objects using a field of type `RealmList<T>` where`T` is a Realm object in your application: ```kotlin class Sushi : RealmObject {     val _id: ObjectId = ObjectId()     val name: String = \"\"     val fishes: RealmList<Fish> = realmListOf<Fish>() } \n``` RealmLists are containers of RealmObjects, but otherwise behave like a regular collection. The same object can occur in multiple to-many relationships; the distinction between a many-to-many and a one-to-many relationship is up to your application. ## Note The child objects in a to-many relationship must be a [RealmList](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-list/index.html) or a[RealmSet](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-set/index.html). For instance, if a \"Sushi\" object has many \"Fish\" objects, you must specify the \"Sushi.fishes\" as a `RealmList` or `RealmSet` of `Fish` objects.\n\n An inverse relationship links an object back to any other objects that refer to it in a defined to-one or to-many relationship. Relationship definitions are unidirectional, so you must explicitly define a property in the object's model as an inverse relationship. For example, the to-many relationship \"User has many Posts\" does not automatically create the inverse relationship \"Post belongs to User\". Realm Database automatically updates implicit relationships whenever an object is added or removed in the specified relationship. You cannot manually add or remove items from a [backlinks collection.](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.ext/backlinks.html) Because relationships are many-to-one or many-to-many, following inverse relationships can result in zero, one, or many objects. Consider the following class defining a `User` with a [RealmList](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-list/index.html) of `posts`: ```kotlin class User: RealmObject {     @PrimaryKey     var _id: ObjectId = ObjectId()     lateinit var name: String     val posts: RealmList<Post>? = null } \n``` You can provide a link in the opposite direction, from `Post` to `User`. This allows you [filter](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/filter-data/#std-label-kotlin-filter-data) data about the user who the post belongs to like any other `RealmResults`. ```kotlin class Post: RealmObject {     @PrimaryKey     var _id: ObjectId = ObjectId()     lateinit var title: String     val user: RealmResults<User> by backlinks(User::posts) } \n``` ← [Remap a Property - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/remap/ \"Previous Section\")[Embedded Objects - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/embedded-objects/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/optional/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Optional Fields - Kotlin SDK To mark a field as optional, use the built-in `?` Kotlin operator: `| class Knight : RealmObject {   |\n| ------------------------------ |\n| val _id: ObjectId = ObjectId() |\n| val name: String = \"\"          |\n| val mount: Horse? = null       |\n| }                              | ` ← [Index a Field - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/index/ \"Previous Section\")[Remap a Property - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/remap/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/uuid/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # UUID - Kotlin SDK On this page * [Create a UUID from a String](#create-a-uuid-from-a-string)\n* [Create a Random UUID](#create-a-random-uuid) `UUID` (Universal Unique Identifier) is a 16-byte [unique value](https://en.wikipedia.org/wiki/Universally%5Funique%5Fidentifier). You can use `UUID` as an identifier for objects. `UUID` is [indexable](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-indexes), and you can use it as a[primary key.](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-primary-keys) Realm Database creates UUIDs with the [RealmUUID](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-u-u-i-d/index.html) type that: * conform to [RFC 4122 version 4](https://www.rfc-editor.org/rfc/rfc4122.htm)\n* are created with random bytes `| class Cat: RealmObject {                |\n| --------------------------------------- |\n| @PrimaryKey                             |\n| var _id: RealmUUID = RealmUUID.random() |\n| }                                       | ` ## Note ### Using UUID Instead of ObjectId In general, you can use `UUID` for any fields that function as a unique identifier. Using `UUID` might be particularly useful if you are migrating data not stored in MongoDB since it is likely that your object's unique identifiers are already of a `UUID` type. Alternatively, using `ObjectId`might be useful for a collection of data that already exists in MongoDB. ## Create a UUID from a String To generate a new `RealmUUID` from a UUID formatted string, pass the string to [RealmUUID.from():](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-u-u-i-d/-companion/from.html) ```kotlin realm.write {     this.copyToRealm(Cat().apply {         _id = RealmUUID.from(\"46423f1b-ce3e-4a7e-812f-004cf9c42d76\")     }) } \n``` ## Create a Random UUID To generate a random `RealmUUID`, call [RealmUUID.random():](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-u-u-i-d/-companion/random.html) ```kotlin realm.write {     this.copyToRealm(Cat().apply {         _id = RealmUUID.random()     }) } \n``` ← [RealmSet - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/realm-set/ \"Previous Section\")[Manage Realm Database Files - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/realm-files/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/index/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Index a Field - Kotlin SDK Indexes speed up some queries at the cost of slightly slower write times and additional storage and memory overhead. Realm Database stores indexes on disk, which makes your realm files larger. Each index entry is a minimum of 12 bytes. To index a field, use the [@Index](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types.annotations/-index/index.html)annotation in the [object schema:](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-object-schema) `| class Movie : RealmObject {           |\n| ------------------------------------- |\n| @Index                                |\n| val _id: ObjectId = ObjectId()        |\n| val starring: List<String> = listOf() |\n| }                                     | ` ## Note [Primary keys](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/primary-key/#std-label-kotlin-primary-keys) are indexed by default. Indexes support the efficient execution of queries in Realm Database. Without indexes, Realm Database must perform a _collection scan_, i.e. scan every document in a collection, to select those documents that match a query. If an appropriate index exists for a query, Realm Database can use the index to limit the number of documents that it must inspect. Indexes are special data structures that store a small portion of a realm's data in an easy to traverse form. The index stores the value of a specific field ordered by the value of the field. The ordering of the index entries supports efficient equality matches and range-based query operations. You can index fields with the following types: * `String`\n* `Byte`\n* `Short`\n* `Int`\n* `Long`\n* `Boolean`\n* `RealmInstant`\n* `ObjectId`\n* `RealmUUID` ← [Ignore a Field - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/ignore/ \"Previous Section\")[Optional Fields - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/optional/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/remap/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Remap a Property - Kotlin SDK By default, Realm Database uses the name defined in the model class to represent fields internally. In some cases, you might want to change this behavior: * To make it easier to work across platforms where naming conventions differ. For example, if your Device Sync schema property names use snake case, while your project uses camel case.\n* To change a field name in Kotlin without forcing a [migration.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/change-an-object-model/#std-label-kotlin-migrations) To map a different property name in your code than is stored in Realm Database, use the [@PersistedName](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types.annotations/-persisted-name/index.html)annotation in the [object schema](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-object-schema) and specify the property `name` that you want persisted to the realm. If you write to a synced realm, the Sync schema sees the values stored using the persisted property name. In this example, `riderName` is the Kotlin property name used in the code throughout the project to perform CRUD operations and `rider_name` is the persisted name used to store values in Realm Database: `| class Horse : RealmObject {                               |\n| --------------------------------------------------------- |\n| val _id: ObjectId = ObjectId()                            |\n| val name: String =\"\"                                      |\n| @PersistedName(\"rider_name\") // Name persisted to realm   |\n| val riderName: Knight? = null // Kotlin name used in code |\n| }                                                         | ` Note that migrations must use the persisted property name when creating classes and properties, and any schema errors reported will also use the persisted name. You can query by both the Kotlin name used in the code and by the persisted name stored in Realm Database. ← [Optional Fields - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/optional/ \"Previous Section\")[Relationships - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/relationships/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/read/find-objects-of-a-type/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Find Objects of a Type - Kotlin SDK To find all objects of a type, open a realm and pass the type as a type parameter to [realm.query():](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html)\n\n ` ## Tip [find()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.query/find.html)runs a synchronous query on the thread it is called from. As a result, avoid using `find()` on the UI thread or in logic that could delay the UI thread. Prefer [asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/as-flow.html) in time sensitive environments. ← [Find Object by Primary Key - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/find-object-by-primary-key/ \"Previous Section\")[Filter Data - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/filter-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/read/filter-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Filter Data - Kotlin SDK Filter results to retrieve a specific segment of objects with [realm.query()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html). In the argument of `realm.query()`, use Realm Query Language to perform filtering. Realm Query Language is a string-based query language that you can use to retrieve objects from a realm. Specify the object type as a type parameter passed to `query()`. For more information on constructing queries, refer to the[Realm Query Language reference documentation.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql) `| // Find frogs where name is 'Michigan J. Frog'            |\n| --------------------------------------------------------- |\n| val michiganFrogs: RealmResults<Frog> =                   |\n| realm.query<Frog>(\"name = 'Michigan J. Frog'\").find()     |\n| // Find frogs where age > 3 AND species is 'Green'        |\n| val oldGreenFrogs: RealmResults<Frog> =                   |\n| realm.query<Frog>(\"age > 3 AND species = 'green'\").find() | ` ← [Find Objects of a Type - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/find-objects-of-a-type/ \"Previous Section\")[Sort Queries - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/sort-queries/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/embedded-objects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Embedded Objects - Kotlin SDK On this page * [Overview](#overview)\n* [Define an Embedded Object](#define-an-embedded-object)\n* [Read and Write Embedded Objects](#read-and-write-embedded-objects)\n* [Create an Embedded Object](#create-an-embedded-object)\n* [Update Embedded Object Properties](#update-embedded-object-properties)\n* [Overwrite an Embedded Object](#overwrite-an-embedded-object)\n* [Query an Embedded Object](#query-an-embedded-object)\n* [Delete an Embedded Object](#delete-an-embedded-object) ## Overview An embedded object is a special type of [Realm object](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/define-realm-object-model/#std-label-kotlin-object-type) that models complex data about a specific object. Realm treats each embedded object as nested data inside of a single specific parent object. Embedded objects are similar to [relationships](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/relationships/#std-label-kotlin-relationships), but an embedded object inherits the lifecycle of its parent object and cannot exist as an independent Realm object. Because of this, embedded objects have the following constraints: * Embedded objects are deleted when their parent object is deleted or their parent no longer references them.\n* Embedded objects cannot have a [primary key.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/primary-key/#std-label-kotlin-primary-keys)\n* You cannot reassign an embedded object to a different parent object.\n* You cannot link to an embedded object from multiple parent objects. ## Tip ### Embedded Object Types are Reusable and Composable You can use the same embedded object type in multiple parent object types, and you can embed objects inside other embedded objects. You can even recursively reference an embedded object type as an optional property in its own definition. ## Define an Embedded Object To define an embedded object, derive a class from[EmbeddedRealmObject:](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-embedded-realm-object/index.html)\n\n ` Once your embedded object class is defined, you must include its schema in the realm's[configuration](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-configuration/index.html)to use it in your realm instance: ```kotlin // Include parent and embedded object classes in schema val config = RealmConfiguration.Builder(     setOf(Contact::class, Address::class) )     .build() val realm = Realm.open(config) \n``` ## Read and Write Embedded Objects ### Create an Embedded Object To create an embedded object, assign an instance of the embedded object to a parent object's property: ```kotlin // Create a parent object with one embedded address realm.write {     val contact = copyToRealm(Contact())         contact.apply {             name = \"Nick Riviera\"             // Embed the address in the contact object             address = Address().apply {                 street = \"123 Fake St\"                 city = \"Some Town\"                 state = \"MA\"                 postalCode = \"12345\"             }         } } \n``` ### Update Embedded Object Properties To update a property in an embedded object, fetch the object and reassign the embedded object properties in a write transaction: ```kotlin // Modify embedded object properties in a write transaction realm.write {     // Fetch the objects     val addressToUpdate = findLatest(address)?: error(\"Cannot find latest version of embedded object\")     val contactToUpdate = findLatest(contact)?: error(\"Cannot find latest version of parent object\")     // Update a single embedded object property directly     addressToUpdate.street = \"100 10th St N\"     // Update multiple properties     addressToUpdate.apply {         street = \"202 Coconut Court\"         city = \"Los Angeles\"         state = \"CA\"         postalCode = \"90210\"     }     // Update property through the parent object     contactToUpdate.address?.state = \"NY\" } \n``` ### Overwrite an Embedded Object To overwrite an embedded object, assign a new embedded object instance to the property in a write transaction: ```kotlin // Overwrite the embedded object in a write transaction realm.write {     // Fetch the parent object     val parentObject: Contact =         realm.query<Contact>(\"name == 'Nick Riviera'\").find().first()     // Overwrite the embedded object (deletes the existing object)     parentObject.address = Address().apply {         street = \"202 Coconut Court\"         city = \"Los Angeles\"         state = \"CA\"         postalCode = \"90210\"     } } \n``` ### Query an Embedded Object You can query the embedded object directly or through the parent object. You can also use the[EmbeddedRealmObject.parent()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.ext/parent.html)method to access the parent of the embedded object. ```kotlin // Query an embedded object directly val queryAddress: Address =     realm.query<Address>(\"state == 'FL'\").find().first() // Get the parent of an embedded object val getParent: Contact =     queryAddress.parent() // Query through the parent object val queryContactAddresses: RealmResults<Contact> =\n\n         .sort(\"name\")         .find() \n``` ### Delete an Embedded Object ## Warning ### Realm Uses Cascading Deletes for Embedded Objects When you delete a Realm object, Realm automatically deletes any embedded objects referenced by that object. If you want the referenced objects to persist after the deletion of the parent object, use a regular Realm object with a [to-one relationship](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/relationships/#std-label-kotlin-to-one-relationship) instead. You can delete an embedded object directly or through the parent object. To delete only an embedded object, you can fetch and delete a specific embedded object or clear the parent's reference to the embedded object, which also deletes the embedded object instance. Deleting the parent object automatically deletes all of its embedded objects. ```kotlin //  Delete an embedded object directly realm.write {     val addressToDelete: Address =         this.query<Address>(\"street == '123 Fake St'\").find().first()     // Delete the embedded object (nullifies the parent property)     delete(addressToDelete) } // Delete an embedded object through the parent realm.write {     val propertyToClear: Contact =         this.query<Contact>(\"name == 'Nick Riviera'\").find().first()     // Clear the parent property (deletes the embedded object instance)     propertyToClear.address = null } // Delete parent object (deletes all embedded objects) realm.write {     val contactToDelete: Contact =         this.query<Contact>(\"name == 'Nick Riviera'\").find().first()     delete(contactToDelete) } \n``` ← [Relationships - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/relationships/ \"Previous Section\")[RealmSet - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/realm-set/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/read/find-object-by-primary-key/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Find Object by Primary Key - Kotlin SDK To find an object with a specific primary key value, open a realm and query the primary key field for the desired primary key value using [realm.query()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html). Specify the object type as a type parameter passed to `query()`: `| // Search equality on the primary key field name                                    |\n| ----------------------------------------------------------------------------------- |\n| val frogs: Frog? = realm.query<Frog>(\"_id == $0\", PRIMARY_KEY_VALUE).first().find() | ` ## Tip [find()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/find.html)runs a synchronous query on the thread it is called from. As a result, avoid using `find()` on the UI thread or in logic that could delay the UI thread. Prefer [asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/as-flow.html) in time sensitive environments. ← [Read - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/ \"Previous Section\")[Find Objects of a Type - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/find-objects-of-a-type/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/realm-set/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # RealmSet - Kotlin SDK On this page * [Overview](#overview)\n* [Define a RealmSet](#define-a-realmset)\n* [Add an Item to a RealmSet](#add-an-item-to-a-realmset)\n* [Add Many Items to a RealmSet](#add-many-items-to-a-realmset)\n* [Check if the RealmSet Contains an Item](#check-if-the-realmset-contains-an-item)\n* [Check if the RealmSet Contains Multiple Items](#check-if-the-realmset-contains-multiple-items)\n* [Remove an Item from a RealmSet](#remove-an-item-from-a-realmset)\n* [Remove Multiple Items from a RealmSet](#remove-multiple-items-from-a-realmset)\n* [Notifications](#notifications) ## Overview You can use the [RealmSet()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-set/index.html) data type to manage a collection of unique keys. `RealmSet` implements Kotlin's`Set` interface, so it works just like the built-in `HashSet` class, except managed `RealmSet` instances persist their contents to a realm. `RealmSet` instances that contain Realm objects only store references to those objects, so deleting a Realm object from a realm also deletes that object from any `RealmSet` instances that contain the object. ## Define a RealmSet To define a property as a `RealmSet`, specify its type within the schema. Instantiate an unmanaged `RealmSet` by setting the field's default value using the [realmSetOf()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.ext/realm-set-of.html) method. In the following example, we define a `Frog` schema with a `favoriteSnacks`field that is a `RealmSet` of `Snack` objects. `| class Frog : RealmObject {                                |\n| --------------------------------------------------------- |\n| var name: String = \"\"                                     |\n| var favoriteSnacks: RealmSet<Snack> = realmSetOf<Snack>() |\n| }                                                         |\n| class Snack : RealmObject {                               |\n| var name: String? = null                                  |\n| }                                                         | ` ## Add an Item to a RealmSet\n\n In the following example, we get the `favoriteSnacks` set, then add a new`Snack` object to the set of favorite snacks. ```kotlin realm.write {     // create a Frog object named 'Kermit' that will have a RealmSet of favorite snacks     val frog = this.copyToRealm(Frog().apply {         name = \"Kermit\"     })     // get the RealmSet of favorite snacks from the Frog object we just created     val set = frog.favoriteSnacks     // create a Snack object for the Frog to add to Kermit's favorite snacks     val fliesSnack = this.copyToRealm(Snack().apply {         name = \"flies\"     })     // Add the flies to the RealmSet of Kermit's favorite snacks     set.add(fliesSnack) } \n``` ## Add Many Items to a RealmSet To add multiple items to a `RealmSet`, pass the elements you wish to add to the [set.addAll()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-set/index.html#-800009087%2FFunctions%2F-1651551339)method. In the following example, we create several `Snack` objects and use the[setOf](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/set-of.html)method to create a read-only set of the given elements. We then pass these elements to the `set.addAll()` method to add them to our `Frog` object's favorite snacks. ```kotlin realm.write {     val cricketsSnack = this.copyToRealm(Snack().apply {         name = \"crickets\"     })     val earthWormsSnack = this.copyToRealm(Snack().apply {         name = \"earthworms\"     })     val waxWormsSnack = this.copyToRealm(Snack().apply {         name = \"waxworms\"     })     set.addAll(setOf(cricketsSnack, earthWormsSnack, waxWormsSnack)) } \n``` ## Check if the RealmSet Contains an Item To check if the `RealmSet` contains a particular item, pass the element to[set.contains()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-set/index.html#607101300%2FFunctions%2F-1651551339). The method returns true if the set contains the element. ```kotlin Log.v(\"Does Kermit eat earth worms?: ${set.contains(earthWormsSnack)}\") // true \n``` ## Check if the RealmSet Contains Multiple Items To check if the `RealmSet` contains multiple items, pass the elements to[set.containsAll()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-set/index.html#1318510207%2FFunctions%2F-1651551339). The method returns true if the set contains the specified elements. In the following example, we pass the `Snack` objects we created earlier to the `setOf()` method to create a read-only set of favorite snacks. Then we check if the `RealmSet` contains all of these `Snack` objects by passing the read-only set to `set.containsAll()`. ```kotlin val setOfFrogSnacks = setOf(cricketsSnack, earthWormsSnack, waxWormsSnack)\n\n Log.v(\"Does Kermit eat crickets, earth worms, and wax worms?: $containsAllSnacks\") // true \n``` ## Remove an Item from a RealmSet To remove an item from a `RealmSet`, pass the element you wish to delete to [set.remove()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-set/index.html#-1503494415%2FFunctions%2F-1651551339) ```kotlin realm.write {     set.remove(fliesSnack) } \n``` ## Remove Multiple Items from a RealmSet To remove multiple items from a `RealmSet`, pass the elements you wish to delete to[set.removeAll()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-set/index.html#430447804%2FFunctions%2F-1651551339) In the following example, we delete the set of favorite snacks we created earlier. ```kotlin realm.write {     set.removeAll(setOfFrogSnacks) } \n``` ## Notifications You can register a notification handler on a `RealmSet`. Realm notifies your handler when the set changes. To register a change listener on a single object, generate a `Flow` from the `RealmSet` with [asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.types/-realm-list/as-flow.html). Next, use the `collect()` method to handle events on that `Flow`. The `Flow`emits an [initialSet()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.notifications/-initial-set/index.html)once subscribed and an [updatedSet()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.notifications/-updated-set/index.html)on change. In the following example, we react to changes on the `favoriteSnacks` set of our `Frog` object. ```kotlin val kermitFrog = realm.query<Frog>(\"name = 'Kermit'\").first().find() val job = CoroutineScope(Dispatchers.Default).launch {     kermitFrog?.favoriteSnacks         ?.asFlow()         ?.collect() {             // Listen for changes to the RealmSet         } } \n``` The `Flow` runs indefinitely until you [cancel the enclosing coroutine](https://kotlinlang.org/docs/cancellation-and-timeouts.html) or until you delete the parent object. ```kotlin job.cancel() \n``` ← [Embedded Objects - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/embedded-objects/ \"Previous Section\")[UUID - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/uuid/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/read/sort-queries/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sort Queries - Kotlin SDK To sort results, specify a sort in the query passed to[realm.query()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html)with the `SORT` keyword. Similarly, use `DISTINCT`to constrain results to unique values of a field, and`LIMIT` to cap the number of results. The SDK provides convenience methods on `RealmQuery` so you don't have to manually write the keywords: * [realmQuery.sort()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/sort.html)\n* [realmQuery.distinct()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/distinct.html)\n* [realmQuery.limit()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/limit.html) When used on the same query in both RQL and method form, `SORT`,`DISTINCT`, and `LIMIT` execute in the order they're added to the query. This can impact the results returned from your query.\n\n ` ## Tip [find()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/find.html)runs a synchronous query on the thread it is called from. As a result, avoid using `find()` on the UI thread or in logic that could delay the UI thread. Prefer [asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/as-flow.html) in time sensitive environments. ← [Filter Data - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/filter-data/ \"Previous Section\")[Iteration - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/iteration/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/read/iteration/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Iteration - Kotlin SDK You can iterate through results using `Flows`. ## Tip ### See also:  To learn more about Kotlin Flows, check out [the kotlinx.coroutines documentation on Flows.](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/) To convert your results into a `Flow`, call [realmQuery.asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/as-flow.html). Then iterate through the results with [flow.collect():](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html)\n\n ` ## Tip You can also iterate through results returned via [find()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.query/find.html).`find()` runs a synchronous query on the thread it is called from. As a result, avoid using `find()` on the UI thread or in logic that could delay the UI thread. Prefer [asFlow()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-element-query/as-flow.html) in time sensitive environments. ← [Sort Queries - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/read/sort-queries/ \"Previous Section\")[Update - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/update/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/update/modify-an-object/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Modify an Object - Kotlin SDK To modify an object stored within a realm: 1. Open a write transaction with [realm.write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) or[realm.writeBlocking().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html)\n2. Query the transaction's mutable realm with [realm.query()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html). Specify the object type as a type parameter passed to `query()`. To ensure your query returns the correct object, filter with unique identifying information such as a primary key value.\n3. Change an object property within the[write transaction](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/#std-label-kotlin-write-transactions). The SDK automatically persists changes to the realm. `| realm.write {                                                                         |\n| ------------------------------------------------------------------------------------- |\n| // fetch a frog from the realm by primary key                                         |\n| val frog: Frog? =                                                                     |\n| this.query<Frog>(\"_id == $0\", PRIMARY_KEY_VALUE).first().find()                       |\n| // modify the frog's age in the write transaction to persist the new age to the realm |\n| frog?.age = 42                                                                        |\n| }                                                                                     | ` ## Note You can only modify objects in a realm within a[write transaction.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/#std-label-kotlin-write-transactions) ← [Update - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/update/ \"Previous Section\")[Upsert an Object - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/update/upsert-an-object/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/update/update-collection/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Update a Collection - Kotlin SDK To update a collection of objects in a realm: 1. Query a realm for a collection of objects with [realm.query().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html)\n2. Open a write transaction with [realm.write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) or[realm.writeBlocking().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html)\n3. Update elements of the set of [RealmResults](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm-results/index.html)returned by the query. `| val tadpoles: RealmQuery<Frog> =                  |\n| ------------------------------------------------- |\n| realm.query<Frog>(\"age > $0\", 2)                  |\n| for (tadpole in tadpoles.find()) {                |\n| realm.write {                                     |\n| findLatest(tadpole)?.name = tadpole.name + \" Jr.\" |\n| }                                                 |\n| }                                                 | ` ## Note You can only update objects within a[write transaction.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/#std-label-kotlin-write-transactions) ← [Upsert an Object - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/update/upsert-an-object/ \"Previous Section\")[Delete - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/update/upsert-an-object/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Upsert an Object - Kotlin SDK The **upsert** operation either inserts a new instance of an object or updates an existing object that meets certain criteria. To upsert into a realm: 1. Open a write transaction with [realm.write()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write.html) or[realm.writeBlocking().](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-realm/write-blocking.html)\n2. Query the transaction's mutable realm with [realm.query()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin.query/-realm-query/query.html). Specify the object type as a type parameter passed to `query()`. Filter your criteria with unique identifying criteria for the object you want to upsert.\n3. Insert a new object with the same primary key as the object returned by the previous query (if it exists) with [copyToRealm()](https://www.mongodb.com/docs/realm-sdks/kotlin/latest/library-base/-realm%20-kotlin%20-s-d-k/io.realm.kotlin/-mutable-realm/copy-to-realm.html). If an object matching your filter already exists, realm updates the existing object. If no object exists that matches your filter, realm inserts a new object.\n\n ` ## Note You can only modify objects in a realm within a[write transaction.](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/write-transactions/#std-label-kotlin-write-transactions) ← [Modify an Object - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/update/modify-an-object/ \"Previous Section\")[Update a Collection - Kotlin SDK](https://mongodb.com/docs/realm/sdk/kotlin/realm-database/update/update-collection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - Flutter SDK MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Test & Debug - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/test-and-debug/ \"Previous Section\")[Realm Java SDK](https://mongodb.com/docs/realm/sdk/java/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - Flutter SDK On this page * [Schemas](#schemas)\n* [Persistent or In-Memory Realms](#persistent-or-in-memory-realms)\n* [Queries](#queries)\n* [Encryption](#encryption)\n* [Indexes](#indexes) Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) You can also synchronize data between Realm Database and MongoDB Atlas using Atlas Device Sync. To learn more about using Realm Database with Device Sync, refer to [Device Sync - Flutter SDK.](https://mongodb.com/docs/realm/sdk/flutter/sync/#std-label-flutter-sync) Realm Database supports the following popular database features. ## Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. To learn more, refer to [Define a Schema.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-define-realm-object-schema) Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, do not require a migration. After you increment the local schema version, you can begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. To learn more about schema versioning and migrations, refer to [Update a Realm Object Schema.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/update-realm-object-schema/#std-label-flutter-update-schema) ## Persistent or In-Memory Realms You can use Realm Database to store data persistently on disk, or ephemerally in memory. Ephemeral realms can be useful in situations where you don't need to persist data between application instances, such as when a user works in a temporary workspace. To learn more, refer to [Configure and Open a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-open-close-realm) ## Queries You can query Realm Database using [Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql) To learn more about querying Realm Database, refer to [Read & Write Data.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/#std-label-flutter-read-write-data) ## Encryption Realm Database supports on-device realm encryption. Since memory mapping does not support encryption, encrypted realms use a simulated in-library form of memory mapping instead. To learn more, refer to [Encrypt a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/encrypt/#std-label-flutter-encrypt) ## Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time.\n\n ← [Quick Start - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/quick-start/ \"Previous Section\")[Model Data - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Device Sync - Flutter SDK On this page * [Synced Realms](#synced-realms)\n* [Synced Realms vs. Non-Synced Realms](#synced-realms-vs.-non-synced-realms)\n* [What is Flexible Sync?](#what-is-flexible-sync-)\n* [Enable Flexible Sync on the Backend](#enable-flexible-sync-on-the-backend)\n* [Group Updates for Improved Performance](#group-updates-for-improved-performance)\n* [How Device Sync Works](#how-device-sync-works) Device Sync automatically synchronizes data between client applications and an [Atlas App Services backend application](https://www.mongodb.com/docs/atlas/app-services/#std-label-realm-cloud). When a client device is online, Sync asynchronously synchronizes data in the background between the device and your App Services backend. The Flutter SDK only supports Flexible Sync. You must configure your App Services backend to use [Flexible Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) ## Note The Flutter SDK does not support [Partition-Based Sync.](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync) ## Synced Realms You can configure a realm to automatically synchronize data between many devices that each have their own local copy of the data. Synced realms use a different configuration than local-only realms and require an Atlas App Services backend to handle the synchronization process. Applications can always create, modify, and delete synced realm objects locally, even when offline. Whenever a network connection is available, the Realm Flutter SDK opens a connection to an application server and syncs changes to and from other clients. The [Atlas Device Sync protocol](https://www.mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-sync-protocol) and server-side operational transforms guarantee that all fully synced instances of a realm see exactly the same data, even if some changes occurred offline and/or were received out of order. ### Synced Realms vs. Non-Synced Realms Synced realms differ from non-synced local Realm Database in a couple of ways: * Synced realms attempt to sync changes with your backend App Services App, whereas non-synced realms do not.\n* Synced realms can be accessed by authenticated users, while non-synced realms have no concept of users or authentication. You can copy data from a non-synced Realm Database to a synced realm, and vice versa, but you cannot sync a non-synced Realm Database. ## What is Flexible Sync? When you select [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) for your App Services backend configuration, your client implementation must include subscriptions to queries on [queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields). Flexible Sync works by synchronizing data that matches query subscriptions you maintain in the client application. A subscription set contains a set of queries. Flexible Sync returns documents matching those queries, where the user has the appropriate[permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read or write the documents. If documents match the query, but the client does not have the permission to read or write them, they do not sync to the client application. You can form Flexible Sync queries using a limited subset of [Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language). To learn more about which fields you can query, refer to the [Queryable Fields documentation.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields)\n\n To use Device Sync in your client application, open a synced realm with a Flexible Sync configuration. Then, manage subscriptions to determine which documents to sync. ### Enable Flexible Sync on the Backend Before you can start syncing data from your client application using the SDK, you must enable Flexible Sync in the App Services backend. To begin, refer to the [backend documentation on enabling Device Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) ### Group Updates for Improved Performance Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change. ## How Device Sync Works Device Sync adds network synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. Device Sync relies on a worker client that communicates with your application backend in a dedicated thread in your application. Additionally, synced realms keep a history of changes to contained objects. Sync uses this history to resolve conflicts between client changes and backend changes. Applications that use Device Sync define their schema on the backend using[JSON Schema](https://json-schema.org/learn/getting-started-step-by-step.html). Client applications must match that backend schema to synchronize data. However, if you prefer to define your initial schema in your application's programming language, you can use [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to create a backend JSON Schema based on native SDK objects as you write your application. However, once your application is used for production purposes, you should alter your schema using JSON Schema on the backend. ← [Get the User Access Token - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/access-token/ \"Previous Section\")[Add Device Sync to an App - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/add-sync-to-app/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # User Management - Flutter SDK On this page * [Create and Delete Users](#create-and-delete-users)\n* [Log Users In and Out](#log-users-in-and-out)\n* [User Object](#user-object)\n* [Custom User Data](#custom-user-data) To access Atlas App Services and use Atlas Device Sync with the Realm Flutter SDK, you must first authenticate a user with an App Services authentication provider. For more information on configuring App Services Authentication, refer to [App Services Authentication](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication) in the Atlas App Services documentation. ## Create and Delete Users For all authentication providers other than email/password authentication, App Services automatically [registers a user](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-register)the first time a user authenticates. When using the email/password authentication provider, you must[manually register a user](https://mongodb.com/docs/realm/sdk/flutter/users/email-password-users/#std-label-flutter-manage-email-password-users). If a user authenticates via more than one method, you can [link these user identities](https://mongodb.com/docs/realm/sdk/flutter/users/link-user-identities/#std-label-flutter-link-user-identities)to a single user object. You can also [delete users](https://mongodb.com/docs/realm/sdk/flutter/users/delete-user/#std-label-flutter-delete-user). Deleting a user removes metadata attached to the user from App Services, but does not delete user-entered data from the backend. ## Tip ### Apple Account Deletion Requirements Apple [requires that applications listed through its App Store](https://developer.apple.com/app-store/review/guidelines/#5.1.1) must give any user who creates an account the option to delete the account. Whether you use an authentication method where you must manually register a user, such as email/password authentication, or one that that automatically creates a user, such as Sign-In with Apple, you must implement [user account deletion](https://www.mongodb.com/docs/atlas/app-services/users/manage/#std-label-delete-user) by June 30, 2022. ## Log Users In and Out Use one or more [authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-auth-providers) to [log users in and out](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-authenticate) of your client app. You can: * Log users in with an existing social account, such as Apple, Facebook, or Google.\n* Create new user accounts with App Services email/password management, or your own custom function or custom JWT user management.\n* Enable anonymous users to let users access your App Services App without persisting user data. When you have a logged-in user, you can: * [Open a synced realm](https://mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/#std-label-flutter-open-synced-realm) with the user's configuration object\n* [Run a backend function](https://mongodb.com/docs/realm/sdk/flutter/app-services/call-function/#std-label-flutter-call-function) as the logged-in user\n* [Log the user out](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-logout)\n* [Change the active user](https://mongodb.com/docs/realm/sdk/flutter/users/multiple-users/#std-label-flutter-change-active-user) in a multi-user application\n* [Remove a user](https://mongodb.com/docs/realm/sdk/flutter/users/multiple-users/#std-label-flutter-remove-user) from the device\n* [Delete a user](https://mongodb.com/docs/realm/sdk/flutter/users/delete-user/#std-label-flutter-delete-user)\n\n ### User Object App Services manages sessions with access tokens and refresh tokens. Client SDKs supply the logic to manage tokens, and provide them with requests. Some authentication providers enable developers to access user metadata, such as full name or email address. When you configure these metadata fields on the App Services application, you can read this metadata from your client app. To learn more about the user object that App Services provides the Flutter SDK, refer to the following documentation: * [User Objects](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) in the App Services documentation.\n* [User Metadata](https://mongodb.com/docs/realm/sdk/flutter/users/user-metadata/#std-label-flutter-user-metadata) in the Flutter SDK documentation.\n* [User](https://pub.dev/documentation/realm/latest/realm/User-class.html) in Flutter SDK reference documentation. ## Custom User Data You can associate custom data with a user, such as a preferred language or local timezone, and read it from your client application. For more information on working with custom user data, refer to [Custom User Data.](https://mongodb.com/docs/realm/sdk/flutter/users/custom-user-data/#std-label-flutter-custom-user-data) ← [Call an Atlas Function](https://mongodb.com/docs/realm/sdk/flutter/app-services/call-function/ \"Previous Section\")[Authenticate Users - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/app-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Application Services Overview - Flutter SDK On this page * [Overview](#overview)\n* [The App Services Client](#the-app-services-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Device Sync](#device-sync)\n* [Call Atlas Functions](#call-atlas-functions)\n* [Query Atlas GraphQL API](#query-atlas-graphql-api) ## Overview You can connect your client apps to the Atlas App Services backend using the Flutter SDK. Backend functionality includes: * [Connect to a Realm App](https://mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/)\n* [Authenticate Users](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/)\n* [Query Atlas GraphQL API](https://mongodb.com/docs/realm/sdk/flutter/app-services/graphql-api/) ## The App Services Client To connect to your App Services backend, start with an[App](https://pub.dev/documentation/realm/latest/realm/App-class.html) object. This object provides all other functionality related to the backend. Initialize an App with the Realm app ID, which you can[find in the Realm UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) To learn how to initialize the Realm App client, refer to[Connect to App Services.](https://mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/#std-label-flutter-connect-to-backend) [Create an App Services Account](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Fflutter) ## Authentication & User Management One of the most challenging aspects of client development is implementing a robust and secure authentication system. With the SDKs, however, you can use any of the App Services authentication providers with minimal backend setup and client-side code. With the authentication APIs, you can implement the following functionality: * Create new user accounts\n* User log in and log out\n* Multiple users logged on at the same time on the same device\n* Link user accounts from different providers\n* Store custom data for a particular user To learn how to set up authentication in your app, refer to[Authenticate Users.](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-authenticate) ## Device Sync Device Sync adds data synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. To get started with Sync, refer to [Device Sync.](https://mongodb.com/docs/realm/sdk/flutter/sync/#std-label-flutter-sync) ## Call Atlas Functions [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) let you define and execute server-side logic. You can call these Functions from your client applications via the Realm SDKs. These server-side functions can run in the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your data in Atlas. Using Functions provides a secure way for multiple client applications to share complex functionality without having to reproduce that logic client-side. To learn how to call an Atlas Function from your client app, refer to [Call a Function.](https://mongodb.com/docs/realm/sdk/flutter/app-services/call-function/#std-label-flutter-call-function) ## Query Atlas GraphQL API The [Atlas GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) lets you access data stored in a linked MongoDB Atlas cluster using any standard GraphQL client.\n\n ← [Database Internals - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/database-internals/ \"Previous Section\")[Connect to App Services - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/troubleshooting/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Troubleshooting - Flutter SDK On this page * [Use Realm with the macOS App Sandbox](#use-realm-with-the-macos-app-sandbox)\n* [Connect to App Services Using Android 7 or Older](#connect-to-app-services-using-android-7-or-older) ## Use Realm with the macOS App Sandbox If you are developing with the Realm Flutter SDK in the macOS App Sandbox, network requests do not work by default due to built-in macOS security settings. Network access is required to use Atlas App Services and Device Sync. To enable network requests, add the following code to **both** the files`macos/Runner/DebugProfile.entitlements` and `macos/Runner/Release.entitlements`: `| <!--  Other entitlements -->                 |\n| -------------------------------------------- |\n| <key>com.apple.security.network.client</key> |\n| <true/>                                      |\n| <!--  Other entitlements -->                 | ` You can still use Realm Database locally without adding this network access permission. For more information about Flutter development for macOS, refer to [Building macOS apps with Flutter](https://docs.flutter.dev/development/platform-integration/macos/building#setting-up-entitlements)in the Flutter documentation. ## Connect to App Services Using Android 7 or Older To use App Services with the Realm SDK on a device using Android 7 or older, you must add an HTTP client with a custom Let's Encrypt Transport Layer Security (TLS) encryption certificate to the `App`. This is due to a known issue using Flutter on devices running Android 7 or older to connect to web servers that use Let's Encrypt TLS certificates. As App Services server uses a Let's Encrypt TLS certificate, you must add the custom certificate. You can download the Let's Encrypt certificate to add to your app by clicking this link: <https://letsencrypt.org/certs/lets-encrypt-r3.pem> To set up the custom HTTP client, adapt the following code example to your app. ```dart import 'package:realm_dart/realm.dart'; import \"dart:io\"; import \"dart:convert\"; HttpClient createCustomHttpsClient(String cert) {   SecurityContext context = SecurityContext.defaultContext;   try {     final bytes = utf8.encode(cert);     context.setTrustedCertificatesBytes(bytes);   } on TlsException catch (e) {     final message = e.osError?.message ?? \"\";     if (!message.contains('CERT_ALREADY_IN_HASH_TABLE')) {       rethrow;     }   }   return HttpClient(context: context); } App createAppWithCustomHttpsClient(     String letsEncryptCertificate, String appId) {   HttpClient httpClient = createCustomHttpsClient(letsEncryptCertificate);   final appConfig = AppConfiguration(appId, httpClient: httpClient);   return App(appConfig); } final letsEncryptCertificate = \"<LET'S ENCRYPT CERTIFICATE>\"; final appId = \"<YOUR APP ID>\"; final app = createAppWithCustomHttpsClient(letsEncryptCertificate, appId); \n``` ← [Set the Client Log Level - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/log-level/ \"Previous Section\")[Test & Debug - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/test-and-debug/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - Flutter SDK On this page * [Define Your Object Model](#define-your-object-model)\n* [Create Data Model](#create-data-model)\n* [Generate RealmObject Class](#generate-realmobject-class)\n* [Open a Realm](#open-a-realm)\n* [Work with Realm Objects](#work-with-realm-objects)\n* [Create Objects](#create-objects)\n* [Update Objects](#update-objects)\n* [Query for Objects](#query-for-objects)\n* [Delete Objects](#delete-objects)\n* [React to Changes](#react-to-changes)\n* [Close a Realm](#close-a-realm)\n* [Sync Realm with MongoDB Atlas](#sync-realm-with-mongodb-atlas)\n* [Prerequisites](#prerequisites)\n* [Initialize App Services](#initialize-app-services)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Add a Sync Subscription](#add-a-sync-subscription)\n* [Further Examples and Next Steps](#further-examples-and-next-steps) This page contains information to quickly get Realm Database integrated into your Flutter app. Before you begin, ensure you have: * [Installed the Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/install/#std-label-flutter-install) ## Define Your Object Model Your application's **data model** defines the structure of data stored within Realm Database. You can define your application's data model via Dart classes in your application code with a Realm object schema. You then have to generate the [RealmObject](https://pub.dev/documentation/realm/latest/realm/RealmObject-mixin.html)class that's used within your application. For more information, refer to [Define a Realm Object Schema.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-define-realm-object-schema) ### Create Data Model To define your application's data model, add a Realm model class definition to your application code. Some considerations when defining your Realm model class: * Import package at the top of your class definition file.\n* In your file, give your class a private name (starting with `_`), such as a file `car.dart` with a class `_Car`. You generate the public RealmObject class using the command in the following Generate RealmObject Class section. This command outputs a public class, such as `Car`.\n* Make sure to include the generated file name, such as `part car.g.dart`, before the code defining your model. This is required to generate the RealmObject class. ### Generate RealmObject Class Now generate a RealmObject class `Car` from the data model class `Car`: Running this creates a `Car` class in a `car.g.dart` file located in the directory where you defined the model class per the preceding Create Data Model section. This `Car` class is public and part of the same library as the `_Car` data model class. The generated `Car` class is what's used throughout your application. If you'd like to watch your data model class to generate a new `Car` class whenever there's a change to `_Car`, run: ## Open a Realm Use the [Configuration](https://pub.dev/documentation/realm/latest/realm/Configuration-class.html) class to control the specifics of the realm you would like to open, including schema and whether the realm is local-only or synced. Pass your configuration to the [Realm constructor](https://pub.dev/documentation/realm/latest/realm/Realm-class.html)to generate an instance of that realm: `| final config = Configuration.local([Car.schema]); |\n| ------------------------------------------------- |\n| final realm = Realm(config);                      | ` You can now use that realm instance to work with objects in the database.\n\n ## Work with Realm Objects Once you've opened a realm, you can create objects within it using a[write transaction block.](https://pub.dev/documentation/realm/latest/realm/Realm/write.html) For more information, refer to [Read and Write Data.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/#std-label-flutter-read-write-data) ### Create Objects To create a new `Car`, instantiate an instance of the`Car` class and add it to the realm in a write transaction block: ```dart final car = Car(ObjectId(), 'Tesla', model: 'Model S', miles: 42); realm.write(() {   realm.add(car); }); \n``` ### Update Objects To modify a car, update its properties in a write transaction block: ```dart realm.write(() {   car.miles = 99; }); \n``` ### Query for Objects Retrieve a collection of all objects of a data model in the realm with the[Realm.all()](https://pub.dev/documentation/realm/latest/realm/Realm/all.html) method: ```dart final cars = realm.all<Car>(); final myCar = cars[0]; print('My car is ${myCar.make} ${myCar.model}'); \n``` Filter a collection to retrieve a specific segment of objects with the [Realm.query()](https://pub.dev/documentation/realm/latest/realm/Realm/query.html) method. In the `query()` method's argument, use [Realm Query Language operators](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-operators) to perform filtering. ```dart final cars = realm.query<Car>('make == \"Tesla\"'); \n``` ### Delete Objects Delete a car by calling the [Realm.delete()](https://pub.dev/documentation/realm/latest/realm/Realm/delete.html)method in a write transaction block: ```dart realm.write(() {   realm.delete(car); }); \n``` ### React to Changes Listen and respond to changes to a query, a single object, or a list within an object. The change listener is a Stream that invokes a callback function with an containing changes since last invocation as its argument. To listen to a query, use [RealmResults.changes.listen().](https://pub.dev/documentation/realm/latest/realm/RealmResultsChanges-class.html) ```dart // Listen for changes on whole collection final characters = realm.all<Character>(); final subscription = characters.changes.listen((changes) {   changes.inserted; // indexes of inserted objects   changes.modified; // indexes of modified objects   changes.deleted; // indexes of deleted objects   changes.newModified; // indexes of modified objects   // after deletions and insertions are accounted for   changes.moved; // indexes of moved objects   changes.results; // the full List of objects }); // Listen for changes on RealmResults final hobbits = fellowshipOfTheRing.members.query('species == \"Hobbit\"'); final hobbitsSubscription = hobbits.changes.listen((changes) {   // ... all the same data as above }); \n``` You can pause and resume subscriptions as well. ```dart subscription.pause(); // the changes.listen() method won't fire until the subscription is resumed subscription.resume(); \n``` Once you've finished listening to changes, close the change listener to prevent memory leaks. ```dart await subscription.cancel(); \n``` For more information, refer to [React to Changes.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/react-to-changes/#std-label-flutter-react-to-changes) ## Close a Realm Once you've finished working with a realm, close it to prevent memory leaks. ```dart realm.close(); \n``` ## Sync Realm with MongoDB Atlas You can integrate Realm Database and[Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) into your Flutter app. Atlas Device Sync is an MongoDB Atlas App Service that synchronizes data between a client application and a MongoDB database cluster on Atlas.\n\n ## Note You do not need to add Device Sync to use Realm Database locally. ### Prerequisites Before you can use Device Sync with Realm in your client app, you must configure Device Sync using Atlas App Services: 1. [Create an App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n2. [Enable Anonymous Authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)\n3. [Enable Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync). Include the following Flexible Sync configuration:  \n   * Set `owner_id` as a **queryable field**.  \n   * Add the following backend permissions to have the user only be able to read and write their own data:  \n```  \n{  \n  \"rules\": {},  \n  \"defaultRoles\": [  \n    {  \n      \"name\": \"owner-read-write\",  \n      \"applyWhen\": {},  \n      \"read\": {  \n        \"owner_id\": \"%%user.id\"  \n      },  \n      \"write\": {  \n        \"owner_id\": \"%%user.id\"  \n      }  \n    }  \n  ]  \n}  \n``` ## Tip ### Use Realm Flutter Template App If you want a working Flutter app with Device Sync already set up in the client and on that App Service backend, use the [Flutter Template App](https://www.mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) `flutter.todo.flex`. ### Initialize App Services To use App Services features such as authentication and sync, access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) in the App Services UI. ```dart final app = App(AppConfiguration(APP_ID)); \n``` For more information, refer to [Connect to App Services.](https://mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/#std-label-flutter-connect-to-backend) ### Authenticate a User After you have enabled [anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) in the App Services UI, users can immediately log into your app without providing any identifying information: ```dart final loggedInUser = await app.logIn(Credentials.anonymous()); \n``` For more information, refer to [Authenticate a User.](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-authenticate) ### Open a Synced Realm Once you have enabled Device Sync and authenticated a user, open a synced realm with [Configuration.flexibleSync()](https://pub.dev/documentation/realm/latest/realm/Configuration/flexibleSync.html). Then, pass the configuration to [Realm()](https://pub.dev/documentation/realm/latest/realm/Realm-class.html)to open an instance of the realm. The synced realm **must** have a different[Configuration.path](https://pub.dev/documentation/realm/latest/realm/Configuration/path.html)from other opened local-only realms. ```dart final config = Configuration.flexibleSync(loggedInUser, [Todo.schema]); final realm = Realm(   config, ); \n``` For more information, refer to [Open a Synced Realm.](https://mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/#std-label-flutter-open-synced-realm)\n\n Now create a subscription to synchronize data with Atlas using Device Sync. Add the subscription within the [SubscriptionSet.update()](https://pub.dev/documentation/realm/latest/realm/SubscriptionSet/update.html)callback function. The update block callback function, includes a [MutableSubscriptionSet()](https://pub.dev/documentation/realm/latest/realm/MutableSubscriptionSet-class.html) object as an argument. Use `MutableSubscriptionSet.add()` to add a new subscription. ```dart // Check if the subscription already exists before adding   final userTodoSub = realm.subscriptions.findByName('getUserTodos');   if (userTodoSub == null) {     realm.subscriptions.update((mutableSubscriptions) {       // server-side rules ensure user only downloads their own Todos       mutableSubscriptions.add(realm.all<Todo>(), name: 'getUserTodos');     });   } \n``` For more information, refer to [Manage Sync Subscriptions.](https://mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-subscriptions/#std-label-flutter-flexible-sync-manage-subscriptions) ## Further Examples and Next Steps * To get started with a pre-made Flutter application using the Realm SDK and an Atlas App Services backend set up, use the [Flutter template app](https://www.mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps),`flutter.todo.flex`.\n* For a guided experience of adding the Realm SDK with Device Sync to a Flutter app, read the [Realm Flutter SDK Tutorial.](https://www.mongodb.com/docs/atlas/app-services/tutorial/flutter/#std-label-flutter-tutorial)\n* For further examples of the Flutter SDK methods described above and more, refer to the [Realm Dart Samples Github repo.](https://github.com/realm/realm-dart-samples) ← [Install Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/install/ \"Previous Section\")[Realm Database - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/log-level/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Set the Client Log Level - Flutter SDK You can set the realm sync client log level. You might want to do this to log different amounts of data depending on the app's environment. To learn more about all available logging levels, refer to the[RealmLogLevel documentation.](https://pub.dev/documentation/realm/latest/realm/RealmLogLevel-class.html) Set the log level to `debug` or `trace` to diagnose and troubleshoot errors while developing your application. For production deployments, decrease the log level for improved performance. To configure the log level, set the static property [Realm.logger.level](https://pub.dev/documentation/realm/latest/realm/Realm/logger.html)to one of the `Logger` levels provided by `RealmLogLevel`. You must set the log level **before** you open a synced realm. `| // Must set log level before opening synced realm.                     |\n| ---------------------------------------------------------------------- |\n| Realm.logger.level = RealmLogLevel.error;                              |\n| // Initialize app and user before can open synced realm.               |\n| final app = App(AppConfiguration(APP_ID));                             |\n| final user = await app.logIn(Credentials.anonymous());                 |\n| // Synced realm writes logs according to log level set above.          |\n| final realm = Realm(Configuration.flexibleSync(user, SCHEMA_OBJECTS)); | ` ← [Handle Sync Errors - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/handle-sync-errors/ \"Previous Section\")[Troubleshooting - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/troubleshooting/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm - Flutter SDK On this page * [Prerequisites](#prerequisites)\n* [Supported Platforms](#supported-platforms)\n* [Installation](#installation)\n* [Create a Flutter Project](#create-a-flutter-project)\n* [Add Realm to the Project](#add-realm-to-the-project)\n* [Import Realm Package](#import-realm-package)\n* [Dart Standalone Installation](#dart-standalone-installation)\n* [Create a Dart Project](#create-a-dart-project)\n* [Add Realm to the Project](#add-realm-to-the-project-1)\n* [Install Realm into Application](#install-realm-into-application)\n* [Import Realm Package](#import-realm-package-1)\n* [Update Package Version](#update-package-version) ## Prerequisites * [Install Flutter in your development environment](https://docs.flutter.dev/get-started/install). To use the latest version of the Realm SDK, you must use Flutter version 3.0.3 or later and Dart version 2.17.5 or later. ## Warning ### Incompatible with Dart 2.17.3 The Realm Flutter SDK and Realm Dart Standalone SDK are not compatible with Dart 2.17.3 due to an issue with the Dart virtual machine in this version. You may use Dart 2.17.5 version or later with Realm. ### Supported Platforms You can use the Realm Flutter SDK on the following platforms: * iOS\n* Android\n* macOS\n* Windows\n* Linux running on 64-bit architecture You **cannot** use the Realm Flutter SDK on the following platforms: * Web\n* Linux running on ARM64 or 32-bit architectures ## Installation Follow these steps to add the Realm Flutter SDK to your Flutter project. ## Note ### Use Realm with Only Dart In addition to using Realm with Flutter, you can also use Realm only with Dart, like a CLI application or web server. The usage for Realm with Dart is the same as the Flutter SDK, except you must install and set up a separate package. [Learn how to set up Realm in your Dart project.](#std-label-dart-install-steps) 1 ### Create a Flutter Project Create a Flutter project. Follow the instructions in the [Flutter documentation.](https://docs.flutter.dev/get-started/test-drive?tab=terminal) `| flutter create <app_name> |\n| ------------------------- |\n| cd <app_name>             | ` 2 ### Add Realm to the Project To add the [Realm Flutter SDK](https://pub.dev/packages/realm) to your project, run the command: ``` flutter pub add realm \n``` This downloads the `realm` package and adds it to your project. In your `pubspec.yaml` file, you should see: pubspec.yaml ``` dependencies:   realm: <latest_version> \n``` 3 ### Import Realm Package To use the Realm Flutter SDK within your app, import the package into files where you will use it: ```dart import 'package:realm/realm.dart'; \n``` ## Note ### Using Networking in your macOS App If you are developing with the Realm Flutter SDK in the macOS App Sandbox, network requests do not work by default due to built-in macOS security settings. To fix this, you must change the Flutter app's macOS network entitlements. To learn how to do this, refer to [Use Realm with the macOS App Sandbox.](https://mongodb.com/docs/realm/sdk/flutter/troubleshooting/#std-label-flutter-macos-development) ## Dart Standalone Installation To use Realm with Dart but not Flutter, there is a separate Dart SDK package with its own installation process. The Dart SDK can be used for CLI applications or when running Dart in a server environment. The Dart standalone package `realm_dart` has the same usage as the Flutter package except where otherwise noted. 1 ### Create a Dart Project Create a Dart project. ## Note ### Using Dart without Flutter The official Dart docs have helpful getting started material for using Dart without Flutter for CLI and server use cases. [See the official documentation.](https://dart.dev/server) 2 ### Add Realm to the Project\n\n ``` dart pub add realm_dart \n``` This downloads the `realm_dart` package and adds it to your project. In your `pubspec.yaml` file, you should see: pubspec.yaml ``` dependencies:   realm_dart: <latest_version> \n``` 3 ### Install Realm into Application Install the `realm_dart` package into the application. This downloads and copies the required native binaries to the app directory. ``` dart run realm_dart install \n``` 4 ### Import Realm Package To use the Realm Dart SDK within your app, import the package into files where you will use it: ```dart import 'package:realm_dart/realm.dart'; \n``` ## Update Package Version To change the version of the Flutter SDK or Dart Standalone SDK in your project, follow these steps. ← [Realm Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/ \"Previous Section\")[Quick Start - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/quick-start/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/test-and-debug/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Test & Debug - Flutter SDK On this page * [Test](#test)\n* [Test Using an In-Memory Realm](#test-using-an-in-memory-realm)\n* [Test Using a Default Realm](#test-using-a-default-realm)\n* [Clean up Realm Database in Tests](#clean-up-realm-database-in-tests)\n* [Test App Services](#test-app-services)\n* [Test Synced Realms](#test-synced-realms)\n* [Debug](#debug)\n* [Debug with Realm Studio](#debug-with-realm-studio)\n* [Debug with DevTools and Code Editors](#debug-with-devtools-and-code-editors) This page covers some strategies for testing and debugging Flutter apps using the Realm Flutter SDK. You likely will have to adapt the examples on this page significantly to work with your app. ## Test To run tests on the Flutter SDK using the[flutter\\_test](https://api.flutter.dev/flutter/flutter%5Ftest/flutter%5Ftest-library.html)and [test](https://dart.dev/tools/dart-test), you **must** first run the following command: `| flutter pub run realm install |\n| ----------------------------- | ` This command installs native binaries needed to run tests for the Flutter app. ## Note ### Testing on macOS If you are developing with the Realm Flutter SDK on macOS, network requests do not work by default due to built-in macOS security settings. To fix this, you must change the Flutter app's macOS network entitlements. To learn how to do this, refer to [Use Realm with the macOS App Sandbox.](https://mongodb.com/docs/realm/sdk/flutter/troubleshooting/#std-label-flutter-macos-development) ## Note ### Testing for Dart Standalone SDK If you're using the Dart Standalone SDK, you do don't need to install any additional native binaries to run tests. This is because as part of the [installation](https://mongodb.com/docs/realm/sdk/flutter/install/#std-label-flutter-install) to use the Dart Standalone SDK in an app, you already need to install the native binaries. ### Test Using an In-Memory Realm An easy way to use and test Realm Database-backed applications is to test using an in-memory realm. This helps avoid overriding application data or leaking state between tests. Note that you **cannot** use an in-memory realm to test Device Sync. To create an in-memory realm for your tests, you can do the following: 1. Lazily instantiate the `Realm` with the `late` keyword at a higher scope than your tests\n2. Open the realm with a [Configuration.inMemory()](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-in-memory-realm)inside a [setUp function.](https://api.flutter.dev/flutter/flutter%5Ftest/setUp.html)\n3. Close the realm in a [tearDown function.](https://api.flutter.dev/flutter/flutter%5Ftest/tearDown.html) ```dart import 'package:realm/realm.dart'; import 'package:flutter_test/flutter_test.dart'; import '../lib/schema.dart'; // Import schema used in test void main() {   late Realm realm;   setUp(() {     realm = Realm(Configuration.inMemory([Car.schema]));   });   tearDown(() {     realm.close();   });   // ...rest of test code } \n``` ### Test Using a Default Realm Another way to use and test Realm Database-backed applications is to use the default realm. To avoid overriding application data or leaking state between tests, set the default realm to a new file for each test using [Configuration.defaultRealmName](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-customize-default-configuration)inside of a [setUp function.](https://api.flutter.dev/flutter/flutter%5Ftest/setUp.html)\n\n import 'dart:math'; import 'package:realm/realm.dart'; import 'package:flutter_test/flutter_test.dart'; // Utility function to generate random realm name String generateRandomRealmName(int len) {   final r = Random();   const _chars =       'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890';   final nameBase =       List.generate(len, (index) => _chars[r.nextInt(_chars.length)]).join();   return '$nameBase.realm'; } void main() {   // Set default Realm name before each test   setUp(() {     Configuration.defaultRealmName = generateRandomRealmName(10);   });   // ...rest of test code } \n``` ### Clean up Realm Database in Tests To clean up your tests, you can lazily instantiate the realm with the`late` keyword at a higher scope than your tests. Then run clean up operations inside of a [tearDown function](https://api.flutter.dev/flutter/flutter%5Ftest/tearDown.html). Inside of the `tearDown` callback function, close and delete the realm instance. ```dart import 'package:realm/realm.dart'; import 'package:flutter_test/flutter_test.dart'; import '../lib/schema.dart'; // Import schema used in test void main() {   late Realm realm;   // Close and delete the realm after each test   tearDown(() {     final path = realm.config.path;     realm.close();     Realm.deleteRealm(path);   });   test(\"Open a local realm\", () {     realm = Realm(Configuration.local([Car.schema]));     expect(realm.isClosed, isFalse);   }); } \n``` ### Test App Services To test how your Flutter app interacts with [Atlas App Services](https://mongodb.com/docs/realm/sdk/flutter/app-services/#std-label-flutter-application-services), create a separate App Services App with the same configuration as your production app, and connect to it from your test file. To learn more about how to make a copy of the App, refer to [Copy an App](https://www.mongodb.com/docs/atlas/app-services/apps/copy/#std-label-copy-realm-app)in the App Services documentation. You also likely need an authenticated user to test the services that the App exposes. Often, anonymous users are useful for testing. To test the app, you can lazily instantiate the `App` and `User`with the `late` keyword at a higher scope than your tests. Instantiate the `App` client and log a user in inside a `setUp` function. Then run clean up operations inside of a [tearDown function](https://api.flutter.dev/flutter/flutter%5Ftest/tearDown.html). Inside of the `tearDown` callback function, delete the current user from the backend and then log them out on the device. ```dart import 'package:realm/realm.dart'; import 'package:flutter_test/flutter_test.dart'; void main() {   late App app;   setUp(() async {     app = App(AppConfiguration(TEST_APP_ID));     await app.logIn(Credentials.anonymous());   });   // Delete and log current user out   tearDown(() async {     app.deleteUser(app.currentUser!);     await app.currentUser?.logOut();   });   test(\"Check user type\", () {     final user = app.currentUser!;     expect(user.provider, AuthProviderType.anonymous);   }); } \n``` ### Test Synced Realms\n\n Testing synced realms builds on the Clean up Realm Database in Tests and Test App Services sections above. To test a synced Realm, you can lazily instantiate the `App` and`Realm` with the `late` keyword at a higher scope than your tests. In a `tearDown` function, you should perform the following: 1. Delete all data in the realm.\n2. Sync the latest changes to Atlas to ensure that the deletion propagates to Atlas.\n3. Close the Realm.\n4. Delete the Realm File from the device. ```dart import 'package:realm/realm.dart'; import 'package:flutter_test/flutter_test.dart'; import '../lib/schema.dart'; // Import schema used in test void main() {   late App app;   late Realm realm;   setUp(() async {     app = App(AppConfiguration(TEST_APP_ID));     await app.logIn(Credentials.anonymous());   });   // Log current user out   tearDown(() async {     // Delete all items in the realm so that the items are not persisted in Atlas     // and do not re-sync in subsequent tests.     realm.write(() => realm.deleteAll<Car>());     // Fully synchronize realm before closing and deleting     await realm.syncSession.waitForDownload();     await realm.syncSession.waitForUpload();     // Get path before realm closed to pass to Realm.deleteRealm()     final path = realm.config.path;     realm.close();     Realm.deleteRealm(path);     await app.currentUser?.logOut();   });   test(\"Add subscriptions\", () async {     const subName = 'allDogs';     final user = app.currentUser!;     realm = Realm(Configuration.flexibleSync(user, [Car.schema]));     realm.subscriptions.update((mutableSubscriptions) {       mutableSubscriptions.add(realm.all<Car>(), name: subName);     });     await realm.subscriptions.waitForSynchronization();     expect(realm.subscriptions.findByName(subName), isA<Subscription>());   }); } \n``` ## Debug ### Debug with Realm Studio [Realm Studio](https://mongodb.com/docs/realm/studio/#std-label-realm-studio) enables you to open and edit local realms. It supports Mac, Windows and Linux. ### Debug with DevTools and Code Editors To debug your app, You can use the Realm Flutter SDK with [Flutter DevTools.](https://docs.flutter.dev/development/tools/devtools/overview) ← [Troubleshooting - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/troubleshooting/ \"Previous Section\")[Telemetry - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/telemetry/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/write-to-synced-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Write Data to a Synced Realm - Flutter SDK On this page * [Examples on This Page](#examples-on-this-page)\n* [Write to a Synced Realm](#write-to-a-synced-realm)\n* [Compensating Writes](#compensating-writes) When writing data to a synced realm using Flexible Sync, you can use the same APIs as writing to a local realm. However, there are some differences in behavior to keep in mind as you develop your application. To learn more about reading and writing data to a realm, refer to [Read & Write Data.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/#std-label-flutter-read-write-data) ## Examples on This Page The examples on this page use an Atlas App Services App with the following Device Sync configuration and a client app with the following Realm SDK data model and subscriptions. Device Sync is configured with the following queryable fields: * `_id` (always included)\n* `miles`\n* `ownerId` The App Services App has permissions configured to let users read and write only their own data: `| {                                   |\n| ----------------------------------- |\n| \"name\": \"owner-read-write\",         |\n| \"apply_when\": {},                   |\n| \"document_filters\": {               |\n| \"read\": { \"ownerId\": \"%%user.id\" }, |\n| \"write\": { \"ownerId\": \"%%user.id\" } |\n| },                                  |\n| \"read\": true,                       |\n| \"write\": true                       |\n| }                                   | ` The examples on this page use the following schema: ```dart @RealmModel() class _Car {   @MapTo(\"_id\")   @PrimaryKey()   late ObjectId id;   // This is the queryable field   late String ownerId;   late String make;   late String? model;   late int? miles; } \n``` Using that schema, the examples configure the synced realm to synchronize objects matching this subscription query: ```dart final app = App(AppConfiguration(APP_ID)); final user = await app.logIn(Credentials.anonymous()); final config = Configuration.flexibleSync(user, [Car.schema]); final realm = Realm(config); // Add subscriptions realm.subscriptions.update((mutableSubscriptions) {   // Get Cars from Atlas that match the Realm Query Language query.   // Uses the queryable field `miles`.   // Query matches cars with less than 100 miles or `null` miles.   final newCarQuery = realm.query<Car>(\"miles < 100 OR miles == \\$0\", [null]);   mutableSubscriptions.add(newCarQuery, name: \"new-car-subscription\"); }); await realm.subscriptions.waitForSynchronization(); \n``` ## Write to a Synced Realm When you write to a synced realm, your write operations must match _both_of the following:\n\n To learn more about permission denied errors, compensating write errors and other Device Sync error types, refer to [Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services documentation. ```dart // Per the Device Sync permissions, users can only read and write data // where the `Car.ownerId` property matches their own user ID. final userId = user.id; realm.write(() {   // WRITE SUCCEEDS   // `newCar` is successfully written to the realm and synced to Atlas   // because it's data matches the subscription query (miles < 100)   // and it's `ownerId` field matches the user ID.   final newCar = Car(ObjectId(), userId, 'Toyota', miles: 2);   realm.add(newCar);   // WRITE REVERTED BY COMPENSATING WRITE ERROR   // `oldCar` is initially written to the realm, then removed upon synchronization   // in a compensating write when the server processes the write.   // This is because the `miles` property of `oldCar` doesn't match   // the subscription query, which is only for cars with less than 100 miles.   final oldCar = Car(ObjectId(), userId, 'Honda', miles: 90000);   realm.add(oldCar);   // WRITE REVERTED BY PERMISSION ERROR   // `otherUsersCar` is initially written to the realm, then removed upon synchronization   // because it's `ownerId` property doesn't match the user ID of the user   // making the request.   final otherUsersCar = Car(ObjectId(), 'someOtherId', 'Ford');   realm.add(otherUsersCar); }); \n``` ## Compensating Writes Compensating write errors occur when you write data to a realm that doesn't align with the realm's sync subscriptions. When you write data that doesn't match a subscription, the following occurs: 1. Because the client realm has no concept of \"illegal\" writes, the write initially succeeds until realm resolves the changeset with the App Services backend.\n2. Upon sync, the server applies the rules and permissions. The server determines that the user does not have authorization to perform the write.\n3. The server sends a revert operation, called a \"compensating write\", back to the client.\n4. The client's realm reverts the illegal write operation. Any client-side writes to a given object between an illegal write to that object and the corresponding compensating write will be lost. ```dart final carId = ObjectId(); final ownerId = app.currentUser!.id; realm.write(() {   // `oldCar` is initially written to the realm, then later removed   // in a compensating write when the server processes the write.   // This is because the `miles` property of `oldCar` doesn't match   // the subscription query, which is only for cars with less than 100 miles.   final oldCar = Car(carId, ownerId, 'Honda', miles: 90000);   realm.add(oldCar); }); // Let changes sync to and from server await realm.syncSession.waitForUpload(); await realm.syncSession.waitForDownload(); final noCar = realm.find<Car>(carId); // The Car is no longer in the realm because of // the compensating write from the server. expect(noCar, isNull); \n``` ← [Manage Sync Subscriptions - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-subscriptions/ \"Previous Section\")[Manage a Sync Session - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-session/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/add-sync-to-app/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Add Device Sync to an App - Flutter SDK On this page * [Set up Device Sync](#set-up-device-sync)\n* [Configure Atlas Device Sync in App Services](#configure-atlas-device-sync-in-app-services)\n* [Connect to the App Services Backend](#connect-to-the-app-services-backend)\n* [Authenticate a user](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Use the Realm](#use-the-realm) ## Set up Device Sync 1 ### Configure Atlas Device Sync in App Services Before you can use Device Sync with the Realm Flutter SDK, you must create an Atlas App Services App with Device Sync and authentication enabled. To learn how to set up Device Sync in your App, refer to [Get Started with Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-realm-sync-get-started)in the App Services documentation. To set up authentication, refer to [Authenticate & Manage Users](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication) in the App Services documentation. 2 ### Connect to the App Services Backend Initialize the an [App](https://pub.dev/documentation/realm/latest/realm/App/App.html) instance to connect to your App Services App. Pass the App ID for your App, which you can [find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) `| final app = App(AppConfiguration(APP_ID)); |\n| ------------------------------------------ | ` 3 ### Authenticate a user [Authenticate a user](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-authenticate) in your client project. This example uses [anonymous authentication.](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-login-anonymous) ```dart final user = await app.logIn(Credentials.anonymous()); \n``` 4 ### Open a Synced Realm Use a Flexible Sync configuration to [open the realm as a synced realm](https://mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/#std-label-flutter-open-synced-realm). Also [add a subscription](https://mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-subscriptions/#std-label-flutter-flexible-sync-manage-subscriptions)to synchronize data matching the subscription query. ```dart // Configure and open the realm final config = Configuration.flexibleSync(user, [Car.schema]); final realm = Realm(config); // Add subscription to sync all Car objects in the realm realm.subscriptions.update((mutableSubscriptions) {   mutableSubscriptions.add(realm.all<Car>()); }); // Sync all subscriptions await realm.subscriptions.waitForSynchronization(); \n``` ## Use the Realm The syntax to [read](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/#std-label-flutter-read-data), [write](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/#std-label-flutter-write-operations), and[watch for changes](https://mongodb.com/docs/realm/sdk/flutter/realm-database/react-to-changes/#std-label-flutter-react-to-changes) on a synced realm is identical to the syntax for non-synced realms. While you work with local data, a background thread integrates, uploads, and downloads changesets. The following code creates a new `Car` object and writes it to the realm: ```dart // Write data to realm and it automatically syncs with Atlas // in the background. realm.write(() {\n\n }); \n``` ← [Device Sync - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/ \"Previous Section\")[Open a Synced Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-session/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage a Sync Session - Flutter SDK On this page * [Prerequisites](#prerequisites)\n* [Wait for Changes to Upload and Download](#wait-for-changes-to-upload-and-download)\n* [Pause and Resume a Sync Session](#pause-and-resume-a-sync-session)\n* [When to Pause a Sync Session](#when-to-pause-a-sync-session)\n* [Monitor Sync Upload Progress](#monitor-sync-upload-progress)\n* [Monitor Network Connection](#monitor-network-connection) When you use Atlas Device Sync, the Realm Flutter SDK syncs data with Atlas in the background using a sync session. The sync session starts whenever you open a synced realm. The sync session manages the following: * Uploading and downloading changes to the realm\n* Pausing and resuming sync\n* Monitoring sync progress\n* Monitoring network connectivity You can access the [Session](https://pub.dev/documentation/realm/latest/realm/Session-class.html) of any synced realm through the [Realm.syncSession](https://pub.dev/documentation/realm/latest/realm/Realm/syncSession.html) property. ## Prerequisites Before you can manage your sync session state, you must perform the following: 1. [Configure Flexible Sync on the Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n2. [Add Device Sync to your app](https://mongodb.com/docs/realm/sdk/flutter/sync/add-sync-to-app/#std-label-flutter-add-sync-to-app) ## Wait for Changes to Upload and Download To asynchronously wait for all changes to upload to Atlas from your synced realm, call [Session.waitForUpload()](https://pub.dev/documentation/realm/latest/realm/Session/waitForUpload.html). To asynchronously wait for all changes on Atlas to download to your synced realm, call [Session.waitForDownload().](https://pub.dev/documentation/realm/latest/realm/Session/waitForDownload.html)\n\n ` ## Pause and Resume a Sync Session To pause syncing for a session, call [Session.pause()](https://pub.dev/documentation/realm/latest/realm/Session/pause.html). The realm will not sync changes with Atlas while the session is paused. To resume syncing a changes, call [Session.resume().](https://pub.dev/documentation/realm/latest/realm/Session/resume.html) You must manually call `Session.pause()` and `Session.resume()` for each realm whose Sync session you want to pause and restart. The sync state of one session has no impact on other open sessions. The following code block demonstrates calling these methods: ```dart // Pause the sync session realm.syncSession.pause(); // Data that you add while the sync session is paused does not sync to Atlas. // However, the data is still added to the realm locally. realm.write(() {   realm.addAll<Car>([     Car(ObjectId(), \"Volvo\"),     Car(ObjectId(), \"Genesis\"),     Car(ObjectId(), \"VW\")   ]); }); // Resume sync session. Now, the data you wrote to the realm // syncs to Atlas. realm.syncSession.resume(); \n``` ### When to Pause a Sync Session For most applications, there is no need to manually pause and resume a sync session. However, there are a few circumstances under which you may want to pause or suspend a sync session: * You only want to sync after the user takes a specific action\n* You only want to sync during a certain time of the day\n* You don't want to attempt to sync when there is poor network connectivity\n* You want to explicitly force a sync session to connect In the case of poor network connectivity, continually trying to establish a network connection can drain the user's device battery. The case of explicitly forcing a sync session to connect is most commonly related to being offline for some time. The sync client attempts to connect, and upon failure, goes into exponential backoff. After being offline for a long time, the client may not immediately reconnect. Pausing and resuming the sync session explicitly forces the connection. When you do pause a sync session, keep these things in mind: * If the client may be offline longer than the [client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), the client will be unable to resume syncing and must perform a [client reset.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets)\n* Pausing a sync session pauses it in both directions. Changes that your app makes on the device do not sync with the backend, _and_ changes to the data in the backend or on other devices do not sync to the device. There is no way to pause only uploads or pause only downloads.\n* Do not pause a sync session if you want a client to permanently stop syncing with the backend. To permanently stop syncing, copy the contents of the synced realm into a non-synced realm, and use the non-synced realm in the client. _Do not_ pause sync to stop syncing for indefinite time periods or time ranges in months and years. The functionality is not designed or tested for these use cases. You could encounter a range of issues when using it this way. ## Monitor Sync Upload Progress To monitor Sync upload progress progress, call [SyncSession.getProgressStream()](https://pub.dev/documentation/realm/latest/realm/Session/getProgressStream.html). This method returns a Stream of[SyncProgress](https://pub.dev/documentation/realm/latest/realm/SyncProgress-class.html) objects.`SyncProgress` provides the total number of transferrable bytes and the remaining bytes to be transferred. `SyncSession.getProgressStream()` takes two arguments:\n\n ```dart final stream = realm.syncSession.getProgressStream(     ProgressDirection.upload, ProgressMode.forCurrentlyOutstandingWork); late StreamSubscription streamListener; streamListener = stream.listen((syncProgressEvent) {   if (syncProgressEvent.transferableBytes ==       syncProgressEvent.transferredBytes) {     // Upload complete     print('Upload complete');     // Stop listening to the Stream     streamListener.cancel();   } }); \n``` ## Warning ### Do Not Track Downloads The `ProgressDirection` enum also has a `download` option to track down downloads. The `download` case provides planned future support for download progress notifications. However, these notifications do not currently provide an accurate indicator of download progress. Do not rely on `ProgressDirection.download` for download progress notifications. ## Monitor Network Connection You can get the state of the current network connection with[Session.connectionState](https://pub.dev/documentation/realm/latest/realm/Session/connectionState.html). This returns a [ConnectionState](https://pub.dev/documentation/realm/latest/realm/ConnectionState.html) enum that contains the network connection's state: `connected`, `disconnected`, or `connecting`. ```dart if (realm.syncSession.connectionState == ConnectionState.connected) {   // ... do stuff } \n``` Monitor the state of the network connection with[Session.connectionStateChanges](https://pub.dev/documentation/realm/latest/realm/Session/connectionStateChanges.html). This property returns a Stream of [ConnectionStateChange](https://pub.dev/documentation/realm/latest/realm/ConnectionStateChange-class.html)objects that updates when the network connection changes. You can access the current and previous `ConnectionState` from `ConnectionStateChange`. ```dart final connectionStream = realm.syncSession.connectionStateChanges; late StreamSubscription streamListener; streamListener = connectionStream.listen((connectionStateChange) {   if (connectionStateChange.current == ConnectionState.connected) {     print(\"Connected to Atlas Device Sync server\");     streamListener.cancel();   } }); \n``` ← [Write Data to a Synced Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/write-to-synced-realm/ \"Previous Section\")[Sync Data from Multiple Processes](https://mongodb.com/docs/realm/sdk/flutter/sync/sync-multiple-processes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Open a Synced Realm - Flutter SDK On this page * [Before You Begin](#before-you-begin)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Open a Realm After Downloading Changes](#open-a-realm-after-downloading-changes)\n* [Configure a Realm](#configure-a-realm)\n* [Close a Realm](#close-a-realm)\n* [Further Reading](#further-reading) This page describes how to open a synced realm using Device Sync. To learn how to open and configure non-synced realms, see [Open and Close a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-open-close-realm) ## Before You Begin Before you open a realm with Flexible Sync in a Flutter application: 1. [Configure Flexible Sync on the backend](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync). You must configure Flexible Sync in the backend before you can use it with your client application.\n2. [Initialize the App client.](https://mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/#std-label-flutter-connect-to-backend)\n3. [Authenticate a user](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-authenticate) in your client project. ## Open a Synced Realm To open a synced realm, pass a logged in user, a list of Realm object schemas, and additional optional named arguments to the[Configuration.flexibleSync()](https://pub.dev/documentation/realm/latest/realm/Configuration/flexibleSync.html) constructor. This constructor returns a [FlexibleSyncConfiguration](https://pub.dev/documentation/realm/latest/realm/FlexibleSyncConfiguration-class.html). Then, pass the `FlexibleSyncConfiguration` to [Realm()](https://pub.dev/documentation/realm/latest/realm/Realm-class.html)to open an instance of the realm. Data syncs with App Services in the background after you open the realm. `| final currentUser = await app.logIn(credentials);                         |\n| ------------------------------------------------------------------------- |\n| final config = Configuration.flexibleSync(currentUser, [Tricycle.schema], |\n| path: 'flex.realm');                                                      |\n| final realm = Realm(config);                                              | ` Once you open a synced realm, [configure and manage the sync subscriptions.](https://mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-subscriptions/#std-label-flutter-flexible-sync-manage-subscriptions) ### Open a Realm After Downloading Changes To sync all data with App Services when you open a realm, use the asynchronous method[Realm.open()](https://pub.dev/documentation/realm/latest/realm/Realm/open.html). The operation syncs all available data before returning the realm. On first open, `Realm.open()` downloads all data that matches your sync subscriptions. Subsequent opens only download the latest changes. Depending on initial realm size and updates to the data set while the device is not syncing, performance may be slower on first open and faster on subsequent opens.\n\n ```dart // Helper function to check if device is connected to the internet. Future<bool> isDeviceOnline() async {   // ...logic to check if device is online } final config = Configuration.flexibleSync(currentUser, [Tricycle.schema]); // Only use asynchronous open if app is online. late Realm realm; if (await isDeviceOnline()) {   // If the device is online, download changes and then open the realm.   realm = await Realm.open(config); } else {   // If the device is offline, open the realm immediately   // and automatically sync changes in the background when the device is online.   realm = Realm(config); } \n``` To track the state of the synchronization, pass a [ProgressCallback](https://pub.dev/documentation/realm/latest/realm/ProgressCallback.html)to the optional named argument `onProgressCallback`. ```dart final realm =     await Realm.open(config, onProgressCallback: (syncProgress) {   if (syncProgress.transferableBytes == syncProgress.transferredBytes) {     print('All bytes transferred!');   } }); \n``` To be able to cancel a synchronization in progress, pass a [CancellationToken](https://pub.dev/documentation/cancellation%5Ftoken/latest/cancellation%5Ftoken/CancellationToken-class.html)instance to the optional named argument `cancellationToken`. Call [CancellationToken.cancel()](https://pub.dev/documentation/cancellation%5Ftoken/latest/cancellation%5Ftoken/CancellationToken/cancel.html)to cancel the synchronization. ```dart final token = CancellationToken(); // Cancel the open operation after 30 seconds. // Alternatively, you could display a loading dialog and bind the cancellation // to a button the user can click to stop the wait. Future<void>.delayed(     const Duration(seconds: 30),     () => token.cancel(CancelledException(         cancellationReason: \"Realm took too long to open\"))); // If realm does not open after 30 seconds with asynchronous Realm.open(), // open realm immediately with Realm() and try to sync data in the background. late Realm realm; try {   realm = await Realm.open(config, cancellationToken: token); } on CancelledException catch (err) {   print(err.cancellationReason); // prints \"Realm took too long to open\"   realm = Realm(config); } \n``` ## Example ### Realm() vs. Realm.open() This section compares examples of scenarios when you might want to use `Realm()`versus `Realm.open()` to open a realm in an application. Consider an app that allows users to record and save their favorite recipes. You might want to give the user the option to create a new recipe without waiting to download updates, or even if they're offline. In this case, `Realm()` is preferable. The user can operate offline, but the app syncs their recipes when they next have a network connection. Consider an game app with a tablet and phone version. A user plays the game on both a table and a phone. The user progresses three levels on the tablet. Later, the user opens the game on a phone. In this case, `Realm.open()` is a better way to open the realm. Since `Realm.open()` synchronizes data before returning the realm, it makes sure that the user's progress is synced on the phone before they start using the app, even if the initial load time may be slower. ## Configure a Realm For more information on general realm configuration options, refer to[Configure a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-configure-realm) To handle errors in your synced realm using additional configuration properties, refer to [Handle Sync Errors.](https://mongodb.com/docs/realm/sdk/flutter/sync/handle-sync-errors/#std-label-flutter-handle-sync-errors) ## Close a Realm Once you've finished working with a synced realm, close it to prevent memory leaks. ```dart realm.close(); \n``` ## Further Reading\n\n ← [Add Device Sync to an App - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/add-sync-to-app/ \"Previous Section\")[Manage Sync Subscriptions - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-subscriptions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/access-token/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Get the User Access Token - Flutter SDK On this page * [Retrieve the Access Token](#retrieve-the-access-token)\n* [Refresh the Access Token](#refresh-the-access-token) Every User object contains a JWT token that you can use to access Atlas App Services. You can use the access token to query the Atlas GraphQL API from your client application. Use any GraphQL client to query the Atlas GraphQL API, such as [graphql\\_flutter](https://pub.dev/packages/graphql%5Fflutter). To learn more about setting up and querying the Atlas GraphQL API, refer to [Atlas GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) in the App Services documentation. ## Retrieve the Access Token You can get the access token with the [User.accessToken](https://pub.dev/documentation/realm/latest/realm/User/accessToken.html) property. `| final token = app.currentUser?.accessToken; |\n| ------------------------------------------- | ` ## Refresh the Access Token The access token expires 30 minutes after a user logs in. It does not refresh automatically. Refresh it with [User.refreshCustomData().](https://pub.dev/documentation/realm/latest/realm/User/refreshCustomData.html) ```dart Future<String> getValidAccessToken(User user) async {   // An already logged in user's access token might be stale. To   // guarantee that the token is valid, refresh it if necessary.   await user.refreshCustomData();   return user.accessToken; } \n``` You can also periodically refresh the access token with [Timer.periodic()](https://api.dart.dev/be/180360/dart-async/Timer-class.html)from the `dart:async` library. Wrap the call to `User.refreshCustomData()`with the timer's callback function. ```dart // Refresh the token every 29 minutes Timer.periodic(Duration(minutes: 29), (_) {   app.currentUser?.refreshCustomData(); }); \n``` ← [Delete a User - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/delete-user/ \"Previous Section\")[Device Sync - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/sync-multiple-processes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Data from Multiple Processes You can use a single realm database to synchronize data from multiple processes using Atlas Device Sync. Examples of scenarios where you might want to open a synced realm in multiple processes include: * A multi-window desktop application where each window writes to the same synced realm.\n* A server application that writes to a synced realm from multiple processes. ## Open a Synced Realm in Multiple Processes To open a single synced realm from multiple processes, perform the following: 1. Create a single **main process** that opens a Realm using a standard flexible sync configuration. The main process handles synchronization.\n2. Create one or more **secondary processes** that open the same realm using a disconnected sync configuration. Using a disconnected sync configuration, the secondary processes reads and writes data to the realm without handling the synchronization. The main process handles the synchronization of all data for the secondary process. To open a synced realm in the main process, use the[Configuration.flexibleSync()](https://pub.dev/documentation/realm/latest/realm/Configuration/flexibleSync.html)constructor. For more information, refer to [Open a Synced Realm.](https://mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/#std-label-flutter-open-synced-realm) main\\_process.dart `| // Same realm file location as secondary process                  |\n| ----------------------------------------------------------------- |\n| final realmPath =                                                 |\n| path.join(Configuration.defaultStoragePath, 'synced.realm');      |\n| final flexibleConfig =                                            |\n| Configuration.flexibleSync(currentUser, schema, path: realmPath); |\n| final realmWithSync = Realm(flexibleConfig);                      | ` To open a synced realm in a secondary process, create a `Configuration` with the[Configuration.disconnectedSync()](https://pub.dev/documentation/realm/latest/realm/Configuration/disconnectedSync.html)constructor. Include the schema and any additional optional named arguments. secondary\\_process.dart ```dart // Same realm file location as primary process final sameRealmPath =     path.join(Configuration.defaultStoragePath, 'synced.realm'); final disconnectedSyncConfig =     Configuration.disconnectedSync(schema, path: sameRealmPath); final realmWithDisconnectedSync = Realm(disconnectedSyncConfig); \n``` ## Refresh Data across Processes When sharing the same realm file between multiple processes, Realm has auto-refresh built-in. Data written from one process is visible to the other processes. Generally, you do not need to write additional logic to refresh data across processes. However, occasionally the refresh may not happen immediately. In this case, you can trigger a manual refresh in a process with [Realm.refresh()](https://pub.dev/documentation/realm/latest/realm/Realm/refresh.html)or [Realm.refreshAsync().](https://pub.dev/documentation/realm/latest/realm/Realm/refreshAsync.html) To synchronously force update notifications for changes made by another process, call `Realm.refresh()`. main\\_process.dart ```dart // Add object in one process realm.write(() {   realm.add(Person('John')); }); \n``` secondary\\_process.dart ```dart // Call realm.refresh() in the secondary process // to trigger the data written in the main process // to register in the secondary process. realm.refresh(); realm.find<Person>('John'); \n``` Alternatively, you can use `Realm.refreshAsync()` to asynchronously force update notifications for changes made by another process. secondary\\_process.dart ```dart\n\n await realm.refreshAsync(); final john = realm.find<Person>('John'); \n``` ← [Manage a Sync Session - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-session/ \"Previous Section\")[Handle Sync Errors - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/handle-sync-errors/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/handle-sync-errors/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Handle Sync Errors - Flutter SDK On this page * [Handle Sync Errors](#handle-sync-errors)\n* [Client Reset](#client-reset)\n* [Client Reset Modes](#client-reset-modes)\n* [Automatic vs. Manual Client Reset](#automatic-vs.-manual-client-reset)\n* [Client Reset with Recovery](#client-reset-with-recovery)\n* [Recover or Discard Unsynced Changes Mode](#recover-or-discard-unsynced-changes-mode)\n* [Recover Unsynced Changes Mode](#recover-unsynced-changes-mode)\n* [Discard Unsynced Changes Mode](#discard-unsynced-changes-mode)\n* [Manual Recovery Fallback](#manual-recovery-fallback)\n* [Manual Recovery Mode](#manual-recovery-mode) ## Handle Sync Errors While developing an application that uses [Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), you should set an error handler. This error handler will detect and respond to any failed sync-related API calls. Add a [syncErrorHandler](https://pub.dev/documentation/realm/latest/realm/FlexibleSyncConfiguration/syncErrorHandler.html)property to the [FlexibleSyncConfiguration](https://pub.dev/documentation/realm/latest/realm/FlexibleSyncConfiguration-class.html)when creating a synced realm. `syncErrorHandler` is a[SyncErrorHandler](https://pub.dev/documentation/realm/latest/realm/SyncErrorHandler.html) callback function.`SyncErrorHandler` accepts a [SyncError](https://pub.dev/documentation/realm/latest/realm%5Fcommon/SyncError-class.html)as a parameter. Whenever a `SyncError` occurs in the realm, the callback function is invoked with the `SyncError` as its argument. If you do not specify a `syncErrorHandler`, the default behavior is to print the`SyncError` to the console. `| final config = Configuration.flexibleSync(currentUser, [Tricycle.schema], |\n| ------------------------------------------------------------------------- |\n| syncErrorHandler: (SyncError error) {                                     |\n| print(\"Error message\" + error.message.toString());                        |\n| });                                                                       |\n| final realm = Realm(config);                                              | ` ## Tip For a list of common Device Sync errors and how to handle them, refer to[Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services Device Sync documentation. ## Client Reset When using Device Sync, a **client reset** is an error recovery task that your client app must perform when the Device Sync server can no longer sync with the client realm. Clients in this state may continue to run and save data locally but cannot send or receive sync changesets until they perform a client reset. The client must reset its realm to a state that matches the server in order to restore the ability to sync. The unsyncable realm on the client may contain data that has not yet synced to the server. The Realm SDK can attempt to recover or discard that data during the client reset process. The Realm SDK provides methods to automatically handle client resets in most scenarios.\n\n ### Client Reset Modes To manage the client reset process, you can specify a client reset mode in your [FlexibleSyncConfiguration.clientResetHandler](https://pub.dev/documentation/realm/latest/realm/FlexibleSyncConfiguration/clientResetHandler.html) property when configuring a realm. You can use the following client reset modes: * [Recover or discard unsynced changes mode](#std-label-flutter-client-reset-recover-or-discard-unsynced-changes) (default): In this client reset mode, the client reset handler first attempts to recover unsynced changes. If recovery fails, this handler falls back to the discard unsyced changes mode, which deletes all unsynced local changes. If discard unsyced changes mode fails, the handler falls back to manual recovery mode.\n* [Recover unsynced changes mode](#std-label-flutter-client-reset-recover-unsynced-changes): In this client reset mode, the client reset handler first attempts to recover unsynced changes. If recovery fails, this handler falls back to manual recovery mode.\n* [Discard unsynced changes mode](#std-label-flutter-discard-unsynced-changes): This client reset mode _permanently deletes_ all local unsynced changes made since the last successful sync. If recovery fails, this handler falls back to manual recovery mode.\n* [Manual recovery mode](#std-label-flutter-client-reset-manual-recovery-mode): This client reset mode provides a way for you to implement your own recovery strategy. The following sections describe how to use these client reset modes. ### Automatic vs. Manual Client Reset The Realm SDKs provide client reset modes that automatically handle most client reset errors. Automatic client reset modes restore your local realm file to a syncable state without closing the realm or missing notifications. The following client reset modes support automatic client resets: * Recover unsynced changes mode\n* Recover or discard unsynced changes mode\n* Discard unsynced changes mode The differences between these modes are based on how they handle changes on the device that have not yet synced to the backend. Only manual recovery mode does not perform an automatic client reset. Choose recover unsynced changes mode to handle most client reset scenarios automatically. This attempts to recover unsynced changes when a client reset occurs. If your app requires specific client reset logic that can't be handled automatically, you may want or need to add a [manual client reset handler](#std-label-flutter-client-reset-manual-recovery-fallback)to the automatic client reset mode. ### Client Reset with Recovery Client Recovery is a feature that is enabled by default when you configure Device Sync. When Client Recovery is enabled, Realm Database automatically manages the client reset process in most cases. When you make schema changes the client can recover unsynced changes when there are no schema changes, or non-breaking schema changes. To use Client Recovery, configure your realm with recover unsynced changes or recover or discard unsynced changes client reset modes. When Client Recovery is enabled, these rules determine how objects are integrated, including how conflicts are resolved when both the backend and the client make changes to the same object: * Objects created locally that were not synced before client reset are synced.\n* If an object is deleted on the server, but is modified on the recovering client, the delete takes precedence and the client discards the update.\n* If an object is deleted on the recovering client, but not the server, then the client applies the server's delete instruction.\n* In the case of conflicting updates to the same field, the client update is applied. For more information about configuring Client Recovery, refer to[Client Recovery](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-enable-or-disable-recovery-mode) in the App Services documentation. Client Recovery cannot occur when your app makes breaking schema changes. A breaking change is a change that you can make in your server-side schema that requires additional action to handle. In this scenario, client reset with fall back to a[manual error client reset fallback.](#std-label-flutter-client-reset-manual-recovery-fallback)\n\n #### Recover or Discard Unsynced Changes Mode Recover or discard unsynced changes mode attempts to recover all unsynced local changes automatically during a client reset. If you do not specify a client reset mode, client reset behavior defaults to recover or discard unsynced changes. If the automatic recovery process fails, it falls back to discard unsynced changes mode. If that process fails, it falls back again to a manual reset mode. Recover or discard unsynced changes mode provides the most robust recovery process. However, do not use recover or discard unsynced changes mode if your application cannot lose local data that has not yet synced to the backend. To customize usage of recover or discard unsynced changes mode, pass a [RecoverOrDiscardUnsyncedChangesHandler](https://pub.dev/documentation/realm/latest/realm/RecoverOrDiscardUnsyncedChangesHandler-class.html)callback to the `Configure.clientResetHandler`. Add the following optional callback methods to extend the handler's functionality: * [onBeforeReset](https://pub.dev/documentation/realm/latest/realm/RecoverOrDiscardUnsyncedChangesHandler/onBeforeReset.html), which the SDK invokes prior to the client reset. You can use this callback to notify the user before the client reset begins.\n* [onAfterRecovery](https://pub.dev/documentation/realm/latest/realm/RecoverOrDiscardUnsyncedChangesHandler/onAfterRecovery.html), which the SDK invokes if _and only if_ the automatic reset completes successfully. You can use it to notify the user that the client reset is complete.\n* [onAfterDiscard](https://pub.dev/documentation/realm/latest/realm/RecoverOrDiscardUnsyncedChangesHandler/onAfterDiscard.html), which the SDK invokes only if the automatic client reset fails _and_ the discard local strategy succeeds. If the discard strategy fails, this callback is not invoked.\n* [onManualResetFallback](https://pub.dev/documentation/realm/latest/realm/ClientResetHandler/onManualReset.html), which the SDK invokes only if the automatic recovery and the discard strategy have failed. Implement this callback to handle the reset failure, as explained in the [Manual Recovery Fallback section.](#std-label-flutter-client-reset-manual-recovery-fallback) The following example shows using `RecoverOrDiscardUnsyncedChangesHandler` and each of its callbacks: ```dart final config = Configuration.flexibleSync(currentUser, schema,     clientResetHandler: RecoverOrDiscardUnsyncedChangesHandler(       // All the following callbacks are optional       onBeforeReset: (beforeResetRealm) {         // Executed before the client reset begins.         // Can be used to notify the user that a reset is going         // to happen.       },       onAfterRecovery: (beforeResetRealm, afterResetRealm) {         // Executed if and only if the automatic recovery has succeeded.       },       onAfterDiscard: (beforeResetRealm, afterResetRealm) {         // Executed if the automatic recovery has failed         // but the discard unsynced changes fallback has completed         // successfully.       },       onManualResetFallback: (clientResetError) {         // Automatic reset failed. Handle the reset manually here.         // Refer to the \"Manual Client Reset Fallback\" documentation         // for more information on what you can include here.       },     )); \n``` #### Recover Unsynced Changes Mode Recover unsyced changes mode attempts to recover all unsynced local changes automatically during a client reset. However, unlike recover _or discard_ unsyced changes mode, this mode does not fall back to a discard local changes if the automatic recovery fails. Instead, it falls back to manually recover changes.\n\n * [onBeforeReset](https://pub.dev/documentation/realm/latest/realm/RecoverUnsyncedChangesHandler/onBeforeReset.html), which the SDK invokes prior to the client reset. You can use this callback to notify the user before the reset begins.\n* [onAfterReset](https://pub.dev/documentation/realm/latest/realm/RecoverUnsyncedChangesHandler/onAfterReset.html), which the SDK invokes _if and only if_ the automatic reset completes successfully. You can use this callback to notify the user when the reset has completed successfully.\n* [onManualResetFallback](https://pub.dev/documentation/realm/latest/realm/ClientResetHandler/onManualReset.html), which the SDK invokes only if the automatic recovery and the discard strategy have failed. You implement this callback to handle the reset failure, as explained in the[Manual Recovery Fallback section.](#std-label-flutter-client-reset-manual-recovery-fallback) The following example shows using `RecoverUnsyncedChangesHandler` and each of its callbacks: ```dart final config = Configuration.flexibleSync(currentUser, schema,     clientResetHandler: RecoverUnsyncedChangesHandler(       // All the following callbacks are optional       onBeforeReset: (beforeResetRealm) {         // Executed before the client reset begins.         // Can be used to notify the user that a reset is going         // to happen.       },       onAfterReset: (beforeResetRealm, afterResetRealm) {         // Executed after the client reset is complete.         // Can be used to notify the user that the reset is done.       },       onManualResetFallback: (clientResetError) {         // Automatic reset failed. Handle the reset manually here.         // Refer to the \"Manual Client Reset Fallback\" documentation         // for more information on what you can include here.       },     )); \n``` ### Discard Unsynced Changes Mode Discard unsyced changes mode permanently deletes all local unsynced changes made since the last successful sync. If you choose to use this client reset mode, the SDK restores your local realm file to a syncable state without closing the realm and while keeping notifications fully working. If this process fails, it falls back to manual recovery mode. Do not use recover or discard unsynced changes mode if your application cannot lose local data that has not yet synced to the backend. To use discard unsynced changes mode, pass a [DiscardUnsyncedChangesHandler](https://pub.dev/documentation/realm/latest/realm/DiscardUnsyncedChangesHandler-class.html)callback to the `Configure.clientResetHandler`. This handler provides the following callback methods: * [onBeforeReset](https://pub.dev/documentation/realm/latest/realm/DiscardUnsyncedChangesHandler/onBeforeReset.html), which the SDK invokes prior to the client reset. You can use this callback to notify the user before the reset begins.\n* [onAfterReset](https://pub.dev/documentation/realm/latest/realm/DiscardUnsyncedChangesHandler/onAfterReset.html), which the SDK invokes if _and only if_ the reset completes successfully. You can use it to notify the user when the reset is complete.\n* [onManualResetFallback](https://pub.dev/documentation/realm/latest/realm/ClientResetHandler/onManualReset.html), which the SDK invokes only if the automatic recovery and the discard strategy have failed. You implement this callback to handle the reset failure, as explained in the[Manual Recovery section.](https://mongodb.com/docs/realm/sdk/dotnet/sync/client-reset/#std-label-dotnet-client-reset-manual-recovery) The following example shows using `DiscardUnsyncedChangesHandler` and each of its callbacks: ```dart final config = Configuration.flexibleSync(currentUser, schema,\n\n       onBeforeReset: (beforeResetRealm) {         // Executed before the client reset begins.         // Can be used to notify the user that a reset is going         // to happen.       },       onAfterReset: (beforeResetRealm, afterResetRealm) {         // Executed after the client reset is complete.         // Can be used to notify the user that the reset is done.       },       onManualResetFallback: (clientResetError) {         // Automatic reset failed. Handle the reset manually here.         // Refer to the \"Manual Client Reset Fallback\" documentation         // for more information on what you can include here.       },     )); \n``` ### Manual Recovery Fallback If the client reset with recovery cannot complete automatically, like when there are breaking schema changes, the client reset process falls through to a manual error handler. This may occur in any of the automatic client reset modes: * Recover unsynced changes mode\n* Recover or discard unsynced changes mode\n* Discard unsyced changes mode You must provide a manual client reset implementation in the `onManualResetFallback` callback of the client reset handler for these modes. In `onManualResetFallback`, initiate a client reset using the[ClientResetError.resetRealm()](https://pub.dev/documentation/realm/latest/realm/ClientResetError/resetRealm.html) method of the `ClientResetError` parameter of the callback.`ClientResetError.resetRealm()` performs a client reset by deleting the realm on device and downloading relevant data from the server. Before you use this method, you must close all instances of the realm that you are resetting. The following example demonstrates how you can manually handle an error case by discarding all unsynced changes: ```dart // Lazily initialize `realm` so that it can be used in the callback // before the realm has been opened. late Realm realm; final config = Configuration.flexibleSync(currentUser, schema,     // This example uses the `RecoverOrDiscardUnsyncedChangesHandler`,     // but the same logic could also be used with the `RecoverUnsyncedChangesHandler`     // or the `DiscardUnsyncedChangesHandler`.     clientResetHandler: RecoverOrDiscardUnsyncedChangesHandler(   onManualResetFallback: (clientResetError) {     // Prompt user to perform a client reset immediately. If they don't,     // they won't receive any data from the server until they restart the app     // and all changes they make will be discarded when the app restarts.     var didUserConfirmReset = showUserAConfirmationDialog();     if (didUserConfirmReset) {       // You must close the Realm before attempting the client reset.       realm.close();       // Attempt the client reset.       try {         clientResetError.resetRealm();         // Navigate the user back to the main page or reopen the         // the Realm and reinitialize the current page.       } catch (err) {         // Reset failed.         // Notify user that they'll need to update the app       }     }   }, )); \n``` ### Manual Recovery Mode Use manual recovery mode for the infrequent cases where you need to customize your data recovery process. In most cases, you should use one of the other strategies for client resets. You might want to use a manual client reset handler if the Automatic Recovery logic does not work for your app and you can't discard unsynced local data. To use manual recovery mode, pass a [ManualRecoveryHandler](https://pub.dev/documentation/realm/latest/realm/ManualRecoveryHandler-class.html)callback to the `Configure.clientResetHandler`.\n\n ```dart // Lazily initialize `realm` so that it can be used in the callback // before the realm has been opened. late Realm realm; final config = Configuration.flexibleSync(currentUser, schema,     clientResetHandler: ManualRecoveryHandler((clientResetError) {   // You must close the Realm before attempting the client reset.   realm.close();   // Handle manual client reset here...   // Then perform the client reset.   clientResetError.resetRealm(); })); \n``` ← [Sync Data from Multiple Processes](https://mongodb.com/docs/realm/sdk/flutter/sync/sync-multiple-processes/ \"Previous Section\")[Set the Client Log Level - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/log-level/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/user-metadata/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # User Metadata - Flutter SDK On this page * [Read a User's Metadata](#read-a-user-s-metadata)\n* [Configure User Metadata](#configure-user-metadata)\n* [Update User Metadata](#update-user-metadata) ## Read a User's Metadata You can read the [user metadata](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) of a currently logged-in user through the [User](https://pub.dev/documentation/realm/latest/realm/User-class.html)object. You cannot edit user metadata through a `User` object. The `profile` property on the `User` object returns a[User.profile](https://pub.dev/documentation/realm/latest/realm/User/profile.html) object of a logged-in user. The following example shows how to get a user's email from the metatdata: `| final user = await app.logIn(                                       |\n| ------------------------------------------------------------------- |\n| Credentials.emailPassword(\"lisa@example.com\", \"myStr0ngPassw0rd\")); |\n| final emailAddress = user.profile.email;                            |\n| print(emailAddress); // prints 'lisa@example.com'                   | ` User metadata options vary depending on which provider you're using and[which metadata fields you enable.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-configure-user-metadata-on-the-backend) ## Warning ### User Metadata May Be Stale Atlas App Services fetches the most recent version of user metadata when a user logs in. If the user changes their email address or profile photo with a login provider, for example, those changes do not update in user metadata until the user logs in again. Because we cache credentials and enable you to bypass the login flow, user metadata may become stale unless you force the user to log in again. ## Configure User Metadata You can only read user metadata from the client app that you have configured on the App Services application. You can configure the [user metadata](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) you request from an authentication provider. You do this directly on the authentication provider's configuration. For more details on which metadata fields you can use, see the provider details: * OAuth 2.0 ([Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) & [Google)](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication)\n* [Custom JWT](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) You can change which metadata fields you have configured by [editing the provider's configuration.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-configure-user-metadata-on-the-backend) ## Update User Metadata User metadata that you access through the authentication provider is read-only data. You cannot update or edit user metadata that comes from this source. If you would like to give a user the option the update their metadata from within your client app, use [custom user data](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data), instead.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/delete-user/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete a User - Flutter SDK Call the [App.deleteUser()](https://pub.dev/documentation/realm/latest/realm/App/deleteUser.html)on a user object to delete the user's account from your App Services App. This deletes the account from the App on the server in addition to clearing local data. `| final currentUser = app.currentUser!; |\n| ------------------------------------- |\n| await app.deleteUser(currentUser);    | ` The user must sign up for a new account to use your App in the future. Even if the user signs up again with the same credentials, App Services creates a new user account with a new User ID. ← [User Metadata - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/user-metadata/ \"Previous Section\")[Get the User Access Token - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/access-token/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-subscriptions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Sync Subscriptions - Flutter SDK On this page * [Before You Begin](#before-you-begin)\n* [Align Subscriptions with Backend App](#align-subscriptions-with-backend-app)\n* [Manage Your Subscriptions](#manage-your-subscriptions)\n* [Get Subscriptions](#get-subscriptions)\n* [Add a Query to the Set of Subscriptions](#add-a-query-to-the-set-of-subscriptions)\n* [Update Subscriptions with a New Query](#update-subscriptions-with-a-new-query)\n* [Remove Subscriptions](#remove-subscriptions)\n* [Wait for Subscription Changes to Sync](#wait-for-subscription-changes-to-sync)\n* [Subscription State](#subscription-state)\n* [Flexible Sync RQL Limitations](#flexible-sync-rql-limitations)\n* [Unsupported Query Operators in Flexible Sync](#unsupported-query-operators-in-flexible-sync)\n* [List Queries](#list-queries)\n* [Embedded or Linked Objects](#embedded-or-linked-objects) Atlas Device Sync with Flexible Sync uses subscriptions and permissions to determine which data to sync between Atlas and your app. You can add, update, and remove query subscriptions to determine which data syncs to the client device. ## Note ### Flexible Sync Prerequisites Enabling Flexible Sync in your App requires a non-sharded Atlas cluster running [MongoDB 5.0 or greater](https://www.mongodb.com/docs/manual/release-notes/) ## Before You Begin To use Flexible Sync in a Flutter application: 1. [Configure Flexible Sync on the Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n2. [Initialize the app client](https://mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/#std-label-flutter-connect-to-backend)\n3. [Authenticate a user](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-authenticate) in the client\n4. [Open the synced realm](https://mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/#std-label-flutter-open-synced-realm) in the client ## Align Subscriptions with Backend App Your client-side subscription queries must align with the Device Sync configuration in your backend App Services App. You subscription queries can either: * **Query all objects of a type.**Create the query using [Realm.all().](https://pub.dev/documentation/realm/latest/realm/Realm/all.html)\n* **Query objects that match backend App's queryable fields.**Create the query using [Realm.query()](https://pub.dev/documentation/realm/latest/realm/Realm/query.html)and a Realm Query Language query that includes one or more queryable fields. The Realm SDK throws an error if you try to create a subscription using fields that are not queryable.  \n   * To learn more about configuring queryable fields, refer to [Queryable Fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields) in the App Services documentation.  \n   * To learn more about the limitations of using Realm Query Language with Flexible Sync, refer to the [Flexible Sync RQL Limitations](#std-label-flutter-flexible-sync-rql-limitations) section. ## Manage Your Subscriptions When configuring Flexible Sync on the backend, you specify which fields your client application can query. In the client application, use the[Realm.subscriptions](https://pub.dev/documentation/realm/latest/realm/Realm/subscriptions.html) property to manage a set of subscriptions to specific queries on queryable fields.\n\n * Get a list of all subscriptions\n* Add subscriptions\n* Check subscription state\n* Update a subscription with a new query\n* Remove subscriptions When the data matches the subscription, and the authenticated user has the appropriate permissions, Device Sync syncs the backend data with the client app. Subscription sets persist across sessions even if you no longer include the subscription in your code. Subscription information is stored in the synced realm's database file. You must explicitly remove a subscription for it to stop attempting to sync matching data. You can specify a string name for your subscription. If you do not give your subscription a name, the name is set to `null`. When you create a subscription, Realm looks for data matching a query on a specific object type. In your Flexible Sync subscriptions, you can have subscriptions on several different object types or several queries on the same object type. ### Get Subscriptions When using Flexible Sync, you can access a[SubscriptionSet](https://pub.dev/documentation/realm/latest/realm/SubscriptionSet-class.html), a collection of subscriptions, through the `Realm.subscriptions` property. You can use this subscriptions set to add queries to this list of subscriptions and update existing subscriptions, as shown in the examples below. `| final subscriptions = realm.subscriptions; |\n| ------------------------------------------ | ` ### Add a Query to the Set of Subscriptions You must perform all mutations on the subscriptions set within an update block. To create an update block, call [SubscriptionSet.update().](https://pub.dev/documentation/realm/latest/realm/SubscriptionSet/update.html) The update block callback function includes a [MutableSubscriptionSet()](https://pub.dev/documentation/realm/latest/realm/MutableSubscriptionSet-class.html) object as an argument. You can modify your method on the `SubscriptionSet` to add a query to the subscription. ## Important Flexible Sync does not support all the operators available in Realm Query Language. See [Flexible Sync RQL Limitations](#std-label-flutter-flexible-sync-rql-limitations) for details. The `MutableSubscriptionSet.add()` method takes three arguments: * `RealmResults query`: Required. A `RealmResults` object that you can create using the[Realm Query Language query.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql)\n* `String name`: Optional. Name for the subscription that you can refer to.\n* `bool update`: Optional. When true, adding a subscription with an existing name replaces the existing query with the new query. Only use with named subscriptions. ## Note ### Duplicate Subscriptions If you add a duplicate **unnamed** subscription with the same query, Realm automatically removes it; adding an identical**named** subscription is a [no-op](https://en.wikipedia.org/wiki/NOP%5F%28code%29). Therefore, in both cases, duplicate subscriptions are ignored. You can add a single query, or batch multiple queries within a `SubscriptionSet.update`block. Performing query updates is an expensive operation on the server. We strongly advise designing your application to minimize subscription updates. You can do this by creating all subscriptions in a single update block the first time the user launches the app and batching any follow-up changes to the subscription set. In the example below, we subscribe to two queries. ```dart final planeQuery = realm.all<Plane>(); final longTrainQuery = realm.query<Train>(\"numCars >= 5\"); realm.subscriptions.update((MutableSubscriptionSet mutableSubscriptions) {   mutableSubscriptions.add(planeQuery, name: \"planes\");   mutableSubscriptions.add(longTrainQuery,       name: 'long-trains', update: true); }); await realm.subscriptions.waitForSynchronization(); \n``` ### Update Subscriptions with a New Query You can update a named subscription with a new query. To update a subscription's query, open an update block with `SubscriptionSet.update()`. In the callback function of the update block, pass the following arguments to `MutableSubscriptionSet.add()`: * The new query\n* The name of the subscription that you want to update\n* `update: true`\n\n In the following example, long trains are re-defined to be any trains that have more than 10 cars. ```dart final longerTrainQuery = realm.query<Train>(\"numCars > 10\"); realm.subscriptions.update((MutableSubscriptionSet mutableSubscriptions) {   mutableSubscriptions.add(longerTrainQuery,       name: 'long-trains', update: true); }); \n``` ### Remove Subscriptions To remove subscriptions from the subscription set, you can: * Remove a single subscription with the given query\n* Remove a single subscription with the given name\n* Remove a single subscription with the subscription reference\n* Remove all subscriptions for a Realm object type\n* Remove all subscriptions When you remove a subscription query, the server also removes synced data from the client device. #### Remove a Subscription by Query Within an update block, you can remove a specific subscription by query. Open an update block with `SubscriptionSet.update()`. Pass the `Subscription` to[MutableSubscriptionSet.removeByQuery().](https://pub.dev/documentation/realm/latest/realm/MutableSubscriptionSet/removeByQuery.html) In the following example, the subscription for all `Plane` objects is removed. ```dart realm.subscriptions.update((MutableSubscriptionSet mutableSubscriptions) {   mutableSubscriptions.removeByQuery(realm.all<Plane>()); }); \n``` #### Remove a Subscription by Name Within an update block, you can remove a specific subscription by name. Pass the name to[MutableSubscriptionSet.removeByName()](https://pub.dev/documentation/realm/latest/realm/MutableSubscriptionSet/removeByName.html) ```dart realm.subscriptions.update((MutableSubscriptionSet mutableSubscriptions) {   mutableSubscriptions.removeByName('long-trains'); }); \n``` #### Remove a Subscription by Reference You can remove a subscription if you have a reference to its [Subscription](https://pub.dev/documentation/realm/latest/realm/Subscription-class.html) object. Within a subscription update block, pass the `Subscription` reference to[MutableSubscriptionSet.remove().](https://pub.dev/documentation/realm/latest/realm/MutableSubscriptionSet/remove.html) ```dart final sub = realm.subscriptions[0]; realm.subscriptions.update((MutableSubscriptionSet mutableSubscriptions) {   mutableSubscriptions.remove(sub); }); \n``` #### Remove All Subscriptions for an Object Type You can remove all subscriptions for a given Realm object type. Within a subscription update block, call[MutableSubscriptionSet.removeByType().](https://pub.dev/documentation/realm/latest/realm/MutableSubscriptionSet/removeByType.html) ```dart realm.subscriptions.update((MutableSubscriptionSet mutableSubscriptions) {   mutableSubscriptions.removeByType<Train>(); }); \n``` #### Remove All Subscriptions Within a subscription update block, you can remove all unnamed subscriptions from the subscriptions set with [MutableSubscriptionSet.clear().](https://pub.dev/documentation/realm/latest/realm/MutableSubscriptionSet/clear.html) ```dart realm.subscriptions.update((MutableSubscriptionSet mutableSubscriptions) {   mutableSubscriptions.clear(); }); \n``` ### Wait for Subscription Changes to Sync Mutating the subscription set within an update block is only one part of changing a subscription. After the local subscription change, the realm synchronizes with the server to resolve any updates to the data due to the subscription change. This includes adding or removing data from the synced realm. Use [Realm.subscriptions.waitForSynchronization()](https://pub.dev/documentation/realm/latest/realm/SubscriptionSet/waitForSynchronization.html)to wait for the server to acknowledge this set of subscriptions. If the server rejects the change, and an exception is thrown. An exception may occur if:\n\n ```dart await realm.subscriptions.waitForSynchronization(); \n``` ### Subscription State Use the [Realm.subscriptions.state](https://pub.dev/documentation/realm/latest/realm/SubscriptionSet/state.html)property to read the current state of the subscription set. The `superseded` state is a [SubscriptionSetState](https://pub.dev/documentation/realm/latest/realm/SubscriptionSetState.html) that can occur when another thread updates a subscription on a different instance of the subscription set. If the state becomes `superseded`, you must obtain a new instance of the subscription set before you can update it. ## Note ### Subscription State \"Complete\" The subscription set state \"complete\" does not mean \"sync is done\" or \"all documents have been synced\". \"Complete\" means the following two things have happened: * The subscription has become the active subscription set that is currently being synchronized with the server.\n* The documents that matched the subscription _at the time the subscription was sent to the server_ are now on the local device. Note that this does not necessarily include all documents that currently match the subscription. The Realm SDK does not provide a way to check whether all documents that match a subscription have synced to the device. ## Flexible Sync RQL Limitations Flexible Sync has some limitations when using RQL operators. When you write the [query subscription](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-flexible-sync-query-subscription)that determines which data to sync, the server does not support these query operators. However, you can still use the full range of RQL features to query the synced data set in the client application. ### Unsupported Query Operators in Flexible Sync | Operator Type       | Unsupported Operators          |\n| ------------------- | ------------------------------ |\n| Aggregate Operators | @avg, @count, @max, @min, @sum |\n| Query Suffixes      | DISTINCT, SORT, LIMIT          | Case insensitive queries (`[c]`) cannot use indexes effectively. As a result, case insensitive queries are not recommended, since they could lead to performance problems. Flexible Sync only supports `@count` for array fields. ### List Queries Flexible Sync supports querying lists using the `IN` operator. You can query a list of constants to see if it contains the value of a queryable field: ```javascript // Query a constant list for a queryable field value \"priority IN { 1, 2, 3 }\" \n``` If a queryable field has an array value, you can query to see if it contains a constant value: ```javascript // Query an array-valued queryable field for a constant value \"'comedy' IN genres\" \n``` ## Warning You **cannot** compare two lists with each other in a Flexible Sync query. Note that this is valid Realm Query Language syntax outside of Flexible Sync queries. ```javascript // Invalid Flexible Sync query. Do not do this! \"{'comedy', 'horror', 'suspense'} IN genres\" // Another invalid Flexible Sync query. Do not do this! \"ANY {'comedy', 'horror', 'suspense'} != ANY genres\" \n``` ### Embedded or Linked Objects Flexible Sync does not support querying on properties in Embedded Objects or links. For example, `obj1.field == \"foo\"`. ← [Open a Synced Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/ \"Previous Section\")[Write Data to a Synced Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/sync/write-to-synced-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/multiple-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Work with Multiple Users - Flutter SDK On this page * [User Account States](#user-account-states)\n* [Add a New User to the Device](#add-a-new-user-to-the-device)\n* [List All Users on the Device](#list-all-users-on-the-device)\n* [Remove a User from the Device](#remove-a-user-from-the-device)\n* [Change the Active User](#change-the-active-user) The Realm SDK allows multiple [users](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) to be logged in to an app simultaneously on a given device. Atlas App Services client applications run in the context of a single active user even if multiple users are logged in simultaneously. You can quickly switch between authenticated users without requiring them to log in again. ## Important **Any logged in user may become the active user without re-authenticating.**Depending on your app, this may be a security vulnerability. For example, a user on a shared device may switch to a coworker's logged in account without providing their credentials or requiring their explicit permission. If your application requires stricter authentication, avoid switching between users and prefer to explicitly log the active user out before authenticating another user. ## User Account States When a user first logs in through a Realm SDK on a given device or browser, the SDK saves the user's information and keeps track of the user's state on the device. The user's data remains on the device, even if they log out, unless you actively [remove the user.](#std-label-flutter-remove-user) The following states describe an on-device user at any given time: * **Authenticated:** any user that has logged in on the device and has not logged out or had its session revoked.  \n   * **Active**: a single authenticated user that is currently using the app on a given device. The SDK associates this user with outgoing requests and App Services evaluates data access permissions and runs functions in this user's context. See [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) for more information.  \n   * **Inactive**: all authenticated users that are not the current active user. You can [switch the active user](#std-label-flutter-change-active-user) to a currently inactive user at any time.\n* **Logged Out:** any user that authenticated on the device but has since logged out or had their session revoked. The following diagram shows how users within an App Services client app transition between states when certain events occur: ![A diagram the outlines the different states a user can be in: logged out, logged in and active, & logged in and inactive.](https://mongodb.com/docs/realm/images/multi-user.png) ### Add a New User to the Device The Realm SDK automatically adds users to a device when they log in for the first time on that device. When a user logs in, they immediately become the application's [active user.](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) `| final emailPwCredentials =                                         |\n| ------------------------------------------------------------------ |\n| Credentials.emailPassword(\"lisa@example.com\", \"myStr0ngPassw0rd\"); |\n| await app.logIn(emailPwCredentials);                               | ` For more information on logging users in for the first time, refer to[Register a New User Account.](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-register) ### List All Users on the Device\n\n ```dart final users = app.users; \n``` ### Remove a User from the Device You can remove all information about a user from the device and automatically log the user out by passing the `User` object to[app.removeUser():](https://pub.dev/documentation/realm/latest/realm/App/removeUser.html) ```dart await app.removeUser(user); \n``` ### Change the Active User You can switch an app's [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) to another logged in user by calling[app.switchUser()](https://pub.dev/documentation/realm/latest/realm/App/switchUser.html) on the `User` object you are switching to: ```dart app.switchUser(otherUser); \n``` ← [Email/Password Users - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/email-password-users/ \"Previous Section\")[Link User Identities - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/link-user-identities/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/link-user-identities/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Link User Identities - Flutter SDK On this page * [Example](#example) Atlas App Services provides [multiple authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)to log users into your app. Each provider creates a unique user identity. App Services lets you merge multiple credentials into one user identity. You can link identities by passing the [Credentials](https://pub.dev/documentation/realm/latest/realm/Credentials-class.html)that you want to link to [User.linkCredentials().](https://pub.dev/documentation/realm/latest/realm/User/linkCredentials.html) `| final linkedCredentialUser =                       |\n| -------------------------------------------------- |\n| await user.linkCredentials(additionalCredentials); | ` ## Example Consider an application that offers [anonymous login](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication). This allows users to explore the app without registering. If users like the application, they create permanent accounts. They sign up with SSO or email/password authentication. By default, this creates a new `User` object. The app must link the new identity with the original User. We must first register the new [email/password](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) user before linking. ```dart // on app start without registration final anonymousUser = await app.logIn(Credentials.anonymous()); // ... user interacts with app //... user decides to sign up for app with email/password auth final authProvider = EmailPasswordAuthProvider(app); await authProvider.registerUser(USERNAME, PASSWORD); // link email/password credentials to anonymous user's credentials final linkedCredentialUser = await anonymousUser     .linkCredentials(Credentials.emailPassword(USERNAME, PASSWORD)); \n``` ← [Work with Multiple Users - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/multiple-users/ \"Previous Section\")[Custom User Data - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/custom-user-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/custom-user-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Custom User Data - Flutter SDK On this page * [Before You Begin](#before-you-begin)\n* [Read a User's Custom User Data](#read-a-user-s-custom-user-data)\n* [Write Custom User Data with an Atlas Functions](#write-custom-user-data-with-an-atlas-functions) You can store arbitrary custom data about your users with Atlas App Services. For example, you might store a user's preferred language, date of birth, or local timezone. Before writing and reading this data, you must enable custom user data in the backend. To learn more, see [Enable Custom User Data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ## Important Currently you can only **read** custom user data with the Flutter SDK. In a future update to the SDK, you will be able to write custom user data from the SDK as well. You can create, update, or delete custom user data using one of the other Realm SDKs, with Atlas Functions, or by directly querying Atlas. ## Before You Begin To use custom user data, you must first enable custom user data in App Services: 1. [Create an App.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n2. [Enable custom user data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-enable-custom-user-data-procedure) ## Read a User's Custom User Data You retrieve custom user data in the [User.customData](https://pub.dev/documentation/realm/latest/realm/User/customData.html)property of a logged in user: `| final customUserData = user.customData; |\n| --------------------------------------- | ` App Services **does not dynamically update** the value of the`User.customData` immediately when underlying data changes. Instead, App Services fetches the most recent version of custom user data whenever a user refreshes their [access token](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) or when you explicitly call [User.refreshCustomData()](https://pub.dev/documentation/realm/latest/realm/User/refreshCustomData.html), which ensures your app has the latest custom user data. ```dart // refreshCustomData() returns the updated custom data object final updatedCustomData = await user.refreshCustomData(); // Now when you access User.customData it's the value // returned from User.refreshCustomData() \n``` ## Write Custom User Data with an Atlas Functions You can write to custom user data with an Atlas Function. Atlas Functions are server-side JavaScript functions that are built into your backend App. You can call an Atlas Function directly from the Realm Flutter SDK. It is not possible to write to custom user data directly from the Realm Flutter SDK. To learn more about Atlas Functions, refer to the following documentation: * [Call an Atlas Function](https://mongodb.com/docs/realm/sdk/flutter/app-services/call-function/#std-label-flutter-call-function)\n* [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) in the App Services documentation. There is no single pattern for adding custom user data from an Atlas Function. You should write your Function or Functions to suite your application's use case. In this example, the Atlas Function takes an object passed by the client add adds it to the custom user data collection in Atlas. The Function creates the custom user data if it doesn't already exist and replaces all data in it if it does exist. writeCustomUserData.js - Atlas Function running on server (JavaScript) ```js exports = async function writeCustomUserData(newCustomUserData) {   const userId = context.user.id;   const customUserDataCollection = context.services     .get(\"mongodb-atlas\")     .db(\"custom-user-data-database\")     .collection(\"custom-user-data\");   const filter = { userId };\n\n   const update = { $set: newCustomUserData };   // Insert document if it doesn't already exist   const options = { upsert: true };   const res = await customUserDataCollection.updateOne(filter, update, options);   return res; }; \n``` The Realm SDK code to call this Function: Realm Flutter SDK client code (Dart) ```dart final user = app.currentUser!; final updatedTimestamp = DateTime.now().millisecondsSinceEpoch; final updatedCustomUserData = {   \"userId\": user.id,   \"favoriteFood\": \"pizza\",   \"lastUpdated\": updatedTimestamp }; final functionResponse = await user.functions     .call(\"writeCustomUserData\", [updatedCustomUserData]); // Contains the `updatedCustomUserData` object just added // in the above Atlas Function call final customUserData = await user.refreshCustomData(); \n``` ← [Link User Identities - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/link-user-identities/ \"Previous Section\")[User Metadata - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/user-metadata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/email-password-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Email/Password Users - Flutter SDK On this page * [Before You Begin](#before-you-begin)\n* [Register a User](#register-a-user)\n* [Log in a User](#log-in-a-user)\n* [Confirm a New User's Email Address](#confirm-a-new-user-s-email-address)\n* [Custom Confirmation Function](#custom-confirmation-function)\n* [Send a Confirmation Email](#send-a-confirmation-email)\n* [Retry User Confirmation](#retry-user-confirmation)\n* [Retry a User Confirmation Function](#retry-a-user-confirmation-function)\n* [Resend a User Confirmation Email](#resend-a-user-confirmation-email)\n* [Reset a User's Password](#reset-a-user-s-password)\n* [Call a Reset Function](#call-a-reset-function)\n* [Send Password Reset Email](#send-password-reset-email) With Atlas App Services's email/password authentication provider, you can register a new account, confirm an email address, and reset a user's password from client code. ## Warning ### Version 0.5.0 Breaking Change The Realm Flutter SDK version 0.5.0 includes a breaking change to email/password authentication. The change fixes a bug where the unicode null character `\\u0000`was appended to the end of passwords in previous versions of the SDK. As a result, once you upgrade your application to use version >0.5.0, users must either reset their password or create a new account. Previous passwords will no longer work after updating to >0.5.0. ## Before You Begin 1. [Create an App Services App.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n2. Before you begin writing client code, you should understand the different email/password authentication flows that App Services provides, and configure the backend implementation for your application. App Services has a variety of ways to confirm email/password user identities and reset user passwords. Learn more about, enable, and configure App Services [email/password authentication.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) ## Register a User 1. Create a new [EmailPasswordAuthProvider](https://pub.dev/documentation/realm/latest/realm/EmailPasswordAuthProvider-class.html)instance with your `App` instance as the argument.\n2. Invoke [EmailPasswordAuthProvider.registerUser()](https://pub.dev/documentation/realm/latest/realm/EmailPasswordAuthProvider/registerUser.html), passing the user's email and password as arguments. `| EmailPasswordAuthProvider authProvider = EmailPasswordAuthProvider(app); |\n| ------------------------------------------------------------------------ |\n| await authProvider.registerUser(\"lisa@example.com\", \"myStr0ngPassw0rd\"); | ` ## Note Registering a user does not also log that user in. You must log the user in separately. ## Log in a User 1. Create an email/password credential by calling [Credentials.emailPassword()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.emailPassword.html) with the user's email and password.\n2. Pass the generated credential to `app.logIn`. ```dart final emailPwCredentials =     Credentials.emailPassword(\"lisa@example.com\", \"myStr0ngPassw0rd\"); await app.logIn(emailPwCredentials); \n``` ## Confirm a New User's Email Address Once you register a new email/password user, you must confirm the email address unless you configure App Services to [automatically confirm users.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-automatically-confirm-users) ### Custom Confirmation Function\n\n ### Send a Confirmation Email You only need to send a confirmation email if you [configure App Services to handle user confirmation with an email.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-confirmation-email) To confirm a newly-created user, pass a confirmation `token` and`tokenId` to [EmailPasswordAuthProvider.confirmUser()](https://pub.dev/documentation/realm/latest/realm/EmailPasswordAuthProvider/confirmUser.html). These are included in the email sent to the user's email address when they register. ```dart EmailPasswordAuthProvider authProvider = EmailPasswordAuthProvider(app); await authProvider.confirmUser(token, tokenId); \n``` ## Note ### Use Deep Links in Flutter Apps Mobile applications can handle email confirmation directly in the app by configuring [deep linking.](https://docs.flutter.dev/development/ui/navigation/deep-linking) ## Retry User Confirmation The SDK provides methods to resend user confirmation emails or retry custom confirmation. ### Retry a User Confirmation Function Use this user confirmation method if you've configured the App Services backend to retry a [custom user confirmation function.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-confirmation-function) To retry a confirmation function, pass the email used in sign up to[EmailPasswordAuthProvider.retryCustomConfirmationFunction().](https://pub.dev/documentation/realm/latest/realm/EmailPasswordAuthProvider/retryCustomConfirmationFunction.html) ```dart EmailPasswordAuthProvider authProvider = EmailPasswordAuthProvider(app); await authProvider.retryCustomConfirmationFunction(\"lisa@example.com\"); \n``` ### Resend a User Confirmation Email Use this user confirmation method if you've configured the App Services backend to resend a [confirmation email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-confirmation-email). Email/password URLs expire after 30 minutes, so users who do not visit within that period need new emails to confirm their accounts. To resend a confirmation email, pass the email used in sign up to[EmailPasswordAuthProvider.resendUserConfirmation().](https://pub.dev/documentation/realm/latest/realm/EmailPasswordAuthProvider/resendUserConfirmation.html) ```dart EmailPasswordAuthProvider authProvider = EmailPasswordAuthProvider(app); await authProvider.resendUserConfirmation(\"lisa@example.com\"); \n``` ## Reset a User's Password To reset a user password with App Services, you can either: * Run a password reset function\n* Send a password reset email To select which of these methods to use in your app,[configure the App Services authentication password reset behavior.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication-password-resets) ### Call a Reset Function If you have defined a backend function to reset the user's password, you pass the user's email address, the **new** password, and optional Map of custom arguments to[EmailPasswordAuthProvider.callResetPasswordFunction().](https://pub.dev/documentation/realm/latest/realm/EmailPasswordAuthProvider/callResetPasswordFunction.html) ```dart // The password reset function takes any number of // arguments. You might ask the user to provide answers to // security questions, for example, to verify the user // should be able to complete the password reset. final args = [   \"Snowball II\",   \"Springfield Elementary School\",   \"Bouvier\" ]; EmailPasswordAuthProvider authProvider = EmailPasswordAuthProvider(app); await authProvider.callResetPasswordFunction(     \"lisa@example.com\", \"n3wSt0ngP4ssw0rd!\",     functionArgs: args); \n``` ### Send Password Reset Email To send a password reset email, pass the email used in sign up to[EmailPasswordAuthProvider.resetPassword().](https://pub.dev/documentation/realm/latest/realm/EmailPasswordAuthProvider/resetPassword.html) ```dart\n\n await authProvider.resetPassword(\"lisa@example.com\"); \n``` Password reset emails contain two values, `token` and `tokenId`. To complete the password reset flow, you can reset the user's password on the client or by calling a custom function on the backend. To reset the password on the client, your UI should prompt the user to enter a new password and the `token` and `tokenId` values. You pass these values to[EmailPasswordAuthProvider.completeResetPassword().](https://pub.dev/documentation/realm/latest/realm/EmailPasswordAuthProvider/completeResetPassword.html) ```dart EmailPasswordAuthProvider authProvider = EmailPasswordAuthProvider(app); await authProvider.completeResetPassword(     \"n3wSt0ngP4ssw0rd!\", token, tokenId); \n``` ## Note To access the `token` and `tokenId` values sent in the password reset email, you can use a [custom password reset email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication-password-resets) containing a[deep link.](https://docs.flutter.dev/development/ui/navigation/deep-linking) ← [Authenticate Users - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/ \"Previous Section\")[Work with Multiple Users - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/multiple-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Connect to App Services - Flutter SDK On this page * [Before You Begin](#before-you-begin)\n* [Access the App Client](#access-the-app-client)\n* [Advanced Configuration](#advanced-configuration) The `App` client is the interface to the Atlas App Services backend. It provides access to the [authentication](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-authenticate) and Device Sync. ## Before You Begin 1. [Create an App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app) ## Access the App Client 1. [Find the App ID in the Realm UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id)\n2. Create an [AppConfiguration](https://pub.dev/documentation/realm/latest/realm/AppConfiguration-class.html)object with your App's App ID as the argument.\n3. Create an [App](https://pub.dev/documentation/realm/latest/realm/App-class.html)with the `AppConfiguration` you just created. You use this`App` instance to access App Services features throughout your client application. `| final appConfig = AppConfiguration(APP_ID); |\n| ------------------------------------------- |\n| final app = App(appConfig);                 | ` ## Note You can create multiple `App` instances to connect to multiple Apps or to the same App with different configurations. All`App` instances that share the same App ID use the same underlying connection. ## Advanced Configuration You can add optional arguments to the `AppConfiguration` for more granular control of your `App` client. You may want to add things like custom timeouts for connections or keys for local metadata encryption. To learn about the available configuration options, refer to the[AppConfiguration](https://pub.dev/documentation/realm/latest/realm/AppConfiguration-class.html) reference documentation. ```dart final appConfig = AppConfiguration(APP_ID,     defaultRequestTimeout: const Duration(seconds: 120),     localAppVersion: '2.0'     // ... see reference docs for all available configuration options     ); \n``` ## Note ### Connect Using Android 7 or Older The default HTTP client included with the Realm Flutter SDK does not work for apps running on Android 7 or older. To work around this, you must add a custom HTTP client to your `AppConfiguration`. To learn more, refer to [Connect to App Services Using Android 7 or Older.](https://mongodb.com/docs/realm/sdk/flutter/troubleshooting/#std-label-flutter-connect-old-android) ← [Application Services Overview - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/app-services/ \"Previous Section\")[Atlas GraphQL API](https://mongodb.com/docs/realm/sdk/flutter/app-services/graphql-api/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/app-services/call-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call an Atlas Function On this page * [Before You Begin](#before-you-begin)\n* [Call a Function](#call-a-function) You can call an **Atlas Function** from a client application using the Realm Flutter SDK. Functions are serverless JavaScript functions that let you define and execute server-side logic. These server-side Functions can run in the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your data in Atlas. For more information on configuring and writing Atlas Functions, refer to[Atlas Functions in the App Services documentation.](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) ## Before You Begin 1. In an App Services App, [define an Atlas Function.](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-define-a-function)\n2. In your client project, [initialize the App client.](https://mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/#std-label-flutter-connect-to-backend)\n3. Then, [authenticate a user](https://mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-authenticate) in your client project. ## Call a Function To call a Function, call [User.functions.call()](https://pub.dev/documentation/realm/latest/realm/FunctionsClient/call.html). Pass the Function name as the first argument and all arguments for the Function in a List as the second argument. To include objects as arguments to the Function, convert them to JSON first. You can do this using the [jsonEncode()](https://api.flutter.dev/flutter/dart-convert/jsonEncode.html)function included in the built-in `dart:convert` library. The Function returns a `dynamic` value containing [MongoDB Extended JSON (EJSON)](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/) deserialized to a native Dart object. `| final response = await user.functions.call(\"addition\", [1, 2]); |\n| --------------------------------------------------------------- |\n| // convert EJSON response to Dart number                        |\n| print(response);                                                |\n| final responseAsNum = num.tryParse(response[\"\\$numberDouble\"]); |\n| prints(responseAsNum); // prints 3                              | ` ## Example The above client code call this Atlas Function running in an App Services App. ```js // Add two numbers exports = function(num1, num2){    return num1 + num2; }; \n``` ← [Atlas GraphQL API](https://mongodb.com/docs/realm/sdk/flutter/app-services/graphql-api/ \"Previous Section\")[User Management - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/app-services/graphql-api/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Atlas GraphQL API On this page * [Prerequisites](#prerequisites)\n* [Set Up GraphQL Client](#set-up-graphql-client)\n* [Get Your App ID and GraphQL Endpoint](#get-your-app-id-and-graphql-endpoint)\n* [Install a GraphQL Client Package](#install-a-graphql-client-package)\n* [Import dependencies](#import-dependencies)\n* [Instantiate an App Services Client & Log In a User](#instantiate-an-app-services-client---log-in-a-user)\n* [Instantiate a GraphQL Client](#instantiate-a-graphql-client)\n* [Run Queries and Mutations](#run-queries-and-mutations)\n* [Run a Query](#run-a-query)\n* [Run a Mutation](#run-a-mutation) You can query your data in MongoDB Atlas from your client app using the Atlas GraphQL API and the Realm Flutter SDK. You can use any standard GraphQL client to query the Atlas GraphQL API. ## Prerequisites 1. [Create an App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n2. [Generate a schema and enable schema rules for the GraphQL API](https://www.mongodb.com/docs/atlas/app-services/graphql/expose-data/#std-label-graphql-expose-data)\n3. [Install the Realm Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/install/#std-label-flutter-install) ## Set Up GraphQL Client 1 ### Get Your App ID and GraphQL Endpoint Once you've completed the all the necessary actions in the Prerequisites section above, you must find your App ID and GraphQL endpoint. You can find both of these in your App's UI on Atlas: * To find your App ID, refer to [Find Your App ID.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id)\n* To find your GraphQL Endpoint in the Atlas UI, navigate to the GraphQL page. Near the top of the page, you can copy the GraphQL Endpoint link. 2 ### Install a GraphQL Client Package Install a standard GraphQL client. This page uses [graphql](https://pub.dev/packages/graphql), a lightweight GraphQL client that you can use in Dart standalone and Flutter apps. `| flutter pub add graphql |\n| ----------------------- | ` If you haven't already installed the Realm SDK, you can do so now as well. ```bash flutter pub add realm \n``` While the examples on this page use `graphql` to query the Atlas GraphQL API, there are other Dart and Flutter GraphQL packages that you could use. For example, the [graphql\\_flutter](https://pub.dev/packages/graphql%5Fflutter)package includes Flutter widget wrappers around the `graphql` library to provide a more idiomatic Flutter development experience and reduce the need for writing boilerplate code. 3 ### Import dependencies Import the `realm` and `graphql` packages into your Flutter app. This example also imports the `dart:async` library to help refresh the access token used in the GraphQL queries. ```dart import 'package:graphql/client.dart'; import 'package:realm/realm.dart'; import \"dart:async\"; // used to refresh access token \n``` 4 ### Instantiate an App Services Client & Log In a User Instantiate the App Services client to connect to the backend. You must log a user in to the `App` client to authenticate requests to the Atlas GraphQL API with the user's access token. This example also invokes `Timer.periodic()` to refresh the access token in the background. The access token doesn't refresh automatically. ```dart final app = App(AppConfiguration(YOUR_APP_ID)); await app.logIn(Credentials.anonymous()); // Refresh the user access token every 29 minutes, as the default expiration // time for an access token is 30 minutes. Timer.periodic(\n\n \n``` 5 ### Instantiate a GraphQL Client Now you can use the logged in user's [accessToken](https://pub.dev/documentation/realm/latest/realm/User/accessToken.html)property to authenticate with the Atlas GraphQL API. To query the GraphQL API as a user, use Bearer token authentication with the user's `accessToken`. Use the `graphql` package to create a GraphQL client to run queries from. ```dart // Build GraphQL endpoint and client // In the `authLink`, retrieve the accessToken from the app's // currently logged in user on each request. // If there's no logged in user, pass an empty string as Bearer token, // causing the request to fail. final authLink = AuthLink(   getToken: () => 'Bearer ${app.currentUser?.accessToken ?? \"\"}', ); final link = authLink.concat(HttpLink(YOUR_GRAPHQL_URL)); final client = GraphQLClient(link: link, cache: GraphQLCache()); \n``` To learn more about the ways to authenticate requests to the Atlas GraphQL API, refer to [Authenticate GraphQL Requests](https://www.mongodb.com/docs/atlas/app-services/graphql/authenticate/#std-label-graphql-authentication) in the App Services documentation. ## Run Queries and Mutations Run queries and mutations with the Atlas GraphQL API from the client. To learn more about available operations, refer to the following App Services documentation: * [GraphQL Types, Resolvers, and Operators](https://www.mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-types-and-resolvers)\n* [Define a Custom Resolver](https://www.mongodb.com/docs/atlas/app-services/graphql/custom-resolvers/#std-label-graphql-custom-resolvers) You can also find your entire schema and explore it with test operations in theGraphQL section of the App Services UI. ### Run a Query You can query the Atlas GraphQL API schema with query resolvers generated when you define your schema. To learn more about the generated queries and the inputs they accept, refer to[Query Resolvers](https://www.mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-query-resolvers) in the App Services documentation. ```dart final query = \"\"\" query {   plants(limit: 5) {     _id     name     color   } } \"\"\"; final queryOptions = QueryOptions(   document: gql(query), ); final queryRes = await client.query(queryOptions); \n``` ### Run a Mutation You can run mutation against the Atlas GraphQL API schema with mutation resolvers generated when you define your schema. To learn more about the generated mutations and the inputs they accept, refer to[Mutation Resolvers](https://www.mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-mutation-resolvers) in the App Services documentation. ```dart final mutation = \"\"\" mutation AddPlant( \\$_id: ObjectId!, \\$name: String!, \\$color: String) {   insertOnePlant(data: {     _id: \\$_id     name: \\$name     color: \\$color   }) {     _id     name     color   } } \"\"\"; final mutationOptions = MutationOptions(     document: gql(mutation),     variables: {       '_id': ObjectId().toString(),       'name': 'lily',       'color': 'white'     }); final mutationRes = await client.mutate(mutationOptions); \n``` ← [Connect to App Services - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/app-services/connect-to-app/ \"Previous Section\")[Call an Atlas Function](https://mongodb.com/docs/realm/sdk/flutter/app-services/call-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Files - Flutter SDK On this page * [Realm Files](#realm-files) A **realm** is the core data structure used to organize data in Realm Database. A realm is a collection of the objects that you use in your application, called Realm objects, as well as additional metadata that describe the objects. To learn how to define a Realm object, see[Define a Realm Object Schema.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-define-realm-object-schema) When you open a realm, you can include configuration that specifies additional details about how to configure the realm file. This includes things like: * Pass a file path or in-memory identifier to customize how the realm is stored on device\n* Provide a logged-in user and Sync details to use Sync with the realm\n* Specify the realm use only a subset of your app's classes\n* Whether and when to compact a realm to reduce its file size\n* Pass an encryption key to encrypt a realm\n* Provide a schema version or migration block when making schema changes ## Realm Files Realm Database stores a binary encoded version of every object and type in a realm in a single `.realm` file. The file is located at [a specific path](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-customize-default-configuration) that you can define when you open the realm. You can open, view, and edit the contents of these files with[Realm Studio.](https://mongodb.com/docs/realm/studio/#std-label-realm-studio) Realm Database also creates additional files for each realm. To learn more about these files, see [Realm Database Internals](https://mongodb.com/docs/realm/sdk/flutter/realm-database/database-internals/#std-label-flutter-realm-database-internals). Deleting these files has important implications. For more information about deleting `.realm` or auxiliary files, refer to[Delete a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/delete/#std-label-flutter-delete-realm) ← [Freeze Data - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/freeze/ \"Previous Section\")[Delete a Realm File - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Model Data - Flutter SDK On this page * [Realm Objects](#realm-objects)\n* [Realm Object Properties](#realm-object-properties)\n* [Updating a Realm Object Schema](#updating-a-realm-object-schema) Realm Database applications model data as objects composed of field-value pairs that each contain one or more supported data types. ## Realm Objects Realm objects are regular Dart classes that you can interact with like any other Dart class in your application. The Flutter SDK memory maps Realm objects directly to Realm Database. You can work with Realm objects as you would any other Dart object instance. Every Realm object conforms to a specific **object type**, which is a class that defines the properties and relationships for objects of that type. The SDK guarantees that all objects in a realm conform to the schema for their object type and validates objects whenever they are created, modified, or deleted. To learn more about defining Realm objects, refer to[Define a Realm Object Schema.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-define-realm-object-schema) ## Realm Object Properties When you define your Realm object model, you specify a set of of properties to include in the schema. You can define properties with the following characteristics: * Its data type\n* If it is optional or required\n* If it is a primary key\n* If it is indexed\n* If the property defines a relationship to another Realm object type To learn more about property options when defining Realm objects, refer to the following documentation: * [Data Types](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/data-types/#std-label-flutter-data-types)\n* [Relationships](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/#std-label-flutter-client-relationships)\n* [Property Annotations](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/property-annotations/#std-label-flutter-property-annotations) ## Updating a Realm Object Schema You can update your Realm Database schema over time as your application changes. The steps to update the schema and your data vary depending on the type of schema change. To learn more about the ways to update your schema, refer to [Update a Realm Object Schema.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/update-realm-object-schema/#std-label-flutter-update-realm-object-schema) ← [Realm Database - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/ \"Previous Section\")[Define a Realm Object Schema - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/freeze/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Freeze Data - Flutter SDK On this page * [Freeze a Realm](#freeze-a-realm)\n* [Freeze RealmResults](#freeze-realmresults)\n* [Freeze a RealmObject](#freeze-a-realmobject)\n* [Freeze a RealmList in a RealmObject](#freeze-a-realmlist-in-a-realmobject)\n* [Check if Data Is Frozen](#check-if-data-is-frozen) Freezing creates an immutable snapshot of data in a realm at the time of freezing. Frozen objects are not live and do not automatically update. You cannot write to frozen data. Once data is frozen, it cannot be unfrozen. You can freeze the following object types: * [Realm](#std-label-flutter-freeze-realm)\n* [RealmResults](#std-label-flutter-freeze-realmresults)\n* [RealmObject](#std-label-flutter-freeze-realmobject)\n* [RealmList](#std-label-flutter-freeze-realmlist) ## Freeze a Realm Create a frozen snapshot of an entire realm with [Realm.freeze()](https://pub.dev/documentation/realm/latest/realm/Realm/freeze.html). Once you finish working with the frozen realm, you must close it to prevent memory leaks.\n\n ` ## Freeze RealmResults Create a frozen snapshot of `RealmResults` with [RealmResults.freeze()](https://pub.dev/documentation/realm/latest/realm/RealmResults/freeze.html). Once you finish working with the frozen data, you must close the realm associated with it to prevent memory leaks. ```dart // Add data to the realm final maceWindu = Person(ObjectId(), \"Mace\", \"Windu\"); final jocastaNu = Person(ObjectId(), \"Jocasta\", \"Nu\"); realm.write(() => realm.addAll([maceWindu, jocastaNu])); // Get RealmResults and freeze data final people = realm.all<Person>(); final frozenPeople = people.freeze(); // Update data in the non-frozen realm final newLastName = \"Foo\"; realm.write(() {   people.forEach((Person person) {     person.lastName = newLastName;   }); }); // Data changes not in the frozen snapshot final frozenFooPeople =     frozenPeople.query(\"lastName == \\$0\", [newLastName]); print(frozenFooPeople.length); // prints 0 // You must also close the frozen realm associated // with the frozen RealmResults before exiting the process frozenPeople.realm.close(); \n``` ## Freeze a RealmObject Create a frozen snapshot of a `RealmObject` with [RealmObject.freeze()](https://pub.dev/documentation/realm/latest/realm/RealmObject/freeze.html). Once you finish working with the frozen data, you must close the realm associated with it to prevent memory leaks. ```dart final person = realm.query<Person>(     'firstName == \\$0 AND lastName == \\$1', [\"Count\", \"Dooku\"]).first; // Freeze RealmObject final frozenPerson = person.freeze(); // Change data in the unfrozen object. realm.write(() {   realm.delete(person); }); // Frozen person snapshot still exists even though data deleted // in the unfrozen realm print(frozenPerson.isValid); // prints true print(person.isValid); // prints false // You must also close the frozen realm associated // with the frozen RealmObject before exiting the process frozenPerson.realm.close(); \n``` ## Freeze a RealmList in a RealmObject Create a frozen snapshot of `RealmList` in a `RealmObject`with [RealmList.freeze()](https://pub.dev/documentation/realm/latest/realm/RealmList/freeze.html). Once you finish working with the frozen data, you must close the realm associated with it to prevent memory leaks. ```dart final firstPerson =     realm.query<Person>(\"firstName = \\$0\", [\"Yoda\"]).first; // Freeze RealmList in a RealmObject final firstPersonAttributesFrozen = firstPerson.attributes.freeze(); // Change data in the unfrozen realm final newAttribute = \"quick\"; realm.write(() {   // Append item to list   firstPerson.attributes.add(newAttribute); }); final index = firstPersonAttributesFrozen.indexOf(newAttribute); print(index); // prints -1 because cannot find new attribute // You must also close the frozen realm associated // with the frozen RealmList before exiting the process firstPersonAttributesFrozen.realm.close(); \n``` ## Check if Data Is Frozen Check if any of the freezable data types are frozen with the `isFrozen` property.`isFrozen` returns `true` if an object is frozen and `false` if it is a live object. ```dart // You can check if all freezable types are frozen // with the `isFrozen` property. final realm = Realm(config); print(realm.isFrozen); final people = realm.all<Person>(); print(people.isFrozen); final firstPerson =     realm.query<Person>(\"firstName = \\$0\", [\"Yoda\"]).first; print(firstPerson.isFrozen); final firstPersonAttributes = firstPerson.attributes; print(firstPersonAttributes.isFrozen); \n```\n\n",
  "https://www.mongodb.com/docs/realm/sdk/flutter/users/authenticate/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate Users - Flutter SDK On this page * [Before You Begin](#before-you-begin)\n* [Register a New User Account](#register-a-new-user-account)\n* [Log In](#log-in)\n* [Anonymous User](#anonymous-user)\n* [Email/Password User](#email-password-user)\n* [Custom JWT User](#custom-jwt-user)\n* [API Key User](#api-key-user)\n* [Custom Function User](#custom-function-user)\n* [Facebook User](#facebook-user)\n* [Google User](#google-user)\n* [Apple User](#apple-user)\n* [Log a User Out](#log-a-user-out)\n* [Retrieve Current User](#retrieve-current-user) Atlas App Services provides an API for authenticating users using any enabled authentication provider. Instantiate a [Credentials](https://pub.dev/documentation/realm/latest/realm/Credentials-class.html)object and pass it to [App.logIn()](https://pub.dev/documentation/realm/latest/realm/App/logIn.html)to authenticate and create a [User](https://pub.dev/documentation/realm/latest/realm/User-class.html)object for that user. Each authentication provider corresponds to a static constructor method used to instantiate `Credentials` objects for that authentication provider. ## Before You Begin 1. [Create an App Services App.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n2. Enable and configure one or more App Services [authentication providers.](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) ## Register a New User Account Realm registers accounts differently depending on the authentication provider: * You do not need to register anonymous users.\n* To register an email/password user, refer to [Email/Password User Registration.](https://mongodb.com/docs/realm/sdk/flutter/users/email-password-users/#std-label-flutter-manage-email-password-users-register)\n* If you are using Google, Facebook, Apple, or Custom JWT authentication, registration is handled by these third-party services. ## Log In You can authenticate users with [App.logIn().](https://pub.dev/documentation/realm/latest/realm/App/logIn.html) If successful, `app.logIn` returns a `User` object. ### Anonymous User The [anonymous authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)enables users to log in to your application with short-term accounts that store no persistent personal information. To log in with anonymous authentication, create an anonymous credential by calling[Credentials.anonymous()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.anonymous.html)and then pass the generated credential to`app.logIn`. `| final anonCredentials = Credentials.anonymous(); |\n| ------------------------------------------------ |\n| await app.logIn(anonCredentials);                | ` If you want more than one anonymous user, set `reuseCredentials: false`when creating additional anonymous credentials. ```dart final anonUser = await app.logIn(Credentials.anonymous()); final otherAnonUser =     await app.logIn(Credentials.anonymous(reuseCredentials: false)); \n``` ### Email/Password User\n\n ```dart final emailPwCredentials =     Credentials.emailPassword(\"lisa@example.com\", \"myStr0ngPassw0rd\"); await app.logIn(emailPwCredentials); \n``` To learn more about the complete flow of using App Services Email/Password authentication, refer to [Email/Password Users.](https://mongodb.com/docs/realm/sdk/flutter/users/email-password-users/#std-label-flutter-manage-email-password-users) ### Custom JWT User If you have configured the [Custom JWT authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication), you can log in using JWT credentials from an external authentication provider. To log in with Custom JWT authentication, create a JWT credential by calling[Credentials.jwt()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.jwt.html)on a JWT string. Then pass the credential to `app.logIn`. ```dart final token = await authenticateWithExternalSystem(); final jwtCredentials = Credentials.jwt(token); final currentUser = await app.logIn(jwtCredentials); \n``` ### API Key User If you have enabled [API Key authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication), you can log in using either a client or server API key. To log in with API key authentication, create an [ApiKey](https://pub.dev/documentation/realm/latest/realm/ApiKey-class.html)credential by calling [Credentials.apiKey()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.apiKey.html)on an API key string. Then pass the credential to `app.logIn()`. ```dart final apiKeyCredentials = Credentials.apiKey(myApiKey); final apiKeyUser = await app.logIn(apiKeyCredentials); \n``` To generate a server API key to use in your credentials, refer to the [Create a Server API Key documentation.](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication-server-api-key) To work with user API keys with the same permissions as the currently logged in user, use the [User.apiKeys](https://pub.dev/documentation/realm/latest/realm/User/apiKeys.html) client. You can create, fetch, delete, disable, and enable user API keys. ```dart // Create user API key final apiKey = await user.apiKeys.create(\"api-key-name\"); // Get existing user API key by ID // Returns `null` if no existing API key for the ID final refetchedApiKey = await user.apiKeys.fetch(apiKey.id); // Get all API keys for a user final apiKeys = await user.apiKeys.fetchAll(); // Disable API key await user.apiKeys.disable(apiKey.id); // Check if API key is enabled print(apiKey.isEnabled); // prints `false` // Enable API key await user.apiKeys.enable(apiKey.id); // Delete a user API key await user.apiKeys.delete(apiKey.id); \n``` ### Custom Function User If you have configured the[Custom Function authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication), you can log in using custom authentication logic handled by an Atlas Function. To log in with Custom Function authentication, pass a stringified JSON with your custom arguments to [Credentials.function()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.function.html). Then pass the credential to `app.logIn`. ```dart final credentials = {   \"username\": \"someUsername\", }; // payload must be a JSON-encoded string final payload = jsonEncode(credentials);\n\n final currentUser = await app.logIn(customCredentials); \n``` ### Facebook User If you have configured the [Facebook authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication), you can log in using an existing Facebook account. To log in with Facebook authentication, pass a Facebook access token to[Credentials.facebook()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.facebook.html). Then pass the credential to `app.logIn`. ```dart final facebookCredentials = Credentials.facebook(accessToken); final currentUser = await app.logIn(facebookCredentials); \n``` ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. ### Google User If you have configured the [Google authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication), you can log in using an existing Google account. To log in with a Google authentication code, pass a Google authentication code to[Credentials.googleAuthCode()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.googleAuthCode.html). Then pass the credential to `app.logIn`. ```dart final googleAuthCodeCredentials = Credentials.googleAuthCode(authCode); final currentUser = await app.logIn(googleAuthCodeCredentials); \n``` To log in with a Google ID token, pass a Google ID token to[Credentials.googleIdToken()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.googleIdToken.html). Then pass the credential to `app.logIn`. ```dart final googleIdTokenCredentials = Credentials.googleIdToken(idToken); final currentUser = await app.logIn(googleIdTokenCredentials); \n``` ### Apple User If you have configured the [Sign-in with Apple authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication), you can log in using an existing Apple account. To log in with Apple authentication, pass an Apple access token to[Credentials.apple()](https://pub.dev/documentation/realm/latest/realm/Credentials/Credentials.apple.html). Then pass the credential to `app.logIn`. ```dart final appleCredentials = Credentials.apple(idToken); final currentUser = await app.logIn(appleCredentials); \n``` ## Tip If you get a `Login failed` error saying that the `token contains an invalid number of segments`, verify that you're passing a UTF-8-encoded string version of the JWT. ## Log a User Out You can log out any user, regardless of the authentication provider used to log in, using [User.logOut()](https://pub.dev/documentation/realm/latest/realm/User/logOut.html). This method: * Deletes locally stored user credentials from the device\n* Immediately halts any synchronization to and from the user's realms Because logging out halts synchronization, you should only log out after all local Realm updates have uploaded to the server. ```dart await user.logOut(); \n``` ## Retrieve Current User Once you have an authenticated user, you can retrieve the User object with the[App.currentUser](https://pub.dev/documentation/realm/latest/realm/App/currentUser.html)property. The `currentUser` object is persisted in local storage, so even if the app shuts down after the initial authentication, you do not need to call`logIn` again (unless the user logged out). ```dart final user = app.currentUser; \n```\n\n",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Configure & Open a Realm - Flutter SDK On this page * [Open a Realm](#open-a-realm)\n* [Open a Local-Only Realm](#open-a-local-only-realm)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Open an In-Memory Realm](#open-an-in-memory-realm)\n* [Configure a Realm](#configure-a-realm)\n* [Open a Read-Only Realm](#open-a-read-only-realm)\n* [Set Custom FIFO Special Files](#set-custom-fifo-special-files)\n* [Add Initial Data to Realm](#add-initial-data-to-realm)\n* [Customize Default Configuration](#customize-default-configuration)\n* [Manage Schema Changes](#manage-schema-changes)\n* [Encrypt a Realm](#encrypt-a-realm)\n* [Compact a Realm](#compact-a-realm)\n* [Close a Realm](#close-a-realm)\n* [Copy Data into a New Realm](#copy-data-into-a-new-realm) ## Open a Realm Use the [Configuration](https://pub.dev/documentation/realm/latest/realm/Configuration-class.html) class to control the specifics of the realm you would like to open, including the schema. ### Open a Local-Only Realm To create a realm that only persists data locally, create a configuration with [Configuration.local()](https://pub.dev/documentation/realm/latest/realm/Realm-class.html). You must provide a list of schemas as an argument. Pass the `Configuration` to the [Realm](https://pub.dev/documentation/realm/latest/realm/Realm-class.html) constructor. `| final config = Configuration.local([Car.schema]); |\n| ------------------------------------------------- |\n| final realm = Realm(config);                      | ` You can now use that realm instance to work with objects in the database. ### Open a Synced Realm To open a realm that synchronizes data with Atlas using Device Sync, refer to [Open a Synced Realm.](https://mongodb.com/docs/realm/sdk/flutter/sync/open-synced-realm/#std-label-flutter-open-synced-realm) ### Open an In-Memory Realm To create a realm that runs in memory without being persisted, create your `Configuration` with [Configuration.inMemory()](https://pub.dev/documentation/realm/latest/realm/Configuration/inMemory.html). You must provide a list of schemas as an argument. In-memory realms **cannot** also be read-only. Pass the `Configuration` to the [Realm](https://pub.dev/documentation/realm/latest/realm/Realm-class.html) constructor. ```dart final config = Configuration.inMemory([Car.schema]); final realm = Realm(config); \n``` ## Configure a Realm You can add optional properties to the realm's `Configuration`. ### Open a Read-Only Realm You can open an existing realm in read-only mode. To open a read-only realm, add `readOnly: true` to your `Configuration` object. You can only open _existing_ realms in read-only mode. If you try to write to a read-only realm, it throws an error. ```dart final config = Configuration.local([Car.schema], isReadOnly: true); final realm = Realm(config); \n``` ### Set Custom FIFO Special Files\n\n This property is ignored if the directory for the realm file allows FIFO special files. ```dart final config = Configuration.local([Car.schema],     fifoFilesFallbackPath: \"./fifo_folder\"); final realm = Realm(config); \n``` ### Add Initial Data to Realm Use [initialDataCallback()](https://pub.dev/documentation/realm/latest/realm/InitialDataCallback.html) to invoke a callback function the first time that you open a realm. The function only executes the first time that the realm on the device. The realm instance passed to the callback function already has a write transaction open, so you do not need to wrap write operations in a `Realm.write()` transaction block.`initialDataCallback` can be useful for adding initial data to your application the first time that it is opened on a device. ```dart void dataCb(Realm realm) {   realm.add(Car(ObjectId(), 'Honda')); } final config =     Configuration.local([Car.schema], initialDataCallback: dataCb); final realm = Realm(config); Car honda = realm.all<Car>()[0]; \n``` ### Customize Default Configuration You can customize the default path where Realm stores database files and the default name given to database files. Use the static [Configuration.defaultRealmName](https://pub.dev/documentation/realm/latest/realm/Configuration/defaultRealmName.html)and [Configuration.defaultRealmPath](https://pub.dev/documentation/realm/latest/realm/Configuration/defaultRealmPath.html)to set default configuration for all realms opened within an application. ```dart Configuration.defaultRealmName = \"myRealmName.realm\"; final customDefaultRealmPath = path.join(     (await Directory.systemTemp.createTemp()).path,     Configuration.defaultRealmName); Configuration.defaultRealmPath = customDefaultRealmPath; // Configurations used in the application will use these values final config = Configuration.local([Car.schema]); // The path is your system's temp directory // with the file named 'myRealmName.realm' print(config.path); \n``` You can also check where realm stores the files by default using the static getter[Configuration.defaultStoragePath](https://pub.dev/documentation/realm/latest/realm/Configuration/defaultStoragePath.html). The value for this property varies depending on the platform you are using the SDK on and whether you are using the Dart or Flutter versions of Realm. Check the value of `Configuration.defaultStoragePath` in your application to see where realm files are stored in your environment. ```dart final storagePath = Configuration.defaultStoragePath; // See value in your application print(storagePath); \n``` ### Manage Schema Changes For more information about managing schema changes when configuring a realm, refer to the [Update a Realm Object Schema documentation.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/update-realm-object-schema/#std-label-flutter-update-realm-object-schema) ### Encrypt a Realm You can encrypt your local realm to ensure data security. For more information, see [Encrypt a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/encrypt/#std-label-flutter-encrypt) ### Compact a Realm You can reduce the local realm file size to improve performance and manage file size in a resource-constrained environment. For more information, refer to[Compact a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/compact/#std-label-flutter-compact) ## Close a Realm ## Copy Data into a New Realm To copy data from an existing realm to a new realm with different configuration options, pass the new configuration to[Realm.writeCopy().](https://pub.dev/documentation/realm/latest/realm/Realm/writeCopy.html) In the new realm's configuration, you _must_ specify the `path`. You **cannot** write to a path that already contains a file. Using `Realm.writeCopy()`, you can convert between the following[Configuration](https://pub.dev/documentation/realm/latest/realm/Configuration-class.html)types:\n\n You **cannot** convert from a `LocalConfiguration` or a `InMemoryConfiguration`to a `FlexibleSyncConfiguration`. Some additional considerations to keep in mind while using `Realm.writeCopy()`: 1. The destination file cannot already exist.\n2. Copying a realm is not allowed within a write transaction or during migration.\n3. When using Device Sync, you must sync all local changes with the server before the copy is written. This ensures that the file can be used as a starting point for a newly-installed application. The `Realm.writeCopy()` throws if there are pending uploads. The following example copies the data from a realm with a `InMemoryConfiguration`to a new realm with a `LocalConfiguration`. ```dart // Create in-memory realm and add data to it. // Note that even though the realm is in-memory, it still has a file path. // This is because in-memory realms still use memory-mapped files // for their operations; they just don't persist data across launches. final inMemoryRealm =     Realm(Configuration.inMemory([Person.schema], path: 'inMemory.realm')); inMemoryRealm.write(() {   inMemoryRealm.addAll([Person(\"Tanya\"), Person(\"Greg\"), Person(\"Portia\")]); }); // Copy contents of `inMemoryRealm` to a new realm with `localConfig`. // `localConfig` uses the default file path for local realms. final localConfig = Configuration.local([Person.schema]); inMemoryRealm.writeCopy(localConfig); // Close the realm you just copied when you're done working with it. inMemoryRealm.close(); // Open the local realm that the data from `inMemoryRealm` // was just copied to with `localConfig`. final localRealm = Realm(localConfig); // Person object for \"Tanya\" is in `localRealm` because // the data was copied over with `inMemoryRealm.writeCopy()`. final tanya = localRealm.find<Person>(\"Tanya\"); \n``` You can also [include a new encryption key](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/encrypt/#std-label-flutter-encrypt)in the copied realm's configuration or remove the encryption key from the new configuration. The following example copies data from an **unencrypted** realm with a `LocalConfiguration`to an **encrypted** realm with a `LocalConfiguration`. ```dart // Create unencrypted realm and add data to it. final unencryptedRealm = Realm(Configuration.local([Person.schema])); unencryptedRealm.write(() => unencryptedRealm.addAll([       Person(\"Daphne\"),       Person(\"Harper\"),       Person(\"Ethan\"),       Person(\"Cameron\")     ])); // Create encryption key and encrypted realm. final key = List<int>.generate(64, (i) => Random().nextInt(256)); final encryptedConfig = Configuration.local([Person.schema],     path: 'encrypted.realm', encryptionKey: key); // Copy the data from `unencryptedRealm` to a new realm with // the `encryptedConfig`. The data is encrypted as part of the copying. unencryptedRealm.writeCopy(encryptedConfig); // Close the realm you just copied when you're done working with it. unencryptedRealm.close(); // Open the new encrypted realm with `encryptedConfig`. final encryptedRealm = Realm(encryptedConfig); // Person object for \"Harper\" is in `localRealm` because // the data was copied over with `unencryptedRealm.writeCopy()`. final harper = encryptedRealm.find<Person>('Harper'); \n``` ← [Update a Realm Object Schema - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/update-realm-object-schema/ \"Previous Section\")[Read & Write Data - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/database-internals/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - Flutter SDK On this page * [Schemas](#schemas)\n* [Persistent or In-Memory Realms](#persistent-or-in-memory-realms)\n* [Queries](#queries)\n* [Encryption](#encryption)\n* [Indexes](#indexes) Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) You can also synchronize data between Realm Database and MongoDB Atlas using Atlas Device Sync. To learn more about using Realm Database with Device Sync, refer to [Device Sync - Flutter SDK.](https://mongodb.com/docs/realm/sdk/flutter/sync/#std-label-flutter-sync) Realm Database supports the following popular database features. ## Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. To learn more, refer to [Define a Schema.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-define-realm-object-schema) Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, do not require a migration. After you increment the local schema version, you can begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. To learn more about schema versioning and migrations, refer to [Update a Realm Object Schema.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/update-realm-object-schema/#std-label-flutter-update-schema) ## Persistent or In-Memory Realms You can use Realm Database to store data persistently on disk, or ephemerally in memory. Ephemeral realms can be useful in situations where you don't need to persist data between application instances, such as when a user works in a temporary workspace. To learn more, refer to [Configure and Open a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-open-close-realm) ## Queries You can query Realm Database using [Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql) To learn more about querying Realm Database, refer to [Read & Write Data.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/#std-label-flutter-read-write-data) ## Encryption Realm Database supports on-device realm encryption. Since memory mapping does not support encryption, encrypted realms use a simulated in-library form of memory mapping instead. To learn more, refer to [Encrypt a Realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/encrypt/#std-label-flutter-encrypt) ## Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time.\n\n ← [Quick Start - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/quick-start/ \"Previous Section\")[Model Data - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Read & Write Data - Flutter SDK On this page * [Read Operations](#read-operations)\n* [Find Object by Primary Key](#find-object-by-primary-key)\n* [Query All Objects](#query-all-objects)\n* [Query List of RealmObjects](#query-list-of-realmobjects)\n* [Filter Results](#filter-results)\n* [Sort Results](#sort-results)\n* [Write Operations](#write-operations)\n* [Create Objects](#create-objects)\n* [Update Objects](#update-objects)\n* [Delete Objects](#delete-objects)\n* [Background Writes](#background-writes) This page explains the Realm SDK methods that you can use to create, read, update, and delete data in a realm. ## Example ### About the Examples on This Page The examples on this page use two Realm object types, `Person` and `Team`. `| @RealmModel()            |\n| ------------------------ |\n| class _Person {          |\n| @PrimaryKey()            |\n| late ObjectId id;        |\n| late String name;        |\n| }                        |\n| @RealmModel()            |\n| class _Team {            |\n| @PrimaryKey()            |\n| late ObjectId id;        |\n| late String name;        |\n| late List<_Person> crew; |\n| }                        | ` ## Read Operations ### Find Object by Primary Key Find an object by its primary key with [Realm.find().](https://pub.dev/documentation/realm/latest/realm/Realm/find.html) ```dart final luke = realm.find<Person>(lukePrimaryKey); \n``` ### Query All Objects Retrieve a collection of all objects of a data model in the realm with the[Realm.all()](https://pub.dev/documentation/realm/latest/realm/Realm/all.html) method. ```dart final people = realm.all<Person>(); \n``` ### Query List of RealmObjects You can query any list of [RealmObjects](https://pub.dev/documentation/realm/latest/realm/RealmObject-mixin.html). For more information on querying, refer to [Filter Results.](#std-label-flutter-filter-results) ```dart final config = Configuration.local([Person.schema, Team.schema]); final realm = Realm(config); final heroes = Team(ObjectId(), 'Millenium Falcon Crew', crew: [   Person(ObjectId(), 'Luke'),   Person(ObjectId(), 'Leia'),   Person(ObjectId(), 'Han'),   Person(ObjectId(), 'Chewbacca') ]); realm.write(() => realm.add(heroes)); final lukeAndLeia = heroes.crew.query('name BEGINSWITH \\$0', ['L']); \n``` ### Filter Results Filter a `RealmList` to retrieve a specific segment of objects with the [Realm.query()](https://pub.dev/documentation/realm/latest/realm/Realm/query.html) method. In the `query()` method's argument, use Realm Query Language to perform filtering. Realm Query Language is a string-based query language that you can use to retrieve objects from a realm. For more information on constructing queries, refer to the[Realm Query Language reference documentation.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql) ```dart final team =     realm.query<Team>('name == \\$0', ['Millennium Falcon Crew']).first;\n\n \n``` ### Sort Results Sort the results using the [Realm Query Language SORT() operator](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-sort-distinct-limit) in the `query()` method's argument. ```dart realm.write(() {   realm.addAll([     Person(ObjectId(), 'Luke'),     Person(ObjectId(), 'Leia'),     Person(ObjectId(), 'Han'),     Person(ObjectId(), 'Chewbacca')   ]); }); final alphabetizedPeople =     realm.query<Person>('TRUEPREDICATE SORT(name ASC)'); for (var person in alphabetizedPeople) {   print(person.name); } // prints 'Chewbacca', 'Han', 'Leia', 'Luke' \n``` ## Write Operations Once you've opened a realm, you can create objects within it using a[Realm.write()](https://pub.dev/documentation/realm/latest/realm/Realm/write.html) transaction block. All operations within a write transaction are [atomic](https://en.wikipedia.org/wiki/Atomicity%5F%28database%5Fsystems%29). If an operation in the write transaction fails, the whole transaction fails, Realm throws an error, and no changes from the transaction block are applied to the realm. ```dart realm.write((){   // ...write data to realm }); \n``` You can also return values from the write transaction callback function. ```dart final yoda = realm.write<Person>(() {   return realm.add(Person(ObjectId(), 'Yoda')); }); \n``` ## Warning ### Write RealmObjects to One Realm You can only write `RealmObjects` to a single realm. If you already wrote a `RealmObject` to one realm, the SDK throws a `RealmException` if you try to write it to another realm. ### Create Objects #### Create One Object To add an object to a realm, pass an instance of a Realm object class to the realm in a write transaction block with[Realm.add().](https://pub.dev/documentation/realm/latest/realm/Realm/add.html) ```dart realm.write(() {   realm.add(Person(ObjectId(), 'Lando')); }); \n``` #### Create Multiple Objects To add multiple objects to a realm, pass a list of multiple objects to [Realm.addAll()](https://pub.dev/documentation/realm/latest/realm/Realm/addAll.html) inside a write transaction block. ```dart realm.write(() {   realm.addAll([     Person(ObjectId(), 'Figrin D\\'an'),     Person(ObjectId(), 'Greedo'),     Person(ObjectId(), 'Toro')   ]); }); \n``` ### Update Objects #### Update Object Properties To modify an object's properties, update the properties in a write transaction block. ```dart realm.write(() {   spaceshipTeam.name = 'Galactic Republic Scout Team';   spaceshipTeam.crew       .addAll([Person(ObjectId(), 'Luke'), Person(ObjectId(), 'Leia')]); }); \n``` #### Upsert Objects To upsert an object, call [Realm.add()](https://pub.dev/documentation/realm/latest/realm/Realm/add.html)with the optional `update` flag set to `true` inside a transaction block. The operation inserts a new object with the given primary key if an object with that primary key does not exist. If there's already an object with that primary key, the operation updates the existing object for that primary key. ```dart final id = ObjectId(); // Add Anakin Skywalker to the realm with primary key `id` final anakin = Person(   id,   \"Anakin Skywalker\", ); realm.write(() {   realm.add<Person>(anakin); }); // Overwrite the 'Anakin' Person object // with a new 'Darth Vader' object final darthVader = Person(id, 'Darth Vader'); realm.write(() {   realm.add<Person>(darthVader, update: true); }); \n``` ### Delete Objects #### Delete a Single Object\n\n ```dart realm.write(() {   realm.delete(obiWan); }); \n``` #### Delete Multiple Objects Delete multiple objects from a realm the [Realm.deleteMany()](https://pub.dev/documentation/realm/latest/realm/Realm/deleteMany.html) in a write transaction block. ```dart realm.write(() {   realm.deleteMany([obiWan, quiGon]); }); \n``` #### Delete All Objects of a Type Delete all objects of a type in a realm with [Realm.deleteAll()](https://pub.dev/documentation/realm/latest/realm/Realm/deleteAll.html)in a write transaction block. ```dart realm.write(() {   realm.deleteAll<Person>(); }); \n``` ## Background Writes You can add, modify, or delete objects asynchronously using[Realm.writeAsync().](https://pub.dev/documentation/realm/latest/realm/Realm/writeAsync.html) When you use `Realm.writeAsync()` to perform write operations, waiting to obtain the write lock and committing a transaction occur in the background. Only the write itself occurs on the main process. This can reduce time spent blocking the execution of the main process. This is particularly useful when using Device Sync, where you don't know when and for how long the Sync client will be writing. ```dart // Add Leia to the realm using `writeAsync` Person leia = Person(ObjectId(), \"Leia\"); realm.writeAsync(() {   realm.add<Person>(leia); }); \n``` ← [Configure & Open a Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/ \"Previous Section\")[React to Changes - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/react-to-changes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/encrypt/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Encrypt a Realm - Flutter SDK On this page * [Overview](#overview)\n* [Considerations](#considerations)\n* [Storing & Reusing Keys](#storing---reusing-keys)\n* [Performance Impact](#performance-impact)\n* [Encryption and Atlas Device Sync](#encryption-and-atlas-device-sync)\n* [Accessing an Encrypted Realm from Multiple Processes](#accessing-an-encrypted-realm-from-multiple-processes)\n* [Example](#example) ## Overview You can encrypt your realms to ensure that the data stored to disk can't be read outside of your application. You encrypt the realm database file on disk with AES-256 + SHA-2 by supplying a 64-byte encryption key when[opening a realm.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-open-realm) Realm transparently encrypts and decrypts data with standard[AES-256 encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) using the first 256 bits of the given 512-bit encryption key. Realm uses the other 256 bits of the 512-bit encryption key to validate integrity using a [hash-based message authentication code (HMAC).](https://en.wikipedia.org/wiki/HMAC) ## Warning Do not use cryptographically-weak hashes for realm encryption keys. For optimal security, we recommend generating random rather than derived encryption keys. ## Considerations The following are key impacts to consider when encrypting a realm. ### Storing & Reusing Keys You **must** pass the same encryption key in the realm's[Configuration.encryptionKey](https://pub.dev/documentation/realm/latest/realm/Configuration/encryptionKey.html)property every time you open the realm. The key must be a 64-byte `List<int>`. To create a key that meets this specification, the List must contain exactly 64 integers and all integers must be between 0 and 255. If you don't provide a key or specify the wrong key for an encrypted realm, the Realm SDK throws an error. Apps should store the encryption key securely, typically in the target platform's secure key/value storage, so that other apps cannot read the key. ### Performance Impact Reads and writes on encrypted realms can be up to 10% slower than unencrypted realms. ### Encryption and Atlas Device Sync You can encrypt a [synced realm.](https://mongodb.com/docs/realm/sdk/flutter/sync/#std-label-flutter-sync) Realm only encrypts the data on the device and stores the data unencrypted in your Atlas data source. Any users with authorized access to the Atlas data source can read the data, but the following still applies: * Users must have the correct read [permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read the synced data.\n* Data stored in Atlas is always encrypted at a volume (disk) level.\n* The transfer between client and server is always fully encrypted. You can also enable [Customer Key Management](https://www.mongodb.com/docs/atlas/security-kms-encryption/)to encrypt stored Atlas data using your cloud provider's key (e.g. AWS KMS, Azure Key Vault, Google Cloud KMS). If you need unique keys for each user of your application, you can use an OAuth provider or use one of the [Realm authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication)and an [authentication trigger](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-triggers)to create a 64-bit key and store that key in a [user object.](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) ### Accessing an Encrypted Realm from Multiple Processes You cannot open the same encrypted realm from multiple processes. Attempting to do so will throw the following error:`Encrypted interprocess sharing is currently unsupported.`\n\n ## Example The following code demonstrates how to generate an encryption key and open an encrypted realm: `| // Generate encryption key                                        |\n| ----------------------------------------------------------------- |\n| final key = List<int>.generate(64, (i) => Random().nextInt(256)); |\n| final encryptedConfig = Configuration.local([Car.schema],         |\n| // Include the encryption key in the configuration                |\n| encryptionKey: key);                                              |\n| final encryptedRealm = Realm(encryptedConfig);                    | ` ← [Reduce Realm File Size - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/compact/ \"Previous Section\")[Database Internals - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/database-internals/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/compact/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Reduce Realm File Size - Flutter SDK On this page * [Compaction Strategies](#compaction-strategies)\n* [Realm.compact() Static Method](#realm.compact---static-method)\n* [Conditionally Compact on Open](#conditionally-compact-on-open) If you want to reduce the size of a realm file to improve performance, you can compact the realm. Compacting a realm reduces the amount of unused empty space within the realm. Every production application should implement compaction to periodically reduce the realm file size. The size of a Realm Database file is always larger than the total size of the objects stored within it. This architecture enables some of realm's performance, concurrency, and safety benefits. Realm writes new data within unused space tracked inside the file. In some situations, a realm file may contain a significant amount of unused space. If file size grows large enough to negatively impact performance, you can compact the realm to reduce its file size. Compacting a realm can be an expensive operation that can block the UI thread. Optimize compacting to balance frequency with performance gains. If your application runs in a resource-constrained environment, you may want to compact when you reach a certain file size or when the file size negatively impacts performance. ## Compaction Strategies You can compact a realm file using either of two strategies: * [Realm.compact()](#std-label-flutter-realm-compact) static method: Use this method to compact a realm. You can use this to compact a Flexible Sync realm.\n* [Conditionally compact on open](#std-label-flutter-should-compact-callback): use the `shouldCompactCallback()` when you want to define one or more conditions to determine whether to compact the realm. You might check for a certain realm file size, a percentage of unused space, or other conditions that are relevant to your performance needs or runtime environment. This is a property on realm's [LocalConfiguration](https://pub.dev/documentation/realm/latest/realm/LocalConfiguration-class.html), and only works with non-Synced realms. ## Realm.compact() Static Method You can compact a realm file by calling [Realm.compact()](https://pub.dev/documentation/realm/latest/realm/Realm/compact.html). This method takes a [Configuration](https://pub.dev/documentation/realm/latest/topics/Configuration-topic.html) as an argument. When you use this method, the device must have enough free space to make a copy of the realm. `Realm.compact()` obtains an instance of the realm, and opens it to trigger any schema version upgrades, file format upgrades, migration and initial data callbacks. Upon successfully opening the realm and performing these operations, this method then compacts the realm. If successful, a call to `Realm.compact()` returns `true`. Do not call this method from inside a transaction. You also cannot compact an open realm. `| final config = Configuration.local([Car.schema]);                                  |\n| ---------------------------------------------------------------------------------- |\n| final compacted = Realm.compact(config);                                           |\n| print(                                                                             |\n| \"Successfully compacted the realm: $compacted\"); // On success, this prints \"true\" |\n| final realm = Realm(config);                                                       | ` ## Conditionally Compact on Open ## Note\n\n You can define a [shouldCompactCallback()](https://pub.dev/documentation/realm/latest/realm/LocalConfiguration/shouldCompactCallback.html) as a property of a realm's [LocalConfiguration](https://pub.dev/documentation/realm/latest/realm/LocalConfiguration-class.html). This callback takes two `int` values representing the total number of bytes and the used bytes of the realm file on disk. The callback returns a `bool`. Compaction only occurs if the `bool` returns `true` and another process is not currently accessing the realm file. The most basic usage is to define a file size at which compaction should occur. ```dart final config = Configuration.local([Car.schema],     shouldCompactCallback: ((totalSize, usedSize) {   // shouldCompactCallback sizes are in bytes.   // For convenience, this example defines a const   // representing a byte to MB conversion for compaction   // at an arbitrary 10MB file size.   const tenMB = 10 * 1048576;   return totalSize > tenMB; })); final realm = Realm(config); \n``` You can define more complex logic if you need to optimize performance for different use cases. For example, you could set a threshold for compaction when a certain percentage of the file size is used. ```dart final config = Configuration.local([Car.schema],     shouldCompactCallback: ((totalSize, usedSize) {   // Compact if the file is over 10MB in size and less than 50% 'used'   const tenMB = 10 * 1048576;   return (totalSize > tenMB) &&       (usedSize.toDouble() / totalSize.toDouble()) < 0.5; })); final realm = Realm(config); \n``` ← [Bundle a Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/bundle/ \"Previous Section\")[Encrypt a Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/encrypt/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Delete a Realm File - Flutter SDK On this page * [Delete a Realm File](#delete-a-realm-file) In some cases, you may want to completely delete a realm file from disk. Realm avoids copying data into memory except when absolutely required. As a result, all objects managed by a realm have references to the file on disk. Before you can safely delete the file, you must ensure the deallocation of these objects: * All objects read from or added to the realm\n* All List and Results objects\n* All ThreadSafeReference objects\n* The realm itself ## Warning ### Don't delete files while realms are open If you delete a realm file or any of its auxiliary files while one or more instances of the realm are open, you might corrupt the realm or disrupt [sync.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) ## Delete a Realm File You can delete the `.realm`, `.note` and `.management` files for a given configuration with the static method[Realm.deleteRealm()](https://pub.dev/documentation/realm/latest/realm/Realm/deleteRealm.html), which accepts a path to a realm file as an argument. `| //Get realm's file path                      |\n| -------------------------------------------- |\n| final path = realm.config.path;              |\n| // You must close a realm before deleting it |\n| realm.close();                               |\n| // Delete the realm                          |\n| Realm.deleteRealm(path);                     | ` ← [Realm Files - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/ \"Previous Section\")[Bundle a Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/bundle/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Relationships - Flutter SDK On this page * [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationship](#inverse-relationship) You can reference other Realm models from your Realm model. This lets you create the following types of relationships between Realm objects: * [To-One Relationship](#std-label-flutter-many-to-one-relationship)\n* [To-Many Relationship](#std-label-flutter-many-to-many-relationship)\n* [Inverse Relationship](#std-label-flutter-inverse-relationship) You can also embed one Realm object directly within another to create a nested data structure. Embedded objects are similar to relationships, but provide additional constraints. For more information about these constraints and how to create embedded objects, refer to the [Embedded Objects data type documentation.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/data-types/#std-label-flutter-embedded-objects) ## To-One Relationship A **to-one** relationship means that an object is related in a specific way to no more than one other object. To set up a to-one relationship, create a property in your model whose type is another model. Multiple objects can reference the same object. ## Important ### To-one relationships must be optional When you declare a to-one relationship in your object model, it must be an optional property. If you try to make a to-one relationship required, Realm throws an exception at runtime. `| @RealmModel()          |\n| ---------------------- |\n| class _Bike {          |\n| @PrimaryKey()          |\n| late ObjectId id;      |\n| late String name;      |\n| late _Person? owner;   |\n| }                      |\n| @RealmModel()          |\n| class _Person {        |\n| @PrimaryKey()          |\n| late ObjectId id;      |\n| late String firstName; |\n| late String lastName;  |\n| late int? age;         |\n| }                      | ` ## To-Many Relationship A **to-many** relationship means that an object is related in a specific way to multiple objects. You can create a relationship between one object and any number of objects using a property of type `List<T>` in your application, where T is a Realm model class. ```dart @RealmModel() class _Scooter {   @PrimaryKey()   late ObjectId id;   late String name;   late _Person? owner; } @RealmModel() class _ScooterShop {   @PrimaryKey()   late ObjectId id;   late String name;   late List<_Scooter> owner; } \n``` ## Inverse Relationship An **inverse relationship** links an object back to any other objects that refer to it in to-one or to-many relationships. Inverse relationships have the following properties: * You must explicitly define a property in the object's model as an inverse relationship. The schema cannot infer the inverse relationship.\n* Inverse relationships automatically update themselves with corresponding backlinks. You can find the same set of Realm objects with a manual query, but the inverse relationship field reduces boilerplate query code and capacity for error.\n* You cannot manually set the value of an inverse relationship property. Instead, Realm Database updates implicit relationships when you add or remove an object in the relationship. For example, the to-many relationship \"a User has many Tasks\" does not automatically create the inverse relationship \"a Task belongs to one User\". If you don't specify the inverse relationship in the Task object model, you need to run a separate query to look up the user that is assigned to a given task.\n\n ```dart @RealmModel() class _User {   @PrimaryKey()   late ObjectId id;   late String username;   // One-to-many relationship that the backlink is created for below.   late List<_Task> tasks; } @RealmModel() class _Task {   @PrimaryKey()   late ObjectId id;   late String description;   late bool isComplete;   // Backlink field. Links back to the `tasks` property in the `_User` model.   @Backlink(#tasks)   late Iterable<_User> linkedUser; } \n``` ## Note ### Inverse Relationships Not Present in Device Sync Schema If you are using Atlas Device Sync, inverse relationships are not present in the server-side Device Sync schema in your App Services App. Since you can't directly set the value of an inverse relationship, the relationship does not exist in Device Sync schema. For more information on the server-side Device Sync schema, refer to [Configure and Update Your Data Model](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/sync-schema-overview/#std-label-sync-schema-overview)in the Atlas App Services documentation. ← [Data Types - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/data-types/ \"Previous Section\")[Property Annotations - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/property-annotations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - Flutter SDK On this page * [Register a Query Change Listener](#register-a-query-change-listener)\n* [Register a RealmObject Change Listener](#register-a-realmobject-change-listener)\n* [Register RealmList and RealmSet Change Listeners](#register-realmlist-and-realmset-change-listeners)\n* [Pause and Resume a Change Listener](#pause-and-resume-a-change-listener)\n* [Unsubscribe a Change Listener](#unsubscribe-a-change-listener) Any modern app should be able to react when data changes, regardless of where that change originated. When a user adds a new item to a list, you may want to update the UI, show a notification, or log a message. When someone updates that item, you may want to change its visual state or fire off a network request. Finally, when someone deletes the item, you probably want to remove it from the UI. Realm's notification system allows you to watch for and react to changes in your data, independent of the writes that caused the changes. You can subscribe to changes on the following events: * [Query on collection](#std-label-flutter-query-change-listener)\n* [Realm object](#std-label-flutter-realm-object-change-listener)\n* [List and Set in a Realm object](#std-label-flutter-realm-list-change-listener) ## Example ### About the Examples on This Page The examples in this page use two Realm object types, `Character` and`Fellowship`: `| @RealmModel()                  |\n| ------------------------------ |\n| class _Character {             |\n| @PrimaryKey()                  |\n| late String name;              |\n| late String species;           |\n| late int age;                  |\n| }                              |\n| @RealmModel()                  |\n| class _Fellowship {            |\n| @PrimaryKey()                  |\n| late String name;              |\n| late List<_Character> members; |\n| }                              | ` The examples have this sample data: ```dart final frodo = Character('Frodo', 'Hobbit', 51); final samwise = Character('Samwise', 'Hobbit', 39); final gollum = Character('Gollum', 'Hobbit', 589); final aragorn = Character('Aragorn', 'Human', 87); final legolas = Character('Legolas', 'Elf', 2931); final gimli = Character('Gimli', 'Dwarf', 140); final fellowshipOfTheRing = Fellowship('Fellowship of the Ring',     members: [frodo, samwise, aragorn, legolas, gimli]); final config = Configuration.local([Fellowship.schema, Character.schema]); final realm = Realm(config); realm.write(() {   realm.add(fellowshipOfTheRing);   realm.add(gollum); // not in fellowship }); \n``` ## Register a Query Change Listener You can register a notification handler on any query within a Realm. The handler receives a [RealmResultsChanges](https://pub.dev/documentation/realm/latest/realm/RealmResultsChanges-class.html) object, which includes description of changes since the last notification.`RealmResultsChanges` contains the following properties:\n\n ```dart // Listen for changes on whole collection final characters = realm.all<Character>(); final subscription = characters.changes.listen((changes) {   changes.inserted; // indexes of inserted objects   changes.modified; // indexes of modified objects   changes.deleted; // indexes of deleted objects   changes.newModified; // indexes of modified objects   // after deletions and insertions are accounted for   changes.moved; // indexes of moved objects   changes.results; // the full List of objects }); // Listen for changes on RealmResults final hobbits = fellowshipOfTheRing.members.query('species == \"Hobbit\"'); final hobbitsSubscription = hobbits.changes.listen((changes) {   // ... all the same data as above }); \n``` ## Register a RealmObject Change Listener You can register a notification handler on a specific object within a realm. Realm notifies your handler when any of the object's properties change. The handler receives a [RealmObjectChanges](https://pub.dev/documentation/realm/latest/realm/RealmObjectChanges-class.html) object, which includes description of changes since the last notification.`RealmObjectChanges` contains the following properties: | Property   | Type           | Description                                               |\n| ---------- | -------------- | --------------------------------------------------------- |\n| isDeleted  | _bool_         | true if the object was deleted.                           |\n| object     | _RealmObject_  | Realm object being monitored for changes.                 |\n| properties | _List<String>_ | Names of the Realm object's properties that have changed. | ```dart final frodoSubscription = frodo.changes.listen((changes) {   changes.isDeleted; // if the object has been deleted   changes.object; // the RealmObject being listened to, `frodo`   changes.properties; // the changed properties }); \n``` ## Register RealmList and RealmSet Change Listeners You can register a notification handler on a list or set of any of the supported data types within another `RealmObject`. Realm notifies your handler when any of the items in the set or list change. The handler receives a [RealmListChanges](https://pub.dev/documentation/realm/latest/realm/RealmListChanges-class.html) object for `RealmList` and [RealmSetChanges](https://pub.dev/documentation/realm/latest/realm/RealmSetChanges-class.html) object for `RealmSet`. These objects include description of changes since the last notification. `RealmListChanges` contains the following properties:\n\n ```dart final fellowshipSubscription =     fellowshipOfTheRing.members.changes.listen((changes) {   changes.inserted; // indexes of inserted Realm objects   changes.modified; // indexes of modified Realm objects   changes.deleted; // indexes of deleted Realm objects   changes.newModified; // indexes of modified Realm objects   // after deletions and insertions are accounted for   changes.moved; // indexes of moved Realm objects   changes.list; // the full RealmList of Realm objects   // `true` after call to fellowshipOfTheRing.members.clear().   // Otherwise false.   changes.isCleared; }); \n``` ## Pause and Resume a Change Listener Pause your subscription if you temporarily don't want to receive notifications. You can later resume listening. ```dart subscription.pause(); // the changes.listen() method won't fire until the subscription is resumed subscription.resume(); \n``` ## Unsubscribe a Change Listener Unsubscribe from your change listener when you no longer want to receive notifications on updates to the data it's watching. ```dart await subscription.cancel(); \n``` ← [Read & Write Data - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/ \"Previous Section\")[Freeze Data - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/freeze/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/bundle/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Bundle a Realm - Flutter SDK On this page * [Bundle a Local Realm](#bundle-a-local-realm)\n* [Create a Realm File for Bundling](#create-a-realm-file-for-bundling)\n* [Bundle a Realm File in Your Production Application](#bundle-a-realm-file-in-your-production-application)\n* [Open a Realm from a Bundled Realm File](#open-a-realm-from-a-bundled-realm-file)\n* [Bundle a Synced Realm](#bundle-a-synced-realm) You might want to seed your mobile app with some initial data that will be available to users on the initial launch of the app. To do this, you can bundle an existing realm database file in your Flutter app. If your app uses a synced realm, you may not want to bundle it. For more information, refer to the [Bundle a Synced Realm](#std-label-flutter-bundle-synced-realm) section. ## Tip ### Consider Initial Data Callback You can also add data to your realm the first time an application opens it using the [initial data callback function.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-initial-data-callback) ## Bundle a Local Realm 1 ### Create a Realm File for Bundling Create a new project with the same [Realm object schema](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-define-realm-object-schema) as your production app.[Open an existing realm](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/#std-label-flutter-open-realm) with the data you wish to bundle, or create a new one. Get the path to the realm file with the [Realm.config.path](https://pub.dev/documentation/realm/latest/realm/Configuration/path.html)property. `| print(\"Bundling realm\");                                                |\n| ----------------------------------------------------------------------- |\n| final config = Configuration.local([Car.schema], path: 'bundle.realm'); |\n| final realm = Realm(config);                                            |\n| realm.write(() {                                                        |\n| realm.add(Car(ObjectId(), \"Audi\", model: 'A8'));                        |\n| realm.add(Car(ObjectId(), \"Mercedes\", model: 'G Wagon'));               |\n| });                                                                     |\n| print(\"Bundled realm location: \" + realm.config.path);                  |\n| realm.close();                                                          | ` ## Tip ### Create Bundled Realm with Dart Standalone SDK\n\n * Creating a bundled realm does not require any Flutter UI elements.\n* Dart standalone projects require less boilerplate code than Flutter projects 2 ### Bundle a Realm File in Your Production Application Now that you have a copy of the realm with the \"seed\" data in it, you need to bundle it with your production application. Add the realm file to your application's [Flutter assets](https://docs.flutter.dev/development/ui/assets-and-images). For example you could add the bundled realm in your project at the location`assets/bundled.realm`. Add a reference to the bundled realm to your `pubspec.yaml` file to include it in your production application: pubspec.yaml ``` flutter:   assets:   - realm/bundle.realm \n``` 3 ### Open a Realm from a Bundled Realm File Now that you have a copy of the realm included with your app, you need to add code to use it. Before you deploy your app with the bundled realm, you need to extract the realm from the embedded resources, save it to the app's data location, and then open this new realm in the app. The following code shows how you can do this during start-up of the app. Create a helper function `initBundledRealm` to check if the bundled realm already exists within the app, and load it into the app if it does not exist yet. Call `initBundledRealm` before calling loading the app's widgets with[runApp().](https://api.flutter.dev/flutter/widgets/runApp.html) lib/main.dart ```dart // Also import Realm schema and Flutter widgets import 'package:flutter/services.dart'; import 'package:realm/realm.dart'; import 'dart:io'; Future<Realm> initBundledRealm(String assetKey) async {   final config = Configuration.local([Car.schema]);   final file = File(config.path);   if (!await file.exists()) {     final realmBytes = await rootBundle.load(assetKey);     await file.writeAsBytes(         realmBytes.buffer             .asUint8List(realmBytes.offsetInBytes, realmBytes.lengthInBytes),         mode: FileMode.write);   }   return Realm(config); } void main() async {   WidgetsFlutterBinding.ensureInitialized();   final realm = await initBundledRealm(\"assets/bundle.realm\");   runApp(const MyApp()); } \n``` ## Bundle a Synced Realm In most cases, you should **not** bundle a synced realm. If the bundled realm was last updated further in the past than [client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), the user experiences a client reset the first time they open the bundled realm file. The client reset causes the application to download the full state of the realm from the application backend. This negates the advantages of bundling a realm file. Rather than bundling a synced realm, you can populate your application with data using sync subscriptions. If you add data using sync subscriptions, you do not need to be concerned with data being older than the client maximum online time while taking advantage of Flexible Sync's [trimming](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-trimming) feature. To learn more about using sync subscriptions, refer to [Manage Sync Subscriptions.](https://mongodb.com/docs/realm/sdk/flutter/sync/manage-sync-subscriptions/#std-label-flutter-flexible-sync-manage-subscriptions) You should only bundle a synced realm if your use case meets the following criteria:\n\n To bundle a synced realm, perform the following: 1. Connect to your App Services App and authenticate a user.\n2. Add a subscription to the realm. You need a subscription to write to a synced realm.\n3. Add data to the synced realm.\n4. Wait for all local changes to synchronize with the Device Sync server.\n5. Use [Realm.writeCopy()](https://pub.dev/documentation/realm/latest/realm/Realm/writeCopy.html) to create a new version of the synced realm. You **must** use `Realm.writeCopy()`to bundle the synced realm because the method removes metadata that associates the realm with the user, which allows other users to open the realm file as well. ```dart print(\"Bundling synced realm\"); // You must connect to the Device Sync server with an authenticated // user to work with the synced realm. final app = App(AppConfiguration(APP_ID)); // Check if current user exists and log anonymous user if not. final user = app.currentUser ?? await app.logIn(Credentials.anonymous()); final config = Configuration.flexibleSync(user, [Car.schema]); final realm = Realm(config); // Add subscription that match the data being added     // and your app's backend permissions. realm.subscriptions.update((mutableSubscriptions) {   mutableSubscriptions.add(realm.all<Car>()); }); await realm.subscriptions.waitForSynchronization(); // Add data to realm realm.write(() {   realm.add(Car(ObjectId(), \"Audi\", model: 'A8'));   realm.add(Car(ObjectId(), \"Mercedes\", model: 'G Wagon')); }); // Sync changes with the server await realm.syncSession.waitForUpload(); await realm.syncSession.waitForDownload(); // Create new configuration for the bundled realm. // You must specify a path separate from the realm you // are copying for Realm.writeCopy() to succeed. final bundledConfig = Configuration.flexibleSync(user, [Car.schema],     path: 'sync_bundle.realm'); realm.writeCopy(bundledConfig); print(\"Bundled realm location: \" + bundledConfig.path); realm.close(); \n``` After you create the bundled realm, follow the instructions from the above sections**Bundle a Realm File in Your Production Application** and **Open a Realm from a Bundled Realm File**. ← [Delete a Realm File - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/delete/ \"Previous Section\")[Reduce Realm File Size - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/realm-files/compact/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/property-annotations/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Property Annotations - Flutter SDK On this page * [Required and Optional Properties](#required-and-optional-properties)\n* [Default Field Values](#default-field-values)\n* [Primary Keys](#primary-keys)\n* [Map a Property to a Different Name](#map-a-property-to-a-different-name)\n* [Ignore Properties from Realm Schema](#ignore-properties-from-realm-schema)\n* [Index Properties](#index-properties) You can use annotations to add functionality to properties in your Realm object models. ## Required and Optional Properties In Dart, value types are implicitly non-nullable, but can be made optional (nullable) by appending[?](https://dart.dev/null-safety). Include `?` to make properties optional. `| class _Vehicle {                                                 |\n| ---------------------------------------------------------------- |\n| @PrimaryKey()                                                    |\n| late ObjectId id;                                                |\n| late String? maybeDescription; // optional value                 |\n| late double milesTravelled = 0; // 0 is default value            |\n| @Ignored()                                                       |\n| late String notInRealmModel;                                     |\n| @Indexed()                                                       |\n| late String make;                                                |\n| @MapTo('wheels') // 'wheels' is property name in the RealmObject |\n| late int numberOfWheels;                                         |\n| }                                                                | ` ## Default Field Values You can use the built-in language features to assign a default value to a property. Assign a default value in the property declaration. ```dart class _Vehicle {   @PrimaryKey()   late ObjectId id;   late String? maybeDescription; // optional value   late double milesTravelled = 0; // 0 is default value   @Ignored()   late String notInRealmModel;   @Indexed()   late String make;   @MapTo('wheels') // 'wheels' is property name in the RealmObject   late int numberOfWheels; } \n``` ## Primary Keys\n\n Important aspects of primary keys: * You cannot change a primary key after adding an object to a realm.\n* Only add a primary key to one property in a RealmModel.\n* Only `String`, `int`, `ObjectId`, and `Uuid` types can be primary keys.\n* Realm automatically indexes primary keys.\n* Primary keys are nullable. `null` can only be the primary key of one object in a collection. ```dart class _Vehicle {   @PrimaryKey()   late ObjectId id;   late String? maybeDescription; // optional value   late double milesTravelled = 0; // 0 is default value   @Ignored()   late String notInRealmModel;   @Indexed()   late String make;   @MapTo('wheels') // 'wheels' is property name in the RealmObject   late int numberOfWheels; } \n``` ## Map a Property to a Different Name The [MapTo](https://pub.dev/documentation/realm%5Fcommon/latest/realm%5Fcommon/MapTo-class.html) annotation indicates that a property should be persisted under a different name. It's useful when opening a Realm across different bindings where code style conventions can differ. ```dart class _Vehicle {   @PrimaryKey()   late ObjectId id;   late String? maybeDescription; // optional value   late double milesTravelled = 0; // 0 is default value   @Ignored()   late String notInRealmModel;   @Indexed()   late String make;   @MapTo('wheels') // 'wheels' is property name in the RealmObject   late int numberOfWheels; } \n``` ## Ignore Properties from Realm Schema If you add the [Ignored](https://pub.dev/documentation/realm%5Fcommon/latest/realm%5Fcommon/Ignored-class.html)annotation to a property in your `RealmModel`, the [realm object generator](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-generate-realm-object) doesn't include the property in the `RealmObject` schema or persist it to Realm Database. ```dart class _Vehicle {   @PrimaryKey()   late ObjectId id;   late String? maybeDescription; // optional value   late double milesTravelled = 0; // 0 is default value   @Ignored()   late String notInRealmModel;   @Indexed()   late String make;   @MapTo('wheels') // 'wheels' is property name in the RealmObject   late int numberOfWheels; } \n``` ## Index Properties Add the [Indexed](https://pub.dev/documentation/realm%5Fcommon/latest/realm%5Fcommon/Indexed-class.html)annotation to create an index on the field. Indexes can greatly speed up some queries at the cost of slightly slower write times and additional storage and memory overhead. Realm Database stores indexes on disk, which makes your realm files larger. Each index entry is a minimum of 12 bytes. Indexes can be nullable. The following data types can be indexed: * `bool`\n* `int`\n* `String`\n* `ObjectId`\n* `Uuid`\n* `DateTime`\n* `RealmValue` ```dart class _Vehicle {   @PrimaryKey()   late ObjectId id;   late String? maybeDescription; // optional value   late double milesTravelled = 0; // 0 is default value   @Ignored()   late String notInRealmModel;   @Indexed()   late String make;   @MapTo('wheels') // 'wheels' is property name in the RealmObject   late int numberOfWheels; } \n``` ← [Relationships - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/ \"Previous Section\")[Update a Realm Object Schema - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/update-realm-object-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/update-realm-object-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Update a Realm Object Schema - Flutter SDK On this page * [Schema Version](#schema-version)\n* [Automatically Update Schema](#automatically-update-schema)\n* [Add a Property](#add-a-property)\n* [Delete a Property](#delete-a-property)\n* [Manually Migrate Schema](#manually-migrate-schema)\n* [Delete an Object Type](#delete-an-object-type)\n* [Rename a Property](#rename-a-property)\n* [Other Migration Tasks](#other-migration-tasks)\n* [Updating the Schema of a Synced Realm](#updating-the-schema-of-a-synced-realm) You can change the schema of a Realm object after you first create it. Depending on the type of changes you make to the schema, the changes can be either automatically applied or require a manual update to the new schema. Manual schema updates are called **migrations** in Realm Database. You can automatically update a Realm object schema when you add or delete a property from a Realm object model. For more information, refer to the[Automatically Update Schema section.](#std-label-flutter-automatically-update-schema) You must perform a manual migration for all other schema changes. For more information, refer to the [Manually Migrate Schema section.](#std-label-flutter-manually-migrate-schema) ## Tip ### Bypass Migration During Development When developing or debugging your application, you may prefer to delete the realm instead of migrating it. Use the[LocalConfiguration.shouldDeleteIfMigrationNeeded](https://pub.dev/documentation/realm/latest/realm/LocalConfiguration/shouldDeleteIfMigrationNeeded.html)property to delete the database automatically when a schema mismatch requires a migration. ## Important ### Modify Schema Properties of a Synced Realm The contents on this page only apply to local Realm Databases. Schema migration functions differently for Realm Database using Atlas Device Sync to synchronize data with MongoDB Atlas. Refer to the [Updating the Schema of a Synced Realm section.](#std-label-flutter-update-schema-of-synced-realm) ## Schema Version A **schema version** identifies the state of a [realm schema](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-realm-schema) at some point in time. Realm Database tracks the schema version of each realm and uses it to map the objects in each realm to the correct schema. Schema versions are ascending integers that you can optionally include in the realm configuration when you open a realm. If a client application does not specify a version number when it opens a realm then the realm defaults to version `0`. Manual migrations must update a realm to a higher schema version. Realm Database throws an error if a client application opens a realm with a schema version that is lower than the realm's current version or if the specified schema version is the same as the realm's current version but includes different object schemas. ## Automatically Update Schema Realm Database can automatically migrate added and deleted properties. You must update the schema version when you make these changes. ### Add a Property To add a property to a schema: 1. Add the new property to the object's `RealmModel` class.\n2. [Regenerate the RealmObject.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-generate-realm-object)\n3. Set a schema version to the realm's[Configuration object.](https://pub.dev/documentation/realm/latest/realm/Configuration-class.html) ## Example A realm using schema version `1` has a `Person` object type with a`firstName`, and `lastName` property. The developer decides to add an`age` property to the `_Person` RealmModel class. To change the realm to conform to the updated `Person` schema, the developer sets the realm's [schema version](#std-label-flutter-schema-version)to `2`.\n\n ` ```dart final config = Configuration.local([Person.schema], schemaVersion: 2); final realm = Realm(config); \n``` ### Delete a Property To delete a property from a schema: 1. Remove the property from the object's `RealmModel` class.\n2. [Regenerate the RealmObject.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-generate-realm-object)\n3. In the realm's configuration, include the regenerated `RealmObject.schema`and increment the `schemaVersion`. Deleting a property does not impact existing objects. ## Example A realm using schema version `1` has a `Dog` object type with a`weight` property. The developer decides to remove the property from the schema. To migrate the realm to conform to the updated `Dog` schema, the developer sets the realm's [schema version](#std-label-flutter-schema-version) to`2`. ```dart final config = Configuration.local([Person.schema], schemaVersion: 2); final realm = Realm(config); \n``` ## Manually Migrate Schema For more complex schema updates, Realm Database requires you to manually migrate old instances of a given object to the new schema. When you open the realm with the updated schema, you must do the following in the realm's `Configuration`: * Increment the `schemaVersion` property.\n* Define the migration logic in a [migrationCallback](https://pub.dev/documentation/realm/latest/realm/MigrationCallback.html)property of a realm's [Configuration](https://pub.dev/documentation/realm/latest/realm/Configuration-class.html). The migration callback has the following parameters:  \n   * `migration`: A [Migration](https://pub.dev/documentation/realm/latest/realm/Migration-class.html)instance with access to the current realm, the realm that you're migrating to, and methods to help with the migration operation.  \n   * `oldSchemaVersion`: The number of the previous schema version of the realm on the device. The following sections explain how to perform various migration operations. ### Delete an Object Type To delete all objects of a type from your realm, pass a string representation of the object schema's name to [Migration.deleteType().](https://pub.dev/documentation/realm/latest/realm/Migration/deleteType.html) This is useful if the previous version of a schema has a Realm object type, but the new version of the schema does not. ```dart final configWithoutPerson = Configuration.local([Car.schema],     schemaVersion: 2,     migrationCallback: ((migration, oldSchemaVersion) {   // Between v1 and v2 we removed the Person type   migration.deleteType('Person'); })); final realmWithoutPerson = Realm(configWithoutPerson); \n``` ### Rename a Property Rename a schema property with [Migration.renameProperty().](https://pub.dev/documentation/realm/latest/realm/Migration/renameProperty.html) ```dart final configWithRenamedAge =     Configuration.local([Person.schema, Car.schema],         schemaVersion: 2,         migrationCallback: ((migration, oldSchemaVersion) {   // Between v1 and v2 we renamed the Person 'age' property to 'yearsSinceBirth'   migration.renameProperty('Person', 'age', 'yearsSinceBirth'); })); final realmWithRenamedAge = Realm(configWithRenamedAge); \n``` ### Other Migration Tasks To perform other realm schema migrations, use the following properties of the `Migration` object in your migration callback function:\n\n To find instances of an object in an old realm in the new realm, use [Migration.findInNewRealm()](https://pub.dev/documentation/realm/latest/realm/Migration/findInNewRealm.html). To access the properties of objects from the old schema, use the [RealmObjects.dynamic](https://pub.dev/documentation/realm/latest/realm/RealmObject/dynamic.html) API. ```dart final configWithChanges = Configuration.local([Person.schema, Car.schema],     schemaVersion: 2,     migrationCallback: ((migration, oldSchemaVersion) {   // Dynamic query for all Persons in previous schema   final oldPeople = migration.oldRealm.all('Person');   for (final oldPerson in oldPeople) {     // Find Person instance in the updated realm     final newPerson = migration.findInNewRealm<Person>(oldPerson);     if (newPerson == null) {       // That person must have been deleted, so nothing to do.       continue;     }     // Use dynamic API to get properties from old schema and use in the     // new schema     newPerson.fullName = oldPerson.dynamic.get<String>(\"firstName\") +         \" \" +         oldPerson.dynamic.get<String>(\"lastName\");     // convert `id` from ObjectId to String     final oldId = oldPerson.dynamic.get<ObjectId>(\"id\");     newPerson.id = oldId.toString();   } })); final realmWithChanges = Realm(configWithChanges); \n``` ## Updating the Schema of a Synced Realm Updating the schema of a synced realm is a separate process from updating the schema of a local-only realm. Synced realms do not have schema versions and automatically migrate objects to the latest schema. Synced realms only support non-breaking schema changes. Learn how to [modify schema properties of a synced realm.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) ← [Property Annotations - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/property-annotations/ \"Previous Section\")[Configure & Open a Realm - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/configure-and-open/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Usage Examples - Node.js SDK ## Realm Database (Non-Sync) * [Connect to an Atlas App Services backend](https://mongodb.com/docs/realm/sdk/node/examples/connect-to-app-services-backend/)\n* [Define a Realm Object Model](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/)\n* [Open & Close a Realm](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/)\n* [Read & Write Data](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/)\n* [React to Changes](https://mongodb.com/docs/realm/sdk/node/examples/react-to-changes/)\n* [Query Data](https://mongodb.com/docs/realm/sdk/node/examples/query-data/)\n* [Modify an Object Schema](https://mongodb.com/docs/realm/sdk/node/examples/modify-an-object-schema/) ## Application Services (Sync) * [Authenticate Users](https://mongodb.com/docs/realm/sdk/node/examples/authenticate-users/)\n* [Sync Changes Between Devices](https://mongodb.com/docs/realm/sdk/node/examples/sync-changes-between-devices/)\n* [Flexible Sync](https://mongodb.com/docs/realm/sdk/node/examples/flexible-sync/)\n* [Call a Function](https://mongodb.com/docs/realm/sdk/node/examples/call-a-function/)\n* [Create & Manage User API Keys](https://mongodb.com/docs/realm/sdk/node/examples/manage-user-api-keys/)\n* [Query MongoDB](https://mongodb.com/docs/realm/sdk/node/examples/query-mongodb/)\n* [Reset a Client Realm](https://mongodb.com/docs/realm/sdk/node/examples/reset-a-client-realm/) ← [Embedded Objects - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/embedded-objects/ \"Previous Section\")[Define a Realm Object Schema - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/migrate/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Upgrade from Stitch to Realm - Node.js SDK On this page * [Overview](#overview)\n* [New Features](#new-features)\n* [Changes](#changes) ## Overview If you have an existing app built with the Stitch SDK, you should migrate your app to use the new Realm SDK. While much of the application logic and flow of information hasn't changed, there are a few changes to how it connects to the realm backend. ## Note This page presents how to migrate from the MongoDB Stitch Server SDK to the Realm JS SDK, to build Node.js Applications. If you are looking to build web apps, consider our [Upgrade from Stitch to Realm Web](https://mongodb.com/docs/realm/web/migrate/#std-label-web-migrating-from-stitch-to-realm) page. If you are looking to develop React Native apps, consider our [Upgrade from Stitch to Realm for React Native](https://mongodb.com/docs/realm/sdk/react-native/migrate/#std-label-react-native-migrating-from-stitch-to-realm) page. ## New Features * The Realm Node SDK now includes Realm Database, which includes local object storage and the ability to synchronize document changes across devices over the internet. ## Changes\n\n ← [Telemetry - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/telemetry/ \"Previous Section\")[Realm React Native SDK](https://mongodb.com/docs/realm/sdk/react-native/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Fundamentals - Node.js SDK * [Realm Database](https://mongodb.com/docs/realm/sdk/node/fundamentals/realm-database/)\n* [Realms](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/)\n* [Live Queries](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/)\n* [Write Transactions](https://mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/)\n* [Relationships & Embedded Objects](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/)\n* [Schema Versions & Migrations](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/)\n* [Application Services](https://mongodb.com/docs/realm/sdk/node/fundamentals/application-services/)\n* [Atlas Device Sync](https://mongodb.com/docs/realm/sdk/node/fundamentals/device-sync/) ← [Quick Start - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/quick-start/ \"Previous Section\")[Realm Database - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/realm-database/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Define a Realm Object Schema - Flutter SDK On this page * [Create Model](#create-model)\n* [Import Realm](#import-realm)\n* [Create Generated File Part Directive](#create-generated-file-part-directive)\n* [Create RealmModel](#create-realmmodel)\n* [Generate RealmObject](#generate-realmobject)\n* [Use RealmObject in Application](#use-realmobject-in-application)\n* [Using Schemas with Device Sync](#using-schemas-with-device-sync)\n* [Supported Data Types](#supported-data-types)\n* [Property Annotations](#property-annotations)\n* [Define Relationship Properties](#define-relationship-properties)\n* [Map Realm Model to Different Name](#map-realm-model-to-different-name)\n* [Generate the RealmObject](#generate-the-realmobject) An **object schema** is a configuration object that defines the properties and relationships of a Realm object. Realm client applications define object schemas with the native class implementation in their respective language using the Object Schema. Object schemas specify constraints on object properties such as the data type of each property and whether or not a property is required. Schemas can also define [relationships](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/#std-label-flutter-client-relationships) between object types in a realm. ## Create Model 1 ### Import Realm Import the Realm SDK package at the top of your file. 2 ### Create Generated File Part Directive Add a part directive to include the `RealmObject` file that you generate in step 4 in the same package as the file you're currently working on. schemas.dart `| part 'schemas.g.dart'; |\n| ---------------------- | ` 3 ### Create RealmModel Create the model for your Realm schema. You must include the annotation [RealmModel](https://pub.dev/documentation/realm%5Fcommon/latest/realm%5Fcommon/RealmModel-class.html)at the top of the class definition. You'll use the `RealmModel` to generate the public `RealmObject`used throughout the application in step 4. You can make the model private or public. We recommend making the all models private and defining them in a single file. Prepend the class name with an underscore (`_`) to make it private. If you need to define your schema across multiple files, you can make the RealmModel public. Prepend the name with a dollar sign (`$`) to make the model public. You must do this to generate the `RealmObject`from the `RealmModel`, as described in step 4. Add fields to the `RealmModel`. You can add all [supported data types](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/data-types/#std-label-flutter-data-types). Include additional behavior using [property annotations.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/property-annotations/#std-label-flutter-property-annotations) schemas.dart ```dart @RealmModel() class _Car {   @PrimaryKey()   late ObjectId id;   late String make;   late String? model;   late int? miles; } \n``` ## Note Class names are limited to a maximum of 57 UTF-8 characters. 4 ### Generate RealmObject Generate the `RealmObject`, which you'll use in your application: This command generates the file in the same directory as your model file. It has the name you specified in the part directive of step 2. ## Tip ### Track the generated file Track the generated file in your version control system, such as git. ## Example ### File structure after generating model ``` . ├── schemas.dart ├── schemas.g.dart // newly generated file ├── myapp.dart └── ...rest of application \n``` 5 ### Use RealmObject in Application\n\n myapp.dart ```dart import './schemas.dart'; final hondaCivic = Car(ObjectId(), 'Honda', model: 'Civic', miles: 99); \n``` ## Using Schemas with Device Sync An **App Services Schema** is a list of valid object schemas that each define an object type that an App may persist. All synced objects in a realm must conform to the App Services Schema. Client applications provide a Object Schema when they open a realm. If a realm already contains data, then it already has a schema, and when it is opened, Realm Database validates the schema on the client against the existing schema. You can define App Services Schemas in the following ways: * Automatically with the Object Schema if [development mode is enabled.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)\n* Explicitly define the App Services Schema with App Services. In your schema you must use the `MapTo(\"_id\")` annotation with your primary key in the `RealmModel` to successfully sync your Object Schema with App Services. ```dart @RealmModel() class _SyncSchema {   @PrimaryKey()   @MapTo(\"_id\")   late ObjectId id;   // ... other properties } \n``` For further information on defining your schema and which of these approaches you should consider for your application, refer to the [Create a Realm Schema documentation.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/#std-label-create-schema-for-backend-realm-app) ## Supported Data Types Realm schemas support many Dart-language data types, in addition to some Realm-specific types. For a comprehensive reference of all supported data types, refer to [Data Types.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/data-types/#std-label-flutter-data-types) ## Property Annotations Use annotations to add functionality to properties in your Realm object models. You can use annotations for things like marking a property as nullable, setting a primary key, ignoring a property, and more. To learn more about the available property annotations, refer to [Property Annotations.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/property-annotations/#std-label-flutter-property-annotations) ## Define Relationship Properties You can define relationships between Realm objects in your schema. The Realm Flutter SDK supports to-one relationships, to-many relationships, inverse relationships, and embedding objects within other objects. To learn more about how to define relationships in your Realm object schema, refer to [Relationships.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/#std-label-flutter-client-relationships) ## Map Realm Model to Different Name You can use the [MapTo](https://pub.dev/documentation/realm%5Fcommon/latest/realm%5Fcommon/MapTo-class.html)annotation to map a Realm object model to a different model name in Realm Database. This can be useful in the following scenarios: * Working with one realm from different Realm SDKs\n* Migrating Realm object models\n* Adhering to certain code style conventions If you're using Atlas Device Sync, the name that you map to corresponds with the [App Services Schema](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) name. ```dart @RealmModel() @MapTo('naval_ship') class _Boat {   @PrimaryKey()   late ObjectId id;   late String name;   late int? maxKnots;   late int? nauticalMiles; } \n``` ## Generate the RealmObject Once you've completed your Realm model, you must generate the[RealmObject](https://pub.dev/documentation/realm/latest/realm/RealmObject-mixin.html) class to use it in your application. Run the following command to generate `RealmObjects`: Running this creates a public class in a new file in the directory where you defined the `RealmModel` class per the [Create Model section.](#std-label-flutter-create-model)\n\n ## Note Remember to include the generated file in a part directive in your `RealmModel` definition file. schemas.dart ```dart // ...import packages part 'schemas.g.dart'; @RealmModel() // ...model definition \n``` If you'd like to watch your data models to generate `RealmObjects` whenever there's a change, include the `--watch` flag in your command. To clean the generator caches, include the `--clean` flag in your command. Cleaning the generator cache can be useful when debugging. ← [Model Data - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/ \"Previous Section\")[Data Types - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/data-types/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/telemetry/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Telemetry - Node.js SDK MongoDB collects anonymized telemetry data from the Realm SDKs to better understand how and where developers use Realm. This data helps us determine what to work on next and lets us gracefully deprecate features with minimal impact. None of the telemetry data collected by the Realm SDKs personally identifies you, your app, or your employer. Data is collected whenever you install the SDK, build your app (if applicable), or run your app in a non-production, debugging environment. MongoDB collects the following information: * An anonymized machine ID and bundle ID\n* The Realm SDK version\n* Your programming language and framework versions\n* Your operating system platform and version Telemetry is on by default for the Realm SDKs. You can disable telemetry at any time b by setting the `REALM_DISABLE_ANALYTICS` environment variable to `true` in your shell environment: `| export REALM_DISABLE_ANALYTICS=true |\n| ----------------------------------- | ` ← [Bundle a Realm File - Node SDK](https://mongodb.com/docs/realm/sdk/node/advanced/bundle/ \"Previous Section\")[Upgrade from Stitch to Realm - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/migrate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/data-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Data Types - Flutter SDK On this page * [Dart Types](#dart-types)\n* [DateTime](#datetime)\n* [Reference Realm Objects](#reference-realm-objects)\n* [Collections](#collections)\n* [RealmList](#realmlist)\n* [RealmSet](#realmset)\n* [RealmResults](#realmresults)\n* [Collections are Live](#collections-are-live)\n* [Additional Supported Data Types](#additional-supported-data-types)\n* [ObjectId](#objectid)\n* [UUID](#uuid)\n* [RealmValue](#realmvalue)\n* [Embedded Objects](#embedded-objects)\n* [Example](#example) The Flutter SDK supports Dart-language data types, a limited subset of[BSON](https://bsonspec.org/) types, and [UUID.](https://en.wikipedia.org/wiki/Universally%5Funique%5Fidentifier) ## Dart Types Realm supports the following Dart types: * `int`\n* `double`\n* `bool`\n* `String`\n* `DateTime` ### DateTime When you use `DateTime` with the Realm Flutter SDK, you can declare it in the model as you would any other Dart type: `| @RealmModel()                   |\n| ------------------------------- |\n| class _Vehicle {                |\n| @PrimaryKey()                   |\n| late String nickname;           |\n| late DateTime dateLastServiced; |\n| }                               | ` However, it is important to note that Realm stores `DateTime` in UTC. When you use `DateTime`, you must create it in UTC or convert it with `.toUtc()` before you store it. If your application requires it, you can convert it back to local or the desired time zone when reading from Realm. ```dart // Create a Realm object with date in UTC, or convert with .toUtc() before storing final subaruOutback = realm.write<Vehicle>(() {   return realm.add(Vehicle('Subie', DateTime.utc(2022, 9, 18, 12, 30, 0))); }); final fordFusion = Vehicle('Fuse', DateTime(2022, 9, 18, 8, 30, 0).toUtc()); realm.write(() {   realm.add(fordFusion); }); // When you query the object, the `DateTime` returned is UTC final queriedSubaruOutback =     realm.all<Vehicle>().query('nickname == \"Subie\"')[0]; // If your app needs it, convert it to Local() or the desired time zone final localizedSubieDateLastServiced =     queriedSubaruOutback.dateLastServiced.toLocal(); \n``` ## Reference Realm Objects You can also reference one or more Realm objects from another. Learn more in the[relationship properties documentation.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/#std-label-flutter-client-relationships) ## Collections A Realm collection contains zero or more instances of a[Realm supported data type](#std-label-flutter-data-types). In a Realm collection, all objects in a collection are of the same type. You can filter and sort any collection using Realm Database's[query language](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/#std-label-flutter-filter-results). Collections are[live objects](https://mongodb.com/docs/realm/sdk/flutter/realm-database/database-internals/#std-label-flutter-live-object), so they always reflect the current state of the realm instance. The contents of a collection update when new elements are added to or deleted from the collection or from its Realm.\n\n Realm Database has the following types of collections: * [RealmList](#std-label-flutter-realm-list)\n* [RealmSet](#std-label-flutter-realm-set)\n* [RealmResults](#std-label-flutter-realm-results) ### RealmList Realm objects can contain lists of any supported data type. Realm uses the [RealmList](https://pub.dev/documentation/realm/latest/realm/RealmList-class.html) data type to store the data. When you include `RealmObjects` as the items in a `RealmList`, it represents a [to-many relationship.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/#std-label-flutter-many-to-one-relationship) Deleting an object from the database will remove it from any RealmLists where it existed. Therefore, a `RealmList` of `RealmObject` types will never contain null values. Also, a `RealmList` can contain multiple references to the same `RealmObject`. A `RealmList` of primitive types can contain null values. If you do not want to allow null values in a list, then either use non-nullable types in the list declaration (for example, use `List<int>` instead of`List<int?>`). A `RealmList` is mutable and you can add and remove elements on a `RealmList`within a write transaction. #### Add a RealmList to a Schema You can add a `RealmList` to your Realm Object schema by defining a property as type`List<T>` where `T` can be any [supported Realm data type](#std-label-flutter-data-types)(except other collections), in your Realm Object model. ```dart @RealmModel() class _Player {   @PrimaryKey()   late String username;   // `inventory` property of type RealmList<Item>   // where Items are other RealmObjects   late List<_Item> inventory;   // `traits` property of type RealmList<String>   // where traits are Dart Strings.   late List<String> traits; } @RealmModel() class _Item {   @PrimaryKey()   late String name;   late String description; } \n``` #### Work with a RealmList ```dart final artemis = realm.write(() => realm.add(Player('Art3mis', inventory: [       Item('elvish sword', 'sword forged by elves'),       Item('body armor', 'protects player from damage'),     ], traits: [       'brave',       'kind'     ]))); // Use RealmList methods to filter results RealmList<String> traits = artemis.traits; final brave = traits.firstWhere((element) => element == 'brave'); final elvishSword =     artemis.inventory.where((item) => item.name == 'elvish sword').first; // Query RealmList with Realm Query Language final playersWithBodyArmor =     realm.query<Player>(\"inventory.name == \\$0\", ['body armor']); print(\"LEN \" + playersWithBodyArmor.length.toString()); \n``` ### RealmSet Realm objects can contain sets of any supported data type except another collection. Realm uses the [RealmSet](https://pub.dev/documentation/realm/latest/realm/RealmSet-class.html) data type to store the data. In a `RealmSet` collection, all values are _unique_.`RealmSet` extends the native Dart [Set](https://api.dart.dev/stable/dart-core/Set-class.html)data type with additional Realm-specific properties and methods. When you include `RealmObjects` as the items in a `RealmSet`, it represents a [to-many relationship.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/#std-label-flutter-many-to-one-relationship) A `RealmSet` is mutable and you can add and remove elements in a `RealmSet`within a write transaction. #### Add a RealmSet to a Schema\n\n When defining a RealmSet in a schema: * A set of primitive types can be defined as either nullable or non-nullable. For example, both `Set<int>` and `Set<int?>` are valid in a Realm schema.\n* A set of `RealmObject` and `RealmValue` types can only be non-nullable. For example `Set<RealmValue>` **is valid** and `Set<RealmValue?>` **is not valid**.\n* You **cannot** define default values when defining a set in a schema. For example, `Set mySet = {0,1,2}` **is not valid**. ```dart @RealmModel() class _RealmSetExample {   late Set<String> primitiveSet;   late Set<int?> nullablePrimitiveSet;   late Set<_SomeRealmModel> realmObjectSet; } @RealmModel() class _SomeRealmModel {   late ObjectId id; } \n``` #### Work with a RealmSet The following example demonstrates some basic usage of `RealmSet`. For more information about all available methods, refer to the[RealmSet reference documentation on pub.dev.](https://pub.dev/documentation/realm/latest/realm/RealmSet-class.html) ```dart final realm = Realm(     Configuration.local([RealmSetExample.schema, SomeRealmModel.schema])); // Pass native Dart Sets to the object to create RealmSets final setExample = RealmSetExample(     primitiveSet: {'apple', 'pear'},     nullablePrimitiveSet: {null, 2, 3},     realmObjectSet: {SomeRealmModel(ObjectId())}); // Add RealmObject to realm database realm.write(() => realm.add(setExample)); // Once you add Sets to the Realm, they are of type RealmSet RealmSet primitiveSet = setExample.primitiveSet; // Modify RealmSets of RealmObjects in write transactions realm.write(() {   // Add element to a RealmSet with RealmSet.add()   setExample.realmObjectSet.add(SomeRealmModel(ObjectId()));   // Remove element from a RealmSet with RealmSet.remove()   setExample.primitiveSet.remove('pear'); }); // Check if a RealmSet contains an element with RealmSet.contains() if (setExample.primitiveSet.contains('apple')) {   print('Set contains an apple'); } // Query RealmSets using Realm Query Language final results =     realm.query<RealmSetExample>('\\$0 IN nullablePrimitiveSet', [null]); // Check number of elements in a RealmSet with RealmSet.length print(setExample.primitiveSet.length); \n``` ### RealmResults A [RealmResults](https://pub.dev/documentation/realm/latest/realm/RealmResults-class.html)collection represents the lazily-evaluated results of a query operation. Unlike a `RealmList`, results are immutable: you cannot add or remove elements on the results collection. This is because the contents of a results collection are determined by a query against the database. [Realm.all()](https://pub.dev/documentation/realm/latest/realm/Realm/all.html) and [Realm.query()](https://pub.dev/documentation/realm/latest/realm/Realm/query.html) return `RealmResults`. For more information on querying Realm Database, refer to [Read Operations.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/read-and-write-data/#std-label-flutter-read-data) ```dart RealmResults<Player> players = realm.all<Player>(); RealmResults<Player> bravePlayers =     realm.query<Player>('ANY traits == \\$0', ['brave']); \n``` #### Results are Lazily Evaluated Realm Database only runs a query when you actually request the results of that query, e.g. by accessing elements of the results collection. This lazy evaluation enables you to write elegant, highly performant code for handling large data sets and complex queries. ### Collections are Live\n\n * Live **results collections** always reflect the current results of the associated query.\n* Live **lists** of `RealmObjects` always reflect the current state of the relationship on the realm instance. There are two cases, however, when a collection is **not** live: * The collection is unmanaged: a `RealmList` property of a Realm object that has not been added to a realm yet or that has been copied from a realm.\n* The collection is [frozen.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/freeze/#std-label-flutter-freeze) Combined with [listening for changes on a collection](https://mongodb.com/docs/realm/sdk/flutter/realm-database/react-to-changes/#std-label-flutter-react-to-changes), live collections enable clean, reactive code. For example, suppose your view displays the results of a query. You can keep a reference to the results collection in your view class, then read the results collection as needed without having to refresh it or validate that it is up-to-date. ## Important ### Indexes may change Since results update themselves automatically, do not store the positional index of an object in the collection or the count of objects in a collection. The stored index or count value could be outdated by the time you use it. ## Additional Supported Data Types ### ObjectId ObjectId is a MongoDB-specific 12-byte unique value which you can use as an identifier for objects. ObjectId is indexable and can be used as a primary key. To define a property as an ObjectId, set its type as `ObjectId` in your [object model.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-create-model) ```dart @RealmModel() class _ObjectIdPrimaryKey {   @PrimaryKey()   late ObjectId id; } \n``` Call `ObjectId()` to set any unique identifier properties of your object. Alternatively, pass a string to `ObjectId()` to set the unique identifier property to a specific value. ```dart final id = ObjectId(); final object = ObjectIdPrimaryKey(id); \n``` ### UUID UUID (Universal Unique Identifier) is a 16-byte [unique value](https://en.wikipedia.org/wiki/Universally%5Funique%5Fidentifier). You can use a UUID as an identifier for objects. UUIDs are indexable and you can use them as primary keys. ## Note ### Using UUID Instead of ObjectId In general, you can use `UUID` for any fields that function as a unique identifier. Using `UUID` might be particularly useful if you are migrating data not stored in MongoDB since it is likely that your object's unique identifiers are already of a `UUID` type. Alternatively, using `ObjectId`might be useful for a collection of data that already exists in MongoDB. To define a property as a UUID, set its type as `Uuid` in your [object model.](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-create-model) ```dart @RealmModel() class _UuidPrimaryKey {   @PrimaryKey()   late Uuid id; } \n``` To set any unique identifier properties of your object to a random value, call one of the `Uuid` methods to create a UUID, such as `Uuid.v4()`. ```dart final myId = Uuid.v4(); final object = UuidPrimaryKey(myId); \n``` ### RealmValue The [RealmValue](https://pub.dev/documentation/realm%5Fcommon/latest/realm%5Fcommon/RealmValue-class.html)data type is a mixed data type that can represent any other valid Realm data type except a collection. You can create collections of type `RealmValue`, but a `RealmValue` itself cannot be a collection. `RealmValue` is indexable, but cannot be a primary key. ## Note When defining your Realm object schema, you cannot create a nullable `RealmValue`. However, if you want a `RealmValue` property to contain a null value, you can use the special `RealmValue.nullValue()` property. To define a property as `RealmValue`, set its type in your Realm object model. ```dart\n\n class _RealmValueExample {   @Indexed()   late RealmValue singleAnyValue;   late List<RealmValue> listOfMixedAnyValues; } \n``` To add a `RealmValue` to a Realm object, call `RealmValue.from()` on the data. ```dart final realm = Realm(Configuration.local([RealmValueExample.schema])); realm.write(() {   realm.addAll([     RealmValueExample(         singleAnyValue: RealmValue.from(1),         listOfMixedAnyValues: [Uuid.v4(), \"abc\", 123].map(RealmValue.from)),     RealmValueExample(         singleAnyValue: RealmValue.nullValue(),         listOfMixedAnyValues: [\"abc\", 123].map(RealmValue.from))   ]); }); \n``` Access the type of data with `RealmValue.type` and the value with `RealmValue.value`. ```dart final data = realm.all<RealmValueExample>(); for (var obj in data) {   if (obj.singleAnyValue.type == int) {     print(obj.singleAnyValue.value.toString());   } } \n``` ## Embedded Objects Realm treats each embedded object as nested data inside of a parent object. An embedded object inherits the lifecycle of its parent object. It cannot exist as an independent Realm object. Embedded objects have the following properties: * Embedded objects are deleted when their parent object is deleted or their parent no longer references them.\n* You cannot reassign an embedded object to a different parent object.\n* you cannot link to an embedded object from multiple parent objects.\n* You can only query an embedded object by accessing it through its parent object. Declare an embedded objects by passing [ObjectType.embeddedObject](https://pub.dev/documentation/realm%5Fcommon/latest/realm%5Fcommon/ObjectType.html)to the `@RealmModel()` annotation. Embedded objects must be nullable when defining them in the parent object's`RealmModel`. You must also include the embedded object's schema in the realm's[Configuration.](https://pub.dev/documentation/realm/latest/realm/Configuration-class.html) The following example shows how to model an embedded object in a Realm schema. The `_Address` model is embedded within the `_Person` model. ```dart // The generated `Address` class is an embedded object. @RealmModel(ObjectType.embeddedObject) class _Address {   late String street;   late String city;   late String state;   late String country; } @RealmModel() class _Person {   @PrimaryKey()   late String name;   // Embedded object in parent object schema   late _Address? address; // Must be nullable } \n``` You can use the [parent](https://pub.dev/documentation/realm/latest/realm/EmbeddedObjectExtension/parent.html)property to access the parent of the embedded object. The following example shows the unique considerations when working with embedded objects. The example uses the `Address` embedded object generated from the `_Address` `RealmModel` in the above schema. ```dart // Both parent and embedded objects in schema final realm = Realm(Configuration.local([Person.schema, Address.schema])); // Create an embedded object. final joesHome = Address(\"500 Dean Street\", \"Brooklyn\", \"NY\", \"USA\"); final joe = Person(\"Joe\", address: joesHome); realm.write(() => realm.add(joe)); // Update an embedded object property. realm.write(() {   joe.address?.street = \"800 Park Place\"; }); // Query a collection of embedded objects. // You must access the embedded object through the parent RealmObject type. final peopleWithNewYorkHomes = realm.query<Person>(\"address.state = 'NY'\"); // Overwrite an embedded object. // Also deletes original embedded object from realm. final joesNewHome = Address(\"12 Maple Way\", \"Toronto\", \"ON\", \"Canada\"); realm.write(() {   joe.address = joesNewHome; }); // You can access the parent object from an embedded object. final thePersonObject = joesNewHome.parent; // Delete embedded object from parent object.\n\n // Add address back for the following example. final anotherNewHome = Address(\"202 Coconut Court\", \"Miami\", \"FL\", \"USA\"); realm.write(() {   joe.address = anotherNewHome; }); // Deleting the parent object also deletes the embedded object. realm.write(() => realm.delete(joe)); \n``` ## Example The following model includes some supported data types. ```dart part 'car.g.dart'; @RealmModel() class _Car {   @PrimaryKey()   late ObjectId id;   String? licensePlate;   bool isElectric = false;   double milesDriven = 0;   late List<String> attributes;   late _Person? owner; } // The generated `Address` class is an embedded object. @RealmModel(ObjectType.embeddedObject) class _Address {   late String street;   late String city;   late String state;   late String country; } @RealmModel() class _Person {   @PrimaryKey()   late String name;   // Embedded object in parent object schema   late _Address? address; // Must be nullable } \n``` ← [Define a Realm Object Schema - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/ \"Previous Section\")[Relationships - Flutter SDK](https://mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/relationships/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/advanced/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Advanced Guides - Node.js SDK ## Realm-Database (Non-Sync) * [Encrypt a Realm](https://mongodb.com/docs/realm/sdk/node/advanced/encrypt/)\n* [Bundle a Realm](https://mongodb.com/docs/realm/sdk/node/advanced/bundle/) ## Application Services (Sync) * [Access Custom User Data](https://mongodb.com/docs/realm/sdk/node/advanced/access-custom-user-data/)\n* [Multi-User Applications](https://mongodb.com/docs/realm/sdk/node/advanced/multi-user-applications/)\n* [Link User Identities](https://mongodb.com/docs/realm/sdk/node/advanced/link-identities/)\n* [Client Reset Data Recovery](https://mongodb.com/docs/realm/sdk/node/advanced/client-reset-data-recovery/) ← [Quick Start with Electron using React](https://mongodb.com/docs/realm/sdk/node/integrations/electron-cra/ \"Previous Section\")[Access Custom User Data - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/access-custom-user-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/integrations/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Integrations - Node.js SDK * [Quick Start with Electron](https://mongodb.com/docs/realm/sdk/node/integrations/electron/)\n* [Quick Start with Electron using React](https://mongodb.com/docs/realm/sdk/node/integrations/electron-cra/) ← [Query MongoDB - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/query-mongodb/ \"Previous Section\")[Quick Start with Electron](https://mongodb.com/docs/realm/sdk/node/integrations/electron/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/install/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Install Realm for Node.js On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Installation](#installation)\n* [Create a Node.js Project](#create-a-node.js-project)\n* [Install Realm with NPM](#install-realm-with-npm)\n* [Enable TypeScript (optional)](#enable-typescript--optional-)\n* [IoT Installation](#iot-installation)\n* [Install a C++ Compiler](#install-a-c---compiler)\n* [Create a Node.js Project](#create-a-node.js-project-1)\n* [Install Realm with NPM](#install-realm-with-npm-1)\n* [Enable TypeScript (optional)](#enable-typescript--optional--1)\n* [Import Realm](#import-realm) ## Overview The Realm Node.js SDK enables development of applications using the JavaScript and [TypeScript](https://www.typescriptlang.org/) languages. Realm on Node.js is best suited for writing server-side applications. Your Node.js application could be one component in a wider stack that also includes iOS and Android apps. The Realm Node.js SDK is not suitable for front-end application development. * Due to limitations of the browser environment, it is not possible to build a browser-based web app with this SDK. For front-end web applications, use the Realm [Web SDK.](https://mongodb.com/docs/realm/web/#std-label-web-intro)\n* For cross-platform mobile app development, use the Realm [React Native SDK.](https://mongodb.com/docs/realm/sdk/react-native/install/) ## Prerequisites Before getting started, ensure your environment meets the following prerequisites: * [Node.js](https://nodejs.org/en/) version 12.x or later (including Node.js version 14)\n* Linux, macOS 10.8 (or later), or Windows 8 (or later) ## Installation Follow these steps to create a Node.js project and add the Realm Node.js SDK to it. 1 ### Create a Node.js Project Create your Node.js project by creating a new directory for your project and running `npm init` in that directory. In the example below, replace `MyRealmApp`with your desired project name. Answer all of the prompts to fill out the details of your project. `| mkdir MyRealmApp && cd MyRealmApp && npm init |\n| --------------------------------------------- | ` 2 ### Install Realm with NPM In your Node.js project directory, use the following command to add Realm to your project: ```bash npm install realm \n``` 3 ### Enable TypeScript (optional) TypeScript is a superset of JavaScript that adds static type checking and other features intended to make application-scale development more robust. If you'd like to use TypeScript, follow the TypeScript team's official[Node Starter guide](https://github.com/Microsoft/TypeScript-Node-Starter#typescript--node). Realm supports TypeScript natively and integrates easily into a TypeScript project. ## IoT Installation To create a Node.js project and add the Realm Node.js SDK on an Internet of Things (IoT) platform such as the Raspberry Pi 2, 3, or 4 running Raspberry Pi OS (formerly Raspbian), follow the steps below: 1 ### Install a C++ Compiler The Realm IoT SDK is not distributed as a binary, so you must build it from source. To do this, you'll need a working C++ compiler. To install such a compiler on your IoT device, run the following command: ```bash sudo apt install build-essential g++ libssl-dev \n``` 2 ### Create a Node.js Project Create your Node.js project by creating a new directory for your project and running `npm init` in that directory. In the example below, replace `MyRealmApp`with your desired project name. Answer all of the prompts to fill out the details of your project. ```bash mkdir MyRealmApp && cd MyRealmApp && npm init \n``` 3 ### Install Realm with NPM In your Node.js project directory, use the following command to add Realm to your project: ```bash npm install realm \n``` 4 ### Enable TypeScript (optional)\n\n ## Import Realm Add the following line to the top of your source files (JavaScript or TypeScript) where you want to use Realm: ```javascript import Realm from \"realm\"; \n``` ← [Realm Node.js SDK](https://mongodb.com/docs/realm/sdk/node/ \"Previous Section\")[Quick Start - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/quick-start/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/data-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Data Types - Node.js SDK * [Field Types](https://mongodb.com/docs/realm/sdk/node/data-types/field-types/)\n* [Collections](https://mongodb.com/docs/realm/sdk/node/data-types/collections/)\n* [Dictionaries](https://mongodb.com/docs/realm/sdk/node/data-types/dictionaries/)\n* [Sets](https://mongodb.com/docs/realm/sdk/node/data-types/sets/)\n* [Mixed](https://mongodb.com/docs/realm/sdk/node/data-types/mixed/)\n* [UUID](https://mongodb.com/docs/realm/sdk/node/data-types/uuid/)\n* [Embedded Objects](https://mongodb.com/docs/realm/sdk/node/data-types/embedded-objects/) ← [Atlas Device Sync - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/device-sync/ \"Previous Section\")[Field Types - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/field-types/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/user-metadata/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # User Metadata - Node.js SDK On this page * [Read a User's Metadata](#read-a-user-s-metadata)\n* [Configure User Metadata](#configure-user-metadata)\n* [Update User Metadata](#update-user-metadata) ## Read a User's Metadata You can read the [user metadata](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) of a currently logged-in user through that user's `User` object. You cannot edit user metadata through a `User` object. To read the data, access the `profile` property on the `User` object of a logged-in user: `| try {                                                                    |\n| ------------------------------------------------------------------------ |\n| await app.logIn(Realm.Credentials.<email>Password(<email>, <password>)); |\n| } catch (err) {                                                          |\n| console.error(\"Failed to log in\", err.message);                          |\n| }                                                                        |\n| const userEmail = app.currentUser.profile.email;                         | ` User metadata options vary depending on which provider you're using and[which metadata fields you enable.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-configure-user-metadata-on-the-backend) ## Warning ### User Metadata May Be Stale Atlas App Services fetches the most recent version of user metadata when a user logs in. If the user changes their email address or profile photo with a login provider, for example, those changes do not update in user metadata until the user logs in again. Because we cache credentials and enable you to bypass the login flow, user metadata may become stale unless you force the user to log in again. ## Configure User Metadata You can only read user metadata from the client app that you have configured on the App Services application. You can configure the [user metadata](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) you request from an authentication provider. You do this directly on the authentication provider's configuration. For more details on which metadata fields you can use, see the provider details: * OAuth 2.0 ([Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) & [Google)](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication)\n* [Custom JWT](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) You can change which metadata fields you have configured by [editing the provider's configuration.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-configure-user-metadata-on-the-backend) ## Update User Metadata User metadata that you access through the authentication provider is read-only data. You cannot update or edit user metadata that comes from this source.\n\n ← [Create and Delete Users - Node SDK](https://mongodb.com/docs/realm/sdk/node/examples/create-delete-users/ \"Previous Section\")[Authenticate Users - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/authenticate-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/connect-to-app-services-backend/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Connect to an Atlas App Services Backend - Node.js SDK The App client is the interface to the Atlas App Services backend. It provides access to the [authentication functionality](https://mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-authenticate-users), [functions](https://mongodb.com/docs/realm/sdk/node/examples/call-a-function/#std-label-node-call-a-function), and[sync management.](https://mongodb.com/docs/realm/sdk/node/examples/sync-changes-between-devices/#std-label-node-sync-changes-between-devices) ## Before You Begin 1. [Create an App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n2. [Install the Realm Node.js SDK](https://mongodb.com/docs/realm/sdk/node/install/#std-label-node-install) ## Access the App Client To connect to the App Services backend from your client, you need to create a[configuration object](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#~AppConfiguration). Then, pass that configuration object to a `Realm.App()` instance. You must include the `id` field and the App ID for your App Services App, which you can[find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) `| // Initialize your App.     |\n| --------------------------- |\n| const app = new Realm.App({ |\n| id: \"<yourAppId>\",          |\n| });                         | ` ## Retrieve an Instance of the App Client To retrieve an instance of the App Client from anywhere in your application, call [Realm.App.getApp()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#getApp) and pass in yourApp ID. ```javascript const app = Realm.App.getApp(\"<yourAppId>\"); \n``` ← [Modify an Object Schema - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/modify-an-object-schema/ \"Previous Section\")[Create and Delete Users - Node SDK](https://mongodb.com/docs/realm/sdk/node/examples/create-delete-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/quick-start/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start - Node.js SDK On this page * [Overview](#overview)\n* [Import Realm](#import-realm)\n* [Define Your Object Model](#define-your-object-model)\n* [Open a Realm](#open-a-realm)\n* [Create Realm Objects](#create-realm-objects)\n* [Find, Sort, and Filter Objects](#find--sort--and-filter-objects)\n* [Modify an Object](#modify-an-object)\n* [Delete an Object](#delete-an-object)\n* [Watch a Collection](#watch-a-collection)\n* [Close a Realm](#close-a-realm)\n* [Add Device Sync (Optional)](#add-device-sync--optional-)\n* [Prerequisites](#prerequisites)\n* [Initialize the App](#initialize-the-app)\n* [Authenticate a User](#authenticate-a-user)\n* [Define an Object Model](#define-an-object-model)\n* [Open a Synced Realm](#open-a-synced-realm) ## Overview This page contains information to quickly get Realm Database integrated into your app. If you haven't already, [install the Realm Node.js SDK.](https://mongodb.com/docs/realm/sdk/node/install/#std-label-node-install) ## Import Realm At the top of your source files where you want to use Realm, add the following line to import the SDK. `| import Realm from \"realm\"; |\n| -------------------------- | ` ## Define Your Object Model Your application's [object model](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas) defines the data that you can store within Realm Database. To define a Realm object type, create a schema object that specifies the type's`name` and `properties`. The type name must be unique among object types in a realm. For details on how to define specific properties, see [Define Object Properties.](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-define-a-property) The following code shows how to define an object model for a `Task` object. In this example: * The `primaryKey` is the `_id` of type `int`. Another common type used for primary keys is [ObjectId.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#objectId)\n* The `name` field is required.\n* The `status` and `onwer_id` fields are optional, denoted by the question mark immediately after the data type. ```javascript const TaskSchema = {   name: \"Task\",   properties: {     _id: \"int\",     name: \"string\",     status: \"string?\",     owner_id: \"string?\",   },   primaryKey: \"_id\", }; \n``` ## Open a Realm To open a realm, pass a [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object to [Realm.open().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open) ```javascript const realm = await Realm.open({   path: \"realm-files/myrealm\",   schema: [TaskSchema], }); \n``` ## Create Realm Objects Once you have opened a realm, you can create [objects](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-types) in it. All writes must occur within a [write transaction.](https://mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/#std-label-node-write-transactions) ```javascript // Add a couple of Tasks in a single, atomic transaction let task1, task2; realm.write(() => {   task1 = realm.create(\"Task\", {     _id: 1,     name: \"go grocery shopping\",     status: \"Open\",   });\n\n     _id: 2,     name: \"go exercise\",     status: \"Open\",   });   console.log(`created two tasks: ${task1.name} & ${task2.name}`); }); // use task1 and task2 \n``` ## Find, Sort, and Filter Objects The following code demonstrates how to: * Query for all instances of the \"Task\" object type.\n* Filter the query to retrieve only the tasks that are \"Open\".\n* Sort the tasks by the name in an ascending order. ```javascript // query realm for all instances of the \"Task\" type. const tasks = realm.objects(\"Task\"); console.log(`The lists of tasks are: ${tasks.map((task) => task.name)}`); // filter for all tasks with a status of \"Open\" const openTasks = tasks.filtered(\"status = 'Open'\"); console.log(   `The lists of open tasks are: ${openTasks.map(     (openTask) => openTask.name   )}` ); // Sort tasks by name in ascending order const tasksByName = tasks.sorted(\"name\"); console.log(   `The lists of tasks in alphabetical order are: ${tasksByName.map(     (taskByName) => taskByName.name   )}` ); \n``` ## Modify an Object As with writes, any changes to a Realm object must occur within a[Write transaction](https://mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/#std-label-node-write-transactions) block. To modify an object, you update the object properties: In the following example, an application developer updates `task1` from the[Create Realm Objects](#std-label-node-quickstart-local-create-realm-objects)example above. The developer begins progress on the \"go grocery shopping task\" and sets `task1` to \"InProgress\". ```javascript realm.write(() => {   task1.status = \"InProgress\"; }); \n``` ## Delete an Object You can delete an object by calling the [realm.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#delete) method within a write transaction block: In the following example, an application developer deletes `task1` from the[Create Realm Objects](#std-label-node-quickstart-local-create-realm-objects)example above. ```javascript realm.write(() => {   // Delete the task from the realm.   realm.delete(task1);   // Discard the reference.   task1 = null; }); \n``` ## Watch a Collection You can [watch a realm, collection, or object for changes](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-change-notifications) by registering event handlers with the[Realm.addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#addListener) [Object.addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#addListener) [Collection.addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#addListener)methods. In the following example, an application developer watches for changes to the`Task` collection. ```javascript // Define the collection notification listener function listener(tasks, changes) {   // Update UI in response to deleted objects   changes.deletions.forEach((index) => {     // Deleted objects cannot be accessed directly,     // but we can update a UI list, etc. knowing the index.     console.log(`A task was deleted at the ${index} index`);   });   // Update UI in response to inserted objects   changes.insertions.forEach((index) => {     let insertedTasks = tasks[index];     console.log(       `insertedTasks: ${JSON.stringify(insertedTasks, null, 2)}`     );     // ...   });   // Update UI in response to modified objects   // `newModifications` contains object indexes from after they were modified\n\n     let modifiedTask = tasks[index];     console.log(`modifiedTask: ${JSON.stringify(modifiedTask, null, 2)}`);     // ...   }); } // Observe collection notifications. tasks.addListener(listener); \n``` ## Close a Realm Call the [realm.close()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#close) method when done with a realm instance to avoid memory leaks. ```javascript // Remember to close the realm realm.close(); \n``` ## Add Device Sync (Optional) This section illustrates how to authenticate with an Anonymous User and open a Flexible Sync realm to sync data between devices. ### Prerequisites * [An App Services App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) enabled in the App Services UI\n* [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) enabled with [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)on and an `owner_id` field in the Queryable Fields section ### Initialize the App To use App Services features, such as authentication and sync, you must first access your App Services App using your App ID. You can [find your App ID](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id)in the App Services UI. ```javascript // Initialize your App. const app = new Realm.App({   id: \"<yourAppId>\", }); \n``` ### Authenticate a User To authenticate and log in a user, call [App.logIn()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#logIn). When [anonymous authentication](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) is enabled, users can immediately log into your app without providing any identifying information: ```javascript // Initialize your App. const app = new Realm.App({   id: \"<yourAppId>\", }); // Authenticate an anonymous user. await app.logIn(Realm.Credentials.anonymous()); \n``` ### Define an Object Model Object models for synced realms work the same way as [local-only Realms](#std-label-node-quickstart-local-define-an-object-model). Define your object model just as you would for a local-only Realm. ```javascript const TaskSchema = {   name: \"Task\",   properties: {     _id: \"int\",     name: \"string\",     status: \"string?\",     owner_id: \"string?\",   },   primaryKey: \"_id\", }; \n``` ### Open a Synced Realm After you have initialized your App, authenticated a user, and defined your object model, you can create a [SyncConfiguration.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) To open a Flexible Sync realm, call [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open). Pass in a [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration)object, which must include the `sync` property defining a[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) object. To use Flexible Sync, in the SyncConfiguration, you must include include a`user` and `flexible: true`.\n\n ```javascript // Initialize your App. const app = new Realm.App({   id: \"<yourAppId>\", }); // Authenticate an anonymous user. await app.logIn(Realm.Credentials.anonymous()); // Define an object model const TaskSchema = {   name: \"Task\",   properties: {     _id: \"int\",     name: \"string\",     status: \"string?\",     progressMinutes: \"int?\",     owner: \"string?\",     dueDate: \"date?\",   },   primaryKey: \"_id\", }; // Create a `SyncConfiguration` object. const config = {   schema: [TaskSchema],   sync: {     // Use the previously-authenticated anonymous user.     user: app.currentUser,     // Set flexible sync to true to enable sync.     flexible: true,     // Define initial subscriptions to start syncing data as soon as the     // realm is opened.     initialSubscriptions: {       update: (subs, realm) => {         subs.add(           // Get objects that match your object model, then filter them           // the `owner_id` queryable field           realm.objects(\"Task\").filtered(`owner_id = ${app.currentUser.id}`)         );       },     },   }, }; const realm = await Realm.open(config); \n``` The syntax to [read](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/#std-label-node-read-operations), [write](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/#std-label-node-write-operations), and [watch for changes](https://mongodb.com/docs/realm/sdk/node/examples/react-to-changes/#std-label-node-react-to-changes) on a synced realm is identical to the syntax for non-synced realms above. While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. ← [Install Realm for Node.js](https://mongodb.com/docs/realm/sdk/node/install/ \"Previous Section\")[Realm Fundamentals - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/create-delete-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create and Delete Users - Node SDK On this page * [Create a User](#create-a-user)\n* [Delete a User](#delete-a-user) ## Create a User For most [authentication methods](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), Realm automatically creates a [user account](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) the first time a user authenticates. The only exception is email/password authentication. When you use email/password authentication, you must [register](https://mongodb.com/docs/realm/sdk/node/examples/manage-email-password-users/#std-label-node-register-new-user) and [confirm](https://mongodb.com/docs/realm/sdk/node/examples/manage-email-password-users/#std-label-node-complete-confirmation) a user before the user can authenticate to a Realm application. ## Delete a User _New in version 10.13.0_. Call the [App.deleteUser()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#deleteUser) on a user object to delete the user's account from your Realm application. This deletes the account from the server in addition to clearing local data. `| await app.deleteUser(app.currentUser); |\n| -------------------------------------- | ` To use your app in the future, the user must sign up for a new account. They can use the same credentials (depending on the authentication provider), but will not have the same User ID as their deleted account. ## Important ### Deleting All User Data Deleting a user only deletes the [user object](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects), which may contain associated metadata from the associated auth provider. This does not delete [custom user data](https://mongodb.com/docs/realm/sdk/node/advanced/access-custom-user-data/#std-label-node-access-custom-user-data)or other user data that your app stores in a linked collection or external services. Use the [Authentication Trigger DELETE event](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-event-operation-types)to programmatically clean up other data when you delete a user. For example, you can delete the user's data from your custom user data collection or another service. ← [Connect to an Atlas App Services Backend - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/connect-to-app-services-backend/ \"Previous Section\")[User Metadata - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/user-metadata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Open & Close a Realm - Node.js SDK On this page * [Open a Local Realm](#open-a-local-realm)\n* [Open an In-Memory Realm](#open-an-in-memory-realm)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Open a Flexible Synced Realm](#open-a-flexible-synced-realm)\n* [Open a Partition-Based Synced Realm](#open-a-partition-based-synced-realm)\n* [Open a Synced Realm While Offline](#open-a-synced-realm-while-offline)\n* [Open Immediately with Background Sync](#open-immediately-with-background-sync)\n* [Open After Timeout with Background Sync](#open-after-timeout-with-background-sync)\n* [Copy Data and Open a New Realm](#copy-data-and-open-a-new-realm)\n* [Close a Realm](#close-a-realm) ## Open a Local Realm To open a local (non-synced) realm, pass a [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object to the asynchronous method [Realm.open().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open) ## Note ### Accessing the Default Realm Path If the `path` property is not specified in your `Configuration` object, the default path is used. You can access and change the default Realm path using the `Realm.defaultPath` global property.\n\n ` ### Open an In-Memory Realm To create a realm that runs entirely in memory without being written to a file, add `inMemory: true` to your [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object: ```javascript const realm = await Realm.open({   inMemory: true,   schema: [Car], }); \n``` ## Note In-memory realms may use disk space if memory is running low, but files created by an in-memory realm are deleted when you close the realm. ## Open a Synced Realm You can open a Synced realm with a Flexible Sync or Partition-Based Sync. If you have not yet decided or are unsure which to use, read the [Choose Your Sync Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-sync-modes) page. By default, Realm syncs all data from the server before returning. If you want to sync data in the background, read the [Open a Synced Realm While Offline](#std-label-node-open-synced-realm-offline) section. ### Open a Flexible Synced Realm To open a realm using Flexible Sync, call [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open). Pass in a [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration)object, which must include the `sync` property defining a[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) object. In the SyncConfiguration, you must include include a `user` and `flexible:true`. ```javascript const realm = await Realm.open({   schema: [TaskSchema, TeamSchema],   sync: {     user: app.currentUser,     flexible: true,   }, }); \n``` ## Important ### Flexible Sync Requires a Subscription You can't use a Flexible Sync realm until you add at least one subscription. To learn how to add subscriptions, see: [Add a Query to the List Of Subscriptions.](https://mongodb.com/docs/realm/sdk/node/examples/flexible-sync/#std-label-node-sync-add-subscription) ### Open a Partition-Based Synced Realm To open a realm with Partition-Based Sync, call [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open). Pass in a [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration)object, which must include the `sync` property defining a[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) object. In the SyncConfiguration, you must include include `user` and `partitionValue`. ```javascript const config = {   schema: [Car], // predefined schema   sync: {     user: app.currentUser, // already logged in user     partitionValue: \"myPartition\",   }, }; try {   const realm = await Realm.open(config);   realm.close(); } catch (err) {   console.error(\"failed to open realm\", err.message); } \n``` ## Open a Synced Realm While Offline When your Realm application authenticates a user, it caches the user's credentials. You can check for existing user credentials to bypass the login flow and access the cached user. Use this to open a realm offline. ## Note ### Initial login requires a network connection When a user signs up for your app, or logs in for the first time with an existing account on a client, the client must have a network connection. Checking for cached user credentials lets you open a realm offline, but only if the user has previously logged in while online. ```javascript // Log the user into the backend app. // The first time you login, the user must have a network connection. const getUser = async () => {   // Check for an existing user.   // If the user is offline but credentials are\n\n   if (app.currentUser) return app.currentUser;   // If the device has no cached user credentials, log them in.   const credentials = Realm.Credentials.anonymous();   return await app.logIn(credentials); }; \n``` The following subsections show how to use background synchronization to access a realm while offline. To do this, use the cached user and an[OpenRealmBehaviorConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~OpenRealmBehaviorConfiguration) object. Within your Sync Configuration, set the optional `newRealmFileBehavior` and`existingRealmFileBehavior` fields to your `OpenRealmBehaviorConfiguration` object to enable background synchronization. ## Important ### Offline Login is Supported for Both Flexible and Partition-Based Sync Configurations You can open a realm immediately with background sync or after a timeout elapses using either Flexible and Partition-Based Sync. ### Open Immediately with Background Sync If the user's device is not connected to the internet or you're uncertain of it's connection status, set the realm behavior's type to `openImmediately`. This syncs data from the server in the background. ```javascript const openRealmBehaviorConfig = {   type: \"openImmediately\", }; const config = {   schema: [Car], // predefined schema   sync: {     user: await getUser(),     partitionValue: \"myPartition\",     newRealmFileBehavior: openRealmBehaviorConfig,     existingRealmFileBehavior: openRealmBehaviorConfig,   }, }; \n``` ### Open After Timeout with Background Sync If you want to sync data but you're in an environment where it's uncertain if the user has an Internet connection, specify a `timeOut`. This automatically opens the realm when either: * the timeout period elapses.\n* the realm has completely downloaded. If the realm doesn't finish downloading before the timeout, the initial realm sync continues in the background. ```javascript const openRealmBehaviorConfig = {   type: \"downloadBeforeOpen\",   timeOut: 1000,   timeOutBehavior: \"openLocalRealm\", }; const config = {   schema: [Car], // predefined schema   sync: {     user: await getUser(), // already logged in user     partitionValue: \"myPartition\",     existingRealmFileBehavior: openRealmBehaviorConfig,     newRealmFileBehavior: openRealmBehaviorConfig,   }, }; \n``` ## Copy Data and Open a New Realm _New in version 10.14.0_. To copy data from an existing realm to a new realm with different configuration options, pass the new configuration the[Realm.writeCopyTo()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#writeCopyTo) method. ## Note ### Partition-Based Sync Only This method only supports Partition-Based Sync. If your app uses Flexible Sync, you must manually iterate through the objects in one realm and copy them into the other realm. In the new realm's configuration, you _must_ specify the `path`. If you write the copied realm to a realm file that already exists, the data is written object by object. The copy operation replaces objects if there already exists objects for given primary keys. The schemas of the realm you copy and the realm you are writing to must be compatible for the copy operation to succeed. Only objects in the schemas of both configurations are copied over. The configuration change can include modifications to [SyncConfiguration:](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) * Local realm to synced realm\n* Synced Realm to local realm The configuration change can also include changes to `encryptionKey`property of the `Configuration`: * Encrypted realm to unencrypted realm\n* Unencrypted realm to encrypted realm ## Example ### Convert Local Realm to Synced Realm ```javascript const localConfig = {   schema: [Car],   path: \"localOnly.realm\", }; const localRealm = await Realm.open(localConfig); const syncedConfig = {   schema: [Car], // predefined schema   path: \"copyLocalToSynced.realm\", // must include in output configuration   sync: {     user: app.currentUser, // already logged in user\n\n   }, }; localRealm.writeCopyTo(syncedConfig); const syncedRealm = await Realm.open(syncedConfig); \n``` You can also combine changes to configuration. For example, you can open a local encrypted realm as a synced unencrypted realm or a unencrypted synced realm as an encrypted synced realm. ## Example ### Convert Synced Encrypted to Local Unencrypted Realm ```javascript const encryptionKey = new Int8Array(64); // Create a secure key // ... store key ... const syncedEncryptedConfig = {   schema: [Car], // predefined schema   path: \"syncedEncrypted.realm\", // must include in output configuration   sync: {     user: app.currentUser, // already logged in user     partitionValue: \"myPartition\",   },   encryptionKey, }; const syncedEncryptedRealm = await Realm.open(syncedEncryptedConfig); const localUnencryptedConfig = {   schema: [Car], // predefined schema   path: \"copyLocalUnencrypted.realm\", // must include in output configuration }; syncedEncryptedRealm.writeCopyTo(localUnencryptedConfig); const localUnencryptedRealm = await Realm.open(syncedEncryptedConfig); \n``` ## Tip ### See also:  * [Open a Flexible Synced Realm - Node.js SDK](#std-label-node-flexible-sync-open-realm)\n* [Open a Partition-Based Synced Realm - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/encrypt/#std-label-node-encrypt-a-realm)\n* [Encrypt a Realm - Node.js SDK](#std-label-node-partition-sync-open-realm) ## Close a Realm It is important to remember to call the `close()` method when done with a realm instance to avoid memory leaks. ```javascript realm.close(); \n``` ← [Define a Realm Object Schema - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/ \"Previous Section\")[Read & Write Data - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/manage-email-password-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manage Email/Password Users - Node.js SDK On this page * [Register a New User Account](#register-a-new-user-account)\n* [Confirm a New User's Email Address](#confirm-a-new-user-s-email-address)\n* [Complete a User Confirmation](#complete-a-user-confirmation)\n* [Retry User Confirmation Methods](#retry-user-confirmation-methods)\n* [Resend a Confirmation Email](#resend-a-confirmation-email)\n* [Retry a User Confirmation Function](#retry-a-user-confirmation-function)\n* [Reset a User's Password](#reset-a-user-s-password)\n* [Send a Password Reset Email](#send-a-password-reset-email)\n* [Call a Password Reset Function](#call-a-password-reset-function)\n* [Complete a Password Reset](#complete-a-password-reset) ## Register a New User Account To register a new email/password user, pass the user's email address and desired password to [EmailPasswordAuth.registerUser()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#registerUser). The email address must not be associated with another email/password user and the password must be between 6 and 128 characters. `| await app.emailPasswordAuth.registerUser({ |\n| ------------------------------------------ |\n| email: \"someone@example.com\",              |\n| password: \"passw0rd\",                      |\n| });                                        | ` ## Note ### Confirm New Users You must [confirm a new user's email address](#std-label-node-confirm-user) before they can log in to your app. ## Confirm a New User's Email Address New users must confirm that they own their email address before they can log in to your app unless the provider is configured to [automatically confirm new users.](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-automatically-confirm-users) ### Complete a User Confirmation You need a valid `token` and `tokenId` for a registered user in order to confirm them and allow them to log in. These values are available in different places depending on the provider configuration: * If the provider is set to [send a confirmation email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-confirmation-email), the `token` and `tokenId` values are included as query parameters in the Email Confirmation URL.\n* If the provider is set to [run a confirmation function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-confirmation-function), the `token` and `tokenId` values are passed to the function as arguments. To confirm a registered user, pass a valid `token` and `tokenId` to[EmailPasswordAuth.confirmUser().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#confirmUser) ```javascript const token = \"someToken\"; const tokenId = \"someTokenId\"; try {   await app.emailPasswordAuth.confirmUser({ token, tokenId });   // User email address confirmed.   console.log(\"Successfully confirmed user.\"); } catch (err){   console.log(`User confirmation failed: ${err}`); } \n``` ## Retry User Confirmation Methods The SDK provides methods to resend user confirmation emails or retry custom confirmation methods. ### Resend a Confirmation Email\n\n To send a new confirmation email to a user, pass their email address to[EmailPasswordAuth.resendConfirmationEmail().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#resendConfirmationEmail) ```javascript const email = \"someone@example.com\"; await app.emailPasswordAuth.resendConfirmation({ email }); \n``` ### Retry a User Confirmation Function To re-run your [custom confirmation function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-confirmation-function), call the `retryCustomConfirmation()` method with the user's email address: ```javascript const email = \"someone@example.com\"; await app.emailPasswordAuth.retryCustomConfirmation({ email }); \n``` ## Reset a User's Password ### Send a Password Reset Email To [send a password reset email](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-send-a-password-reset-email) (if the provider is configured to do so), call[EmailPasswordAuth.sendResetPasswordEmail()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#sendResetPasswordEmail). The email contains a link to the configured Password Reset URL. ```javascript const email = \"someone@example.com\" await app.emailPasswordAuth.sendResetPasswordEmail({ email }); \n``` ### Call a Password Reset Function To [run a password reset function](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function) (if the provider is configured to do so), pass the user's email address, new password, and any additional function arguments to[EmailPasswordAuth.callResetPasswordFunction().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#callResetPasswordFunction) ```javascript const email = \"someone@example.com\"; // The new password to use const password = \"newPassw0rd\"; // Additional arguments for the reset function const args = []; await app.emailPasswordAuth.callResetPasswordFunction({ email, password }, args); \n``` ### Complete a Password Reset Once a user requests a password reset, either by [sending a password reset email](#std-label-node-send-password-reset-email) or [calling a password reset function](#std-label-node-call-password-reset-function), Realm generates a pair of unique`token` and `tokenId` values that they can use to complete the password reset within 30 minutes of the initial request. To complete the password reset, pass the `token`, `tokenId`, and new password to [EmailPasswordAuth.resetPassword().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.EmailPasswordAuth.html#resetPassword) ```javascript await app.emailPasswordAuth.resetPassword({ password: \"newPassw0rd\", token, tokenId }); \n``` ← [Call a Function - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/call-a-function/ \"Previous Section\")[Create & Manage User API Keys - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/manage-user-api-keys/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/sync-changes-between-devices/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sync Changes Between Devices - Node.js SDK On this page * [Prerequisites](#prerequisites)\n* [Sync Changes in the Background](#sync-changes-in-the-background)\n* [Pause or Resume a Sync Session](#pause-or-resume-a-sync-session)\n* [When to Pause a Sync Session](#when-to-pause-a-sync-session)\n* [Check Upload & Download Progress for a Sync Session](#check-upload---download-progress-for-a-sync-session)\n* [Check the Network Connection](#check-the-network-connection)\n* [Set the Client Log Level](#set-the-client-log-level)\n* [Multiplex Sync Sessions](#multiplex-sync-sessions)\n* [Handle Sync Errors](#handle-sync-errors)\n* [Perform a Client Reset](#perform-a-client-reset) ## Prerequisites Before you can access a synced realm from the client, you must: 1. [Enable sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) in the App Services UI.\n2. [Initialize the app](https://mongodb.com/docs/realm/sdk/node/quick-start/#std-label-node-quick-start-init-app)\n3. [Authenticate a user](https://mongodb.com/docs/realm/sdk/node/quick-start/#std-label-node-quick-start-authenticate) in your client project.\n4. [Open a Flexible Synced Realm](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-flexible-sync-open-realm)or [Open a Partition-Based Synced Realm](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-partition-sync-open-realm) ## Note ### Sync method in the examples on this page The examples on this page use **Partition-Based Sync** with the[firehose partition strategy](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-strategy-firehose). This means that data is synced to the clients of all users with the same static partition value. In the examples on this page, the static partition value is `MyPartitionValue`. All realms with the partition `MyPartitionValue`have access to any document with a matching partition value. The realm's [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object includes a [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) with`partitionValue: \"MyPartitionValue\"`. Configuration `| const config = {                          |\n| ----------------------------------------- |\n| schema: [DogSchema], // predefined schema |\n| sync: {                                   |\n| user: app.currentUser,                    |\n| partitionValue: \"MyPartitionValue\",       |\n| ...rest of SyncConfiguration              |\n| },                                        |\n| };                                        | `\n\n ## Sync Changes in the Background You may want to sync changes in the background to display partial data to the user while the synced realm downloads data from the server, preventing the user experience from being blocked. We recommend syncing changes in the background for applications in which the user's device may go offline. To sync changes in the background, open a synced realm synchronously. Create a [OpenRealmBehaviorConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~OpenRealmBehaviorConfiguration) object and set its`type` to `\"openImmediately\"`. ```javascript const OpenRealmBehaviorConfiguration = {   type: \"openImmediately\", }; \n``` Create a [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object, which must include the `sync` property defining a [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) object. Set this`OpenRealmBehaviorConfiguration` object as the value for the `newRealmFileBehavior` and `existingRealmFileBehavior` fields of the`SyncConfiguration`. ```javascript const config = {   schema: [DogSchema], // predefined schema   sync: {     user: app.currentUser,     partitionValue: \"MyPartitionValue\",     // The behavior to use when this is the first time opening a realm.     newRealmFileBehavior: OpenRealmBehaviorConfiguration,     // The behavior to use when a realm file already exists locally,     // i.e. you have previously opened the realm.     existingRealmFileBehavior: OpenRealmBehaviorConfiguration,   }, }; \n``` Finally, call [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open)to open a synced realm. This will create a sync session and begin downloading any existing data from the server in the background. ```javascript const realm = await Realm.open(config); \n``` ## Pause or Resume a Sync Session Opening a synced realm starts a [sync session](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html). You can pause and resume the sync session on the realm. Pausing a sync session only pauses that realm's sync session. If you have more than one open realm, pause does not affect the sync sessions for other realms. To pause synchronization, use the [syncSession.pause()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#~pause) method. To resume synchronization, use the[syncSession.resume()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#~resume) method. ```javascript const OpenRealmBehaviorConfiguration = {   type: \"openImmediately\", }; var config = {   schema: [DogSchema], // predefined schema   sync: {     user: app.currentUser,     partitionValue: \"MyPartitionValue\",     newRealmFileBehavior: OpenRealmBehaviorConfiguration,     existingRealmFileBehavior: OpenRealmBehaviorConfiguration,   }, }; let realm = await Realm.open(config); const syncSession = realm.syncSession; // Pause synchronization syncSession.pause(); // Later, resume synchronization syncSession.resume(); \n``` ### When to Pause a Sync Session For most applications, there is no need to manually pause and resume a sync session. However, there are a few circumstances under which you may want to pause or suspend a sync session: * You only want to sync after the user takes a specific action\n* You only want to sync during a certain time of the day\n* You don't want to attempt to sync when there is poor network connectivity\n* You want to explicitly force a sync session to connect In the case of poor network connectivity, continually trying to establish a network connection can drain the user's device battery.\n\n When you do pause a sync session, keep these things in mind: * If the client may be offline longer than the [client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), the client will be unable to resume syncing and must perform a [client reset.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets)\n* Pausing a sync session pauses it in both directions. Changes that your app makes on the device do not sync with the backend, _and_ changes to the data in the backend or on other devices do not sync to the device. There is no way to pause only uploads or pause only downloads.\n* Do not pause a sync session if you want a client to permanently stop syncing with the backend. To permanently stop syncing, copy the contents of the synced realm into a non-synced realm, and use the non-synced realm in the client. _Do not_ pause sync to stop syncing for indefinite time periods or time ranges in months and years. The functionality is not designed or tested for these use cases. You could encounter a range of issues when using it this way. ## Check Upload & Download Progress for a Sync Session To check the upload and download progress for a sync session, add a progress notification using the [syncSession.addProgressNotification()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#.addProgressNotification) method. The `syncSession.addProgressNotification()` method takes in the following three parameters: * A `direction` parameter. Set to `\"upload\"` to register notifications for uploading data. Set to `\"download\"` to register notifications for downloading data.\n* A `mode` parameter. Set to `\"reportIndefinitely\"`for the notifications to continue until the callback is unregistered using[syncSession.removeProgressNotification()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#.removeProgressNotification). Set to `\"forCurrentlyOutstandingWork\"` for the notifications to continue until only the currently transferable bytes are synced.\n* A callback function parameter that has the arguments `transferred` and `transferable`.`transferred` is the current number of bytes already transferred.`transferable` is the total number of bytes already transferred plus the number of bytes pending transfer. ## Note Flexible Sync progress notifications are not yet fully supported. When using Flexible Sync, downloads only report notifications after changes are integrated. Partition-Based Sync provides ongoing notifications as changes progress downloading. Uploads report ongoing progress notifications for both Sync Modes. ## Example In the following example, an application developer registers a callback on the `syncSession` to listen for upload events indefinitely. The developer writes to the realm and then unregisters the `syncSession` notification callback. ```javascript const OpenRealmBehaviorConfiguration = {   type: \"openImmediately\", }; var config = {   schema: [DogSchema], // predefined schema   sync: {     user: app.currentUser,     partitionValue: \"MyPartitionValue\",     newRealmFileBehavior: OpenRealmBehaviorConfiguration,     existingRealmFileBehavior: OpenRealmBehaviorConfiguration,   }, }; let realm = await Realm.open(config); const syncSession = realm.syncSession; syncSession.addProgressNotification(   \"upload\",   \"reportIndefinitely\",   (transferred, transferable) => {     console.log(`${transferred} bytes has been transferred`);     console.log(       `There are ${transferable} total transferable bytes, including the ones that have already been transferred`     );   } ); // Upload something let dog; realm.write(() => {   dog = realm.create(\"Dog\", {     name: \"Fido\",     age: 2,   }); }); // use dog // remember to unregister the progress notifications syncSession.removeProgressNotification((transferred, transferable) => {   console.log(`There was ${transferable} total transferable bytes`);\n\n }); \n``` ## Check the Network Connection To check the current state of the connection to the server, call the[syncSession.connectionState()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html#.connectionState) method. ## Tip Realm's _offline-first_ design means that you generally don't need to check the current network connection state. That said, the`syncSession.connectionState()` method is available if your app needs to gets the current state of the connection to the server. ```javascript var config = {   schema: [DogSchema], // predefined schema   sync: {     user: app.currentUser,     partitionValue: \"MyPartitionValue\",   }, }; let realm = await Realm.open(config); const syncSession = realm.syncSession; const connectionState = syncSession.connectionState(); \n``` ## Set the Client Log Level You can set the realm Sync client [log level](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~LogLevel) by calling[Realm.App.Sync.setLogLevel()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#.setLogLevel) with your [Realm.App.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html) ## Example In the following example, an application developer sets the sync client log level to `\"debug\"`. ```javascript Realm.App.Sync.setLogLevel(app, \"debug\"); \n``` ## Tip To diagnose and troubleshoot errors while developing your application, set the log level to `debug` or `trace`. For production deployments, decrease the log level for improved performance. ## Multiplex Sync Sessions Enable [session multiplexing](https://en.wikipedia.org/wiki/Session%5Fmultiplexing) to consolidate multiple sync sessions of a Realm app. Only use session multiplexing if you see errors about reaching the file descriptor limit, and you know you are using many sync sessions. To enable session multiplexing, call [Realm.App.Sync.enableSessionMultiplexing()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#.enableSessionMultiplexing) with your [Realm.App.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html) ## Example ```javascript Realm.App.Sync.enableSessionMultiplexing(app); \n``` ## Handle Sync Errors While developing an application that uses Device Sync, you should set an error handler. This error handler will detect and respond to any failed sync-related API calls. Set an error handler by registering an error callback as part of the [SyncConfiguration.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration) ```javascript var config = {   schema: [DogSchema], // predefined schema   sync: {     user: app.currentUser,     partitionValue: \"MyPartitionValue\",     error: (_session, error) => {       (error) => {         console.log(error.name, error.message);       };     },   }, }; const realm = await Realm.open(config); \n``` ## Tip For a list of common Device Sync errors and how to handle them, refer to[Sync Errors](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/#std-label-sync-errors) in the App Services Device Sync documentation. ## Perform a Client Reset You can customize behavior in the event of a [client reset](https://mongodb.com/docs/realm/sdk/node/examples/reset-a-client-realm/#std-label-node-client-resets) error with a custom error handler function: ```javascript let realm = await Realm.open(config); function errorSync(_session, error) {   if (realm) {     if (error.name === \"ClientReset\") {\n\n       realm.close();       console.log(`Error ${error.message}, need to reset ${realmPath}…`);       Realm.App.Sync.initiateClientReset(app, realmPath); // pass your realm app instance, and realm path to initiateClientReset()       console.log(`Creating backup from ${error.config.path}…`);       // Move backup file to a known location for a restore       fs.renameSync(error.config.path, realmPath + \"~\");       // Discard the reference to the realm instance       realm = null;     } else {       console.log(`Received error ${error.message}`);     }   } } var config = {   schema: [DogSchema], // predefined schema   sync: {     user: app.currentUser,     partitionValue: \"MyPartitionValue\",     error: errorSync,   }, }; \n``` ## Tip To see how to recover unsynced local changes in a client reset, check out this [example on GitHub.](https://github.com/mongodb/realm-practice/blob/main/node/index.js#L49) ← [Authenticate Users - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/authenticate-users/ \"Previous Section\")[Flexible Sync - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/flexible-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/modify-an-object-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Modify an Object Schema - Node.js SDK On this page * [Add a Property](#add-a-property)\n* [Delete a Property](#delete-a-property)\n* [Rename a Property](#rename-a-property)\n* [Modify a Property Type](#modify-a-property-type) ## Note ### Modify Schema Properties of a Synced Realm The following page demonstrates how to modify schema properties of a local realm. Learn how to [modify schema properties of a synced realm.](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) ## Tip ### Bypass Migration During Development When developing or debugging your application, you may prefer to delete the realm instead of migrating it. Use the`deleteRealmIfMigrationNeeded` flag to delete the database automatically when a schema mismatch would require a migration. Never release an app to production with this flag set to `true`. ## Add a Property To add a property to a schema, add the new property to the object's class and set a `schemaVersion` of the [realm's configuration object.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) ## Example A realm using schema version `1` has a `Person` object type with a`firstName`, and `lastName` property. The developer decides to add an`age` property to the `Person` class. To migrate the realm to conform to the updated `Person` schema, the developer sets the realm's [schema version](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/#std-label-node-schema-version) to`2`. ## Delete a Property To delete a property from a schema, remove the property from the object's class and set a `schemaVersion` of the [realm's configuration object](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration). Deleting a property will not impact existing objects. ## Example A realm using schema version `1` has a `Dog` object type with a`weight` property. The developer decides to remove the property from the schema. To migrate the realm to conform to the updated `Dog` schema, the developer sets the realm's [schema version](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/#std-label-node-schema-version) to`2`. ## Rename a Property To rename an object property, change the property name in the object schema and then open the realm with an incremented [schema version](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/#std-label-node-schema-version) and a [migration](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/#std-label-node-migrations) function that updates existing objects to use the new property name. Migrations do not allow you to directly rename a property. Instead you can create a new property with the updated name, copy the value from the old property, and then delete the old property. ## Example A realm using schema version `1` has a `Person` object type. The original schema had a `firstName` and `lastName` field. The developer later decides that the `Person` class should use a combined `fullName`field and removes the separate `firstName` and `lastName` fields. To migrate the realm to conform to the updated `Person` schema, the developer sets the realm's [schema version](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/#std-label-node-schema-version) to`2` and defines a migration function to set the value of `fullName` based on the existing `firstName` and `lastName` properties. ## Important ### Synced Realms\n\n ## Modify a Property Type To modify a property's type, set the property type of the field that you wish to modify to the new data type. Then, set a `schemaVersion`, and a `migration`callback function of the [realm's configuration Object.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) ## Note [Synchronized realms](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) only support non-breaking changes, to ensure that older clients can sync with newer clients. This means that synchronized realms do not support modifying the type of a property of a schema. ## Example A realm using schema version `1` has a `Dog` object type. The original schema had an `_id` with a property type of `Object ID`. The developer later decides that the `Dog` class's `_id` field should be of type `string`, and updates the schema. To migrate the realm to conform to the updated `Dog` schema, the developer sets the realm's [schema version](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/#std-label-node-schema-version) to`2` and defines a migration function to convert the `Object ID` type to a`string` type. ← [Query Data - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/query-data/ \"Previous Section\")[Connect to an Atlas App Services Backend - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/connect-to-app-services-backend/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/query-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query Data - Node.js SDK On this page * [Examples on This Page](#examples-on-this-page)\n* [Construct a Query](#construct-a-query)\n* [Operators](#operators)\n* [Comparison Operators](#comparison-operators)\n* [Logical Operators](#logical-operators)\n* [String Operators](#string-operators)\n* [Aggregate Operators](#aggregate-operators)\n* [Collection Operators](#collection-operators)\n* [Summary](#summary) To filter data in your Realms, construct queries with Realm Query Language. For more information about syntax, usage and limitations, refer to the [Realm Query Language reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Examples on This Page The examples in this page use a simple data set for a task list app. The two Realm object types are `Project`and `Task`. A `Task` has a name, assignee's name, and completed flag. There is also an arbitrary number for priority (higher is more important) and a count of minutes spent working on it. A `Project` has zero or more`Tasks`. See the schema for these two classes, `Project` and`Task`: `| const TaskSchema = {    |\n| ----------------------- |\n| name: \"Task\",           |\n| properties: {           |\n| name: \"string\",         |\n| isComplete: \"bool\",     |\n| priority: \"int\",        |\n| progressMinutes: \"int\", |\n| assignee: \"string?\"     |\n| }                       |\n| };                      |\n| const ProjectSchema = { |\n| name: \"Project\",        |\n| properties: {           |\n| name: \"string\",         |\n| tasks: \"Task[]\"         |\n| }                       |\n| };                      | ` ## Construct a Query To filter data, pass a query made with Realm Query Language to[Realm.Results.filtered()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Results.html#filtered) ```js const tasks = realm.objects(\"Task\"); // Gets all tasks where the 'priority' property is 7 or more. const importantTasks = tasks.filtered(\"priority >= 7\"); \n``` ## Operators There are several types of operators available to filter a[Realm collection](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-results-collections). Filters work by **evaluating** an operator expression for every object in the collection being filtered. If the expression resolves to `true`, Realm Database includes the object in the results collection. An **expression** consists of one of the following: * The name of a property of the object currently being evaluated.\n* An operator and up to two argument expression(s).\n* A literal string, number, or date. ### Comparison Operators The most straightforward operation in a search is to compare values. Realm Query Language has standard comparison operators like `==`,`>`, `>=`, `in`, `<`, `<=`, and `!=`. For complete documentation on comparison operators, refer to the [Realm Query Language comparison operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-comparison-operators) The following example uses the query engine's comparison operators to:\n\n ```javascript const highPriorityTasks = tasks.filtered(\"priority > 5\"); const unassignedTasks = tasks.filtered(\"assignee == null\"); const lowProgressTasks = tasks.filtered(\"1 <= progressMinutes && progressMinutes < 10\"); const aliTasks = tasks.filtered(\"assignee == 'Ali'\"); console.log(   `Number of high priority tasks: ${highPriorityTasks.length}`,   `Number of unassigned tasks: ${unassignedTasks.length}`,   `Number of just-started or short-running tasks: ${lowProgressTasks.length}`,   `Number of tasks for Ali: ${aliTasks.length}` ); \n``` ### Logical Operators Create compound predicates using logical operators. Realm Query Language has standard logical operators like `AND`, `OR`, and `NOT`. For complete documentation on logical operators, refer to the [Realm Query Language logical operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-logical-operators) The following example uses Realm Query Language's logical operators to find all of Ali's completed tasks. We find all tasks where the `assignee` property value is equal to 'Ali' AND the `isComplete` property value is `true`. ```javascript console.log(   \"Number of Ali's complete tasks: \" +     tasks.filtered(\"assignee == 'Ali' && isComplete == true\").length ); \n``` ### String Operators You can compare string values using string operators like `==`, `beginsWith`,`contains`, and `endsWith`. You can also use the `LIKE` operator to search with regex-like wildcards. For complete documentation on string operators, refer to the [Realm Query Language string operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-string-operators) The following example uses Realm Query Language's string operators to find projects with a name starting with the letter 'e' and projects with names that contain 'ie'. ```javascript // Use [c] for case-insensitivity. console.log(   \"Projects that start with 'e': \" +     projects.filtered(\"name BEGINSWITH[c] 'e'\").length ); console.log(   \"Projects that contain 'ie': \" +     projects.filtered(\"name CONTAINS 'ie'\").length ); \n``` ### Aggregate Operators Traverse a [collection](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-results-collections) and reduce it to a single value with an aggregate operator. For complete documentation on aggregate operators, refer to the [Realm Query Language aggregate operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-aggregate-operators) The following examples uses aggregate operators to show different facets of the data: * `@avg` to show projects with average tasks priority above 5.\n* `@sum` to show long running projects. ```javascript console.log(   \"Number of projects with average tasks priority above 5: \" +     projects.filtered(\"tasks.@avg.priority > 5\").length ); console.log(   \"Number of long-running projects: \" +     projects.filtered(\"tasks.@sum.progressMinutes > 120\").length ); \n``` ### Collection Operators A **collection operator** uses rules to determine whether to pass each input collection object to the output collection by applying a given predicate to every element of a given list property of the object. For complete documentation on collection operators, refer to the [Realm Query Language collection operator reference.](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql-collection-operators) The following examples uses Realm Query Language's collection operators to find: * `ALL` for projects with no complete tasks.\n* `ANY` for projects with any top priority tasks. ```javascript console.log(   \"Number of projects with no complete tasks: \" +     projects.filtered(\"ALL tasks.isComplete == false\").length ); console.log(   \"Number of projects with any top priority tasks: \" +     projects.filtered(\"ANY tasks.priority == 10\").length ); \n``` ## Summary\n\n ← [React to Changes - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/react-to-changes/ \"Previous Section\")[Modify an Object Schema - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/modify-an-object-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/authenticate-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Authenticate Users - Node.js SDK On this page * [Log In](#log-in)\n* [User Sessions](#user-sessions)\n* [Anonymous User](#anonymous-user)\n* [Email/Password User](#email-password-user)\n* [API Key User](#api-key-user)\n* [Custom JWT User](#custom-jwt-user)\n* [Custom Function User](#custom-function-user)\n* [Facebook User](#facebook-user)\n* [Google User](#google-user)\n* [Apple User](#apple-user)\n* [Offline Login](#offline-login)\n* [Get a User Access Token](#get-a-user-access-token)\n* [Log a User Out](#log-a-user-out) ## Log In Realm provides an API for authenticating users into an App with any enabled authentication provider. Instantiate a `Credentials` object and pass it to the`app.login()` method to authenticate a user login and create a `User`object. ### User Sessions Atlas App Services manages sessions with access tokens and refresh tokens. Client SDKs supply the logic to manage tokens, and provide them with requests. ## Tip ### See also:  [User Sessions](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) ## Anonymous User The [Anonymous](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) provider allows users to log in to your application with temporary accounts that have no associated information. To log in, create an anonymous credential and pass it to `App.logIn()`: ## Email/Password User The [email/password](https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) authentication provider allows users to log in to your application with an email address and a password. To log in, create an email/password credential with the user's email address and password and pass it to `App.logIn()`: ## API Key User The [API key](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication) authentication provider allows server processes to access your app directly or on behalf of a user. To log in with an API key, create an API Key credential with a server or user API key and pass it to `App.logIn()`: ## Custom JWT User The [Custom JWT](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) authentication provider allows you to handle user authentication with any authentication system that returns a[JSON web token.](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-json-web-tokens) To log in, create a Custom JWT credential with a JWT from the external system and pass it to `App.logIn()`: ## Custom Function User The [Custom Function](https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication) authentication provider allows you to handle user authentication by running a [function](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) that receives a payload of arbitrary information about a user. To log in with the custom function provider, create a Custom Function credential with a payload object and pass it to `App.logIn()`: ## Facebook User The [Facebook](https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication) authentication provider allows you to authenticate users through a Facebook app using their existing Facebook account. ## Important ### Enable the Facebook Auth Provider\n\n ## Important ### Do Not Store Facebook Profile Picture URLs Facebook profile picture URLs include the user's access token to grant permission to the image. To ensure security, do not store a URL that includes a user's access token. Instead, access the URL directly from the user's metadata fields when you need to fetch the image. You can use the [official Facebook SDK](https://developers.facebook.com/docs/facebook-login/overview)to handle the user authentication and redirect flow from a client application. Once authenticated, the Facebook SDK returns an access token that you can send to your Node.js app and use to finish logging the user in to your app. `| // Get the access token from the Facebook SDK                     |\n| ----------------------------------------------------------------- |\n| const { accessToken } = FB.getAuthResponse();                     |\n| // Define credentials with the access token from the Facebook SDK |\n| const credentials = Realm.Credentials.facebook(accessToken);      |\n| // Log the user in to your app                                    |\n| await app.logIn(credentials);                                     | ` ## Google User The [Google](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication) authentication provider allows you to authenticate users through a Google project using their existing Google account. ## Note ### Enable the Google Auth Provider To authenticate a Google user, you must configure the [Google authentication provider](https://www.mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication). You must enable OpenID Connect to use the Google Authentication Provider with the Node.js SDK. To set up your App for Google User authentication in your App configuration: 1. In the [Google Cloud Platform console](https://console.cloud.google.com/apis/credentials), create an OAuth 2.0 client ID of type \"Web application\".\n2. Configure your backend App to use that client ID and the associated client secret.\n3. Enable OpenID Connect on the backend. Use the official [Google Auth Library for Node.js](https://cloud.google.com/nodejs/docs/reference/google-auth-library/latest)to handle the user authentication and redirect flow from a Node.js client application:\n\n ## Example ### Authenticate with Google on a Node.js Server Refer to [the code for an example Node.js server](https://github.com/mongodb/docs-realm/tree/master/examples/node/Examples/server%5Fgoogle%5Fauth)that implements Sign in With Google. All of the Google OAuth 2.0 implementation is in the `server.js` file. The example uses [Express](https://expressjs.com/) for routing and the Google Auth Library for Node.js. You might want to authenticate with Google on a Node.js server to perform server-side operations on behalf of a user, like call an Atlas Function with a user's credentials. ## Apple User The [Apple](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication) authentication provider allows you to authenticate users through Sign-in With Apple. ## Note ### Enable the Apple Auth Provider To authenticate an Apple user, you must configure the [Apple authentication provider.](https://www.mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication) You can use the [official Sign in with Apple JS SDK](https://developer.apple.com/documentation/sign%5Fin%5Fwith%5Fapple/sign%5Fin%5Fwith%5Fapple%5Fjs) to handle the user authentication and redirect flow from a client application. Once authenticated, the Apple JS SDK returns an ID token that you can send to your Node.js app and use to finish logging the user in to your app. ```javascript // Get the ID token from the Apple SDK const { id_token } = await AppleID.auth.signIn(); // Define credentials with the ID token from the Apple SDK const credentials = Realm.Credentials.apple(id_token); // Log the user in to your app const user = await app.logIn(credentials); \n``` ## Tip If you get a `Login failed` error saying that the `token contains an invalid number of segments`, verify that you're passing a UTF-8-encoded string version of the JWT. ## Offline Login When your Realm application authenticates a user, it caches the user's credentials. You can check for existing user credentials to bypass the login flow and access the cached user. Use this to open a realm offline. ## Note ### Initial login requires a network connection When a user signs up for your app, or logs in for the first time with an existing account on a client, the client must have a network connection. Checking for cached user credentials lets you open a realm offline, but only if the user has previously logged in while online. ```javascript // Log the user into the backend app. // The first time you login, the user must have a network connection. const getUser = async () => {   // Check for an existing user.   // If the user is offline but credentials are   // cached, this returns the existing user.   if (app.currentUser) return app.currentUser;   // If the device has no cached user credentials, log them in.   const credentials = Realm.Credentials.anonymous();   return await app.logIn(credentials); }; \n``` To learn how to use the cached user in the Sync Configuration and access a realm while offline, read the [Open a Synced Realm While Offline](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-open-synced-realm-offline) docs. ## Get a User Access Token When a user logs in, Atlas App Services creates an access token for the user that grants them access to your App. The Realm SDK automatically manages access tokens, refreshes them when they expire, and includes a valid access token for the current user with each request. If you send requests outside of the SDK (for example, through the GraphQL API) then you need to include the user's access token with each request, and manually refresh the token when it expires. You can access and refresh a logged in user's access token in the SDK from their`Realm.User` object, as in the following example: ## Log a User Out To log any user out, call the `User.logOut()` on their user instance. ## Warning\n\n ← [User Metadata - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/user-metadata/ \"Previous Section\")[Sync Changes Between Devices - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/sync-changes-between-devices/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/flexible-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Flexible Sync - Node.js SDK On this page * [Overview](#overview)\n* [Subscribe to Queryable Fields](#subscribe-to-queryable-fields)\n* [Get Subscriptions](#get-subscriptions)\n* [Add a Query to the List Of Subscriptions](#add-a-query-to-the-list-of-subscriptions)\n* [Bootstrap the Realm with Initial Subscriptions](#bootstrap-the-realm-with-initial-subscriptions)\n* [Check the Status of Subscriptions](#check-the-status-of-subscriptions)\n* [Update Subscriptions with a New Query](#update-subscriptions-with-a-new-query)\n* [Remove Subscriptions](#remove-subscriptions)\n* [Remove a Subscription by Query](#remove-a-subscription-by-query)\n* [Remove a Subscription by Name](#remove-a-subscription-by-name)\n* [Remove a Subscription by Reference](#remove-a-subscription-by-reference)\n* [Remove All Subscriptions on an Object Type](#remove-all-subscriptions-on-an-object-type)\n* [Remove All Subscriptions](#remove-all-subscriptions)\n* [Flexible Sync RQL Limitations](#flexible-sync-rql-limitations)\n* [Unsupported Query Operators in Flexible Sync](#unsupported-query-operators-in-flexible-sync)\n* [List Queries](#list-queries)\n* [Embedded or Linked Objects](#embedded-or-linked-objects) ## Overview Flexible Sync uses subscriptions and permissions to determine which data to sync with your App. To use Flexible Sync in a Node.js client: * [Configure Flexible Sync on the backend.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync)\n* [Initialize the app](https://mongodb.com/docs/realm/sdk/node/quick-start/#std-label-node-quick-start-init-app)\n* [Authenticate a user](https://mongodb.com/docs/realm/sdk/node/quick-start/#std-label-node-quick-start-authenticate) in your client project.\n* [Open the synced Realm with a Flexible Sync configuration](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-flexible-sync-open-realm)\n* [Add subscriptions to the client application](#std-label-node-sync-subscribe-to-queryable-fields) You can add, update, and remove query subscriptions to determine which data syncs to the client device. ## Note ### Flexible Sync Prerequisites Enabling Flexible Sync in your App requires a non-sharded Atlas cluster running [MongoDB 5.0 or greater](https://www.mongodb.com/docs/manual/release-notes/) ## Note ### Realm JS SDK Version Requirement In addition to the requirements above, you must use [Realm JS version 10.12.0](https://github.com/realm/realm-js/releases) or greater in order to use Flexible Sync in your Node.js client application. ## Important ### Flexible Sync Query Limitations You cannot use all queries with Flexible Sync subscriptions. Refer to the [Flexible Sync RQL Limitations documentation](#std-label-node-flexible-sync-rql-limitations)for information on which query types are not supported. ## Subscribe to Queryable Fields When configuring Flexible Sync on the backend, you specify which fields your client application can query. In the client application, use the[Subscriptions](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Subscription.html) API to manage a set of subscriptions to specific queries on queryable fields. You can: * Get a list of all subscriptions\n* Add subscriptions\n* Check subscription state\n* Update a subscription with a new query\n* Remove individual subscriptions or all subscriptions of a type\n\n A Realm subscription in JavaScript has: * A created and updated date\n* A name\n* An object type\n* A query string You can specify a string name for your subscription. If you do not give your subscription a name, the name is set to [null.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/null) When you create a subscription, Realm looks for data matching a query on a specific object type. In your Flexible Sync subscriptions, you can have subscriptions on several different object types or several queries on the same object type. ## Example In the following example, queries are created to subscribe to: * A filtered list of completed tasks that have taken over 120 `progressMinutes`\n* A filtered list of completed tasks Notice that queries that you subscribe to using Flexible Sync are syntactically the same as [querying a realm](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/#std-label-node-read-operations)and that the queries below will create an overlapping result set. `| const tasks = realm.objects(\"Task\");                |\n| --------------------------------------------------- |\n| const longRunningTasks = tasks.filtered(            |\n| 'status == \"completed\" && progressMinutes > 120'    |\n| );                                                  |\n| const bensTasks = tasks.filtered('owner == \"Ben\"'); | ` ## Important ### Object Links You must add both an object and its linked object to the subscription set to see a linked object. If your subscription results contain an object with a property that links to an object not contained in the results, the link appears to be null. There is no way to distinguish whether that property's value is legitimately null, or whether the object it links to exists but is out of view of the query subscription. ### Get Subscriptions When using a flexible synced realm, you can access a `SubscriptionSet`, a collection of subscriptions, through the [realm.subscriptions](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#subscriptions) property. ```javascript // get the SubscriptionSet for the realm const subscriptions = realm.subscriptions; \n``` You can use this `SubscriptionSet` to add queries to the list of subscriptions and update existing subscriptions, as shown in the examples below. ### Add a Query to the List Of Subscriptions Compose queries to add to your Flexible Sync subscriptions using the[query engine:](https://mongodb.com/docs/realm/sdk/react-native/realm-database/crud/query-data/#std-label-react-native-client-query-engine) ```javascript const tasks = realm.objects(\"Task\"); const longRunningTasks = tasks.filtered(   'status == \"completed\" && progressMinutes > 120' ); const bensTasks = tasks.filtered('owner == \"Ben\"'); \n``` Add queries to your subscriptions list to sync the query's data. To do so, perform the following: 1. Create a transaction by passing a callback function to the[SubscriptionSet.update()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.SubscriptionSet.html#update)method of your `SubscriptionSet`. The callback function provides a [MutableSubscriptionSet](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html)as an argument.\n2. Within the callback function, call the[add()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#add)method on the `MutableSubscriptionSet` to add a query to the subscription. The following example shows how to subscribe to the queries created above. ```javascript await realm.subscriptions.update((mutableSubs) => {   mutableSubs.add(longRunningTasks, {     name: \"longRunningTasksSubscription\",\n\n   mutableSubs.add(bensTasks);   mutableSubs.add(realm.objects(\"Team\"), {     name: \"teamsSubscription\",     throwOnUpdate: true,   }); }); \n``` The `add()` method on the `MutableSubscriptionSet` takes a `query` and a[SubscriptionOptions](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#.SubscriptionOptions) object. The subscription options include: * a `name` string field\n* a `throwOnUpdate` boolean field. If `throwOnUpdate` is false or undefined, adding a subscription with an existing name will replace the existing query with the new query. However, if you set `throwOnUpdate` to true, adding a subscription with an existing name but a different query throws an exception. #### Bootstrap the Realm with Initial Subscriptions _New in version 10.18.0_. You must have at least one subscription before you can read from or write to a realm with Flexible Sync enabled. You can bootstrap a realm with an initial subscription set when you open it with a [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration)and Flexible Sync enabled. Include the `initialSubscriptions` field into the`SyncConfiguration`. Within the `initialSubscriptions` object, add an `update`field set to a callback in which you can subscribe to queries to bootstrap your application: ```javascript const config = {   sync: {     user: app.currentUser,     flexible: true,     initialSubscriptions: {       update: (subs, realm) => {         subs.add(           realm.objects(\"Team\").filtered(\"name == 'Developer Education'\")         );       },     },   }, }; const realm = await Realm.open(config); \n``` ### Check the Status of Subscriptions You can check the subscription state to see if the server has acknowledged the subscription and the device has downloaded the data locally. You can use subscription state to: * Trigger error handling\n* Show if the transaction is pending or has completed\n* Find out when a subscription set is superseded, and you should obtain a new instance of the subscription set to write a subscription change To the status of subscriptions, log the value of the subscription's[state.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.SubscriptionSet.html#state) ```javascript console.log(realm.subscriptions.state); // log the subscription state \n``` ## Note ### Subscription State \"Complete\" The subscription set state \"complete\" does not mean \"sync is done\" or \"all documents have been synced\". \"Complete\" means the following two things have happened: * The subscription has become the active subscription set that is currently being synchronized with the server.\n* The documents that matched the subscription _at the time the subscription was sent to the server_ are now on the local device. Note that this does not necessarily include all documents that currently match the subscription. The Realm SDK does not provide a way to check whether all documents that match a subscription have synced to the device. ### Update Subscriptions with a New Query You can update a named subscription with a new query. To update a subscriptions query, pass the new query and a subscription option with the name of the subscription that you want to update to the`MutableSubscriptionSet.add()` method. Like adding a new subscription, you must update a subscription within a transaction by calling`subscriptions.update()` method. In the following example, long-running tasks are re-defined to be any tasks that have taken more than 180 minutes. ```javascript realm.subscriptions.update((mutableSubs) => {   mutableSubs.add(     tasks.filtered('status == \"completed\" && progressMinutes > 180'),     {       name: \"longRunningTasksSubscription\",     }   ); }); \n``` ## Note Attempting to update a subscription that has the`SubscriptionOptions.throwOnUpdate` field set to true, throw an exception. ### Remove Subscriptions To remove subscriptions from the subscription set, you can:\n\n When you remove a subscription query, the server also removes synced data from the client device. #### Remove a Subscription by Query You can remove a specific subscription by query by executing a transaction on the subscriptions set. Pass the query to the [remove()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#remove) method on the`MutableSubscriptionSet` within a transaction. In the following example, the subscription to tasks with an owner named 'Ben' is removed from the subscriptions set. ```javascript realm.subscriptions.update((mutableSubs) => {   // remove a subscription with a specific query   mutableSubs.remove(tasks.filtered('owner == \"Ben\"')); }); \n``` #### Remove a Subscription by Name To remove a specific subscription by name, execute a transaction on the subscriptions set. Within the transaction, pass the name to the[removeByName()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#removeByName) method on the`MutableSubscriptionSet`. ```javascript realm.subscriptions.update((mutableSubs) => {   // remove a subscription with a specific name   mutableSubs.removeByName(\"longRunningTasksSubscription\"); }); \n``` #### Remove a Subscription by Reference If you have a reference to a subscription, you can remove that subscription. To do so, execute a transaction on the subscriptions set. Within the transaction, pass the reference variable to the [removeSubscription](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#removeSubscription) method on the`MutableSubscriptionSet`. ```javascript let subscriptionReference; realm.subscriptions.update((mutableSubs) => {   subscriptionReference = mutableSubs.add(realm.objects(\"Task\")); }); // later.. realm.subscriptions.removeSubscription(subscriptionReference); \n``` #### Remove All Subscriptions on an Object Type To remove all subscriptions on a specific object type, execute a transaction on the subscriptions set. Within the transaction, pass the object type as a string to the [removeByObjectType](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#removeByObjectType) method on the`MutableSubscriptionSet`. ```javascript realm.subscriptions.update((mutableSubs) => {   mutableSubs.removeByObjectType(\"Team\"); }); \n``` #### Remove All Subscriptions To remove all subscriptions from the subscriptions set, execute a transaction on the subscriptions set. Call [removeAll()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.MutableSubscriptionSet.html#removeAll) on the`MutableSubscriptionSet` within the transaction ```javascript realm.subscriptions.update((mutableSubs) => {   mutableSubs.removeAll(); }); \n``` ## Flexible Sync RQL Limitations Flexible Sync has some limitations when using RQL operators. When you write the [query subscription](https://www.mongodb.com/docs/atlas/app-services/sync/get-started/#std-label-flexible-sync-query-subscription)that determines which data to sync, the server does not support these query operators. However, you can still use the full range of RQL features to query the synced data set in the client application. ### Unsupported Query Operators in Flexible Sync | Operator Type       | Unsupported Operators          |\n| ------------------- | ------------------------------ |\n| Aggregate Operators | @avg, @count, @max, @min, @sum |\n| Query Suffixes      | DISTINCT, SORT, LIMIT          | Case insensitive queries (`[c]`) cannot use indexes effectively. As a result, case insensitive queries are not recommended, since they could lead to performance problems. Flexible Sync only supports `@count` for array fields. ### List Queries\n\n You can query a list of constants to see if it contains the value of a queryable field: ```javascript // Query a constant list for a queryable field value \"priority IN { 1, 2, 3 }\" \n``` If a queryable field has an array value, you can query to see if it contains a constant value: ```javascript // Query an array-valued queryable field for a constant value \"'comedy' IN genres\" \n``` ## Warning You **cannot** compare two lists with each other in a Flexible Sync query. Note that this is valid Realm Query Language syntax outside of Flexible Sync queries. ```javascript // Invalid Flexible Sync query. Do not do this! \"{'comedy', 'horror', 'suspense'} IN genres\" // Another invalid Flexible Sync query. Do not do this! \"ANY {'comedy', 'horror', 'suspense'} != ANY genres\" \n``` ### Embedded or Linked Objects Flexible Sync does not support querying on properties in Embedded Objects or links. For example, `obj1.field == \"foo\"`. ← [Sync Changes Between Devices - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/sync-changes-between-devices/ \"Previous Section\")[Reset a Client Realm - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/reset-a-client-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/call-a-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Call a Function - Node.js SDK On this page * [Call a Function by Name](#call-a-function-by-name) The examples in this section demonstrate calling a simple Atlas Function named `sum` that takes two arguments, adds them, and returns the result: `| // sum: adds two numbers   |\n| -------------------------- |\n| exports = function(a, b) { |\n| return a + b;              |\n| };                         | ` ## Call a Function by Name ## Important Make sure to sanitize client data to protect against code injection when using Functions. To call a function, you can either pass its name and arguments to`User.callFunction()` or call the function as if it was a method on the[User.functions](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#functions) property. ## Note ### Link a MongoDB Atlas Data Source This example requires an App Services App with a linked[Atlas data source](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources). Replace`<appId>` in the code with your App ID, which you can find in the left navigation menu of the App Services UI. ```javascript // wrap the code below in an async function to 'await' for the promises to resolve const numA = 2; const numB = 3; const result = await user.functions.sum(numA, numB); const resultOfCallFunction = await user.callFunction(\"sum\", numA, numB); // alternate syntax to call a MongoDB Realm Function console.log(   `Using the \"functions.sum()\" method: the sum of ${numA} + ${numB} = ${result}` ); console.log(   `Using the \"callFunction()\" method: the sum of ${numA} + ${numB} = ${resultOfCallFunction}` ); \n``` When you run the code sample, your output should resemble the following: ``` Using the \"functions.sum()\" method: the sum of 2 + 3 = 5 Using the \"callFunction()\" method: the sum of 2 + 3 = 5 \n``` ← [Reset a Client Realm - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/reset-a-client-realm/ \"Previous Section\")[Manage Email/Password Users - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/manage-email-password-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/reset-a-client-realm/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Reset a Client Realm - Node.js SDK On this page * [Client Reset Modes](#client-reset-modes)\n* [Automatic vs. Manual Client Reset](#automatic-vs.-manual-client-reset)\n* [Client Reset with Recovery](#client-reset-with-recovery)\n* [Recover Unsynced Changes Mode](#recover-unsynced-changes-mode)\n* [Recover or Discard Unsynced Changes Mode](#recover-or-discard-unsynced-changes-mode)\n* [Manual Client Reset Fallback](#manual-client-reset-fallback)\n* [Discard Unsynced Changes Mode](#discard-unsynced-changes-mode)\n* [Discard Unsynced Changes after Breaking Schema Changes](#discard-unsynced-changes-after-breaking-schema-changes)\n* [Manual Mode](#manual-mode)\n* [Manual Data Recovery](#manual-data-recovery) A **client reset error** is a scenario where a client realm cannot sync data with the Atlas App Services backend. Clients in this state may continue to run and save data locally but cannot send or receive sync changesets until they perform a client reset. To learn about the causes of and modes for handling client resets, check out Device Sync [Client Resets in the App Services documentation.](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) ## Client Reset Modes You can specify which **client reset mode** your app should use to restore the realm to a syncable state: * [Recover unsynced changes mode](#std-label-node-recover-unsynced-changes): When you choose this mode, the client attempts to recover unsynced changes. Choose this mode when you do not want to fall through to discard unsynced changes.\n* [Recover or discard unsynced changes mode](#std-label-node-recover-discard-unsynced-changes): The client first attempts to recover changes that have not yet synced. If the client cannot recover unsynced data, it falls through to discard unsynced changes but continues to automatically perform the client reset. Choose this mode when you want to enable automatic client recovery to fall back to discard unsynced changes.\n* [Discard unsynced changes mode](#std-label-node-discard-unsynced-changes): Restores the realm to a syncable state by discarding changes made since the last sync.\n* [Manual recovery mode](#std-label-node-manually-recover-unsynced-changes): Downloads a new copy of the realm, and moves the unsyncable realm to a backup. Migrate unsynced data from the backup copy of the realm to the new syncable copy. ## Automatic vs. Manual Client Reset The Realm SDKs provide client reset modes that automatically handle most client reset errors. Automatic client reset modes restore your local realm file to a syncable state without closing the realm or missing notifications. The following client reset modes support automatic client resets: * Recover unsynced changes mode\n* Recover or discard unsynced changes mode\n* Discard unsynced changes mode The differences between these modes are based on how they handle changes on the device that have not yet synced to the backend. Only manual recovery mode does not perform an automatic client reset. Choose recover unsynced changes mode to handle most client reset scenarios automatically. This attempts to recover unsynced changes when a client reset occurs. If your app requires specific client reset logic that can't be handled automatically, you may want or need to [add a manual client reset handler](#std-label-node-manually-recover-unsynced-changes)to the automatic client reset mode. ## Client Reset with Recovery _New in version 10.23.0_. Client Recovery is a feature that is enabled by default when you configure Device Sync. When Client Recovery is enabled, Realm Database automatically manages the client reset process in most cases. The client can recover unsynced changes when there are no schema changes, or non-breaking schema changes. To use Client Recovery, configure your realm with one of the following client reset modes: * Recover unsynced changes mode\n* Recover or discard unsynced changes\n\n * Objects created locally that were not synced before client reset are synced.\n* If an object is deleted on the server, but is modified on the recovering client, the delete takes precedence and the client discards the update.\n* If an object is deleted on the recovering client, but not the server, then the client applies the server's delete instruction.\n* In the case of conflicting updates to the same field, the client update is applied. For more information about configuring Client Recovery, refer to[Client Recovery](https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-enable-or-disable-recovery-mode) in the App Services documentation. Client Recovery cannot succeed when your app makes breaking schema changes. A breaking change is a change that you can make in your server-side schema that requires additional action to handle. In this scenario, client reset falls back to a[manual error client reset fallback.](#std-label-node-manual-client-reset-fallback) For information on breaking vs. non-breaking schema changes, refer to[Breaking vs. Non-Breaking Change Quick Reference](https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-breaking-change-quick-reference) in the App Services documentation. ### Recover Unsynced Changes Mode When you choose **recover unsynced changes** mode, the client attempts to recover unsynced changes with Client Recovery. Choose this mode when you do not want to fall through to discard unsynced changes. To handle client resets with the recover unsynced changes mode, pass a [ClientResetConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~ClientResetConfiguration)to the `clientReset` field of your[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration). Include these properties in the `ClientResetConfiguration`: * `mode`: Set to `\"recoverUnsyncedChanges\"`.\n* `onBefore`: Optional. Callback function invoked before the SDK executes this mode, when the SDK receives a client reset error from the backend. Provides a copy of the realm.\n* `onAfter`: Optional. Callback function invoked after the SDK successfully executes this mode. Provides instances of the realm before and after the client reset.\n* `onFallback`: Optional. Callback function which the SDK invokes only if the automatic recovery fails. For more information, refer to the[Manual Client Reset Fallback section.](#std-label-node-manual-client-reset-fallback) The following example implements recover unsynced changes mode:\n\n ` ### Recover or Discard Unsynced Changes Mode In **recover or discard unsynced changes** mode, the client first attempts to recover changes that have not yet synced. If the client cannot recover unsynced data, it falls through to discard unsynced changes but continues to automatically perform the client reset. Choose this mode when you want to enable automatic client recovery to fall back to discard unsynced changes. Do not use recover or discard unsynced changes mode if your application cannot lose local data that has not yet synced to the backend. To handle client resets with the recover or discard unsynced changes mode, pass a [ClientResetConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~ClientResetConfiguration)to the `clientReset` field of your[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration). Include these properties in the `ClientResetConfiguration`: * `mode`: Set to `\"recoverOrDiscardUnsyncedChanges\"`.\n* `onBefore`: Optional. Callback function invoked before the SDK executes this mode, when the SDK receives a client reset error from the backend. Provides a copy of the realm.\n* `onAfter`: Optional. Callback function invoked after the SDK successfully executes this mode. Provides instances of the realm before and after the client reset.\n* `onFallback()`: Optional. Callback function which the SDK invokes only if both the automatic recovery and and discarding changes fails. For more information, refer to the [Manual Client Reset Fallback section.](#std-label-node-manual-client-reset-fallback) The following example implements recover unsynced changes mode: ```js const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"recoverOrDiscardUnsyncedChanges\",       onBefore: (realm) => {         // This block could be used for custom recovery, reporting, debugging etc.       },       onAfter: (beforeRealm, afterRealm) => {         // This block could be used for custom recovery, reporting, debugging etc.       },       onFallback: (session, path) => {         // See below \"Manual Client Reset Fallback\" section for example       },     },   }, }; \n``` ### Manual Client Reset Fallback If the client reset with recovery cannot complete automatically, like when there are breaking schema changes, the client reset process falls through to a manual error handler. This may occur in either of the client reset with recovery modes, recover unsynced changes and recover or discard unsynced changes. You must provide a manual client reset implementation in the `SyncConfiguration.onFallback()` callback. `onFallback()` takes two arguments: * `session`: [Session](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.Session.html) object representing the state of the Device Sync session.\n* `path`: String with the path to the current realm database file. The following example demonstrates how you can manually handle this error case by discarding all unsynced changes: ```js // Must define `realm` at higher scope than `config` so it's accessible // from the `onFallback` callback let realm; const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"recoverOrDiscardUnsyncedChanges\", // or \"recoverUnsyncedChanges\"       // can also include `onBefore` and `onAfter` callbacks       onFallback: (_session, path) => {         try {           // Prompt user to perform a client reset immediately. If they don't,           // they won't receive any data from the server until they restart the app\n\n           const didUserConfirmReset = showUserAConfirmationDialog();           if (didUserConfirmReset) {             // Close and delete old realm from device             realm.close();             Realm.deleteFile(path);             // Perform client reset             Realm.App.Sync.initiateClientReset(app, path);             // Navigate the user back to the main page or reopen the             // the Realm and reinitialize the current page           }         } catch (err) {           // Reset failed. Notify user that they'll need to           // update the app         }       },     },   }, }; realm = await Realm.open(config); \n``` ## Discard Unsynced Changes Mode _New in version 10.11.0_. _Changed in version 10.23.0_: Mode renamed from \"discardLocal\" to \"discardUnsyncedChanges\". Both currently work, but in a future version, \"discardLocal\" will be removed. \"clientResetBefore\" and \"clientResetAfter\" callbacks renamed to \"onBefore\" and \"onAfter\", respectively. **Discard Unsynced Changes** mode permanently deletes all local unsynced changes made since the last successful sync. You might use this mode when your app requires client recovery logic that is not consistent with [automatic Client Recovery](#std-label-node-client-reset-recovery), or when you don't want to recover unsynced data. Do not use discard unsynced changes mode if your application cannot lose local data that has not yet synced to the backend. To handle client resets with the discard unsynced changes mode, pass a [ClientResetConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~ClientResetConfiguration)to the `clientReset` field of your[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration). Include these properties in the `ClientResetConfiguration`: * `mode`: Set to `\"discardUnsyncedChanges\"`.\n* `onBefore`: Optional. Callback function invoked before the SDK executes this mode, when the SDK receives a client reset error from the backend. Provides a copy of the realm.\n* `onAfter`: Optional. Callback function invoked after the SDK successfully executes this mode. Provides instances of the realm before and after the client reset. The following example implements discard unsynced changes mode: ```javascript const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"discardUnsyncedChanges\",       onBefore: (realm) => {         console.log(\"Beginning client reset for \", realm.path);       },       onAfter: (beforeRealm, afterRealm) => {         console.log(\"Finished client reset for\", beforeRealm.path);         console.log(\"New realm path\", afterRealm.path);       },     },   }, }; \n``` ### Discard Unsynced Changes after Breaking Schema Changes If your application experiences a breaking schema change, discard unsynced changes mode cannot handle the resulting client reset automatically. Instead, you must provide a manual client reset implementation in the SyncConfiguration `error()` callback. The following example demonstrates how you can manually handle this error case by discarding all unsynced changes: ```javascript // Once you have opened your Realm, you will have to keep a reference to it. // In the error handler, this reference is called `realm` async function handleSyncError(session, syncError) {\n\n     console.log(syncError);     try {       console.log(\"error type is ClientReset....\");       const path = realm.path; // realm.path will not be accessible after realm.close()       realm.close();       Realm.App.Sync.initiateClientReset(app, path);       // Download Realm from the server.       // Ensure that the backend state is fully downloaded before proceeding,       // which is the default behavior.       realm = await Realm.open(config);       realm.close();     } catch (err) {       console.error(err);     }   } else {     // ...handle other error types   } } const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"discardUnsyncedChanges\",       onBefore: (realm) => {         // NOT used with destructive schema changes         console.log(\"Beginning client reset for \", realm.path);       },       onAfter: (beforeRealm, afterRealm) => {         // Destructive schema changes do not hit this function.         // Instead, they go through the error handler.         console.log(\"Finished client reset for\", beforeRealm.path);         console.log(\"New realm path\", afterRealm.path);       },     },     error: handleSyncError, // invoked with destructive schema changes   }, }; \n``` ## Note ### Discard with Recovery If you'd like to attempt to recover unsynced changes, but but discard any changes that cannot be recovered, refer to the[recover or discard unsynced changes mode section.](#std-label-node-recover-discard-unsynced-changes) ## Manual Mode _Changed in version 10.23.0_: onManual callback added In **manual** mode, you define your own client reset handler. You might want to use a manual client reset handler if the Automatic Recovery logic does not work for your app and you can't discard unsynced local data. To handle client resets with manual mode, pass a [ClientResetConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~ClientResetConfiguration)to the `clientReset` field of your[SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration). Include these properties in the `ClientResetConfiguration`: * `mode`: Set to `\"manual\"`.\n* `onManual`: Optional. Callback function invoked when the client reset occurs. Provides information about the sync session and the path to the current realm. If you don't set the `onManual` error handler, the client reset error falls back to the general sync error handler. ```js const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     flexible: true,     clientReset: {       mode: \"manual\",       onManual: (session, path) => {         // handle manual client reset here       },     },   }, }; \n``` ### Manual Data Recovery To recover data from a manual client reset requires significant amounts of code, schema concessions, and custom conflict resolution logic. If you need to implement your own custom client reset logic, see the [Advanced Guide to Manual Client Reset Data Recovery.](https://mongodb.com/docs/realm/sdk/node/advanced/client-reset-data-recovery/#std-label-node-advanced-manual-client-reset-data-recovery)\n\n",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/manage-user-api-keys/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Create & Manage User API Keys - Node.js SDK On this page * [Create a User API Key](#create-a-user-api-key)\n* [Look up a User API Key](#look-up-a-user-api-key)\n* [Enable or Disable an API Key](#enable-or-disable-an-api-key)\n* [Delete an API Key](#delete-an-api-key) ## Create a User API Key To create a new [user API key](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication-user-api-key), pass a name that's unique among all of the user's API keys to[ApiKeyAuth.create().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#create) `| const user = app.currentUser;                        |\n| ---------------------------------------------------- |\n| const key = await user.apiKeys.create(\"apiKeyName\"); | ` ## Important You cannot create a user API key for a [server API key](https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication-server-api-key) or an [anonymous user.](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication) ## Warning ### Store the API Key Value The SDK only returns the value of the user API key when you create it. Make sure to store the `key` value securely so that you can use it to log in. If you lose or do not store the `key` value there is no way to recover it. You will need to create a new user API key. ## Look up a User API Key To get an array that lists all of a user's API keys, call[ApiKeyAuth.fetchAll().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#fetchAll) To find a specific API key, pass the key's `_id` to[ApiKeyAuth.fetch().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#fetch) ```javascript const user = app.currentUser; // List all of a user's keys const keys = await user.apiKeys.fetchAll(); // Get a specific key by its ID const key = await user.apiKeys.fetch(\"5eb5931548d79bc784adf46e\"); \n``` ## Enable or Disable an API Key To enable or disable a user API key, pass the key's `_id` to[ApiKeyAuth.enable()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#enable) or[ApiKeyAuth.disable()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#disable). When a key is disabled, it cannot be used to log in on behalf of the user. ```javascript // Get the ID of a User API Key const user = app.currentUser; const apiKeys = await user.apiKeys.fetchAll(); const keyId = apiKeys[0][\"_id\"]; // Enable the User API Key await user.apiKey.enable(keyId); // Disable the User API Key await user.apiKey.disable(keyId); \n``` ## Delete an API Key To permanently delete a user API, pass the key's `_id` to[ApiKeyAuth.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Auth.ApiKeyAuth.html#delete). Deleted keys cannot be recovered. ```javascript // Get the ID of a User API Key const user = app.currentUser;\n\n const keyId = apiKeys[0][\"_id\"]; // Delete the User API Key await user.apiKey.delete(keyId); \n``` ← [Manage Email/Password Users - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/manage-email-password-users/ \"Previous Section\")[Query MongoDB - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/query-mongodb/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/react-to-changes/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # React to Changes - Node.js SDK On this page * [Register a Realm Change Listener](#register-a-realm-change-listener)\n* [Register a Collection Change Listener](#register-a-collection-change-listener)\n* [Register an Object Change Listener](#register-an-object-change-listener)\n* [Remove All Change Listeners](#remove-all-change-listeners) ## Register a Realm Change Listener To register a change listener for an entire realm, pass a callback function to the realm's [addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#addListener) method. Realm Database calls the listener asynchronously whenever an operation adds, changes, or removes objects in the realm. To remove a realm listener, pass the callback to the realm's [removeListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#removeListener) method. ## Tip ### Use Object & Collection Listeners for Change Details Realm Database does not pass any information about what changed to realm listener callback functions. If you need to know more information about what changed in an object or collection, use [object listeners](#std-label-node-object-listener) and [collection listeners.](#std-label-node-collection-listener) ## Tip ### Handling Exceptions Inside a Listener To handle exceptions thrown from a change listener, wrap your `addListener()` call within a [try...catch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch) statement.\n\n  `` ## Register a Collection Change Listener To register a change listener for a collection of Realm objects, pass a callback function to the collection's [addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#addListener) method. Realm Database calls the listener asynchronously when it's registered as well as whenever an operation adds, changes, or removes objects in the collection. To remove a collection listener, pass the callback to the collection's [removeListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#removeListener) method. ## Important ### Order Matters In collection notification handlers, always apply changes in the following order: deletions, insertions, then modifications. Handling insertions before deletions may result in unexpected behavior. ```javascript // You can define a listener for any collection of Realm objects const dogs = realm.objects(\"Dog\"); // Define a listener callback function for changes to any Dog function onDogsChange(dogs, changes) {   // Handle deleted Dog objects   changes.deletions.forEach((index) => {     // You cannot directly access deleted objects,     // but you can update a UI list, etc. based on the index.     console.log(`Looks like Dog #${index} has left the realm.`);   });   // Handle newly added Dog objects   changes.insertions.forEach((index) => {     const insertedDog = dogs[index];     console.log(`Welcome our new friend, ${insertedDog.name}!`);   });   // Handle Dog objects that were modified   changes.modifications.forEach((index) => {     const modifiedDog = dogs[index];     console.log(`Hey ${modifiedDog.name}, you look different!`);   }); } // Add the listener callback to the collection of dogs try {   dogs.addListener(onDogsChange); } catch (error) {   console.error(     `An exception was thrown within the change listener: ${error}`   ); } // Remember to remove the listener when you're done! dogs.removeListener(onDogsChange); \n``` ## Register an Object Change Listener To register a change listener on a specific Realm object, pass a callback function to the object's [addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#addListener) method. Realm Database calls the listener if any of the object's properties change or if someone deletes the object. To remove an object listener, pass the callback to the object's[removeListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#removeListener) method. ```javascript // Define a listener callback function for changes to a specific Dog function onDogChange(dog, changes) {   if (changes.deleted) {     console.log(`dog is deleted: ${changes.deleted}`);   } else {     changes.changedProperties.forEach((prop) => {       console.log(`* the value of \"${prop}\" changed to ${dog[prop]}`);     });   } } // You can define a listener for any Realm object try {   dog.addListener(onDogChange); } catch (error) {   console.error(     `An exception was thrown within the change listener: ${error}`   ); } // Remember to remove the listeners when you're done! dog.removeListener(onDogChange); \n``` ## Remove All Change Listeners To remove **all** listeners on a given realm, object, or collection instance, call the instance's `removeAllListeners()` function: * [Realm.removeAllListeners()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#removeAllListeners)\n* [Realm.Collection.removeAllListeners()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#removeAllListeners)\n* [Realm.Object.removeAllListeners()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#removeAllListeners) ```javascript\n\n realm.removeAllListeners(); // Remove all listeners from a collection dogs.removeAllListeners(); // Remove all listeners from an object dog.removeAllListeners(); \n``` ← [Read & Write Data - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/ \"Previous Section\")[Query Data - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/query-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/data-types/mixed/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Mixed - Node.js SDK On this page * [Overview](#overview)\n* [Realm Object Models](#realm-object-models)\n* [Create an Object With a Mixed Value](#create-an-object-with-a-mixed-value)\n* [Query for Objects with a Mixed Value](#query-for-objects-with-a-mixed-value) _New in version 10.5.0_. ## Overview The mixed data type is a realm property type that can hold any valid Realm data type except a collection. You can create collections (lists, sets, and dictionaries) of type `mixed`, but a `mixed` itself cannot be a collection. Properties using the mixed data type can also hold null values. ## Note The mixed data type is indexable, but you can't use it as a primary key. Because null is a permitted value, you can't declare a Mixed property as optional. ## Realm Object Models To [set a property of your object model](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-define-a-realm-object-schema) as `Mixed`, set the property's type to \"`mixed`\". `| const DogSchema = { |\n| ------------------- |\n| name: \"Dog\",        |\n| properties: {       |\n| name: \"string\",     |\n| birthDate: \"mixed\", |\n| },                  |\n| };                  | ` ## Create an Object With a Mixed Value Create an object with a mixed value by running the [realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) method within a write transaction. ```javascript realm.write(() => {   // create a Dog with a birthDate value of type string   realm.create(\"Dog\", { name: \"Euler\", birthDate: \"December 25th, 2017\" });   // create a Dog with a birthDate value of type date   realm.create(\"Dog\", {     name: \"Blaise\",     birthDate: new Date(\"August 17, 2020\"),   });   // create a Dog with a birthDate value of type int   realm.create(\"Dog\", {     name: \"Euclid\",     birthDate: 10152021,   });   // create a Dog with a birthDate value of type null   realm.create(\"Dog\", {     name: \"Pythagoras\",     birthDate: null,   }); }); \n``` ## Query for Objects with a Mixed Value Query for objects with a mixed value by running the[Collection.filtered()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#filtered) method and passing in a [filter](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/#std-label-node-filter-queries) for a non-mixed field. You can then print the value of the mixed property or the entire object itself. ```javascript // To query for Blaise's birthDate, filter for his name to retrieve the realm object. // Use dot notation to access the birthDate property. let blaiseBirthDate = realm.objects(\"Dog\").filtered(`name = 'Blaise'`)[0]   .birthDate; console.log(`Blaise's birth date is ${blaiseBirthDate}`); \n``` ← [Sets - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/sets/ \"Previous Section\")[UUID - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/uuid/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/query-mongodb/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Query MongoDB - Node.js SDK On this page * [Use Cases](#use-cases)\n* [Prerequisites](#prerequisites)\n* [Connect to a Linked Cluster](#connect-to-a-linked-cluster)\n* [Read Operations](#read-operations)\n* [Find a Single Document](#find-a-single-document)\n* [Find Multiple Documents](#find-multiple-documents)\n* [Count Documents](#count-documents)\n* [Write Operations](#write-operations)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Update a Single Document](#update-a-single-document)\n* [Update Multiple Documents](#update-multiple-documents)\n* [Upsert Documents](#upsert-documents)\n* [Delete a Single Document](#delete-a-single-document)\n* [Delete Multiple Documents](#delete-multiple-documents)\n* [Real-time Change Notifications](#real-time-change-notifications)\n* [Watch for All Changes in a Collection](#watch-for-all-changes-in-a-collection)\n* [Watch for Specific Changes in a Collection](#watch-for-specific-changes-in-a-collection)\n* [Aggregation Operations](#aggregation-operations)\n* [Run an Aggregation Pipeline](#run-an-aggregation-pipeline) You can query data stored in MongoDB Atlas directly from your client application code by using the Realm Node.js SDK's [MongoDB client](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm-MongoDB.html)with the [Query API](https://www.mongodb.com/docs/manual/tutorial/query-documents/). Atlas App Services provides data access [rules](https://www.mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) on collections to securely retrieve results based on the logged-in user or the content of each document. ## Note ### Example Dataset The examples on this page use a MongoDB collection that describes inventory in a chain of plant stores. For more information on the collection schema and document contents, see [Example Data.](#std-label-node-mongodb-example-dataset) ## Use Cases There are a variety of reasons you might want to query a MongoDB data source. Working with data in your client via Atlas Device Sync is not always practical or possible. You might want to query MongoDB when: * The data set is large or the client device has constraints against loading the entire data set\n* You are [creating or updating custom user data](https://mongodb.com/docs/realm/sdk/node/advanced/access-custom-user-data/#std-label-node-access-custom-user-data)\n* You are retrieving documents that are not modeled in Realm\n* Your app needs to access collections that don't have strict schemas\n* A non-Realm service generates collections that you want to access While not exhaustive, these are some common use cases for querying MongoDB directly. ## Prerequisites Before you can query MongoDB from your Node.js application, you must set up MongoDB Data Access in your App Services App. To learn how to set up your backend App to let the Realm SDK query Atlas, refer to [Set Up MongoDB Data Access](https://www.mongodb.com/docs/atlas/app-services/mongodb/data-access/#std-label-client-data-access)in the App Services documentation. ## Example ### Example Data The examples on this page use the following MongoDB collection that describes various plants for sale in a chain of plant stores:\n\n ` Documents in the `plants` collection use the following schema: ## Connect to a Linked Cluster To access a linked cluster from your client application, pass the cluster name to [User.mongoClient()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#mongoClient). This returns a MongoDB service interface that you can use to access databases and collections in the cluster. ## Read Operations ### Find a Single Document To find a single document, pass a query that matches the document to[collection.findOne()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#findOne). If you do not pass a query, `findOne()` matches the first document it finds in the collection. The following snippet finds the document that describes \"venus flytrap\" plants in the[collection of documents that describe plants for sale in a group of stores:](#std-label-node-mongodb-example-dataset) ```js const venusFlytrap = await plants.findOne({ name: \"venus flytrap\" }); console.log(\"venusFlytrap\", venusFlytrap); \n``` HIDE OUTPUT `| {                                          |\n| ------------------------------------------ |\n| _id: ObjectId(\"5f87976b7b800b285345a8b4\"), |\n| name: \"venus flytrap\",                     |\n| sunlight: \"full\",                          |\n| color: \"white\",                            |\n| type: \"perennial\",                         |\n| _partition: \"Store 42\",                    |\n| }                                          | ` ### Find Multiple Documents To find multiple documents, pass a query that matches the documents to[collection.find()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#find). If you do not pass a query, `find()` matches all documents in the collection. The following snippet finds all documents that describe perennial plants in the[collection of documents that describe plants for sale in a group of stores:](#std-label-node-mongodb-example-dataset) ```js const perennials = await plants.find({ type: \"perennial\" }); console.log(\"perennials\", perennials); \n``` HIDE OUTPUT ```js [   { _id: ObjectId(\"5f87976b7b800b285345a8b4\"), name: 'venus flytrap', sunlight: 'full', color: 'white', type: 'perennial', _partition: 'Store 42' },   { _id: ObjectId(\"5f87976b7b800b285345a8b6\"), name: 'thai basil', sunlight: 'partial', color: 'green', type: 'perennial', _partition: 'Store 42' },   { _id: ObjectId(\"5f879f83fc9013565c23360e\"), name: 'lily of the valley', sunlight: 'full', color: 'white', type: 'perennial', _partition: 'Store 47' },   { _id: ObjectId(\"5f87a0defc9013565c233611\"), name: 'rhubarb', sunlight: 'full', color: 'red', type: 'perennial', _partition: 'Store 47' },\n\n   { _id: ObjectId(\"5f87a0dffc9013565c233613\"), name: 'daffodil', sunlight: 'full', color: 'yellow', type: 'perennial', _partition: 'Store 42' } ] \n``` ### Count Documents To count documents, pass a query that matches the documents to[collection.count()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#count). If you do not pass a query, `count()` counts all documents in the collection. The following snippet counts the number of documents in a [collection of documents that describe plants for sale in a group of stores:](#std-label-node-mongodb-example-dataset) ```js const numPlants = await plants.count(); console.log(`There are ${numPlants} plants in the collection`); \n``` HIDE OUTPUT ```js \"There are 9 plants in the collection\" \n``` ## Write Operations ### Insert a Single Document To insert a single document, pass it to [collection.insertOne().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#insertOne) The following snippet inserts a single document describing a \"lily of the valley\" plant into a [collection of documents that describe plants for sale in a group of stores:](#std-label-node-mongodb-example-dataset) ```js const result = await plants.insertOne({   name: \"lily of the valley\",   sunlight: \"full\",   color: \"white\",   type: \"perennial\",   _partition: \"Store 47\", }); console.log(result); \n``` HIDE OUTPUT ```js {   insertedId: \"5f879f83fc9013565c23360e\", } \n``` ### Insert Multiple Documents To insert multiple documents at the same time, pass them as an array to[collection.insertMany().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#insertMany) The following snippet inserts three documents describing plants into a[collection of documents that describe plants for sale in a group of stores:](#std-label-node-mongodb-example-dataset) ```js const result = await plants.insertMany([   {     name: \"rhubarb\",     sunlight: \"full\",     color: \"red\",     type: \"perennial\",     _partition: \"Store 47\",   },   {     name: \"wisteria lilac\",     sunlight: \"partial\",     color: \"purple\",     type: \"perennial\",     _partition: \"Store 42\",   },   {     name: \"daffodil\",     sunlight: \"full\",     color: \"yellow\",     type: \"perennial\",     _partition: \"Store 42\",   }, ]); console.log(result); \n``` HIDE OUTPUT ```js {   insertedIds: [     \"5f87a0defc9013565c233611\",     \"5f87a0dffc9013565c233612\",     \"5f87a0dffc9013565c233613\",   ], } \n``` ### Update a Single Document To update a single document, pass a query that matches the document and an update document to [collection.updateOne().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#updateOne) The following snippet updates a single document in a [collection of documents that describe plants for sale in a group of stores](#std-label-node-mongodb-example-dataset). This operation queries for a document where the`name` field contains the value \"petunia\" and changes the value of the first matched document's `sunlight` field to \"partial\": ```js const result = await plants.updateOne(   { name: \"petunia\" },   { $set: { sunlight: \"partial\" } } ); console.log(result); \n```\n\n ```js { matchedCount: 1, modifiedCount: 1 } \n``` ### Update Multiple Documents To update multiple documents simultaneously, pass a query that matches the documents and an update description to [collection.updateMany().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#updateMany) The following snippet updates multiple documents in a [collection of documents that describe plants for sale in a group of stores](#std-label-node-mongodb-example-dataset). This operation queries for documents where the`_partition` field contains the value \"Store 47\" and changes the value of the`_partition` field of each matching document to \"Store 51\": ```js const result = await plants.updateMany(   { _partition: \"Store 47\" },   { $set: { _partition: \"Store 51\" } } ); console.log(result); \n``` HIDE OUTPUT ```js { matchedCount: 3, modifiedCount: 3 } \n``` ### Upsert Documents To upsert a document, set the `upsert` option to `true` in your update operation. If the operation's query does not match any document in the collection, an upsert automatically inserts a single new document into the collection that matches the provided query document with the update applied to it. The following snippet updates a document in a [collection of documents that describe plants for sale in a group of stores](#std-label-node-mongodb-example-dataset)with an upsert operation. The query doesn't match any existing documents, so MongoDB automatically creates a new one. ```js const result = await plants.updateOne(   {     sunlight: \"full\",     type: \"perennial\",     color: \"green\",     _partition: \"Store 47\",   },   { $set: { name: \"sweet basil\" } },   { upsert: true } ); console.log(result); \n``` HIDE OUTPUT ```js {   matchedCount: 0,   modifiedCount: 0,   upsertedId: ObjectId(\"5f1f63055512f2cb67f460a3\"), } \n``` ### Delete a Single Document To delete a single document from a collection, pass a query that matches the document to [collection.deleteOne()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#deleteOne). If you do not pass a query or if the query matches multiple documents, then the operation deletes the first document it finds. The following snippet deletes one document in a [collection of documents that describe plants for sale in a group of stores](#std-label-node-mongodb-example-dataset). This operation queries for a document where the `color` field has a value of \"green\" and deletes the first document that matches the query: ```js const result = await plants.deleteOne({ color: \"green\" }); console.log(result); \n``` HIDE OUTPUT ```js { deletedCount: 1 } \n``` ### Delete Multiple Documents To delete multiple document from a collection, pass a query that matches the documents to [collection.deleteMany()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#deleteMany). If you do not pass a query,`deleteMany()` deletes all documents in the collection. The following snippet deletes all documents for plants that are in \"Store 51\" in a [collection of documents that describe plants for sale in a group of stores:](#std-label-node-mongodb-example-dataset) ```js const result = await plants.deleteMany({   _partition: \"Store 51\", }); console.log(result); \n``` HIDE OUTPUT ```js { deletedCount: 3 } \n``` ## Real-time Change Notifications You can call [collection.watch()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#watch)to subscribe to real-time change notifications that MongoDB emits whenever a document in the collection is added, modified, or deleted. Each notification specifies a document that changed, how it changed, and the full document after the operation that caused the event. ## Note\n\n ## Important ### Serverless Limitations You cannot watch for changes if the data source is an Atlas serverless instance. MongoDB serverless currently does not support change streams, which are used on watched collections to listen for changes. ### Watch for All Changes in a Collection To watch for all changes in a collection, call [collection.watch()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#watch) with no arguments: ```javascript for await (const change of plants.watch()) {   switch (change.operationType) {     case \"insert\": {       const { documentKey, fullDocument } = change;       console.log(`new document: ${documentKey}`, fullDocument);       break;     }     case \"update\": {       const { documentKey, fullDocument } = change;       console.log(`updated document: ${documentKey}`, fullDocument);       break;     }     case \"replace\": {       const { documentKey, fullDocument } = change;       console.log(`replaced document: ${documentKey}`, fullDocument);       break;     }     case \"delete\": {       const { documentKey } = change;       console.log(`deleted document: ${documentKey}`);       break;     }   } } \n``` ### Watch for Specific Changes in a Collection To watch for specific changes in a collection, pass a query that matches[change event](https://www.mongodb.com/docs/manual/reference/change-events/) fields to[collection.watch():](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#watch) ```javascript for await (const change of plants.watch({   filter: {     operationType: \"insert\",     \"fullDocument.type\": \"perennial\",   }, })) {   // The change event will always represent a newly inserted perennial   const { documentKey, fullDocument } = change;   console.log(`new document: ${documentKey}`, fullDocument); } \n``` ## Aggregation Operations Aggregation operations run all documents in a collection through a series of stages called an [aggregation pipeline](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/). Aggregation allows you to filter and transform documents, collect summary data about groups of related documents, and other complex data operations. ### Run an Aggregation Pipeline To execute an aggregation pipeline, pass an array of aggregation stages to[collection.aggregate()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.MongoDBCollection.html#aggregate). Aggregation operations return the result set of the last stage in the pipeline. The following snippet groups all documents in the `plants` collection by their`type` value and aggregates a count of the number of each type: ```js const result = await plants.aggregate([   {     $group: {       _id: \"$type\",       total: { $sum: 1 },     },   },   { $sort: { _id: 1 } }, ]); console.log(result); \n``` HIDE OUTPUT ```js [   { _id: \"annual\", total: 1 },   { _id: \"perennial\", total: 5 }, ] \n``` #### Filter Documents You can use the [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) stage to filter documents according to standard MongoDB [query syntax.](https://www.mongodb.com/docs/manual/tutorial/query-documents/) ```javascript {   \"$match\": {     \"<Field Name>\": <Query Expression>,     ...   } } \n``` ## Example The following `$match` stage filters documents to include only those where the `type` field has a value equal to \"perennial\": ```js const perennials = await plants.aggregate([\n\n ]); console.log(perennials); \n``` VIEW OUTPUT #### Group Documents You can use the [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/) stage to aggregate summary data for one or more documents. MongoDB groups documents based on the expression defined in the `_id` field of the `$group` stage. You can reference a specific document field by prefixing the field name with a `$`. ```javascript {   \"$group\": {     \"_id\": <Group By Expression>,     \"<Field Name>\": <Aggregation Expression>,     ...   } } \n``` ## Example The following `$group` stage arranges documents by the value of their`type` field and calculates the number of plant documents that each unique `type` value appears in. ```js const result = await plants.aggregate([   {     $group: {       _id: \"$type\",       numItems: { $sum: 1 },     },   },   { $sort: { _id: 1 } }, ]); console.log(result); \n``` VIEW OUTPUT #### Project Document Fields You can use the [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) stage to include or omit specific fields from documents or to calculate new fields using[aggregation operators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). Projections work in two ways: * Explicitly include fields with a value of 1\\. This has the side-effect of implicitly excluding all unspecified fields.\n* Implicitly exclude fields with a value of 0\\. This has the side-effect of implicitly including all unspecified fields. These two methods of projection are mutually exclusive: if you explicitly include fields, you cannot explicitly exclude fields, and vice versa. ## Note The `_id` field is a special case: it is always included in every query unless explicitly specified otherwise. For this reason, you_can_ exclude the `_id` field with a `0` value while simultaneously including other fields, like `_partition`, with a `1`. Only the special case of exclusion of the `_id` field allows both exclusion and inclusion in one `$project` stage. ```javascript {   \"$project\": {     \"<Field Name>\": <0 | 1 | Expression>,     ...   } } \n``` ## Example The following `$project` stage omits the `_id` field, includes the `name` field, and creates a new field named `storeNumber`. The `storeNumber` is generated using two aggregation operators: 1. `$split` separates the `_partition` value into two string segments surrounding the space character. For example, the value \"Store 42\" split in this way returns an array with two elements: \"Store\" and \"42\".\n2. `$arrayElemAt` selects a specific element from an array based on the second argument. In this case, the value `1` selects the second element from the array generated by the `$split` operator since arrays index from `0`. For example, the value \\[\"Store\", \"42\"\\] passed to this operation would return a value of \"42\". ```js const result = await plants.aggregate([   {     $project: {       _id: 0,       name: 1,       storeNumber: {         $arrayElemAt: [{ $split: [\"$_partition\", \" \"] }, 1],       },     },   }, ]); console.log(result); \n``` VIEW OUTPUT #### Add Fields to Documents You can use the [$addFields](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/) stage to add new fields with calculated values using [aggregation operators.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/) ```javascript { $addFields: { <newField>: <expression>, ... } } \n``` ## Note `$addFields` is similar to [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) but does not allow you to include or omit fields. ## Example\n\n ```js const result = await plants.aggregate([   {     $addFields: {       storeNumber: {         $arrayElemAt: [{ $split: [\"$_partition\", \" \"] }, 1],       },     },   }, ]); console.log(result); \n``` VIEW OUTPUT #### Unwind Array Values You can use the [$unwind](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/) stage to transform a single document containing an array into multiple documents containing individual values from that array. When you unwind an array field, MongoDB copies each document once for each element of the array field but replaces the array value with the array element in each copy. ```javascript {   $unwind: {     path: <Array Field Path>,     includeArrayIndex: <string>,     preserveNullAndEmptyArrays: <boolean>   } } \n``` ## Example The following example uses the `$unwind` stage for each object's `type` and `color`combination. The aggregation pipeline has the following steps: 1. Use `$group` stage with `$addToSet` to create new documents for each `type` with a new field `colors` that contains an array of all the the colors for that flower type that occur in the collection.\n2. Use `$unwind` stage to create separate documents for each combination of type and color.\n3. Use `$sort` stage to sort the results in alphabetical order. ```js const result = await plants.aggregate([   { $group: { _id: \"$type\", colors: { $addToSet: \"$color\" } } },   { $unwind: { path: \"$colors\" } },   { $sort: { _id: 1, colors: 1 } }, ]); console.log(result); \n``` VIEW OUTPUT ← [Create & Manage User API Keys - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/manage-user-api-keys/ \"Previous Section\")[Realm Integrations - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/integrations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/data-types/collections/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Collections - Node.js SDK On this page * [Overview](#overview)\n* [Results](#results)\n* [Lists](#lists)\n* [Results are Lazily Evaluated](#results-are-lazily-evaluated)\n* [Collections are Live](#collections-are-live)\n* [Working With Collections](#working-with-collections)\n* [Limiting Query Results](#limiting-query-results)\n* [Pagination](#pagination)\n* [Summary](#summary) ## Overview Realm has several types to represent groups of objects, which we call **collections**. A collection is an object that contains zero or more instances of one [Realm type.](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-types) You can filter and sort any collection using Realm Database's[query engine](https://mongodb.com/docs/realm/sdk/node/examples/query-data/#std-label-node-client-query-engine). Collections are[live](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-live-objects), so they always reflect the current state of the realm instance on the current thread. You can also listen for changes in the collection by subscribing to [collection notifications.](https://mongodb.com/docs/realm/sdk/node/examples/react-to-changes/#std-label-node-register-a-collection-change-listener) ## Results A [Results](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Results.html) collection represents the lazily-evaluated results of a query operation. Results are immutable: you cannot add or remove elements to or from the results collection. Results have an associated query that determines their contents. ## Tip ### See also:  [Reads](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-realm-database-reads) ## Lists A [List](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.List.html) represents a collection of values of a single type. Lists are declared as a property within an[object model](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas), and are not associated with a query. Lists behave like normal JavaScript arrays, except that they can only store values of a single type, which you indicate by setting the[type](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.List.html#type) property to one of the valid [property types](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~PropertyType) or to the name of another Realm object type.\n\n ` You can only modify a List within a write transaction, and Lists are mutable: within the write transaction, you can add and remove elements to and from the List. ## Results are Lazily Evaluated Realm Database only runs a query when you request the results of that query. This lazy evaluation enables you to write elegant, highly-performant code for handling large data sets and complex queries. ## Collections are Live Like [live objects](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-live-objects), Realm collections are usually **live**: * Live results collections always reflect the current results of the associated query.\n* Live lists always reflect the current state of the relationship on the realm instance. A collection is **not** live when: * it is a [results collection](#std-label-node-realm-results) that you are iterating through using a [for..in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)or [for..of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of) statement. Both statements will continue to iterate through objects in the collection even if you have deleted or modified the collection's objects to exclude them from the filter that produced the results collection.\n* the collection is a frozen [Results.snapshot().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#snapshot) Combined with [collection notifications](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-change-notifications), live collections enable reactive code. For example, suppose your view displays the results of a query. You can keep a reference to the results collection in your view class, then read the results collection as needed without having to refresh it or validate that it is up-to-date. ## Important ### Indexes may change Since results update themselves automatically, do not store the positional index of an object in the collection or the count of objects in a collection. The stored index or count value could be outdated by the time you use it. ## Working With Collections ### Limiting Query Results As a result of lazy evaluation, you do not need any special mechanism to limit query results with Realm Database. For example, if your query matches thousands of objects, but you only want to load the first ten, access only the first ten elements of the results collection. ### Pagination Thanks to lazy evaluation, the common task of pagination becomes quite simple. For example, suppose you have a results collection associated with a query that matches thousands of objects in your realm. You display one hundred objects per page. To advance to any page, simply access the elements of the results collection starting at the index that corresponds to the target page. ## Summary * A Realm **collection** is a homogenous container of zero or more instances of one[Realm type.](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-types)\n* There are two main kinds of collection: **lists** and **results**. Lists define the [to-many relationships](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-to-many-relationship)of your Realm types, while results represent the lazily-loaded output of a [read operation.](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-realm-database-reads)\n* Lazy evaluation of results collections means there is no need to design a special query to get limited or paginated results. Perform the query and read from the results collection as needed.\n* Data in Realm is _live_, which means that an object always reflects its most recent saved state. ← [Field Types - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/field-types/ \"Previous Section\")[Dictionaries - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/dictionaries/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Define a Realm Object Schema - Node.js SDK On this page * [Define Realm Object Types with JavaScript Classes](#define-realm-object-types-with-javascript-classes)\n* [Supported Property Types](#supported-property-types)\n* [Define Object Properties](#define-object-properties)\n* [Specify an Optional Property](#specify-an-optional-property)\n* [Specify a Primary Key](#specify-a-primary-key)\n* [Index a Property](#index-a-property)\n* [Define a Default Property Value](#define-a-default-property-value)\n* [Remap a Property](#remap-a-property)\n* [Define Relationship Properties](#define-relationship-properties)\n* [Define a To-One Relationship Property](#define-a-to-one-relationship-property)\n* [Define a To-Many Relationship Property](#define-a-to-many-relationship-property)\n* [Define an Inverse Relationship Property](#define-an-inverse-relationship-property)\n* [Define an Embedded Object Property](#define-an-embedded-object-property)\n* [Define an Asymmetric Object](#define-an-asymmetric-object) To define a Realm object type, create a schema object that specifies the type's`name` and `properties`. The type name must be unique among object types in a realm. For details on how to define specific properties, see [Define Object Properties.](#std-label-node-define-a-property) You can define your schemas with JavaScript classes (like most of the examples on this page), but you can also define them as JavaScript objects. `| const Car = {    |\n| ---------------- |\n| name: \"Car\",     |\n| properties: {    |\n| _id: \"objectId\", |\n| make: \"string\",  |\n| model: \"string\", |\n| miles: \"int?\",   |\n| },               |\n| };               | ` ## Define Realm Object Types with JavaScript Classes You can define Realm object types with JavaScript classes. To use a class as an object type, define the object schema on the static property `schema`. ```javascript class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: { type: 'objectId', default: () => new Realm.BSON.ObjectId() },       make: \"string\",       model: \"string\",       miles: \"int?\",     },     primaryKey: '_id',   }; } \n``` ## Note Class names are limited to a maximum of 57 UTF-8 characters. Pass the class itself to the schema property of the [Realm.Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) object when opening a realm. You can then [read and write data](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/) normally. ```javascript const realm = await Realm.open({   path: \"myrealm\",   schema: [Car], }); let car1; realm.write(() => {   car1 = realm.create(Car, {     make: \"Nissan\",     model: \"Sentra\",     miles: 1000,   }); }); \n``` ## Supported Property Types Every property in a Realm object has a strongly defined data type. A property's type can be a primitive data type or an object type defined in the same realm. The type also specifies whether the property contains a single value or a list of values. Realm Database supports the following primitive data types:\n\n To specify that a field contains a list of a primitive value type, append `[]`to the type name. ## Define Object Properties To define a property for an object type, create a key-value pair representing the name and data type of the property under the `properties` field. The following schema defines a `Car` type that has these properties: `_id` `make`, `model`, and `miles`. ```javascript class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: { type: 'objectId', default: () => new Realm.BSON.ObjectId() },       make: \"string\",       model: \"string\",       miles: \"int?\",     },     primaryKey: '_id',   }; } \n``` ### Specify an Optional Property To mark a property as optional, append a question mark `?` to its type. The following `Car` schema defines an optional `miles` property of type `int`. ```javascript class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: { type: 'objectId', default: () => new Realm.BSON.ObjectId() },       make: \"string\",       model: \"string\",       miles: \"int?\",     },     primaryKey: '_id',   }; } \n``` ### Specify a Primary Key To specify a property as an object type's primary key, set the schema's`primaryKey` field to the property name. ## Note A **primary key** is a property that uniquely identifies an object. Realm Database automatically [indexes](#std-label-node-indexes)primary key properties, which allows you to efficiently read and modify objects based on their primary key. If an object type has a primary key, then all objects of that type must include the primary key property with a value that is unique among objects of the same type in a realm. An object type may have at most one primary key. You cannot change the primary key property for an object type after any object of that type is added to a realm and you cannot modify an object's primary key value. The following `Car` object schema specifies the `_id` property as its primary key. ```javascript class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: { type: 'objectId', default: () => new Realm.BSON.ObjectId() },       make: \"string\",       model: \"string\",       miles: \"int?\",     },     primaryKey: '_id',   }; } \n``` ### Index a Property Realm supports indexing for string, integer, boolean, `Date`, `UUID`, and `ObjectId`properties. To define an index for a given property, set `indexed` to`true`. ## Note An **index** significantly increases the speed of certain read operations at the cost of slightly slower write times and additional storage and memory overhead. Realm Database stores indexes on disk, which makes your realm files larger. Each index entry is a minimum of 12 bytes. The ordering of the index entries supports efficient equality matches and range-based query operations. It's best to only add indexes when optimizing the read performance for specific situations. The following `Car` object schema defines an index on the `_id`property. ```javascript class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: { type: \"objectId\", indexed: true },       make: \"string\",       model_name: { type: \"string\", mapTo: \"modelName\" },       miles: { type: \"int\", default: 0 },     },     primaryKey: '_id',   }; } \n``` ### Define a Default Property Value To define a default value, set the value of the property to an object with a`type` field and a `default` field. The following `Car` object schema specifies a default value of `0` for the `miles` property: ```javascript class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {\n\n       make: \"string\",       model_name: { type: \"string\", mapTo: \"modelName\" },       miles: { type: \"int\", default: 0 },     },     primaryKey: '_id',   }; } \n``` ### Remap a Property To use a different property name in your code than is stored in Realm Database, set `mapTo` to the name of the property as it appears in your code. In the following `Car` object schema, Realm Database stores the car's model name with the snake case `model_name` property. The schema maps the property to `modelName` for objects used in client code. ```javascript class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: { type: \"objectId\", indexed: true },       make: \"string\",       model_name: { type: \"string\", mapTo: \"modelName\" },       miles: { type: \"int\", default: 0 },     },     primaryKey: '_id',   }; } \n``` ## Define Relationship Properties ## Tip ### See also:  With Device Sync, you can also [define your relationships](https://www.mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-define-a-relationship) in the App Services UI. ### Define a To-One Relationship Property A **to-one** relationship maps one property to a single instance of another object type. For example, you can model a manufacturer having at most one car as a to-one relationship. To define a to-one relationship property, specify the related object type name as the property type. ## Important ### To-one relationships must be optional When you declare a to-one relationship in your object model, it must be an optional property. If you try to make a to-one relationship required, Realm throws an exception at runtime. The following `Manufacturer` object schema specifies that a manufacturer may or may not make a single `Car`. If they do make a `Car`, Realm links to it through the`car` property: ```javascript class Manufacturer extends Realm.Object {   static schema = {     name: \"Manufacturer\",     properties: {       _id: \"objectId\",       // A manufacturer that may have one car       car: \"Car?\"     },   }; } class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: \"objectId\",       make: \"string\",       model: \"string\",       miles: \"int?\",     },   }; } \n``` ### Define a To-Many Relationship Property A **to-many** relationship maps one property to zero or more instances of another object type. For example, you can model a manufacturer having any number of cars as a to-many relationship. To define a to-many relationship property, specify the related object type name as a list. An application could use the following object schemas to indicate that a `Manufacturer`may make multiple `Car` objects by including them in its `cars` property: ```javascript class Manufacturer extends Realm.Object {   static schema = {     name: \"Manufacturer\",     properties: {       _id: \"objectId\",       // A manufacturer that may have many cars       cars: \"Car[]\"     },   }; } class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: \"objectId\",       make: \"string\",       model: \"string\",       miles: \"int?\",     },   }; } \n``` ### Define an Inverse Relationship Property An **inverse relationship** property is an automatic backlink relationship. Realm Database automatically updates implicit relationships whenever an object is added or removed in a corresponding to-many list. You cannot manually set the value of an inverse relationship property. To define an inverse relationship property, set the property type to`linkingObjects` and specify the object type and property name that define the relationship to invert.\n\n * The `Manufacturer` object's `cars` property is defined as a to-many relationship  \nwith `Car` objects and contains all of a given manufacturer's cars.\n* The `Car` object's `assignee` property inverts the relationship and  \nautomatically updates to refer back to any `Manufacturer` object that contains the car in its `cars` property. ```javascript class Manufacturer extends Realm.Object {   static schema = {     name: \"Manufacturer\",     properties: {       _id: \"objectId\",       // A manufacturer that may have many cars       cars: \"Car[]\"     },   }; } class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: \"objectId\",       make: \"string\",       model: \"string\",       miles: \"int?\",       // Backlink to the manufacturer. This is automatically updated whenever       // this car is added to or removed from a manufacturer's cars list.       assignee: {         type: \"linkingObjects\",         objectType: \"Manufacturer\",         property: \"cars\",       }     },   }; } \n``` ### Define an Embedded Object Property To define a Realm object model with an embedded object (nested Realm object), set `embedded` to `true`. An **embedded object** exists as nested data inside of a single, specific parent object. It inherits the lifecycle of its parent object and cannot exist as an independent Realm object. Realm automatically deletes embedded objects if their parent object is deleted or when overwritten by a new embedded object instance. Embedded objects cannot have a primary key. You can reference an embedded object type from parent object types in the same way as a relationship. The following example requires two parent schemas, `Manufacturer` and`Car`. The application requires an embedded child schema `Warranty`. A `Manufacturer` object can embed a list of `Warranty` objects, whereas a`Car` object can only embed a single `Warranty` object. ```javascript class Manufacturer extends Realm.Object {   static schema = {     name: \"Manufacturer\",     properties: {       _id: \"objectId\",       name: \"string\",       // Embed an array of objects       warranties: { type: \"list\", objectType: \"Warranty\" }     },   }; } class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: \"objectId\",       make: \"string\",       model: \"string\",       miles: \"int?\",       // Embed one object       warranty: \"Warranty\",     },   }; } class Warranty extends Realm.Object {   static schema = {     name: \"Warranty\",     embedded: true,     properties: {       name: \"string\",       termLength: \"int\",       cost: \"int\",     },   }; } \n``` ## Define an Asymmetric Object If you are using Flexible Sync and need to sync a collection unidirectionally from your device to your Atlas database, you can set the `asymmetric` property on your object schema. In the following example of a retail app, the client requires large amounts of invoice data to be recorded rapidly by store employees. The client specifies that invoice data does not need to be read after employees have recorded it. To satisfy this requirement, the application developer defines an invoice collection with its `asymmetric` property set to `true`. ```javascript const InvoiceSchema = {   name: \"Invoice\",   // sync Invoice objects one way from your device to your Atlas database.   asymmetric: true,   primaryKey: \"_id\",   properties: {     _id: \"objectId\",     item: \"string\",     quantity: \"int\",     price: \"int\",   }, }; \n``` ## Note\n\n Asymmetric Sync objects cannot be read. If you attempt to query an Asymmetric Sync object, you will get the following error: \"Error: You cannot query an asymmetric class.\". To learn more about Asymmetric Sync, read [Optimize Sync with Asymmetric Sync.](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) ← [Usage Examples - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/ \"Previous Section\")[Open & Close a Realm - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/data-types/uuid/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # UUID - Node.js SDK On this page * [Overview](#overview)\n* [Usage](#usage) _New in version 10.5.0_. ## Overview `UUID` (Universal Unique Identifier) is a 16-byte [unique value](https://en.wikipedia.org/wiki/Universally%5Funique%5Fidentifier). You can use `UUID` as an identifier for objects. `UUID` is [indexable](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-indexes) and you can use it as a[primary key.](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-primary-keys) ## Note ### Using UUID Instead of ObjectId In general, you can use `UUID` for any fields that function as a unique identifier. Using `UUID` might be particularly useful if you are migrating data not stored in MongoDB since it is likely that your object's unique identifiers are already of a `UUID` type. Alternatively, using `ObjectId`might be useful for a collection of data that already exists in MongoDB. ## Usage To define a property as a `UUID`, set its type to the string `\"uuid\"` in your [object model](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas). Create a Realm object within a write transaction. To set any unique identifier properties of your object to a random value, call `new UUID()`. Alternatively, pass a string to `new UUID()` to set the unique identifier property to a specific value.\n\n ` ← [Mixed - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/mixed/ \"Previous Section\")[Embedded Objects - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/embedded-objects/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/data-types/field-types/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Field Types - Node.js SDK Realm Database supports the following field data types: * `bool` maps to the JavaScript [Boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Boolean) type\n* `int` maps to the JavaScript [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) type. Internally, Realm Database stores `int` with 64 bits.\n* `float` maps to the JavaScript [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) type. Internally, Realm Database stores `float` with 32 bits.\n* `double` maps to the JavaScript [Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) type. Internally, Realm Database stores `double` with 64 bits.\n* `string` maps to the JavaScript [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Boolean) type.\n* `decimal128` for high precision numbers.\n* `objectId` maps to BSON [ObjectId](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) type.\n* `data` maps to the JavaScript [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/ArrayBuffer) type.\n* `date` maps to the JavaScript [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date) type.\n* `list` maps to the JavaScript [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array) type. You can also specify that a field contains a list of primitive value types by appending `[]` to the type name.\n* `linkingObjects` is a special type used to define an inverse relationship.\n* `dictionary` used to manage a collection of unique String keys paired with values. The `Dictionary` data type is available in the [realm-js@10.5.0 release.](https://github.com/realm/realm-js/releases/tag/v10.5.0)\n* `set` is based on the JavaScript [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set) type. `Realm Set` is available in the [realm-js@10.5.0 release.](https://github.com/realm/realm-js/releases/tag/v10.5.0)\n* `mixed` is a property type that can hold different data types. The `Mixed` data type is available in the [realm-js@10.5.0 release.](https://github.com/realm/realm-js/releases/tag/v10.5.0)\n* `uuid` is a universally unique identifier from [Realm.BSON](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.BSON). The `UUID` data type is available in the [realm-js@10.5.0 release.](https://github.com/realm/realm-js/releases/tag/v10.5.0) ← [Realm Data Types - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/ \"Previous Section\")[Collections - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/collections/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Read & Write Data - Node.js SDK On this page * [About the Examples on this Page](#about-the-examples-on-this-page)\n* [Read Operations](#read-operations)\n* [Find a Specific Object by Primary Key](#find-a-specific-object-by-primary-key)\n* [Query an Object Type](#query-an-object-type)\n* [Filter Queries](#filter-queries)\n* [Sort Query Results](#sort-query-results)\n* [Write Operations](#write-operations)\n* [Create a New Object](#create-a-new-object)\n* [Update an Object](#update-an-object)\n* [Upsert an Object](#upsert-an-object)\n* [Bulk Update a Collection](#bulk-update-a-collection)\n* [Delete an Object](#delete-an-object)\n* [Delete Multiple Objects](#delete-multiple-objects)\n* [Delete All Objects of a Specific Type](#delete-all-objects-of-a-specific-type)\n* [Delete All Objects in a Realm](#delete-all-objects-in-a-realm) ## About the Examples on this Page The examples on this page use the following schemas: `| const TaskSchema = {     |\n| ------------------------ |\n| name: \"Task\",            |\n| properties: {            |\n| _id: \"int\",              |\n| name: \"string\",          |\n| priority: \"int?\",        |\n| progressMinutes: \"int?\", |\n| },                       |\n| primaryKey: \"_id\",       |\n| };                       |\n| const PersonSchema = {   |\n| name: \"Person\",          |\n| properties: {            |\n| name: \"string\",          |\n| age: \"int?\",             |\n| },                       |\n| };                       |\n| const DogSchema = {      |\n| name: \"Dog\",             |\n| properties: {            |\n| name: \"string\",          |\n| owner: \"Person?\",        |\n| age: \"int?\",             |\n| },                       |\n| };                       |\n| const CatSchema = {      |\n| name: \"Cat\",             |\n| properties: {            |\n| name: \"string\",          |\n| },                       |\n| };                       | ` ## Read Operations ### Find a Specific Object by Primary Key\n\n ```javascript const myTask = realm.objectForPrimaryKey(\"Task\", 12342245); // search for a realm object with a primary key that is an int. \n``` ### Query an Object Type To query for objects of a given type in a realm, pass the type name to[Realm.objects().](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#objects) Query operations return a collection of Realm objects that match the query as a [Realm.Results](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Results.html) object. A basic query matches all objects of a given type in a realm, but you can also apply a[filter](#std-label-node-filter-queries) to the collection to find specific objects. ```javascript // Query realm for all instances of the \"Task\" type. const tasks = realm.objects(\"Task\"); \n``` ### Filter Queries A **filter** selects a subset of results based on the value(s) of one or more object properties. Realm Database lets you filter data using[Realm Query Language](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql), a string-based query language to constrain searches when retrieving objects from a realm. To filter a query, call [filtered()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#filtered) on the query results collection. Pass a Realm Query Language query as argument to `filtered()`. In the following example, we use the [query engine](https://mongodb.com/docs/realm/sdk/node/examples/query-data/#std-label-node-client-query-engine)'s comparison operators to: * Find high priority tasks by comparing the value of the `priority` property value with a threshold number, above which priority can be considered high.\n* Find just-started or short-running tasks by seeing if the `progressMinutes`property falls within a certain range. ```javascript // retrieve the set of Task objects const tasks = realm.objects(\"Task\"); // filter for tasks with a high priority const highPriorityTasks = tasks.filtered(\"priority > 5\"); // filter for tasks that have just-started or short-running progress const lowProgressTasks = tasks.filtered(   \"1 <= progressMinutes && progressMinutes < 10\" ); console.log(   `Number of high priority tasks: ${highPriorityTasks.length} \\n`,   `Number of just-started or short-running tasks: ${lowProgressTasks.length}` ); \n``` ## Tip ### Filter on Related and Embedded Object Properties To filter a query based on a property of an [embedded object](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-embedded-objects) or a [related object](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-client-relationships), use dot-notation as if it were in a regular, nested object. ## Tip ### See also:  * [Realm Query Language Reference](https://mongodb.com/docs/realm/realm-query-language/#std-label-rql)\n* [Query Data - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/query-data/#std-label-node-query-data) ### Sort Query Results A **sort** operation allows you to configure the order in which Realm Database returns queried objects. You can sort based on one or more properties of the objects in the results collection. Realm Database only guarantees a consistent order of results if you explicitly sort them. To sort a query, call the [sorted()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#sorted)method on the query results collection. ```javascript // retrieve the set of Task objects const tasks = realm.objects(\"Task\"); // Sort tasks by name in ascending order const tasksByName = tasks.sorted(\"name\"); // Sort tasks by name in descending order const tasksByNameDescending = tasks.sorted(\"name\", true); // Sort tasks by priority in descending order and then by name alphabetically const tasksByPriorityDescendingAndName = tasks.sorted([   [\"priority\", true],   [\"name\", false], ]);\n\n let dogsByOwnersName = realm.objects(\"Dog\").sorted(\"owner.name\"); \n``` ## Tip ### Sort on Related and Embedded Object Properties To sort a query based on a property of an [embedded object](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-embedded-objects) or a [related object](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-client-relationships), use dot-notation as if it were in a regular, nested object. ## Write Operations ### Create a New Object To add an object to a realm, instantiate it as you would any other object and then pass it to [Realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) inside of a write transaction. If the realm's [schema](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-realm-schema) includes the object type and the object conforms to the schema, then Realm stores the object, which is now _managed_ by the realm. ```javascript // Declare the variable that will hold the dog instance. let dog; // Open a transaction. realm.write(() => {   // Assign a newly-created instance to the variable.   dog = realm.create(\"Dog\", { name: \"Max\", age: 5 }); }); // use newly created dog object \n``` ### Update an Object You can add, modify, or delete properties of a Realm object inside of a write transaction in the same way that you would update any other JavaScript object. ```javascript // Open a transaction. realm.write(() => {   // Get a dog to update.   const dog = realm.objects(\"Dog\")[0];   // Update some properties on the instance.   // These changes are saved to the realm.   dog.name = \"Maximilian\";   dog.age += 1; }); \n``` ## Tip ### Update Related and Embedded Objects To update a property of an [embedded object](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-embedded-objects) or a [related object](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-client-relationships), modify the property with[dot-notation or bracket-notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors) as if it were in a regular, nested object. ### Upsert an Object To upsert an object, call [Realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) with the update mode set to `modified`. The operation either inserts a new object with the given primary key or updates an existing object that already has that primary key. ```javascript realm.write(() => {   // Add a new person to the realm. Since nobody with ID 1234   // has been added yet, this adds the instance to the realm.   person = realm.create(     \"Person\",     { _id: 1234, name: \"Joe\", age: 40 },     \"modified\"   );   // If an object exists, setting the third parameter (`updateMode`) to   // \"modified\" only updates properties that have changed, resulting in   // faster operations.   person = realm.create(     \"Person\",     { _id: 1234, name: \"Joseph\", age: 40 },     \"modified\"   ); }); \n``` ### Bulk Update a Collection To apply an update to a collection of objects, iterate through the collection (e.g. with [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)). In the loop, update each object individually: ```javascript realm.write(() => {   // Create someone to take care of some dogs.   const person = realm.create(\"Person\", { name: \"Ali\" });   // Find dogs younger than 2.   const puppies = realm.objects(\"Dog\").filtered(\"age < 2\");\n\n   for (const puppy of puppies) {     // Give all puppies to Ali.     puppy.owner = person;   } }); \n``` ## Note ### Inverse Relationships Thanks to an [inverse relationship](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-inverse-relationship) from`Dog.owner` to `Person.dogs`, Realm Database automatically updates Ali's list of dogs whenever we set her as a puppy's owner. ### Delete an Object To delete an object from a realm, pass the object to [Realm.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#delete) inside of a write transaction. ```javascript realm.write(() => {   // Delete the dog from the realm.   realm.delete(dog);   // Discard the reference.   dog = null; }); \n``` ## Important ### Do not use objects after delete You cannot access or modify an object after you have deleted it from a Realm. If you try to use a deleted object, Realm Database throws an error. ### Delete Multiple Objects To delete a collection of objects from a realm, pass the collection to[Realm.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#delete) inside of a write transaction. ```javascript realm.write(() => {   // Find dogs younger than 2 years old.   const puppies = realm.objects(\"Dog\").filtered(\"age < 2\");   // Delete the collection from the realm.   realm.delete(puppies); }); \n``` ### Delete All Objects of a Specific Type To delete all objects of a given object type from a realm, pass`Realm.objects(<ObjectType>)` to the [Realm.delete()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#delete) method inside of a write transaction. ```javascript realm.write(() => {   // Delete all instances of Cat from the realm.   realm.delete(realm.objects(\"Cat\")); }); \n``` ### Delete All Objects in a Realm To delete **all** objects from the realm, call [Realm.deleteAll()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#deleteAll) inside of a write transaction. This clears the realm of all object instances but does not affect the realm's schema. ```javascript realm.write(() => {   // Delete all objects from the realm.   realm.deleteAll(); }); \n``` ## Tip ### Delete All In Development [Realm.deleteAll()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#deleteAll) is a useful method to quickly clear out your realm in the course of development. For example, rather than writing a migration to update objects to a new schema, it may be faster to delete and then re-generate the objects with the app itself. ← [Open & Close a Realm - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/ \"Previous Section\")[React to Changes - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/react-to-changes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/advanced/link-identities/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Link User Identities - Node.js SDK ## Overview Realm provides [many authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)to log users into your app. Each provider creates a unique user identity. Realm lets you merge multiple credentials into one user identity. ## Example Consider an application that offers [anonymous login](https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication). This allows users to explore the app without registering. If users like the application, they create permanent accounts. They sign up with SSO or email/password authentication. By default, this creates a new `User` object. The app must link the new identity with the original User. You can link identities using [linkCredentials()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#linkCredentials). This links authentication providers to a logged-in `User` object. ← [Multi-User Applications - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/multi-user-applications/ \"Previous Section\")[Encrypt a Realm - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/encrypt/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/data-types/sets/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Sets - Node.js SDK On this page * [Overview](#overview)\n* [Realm Object Models](#realm-object-models)\n* [Create an Object With a Set](#create-an-object-with-a-set)\n* [Add Items to a Set](#add-items-to-a-set)\n* [Check if a Set has Specific Items](#check-if-a-set-has-specific-items)\n* [Check the Size of a Set](#check-the-size-of-a-set)\n* [Remove an Item from a Set](#remove-an-item-from-a-set)\n* [Remove all Items from a Set](#remove-all-items-from-a-set)\n* [Traverse a Set](#traverse-a-set) _New in version 10.5.0_. ## Overview A **Realm Set** is a special object that allows you to store a collection of unique values. **Realm Sets** are based on JavaScript[sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set), but can only contain values of a single type and can only be modified within a write transaction. Sets allow you to perform math operations such as finding the union, intersection, or difference between two sets. To learn more about performing these operations, see the MDN docs for [Implementing basic set operations.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set#implementing%5Fbasic%5Fset%5Foperations) ## Realm Object Models To define a property type as a **Realm Set**, specify the data type you want in the set, followed by `<>`. For instance, for a set made of integer values, specify `\"int<>\"`. `| const characterSchema = { |\n| ------------------------- |\n| name: \"Character\",        |\n| primaryKey: \"_id\",        |\n| properties: {             |\n| _id: \"objectId\",          |\n| name: \"string\",           |\n| levelsCompleted: \"int<>\", |\n| inventory: \"string<>\",    |\n| },                        |\n| };                        | ` ## Create an Object With a Set To create an object with a **Realm Set** property, you must create the object within a write transaction. When defining your Realm object, initialize the **Realm Set** by passing an empty array or an array with your initial values. ```javascript let playerOne, playerTwo; realm.write(() => {   playerOne = realm.create(\"Character\", {     _id: new BSON.ObjectId(),     name: \"PlayerOne\",     inventory: [\"elixir\", \"compass\", \"glowing shield\"],     levelsCompleted: [4, 9],   });   playerTwo = realm.create(\"Character\", {     _id: new BSON.ObjectId(),     name: \"PlayerTwo\",     inventory: [\"estus flask\", \"gloves\", \"rune\"],     levelsCompleted: [1, 2, 5, 24],   }); }); \n``` ## Add Items to a Set To add an item to a set, pass the new value to the `<Realm.Set>.add()` method within a write transaction. ```javascript realm.write(() => {   playerOne.inventory.add(\"hammer\");   playerOne.levelsCompleted.add(32); }); \n``` ## Check if a Set has Specific Items To determine if a set contains a particular value, pass the value to the `<Realm.Set>.has()` method. The`set.has()` method will return true if the set contains the value specified. ```javascript // check if playerTwo has completed level 3 by calling the `has()` method  // on the Realm Set object\n\n console.log(   `Is level three completed by playerTwo: ${playerTwoHasCompletedLevelThree}` ); \n``` ## Check the Size of a Set To discover how many items are in a set, you can check the set's `size` property. ```javascript // check how many items playerTwo has in his inventory through the `size`  // property of the Realm Set object const playerTwoInventorySize = playerTwo.inventory.size; console.log(`playerTwo has ${playerTwoInventorySize} inventory items`); \n``` ## Remove an Item from a Set To remove a specific value from a set, pass the value to the `<Realm.Set>.delete()` method within a write transaction. ```javascript realm.write(() => {   // remove the compass from playerOne's inventory by calling the    // `delete()` method of the Realm Set object within a write transaction   playerOne.inventory.delete(\"compass\"); }); \n``` ## Remove all Items from a Set To clear the set, run the `<Realm.Set>.clear()` method within a write transaction. ```javascript realm.write(() => {   // clear all data from the inventory slot of playerTwo by calling    // the `clear()` method of the Realm Set object in a write transaction   playerTwo.inventory.clear(); }); \n``` ## Traverse a Set To traverse a set, use the `<Realm.Set>.forEach()` method or alternative [iteration method.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set#iteration%5Fmethods) ```javascript playerOne.inventory.forEach((item) => {   console.log(item); }); \n``` ## Example ### Traversing a Set in Order The order of the **Realm Set** may be different from the order that the items were added. You can track the set order by updating an array when a new value is added. For example: ```javascript function updateSetAndOrderedSetArray(set, orderedArray, value) {   const oldSize = set.size;   set.add(value);   if (set.size > oldSize) {     orderedArray.push(value);   } } let playerOne; let levelsCompletedInOrder = []; const realm = await Realm.open({   schema: [characterSchema], }); realm.write(() => {   playerOne = realm.create(\"Character\", {     _id: new BSON.ObjectId(),     name: \"PlayerOne\",     inventory: [\"potion\", \"wand\", \"spell book\"],     levelsCompleted: [],   }); }); realm.write(() => {   updateSetAndOrderedSetArray(     playerOne.levelsCompleted,     levelsCompletedInOrder,     5   ); }); realm.write(() => {   updateSetAndOrderedSetArray(     playerOne.levelsCompleted,     levelsCompletedInOrder,     12   ); }); realm.write(() => {   updateSetAndOrderedSetArray(     playerOne.levelsCompleted,     levelsCompletedInOrder,     2   ); }); realm.write(() => {   updateSetAndOrderedSetArray(     playerOne.levelsCompleted,     levelsCompletedInOrder,     7   ); }); console.log(\"set ordered\", Array.from(playerOne.levelsCompleted)); // not necessarily [5, 12, 2, 7] console.log(\"insert ordered\", levelsCompletedInOrder); // [5, 12, 2, 7] // close the realm realm.close(); \n``` ← [Dictionaries - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/dictionaries/ \"Previous Section\")[Mixed - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/mixed/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/advanced/access-custom-user-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Access Custom User Data - Node.js SDK On this page * [Before You Begin](#before-you-begin)\n* [Read Custom User Data](#read-custom-user-data)\n* [Write to Custom User Data with a MongoClient](#write-to-custom-user-data-with-a-mongoclient) You can store arbitrary custom data about your users with Atlas App Services. For example, you might store a user's preferred language, date of birth, or local timezone. Before writing and reading this data, you must enable custom user data in the backend. To learn more, see [Enable Custom User Data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ## Before You Begin To use custom user data, you must first enable custom user data in App Services: 1. [Create an App.](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n2. [Enable custom user data.](https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-enable-custom-user-data-procedure)\n3. [Create a user](https://mongodb.com/docs/realm/sdk/node/examples/create-delete-users/#std-label-node-create-and-delete-users) to apply custom data to. ## Read Custom User Data You retrieve custom user data in the [customData](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#customData)property of the `User` object: `| const customUserData = app.currentUser.customData; |\n| -------------------------------------------------- |\n| console.log(customUserData);                       | ` App Services **does not immediately update** the value of the`User.customData` when underlying data changes. Instead, App Services fetches the most recent version of custom user data whenever a user refreshes their [access token](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) or when you explicitly call [refreshCustomData()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.User.html#refreshCustomData), which ensures your app has the latest custom user data. ```javascript const updatedCustomUserData = await user.refreshCustomData(); console.log(updatedCustomUserData); \n``` ## Note The `customData` field of the user object is read-only from a Node application. ## Write to Custom User Data with a MongoClient Using standard CRUD operations through the [MongoDB Atlas service](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) and a [mongoClient](https://mongodb.com/docs/realm/sdk/node/examples/query-mongodb/#std-label-node-mongodb-data-access), you can access a user's custom data. The following example updates a user's custom data to alter the user's `favoriteColor` to pink. ```javascript // A user must be logged in to use a mongoClient const user = app.currentUser; const mongo = user.mongoClient(\"mongodb-atlas\"); const collection = mongo.db(\"custom-user-data-database\").collection(\"custom-user-data\"); // Query for the user object of the logged in user const filter = { userId: user.id}; // Set the logged in user's favorite color to pink const update = { $set: { favoriteColor: \"pink\" }}; // Insert document if it doesn't already exist const options = { upsert: true }; const result = await collection.updateOne(filter, update, options); \n``` ## Note\n\n ← [Advanced Guides - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/ \"Previous Section\")[Multi-User Applications - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/multi-user-applications/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/data-types/dictionaries/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Dictionaries - Node.js SDK On this page * [Overview](#overview)\n* [Realm Object Models](#realm-object-models)\n* [Create an Object with a Dictionary Value](#create-an-object-with-a--dictionary-value)\n* [Query for Objects with a Dictionary Property](#query-for-objects-with-a-dictionary-property)\n* [Add a Listener to a Dictionary](#add-a-listener-to-a-dictionary)\n* [Update a Dictionary](#update-a-dictionary)\n* [Delete Members of a Dictionary](#delete-members-of-a-dictionary) _New in version 10.5.0_. ## Overview You can use the `dictionary` data type to manage a collection of unique String keys paired with values. The `dictionary` data maps to the Javascript[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object) type. ## Realm Object Models To define a dictionary of mixed values in your schema, set the data type of your field to an empty object, `\"{}\"`. Alternatively, to create a dictionary with values of a specific type, add the data type before the brackets. For instance, `\"int{}\"` to specify that dictionary values must be integers or `\"string{}\"` to specify that dictionary values must be strings. `| const PersonSchema = { |\n| ---------------------- |\n| name: \"Person\",        |\n| properties: {          |\n| name: \"string\",        |\n| home: \"{}\",            |\n| },                     |\n| };                     | ` ## Create an Object with a Dictionary Value Create an object with a dictionary value by running the [realm.create()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#create) method within a write transaction. ```javascript let johnDoe; let janeSmith; realm.write(() => {   johnDoe = realm.create(\"Person\", {     name: \"John Doe\",     home: {       windows: 5,       doors: 3,       color: \"red\",       address: \"Summerhill St.\",       price: 400123,     },   });   janeSmith = realm.create(\"Person\", {     name: \"Jane Smith\",     home: {       address: \"100 northroad st.\",       yearBuilt: 1990,     },   }); }); \n``` ## Query for Objects with a Dictionary Property To filter a query, run [collection.filtered()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Collection.html#filtered) to specify a subset of results based on the value(s) of one or more object properties. You can specify results based on the value of a dictionary's properties by using [bracket-notation.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors) You can also determine whether a results collection has a certain key or value by using `<dictionary>.@keys` or `<dictionary>.@values`. For instance, if you had a `Person` collection with a nested `home` dictionary, you could return all `Person` objects with a `home` with a `\"price\"` property by running the query: `home.@keys = \"price\"`. ```javascript // query for all Person objects const persons = realm.objects(\"Person\"); // run the `.filtered()` method on all the returned persons to  // find the house with the address \"Summerhill St.\" const summerHillHouse = persons.filtered(   `home['address'] = \"Summerhill St.\"` )[0].home;\n\n const peopleWithHousesWithAListedPrice = persons.filtered(   `home.@keys = \"price\" ` ); // find a house that has any field with a value of 'red' const redHouse = persons.filtered(`home.@values = \"red\" `)[0].home; \n``` ## Add a Listener to a Dictionary You can add a listener to a dictionary by running the[dictionary.addListener()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.List.html#addListener) method. The`addListener` method's callback function has two parameters, the changed dictionary and an array of changes describing how the dictionary was changed. ## Note Learn more about [change notifications.](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-change-notifications) ```javascript summerHillHouse.addListener((changedHouse, changes) => {   console.log(\"A change has occurred to the Summer Hill House object\"); }); \n``` ## Update a Dictionary To update a dictionary's properties, use dot notation or the `dictionary.put()` method. ```javascript realm.write(() => {   // use the `put()` method to update a field of a dictionary   summerHillHouse.put({ price: 400100 });   // alternatively, update a field of a dictionary through dot notation   summerHillHouse.color = \"brown\";   // update a dictionary by adding a field   summerHillHouse.yearBuilt = 2004; }); \n``` ## Delete Members of a Dictionary To delete members of a dictionary, use the `dictionary.remove()` method with an array of properties to remove from the dictionary. ```javascript realm.write(() => {   // remove the 'windows' and 'doors' field of the Summerhill House.   summerHillHouse.remove([\"windows\", \"doors\"]); }); \n``` ← [Collections - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/collections/ \"Previous Section\")[Sets - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/sets/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/data-types/embedded-objects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Embedded Objects - Node.js SDK On this page * [Overview](#overview)\n* [Realm Object Models](#realm-object-models)\n* [JSON Schema](#json-schema)\n* [Read and Write Embedded Objects](#read-and-write-embedded-objects)\n* [Create an Embedded Object](#create-an-embedded-object)\n* [Update an Embedded Object Property](#update-an-embedded-object-property)\n* [Overwrite an Embedded Object](#overwrite-an-embedded-object)\n* [Query a Collection on Embedded Object Properties](#query-a-collection-on-embedded-object-properties)\n* [Delete an Embedded Object](#delete-an-embedded-object) ## Overview An embedded object is a special type of [Realm object](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas)that models complex data about a specific object. Embedded objects are similar to [relationships](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-client-relationships), but they provide additional constraints and map more naturally to the denormalized [MongoDB document model.](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/) Realm enforces unique ownership constraints that treat each embedded object as nested data inside a single, specific parent object. An embedded object inherits the lifecycle of its parent object and cannot exist as an independent Realm object. This means that embedded objects cannot have a primary key and that Realm automatically deletes embedded objects if their parent object is deleted. ## Tip ### Embedded object types are reusable and composable You can use the same embedded object type in multiple parent object types, and you can embed objects inside other embedded objects. You can even recursively reference an embedded object type as an optional property in its own definition. ## Note ### Realm Uses Cascading Deletes for Embedded Objects When you delete a Realm object, Realm automatically deletes any embedded objects referenced by that object. Any objects that your application must persist after the deletion of their parent object should use [relationships](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-client-relationships)instead. ### Realm Object Models To define an embedded object, set `embedded`to `true`. You can reference an embedded object type from parent object types in the same way as you would define a relationship: ## Important Embedded objects cannot have a [primary key.](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-primary-keys)\n\n ` ### JSON Schema Embedded objects map to embedded documents in the parent type's [schema](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). This behavior differs from regular Realm objects, which map to their own MongoDB collection. ``` {   \"title\": \"Contact\",   \"bsonType\": \"object\",   \"required\": [\"_id\"],   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"name\": { \"bsonType\": \"string\" },     \"address\": {       \"title\": \"Address\",       \"bsonType\": \"object\",       \"properties\": {         \"street\": { \"bsonType\": \"string\" },         \"city\": { \"bsonType\": \"string\" },         \"country\": { \"bsonType\": \"string\" },         \"postalCode\": { \"bsonType\": \"string\" }       }     }   } } \n``` ``` {   \"title\": \"Business\",   \"bsonType\": \"object\",   \"required\": [\"_id\", \"name\", \"addresses\"],   \"properties\": {     \"_id\": \"objectId\",     \"name\": { \"bsonType\": \"string\" },     \"addresses\": {       \"bsonType\": \"array\",       \"items\": {         \"title\": \"Address\",         \"bsonType\": \"object\",         \"properties\": {           \"street\": { \"bsonType\": \"string\" },           \"city\": { \"bsonType\": \"string\" },           \"country\": { \"bsonType\": \"string\" },           \"postalCode\": { \"bsonType\": \"string\" }         }       }     }   } } \n``` ## Read and Write Embedded Objects ### Create an Embedded Object To create an embedded object, assign an instance of the embedded object to a parent object's property: ```javascript //   create an embedded address object const sydneyOrthodontics = {   street: \"42 Wallaby Way\",   city: \"Sydney\",   country: \"Australia\",   postalCode: \"2774\", }; realm.write(() => {   // create a contact object   realm.create(\"Contact\", {     _id: new BSON.ObjectId(),     name: \"Philip Sherman\",     address: sydneyOrthodontics, // embed the address in the contact object   }); }); \n``` ### Update an Embedded Object Property To update a property in an embedded object, modify the property in a write transaction: ```javascript // Find the contact with the address you want to update const harryPotter = realm   .objects(\"Contact\")   .filtered(\"name = 'Harry Potter'\")[0]; // modify the property of the embedded object in a write transaction realm.write(() => {   // update the embedded object directly through the contact   harryPotter.address.street = \"1 Hogwarts Ave\"; }); \n``` ### Overwrite an Embedded Object To overwrite an embedded object, reassign the embedded object property of a party to a new instance in a write transaction: ```javascript // create a new address const harryNewAddress = {   street: \"12 Grimmauld Place\",   city: \"London\",   country: \"UK\",   postalCode: \"E1 7AA\", }; realm.write(() => {   // overwrite the embedded object with the new address within a write transaction   harryPotter.address = harryNewAddress; }); \n``` ### Query a Collection on Embedded Object Properties Use dot notation to filter or sort a [collection](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-results-collections) of objects based on an embedded object property value: ## Note It is not possible to query embedded objects directly. Instead, access embedded objects through a query for the parent object type.\n\n const philipShermanAddress = realm   .objects(\"Contact\")   .filtered(\"name = 'Philip Sherman'\")[0].address.street; console.log(`Philip Sherman's address is ${philipShermanAddress}`); \n``` ### Delete an Embedded Object Realm Uses Cascading Deletes for Embedded Objects. To delete an embedded object, delete the embedded object's parent. ```javascript realm.write(() => {   // Deleting the contact will delete the embedded address of that contact   realm.delete(     realm.objects(\"Contact\").filtered(\"name = 'Philip Sherman'\")   ); }); \n``` ← [UUID - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/data-types/uuid/ \"Previous Section\")[Usage Examples - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/examples/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/advanced/encrypt/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Encrypt a Realm - Node.js SDK On this page * [Overview](#overview)\n* [Considerations](#considerations)\n* [Storing & Reusing Keys](#storing---reusing-keys)\n* [Performance Impact](#performance-impact)\n* [Encryption and Atlas Device Sync](#encryption-and-atlas-device-sync)\n* [Accessing an Encrypted Realm from Multiple Processes](#accessing-an-encrypted-realm-from-multiple-processes)\n* [Example](#example) ## Overview You can encrypt the realm database file on disk with AES-256 + SHA-2 by supplying a 64-byte encryption key when [opening a realm.](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-open-a-local-realm) Realm transparently encrypts and decrypts data with standard[AES-256 encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) using the first 256 bits of the given 512-bit encryption key. Realm uses the other 256 bits of the 512-bit encryption key to validate integrity using a [hash-based message authentication code (HMAC).](https://en.wikipedia.org/wiki/HMAC) ## Warning Do not use cryptographically-weak hashes for realm encryption keys. For optimal security, we recommend generating random rather than derived encryption keys. ## Considerations The following are key impacts to consider when encrypting a realm. ### Storing & Reusing Keys You **must** pass the same encryption key every time you open the encrypted realm. If you don't provide a key or specify the wrong key for an encrypted realm, the Realm SDK throws an error. Apps should store the encryption key securely, typically in the target platform's secure key/value storage, so that other apps cannot read the key. ### Performance Impact Reads and writes on encrypted realms can be up to 10% slower than unencrypted realms. ### Encryption and Atlas Device Sync You can encrypt a [synced realm.](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-open-a-synced-realm) Realm only encrypts the data on the device and stores the data unencrypted in your Atlas data source. Any users with authorized access to the Atlas data source can read the data, but the following still applies: * Users must have the correct read [permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read the synced data.\n* Data stored in Atlas is always encrypted at a volume (disk) level.\n* The transfer between client and server is always fully encrypted. You can also enable [Customer Key Management](https://www.mongodb.com/docs/atlas/security-kms-encryption/)to encrypt stored Atlas data using your cloud provider's key (e.g. AWS KMS, Azure Key Vault, Google Cloud KMS). If you need unique keys for each user of your application, you can use an OAuth provider or use one of the [Realm authentication providers](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication)and an [authentication trigger](https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-triggers)to create a 64-bit key and store that key in a [user object.](https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) ### Accessing an Encrypted Realm from Multiple Processes You cannot open the same encrypted realm from multiple processes. Attempting to do so will throw the following error:`Encrypted interprocess sharing is currently unsupported.` If multiple processes need to access a realm simultaneously, use an unencrypted realm. ## Example The following code demonstrates how to generate an encryption key and open an encrypted realm:\n\n",
  "https://www.mongodb.com/docs/realm/sdk/node/advanced/bundle/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Bundle a Realm File - Node SDK On this page * [Overview](#overview)\n* [Create a Realm File for Bundling](#create-a-realm-file-for-bundling)\n* [Bundle a Realm File in Your Production Application](#bundle-a-realm-file-in-your-production-application)\n* [Open a Realm from a Bundled Realm File](#open-a-realm-from-a-bundled-realm-file)\n* [Bundle a Synchronized Realm](#bundle-a-synchronized-realm) Realm supports **bundling** realm files. When you bundle a realm file, you include a database and all of its data in your application download. This allows users to start applications for the first time with a set of initial data. For synced realms, bundling can avoid a lengthy initial download the first time a user opens your application. Instead, users must only download the synced changes that occurred since you generated the bundled file. ## Overview To create and bundle a realm file with your application: 1. [Create a realm file](#std-label-node-create-a-realm-for-bundling) that contains the data you'd like to bundle.\n2. [Add the bundled realm file](#std-label-node-bundle-realm-file)to your production application.\n3. In your production application,[open the realm from the bundled asset file](#std-label-node-open-a-realm-from-a-bundled-realm-file). For synchronized realms, you must include the partition key. ## Note ### Bundle Synchronized Realms SDK version 10.12.0 introduced the ability to bundle synchronized realms. Before version 10.12.0, you could only bundle local realms. [See the Bundle a Synchronized Realm section for details on considerations and limitations when bundling a synchronized realm.](#std-label-node-bundle-synced-realm) ## Create a Realm File for Bundling\n\n ## Bundle a Realm File in Your Production Application Now that you have a copy of the realm that contains the initial data, bundle it with your production application. Add the bundled realm file made in the previous section to your production application. prod\\_realm\\_app ``` . ├── copyOfDefault.realm ... rest of files in _prod_ application \n``` ## Open a Realm from a Bundled Realm File Now that you have a copy of the realm included with your production application, you need to add code to use it. Create a [Configuration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#~Configuration) with the path to the bundled realm as the value for the `path` field. Pass that configuration to the [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open) method. Now you can work with the data from your bundled realm in the realm you've just opened. ```javascript const copyConfig = {   schema: [Car],   path: \"path/to/bundled/file.realm\" }; const copyRealm = await Realm.open(copyConfig); \n``` ## Bundle a Synchronized Realm Generally, bundling a synchronized realm works the same as bundling a local-only realm. However, there are some limitations to bundling realms that use Device Sync. 1. You can only bundle fully synchronized realms. Make sure that the realm has fully synchronized with the server before bundling:  \n```javascript  \nconst config = {  \n  sync: {  \n    user: app.currentUser,  \n    partitionValue: app.currentUser.id,  \n  },  \n  schema: [Car],  \n};  \nconst realm = await Realm.open(config);  \n// create many changes  \nrealm.write(() => {  \n  for (let i = 0; i < 25; i++) {  \n    realm.create(\"Car\", {  \n      make: \"Toyota\",  \n      model: \"Prius\",  \n      miles: i,  \n      owner: app.currentUser.id,  \n    });  \n  }  \n});  \n// ensure synchronize all changes before copy  \nawait realm.syncSession.uploadAllLocalChanges();  \nawait realm.syncSession.downloadAllServerChanges();  \n// changes are synchronized -- we can copy the realm  \nrealm.writeCopyTo(__dirname + \"syncedCopy.realm\");  \n```\n2. When opening a bundled synchronized realm, you must use the same partition key that was used in the original realm. If you use a different partition key, the SDK throws an error when opening the bundled realm. ## Warning ### Synchronized Realm Bundling and Client Maximum Offline Time If your application has enabled [advanced backend compaction](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-advanced-backend-compaction) by configuring a[client maximum offline time](https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time), users could experience a client reset the first time they open the bundled realm file. This can happen if: * the bundled realm file was generated more than**client maximum offline time** days before the user syncs the realm for the first time. Users experiencing a client reset download the full state of the realm from the application backend. This negates the advantages of bundling a realm file. To prevent client resets and preserve the advantages of realm file bundling: * Avoid using a client maximum offline time in applications that bundle a synchronized realm.\n* If your application does use a client maximum offline time, ensure that your application download always includes a recently synchronized realm file. Generate a new file each application version, and ensure that no version ever stays current for more than**client maximum offline time** number of days.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Live Queries - Node.js SDK On this page * [Live Objects](#live-objects)\n* [Collections](#collections)\n* [Change Notifications](#change-notifications) You can query a realm to find objects based on their type and the values of their properties. Objects and queries always reflect the latest state of an object and emit [notifications](#std-label-node-change-notifications) that can update your app whenever data changes. ## Tip ### Learn How to Define and Run Queries For code examples that show how to read and filter Realm objects with the Node.js SDK, see [Read Operations.](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/#std-label-node-read-operations) ## Live Objects Data in Realm is _live_, which means that an object always reflects its most recent saved state and read operations never block. Objects automatically update in response to changes, so you can see up-to-date data in your application without running a new query. ## Note ### Memory-mapped Realm Objects Realm can support live objects because it [memory-maps](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) objects in your application directly to data stored in the [realm file](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-realm-file) instead of a copy of the data stored in memory. ## Collections A results collection represents all objects in a realm that match a query operation. In general you can work with a collection like a regular JavaScript array but collections don't actually hold matching Realm objects in memory. Instead they reference the matched objects, which themselves map directly to data in the realm file. ## Note ### Pagination & Limits Some queries only need to access a subset of all objects that match the query. Realm's lazy-loaded collections only fetch objects when you actually access them, so you do not need any special mechanism to limit query results. For example, if you only want to find 10 matching objects at a time (such as in a paged product catalog) you can just access ten elements of the results collection. To advance to the next page, access the next ten elements of the results collection starting at the index immediately following the last element of the previous page. ## Change Notifications Realm objects and collections always reflect the latest state of your data when you read them. Realm emits a change notification whenever the state of your data changes, which lets you reactively update your app in response to committed[write transaction.](https://mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/#std-label-node-write-transactions) You can register three types of notification listeners: * A **realm listener** fires whenever any object in a realm changes.\n* A **collection listener** fires whenever a specific query matches a new set of objects or when any matched object changes.\n* An **object listener** fires whenever a specific object is deleted or has one or more properties modified. ## Tip ### Learn How to React to Changes For code examples that show how to define, register, and clean up change notification listeners with the Node.js SDK, see [React to Changes.](https://mongodb.com/docs/realm/sdk/node/examples/react-to-changes/#std-label-node-react-to-changes) ← [Realms - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/ \"Previous Section\")[Write Transactions - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/realm-database/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realm Database - Node.js SDK On this page * [Database Internals](#database-internals)\n* [Native Database Engine](#native-database-engine)\n* [Realm Files](#realm-files)\n* [Copy-on-Write: The Secret Sauce of Data Versioning](#copy-on-write--the-secret-sauce-of-data-versioning)\n* [Memory Mapping](#memory-mapping)\n* [Compaction](#compaction)\n* [ACID Compliance](#acid-compliance)\n* [Features](#features)\n* [Queries](#queries)\n* [Encryption](#encryption)\n* [Indexes](#indexes)\n* [Schemas](#schemas)\n* [Persistent or In-Memory Realms](#persistent-or-in-memory-realms)\n* [Atlas Device Sync](#atlas-device-sync) Realm Database is a reactive, object-oriented, cross-platform, mobile database: * **Reactive**: query the current state of data and subscribe to state changes like the result of a query, or even changes to a single object.\n* **Object-oriented**: organizes data as objects, rather than rows, documents, or columns.\n* **Cross-platform**: use the same database on iOS, Android, Linux, macOS, or Windows. Just define a schema for each SDK you use.\n* **Mobile**: designed for the low-power, battery-sensitive, real-time environment of a mobile device. Realm Database is a cross-platform and mobile-optimized alternative to other mobile databases such as [SQLite](https://www.sqlite.org/index.html),[Core Data](https://developer.apple.com/documentation/coredata), and [Room.](https://developer.android.com/jetpack/androidx/releases/room) This page explains some of the implementation details and inner workings of Realm Database and Device Sync. This page is for you if you are: * a developer interested in learning more about Realm Database\n* comparing Realm Database with competing databases\n* trying to understand how Realm Database works with Device Sync This explanation begins with a deep dive into database internals, continues with a high-level introduction to some of the features of Realm Database, and wraps up with some of the differences of working with Device Sync and the local version of Realm Database. ## Database Internals Realm Database uses a completely unique database engine, file format, and design. This section describes some of the high-level details of those choices. This section applies to both the device-local version of Realm Database as well as the networked Device Sync version. Differences between the local database and the synchronized database are explained in the Atlas Device Sync section. ### Native Database Engine Realm Database is an entire database written from scratch in C++, instead of building on top of an underlying database engine like SQLite. Realm Database's underlying storage layer uses[B+ trees](https://en.wikipedia.org/wiki/B%2B%5Ftree) to organize objects. As a result, Realm Database controls optimizations from the storage level all the way up to the access level. Realm Database stores data in **realms**: collections of heterogeneous realm objects. You can think of each realm as a database. Each object in a realm is equivalent to a row in a SQL database table or a MongoDB document. Unlike SQL, realms do not separate different object types into individual tables. Realm Database stores objects as groups of property values. We call this column-based storage. This means that queries or writes for individual objects can be slower than row-based storage equivalents when unindexed, but querying a single field across multiple objects or fetching multiple objects can be much faster due to spatial locality and in-CPU vector operations. Realm Database uses a [zero-copy](https://en.wikipedia.org/wiki/Zero-copy) design to make queries faster than an ORM, and often faster than raw SQLite. ### Realm Files Realm Database persists data in files saved on device storage. The database uses several kinds of file:\n\n Realm files contain object data with the following data structures: Groups, Tables, Cluster Trees, and Clusters. Realm Database organizes these data structures into a tree structure with the following form: * The top level, known as a Group, stores object metadata, a transaction log, and a collection of Tables.\n* Each class in the realm schema corresponds to a Table within the top-level Group.\n* Each Table contains a Cluster Tree, an implementation of a B+ tree.\n* Leaves on the Cluster Tree are called Clusters. Each contains a range of objects sorted by key value.\n* Clusters store objects as collections of columns.\n* Each column contains data for a single property for multiple instances of a given object. Columns are arrays of data with uniformly sized values.\n* Columns store data in one of the following sizes: 1, 2, 4, 8, 16, 32, or 64 bits. Each column uses one value size, determined by the largest value. Since pointers refer to memory addresses, objects written to persistent files cannot store references as pointers. Instead, realm files refer to data using the offset from the beginning of the file. We call this a ref. As Realm Database uses memory mapping to read and write data, database operations translate these refs from offsets to memory pointers when navigating database structures. ### Copy-on-Write: The Secret Sauce of Data Versioning Realm Database uses a technique called **copy-on-write**, which copies data to a new location on disk for every write operation instead of overwriting older data on disk. Once the new copy of data is fully written, the database updates existing references to that data. Older data is only garbage collected when it is no longer referenced or actively in use by a client application. Because of copy-on-write, older copies of data remain valid, since all of the references in those copies still point to other valid data. Realm Database leverages this fact to offer multiple versions of data simultaneously to different threads in client applications. Most applications tie data refreshes to the repaint cycle of the looper thread that controls the UI, since data only needs to refresh as often as the UI does. Longer-running procedures on background threads, such as large write operations, can work with a single version of data for a longer period of time before committing their changes. ### Memory Mapping Writes use [memory mapping](https://en.wikipedia.org/wiki/Memory-mapped%5Ffile) to avoid copying data back and forth from memory to storage. Accessors and mutators read and write to disk via memory mapping. As a result, object data is never stored on the stack or heap of your app. By default, data is memory-mapped as read-only to prevent accidental writes. Realm Database uses operating system level paging, trusting each operating system to implement memory mapping and persistence better than a single library could on its own. ### Compaction Realm Database automatically reuses free space that is no longer needed after database writes. However, realm files never shrink automatically, even if the amount of data stored in your realm decreases significantly. Compact your realm to optimize storage space and decrease file size if possible. You should compact your realms occasionally to keep them at an optimal size. You can do this manually, or by configuring your realms to compact on launch. However, Realm Database reclaims unused space for future writes, so compaction is only an optimization to conserve space on-device. ### ACID Compliance Realm Database guarantees that transactions are [ACID](https://en.wikipedia.org/wiki/ACID) compliant. This means that all committed write operations are guaranteed to be valid and that clients don't see transient states in the event of a system crash. Realm Database complies with ACID with the following design choices:\n\n ## Features Realm Database supports many popular database features. ### Queries You can query Realm Database using platform-native queries or a raw query language that works across platforms. ### Encryption Realm Database supports on-device realm encryption. Since memory mapping does not support encryption, encrypted realms use a simulated in-library form of memory mapping instead. ## Note Realm forbids opening the same encrypted realm from multiple processes. Attempting to do so will throw the error: \"Encrypted interprocess sharing is currently unsupported.\" ### Indexes Indexes are implemented as trees containing values of a given property instead of a unique internal object key. This means that indexes only support one column, and thus only one property, at a time. ### Schemas Every realm object has a schema. That schema is defined via a native object in your SDK's language. Object schemas can include embedded lists and relations between object instances. Each realm uses a versioned schema. When that schema changes, you must define a migration to move object data between schema versions. Non-breaking schema changes, also referred to as additive schema changes, do not require a migration. After you increment the local schema version, you can begin using the updated schema in your app. Breaking schema changes, also called destructive schema changes, require a migration function. See your SDK's documentation for more information on migrations. ### Persistent or In-Memory Realms You can use Realm Database to store data persistently on disk, or ephemerally in memory. Ephemeral realms can be useful in situations where you don't need to persist data between application instances, such as when a user works in a temporary workspace. ## Atlas Device Sync Device Sync adds network synchronization between an App Services backend and client devices on top of all of the functionality of Realm Database. When you use Realm Database with Sync, realms exist on device just like when you only use Realm Database. However, changes to the data stored in those realms synchronize between all client devices through a backend App Services instance. That backend also stores realm data in a cloud-based Atlas cluster running MongoDB. Device Sync relies on a worker client that communicates with your application backend in a dedicated thread in your application. Additionally, synced realms keep a history of changes to contained objects. Sync uses this history to resolve conflicts between client changes and backend changes. Applications that use Device Sync define their schema on the backend using[JSON Schema](https://json-schema.org/learn/getting-started-step-by-step.html). Client applications must match that backend schema to synchronize data. However, if you prefer to define your initial schema in your application's programming language, you can use [Development Mode](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to create a backend JSON Schema based on native SDK objects as you write your application. However, once your application is used for production purposes, you should alter your schema using JSON Schema on the backend. ← [Realm Fundamentals - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/ \"Previous Section\")[Realms - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/advanced/client-reset-data-recovery/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Manual Client Reset Data Recovery - Node.js SDK On this page * [Track Changes by Object Strategy](#track-changes-by-object-strategy)\n* [Example](#example)\n* [Include Last Updated Time in Your Schema](#include-last-updated-time-in-your-schema)\n* [Configure Realm to Use Manual Client Reset](#configure-realm-to-use-manual-client-reset)\n* [Track Synchronization in Separate Realm](#track-synchronization-in-separate-realm)\n* [Create Callback to Handle Client Reset](#create-callback-to-handle-client-reset)\n* [Alternative Strategies](#alternative-strategies) This page explains how to manually recover unsynced realm data after a client reset using the Manual Recovery client reset mode. Manual recovery requires significant amounts of code, schema concessions, and custom conflict resolution logic. You should only perform a manual recovery of unsynced realm data if you cannot lose unsynced data and the other automatic client reset methods do not meet your use case. For more information about the other available client reset modes, refer to[Reset a Client Realm.](https://mongodb.com/docs/realm/sdk/node/examples/reset-a-client-realm/#std-label-node-client-resets) The specifics of manual recovery depend heavily upon your application and your schema. However, there are a few techniques that can help with manual recoveries. The [Track Changes by Object Strategy section](#std-label-node-client-reset-track-changes-by-object) demonstrates one method of recovering unsynced changes during a client reset. ## Warning ### Avoid Making Breaking Schema Changes in Production Do not expect to recover all unsynced data after a breaking schema change. The best way to preserve user data is to never make a breaking schema change at all. ## Important ### Breaking Schema Changes Require an App Schema Update After a breaking schema change: * All clients must perform a client reset.\n* You must update client models affected by the breaking schema change. ## Track Changes by Object Strategy The **track changes by object** manual client reset data recovery strategy lets you recover data already written to the client realm file but not yet synced to the backend. In this strategy, you add a \"Last Updated Time\" to each object model to track when each object last changed. We'll watch the to determine when the realm last uploaded its state to the backend. When backend invokes a client reset, find objects that were deleted, created, or updated since the last sync with the backend. Then copy that data from the backup realm to the new realm. The following steps demonstrate implementing the process at a high level:\n\n ### Example This example demonstrates implementing the **track changes by object**manual client reset data recovery strategy. ## Note ### Limitations of This Example * This example only is for an application with a single realm containing a single Realm object type. For each additional object type, you'd need to add another sync listener as described in the[Track Synchronization in Separate Realm section.](#std-label-node-manual-client-reset-track-sync)\n* This example keeps track of the last time each _object_ was updated. As a result, the recovery operation overwrites the entire object in the new realm if any field was updated after the last successful sync of the backup realm. This could overwrite fields updated by other clients with old data from this client. If your realm objects contain multiple fields containing important data, consider keeping track of the last updated time of each _field_ instead, and recovering each field individually. For more information on other ways to perform a manual client reset with data recovery, refer to the [Alternative Strategies section.](#std-label-node-manual-client-reset-alternative-strategies) 1 #### Include Last Updated Time in Your Schema Add a new property to your Realm object schema to track the last time it was updated. Whenever you create or update a Realm object with the schema, include a timestamp with the update time. Ordinarily, there is no way to detect when a Realm object was last modified. This makes it difficult to determine which changes were synced to the backend. By adding a timestamp `lastUpdated` to your Realm object models and updating that timestamp to the current time whenever a change occurs, you can keep track of when objects were changed. `| const DogSchema = { |\n| ------------------- |\n| name: \"Dog\",        |\n| properties: {       |\n| name: \"string\",     |\n| age: \"int?\",        |\n| lastUpdated: \"int\", |\n| },                  |\n| };                  | ` 2 #### Configure Realm to Use Manual Client Reset In the realm's [SyncConfiguration](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.Sync.html#~SyncConfiguration), set the `clientReset` field to manual mode and include an `error` callback function. You'll define the error callback function in the[Create Callback to Handle Client Reset section.](#std-label-node-manual-client-reset-create-callback) ```javascript const config = {   schema: [DogSchema],   sync: {     user: app.currentUser,     partitionValue: \"MyPartitionValue\",     clientReset: {       mode: \"manual\",     },     error: handleSyncError, // callback function defined later   }, }; \n``` 3 #### Track Synchronization in Separate Realm Just knowing when objects were changed isn't enough to recover data during a client reset. You also need to know when the realm last completed a sync successfully. This example implementation uses a singleton object in a separate realm called `LastSynced`paired with a change listener to record when a realm finishes syncing successfully. Define your LastSynced Realm to track the latest time your realm synchronizes. ```javascript const LastSyncedSchema = {   name: \"LastSynced\",   properties: {     realmTracked: \"string\",     timestamp: \"int?\",   },   primaryKey: \"realmTracked\", }; const lastSyncedConfig = { schema: [LastSyncedSchema] }; const lastSyncedRealm = await Realm.open(lastSyncedConfig); lastSyncedRealm.write(() => {   lastSyncedRealm.create(\"LastSynced\", {     realmTracked: \"Dog\",   }); }); \n``` Register a change listener to subscribe to changes to the Dog collection. Only update the LastSynced object if the sync session is connected and all local changes have been synced with the server. ```javascript // Listens for changes to the Dogs collection realm.objects(\"Dog\").addListener(async () => {   // only update LastSynced if sync session is connected   // and all local changes are synced   if (realm.syncSession.isConnected()) {\n\n     lastSyncedRealm.write(() => {       lastSyncedRealm.create(\"LastSynced\", {         realmTracked: \"Dog\",         timestamp: Date.now(),       });     });   } }); \n``` 4 #### Create Callback to Handle Client Reset Now that you've recorded update times for all objects in your application as well as the last time your application completed a sync, it's time to implement the manual recovery process. This example handles two main recovery operations: * Restore unsynced inserts and updates from the backup realm\n* Delete objects from the new realm that were previously deleted from the backup realm You can follow along with the implementation of these operations in the code samples below. ```javascript async function handleSyncError(_session, error) {   if (error.name === \"ClientReset\") {     const realmPath = realm.path; // realm.path will not be accessible after realm.close()     realm.close(); // you must close all realms before proceeding     // pass your realm app instance and realm path to initiateClientReset()     Realm.App.Sync.initiateClientReset(app, realmPath);     // Redownload the realm     realm = await Realm.open(config);     const oldRealm = await Realm.open(error.config);     const lastSyncedTime = lastSyncedRealm.objectForPrimaryKey(       \"LastSynced\",       \"Dog\"     ).timestamp;     const unsyncedDogs = oldRealm       .objects(\"Dog\")       .filtered(`lastUpdated > ${lastSyncedTime}`);     // add unsynced dogs to synced realm     realm.write(() => {       unsyncedDogs.forEach((dog) => {         realm.create(\"Dog\", dog, \"modified\");       });     });     // delete dogs from synced realm that were deleted locally     const syncedDogs = realm       .objects(\"Dog\")       .filtered(`lastUpdated <= ${lastSyncedTime}`);     realm.write(() => {       syncedDogs.forEach((dog) => {         if (!oldRealm.objectForPrimaryKey(\"Dog\", dog._id)) {           realm.delete(dog);         }       });     });     // make sure everything syncs and close old realm     await realm.syncSession.uploadAllLocalChanges();     oldRealm.close();   } else {     console.log(`Received error ${error.message}`);   } } \n``` ## Alternative Strategies Possible alternate implementations include:\n\n ← [Encrypt a Realm - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/encrypt/ \"Previous Section\")[Bundle a Realm File - Node SDK](https://mongodb.com/docs/realm/sdk/node/advanced/bundle/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/device-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Atlas Device Sync - Node.js SDK On this page * [Overview](#overview)\n* [Partition-Based Sync](#partition-based-sync)\n* [Flexible Sync](#flexible-sync)\n* [Group Updates for Improved Performance](#group-updates-for-improved-performance) ## Overview Atlas Device Sync automatically synchronizes data between client applications and an [Atlas App Services backend](https://www.mongodb.com/docs/atlas/app-services/#std-label-realm-cloud). When a client device is online, Sync asynchronously synchronizes data in a background thread between the device and your backend App. When you use Sync in your client application, your implementation must match the Sync Mode you select in your backend App configuration. The Sync Mode options are: * Partition-Based Sync\n* Flexible Sync You can only use one Sync Mode for your application. You cannot mix Partition-Based Sync and Flexible Sync within the same App. ## Tip ### See also:  [Configure and Enable Atlas Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) ## Partition-Based Sync When you select [Partition-Based Sync](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync) for your backend App configuration, your client implementation must include a partition value. This is the value of the [partition key](https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-key) field you select when you configure Partition-Based Sync. The partition value determines which data the client application can access. You pass in the partition value when you open a synced realm. ## Flexible Sync When you select [Flexible Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync) for your backend App configuration, your client implementation must include subscriptions to queries on [queryable fields](https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields). Flexible Sync works by synchronizing data that matches query subscriptions you maintain in the client application. A subscription set contains a set of queries. Realm Flexible Sync returns documents matching those queries, where the user has the appropriate[permissions](https://www.mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to read and/or read and write the documents. If documents match the query, but the client does not have the permission to read or write them, they do not sync to the client application. You can form queries using [Realm Query Language.](https://mongodb.com/docs/realm/realm-query-language/#std-label-realm-query-language) ## Note Flexible Sync does not support all the query operators available in Realm Query Language and the SDK's query engine. See [Flexible Sync RQL Limitations](https://mongodb.com/docs/realm/realm-query-language/#std-label-flexible-sync-rql-limitations) for details. Subscription sets are based on a specific type of [Realm object](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-types). You might have multiple subscriptions if you have many types of Realm objects. To use Flexible Sync in your client application, open a synced realm with a flexible sync configuration. Then, manage subscriptions to determine which documents to sync. ### Group Updates for Improved Performance Every write transaction for a subscription set has a performance cost. If you need to make multiple updates to a Realm object during a session, consider keeping edited objects in memory until all changes are complete. This improves sync performance by only writing the complete and updated object to your realm instead of every change.\n\n",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Write Transactions - Node.js SDK On this page * [Transaction Lifecycle](#transaction-lifecycle) A write transaction is a function that modifies objects in a realm. Write transactions let you create, modify, or delete Realm objects. They handle operations in a single, idempotent update. A transaction is_all or nothing_. Either: * All the operations in the transaction succeed, or;\n* If any operation fails, none of the operations complete. ## Important Every write operation must occur in a write transaction. Write transactions are callback functions that you pass to a realm instance. For examples of specific write operations, see[Write Operations.](https://mongodb.com/docs/realm/sdk/node/examples/read-and-write-data/#std-label-node-write-operations) For example, assuming we already have a Realm object called `task1`, we can modify `task1`'s status property by writing to the object. `| realm.write(() => {          |\n| ---------------------------- |\n| task1.status = \"InProgress\"; |\n| });                          | ` ## Transaction Lifecycle A given realm only processes one write transaction at a time. When you make a write transaction, the realm adds the transaction to a queue. The realm evaluates each transaction in the order it arrived. After processing a transaction, Realm Database either **commits** it or**cancels** it: * After a **commit**, the realm applies all operations in the transaction. Once applied, the realm automatically updates [live queries](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-live-queries). It notifies listeners of created, modified, and deleted objects.  \n## Note  \nWhen using [Sync](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync), the SDK also queues the changes to send to Atlas App Services. The SDK sends these changes when a network is available.\n* Realm Database does not apply any operations in a **cancelled**transaction. Realm Database cancels a transaction if an operation fails or is invalid. ← [Live Queries - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/ \"Previous Section\")[Relationships & Embedded Objects - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/realms/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Realms - Node.js SDK On this page * [Realm vs Other Databases](#realm-vs-other-databases)\n* [Object Types & Schemas](#object-types---schemas)\n* [Realm Schema](#realm-schema)\n* [Realm Files](#realm-files)\n* [In-Memory Realms](#in-memory-realms)\n* [Synced Realms](#synced-realms) Realms are the core data structure used to organize data in Realm Database. At its core, a realm is a collection of the objects that you use in your application, called Realm objects, as well as additional metadata that describe the objects. ## Tip ### Learn How to Work With a Realm See [Open & Close a Realm](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-open-close-realm) for code examples that show how to configure and open a realm in the Node.js SDK. ## Realm vs Other Databases The Realm data model is similar to both relational and document databases but has distinct differences from both. To underscore these differences, it's helpful to highlight what a realm **is not**: A realm is not a single, application-wide database. Applications based on other database systems generally store all of their data in a single database. Apps often split data across multiple realms to organize data more efficiently and to enforce access controls. A realm is not a relational table. Normalized tables in relational databases only store one type of information, such as street addresses or items in a store inventory. A realm can contain any number of object types that are relevant to a given domain. A realm is not a collection of schemaless documents. Document databases don't necessarily enforce a strict schema for the data in each collection. While similar to documents in form, every Realm object conforms to a schema for a specific object type in the realm. An object cannot contain a property that is not described by its schema. ## Object Types & Schemas Every Realm object conforms to a specific **object type**, which is essentially a class that defines the properties and [relationships](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/#std-label-node-client-relationships) for objects of that type using a pre-defined schema. Realm guarantees that all objects in a realm conform to the schema for their object type and validates objects whenever they're created, modified, or deleted. Realm objects are fundamentally similar to a common JavaScript object but they also bring along a few additional features like schema validation and [live queries](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/#std-label-node-live-queries). The Node.js SDK memory maps Realm objects directly to native JavaScript objects, which means there's no need to use a special data access library, such as an [ORM](https://en.wikipedia.org/wiki/Object-relational%5Fmapping). Instead, you can work with Realm objects as you would any other object. The following class contains a schema that defines a `Car` object type with`id`, `make`, `model`, and `miles` properties. It also defines a primary key.\n\n ` ## Tip ### Learn How to Define an Object Schema For code examples that show how to define a Realm object schema in the Node.js SDK, see [Define a Realm Object Schema.](https://mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-define-a-realm-object-schema) ## Realm Schema A **realm schema** is a list of valid [object schemas](#std-label-node-object-schemas) that a realm may contain. Every Realm object must conform to an object type that's included in its realm's schema. If a realm already contains data when you open it, Realm Database validates each object to ensure that an object schema was provided for its type and that it meets all of the constraints specified in the schema. A realm that contains basic data about cars and manufacturers might use a schema like the following: ```javascript class Manufacturer extends Realm.Object {   static schema = {     name: \"Manufacturer\",     properties: {       _id: \"objectId\",       // A manufacturer that may have many cars       cars: \"Car[]\"     },   }; } class Car extends Realm.Object {   static schema = {     name: \"Car\",     properties: {       _id: \"objectId\",       make: \"string\",       model: \"string\",       miles: \"int?\",     },   }; } \n``` ## Realm Files Realm Database stores a binary encoded version of every object and type in a realm in a single `.realm` file. The file is located at a specific path that you define when you open the realm. ## Tip ### Implement Compacting in Your Production Application Every production application should implement a `shouldCompactOnLaunch`callback to periodically reduce the realm file size. ## Note ### Auxiliary Realm Files Realm Database creates additional files for each realm. To learn more about these files, see [Realm Database Internals.](https://mongodb.com/docs/realm/sdk/node/fundamentals/realm-database/#std-label-node-realm-database) ## Warning ### Use Caution When Deleting Realm Files In some circumstances, such as a client reset scenario, you might need to delete a realm file and its auxiliary files. If you delete a realm file or any of its auxiliary files while one or more instances of the realm are open, you might corrupt the realm or disrupt [sync.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync) You may safely delete these files when all instances of a realm are closed. Before you delete a realm file, make sure that you back up any important objects as you will lose all unsynced data in the realm. ### In-Memory Realms You can also open a realm entirely in memory, which will not create a `.realm`file or its associated auxiliary files. Instead the SDK stores objects in memory while the realm is open and discards them immediately when all instances are closed. ## Synced Realms You can configure a realm to automatically synchronize data between many devices that each have their own local copy of the data. Synced realms use a different configuration than local-only realms and require an Atlas App Services backend to handle the synchronization process. Applications can always create, modify, and delete synced realm objects locally, even when offline. Whenever a network connection is available, the Realm SDK opens a connection to an application server and syncs changes to and from other clients. The [Atlas Device Sync protocol](https://www.mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-sync-protocol) and server-side operational transforms guarantee that all fully synced instances of a realm see exactly the same data, even if some changes occurred offline and/or were received out of order. ## Tip ### Learn How to Configure and Use Sync For more information on synced realms, including directions on how to set up sync in a Realm app, see [Atlas Device Sync Overview.](https://www.mongodb.com/docs/atlas/app-services/sync/#std-label-sync)\n\n ← [Realm Database - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/realm-database/ \"Previous Section\")[Live Queries - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/live-queries/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/advanced/multi-user-applications/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Multi-User Applications - Node.js SDK On this page * [User Account States](#user-account-states)\n* [Add a New User to the Device](#add-a-new-user-to-the-device)\n* [List All Users on the Device](#list-all-users-on-the-device)\n* [Remove a User from the Device](#remove-a-user-from-the-device)\n* [Change the Active User](#change-the-active-user) The Realm SDK allows multiple [users](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) to be logged in to an app simultaneously on a given device. Realm client applications run in the context of a single active user even if multiple users are logged in simultaneously. You can quickly switch between authenticated users without requiring them to log in again. ## Important **Any logged in user may become the active user without re-authenticating.**Depending on your app, this may be a security vulnerability. For example, a user on a shared device may switch to a coworker's logged in account without providing their credentials or requiring their explicit permission. If your application requires stricter authentication, avoid switching between users and prefer to explicitly log the active user out before authenticating another user. ## User Account States When a user first logs in through a Realm SDK on a given device or browser, the SDK saves the user's information and keeps track of the user's state on the device. The user's data remains on the device, even if they log out, unless you actively [remove the user.](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/#std-label-dotnet-remove-user) The following states describe an on-device user at any given time: * **Authenticated:** any user that has logged in on the device and has not logged out or had its session revoked.  \n   * **Active**: a single authenticated user that is currently using the app on a given device. The SDK associates this user with outgoing requests and Atlas App Services evaluates data access permissions and runs functions in this user's context. See [active user](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) for more information.  \n   * **Inactive**: all authenticated users that are not the current active user. You can [switch the active user](https://mongodb.com/docs/realm/sdk/dotnet/manage-users/multi-user-applications/#std-label-dotnet-switch-user) to a currently inactive user at any time.\n* **Logged Out:** any user that authenticated on the device but has since logged out or had their session revoked. The following diagram shows how users within an App Services client app transition between states when certain events occur: ![A diagram the outlines the different states a user can be in: logged out, logged in and active, & logged in and inactive.](https://mongodb.com/docs/realm/images/multi-user.png) ### Add a New User to the Device The Realm SDK automatically adds users to a device when they log in for the first time on that device. When a user logs in, they immediately become the application's [active user.](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-active-user) ## Example In the example below, a user with the email `joe@example.com` logs in and becomes the active user. Later, a user with the email`emma@example.com` logs in and becomes the active user. ### List All Users on the Device You can access a list of all [user accounts](https://www.mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) on the device. This list includes all users that have logged in to the client app on a given device. ## Example In the example below, a developer prints out all the logged-in users on the device by looping through [Realm.App.allUsers.](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#allUsers) ### Remove a User from the Device You can remove all information about a user from the device and automatically log the user out. ## Example\n\n ### Change the Active User You can quickly switch an app's active user to another logged-in user at any time. ## Example In the example below, the active user is initially switched to `user1`using the [Realm.App.switchUser()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.App.html#switchUser) method. Later, the active user is switched to `user2`. ← [Access Custom User Data - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/access-custom-user-data/ \"Previous Section\")[Link User Identities - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/link-identities/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Schema Versions & Migrations - Node.js SDK On this page * [Schema Version](#schema-version)\n* [Migrations](#migrations) ## Important ### Migrations Apply to Local Realms Only Migrations only apply to realms that are not synced through Realm. Synced realms do not have schema versions and automatically migrate objects to the latest schema. Synced realms only support non-breaking schema changes. Breaking changes require a client reset. ## Schema Version A **schema version** identifies the state of a [realm schema](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-realm-schema) at some point in time. Realm Database tracks the schema version of each realm and uses it to map the objects in each realm to the correct schema. Schema versions are ascending integers that you can optionally include in the realm configuration when you open a realm. If a client application does not specify a version number when it opens a realm then the realm defaults to version `0`. ## Important ### Increment Versions Monotonically [Migrations](#std-label-node-migrations) must update a realm to a higher schema version. Realm Database will throw an error if a client application opens a realm with a schema version that is lower than the realm's current version or if the specified schema version is the same as the realm's current version but includes different[object schemas.](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas) ## Migrations A **migration** is a function that updates a realm and any objects it contains from one [schema version](#std-label-node-schema-version) to a newer version. Migrations give you the flexibility to change your object schemas over time to accommodate new features and refactors. Whenever you open an existing realm with a schema version greater than the realm's current version, Realm runs a migration function that you define. The function has access to the realm's version number and incrementally updates objects in the realm to conform to the new schema. Realm automatically migrates certain changes, such as new and deleted properties, but does not automatically set values for new properties unless the updated object schema specifies a default value. You can define additional logic in the migration function to further customize property values. ## Tip ### Learn How to Modify a Schema To learn how to modify your app's Realm object schemas with the Node.js SDK, see [Modify an Object Schema.](https://mongodb.com/docs/realm/sdk/node/examples/modify-an-object-schema/#std-label-node-modify-an-object-schema) ← [Relationships & Embedded Objects - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/ \"Previous Section\")[Application Services - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/application-services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/relationships-and-embedded-objects/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Relationships & Embedded Objects - Node.js SDK On this page * [Relationships](#relationships)\n* [To-One Relationship](#to-one-relationship)\n* [To-Many Relationship](#to-many-relationship)\n* [Inverse Relationship](#inverse-relationship)\n* [Embedded Objects](#embedded-objects)\n* [Realm Object Models](#realm-object-models)\n* [JSON Schema](#json-schema) ## Relationships Realm allows you to define explicit relationships between the types of objects in an App. A relationship is an object property that references another Realm object type. You can define relationships by setting an object's property to another object type in the [property schema.](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-realm-schema) Relationships are direct references to other objects in a realm. You don't need bridge tables or create joins to define a relationship like you would in a relational database. Instead you can access related objects by reading and writing to the property that defines the relationship. Realm Database executes read operations lazily as they come in. Querying a relationship is just as performant as reading a regular property. There are three primary types of relationships between objects: * [One-to-One Relationship](#std-label-node-to-one-relationship)\n* [One-to-Many Relationship](#std-label-node-to-many-relationship)\n* [Inverse Relationship](#std-label-node-inverse-relationship) ## Note ### Realm vs Other Databases Objects often contain direct references to other objects. When working with objects and references, you often copy from database storage into application memory. This situation leaves the developer with a choice of what to copy into memory: * You can copy the entire referenced object ahead of time. This means that all referenced data is always available quickly, but can use up a lot of resources. Depending on the amount of available memory this may not be viable.\n* You can copy only a foreign key value for each object ahead of time that you can use to query the full object if it's needed. These referenced lookups are memory-efficient. However, they require more query code and too many lookups can slow your application down. Realm's query architecture avoids the tradeoff between memory usage and computational overhead. Instead, Realm queries can directly reference [related objects](#std-label-node-relationships) and their properties on disk. ### To-One Relationship A **to-one** relationship means that an object is related to no more than one other object in an [object schema](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas). To define a to-one relationship, specify the property type as the related Realm object type. ## Example An application could use the following object schemas to indicate that a Person may own a single Dog: `| const Person = {   |\n| ------------------ |\n| name: \"Person\",    |\n| properties: {      |\n| name: \"string\",    |\n| birthdate: \"date\", |\n| dog: \"Dog?\"        |\n| }                  |\n| };                 |\n| const Dog = {      |\n| name: \"Dog\",       |\n| properties: {      |\n| name: \"string\",    |\n| age: \"int\",        |\n| breed: \"string?\"   |\n| }                  |\n| };                 | ` ### To-Many Relationship A **to-many** relationship means that an object is related in a specific way to multiple objects. To define a to-many relationship, specify a property where the type is a list or array of the related Realm object type in its[object schema.](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas) ## Example\n\n ```javascript const Person = {   name: \"Person\",   properties: {     name: \"string\",     birthdate: \"date\",     dogs: \"Dog[]\"   } }; const Dog = {   name: \"Dog\",   properties: {     name: \"string\",     age: \"int\",     breed: \"string?\"   } }; \n``` ### Inverse Relationship An inverse relationship links an object back to any other objects that refer to it in a defined to-one or to-many relationship. Relationship definitions are unidirectional by default. You must explicitly define a property in the object's model as an inverse relationship. For example, the to-many relationship \"User has many Tasks\" does not automatically create the inverse relationship \"Task belongs to User\". If you don't specify the inverse relationship in the object model, you need to run a separate query to look up the user assigned to a task. To define an inverse relationship, define a `linkingObjects` property in your object model. `linkingObjects` specifies the object type and property name of the relationship that it inverts. You cannot manually set the value of an inverse relationship property. Realm Database automatically updates implicit relationships whenever you add or remove a related object. ## Example An application could use the following object schemas to indicate: 1. A User may be assigned many Tasks.\n2. Each Task should automatically keep track of which User it's assigned to. The User object's tasks property is defined as a to-many relationship with Task objects. It contains all of a given user's assigned tasks. The Task object's assignee property inverts this relationship. Assignee automatically updates to refer back to any User object that contains the Task in its tasks property. #### Dynamically Obtain an Inversely Linked Object You can dynamically retrieve an object with an inverse relationship without defining a `linkingObjects` type in its schema. Remove the`linkingObjects` type from your schema, so your schemas look like a standard**to-many** relationship. When you need to retrieve the linked object, call the[Realm.Object.linkingObjects()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.Object.html#linkingObjects)query. ## Example In the following continuation from the inverse relationship example, we have removed the`assignee` field with type 'linkingObjects' from the Task schema. An application developer creates several users and task objects, and the application pushes the newly created tasks into a user's task field. To find the user who owns a specific task object, the developer calls the`task.linkingObjects()` method and passes the \"User\" class name and \"tasks\" field as parameters. ## Embedded Objects An embedded object is a special type of [Realm object](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas)that models complex data. They also map more naturally to the [MongoDB document model](https://www.mongodb.com/docs/manual/core/data-modeling-introduction/). Embedded objects are similar to [relationships](#std-label-node-client-relationships), but provide additional constraints. Realm treats each embedded object as nested data inside of a parent object. An embedded object inherits the lifecycle of its parent object. It cannot exist as an independent Realm object. This means that embedded objects cannot have a primary key. Realm also automatically deletes embedded objects if their parent object is deleted. ## Tip ### Embedded object types are reusable and composable You can use the same embedded object type in multiple parent object types. You can also embed objects inside of other embedded objects. You can even recursively reference an embedded object type as an optional property in its own definition. ### Realm Object Models To specify that a Realm object model defines an embedded object, set `embedded`to `true`. Reference an embedded object type from parent object types as you would define a relationship: ```javascript const AddressSchema = {   name: \"Address\",   embedded: true, // default: false   properties: {     street: \"string?\",     city: \"string?\",     country: \"string?\",     postalCode: \"string?\",   }, }; const ContactSchema = {   name: \"Contact\",   primaryKey: \"_id\",   properties: {     _id: \"objectId\",     name: \"string\",     address: \"Address\", // Embed a single object\n\n }; const BusinessSchema = {   name: \"Business\",   primaryKey: \"_id\",   properties: {     _id: \"objectId\",     name: \"string\",     addresses: { type: \"list\", objectType: \"Address\" }, // Embed an array of objects   }, }; \n``` ### JSON Schema Embedded objects map to embedded documents in the parent type's [schema](https://www.mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). This behavior differs from regular Realm objects, which map to their own MongoDB collection. ``` {   \"title\": \"Contact\",   \"bsonType\": \"object\",   \"required\": [\"_id\"],   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"name\": { \"bsonType\": \"string\" },     \"address\": {       \"title\": \"Address\",       \"bsonType\": \"object\",       \"properties\": {         \"street\": { \"bsonType\": \"string\" },         \"city\": { \"bsonType\": \"string\" },         \"country\": { \"bsonType\": \"string\" },         \"postalCode\": { \"bsonType\": \"string\" }       }     }   } } \n``` ``` {   \"title\": \"Business\",   \"bsonType\": \"object\",   \"required\": [\"_id\", \"name\", \"addresses\"],   \"properties\": {     \"_id\": \"objectId\",     \"name\": { \"bsonType\": \"string\" },     \"addresses\": {       \"bsonType\": \"array\",       \"items\": {         \"title\": \"Address\",         \"bsonType\": \"object\",         \"properties\": {           \"street\": { \"bsonType\": \"string\" },           \"city\": { \"bsonType\": \"string\" },           \"country\": { \"bsonType\": \"string\" },           \"postalCode\": { \"bsonType\": \"string\" }         }       }     }   } } \n``` ← [Write Transactions - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/ \"Previous Section\")[Schema Versions & Migrations - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/integrations/electron/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start with Electron On this page * [Overview](#overview)\n* [Setup](#setup)\n* [Set up Your Application Files](#set-up-your-application-files)\n* [Create the Main Script File](#create-the-main-script-file)\n* [Set up a package.json](#set-up-a-package.json)\n* [Install Your Project Dependencies](#install-your-project-dependencies)\n* [Create a Script to Run Your Application](#create-a-script-to-run-your-application)\n* [Run Your Application](#run-your-application)\n* [Open a Realm](#open-a-realm) ## Overview This page contains information to integrate Realm into your Electron application quickly. To learn how to set up an Electron application with Realm without using any additional frameworks, see the[Electron set up](#std-label-electron-setup) instructions. If you have already created an application using [Create React App](https://reactjs.org/docs/create-a-new-react-app.html) or are interested in integrating a React App with Realm using Electron, check out the [Electron with React set up](https://mongodb.com/docs/realm/sdk/node/integrations/electron-cra/#std-label-node-electron-cra-client-quick-start)instructions. Before you begin, ensure you have: * [Created an App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enabled Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) ## Note ### Version Requirement Realm works with any of the officially supported Electron versions. We recommend using the latest stable release. To see the officially supported Electron versions, check out the [Electron Releases](https://www.electronjs.org/releases/) document. ## Setup 1 ### Set up Your Application Files To begin developing your application, create an application directory: `| mkdir myElectronApplication |\n| --------------------------- | ` Create an `index.html`, `main.js`, and `renderer.js` file in the root directory of your application. ```shell touch index.html main.js renderer.js \n``` The `main.js` file is the entry point into your application and executes on the main process. It is responsible for loading your `index.html`file into Electron's [BrowserWindow API](https://www.electronjs.org/docs/api/browser-window). Any script files that you require in this HTML file will execute on a renderer process. Add the following to your `index.html` file: ``` <!DOCTYPE html> <html>   <head>     <meta charset=\"UTF-8\" />     <title>Hello World!</title>   </head>   <body>     <h1>Hello World!</h1>     <script src=\"renderer.js\"></script>   </body> </html> \n``` Add the following code to the `renderer.js` file: ```javascript const Realm = require(\"realm\"); \n``` ## Note Each Electron application can only have one `main process`. The main process creates web pages. Each web page runs in its own process, known as a `renderer process`. To learn more about this, read the official [Electron Process Model](https://www.electronjs.org/docs/latest/tutorial/process-model)document. 2 ### Create the Main Script File The `main.js` file is the entry point of your application. Create an Electron BrowserWindow in it and load your `index.html` file to display your HTML to users: ```javascript const { app, BrowserWindow } = require('electron') function createWindow () {   const win = new BrowserWindow({     width: 800,     height: 600,     webPreferences: {       nodeIntegration: true,       contextIsolation: false     }   })\n\n   process.stdin.resume();   win.loadFile('index.html') } app.whenReady().then(createWindow) \n``` 3 ### Set up a `package.json` Initialize a `package.json` to begin installing packages and using them in your project. Run the following command in your terminal: ```shell npm init -y \n``` Your application file structure should resemble the following: ``` . |-- package.json |-- package-lock.lock |-- index.html |-- main.js // runs on the main process |-- renderer.js // runs on a renderer process \n``` The file `main.js` executes on the `main` process. The file`renderer.js` and any other files required by it, or by `index.html`, executes on a `renderer` process. 4 ### Install Your Project Dependencies Install the necessary dependencies to begin developing your Electron application using Realm. ```shell npm install electron --save-dev npm install realm --save \n``` 5 ### Create a Script to Run Your Application Add a script to your `package.json` file in order to start your application with the `npm start` command. ``` \"scripts\": {  \"start\": \"electron .\" } \n``` 6 ### Run Your Application Start your application from the terminal: ```shell npm start \n``` You should see the following: ![Electron Desktop App](https://mongodb.com/docs/realm/images/electron-app.png) ## Open a Realm Authenticate a user, define a schema, and [sync enabled Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync), then call [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open) in your renderer.js file. Once you have opened the realm, you can [write to the realm.](https://mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/#std-label-node-realm-database-writes) ```javascript const app = new Realm.App({ id: \"<Your App ID>\" }); // create a new instance of the Realm.App async function run() {   // login with an anonymous credential   await app.logIn(Realm.Credentials.anonymous());   const DogSchema = {       name: \"Dog\",       properties: {         _id: 'int',         name: \"string\",         age: \"int\",       },       primaryKey: '_id'   };   const realm = await Realm.open({     schema: [DogSchema],     sync: {       user: app.currentUser,       partitionValue: \"myPartition\",     },   });   // The myPartition realm is now synced to the device. You can   // access it through the `realm` object returned by `Realm.open()`   // write to the realm } run().catch(err => {   console.error(\"Failed to open realm:\", err) }); \n``` ## Note For an example of writing to a realm from both the `renderer` and `main`processes, check out the [realm-electron-advanced-quickstart](https://github.com/mongodb-university/realm-electron-advanced-quickstart)repository. ## Tip ### See also:  * [Sync Changes Between Devices](https://mongodb.com/docs/realm/sdk/node/examples/sync-changes-between-devices/#std-label-node-sync-changes-between-devices)\n* [Define Your Schema](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas)\n* [Authenticate a User](https://mongodb.com/docs/realm/sdk/node/examples/authenticate-users/) ← [Realm Integrations - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/integrations/ \"Previous Section\")[Quick Start with Electron using React](https://mongodb.com/docs/realm/sdk/node/integrations/electron-cra/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/integrations/electron-cra/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Quick Start with Electron using React On this page * [Overview](#overview)\n* [Setup](#setup)\n* [Create Your React Application](#create-your-react-application)\n* [Remove the web-vitals dependency](#remove-the-web-vitals-dependency)\n* [Install CRACO to Alter Your Webpack Configuration](#install-craco-to-alter-your-webpack-configuration)\n* [Create a CRACO Configuration File](#create-a-craco-configuration-file)\n* [Install Electron](#install-electron)\n* [Create Your Electron Main Process File](#create-your-electron-main-process-file)\n* [Run Your Application](#run-your-application)\n* [Install Realm](#install-realm)\n* [Open a Realm](#open-a-realm) ## Overview This page contains information to get Realm integrated into your Electron application quickly by developing an application using [Create React App.](https://reactjs.org//docs/create-a-new-react-app.html) Before you begin, ensure you have: * [Created an App](https://www.mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-a-realm-app)\n* [Enabled Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) ## Note ### Version Requirement - Electron Realm works with any of the officially supported Electron versions. However, as Electron is constantly changing with each update, we recommend using Electron version 13.2.x for compatibility with this documentation. To see the officially supported Electron versions, check out the [Electron Releases](https://www.electronjs.org/releases/) document. ## Note ### Version Requirement - React.js This guide was created with support for [React.js version 17.0](https://reactjs.org//versions) and [Create React App version 4.0](https://github.com//facebook/create-react-app/releases). Versions other than those may lead to errors while building the application since new dependencies are frequently added to both React.js and Create React App. ## Setup To set up an Electron application using Realm use the following instructions: 1 ### Create Your React Application Scaffold your application by using the [Create React App](https://reactjs.org/docs/create-a-new-react-app.html) toolchain. Enter the following command into your terminal: `| npx create-react-app my_electron_react_application |\n| -------------------------------------------------- | ` Your application should include the following files. Some additional files in your project, such as CSS, service worker, and test files aren't included below. ``` . |-- package.json |-- package-lock.lock |-- public |   |-- index.html |-- src |   |-- App.js // renderer process |-- |-- index.js // renderer process \n``` Any JS file within the `src` directory executes on a `renderer process`. ## Note Each Electron application can only have one **main process**. The main process creates web pages. Each web page runs in its own process, known as **renderer process**. To learn more about this, read the official [Electron Process Model](https://www.electronjs.org/docs/latest/tutorial/process-model) doc. 2 ### Remove the web-vitals dependency Create React App version 4.0+ includes the [web-vitals](https://www.npmjs.com//package/web-vitals) module. Since 'web-vitals' is designed to work with the web rather than an Electron environment, the inclusion of this module may lead to a `\"chunk runtime-main [entry] Cannot convert undefined or null to object\"` error when building the application. To avoid this error, run the following command to uninstall the `web-vitals` package. ```shell npm uninstall web-vitals \n``` Then delete the `reportWebVitals.js` file: ```shell rm src/reportWebVitals.js \n``` Finally, remove the following lines from the `src/index.js` file: ```javascript\n\n reportWebVitals(); \n``` 3 ### Install CRACO to Alter Your Webpack Configuration To allow your application to work properly with Electron, you have to alter your webpack configuration. By default, applications created via create-react-app use a preconfigured webpack file and hidden to the end-user. The Create React App default webpack configuration is not compatible with Realm and you must override it. You can use [CRACO](https://www.npmjs.com/package/@craco/craco) to override these default values. Install CRACO with the following command: ```shell npm install @craco/craco \n``` 4 ### Create a CRACO Configuration File In order to override the preconfigured webpack values, create a CRACO config file called `craco.config.js` at the root of your application. Add the following to this file: ```javascript const nodeExternals = require(\"webpack-node-externals\"); module.exports = {   webpack: {     configure: {       target: \"electron-renderer\",       externals: [         nodeExternals({           allowlist: [/webpack(\\/.*)?/, \"electron-devtools-installer\"],         }),       ],     },   }, }; \n``` The [target](https://webpack.js.org/configuration/target/) is set to \"electron-renderer\" to compile your application for browser environments for Electron built-in modules. `nodeExternals` is also specified to prevent all node\\_modules from being bundled. The `allowList` key in the object passed in to `nodeExternals` specifies a list of modules to include in the bundle, in this case electron's dev tools and webpack. In order to make use of webpack-node-externals, run the following command: ```shell npm install webpack-node-externals --save-dev \n``` 5 ### Install Electron To add Electron to your project, run the following command: ```shell npm install electron --save-dev \n``` 6 ### Create Your Electron Main Process File The Electron `main process` file can be thought of as the entry point into your application. This file is responsible for loading your React App's `index.html` file into the `BrowserWindow` created by Electron. ## Note Each Electron application can only have one **main process**. The main process can create web pages. Each web page runs in its own process, known as a **renderer process**. To learn more about this, read the official [Electron Process Model](https://www.electronjs.org/docs/latest/tutorial/process-model)doc. Add the following code to a new file called `electron.js` in the`public` directory: ```javascript const electron = require(\"electron\"); const path = require(\"path\"); const app = electron.app; const BrowserWindow = electron.BrowserWindow; let mainWindow; function createWindow() {   // Create the browser window.   mainWindow = new BrowserWindow({     width: 800,     height: 600,     webPreferences: { nodeIntegration: true, contextIsolation: false },   });   // and load the index.html of the app.   console.log(__dirname);   mainWindow.loadFile(path.join(__dirname, \"../build/index.html\")); } // This method will be called when Electron has finished // initialization and is ready to create browser windows. // Some APIs can only be used after this event occurs. app.on(\"ready\", createWindow); \n``` Your application should now include the following files. Some additional files in your project, such as CSS, service worker, and test files aren't included below. ``` . |-- package.json |-- package-lock.lock |-- craco.config.js |-- public |   |-- index.html |   |-- electron.js // main process |-- src |   |-- App.js // renderer process |-- |-- index.js // renderer process \n``` All JS files within the `src` directory executes on the `renderer` process. The electron.js and any files required by it execute on the main process. 7 ### Run Your Application\n\n ```shell \"main\": \"public/electron.js\", \"homepage\": \"./\", \n``` Finally, add the following scripts to your `package.json` file: ```shell \"scripts\": {   \"build\": \"craco build\",   \"start\": \"electron .\" }, \n``` In your terminal, run `npm run build` and then `npm run start`. You should see the following: ![Electron Desktop App with React](https://mongodb.com/docs/realm/images/electron-cra.png) 8 ### Install Realm In your terminal, use the following command to add Realm to your project: ```shell npm install realm \n``` Use realm in the **renderer process** by adding the following to the top of the `src/App.js` file (you will also need to import it in whichever file you write code using Realm in): ```shell import Realm from \"realm\"; \n``` ## Open a Realm Authenticate a user, define a schema, and [sync enabled Device Sync](https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync), then call [Realm.open()](https://www.mongodb.com/docs/realm-sdks/js/latest/Realm.html#.open) in a file that you have imported Realm into. Once you have opened the realm, you can [write to the realm.](https://mongodb.com/docs/realm/sdk/node/fundamentals/write-transactions/#std-label-node-realm-database-writes) ```javascript const app = new Realm.App({ id: \"<Your App ID>\" }); // create a new instance of the Realm.App async function run() {   // login with an anonymous credential   await app.logIn(Realm.Credentials.anonymous());   const DogSchema = {       name: \"Dog\",       properties: {         _id: 'int',         name: \"string\",         age: \"int\",       },       primaryKey: '_id'   };   const realm = await Realm.open({     schema: [DogSchema],     sync: {       user: app.currentUser,       partitionValue: \"myPartition\",     },   });   // The myPartition realm is now synced to the device. You can   // access it through the `realm` object returned by `Realm.open()`   // write to the realm } run().catch(err => {   console.error(\"Failed to open realm:\", err) }); \n``` ## Note For an example of writing to a realm from both the `renderer` and `main`processes, check out the [realm-electron-advanced-quickstart](https://github.com/mongodb-university/realm-electron-advanced-quickstart)repository. ## Tip ### See also:  * [Sync Data](https://mongodb.com/docs/realm/sdk/node/examples/open-and-close-a-realm/#std-label-node-partition-sync-open-realm)\n* [Define Your Schema](https://mongodb.com/docs/realm/sdk/node/fundamentals/realms/#std-label-node-object-schemas)\n* [Authenticate a User](https://mongodb.com/docs/realm/sdk/node/examples/authenticate-users/) ← [Quick Start with Electron](https://mongodb.com/docs/realm/sdk/node/integrations/electron/ \"Previous Section\")[Advanced Guides - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/advanced/ \"Next Section\") →",
  "https://www.mongodb.com/docs/realm/sdk/node/fundamentals/application-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Realm](https://mongodb.com/docs/realm/) # Application Services - Node.js SDK On this page * [Overview](#overview)\n* [The App Client](#the-app-client)\n* [Authentication & User Management](#authentication---user-management)\n* [Calling Functions](#calling-functions)\n* [Accessing MongoDB](#accessing-mongodb) ## Overview Realm provides SDKs that help you connect your client apps to the Atlas App Services backend. The SDK provides the functionality needed to authenticate users with any of the built-in [Authentication providers](https://www.mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers), call [Atlas Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions), and directly access a[MongoDB database.](https://www.mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) ## The App Client When using the SDK to access the App Services backend, you start with an App object. This object provides all other functionality related to App Services. The `App` object is[initialized](https://mongodb.com/docs/realm/sdk/node/examples/connect-to-app-services-backend/#std-label-node-connect-to-mongodb-realm-backend-app) with the App ID, which you can[find in the App Services UI.](https://www.mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-find-your-app-id) ## Tip To learn how to initialize the App client, see[Connect to an Atlas App Services Backend - Node.js SDK.](https://mongodb.com/docs/realm/sdk/node/examples/connect-to-app-services-backend/#std-label-node-connect-to-mongodb-realm-backend-app) ## Authentication & User Management One of the most challenging aspects of client development is implementing a robust and secure authentication system. With the Realm SDKs, however, you can use any of the App Services authentication providers with very minimal backend setup or client-side code required. With the authentication APIs, you can implement the following functionality: * Creation of new user accounts\n* User log-in and log-out\n* Multiple users logged on at the same time on the same device\n* Linking user accounts from different providers\n* Providing custom user data ## Tip To learn how to set up authentication with different providers, see[Authenticate Users - Node.js SDK.](https://mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-authenticate-users) To learn how to manage multiple users, see [Multi-User Applications - Node.js SDK.](https://mongodb.com/docs/realm/sdk/node/advanced/multi-user-applications/#std-label-node-multi-user-applications) To learn how to link user accounts, see [Link User Identities - Node.js SDK.](https://mongodb.com/docs/realm/sdk/node/advanced/link-identities/#std-label-node-link-user-identities) To learn how to provide custom user data, see [Access Custom User Data - Node.js SDK.](https://mongodb.com/docs/realm/sdk/node/advanced/access-custom-user-data/#std-label-node-access-custom-user-data) ## Calling Functions [Functions](https://www.mongodb.com/docs/atlas/app-services/functions/#std-label-functions) enable you to define and execute server-side logic for your application. You can call these functions from your client applications via the Realm SDKs. These server-side functions can run under the context of the authenticated user, and thus honor the rules, roles, and permissions that you have assigned to your collections. By using Functions, you provide a secure way for a variety of client applications to share complex functionality without having to reproduce that logic client-side. ## Tip To learn how to call functions, see [Call a Function.](https://mongodb.com/docs/realm/sdk/node/examples/call-a-function/#std-label-node-call-a-function) ## Accessing MongoDB\n\n ## Tip To learn how to use the MongoDB APIs, see [Query MongoDB.](https://mongodb.com/docs/realm/sdk/node/examples/query-mongodb/#std-label-node-mongodb-data-access) ← [Schema Versions & Migrations - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/schema-versions-and-migrations/ \"Previous Section\")[Atlas Device Sync - Node.js SDK](https://mongodb.com/docs/realm/sdk/node/fundamentals/device-sync/ \"Next Section\") →"
}