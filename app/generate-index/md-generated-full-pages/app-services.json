{
  "https://www.mongodb.com/docs/atlas/app-services/rules/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Define Data Access Permissions ## Overview In traditional applications, an application server exposes an API to client applications and handles database queries on their behalf. To prevent malicious, improper, or incorrect read and write operations, clients don't query the database directly. Atlas App Services provides a configurable and dynamic permissions engine that enables you to run a MongoDB query from client applications while transparently preventing unauthorized reads and writes. Permissions are defined for entire collections in a linked MongoDB Atlas cluster and apply to individual documents in the collection dynamically based on the [application user](https://mongodb.com/docs/atlas/app-services/users/) that issues a query or uses Device Sync. You can also define default rules that serve as a fallback for any collection that doesn't have its own rules. ## Note Federated data sources [do not support rules or schemas](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats). You can only access a Federated data source from a system function. ## Key Concepts To understand how the permissions engine works and how to configure it for your use case, see [Role-based Permissions.](https://mongodb.com/docs/atlas/app-services/rules/roles/) You define permissions with [Rule Expressions](https://mongodb.com/docs/atlas/app-services/rules/expressions/), a domain-specific language built on JSON. You can optimize the performance of the permissions engine with filters. See[Filter Incoming Queries.](https://mongodb.com/docs/atlas/app-services/rules/filters/) If you're using Device Sync (Flexible Mode), permissions work a bit differently. See [Device Sync-Compatible Permissions](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/) for important considerations. The default or \"Basic Mode\" rules editor in the App Services UI covers the majority of use cases for collection rules. However, there are times when you need more fine-grained control than the UI interface provides. In those times, see [Configure Advanced Rules.](https://mongodb.com/docs/atlas/app-services/mongodb/configure-advanced-rules/) Finally, to help you put these concepts into practice, we have provided some[Data Access Role Examples.](https://mongodb.com/docs/atlas/app-services/rules/examples/) ← [Access a Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/access-a-value/ \"Previous Section\")[Role-based Permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/triggers/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Atlas Triggers On this page * [Trigger Types](#trigger-types)\n* [Limitations](#limitations)\n* [Atlas Function Constraints Apply](#atlas-function-constraints-apply)\n* [Maximum Executions Per Second](#maximum-executions-per-second)\n* [Number of Triggers Cannot Exceed Available Change Streams](#number-of-triggers-cannot-exceed-available-change-streams) Atlas Triggers execute application and database logic. Triggers can respond to events or use pre-defined schedules. Triggers listen for events of a configured type. Each Trigger links to a specific [Atlas Function](https://mongodb.com/docs/atlas/app-services/functions/). When a Trigger observes an event that matches your configuration, it _\"fires.\"_ The Trigger passes this event object as the argument to its linked Function. A Trigger might fire on: * A specific _operation type_ in a given Collection.\n* An authentication event, such as user creation or deletion.\n* A scheduled time. App Services keeps track of the latest execution time for each Trigger. ## Trigger Types App Services supports three types of triggers: * [Database triggers](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/)respond to document insert, changes, or deletion. You can configure Database Triggers for each linked MongoDB collection.\n* [Authentication triggers](https://mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/)respond to user creation, login, or deletion.\n* [Scheduled triggers](https://mongodb.com/docs/atlas/app-services/triggers/scheduled-triggers/)execute functions according to a pre-defined schedule. ## Limitations ### Atlas Function Constraints Apply Triggers invoke Atlas Functions. This means they have the same constraints as all Atlas Functions. [Learn more about Atlas Function constraints.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-function-constraints) ### Maximum Executions Per Second App Services limits the execution of Trigger Functions. A Trigger can execute up to 2500 times per second. When a Trigger calls a Function, this call goes into a queue. When capacity becomes available, App Services executes the Function call. ## Note Your application's execution rate may be lower than 2500 per second. This varies depending on your Atlas instance size. Database Triggers with _event ordering_ work differently. Each ordered Trigger processes events in sequence. App Services waits for each event execution in the sequence to complete. Then, it handles the next event. Only one sequence for a given ordered Trigger executes at a time. ### Number of Triggers Cannot Exceed Available Change Streams App Services limits the total number of Database Triggers. The size of your Atlas cluster drives this limit. Each Atlas cluster tier has a maximum number of supported change streams. A Database Trigger requires its own change stream. Other App Services also use change streams, such as Atlas Device Sync. Database Triggers may not exceed the number of available change streams. [Learn more about the number of supported change streams for Atlas tiers.](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations-change-streams) ← [JavaScript Support](https://mongodb.com/docs/atlas/app-services/functions/javascript-support/ \"Previous Section\")[Database Triggers](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/get-started/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Get Started On this page * [Template Apps](#template-apps)\n* [Tutorials](#tutorials) The resources on this page are designed to help you begin using Atlas App Services. To explore a working codebase that showcases App Services' features, check out a Template App. For a more guided experience in learning how to develop with App Services and Realm, start with a Tutorial. ## Template Apps Bootstrap App Services with a [Template App](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps). Template apps bring together many of the building blocks available in Atlas App Services and start you off with a prebuilt app that you can customize. The following template apps are available: * Todo list mobile apps written with Realm SDKs that sync data with App Services using Device Sync\n* A todo list web app using the GraphQL API and the Realm Web SDK\n* An Event-driven [Database Trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/)template that updates a view in a separate collection. Checkout the template apps or visit the Tutorials section for a walkthrough of a template app. [Sign-up to Deploy a Template App](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Ftemplate%5Fapps) ## Tutorials Tutorials provide a detailed step-by-step guide to developing apps that use App Services features. ![React Native SDK](https://mongodb.com/docs/atlas/app-services/images/icons/react_native_sdk.svg) React Native Template App with JavaScript Develop a cross-platform to-do list app that syncs data using the React Native SDK and Device Sync. ![Swift SDK](https://mongodb.com/docs/atlas/app-services/images/icons/swift_sdk.svg) iOS Template App with SwiftUI Develop an iOS to-do list app that syncs data using the Swift SDK and Device Sync. ![Kotlin SDK](https://mongodb.com/docs/atlas/app-services/images/icons/kotlin_sdk.svg) Android Template App with Kotlin Develop an Android to-do list app that syncs data using the Kotlin SDK and Device Sync. ![Dot Net SDK](https://mongodb.com/docs/atlas/app-services/images/icons/dot_net_sdk.svg) Xamarin Template App with C# Develop a cross-platform to-do list app that syncs data using the .NET SDK and Device Sync. ![Flutter SDK](https://mongodb.com/docs/atlas/app-services/images/icons/flutter.svg) Flutter Template App with Dart Develop a multi-platform to-do list app that syncs data using the Flutter SDK and Device Sync. ![Tracker Dashboard Icon](https://mongodb.com/docs/atlas/app-services/images/icons/data-access-control.png) Github Issue Tracker Build a serverless app to track GitHub activity. ← [Introduction to Atlas App Services for Backend and Web Developers](https://mongodb.com/docs/atlas/app-services/introduction/ \"Previous Section\")[MAUI Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/dotnet/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/graphql/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Atlas GraphQL API On this page * [Overview](#overview)\n* [Why GraphQL?](#why-graphql-)\n* [How App Services Creates GraphQL Schemas](#how-app-services-creates-graphql-schemas)\n* [GraphQL Operations](#graphql-operations)\n* [Queries](#queries)\n* [Mutations](#mutations)\n* [Limitations](#limitations) ## Overview The Atlas [GraphQL](https://graphql.org/) API allows client applications to access data stored in a linked MongoDB Atlas cluster using any standard GraphQL client. Atlas App Services automatically creates GraphQL types for every linked collection that has a defined [schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) and evaluates[role-based permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-define-roles-and-permissions) for all GraphQL requests. To learn how to make data available through the GraphQL API, see [Expose Data in a Collection.](https://mongodb.com/docs/atlas/app-services/graphql/expose-data/#std-label-graphql-expose-data) To learn about the generated types and operations that you can use with the Atlas GraphQL API, see [GraphQL Types & Resolvers.](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-types-and-resolvers) To extend the generated GraphQL API's functionality with custom queries and mutations, see [Define a Custom Resolver.](https://mongodb.com/docs/atlas/app-services/graphql/custom-resolvers/#std-label-graphql-custom-resolvers) ## Note ### Create an Atlas Cluster for Free The GraphQL API lets you access data that you have stored in a[MongoDB Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container) cluster or Federated database instance. To get started, create a free cluster and [link it to your App.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-link-a-data-source) If you don't have any data yet but you still want to explore the GraphQL API, consider adding a [sample data set](https://www.mongodb.com/docs/atlas/sample-data/) to your cluster. ## Why GraphQL? GraphQL is a declarative, strongly-typed query language for client applications. Clients define the exact data shape and contents that they need in a single request which eliminates over-fetching problems and circumvents the need for multiple costly round trips to the server. To learn more about GraphQL, check out the [official GraphQL tutorial.](https://graphql.org/learn) ## How App Services Creates GraphQL Schemas Using App Services, you generate the GraphQL schema and resolvers from JSON schemas for MongoDB collections. This differs from the traditional code-first and schema-first approaches to GraphQL schema development. To define your GraphQL schema with App Services: 1. [Define a JSON schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) for a MongoDB collection in your MongoDB Atlas cluster. You can [enforce the shape of the collection schema](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema)based on custom definitions or use a generated schema based on the documents in the collection.\n2. [Generate the GraphQL schema and resolvers](https://mongodb.com/docs/atlas/app-services/graphql/expose-data/#std-label-graphql-expose-data) based on your collection JSON schema.\n3. Optionally extend the functionality of your generated GraphQL schema with[custom resolvers.](https://mongodb.com/docs/atlas/app-services/graphql/custom-resolvers/#std-label-graphql-custom-resolvers) ## GraphQL Operations\n\n For more information on how to expose a collection and name its data type, see [Expose Data in a Collection.](https://mongodb.com/docs/atlas/app-services/graphql/expose-data/#std-label-graphql-expose-data) ## Note GraphQL mutation and custom resolver requests use MongoDB transactions to ensure correctness across multiple database operations. If any operation in a request fails, then the entire transaction fails and no operations are committed to the database. ### Queries A GraphQL **query** is a read operation that requests specific fields from one or more types. App Services automatically generates query types for documents in each collection that has a defined [schema.](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) For more information and examples, including a list of all automatically generated query types, see [Query Resolvers.](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-query-resolvers)\n\n ` ### Mutations A GraphQL **mutation** is a write operation that creates, modifies, or deletes one or more documents. App Services automatically generates mutation types for documents in each collection that has a defined [schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). App Services uses transactions to ensure safe writes via mutations. For more information and examples, including a list of all automatically generated mutation types, see [Mutation Resolvers.](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-mutation-resolvers) ``` # Insert a new movie mutation {   insertOneMovie(data: {     title: \"Little Women\"     director: \"Greta Gerwig\"     year: 2019     runtime: 135   }) {     _id     title   } } # Update the year of a movie mutation {   updateOneMovie(     query: { title: \"The Matrix\" }     set: { year: 1999 }   ) {     _id     title   } } # Delete a movie mutation {   deleteOneMovie(query: { title: \"The Room\" }) {     _id     title   } } # Delete multiple movies mutation {   deleteManyMovies(query: { director: \"Tommy Wiseau\" }) {     _id     title   } } \n``` ## Limitations * The GraphQL API can process a maximum of ten resolvers for a given query or mutation. If an operation specifies more than ten resolvers, the entire operation fails with the error message `\"max number of queries reached\"`.\n* The GraphQL API can resolve [relationships](https://mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-relationships) to a maximum depth of five for a given query or mutation. If an operation specifies a relationship deeper than five resolvers, the entire operation fails with the error message `\"max relationship depth exceeded\"`.\n* The GraphQL API does not currently support relationships for fields inside arrays of embedded objects. You can use a [custom resolver](https://mongodb.com/docs/atlas/app-services/graphql/custom-resolvers/#std-label-graphql-custom-resolvers) to manually look up and resolve embedded object array relationships. ← [Atlas Device Sync Protocol](https://mongodb.com/docs/atlas/app-services/sync/details/protocol/ \"Previous Section\")[Expose Data in a Collection](https://mongodb.com/docs/atlas/app-services/graphql/expose-data/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Reference * [App Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/)\n* [App Metrics](https://mongodb.com/docs/atlas/app-services/reference/metrics/)\n* [App Services Admin API](https://mongodb.com/docs/atlas/app-services/admin/api/v3/)\n* [Realm CLI](https://mongodb.com/docs/atlas/app-services/cli/)\n* [Billing](https://mongodb.com/docs/atlas/app-services/billing/)\n* [Service Limitations](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/)\n* [Template Apps](https://mongodb.com/docs/atlas/app-services/reference/template-apps/)\n* [Third-Party Licenses](https://mongodb.com/docs/atlas/app-services/reference/third-party-licenses/)\n* [Upgrade a Shared Tier Cluster](https://mongodb.com/docs/atlas/app-services/reference/upgrade-shared-cluster/)\n* [Partition-Based Sync Mode](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/)\n* [Push Notifications \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/reference/push-notifications/)\n* [Third-Party Services \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/reference/services/) ← [Use a Custom Domain Name](https://mongodb.com/docs/atlas/app-services/hosting/use-a-custom-domain-name/ \"Previous Section\")[App Configuration](https://mongodb.com/docs/atlas/app-services/reference/config/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/security/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Secure Your App On this page * [Overview](#overview)\n* [Application Users](#application-users)\n* [Data Access Permissions](#data-access-permissions)\n* [App Services Applications with Sync](#app-services-applications-with-sync)\n* [MongoDB Atlas Data Sources](#mongodb-atlas-data-sources)\n* [Values and Secrets](#values-and-secrets)\n* [Summary](#summary) ## Overview Atlas App Services provides a variety of security features to protect your data and prevent unauthorized access to your application. This includes things like: * Built-in user management\n* Data access permissions\n* Network security features\n* The ability to store and substitute values and secrets ## Application Users You can secure App Services Apps with [built-in user management](https://mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication). With the built-in user management of App Services, only authorized users can access your App. You can[delete](https://mongodb.com/docs/atlas/app-services/users/manage/#std-label-delete-user) or [disable](https://mongodb.com/docs/atlas/app-services/users/manage/#std-label-disable-user) users, and[revoke user sessions](https://mongodb.com/docs/atlas/app-services/users/sessions/#std-label-revoke-user-sessions). Users can log in with: * Existing provider credentials, such as [Facebook](https://mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication), [Google](https://mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication), or[Apple ID](https://mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication)\n* New credentials with [email/password](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication),[custom JWT](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication), or [custom function authentication](https://mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication)\n* [Anonymous authentication](https://mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication), if you don't need to store user data You can enable one or more [authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) in the App Services backend, and then implement them in your client code. You can also link user accounts with client SDKs. ## Data Access Permissions Use App Services [data access rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-rules) to grant read and write access to data. Apps that use Atlas Device Sync define data access permissions during the process of enabling Device Sync. Apps that do not use Device Sync can link an MongoDB Atlas data source, and define permissions to perform CRUD operations on that data source. MongoDB data access rules prevent operations where users do not have appropriate permissions. Users who do not meet your data access rules cannot view or modify data. ### App Services Applications with Sync Atlas Device Sync allows you to define data access rules that determine which users can read or write which data. To learn how to configure these rules, refer to [Role-based Permissions.](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-sync-permissions) ### MongoDB Atlas Data Sources When you access [MongoDB Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container)through App Services, you can define roles that enable users to read and modify data. App Services uses a strict rules system that prevents all operations unless they are explicitly enabled.\n\n ## Note When you access MongoDB Atlas through an App with Atlas Device Sync enabled, the permissions you define for Device Sync apply, instead of the[role-based permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-define-roles-and-permissions) you define when you link an MongoDB Atlas data source. ## Values and Secrets App Services enables you to define [values and secrets](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets)that you can access or link to from your application. This enables you to remove deployment-specific configuration data and sensitive information from your app's business logic. Instead, you refer to it by name and App Services substitutes the value when executing your request. ## Summary * Built-in user management handles authentication and ensures only logged-in users can access your App.\n* Data access permissions enable you to specify read and write permissions for Atlas Device Sync, linked MongoDB Atlas data sources, and developers building your apps.\n* Network security features enable you to guard against unauthorized access from unknown IP addresses or URLs.\n* Store values and secrets and refer to them by name to remove sensitive information from your business logic. ← [Data Access Role Examples](https://mongodb.com/docs/atlas/app-services/rules/examples/ \"Previous Section\")[Configure Network Security](https://mongodb.com/docs/atlas/app-services/security/network/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/": " # Atlas Device Sync You're developing a mobile app. Your users want their data saved in the cloud and accessible from their other devices. Network access on a mobile device can be intermittent, so you write data locally on the device first. A background process then synchronizes the data to the cloud and resolves any conflicting writes. Atlas Device Sync provides all of the above, so you can build better apps faster. [Start Building with a Template App](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Fapp%5Fservices) ![Atlas Device Sync Illustration](https://mongodb.com/docs/atlas/app-services/images/plp/Spot_AzureBlue_Sync_Tech_RealmSync.png) What It Is ## Key Features ![An icon depicting a mobile phone connecting with the cloud](https://mongodb.com/docs/atlas/app-services/images/icons/General_FEATURES_IntelligentEdge3x.png) Realm in the Front, MongoDB in the Back Atlas Device Sync is a bridge between client apps using the [Realm SDKs](https://www.mongodb.com/docs/realm/)and a MongoDB instance running in Atlas. Realm is a lightweight database optimized for mobile development. ![An icon depicting conflict resolution](https://mongodb.com/docs/atlas/app-services/images/icons/Technical_REALM_ConflictResolution3x.png) Robust & Secure Device Sync handles conflicts for you, so you don't have to write complex custom code to resolve conflicting writes from multiple clients. A user-based permissions system lets you control who can access which data. ![An icon depicting network loss](https://mongodb.com/docs/atlas/app-services/images/icons/Technical_REALM_Offline3x.png) \"Always-On\" Experience Realm Database and Device Sync seamlessly handle intermittent connectivity so users can continue using your app regardless of their current network status. Where to Begin ## Get Started ![An icon depicting two mobile devices synchronizing data between each other](https://mongodb.com/docs/atlas/app-services/images/icons/Technical_REALM_iOSAndriodCrossPlatform3x.png) Launch a Template Starter App The best way to start using Device Sync is with a template starter app. In the Atlas App Services UI, under the App Services tab, you can select a template. Atlas configures a backend instance and gives you the frontend code for a selection of platforms. [Register for a free Atlas account](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Fapp%5Fservices) ![A tutorial icon](https://mongodb.com/docs/atlas/app-services/images/icons/General_CONTENT_Tutorial3x.png) Follow a Device Sync Tutorial The mobile app tutorials guide you through building a feature on top of a template starter app with Atlas Device Sync. [Visit the Tutorials Page](https://www.mongodb.com/docs/atlas/app-services/get-started/#tutorials) Next Steps ## Explore the Device Sync Documentation 1 ### Maintain Data Integrity with Schemas Define your application data model with standard schemas that you can use to validate data and generate language-specific classes. Read the[Sync Data Model Overview](https://mongodb.com/docs/atlas/app-services/sync/data-model/sync-schema-overview/#std-label-sync-schema-overview) to get oriented. 2 ### Configure & Enable Device Sync Whether you based your app on one of our template apps or started from scratch, at some point you'll want to configure Sync specially for your needs. Read more: [Configure and Enable Atlas Device Sync.](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) 3 ### Protect User Data with Permissions Device Sync provides a user-based permissions system that lets you control who can access which data. To learn how to set up permissions for a variety of real use cases, check out the[Device Sync Permissions Guide.](https://mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/#std-label-flexible-sync-permissions-guide) 4 ### Handle Errors\n\n 5 ### Go to Production Test your app under a simulated load with the[Sync Production Load Testing](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-load-testing/#std-label-sync-production-load-testing) guide, then get your app ready to ship with the [Device Sync Production Checklist](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-checklist/#std-label-sync-production-checklist). To understand how costs scale with usage beyond the free tier, refer to the [Billing](https://mongodb.com/docs/atlas/app-services/billing/#std-label-billing) page. More Info ## End-to-End Security ![An icon depicting a mobile app](https://mongodb.com/docs/atlas/app-services/images/icons/Technical_REALM_Mobile3x.png) On Device Encrypt sensitive data in Realm Database files with the encryption APIs. Built-in user authentication providers include anonymous, email/password, API key, Custom Function, Custom JWT, Facebook, Google, and Apple. ![An icon depicting network upload and download](https://mongodb.com/docs/atlas/app-services/images/icons/General_CLOUD_Transfer3x.png) In Flight Device Sync encrypts all network traffic using Transport Layer Security (TLS). Document and field-level permissions determine which data may be synced to the device. ![A padlock icon](https://mongodb.com/docs/atlas/app-services/images/icons/General_SECURITY_Default3x.png) In the Cloud MongoDB Atlas has features that meet essential compliance standards: * Encrypted storage volumes\n* Network isolation\n* Role-based access management\n* ISO, SOC, PCI, HIPAA, HITRUST, VPAT, GDPR, CSA",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Authenticate & Manage Users On this page * [Introduction](#introduction)\n* [Concepts](#concepts)\n* [Authentication Providers](#authentication-providers)\n* [User Accounts](#user-accounts)\n* [Authentication Provider Identities](#authentication-provider-identities)\n* [Active User](#active-user)\n* [System User](#system-user)\n* [User Sessions](#user-sessions)\n* [Summary](#summary) ## Introduction Atlas App Services manages authentication for your application's end users. App Services: * Uses role-based [data access rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) to determine read & write permissions.\n* Associates every request with an authenticated user\n* Evaluates permissions for every object included the request. Through user accounts, you can store and access metadata and custom data for each user. Users log in through [authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers). Each provider represents a specific method of authentication. App Services includes built-in providers for common use cases, such as Facebook and Google. Custom providers allow you to integrate any external authentication system. ## Concepts ### Authentication Providers In App Services, an **authentication provider** is a modular service. These services provide identity verification, and maintain information about app users. Users authenticate themselves by providing a set of credentials to an authentication provider. With valid credentials, the provider returns a unique identity associated with the user. App Services logs them in as the [active user.](#std-label-active-user) App Services includes built-in authentication providers for common use cases. This includes: * [Anonymous users](https://mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)\n* [Email/password combinations](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication)\n* [API keys](https://mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication)\n* OAuth 2.0 through [Facebook](https://mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication), [Google](https://mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication), and [Apple ID](https://mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication) You can configure custom providers to integrate external authentication systems. * [Custom JWT](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication): provider accepts JSON web tokens signed by the external system.\n* [Custom Function](https://mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication): provider allows you to define custom login logic in an Atlas Function. ## Important ### Apps Require User Authentication Every application must have at least one authentication provider configured and enabled. Without at least one provider, no client application can connect. To learn how to configure and enable authentication providers, see: [Authentication Providers.](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) ### User Accounts A **user account** represents a single, distinct user of your application. App Services creates the user when an authentication provider validates a unique identity. You can source user metadata, such as email or birthday, from authentication providers. You can associate each user with [custom data.](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ## Tip ### Apple Account Deletion Requirements\n\n ### Authentication Provider Identities App Services stores login metadata for a user in an**authentication provider identity**. App Services uses this metadata to authenticate the user. Upon first login with an authentication provider, App Services creates an identity object. Each object contains a unique ID, and[provider-specific metadata](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) about the user. On later logins, App Services refreshes the existing identity data. A single user account can have more than one identity. Realm SDKs enable you to link identities to existing user accounts. This allows users to log in to a single account with more than one provider. For more information, see the documentation on linking identities for your client SDK. ### Active User In the Realm SDKs, you can log in more than one user, but only one account can be **active** at any given time. The **active user** is a user account associated with an application request. App Services executes requests from client applications as the active user. App Services replaces dynamic references to the user - e.g. [%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user)in a JSON expression - with the active user. You can use a specific active user, or the system user, to execute Functions. ### System User The **system user** is an internal user that has advanced privileges. The system user bypasses all rules. You can execute [functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) as a system user instead of the user making a request. Triggers run in the context of the system user. The system user is useful for administrative tasks. This includes: * Tasks that need to circumvent rules and queries\n* Tasks that need [unrestricted access](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations-version-requirements) to MongoDB CRUD and aggregation operations ## Important ### Security Warning Rules do not apply to the system user. Functions run as the system user can become a security liability. Ensure that you do not expose these functions to unauthorized users. For example, use [function context](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-user) to check if the active user can call the system function. Define a condition to determine whether the user has the appropriate permissions, e.g.: `| exports = function() {                                                 |\n| ---------------------------------------------------------------------- |\n| const activeUser = context.user                                        |\n| const adminUserId = context.values.get(\"adminUserId\");                 |\n| if(activeUser.id == adminUserId) {                                     |\n| // The user can only execute code here if they're an admin.            |\n| } else {                                                               |\n| throw Error(\"This user is not allowed to execute the system function\") |\n| }                                                                      |\n| }                                                                      | ` ### User Sessions\n\n To learn how to create, work with, and revoke user sessions, see[Manage User Sessions.](https://mongodb.com/docs/atlas/app-services/users/sessions/#std-label-manage-user-sessions) ## Summary * App Services supports authentication and user accounts through a variety of[authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers). You can associate users with more than one authentication provider.\n* App Services supports having more than one user logged in at the same time. There is only one **active user** at a time.\n* The **system user** is a special user that bypasses all rules.\n* Realm SDKs manage the access and refresh tokens that comprise a**user session**. ← [Deployment Models & Regions](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/ \"Previous Section\")[Create an App User](https://mongodb.com/docs/atlas/app-services/users/create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/activity/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Monitor App Activity On this page * [App Logs](#app-logs)\n* [Error Logs](#error-logs)\n* [Log Filters](#log-filters)\n* [Log Lines](#log-lines)\n* [Log Retention](#log-retention)\n* [App Metrics](#app-metrics)\n* [Atlas Alerts](#atlas-alerts) App Services keeps a log of application events, records metrics that summarize your App's usage and performance, and publishes notifications to your Atlas project's activity feed. ## App Logs App Services logs all incoming requests and application events. These events include API requests, Device Sync operations, Trigger execution, User Authentication, and other activities. App Services saves logs for 10 days, after which they are deleted. To learn how to view, filter, and analyze your application logs, see[View Application Logs.](https://mongodb.com/docs/atlas/app-services/activity/view-logs/#std-label-view-logs) A log entry describes a single application event of a given type. Each entry contains information about the event and how the system responded. For example, a log may include the IP address that issued a request as well as a summary of the data access permissions that were evaluated and assigned to serve the request. Apps log the following event types: * [Authentication](https://mongodb.com/docs/atlas/app-services/logs/authentication/#std-label-logs-authentication), including user creation, login, and deletion.\n* [Change Stream](https://mongodb.com/docs/atlas/app-services/logs/changestream/#std-label-logs-change-stream), including any time a user opens or closes a stream of change events.\n* [Device Sync](https://mongodb.com/docs/atlas/app-services/logs/sync/#std-label-logs-sync), including all events related to data synchronization between client devices and MongoDB Atlas.\n* [Endpoint](https://mongodb.com/docs/atlas/app-services/logs/endpoint/#std-label-logs-endpoint), including any time a request is made to a Data API endpoint.\n* [Function](https://mongodb.com/docs/atlas/app-services/logs/function/#std-label-logs-function), including both Atlas Functions as well as individual queries to linked MongoDB Atlas data sources made using the MongoDB service of the a Realm SDK.\n* [Service](https://mongodb.com/docs/atlas/app-services/logs/service/#std-label-logs-service), including HTTPS endpoints and service action calls issued from the a Realm SDK.\n* [Schema](https://mongodb.com/docs/atlas/app-services/logs/schema/#std-label-logs-schema), including any events related to changes to an application's schema.\n* [Trigger](https://mongodb.com/docs/atlas/app-services/logs/trigger/#std-label-logs-trigger), including Database Triggers, Authentication Triggers, and Scheduled Triggers. ### Error Logs All App Services log entries have one of two possible statuses: * `OK`, which represents a normal event that succeeded without an error.\n* `Error`, which represents an event that did not run successfully for any reason. For example, App Services would log an error for any of the following events: * You attempt to access data stored in Atlas for which there is no applicable rule.\n* You throw or fail to handle an error or promise rejection in an Atlas Function.\n* You call `context.services.get()` for a service which does not exist. ### Log Filters For performance reasons, App Services limits individual queries to a maximum of 100 log entries per page. You can filter entries by type, status, timestamp, user, and request ID to return only logs that are relevant to your query. ### Log Lines Functions can log information using JavaScript's `console.log()`method. App Services stringifies each console log and stores each string as a single line. App Services truncates lines to 512 bytes in length. For ASCII character sets, this translates to 512 characters; depending on the character set you use, you may see truncation at lower character counts. App Services saves only the first 25 log lines for a given log entry. ### Log Retention App Services retains logs for 10 days, after which they are deleted.\n\n ## App Metrics App Services constantly measures your App's usage and records aggregate metrics over time. You can access and use the metrics to assess your App's performance and see trends in how your App is used. For example, you can see how much time your App spent performing computations or find the 95th percentile response time for Data API requests. To learn more about which metrics are available and how to access them, see [App Services Metrics.](https://mongodb.com/docs/atlas/app-services/reference/metrics/#std-label-app-services-metrics) ## Atlas Alerts Your App publishes alert events to your Atlas project's activity feed. App Services alerts for administrative events, such as when someone deploys changes to an App or when something like a Trigger or Device Sync process fails and cannot restart automatically. To learn more about your App's alerts, see [Activity Feed & Atlas App Services Alerts.](https://mongodb.com/docs/atlas/app-services/activity/alerts/#std-label-alerts) ← [Manage Developer Access](https://mongodb.com/docs/atlas/app-services/security/developer-access/ \"Previous Section\")[View Application Logs](https://mongodb.com/docs/atlas/app-services/activity/view-logs/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Realm CLI On this page * [Overview](#overview)\n* [Installation](#installation)\n* [Authentication](#authentication)\n* [Generate an API Key](#generate-an-api-key)\n* [Authenticate with an API Key](#authenticate-with-an-api-key)\n* [Options](#options)\n* [Commands](#commands) ## Overview The Atlas App Services Command Line Interface ([realm-cli](#mongodb-binary-bin.realm-cli)) allows you to programmatically manage your App Services Apps. With [realm-cli](#mongodb-binary-bin.realm-cli), you can create or update Apps from a local directory as well as export existing applications to a local directory. ## Important ### Check your CLI version This page is a quickstart for version 2 of [realm-cli](#mongodb-binary-bin.realm-cli). If you need documentation for version 1 of [realm-cli](#mongodb-binary-bin.realm-cli), see: [Realm CLI v1](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-reference-v1/#std-label-realm-cli-v1). To check your CLI version, use: `realm-cli --version`. To upgrade your global install to the latest version, use: `npm upgrade -g mongodb-realm-cli`. ## Installation Realm CLI is available on `npm`. To install version 2 of the Realm CLI on your system, ensure that you have [Node.js](https://nodejs.org/en/download/)installed and then run the following command in your shell: `| npm install -g mongodb-realm-cli |\n| -------------------------------- | ` ## Authentication To use the Realm CLI, you must authenticate. To authenticate, you must generate an API Key. ### Generate an API Key 1 #### Navigate to MongoDB Cloud Access Manager The [MongoDB Cloud Access Manager](https://www.mongodb.com/docs/cloud-manager/tutorial/manage-users/)allows you to manage access to your project for users, teams, and API Keys. Use the Project Access Manager by clicking theProject Access tab on the access manager dropdown on your screen's top left-hand side. ![Click Access Manager](https://mongodb.com/docs/atlas/app-services/images/click-access-manager.png) click to enlarge 2 #### Create an API Key Project Users can log in using the Realm CLI tool with a Project API Key. Create a project API Key by clicking the grey Create API Key button on the right-hand side of the Project Access Manager. ![Click Access Manager](https://mongodb.com/docs/atlas/app-services/images/access-manager-create-api-key-button.png) click to enlarge Clicking this button navigates you to the \"Create API Key\" screen. Set a description for your key. For write access, the CLI requires an API key with \"Project Owner\" permissions. For read-only access, you can use \"Project Read Only\". Use theProject Permissions dropdown to select the appropriate permissions for your use case. Copy the public key to use later in order to log in. Click next to continue configuring your key details. ![Click Access Manager](https://mongodb.com/docs/atlas/app-services/images/configure-api-key.png) click to enlarge 3 #### Configure Your API Access List Copy your Private Key to a safe location for later use. For security, the Private Key will not be visible again after initialization. Another security feature is the API Access List. Creating an API Access List entry ensures that API calls originate from permitted IPs. The IP Address of the user who will be using the API Key is required to use the key. Click the Add Access List Entry button. Type in the IP Address or click the Use Current IP Addressbutton and click save. Finally, click the done button on your screen's lower right-hand to finish setting up your API key. ![Click Access Manager](https://mongodb.com/docs/atlas/app-services/images/add-access-list-entry.png) click to enlarge ### Authenticate with an API Key 1 #### Authenticate a CLI User Using your newly created public and private key, log in by running the command below. ```shell\n\n \n``` You should see the following result: ```shell you have successfully logged in as <your public key> \n``` ## Options Use \"realm-cli \\[command\\] --help\" for information on a specific command\n\n ## Commands * [realm-cli accessList](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList/#std-label-realm-cli-accessList) \\- Manage allowed IP addresses and CIDR blocks\n* [realm-cli apps](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps/#std-label-realm-cli-apps) \\- Manage the App Services Apps associated with the current user (alias: app)\n* [realm-cli function](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-function/#std-label-realm-cli-function) \\- Interact with the Functions of your App (alias: functions)\n* [realm-cli login](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-login/#std-label-realm-cli-login) \\- Log the CLI into App Services using a MongoDB Cloud API key\n* [realm-cli logout](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logout/#std-label-realm-cli-logout) \\- Log the CLI out of App Services\n* [realm-cli logs](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logs/#std-label-realm-cli-logs) \\- Interact with the Logs of your App (alias: log)\n* [realm-cli pull](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-pull/#std-label-realm-cli-pull) \\- Exports the latest version of your App into your local directory (alias: export)\n* [realm-cli push](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-push/#std-label-realm-cli-push) \\- Imports and deploys changes from your local directory to your App (alias: import)\n* [realm-cli schema](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-schema/#std-label-realm-cli-schema) \\- Manage the Schemas of your App (alias: schemas)\n* [realm-cli secrets](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets/#std-label-realm-cli-secrets) \\- Manage the Secrets of your App (alias: secret)\n* [realm-cli users](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users/#std-label-realm-cli-users) \\- Manage the Users of your App (alias: user)\n* [realm-cli whoami](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-whoami/#std-label-realm-cli-whoami) \\- Display information about the current user ← [realm-cli accessList](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Develop & Deploy Apps On this page * [Overview](#overview)\n* [What is an App Services App?](#what-is-an-app-services-app-)\n* [How are Apps Deployed?](#how-are-apps-deployed-)\n* [App Administration Tools](#app-administration-tools)\n* [Automate Deployment](#automate-deployment)\n* [Deployment History](#deployment-history) ## Overview ### What is an App Services App? An App Services App is a collection of managed services that run your application's backend operations on MongoDB Atlas. You configure the App's services using declarative configuration files and write JavaScript code to implement custom behavior. An App sits between your application's frontend client and your data stored in MongoDB Atlas. Apps have built-in tools for modeling and working with data in Atlas, including role-based access permissions and document schema validation. You can use these to power services like[Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync), [Triggers](https://mongodb.com/docs/atlas/app-services/triggers/#std-label-triggers), [GraphQL](https://mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api), and the [Data API.](https://mongodb.com/docs/atlas/app-services/data-api/#std-label-data-api) To learn how to create an App, see [Create an App.](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) ### How are Apps Deployed? Apps use a \"serverless\" architecture, which means that you as the developer don't directly manage or think about the servers that run your App. Instead, you deploy your App to a one or more cloud regions around the world. Your services run on-demand on servers in that region managed by MongoDB Atlas. To learn more, see [Deployment Models & Regions.](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-model) ## App Administration Tools App Services includes several tools that you can use to create, configure, and deploy Apps. You can accomplish most administration tasks using any of these tools, so choose the tool that best suits your development workflow. The following administration tools are available: * **App Services UI**: A browser-based GUI that's available within MongoDB Atlas. You can use it to develop and manage your Apps with rich editors and forms.\n* **App Services CLI**: A command-line interface that you can access from a terminal or shell script. The CLI lets you work directly with your App's configuration files in a local environment or CI/CD pipeline.\n* **App Services Admin API**: A REST-ful API that you can access using any standard HTTPS client. You can use the Admin API to integrate App Services with automation tools like CI/CD pipelines. ## Tip Many pages in this documentation include tabs that let you choose a specific admin tool. Make sure to look out for these tabs and to choose your preferred tool. ## Automate Deployment You can use the App Services admin tools on an ad hoc basis to manually develop and deploy changes. Alternatively, you can automate the deployment process. This is particularly useful for Apps with testing and staging environments or that are developed by teams. There are two approaches to automatic deployment: * **App Services GitHub Integration**: The built-in GitHub integration lets you link your App to a GitHub repository and automatically syncs your deployed App with configuration files stored in the repo. To learn more, see [Deploy Automatically with GitHub.](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github)\n* **Custom Automation Workflows**: You can create, modify, and delete Apps in your own CI/CD pipelines using a code-first admin tool like the App Services CLI or Admin API. To learn more, see [Set Up a CI/CD Pipeline.](https://mongodb.com/docs/atlas/app-services/apps/cicd/#std-label-ci-cd-pipeline) ## Deployment History\n\n You can access the deployment history for an App from theDeployment screen in the App Services UI or by calling the[List recent deployments](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#operation/adminListDeployments) Admin API endpoint. ![The table of application deployment history logs in the App Services UI](https://mongodb.com/docs/atlas/app-services/images/deployment-history-table.png) ← [Send Trigger Events to AWS EventBridge](https://mongodb.com/docs/atlas/app-services/triggers/aws-eventbridge/ \"Previous Section\")[Create an App](https://mongodb.com/docs/atlas/app-services/apps/create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/data-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Define a Data Model On this page * [Overview](#overview)\n* [Document Schemas](#document-schemas)\n* [Relationships](#relationships)\n* [Values & Secrets](#values---secrets)\n* [Query Filters](#query-filters) ## Overview Your App's data model is a description of the data that your App uses. Your data model ensures that your data complies with a specific structure, contains only valid values, and only changes in ways that you expect. A data model consists of several components, including: * A set of declarative schemas that describe your App's data types.\n* A set of relationships that define logical connections between your schema.\n* A set of static values that you can use to define global constants, environment values, and secret values.\n* A set of rule-based query filters that you can use to dynamically limit MongoDB operations to a subset of all data for a given request. Defining your App's data model is a key part of configuring and using Device Sync. You don't need to define a data model to use other App Services. However, a data model unlocks many powerful features that can save you time and let you focus on building features instead of writing boilerplate code. For example, once you define a data model, you can: * Automatically generate a GraphQL schema with rich types, queries, and mutations for every document schema. To learn more, see [GraphQL API.](https://mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api)\n* Automatically generate syncable Realm object models in your native programming language using an App administration tool. To learn more, see [Generate SDK Object Models.](https://mongodb.com/docs/atlas/app-services/sync/data-model/generate-sdk-object-models/#std-label-generate-sdk-object-models) ## Document Schemas A document schema is a JSON object that defines the structure of a particular type of data that your App uses. Document schemas describe which fields a document has, the type of values those fields contain, and conditions that must be met for a change of value to be valid. You define schemas at the collection level. This means that you associate each schema with a particular MongoDB collection that holds the documents of that type. Schemas use a superset of the JSON schema standard that includes support for MongoDB's built-in BSON types, which allows you to fully describe your data in MongoDB. Your App enforces schemas at runtime whenever data is written to MongoDB. This includes inserts, updates, and deletes from an API service, Function, or Device Sync. To learn more, see [Schemas.](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) ## Relationships A relationship is a connection between two document schemas that lets you logically associate one document with zero or more other documents. In a relationship, a \"source\" document stores a reference to related documents, for example a list of related document `_id` values. When you use Device Sync or the GraphQL API, App Services automatically resolves the references to the related documents so you can query them directly. To learn more, see [Relationships.](https://mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-relationships) ## Values & Secrets A value is a named constant that you can access by name in various ways throughout your App. For example, you can use a value to define the base URL of an external API service and then reference the value instead of duplicating the base URL across many [Function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions)definitions. You can also define an environment value, which can change depending on your App's [environment](https://mongodb.com/docs/atlas/app-services/apps/environment/#std-label-app-environment) tag. For example, you might use a different API base URL in your development and production environments. For sensitive information like API keys, you can define a named Secret value. Secret values are never directly exposed after you define them. Instead, you reference them by name in configuration files and rule expressions. To learn more, see [Values & Secrets.](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets) ## Query Filters\n\n Filters are dynamic and can apply different conditions based on which user ran the operations or other execution information. Adding a filter to a collection allows you to contextually limit access and can improve query performance for large data sets. To learn more, see [Filter Incoming Queries.](https://mongodb.com/docs/atlas/app-services/rules/filters/#std-label-filters) ← [Internal Database Usage](https://mongodb.com/docs/atlas/app-services/mongodb/internal-database-usage/ \"Previous Section\")[Schemas](https://mongodb.com/docs/atlas/app-services/schemas/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/users/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Authenticate & Manage Users On this page * [Introduction](#introduction)\n* [Concepts](#concepts)\n* [Authentication Providers](#authentication-providers)\n* [User Accounts](#user-accounts)\n* [Authentication Provider Identities](#authentication-provider-identities)\n* [Active User](#active-user)\n* [System User](#system-user)\n* [User Sessions](#user-sessions)\n* [Summary](#summary) ## Introduction Atlas App Services manages authentication for your application's end users. App Services: * Uses role-based [data access rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) to determine read & write permissions.\n* Associates every request with an authenticated user\n* Evaluates permissions for every object included the request. Through user accounts, you can store and access metadata and custom data for each user. Users log in through [authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers). Each provider represents a specific method of authentication. App Services includes built-in providers for common use cases, such as Facebook and Google. Custom providers allow you to integrate any external authentication system. ## Concepts ### Authentication Providers In App Services, an **authentication provider** is a modular service. These services provide identity verification, and maintain information about app users. Users authenticate themselves by providing a set of credentials to an authentication provider. With valid credentials, the provider returns a unique identity associated with the user. App Services logs them in as the [active user.](#std-label-active-user) App Services includes built-in authentication providers for common use cases. This includes: * [Anonymous users](https://mongodb.com/docs/atlas/app-services/authentication/anonymous/#std-label-anonymous-authentication)\n* [Email/password combinations](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication)\n* [API keys](https://mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication)\n* OAuth 2.0 through [Facebook](https://mongodb.com/docs/atlas/app-services/authentication/facebook/#std-label-facebook-authentication), [Google](https://mongodb.com/docs/atlas/app-services/authentication/google/#std-label-google-authentication), and [Apple ID](https://mongodb.com/docs/atlas/app-services/authentication/apple/#std-label-apple-id-authentication) You can configure custom providers to integrate external authentication systems. * [Custom JWT](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication): provider accepts JSON web tokens signed by the external system.\n* [Custom Function](https://mongodb.com/docs/atlas/app-services/authentication/custom-function/#std-label-custom-function-authentication): provider allows you to define custom login logic in an Atlas Function. ## Important ### Apps Require User Authentication Every application must have at least one authentication provider configured and enabled. Without at least one provider, no client application can connect. To learn how to configure and enable authentication providers, see: [Authentication Providers.](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) ### User Accounts A **user account** represents a single, distinct user of your application. App Services creates the user when an authentication provider validates a unique identity. You can source user metadata, such as email or birthday, from authentication providers. You can associate each user with [custom data.](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ## Tip ### Apple Account Deletion Requirements\n\n ### Authentication Provider Identities App Services stores login metadata for a user in an**authentication provider identity**. App Services uses this metadata to authenticate the user. Upon first login with an authentication provider, App Services creates an identity object. Each object contains a unique ID, and[provider-specific metadata](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-user-metadata) about the user. On later logins, App Services refreshes the existing identity data. A single user account can have more than one identity. Realm SDKs enable you to link identities to existing user accounts. This allows users to log in to a single account with more than one provider. For more information, see the documentation on linking identities for your client SDK. ### Active User In the Realm SDKs, you can log in more than one user, but only one account can be **active** at any given time. The **active user** is a user account associated with an application request. App Services executes requests from client applications as the active user. App Services replaces dynamic references to the user - e.g. [%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user)in a JSON expression - with the active user. You can use a specific active user, or the system user, to execute Functions. ### System User The **system user** is an internal user that has advanced privileges. The system user bypasses all rules. You can execute [functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) as a system user instead of the user making a request. Triggers run in the context of the system user. The system user is useful for administrative tasks. This includes: * Tasks that need to circumvent rules and queries\n* Tasks that need [unrestricted access](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations-version-requirements) to MongoDB CRUD and aggregation operations ## Important ### Security Warning Rules do not apply to the system user. Functions run as the system user can become a security liability. Ensure that you do not expose these functions to unauthorized users. For example, use [function context](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-user) to check if the active user can call the system function. Define a condition to determine whether the user has the appropriate permissions, e.g.: `| exports = function() {                                                 |\n| ---------------------------------------------------------------------- |\n| const activeUser = context.user                                        |\n| const adminUserId = context.values.get(\"adminUserId\");                 |\n| if(activeUser.id == adminUserId) {                                     |\n| // The user can only execute code here if they're an admin.            |\n| } else {                                                               |\n| throw Error(\"This user is not allowed to execute the system function\") |\n| }                                                                      |\n| }                                                                      | ` ### User Sessions\n\n To learn how to create, work with, and revoke user sessions, see[Manage User Sessions.](https://mongodb.com/docs/atlas/app-services/users/sessions/#std-label-manage-user-sessions) ## Summary * App Services supports authentication and user accounts through a variety of[authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers). You can associate users with more than one authentication provider.\n* App Services supports having more than one user logged in at the same time. There is only one **active user** at a time.\n* The **system user** is a special user that bypasses all rules.\n* Realm SDKs manage the access and refresh tokens that comprise a**user session**. ← [Deployment Models & Regions](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/ \"Previous Section\")[Create an App User](https://mongodb.com/docs/atlas/app-services/users/create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/data-api/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Atlas Data API On this page * [Endpoints](#endpoints)\n* [How the Data API Works](#how-the-data-api-works)\n* [When to Use the Data API](#when-to-use-the-data-api) The Data API is a managed service that lets you securely work with data stored in Atlas using standard HTTPS requests. The Data API is not a direct connection to your database. Instead, the API is a fully-managed middleware service that sits between your cluster and the clients that send requests. You can use the Data API to connect to MongoDB Atlas from any platform that supports HTTPS, including: * Web browsers\n* Web servers\n* CI/CD pipelines\n* Serverless & Edge compute environments\n* Mobile applications\n* Internet-Of-Things devices You don't need to install any database drivers or opinionated libraries to work with the Data API. Instead, you send standard HTTPS requests like the following:\n\n ` HIDE OUTPUT `| { \"insertedId\": \"63dc56ac74ddb86ed3eb8474\" } |\n| -------------------------------------------- | ` ## Endpoints The Data API supports two types of endpoints: * **Data API Endpoints** are automatically generated endpoints that each represent a MongoDB operation. You can use the endpoints to create, read, update, delete, and aggregate documents in a MongoDB data source.  \nTo learn more, including how to set up and call endpoints, see[Data API Endpoints.](https://mongodb.com/docs/atlas/app-services/data-api/generated-endpoints/#std-label-data-api-endpoints)\n* **Custom Endpoints** are app-specific API routes handled by Atlas Functions that you write. You can use custom endpoints to define operations that fit your use case specifically. For example, you could create an endpoint that runs a pre-defined aggregation or that integrates with an external webhook service.  \nTo learn more, including how to create and call endpoints, see[Custom HTTPS Endpoints.](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-custom-endpoints) ## How the Data API Works Data API requests may resemble traditional database operations, like`find` or `insertOne`, but the Data API is not a direct connection to your database. Instead, the Data API adds additional authentication, authorization, and correctness checks to ensure that your data is only accessed or modified in the ways you allow. This allows you to safely access data in Atlas from potentially vulnerable clients like web apps. For each incoming request, the Data API: 1. **Authenticates the calling user.** This might involve validating an access token, logging in with header credentials, or directly assigning a specific runtime user based on your configuration.\n2. **Authorizes the request.** This ensures that the user sent a well-formed request and has permission to perform the requested operation based on your endpoint authorization scheme.\n3. **Runs the requested operation.** This might involve reading or writing data in Atlas with a generated endpoint or invoke a custom function that you wrote.  \nFor requests that read or write data in Atlas, the Data API also enforces the access control rules and document schemas defined in your App. This means that users can only access data they're allowed to read and write. Requests fail if they include an invalid write operation.\n4. **Returns an HTTPS response to the caller.** The response includes the result of a generated endpoint operation or any data that you return from a custom endpoint. In the request, you can choose to receive the response in either [JSON or EJSON format.](https://mongodb.com/docs/atlas/app-services/data-api/data-formats/#std-label-data-api-data-formats) ## When to Use the Data API For server applications, and especially for high-load and latency sensitive use-cases, we recommend connecting directly to Atlas with a MongoDB driver. Operations called through a Data API endpoint take longer to complete than the corresponding MongoDB operations called through a driver. Additionally, the drivers provide more flexibility and control over how your operations are executed. To learn more, visit the[MongoDB Drivers](https://www.mongodb.com/docs/drivers/) documentation. We recommend using the Data API when: * You want to run MongoDB operations from a web application or other client that you can't trust.\n* You can't or don't want to manage a MongoDB driver in your server-side environment. For example, some edge compute environments don't support database drivers or connection pooling.\n* You want to develop a new feature and prefer a flexible solution for working on the client side first before later creating and refining the API layer.\n* You want to integrate Atlas data access into a federated API gateway.\n* You want to connect to App Services from an environment not currently supported by a Realm SDK and don't want to use a driver to connect over the [wire protocol.](https://mongodb.com/docs/atlas/app-services/mongodb/wire-protocol/#std-label-wire-protocol) ← [Run GraphQL Operations from a CLI](https://mongodb.com/docs/atlas/app-services/graphql/cli/ \"Previous Section\")[Data API Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/generated-endpoints/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/introduction/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Introduction to Atlas App Services for Backend and Web Developers On this page * [What Problem Does App Services Solve?](#what-problem-does-app-services-solve-)\n* [User Authentication and Management](#user-authentication-and-management)\n* [Schema Validation and Data Access Rules](#schema-validation-and-data-access-rules)\n* [Event-Driven Serverless Functions](#event-driven-serverless-functions)\n* [Secure Client-Side Queries](#secure-client-side-queries)\n* [Synchronize Data Across Devices](#synchronize-data-across-devices)\n* [Get Started with App Services](#get-started-with-app-services)\n* [Prebuilt Applications](#prebuilt-applications)\n* [Tutorials](#tutorials)\n* [Summary](#summary) As a backend developer, you can use Atlas App Services to rapidly develop cloud-based applications. App Services Apps can react to changes in your [MongoDB Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container) data, connect that data to other systems, and scale to meet demand. App Services does this without the need to manage database and server infrastructure. As a web developer, you have to deal with lots of overhead when sending data from a server to the browser. This includes things like authentication and data validation. And then the application has to be scalable and secure. Many libraries and frameworks exist to provide these services. Selecting the best ones for your project requires deep understanding of the tradeoffs. As a mobile app developer, syncing data across devices poses challenges. You might write a lot of custom conflict resolution code yourself, or you might use a platform-specific backend like CloudKit that's not designed for developing cross-platform applications. Atlas Device Sync provides an offline-first, cross-platform solution for syncing data between a backend and mobile devices. When you combine this with App Services's authentication and data validation, you solve a host of common mobile app development issues. App Services is a serverless application backend that streamlines solving these common challenges. App Services provides configurable functions, integrated data access, and security rules. With App Services, you can focus on building unique features instead of boilerplate backend code. ## What Problem Does App Services Solve? It takes time, resources, and expertise to build, administer, and maintain backend infrastructure. However, a lot of these features are similar across applications. App Services manages the backend infrastructure and user management for you. This frees you to focus on the features that makes your app special, not boilerplate code. App Services is: Serverless: * Deploy server-side applications without having to set up and manage server infrastructure. App Services includes provisioning, deployment, operating systems, web servers, logging, backups, and redundancy.\n* Run cloud-based Atlas Functions that can crunch data or interact with Node.js modules.\n* Skip writing an authentication API on top of your App Services instance. Authenticated clients can interact with parts of the database based on their permissions. Dynamic and responsive: * React to data changes in MongoDB Atlas, process data from HTTPS endpoints, or run Atlas Functions on a schedule with Atlas Triggers.\n* Get up and running quickly for free, then scale according to the demands of your application.\n* Pay for and receive only the exact amount of compute you need at any given time with usage-based pricing. Usage under a certain amount per month is always free. Simply secure: * Let users log in with familiar authentication providers that are built into App Services.\n* Control which users may read and write data on a per-field basis with[role-based permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-roles) that you can define declaratively or with a function.\n* Enforce data integrity by defining [validation logic.](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) Synchronized: * Seamlessly sync data across devices with Atlas Device Sync .\n* Avoid writing complex synchronization logic with the [Realm Database SDKs.](https://www.mongodb.com/docs/realm/sdk/#std-label-realm-sdks) ### User Authentication and Management\n\n App Services provides built-in user management and authentication methods. These features encapsulate complexity and make it easy to integrate third-party authentication providers. You can enable authentication providers in your server-side configuration then immediately log in from any client application using a Realm SDK. To learn more about authentication in App Services, see [Authenticate & Manage Users.](https://mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication) ### Schema Validation and Data Access Rules Modern applications require that data is available using consistent types and formats. Data consistency guarantees that all the application's components can work together. It's also important to make sure that any given piece of data is only accessible to an authorized user. For example, you might grant a user access to only their own data. App Services validates data with a schema you define in the [JSON schema](https://json-schema.org/) standard. A schema serves as the source of truth for defining data types in your application. App Services also uses the schema to map data between your application and a[MongoDB Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container) collection. You can also configure App Services to secure data with role-based data access rules. These rules determine each user's access to every document for every request. A user can only insert, read, or modify data if both they and the document meet pre-defined conditions. To learn more about defining a schema and access rules for your data, see[collection rules.](https://mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) ### Event-Driven Serverless Functions Many applications require that some business logic runs on a server. Usually this logic deals with sensitive user data or interacting with external services. Apps might also need to respond in real time when something happens in the app or in an external service. App Services lets you define serverless JavaScript functions called Atlas Functions. You can use Atlas Functions for the following common backend use cases: * Call from client applications with the Realm Web SDK.\n* Execute Atlas Functions in response to trigger events, like an update to a document in MongoDB or at a scheduled time.\n* HTTPS endpoints that execute a function in response to external applications. To learn more about defining and using serverless functions, see[Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) and [Atlas Triggers.](https://mongodb.com/docs/atlas/app-services/triggers/#std-label-triggers) ### Secure Client-Side Queries Developers need efficient, secure data access. If the data is on a server, you need an API to access the data and prevent unauthorized access. The Realm SDKs provide a secure MongoDB client to interact with data in your [MongoDB data sources.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) App Services's server-side rules ensures that users only read and modify permitted documents. Rules consist of one or more user roles for each collection. A role determines if a given user has permission to access and edit a document. App Services determines a role for each document in every request. It then enforces the role's permissions before responding. #### GraphQL for MongoDB [GraphQL](https://graphql.org/) is a standard, open-source API architecture that is an alternative to REST and other HTTP APIs. It features a query language that lets you access only the data you need. App Services generates a GraphQL API for your application based on your [data model](#std-label-intro-web-schema). The API includes a set of CRUD operations that you can access with a GraphQL client or in a HTTP request. You can also create custom resolvers backed by [functions.](#std-label-intro-web-functions) To learn more about the Atlas GraphQL API, see [Atlas GraphQL API.](https://mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) #### Client-Side MongoDB Queries Traditionally developers query the database on the server and access the server from the client through a HTTP API. This requires more developer resources and lacks the flexibility of directly querying a database.\n\n The following Realm SDKs let you query Atlas with MongoDB Data Access from client apps: * [Query MongoDB - Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/#std-label-java-mongodb-data-access)\n* [Query MongoDB - .NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/app-services/mongodb-remote-access/#std-label-dotnet-mongodb-data-access)\n* [Query MongoDB - Node.js SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/query-mongodb/#std-label-node-mongodb-data-access)\n* [Query MongoDB - React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/app-services/query-mongodb/#std-label-react-native-mongodb-data-access)\n* [Query MongoDB - Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/#std-label-ios-mongodb-data-access)\n* [Query MongoDB - Web SDK](https://www.mongodb.com/docs/realm/web/mongodb/#std-label-web-mongodb-data-access) ### Synchronize Data Across Devices Synchronizing data is a hard problem for mobile app developers. Device Sync provides offline-first sync capabilities for your mobile application. Client applications use [Realm Database](https://www.mongodb.com/docs/realm/introduction/#std-label-intro-realm-database) to persist data to the local device. When the device has a network connection, Sync seamlessly sends the data to the App. The app stores the data to a linked [MongoDB Atlas data source](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources), and updates the data on other client devices. Device Sync provides [conflict resolution](https://mongodb.com/docs/atlas/app-services/sync/details/conflict-resolution/#std-label-conflict-resolution) to handle multiple users updating the same data. When combined with [user authentication and management](#std-label-intro-user-authentication) and [schema validation and data access](#std-label-intro-web-schema), Device Sync provides a secure way for your mobile clients to sync data across devices and with the cloud. ## Get Started with App Services ### Prebuilt Applications To explore a prebuilt app that you can customize, create a [template app](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps). Template applications are working apps that use App Services services to do things like: * Use Sync to synchronize data between mobile clients and the linked MongoDB Atlas collection.\n* Host a Todo web app using the [GraphQL API](https://mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api)\n* Host a Todo web app using the [Realm Web SDK](https://www.mongodb.com/docs/realm/web/#std-label-web-intro)\n* Manage event-driven [Database Triggers](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-trigger)to update views in a separate collection Template apps are working apps you can run and change to experiment with App Services. These apps are a good choice for developers who prefer to learn by experimentation, versus the tutorials, which provide a deeper, step-by-step process for building apps. ### Tutorials Check out our [tutorials](https://mongodb.com/docs/atlas/app-services/get-started/#std-label-app-services-get-started-tutorials) to learn more about how to build App Services Applications. Tutorials start with our [Template Apps](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps)and and then walk you through building additional features powered by App Services, including Device Sync and Role-based Permissions. ## Summary\n\n ← [What are the Atlas Application Services?](https://mongodb.com/docs/atlas/app-services/ \"Previous Section\")[Get Started](https://mongodb.com/docs/atlas/app-services/get-started/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/mongodb/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Connect to MongoDB Data Sources On this page * [Overview](#overview)\n* [Read, Write, and Aggregate Data](#read--write--and-aggregate-data)\n* [Secure and Validate Data](#secure-and-validate-data)\n* [Automatically Sync Data](#automatically-sync-data)\n* [React to Changing Data](#react-to-changing-data)\n* [Link a Data Source](#link-a-data-source)\n* [Navigate to the Data Source Management Screen](#navigate-to-the-data-source-management-screen)\n* [Link a New Data Source](#link-a-new-data-source)\n* [Save the Linked Data Source](#save-the-linked-data-source)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Create a Data Source Configuration Directory](#create-a-data-source-configuration-directory)\n* [Add a Data Source Configuration File](#add-a-data-source-configuration-file)\n* [Deploy the Data Source Configuration](#deploy-the-data-source-configuration)\n* [Data Source Limitations](#data-source-limitations)\n* [Atlas Data Federation](#atlas-data-federation)\n* [Serverless Instances](#serverless-instances) ## Overview A **data source** represents a [MongoDB Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container)instance in the same project as your app. You use data sources to store and retrieve your application's data. Most apps connect to a single data source, but you can configure multiple data sources if your data is spread across instances. You define a unique name for each data source linked to your application and use the name to refer to the data source throughout your app. Requests to data sources are routed through Atlas App Services. Because of this, App Services automatically opens and closes database connections. This means you don't need to worry about calling `db.close()` when using a data source. ### Read, Write, and Aggregate Data You can read and write data in a data source from a server-side function or connect from a client application. You write queries using standard MongoDB query syntax. `| exports = async function() {                           |\n| ------------------------------------------------------ |\n| const mongodb = context.services.get(\"mongodb-atlas\"); |\n| return mongodb                                         |\n| .db(\"myDatabase\")                                      |\n| .collection(\"myCollection\")                            |\n| .findOne()                                             |\n| }                                                      | ` To learn how to work with a data source in an Atlas Function, refer to the following guides:\n\n To learn how to work with a data source from a Realm SDK, refer to [Query Atlas from Client Apps.](https://mongodb.com/docs/atlas/app-services/mongodb/data-access/#std-label-client-data-access) ## Note Linked data sources do not support all MongoDB CRUD and Aggregation operations. Some operations are not available when you query MongoDB as a specific [user](https://mongodb.com/docs/atlas/app-services/users/#std-label-users-and-authentication) due to overhead from schema validation and data access rules. You can bypass some limitations by querying MongoDB as the [system user](https://mongodb.com/docs/atlas/app-services/users/#std-label-system-user) instead. For more information on which operations are supported, see[CRUD & Aggregation APIs.](https://mongodb.com/docs/atlas/app-services/mongodb/crud-and-aggregation-apis/#std-label-mongodb-crud-and-aggregation-apis) ### Secure and Validate Data Data sources allow you to define [access rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-rules) and[document schemas](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) for the data they contain. Rules dynamically authorize users to read and write subsets of your data and schemas control the shape and contents of each document. Read and write operations on a linked data source are secure by default. A user cannot read or write any data unless a rule explicitly allows them to. Any data inserted or modified by an authorized user must conform to the corresponding schema. If you do not define rules for a collection, queries on the collection will fail. This means that you can safely expose a properly configured data source interface in client applications without risking data corruption or leaks. ### Automatically Sync Data Atlas Device Sync applications store data and sync data changes to a linked cluster, called the _synced cluster_. The sync protocol ensures that your data is eventually consistent across all sync clients and the synced cluster. To learn more about Atlas Device Sync and how it interacts with your app's data sources, see [Atlas Device Sync.](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync) ## Note ### Version 4.4 Required for Sync In order to use Atlas Device Sync, your cluster must run MongoDB version 4.4 or newer. ### React to Changing Data You can create database triggers that run functions automatically in response to changing data. Triggers use MongoDB change streams to observe the data source and execute a function whenever a change event matches the trigger configuration. A trigger function can run arbitrary code and can access a change event for detailed information about the change that caused it to run. To learn more about how triggers work and how to define your own, see[Database Triggers.](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-trigger) ## Important Triggers are only available for data sources that support change streams. You cannot define triggers on a Federated database instance or serverless Atlas instance. ## Link a Data Source A configured data source in your app is _linked_ to the underlying instance in Atlas. You can link multiple instances to your app and even create multiple data sources that link to the same underlying instance. You can configure a new linked data source in the App Services UI or by defining and pushing a configuration file with Realm CLI or GitHub deployment: ## Data Source Limitations A linked data source can represent one of several instance MongoDB Atlas instance types. Depending on the type of the underlying instance, not all functionality is supported. Once you've linked a data source, you cannot change the underlying instance type. Instead, you can link a new data source with another instance type. ### Atlas Data Federation You can link a [Federated database instance](https://www.mongodb.com/atlas/data-federation?tck=docs%5Frealm) to your app as a MongoDB data source. However, there are some caveats to keep in mind when working with Atlas Data Federation:\n\n ### Serverless Instances You can link a [serverless instance](https://www.mongodb.com/cloud/atlas/serverless?tck=docs%5Frealm) to your app as a MongoDB data source. However, serverless instances do not currently support change streams, so the following features are limited: * You cannot create a [database trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-trigger) on a serverless instance.\n* You cannot use a serverless instance as your app's [Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync) cluster.\n* You cannot watch collections for changes data sources that are serverless MongoDB Atlas instances. ← [Apple ID Authentication](https://mongodb.com/docs/atlas/app-services/authentication/apple/ \"Previous Section\")[CRUD & Aggregation APIs](https://mongodb.com/docs/atlas/app-services/mongodb/crud-and-aggregation-apis/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # App Log Types App Services stores logs for the following types of events: * [Authentication Logs](https://mongodb.com/docs/atlas/app-services/logs/authentication/)\n* [Change Stream Logs](https://mongodb.com/docs/atlas/app-services/logs/changestream/)\n* [Device Sync Logs](https://mongodb.com/docs/atlas/app-services/logs/sync/)\n* [Endpoint Logs](https://mongodb.com/docs/atlas/app-services/logs/endpoint/)\n* [Function Logs](https://mongodb.com/docs/atlas/app-services/logs/function/)\n* [Schema Logs](https://mongodb.com/docs/atlas/app-services/logs/schema/)\n* [Service Logs](https://mongodb.com/docs/atlas/app-services/logs/service/)\n* [Trigger Logs](https://mongodb.com/docs/atlas/app-services/logs/trigger/) ← [Activity Feed & Atlas App Services Alerts](https://mongodb.com/docs/atlas/app-services/activity/alerts/ \"Previous Section\")[Authentication Logs](https://mongodb.com/docs/atlas/app-services/logs/authentication/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Host Files On this page * [Introduction](#introduction)\n* [Concepts](#concepts)\n* [Static Content](#static-content)\n* [Hosting Domain](#hosting-domain)\n* [Resource Paths](#resource-paths)\n* [Constraints](#constraints) ## Introduction Atlas Hosting allows you to host, manage, and serve your application's static media and document files. You can use Hosting to store individual pieces of content or to upload and serve your entire client application. To get started, [enable hosting](https://mongodb.com/docs/atlas/app-services/hosting/enable-hosting/) for your application then start [uploading content.](https://mongodb.com/docs/atlas/app-services/hosting/upload-content-to-app-services/) ## Important ### Static Hosting Requires a Paid-Tier Atlas Cluster To enable static hosting, you must have a paid-tier (i.e. `M2` or higher) Atlas cluster linked to your app as a data source. For more information on Atlas cluster tiers, see [Create a Cluster.](https://www.mongodb.com/docs/atlas/tutorial/create-new-cluster/) ## Concepts ### Static Content A file is _static_ if you can serve it directly to clients without requiring additional processing or logic to generate it. Static content includes document files, such as HTML, JavaScript, and CSS, as well as media files like images, audio, and videos. ### Hosting Domain App Services hosts your application's content behind a unique domain name. By default, App Services uses domains of the following form: `| <Your App ID>.mongodbstitch.com |\n| ------------------------------- | ` ## Note You can configure App Services to host content at a [custom domain name](https://mongodb.com/docs/atlas/app-services/hosting/use-a-custom-domain-name/) that you own in addition to the default hosting domain. ### Resource Paths A resource path is a string that uniquely identifies an uploaded file based on its position in the file tree. You can access a hosted file through a unique URL that consists of your application's hosting domain followed by the file's resource path. For example, a PNG image of a company's logo hosted in a directory named`images` would have the resource path `/images/logo.png`. You could access this image at a URL similar to the following: ``` myapp-abcde.mongodbrealm.com/images/logo.png \n``` ## Constraints App Services enforces constraints on static hosting across several dimensions for each app. The following constraints apply to all static content hosted by App Services: | Dimension                 | Constraint          |\n| ------------------------- | ------------------- |\n| **Maximum File Size**     | 25 megabytes        |\n| **Maximum Total Storage** | 1 gigabyte          |\n| **Maximum Total Files**   | 20,000 files        |\n| **Maximum CDN Flushes**   | 25 flushes per hour |\n| **Maximum Bandwidth**     | 100 gigabytes       | ← [Trigger Logs](https://mongodb.com/docs/atlas/app-services/logs/trigger/ \"Previous Section\")[Enable Hosting](https://mongodb.com/docs/atlas/app-services/hosting/enable-hosting/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Atlas Functions On this page * [Overview](#overview)\n* [Functions are Serverless](#functions-are-serverless)\n* [Functions have Context](#functions-have-context)\n* [When To Use Functions](#when-to-use-functions)\n* [How to Write a Function](#how-to-write-a-function)\n* [User and System Functions](#user-and-system-functions)\n* [Define a Function](#define-a-function)\n* [Create a New Function](#create-a-new-function)\n* [Name the New Function](#name-the-new-function)\n* [Configure User Authentication](#configure-user-authentication)\n* [Configure Function Execution Logs](#configure-function-execution-logs)\n* [Specify an Authorization Expression](#specify-an-authorization-expression)\n* [Configure the Function's Privacy Level](#configure-the-function-s-privacy-level)\n* [Write the Function Code](#write-the-function-code)\n* [Save the Function](#save-the-function)\n* [Pull Your App's Latest Configuration Files](#pull-your-app-s-latest-configuration-files)\n* [Write the Function Source Code](#write-the-function-source-code)\n* [Configure the Function](#configure-the-function)\n* [Deploy the Function](#deploy-the-function)\n* [Call a Function](#call-a-function)\n* [Call from a Function](#call-from-a-function)\n* [Call from Realm CLI](#call-from-realm-cli)\n* [Call from Rule Expressions](#call-from-rule-expressions)\n* [Call from Realm SDKs](#call-from-realm-sdks)\n* [Constraints](#constraints) ## Overview An Atlas Function is a piece of server-side JavaScript code that you write to define your app's behavior. You can call your app's functions directly from a client app or define services that integrate and call functions automatically. Functions can call other functions and include a built-in client for working with data in MongoDB Atlas clusters. They also include helpful global utilities, support common Node.js built-in modules, and can import and use external packages from the npm registry. A basic function that returns a greeting `` | exports = function(name) {             |\n| -------------------------------------- |\n| return `Hello, ${name ?? \"stranger\"}!` |\n| }                                      |  `` ### Functions are Serverless When a function is called, your app routes the request to a managed app server that evaluates your code and returns the result. This model makes functions _serverless_, which means that you don't have to deploy and manage a server to run the code. Instead, you write the function source code and your app handles the execution environment. ### Functions have Context A function runs in a context that reflects its execution environment. The context includes the user that called the function, how they called it, and the state of your app when they called it. You can use context to run user-specific code and work with other parts of your app. To learn more about how to work with function context, see [Context.](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-function-context) ### When To Use Functions Functions can run arbitrary JavaScript code that you define, which means you can use them for almost anything. Common use cases include low-latency, short-running tasks like data movement, transformations, and validation. You can also use them to connect to external services and abstract away implementation details from your client applications. In addition to functions that you invoke directly, you also write functions for various services like HTTPS Endpoints, Triggers, and GraphQL custom resolvers. These services automatically call functions to handle specific events. For example, whenever a database trigger observes a change event it calls its associated function with the change event as an argument. In the trigger function, you can then access information from the change event and respond appropriately. ## Tip\n\n * [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints)\n* [Triggers](https://mongodb.com/docs/atlas/app-services/triggers/#std-label-triggers)\n* [GraphQL Custom Resolvers](https://mongodb.com/docs/atlas/app-services/graphql/custom-resolvers/#std-label-graphql-custom-resolvers)\n* [Email/Password Registration](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) ## How to Write a Function The code for a function is essentially a named JavaScript source file, which means you can define multiple JavaScript functions in a single function file. The file must export a single JavaScript function from to serve as the entrypoint for incoming calls. When you call a function by name, you're actually calling the JavaScript function assigned to`exports` in the function's source file. For example, here's a simple function that accepts a `name` argument, adds a log message, and returns a greeting for the provided name: ```javascript exports = function Hello(name) {   console.log(`Said hello to ${name}`);   return `Hello, ${name}!`; }; \n``` You can use modern JavaScript syntax and import packages to define more complex functions: ```javascript // You can use ES6 arrow functions const uppercase = (str) => {   return str.toUpperCase(); }; // You can use async functions and await Promises exports = async function GetWeather() {   // You can get information about the user called the function   const city = context.user.custom_data.city;   // You can import Node.js built-ins and npm packages   const { URL } = require(\"url\");   const weatherUrl = new URL(\"https://example.com\");   weatherUrl.pathname = \"/weather\";   weatherUrl.search = `?location=\"${city}\"`;   // You can send HTTPS requests to external services   const weatherResponse = await context.http.get({     url: url.toString(),     headers: {       Accept: [\"application/json\"],     },   });   const { current, forecasts } = JSON.parse(weatherResponse.body.text());   return [     `Right now ${uppercase(city)} is ${current.temperature}°F and ${current.weather}.`,     `Here's the forecast for the next 7 days:`,     forecasts       .map((f) => `${f.day}: ${f.temperature}°F and ${f.weather}`)       .join(\"\\n  \"),   ].join(\"\\n\"); }; \n``` HIDE OUTPUT `| Right now NEW YORK CITY is 72°F and sunny. |\n| ------------------------------------------ |\n| Here's the forecast for the next 7 days:   |\n| Tuesday: 71°F and sunny                    |\n| Wednesday: 72°F and sunny                  |\n| Thursday: 73°F and partly cloudy           |\n| Friday: 71°F and rainy                     |\n| Saturday: 77°F and sunny                   |\n| Sunday: 76°F and sunny                     |\n| Monday: 74°F and sunny                     | ` Functions automatically serialize returned values to [Extended JSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/). This is useful to preserve type information but may not be what your application expects. For example, the values in the object returned from the following function are converted into structured EJSON values: ```javascript exports = function() {   return {     pi: 3.14159,     today: new Date(),   } } \n``` HIDE OUTPUT ``` {   \"pi\": {\n\n   },   \"today\": {     \"$date\": {       \"$numberLong\": \"1652297239913\"     }   } } \n``` To return a value as standard JSON, call `JSON.stringify()` on the value and then return the stringified result: ```javascript exports = function() {   return JSON.stringify({     pi: 3.14159,     today: new Date(),   }) } \n``` HIDE OUTPUT ``` \"{\\\"pi\\\":3.14159,\\\"today\\\":\\\"2022-05-11T19:27:32.207Z\\\"}\" \n``` ## User and System Functions A function can run in two contexts depending on how they're configured and called: * A **user function** runs in the context of a specific [user](https://mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) of your application. Typically this is the logged in user that called the function. User functions are subject to[rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-rules) and [schema validation.](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas)\n* A **system function** runs as the [system user](https://mongodb.com/docs/atlas/app-services/users/#std-label-system-user)instead of a specific application user. System functions have full access to MongoDB CRUD and Aggregation APIs and bypass all rules and schema validation. ## Note ### Dynamic context.user references References to [context.user](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-user) always resolve to the authenticated user that called a function if there was one, even if the function runs as a system function. To determine if a function is running as a system function, call [context.runningAsSystem().](https://mongodb.com/docs/atlas/app-services/functions/context/#mongodb-method-context.runningAsSystem) If a function executes without being called by an authenticated user, such as in a trigger or webhook, then dynamic references resolve to the [system user](https://mongodb.com/docs/atlas/app-services/users/#std-label-system-user) which has no `id` or other associated data. ## Define a Function You can create and manage functions in your application from the App Services UI or by importing the function configuration and source code with Realm CLI or GitHub deployment. ## Call a Function You can call a function from other functions, from a connected client application, or with Realm CLI. The examples in this section demonstrate calling a simple function named`sum` that takes two arguments, adds them, and returns the result: ```javascript // sum: adds two numbers exports = function sum(a, b) {   return a + b; }; \n``` ### Call from a Function You can call a function from another function through the[context.functions](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-functions) interface, which is available as a global variable in any function. This include HTTPS endpoints, triggers, and GraphQL customer resolvers. The called function runs in the same context as the function that called it. ```javascript // difference: subtracts b from a using the sum function exports = function difference(a, b) {   return context.functions.execute(\"sum\", a, -1 * b); }; \n``` ### Call from Realm CLI You can call a function through Realm CLI with the [function run](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-function-run/#std-label-realm-cli-function-run) command. The command returns the function result as EJSON as well as any log or error messages. ```shell realm-cli function run \\   --function=sum \\   --args=1 --args=2 \n``` By default, functions run in the [system context](#std-label-system-functions). To call a function in the context of a specific user, include their User ID in the `--user` argument. ```shell realm-cli function run \\   --function=sum \\   --args=1 --args=2 \\   --user=61a50d82532cbd0de95c7c89 \n``` ### Call from Rule Expressions\n\n ``` {   \"numGamesPlayed\": {     \"%function\": {       \"name\": \"sum\",       \"arguments\": [         \"%%root.numWins\",         \"%%root.numLosses\"       ]     }   } } \n``` ### Call from Realm SDKs ## Important Make sure to sanitize client data to protect against code injection when using Functions. You can call a function from client applications that are connected with a Realm SDK or over the wire protocol. For code examples that demonstrate how to call a function from a client application, see the documentation for the Realm SDKs: * [C++ SDK](https://www.mongodb.com/docs/realm/sdk/cpp/app-services/call-a-function/#std-label-cpp-call-a-function)\n* [Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/app-services/call-function/#std-label-flutter-call-function)\n* [Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/call-a-function/#std-label-java-call-a-function)\n* [Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/call-function/#std-label-kotlin-call-function)\n* [.NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/app-services/call-a-function/#std-label-dotnet-call-a-function)\n* [Node SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/call-a-function/#std-label-node-call-a-function)\n* [React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/app-services/call-a-function/#std-label-react-native-call-a-function)\n* [Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/app-services/call-a-function/#std-label-ios-call-a-function)\n* [Web SDK](https://www.mongodb.com/docs/realm/web/call-a-function/#std-label-web-call-a-function) ## Constraints * Functions are capped at 210 seconds of runtime per request, after which a function will time out and fail.\n* Functions may use up to 256MB of memory at any time.\n* Functions support most commonly used ES6+ features and Node.js built-in modules. However, some features that are uncommon or unsuited to serverless workloads are not supported. For more information, see[JavaScript Support.](https://mongodb.com/docs/atlas/app-services/functions/javascript-support/#std-label-js-support)\n* A function may open a maximum of 25 sockets using the [net](https://nodejs.org/docs/v10.18.1/api/net.html) built-in module.\n* Incoming requests are limited to a maximum size of 18 MB. This limit applies to the total size of all arguments passed to the function as well as any request headers or payload if the function is called through an HTTPS endpoint. ← [Data Formats](https://mongodb.com/docs/atlas/app-services/data-api/data-formats/ \"Previous Section\")[Query MongoDB Atlas](https://mongodb.com/docs/atlas/app-services/functions/mongodb/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/": " # What are the Atlas Application Services? Atlas Application Services are fully-managed backend services and APIs that help you build apps, integrate services, and connect to your Atlas data faster. Get started now by building on our [free tier.](https://mongodb.com/docs/atlas/app-services/billing/) [Start Building](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Fapp%5Fservices) ![Atlas App Services Illustration](https://mongodb.com/docs/atlas/app-services/images/plp/apis-tech.png) What You Can Do ## Build Data-Driven Apps And Services Services like Device Sync, APIs, and Triggers make it easy to build and run virtually any app or backend service on top of Atlas. Key Features ## Power Your Workload With Secure Backend Services ![Atlas Functions Icon](https://mongodb.com/docs/atlas/app-services/images/icons/atlas-functions.png) Run your application's backend logic and connect to external services with functions that automatically scale to meet demand. [Serverless JavaScript Functions](https://www.mongodb.com/docs/atlas/app-services/functions/) ![Data Access Control Icon](https://mongodb.com/docs/atlas/app-services/images/icons/data-access-control.png) Securely access data from anywhere with dynamic role-based permissions. [Role-Based Permissions](https://www.mongodb.com/docs/atlas/app-services/rules/) ![Document Schema Icon](https://mongodb.com/docs/atlas/app-services/images/icons/document-model.png) Define your application data model with standard schemas that you can use to validate data and generate language-specific classes. [Schemas and Relationships](https://www.mongodb.com/docs/atlas/app-services/schemas/) ![User Authentication Icon](https://mongodb.com/docs/atlas/app-services/images/icons/user-auth.png) Let users register and log in to your app with their preferred authentication method. [User Authentication Providers](https://www.mongodb.com/docs/atlas/app-services/authentication/) ![Value List Icon](https://mongodb.com/docs/atlas/app-services/images/icons/features-list.png) Define and access global values and private secrets from your app's functions and configuration files. [Values & Secrets](https://www.mongodb.com/docs/atlas/app-services/values-and-secrets/) ![Deployment Models Icon](https://mongodb.com/docs/atlas/app-services/images/icons/global.png) Deploy your app in any of the three major cloud providers with regions around the globe. [App Deployment Models](https://www.mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/) Additional Resources ## Join The Community And Learn From Experts ![MongoDB Community Icon](https://mongodb.com/docs/atlas/app-services/images/icons/community.png) Meet other MongoDB developers and find tutorials and examples that use your favorite tools. [MongoDB Developer Center](https://www.mongodb.com/developer/) ![Feedback Icon](https://mongodb.com/docs/atlas/app-services/images/icons/marketing-support.png) Submit and vote on feature requests for MongoDB products. [MongoDB Feedback](https://feedback.mongodb.com/) ![MongoDB Support Icon](https://mongodb.com/docs/atlas/app-services/images/icons/support.png) Get help from MongoDB's official team of support specialists. [MongoDB Support](https://support.mongodb.com/)",
  "https://www.mongodb.com/docs/atlas/app-services/values-and-secrets/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Values & Secrets On this page * [Introduction](#introduction)\n* [Concepts](#concepts)\n* [Value](#value)\n* [Secret](#secret)\n* [Environment Values](#environment-values)\n* [Summary](#summary) ## Introduction [Atlas App Services Values](#std-label-app-value) and [App Services Secrets](#std-label-app-secret) are static, server-side constants that you can access or link to from other components of your application. You can [access Values](https://mongodb.com/docs/atlas/app-services/values-and-secrets/access-a-value/) directly from [Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/) and [rule expressions](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) and link Secrets to configuration values for [authentication providers.](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) ## Concepts ### Value A **value** is a named reference to a piece of static data stored by App Services that you can access in [functions](https://mongodb.com/docs/atlas/app-services/functions/) and [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions). Values provide an alternative to hardcoding configuration constants directly into your functions and rules. In other words, values allow you to separate deployment-specific configuration data from the business logic of your app. Values can resolve to two types of data: * A _plain text_ Value resolves to a regular JSON object, array, or string that you define.\n* A _secret_ Value resolves to the value of a[Secret.](#std-label-app-secret) ### Secret A **Secret** is a private value that is stored on the App Services backend, hidden from users, and not included in exported applications. Secrets are useful for storing sensitive information such as an API key or an internal identifier. You cannot directly read the value of a Secret after defining it. Instead, you link to the Secret by name in authentication provider and service configurations. If you need to access the Secret from a Function or Rule, you can link the Secret to a[Value.](#std-label-app-value) A Secret value has a maximum character length of 500 characters. ### Environment Values An **environment value** is similar to a regular text [Value](#std-label-app-value)but can dynamically resolve to one of multiple values depending on an application-wide environment tag. You can specify different values for each of the following supported environment tags: * `\"\"`\n* `\"development\"`\n* `\"testing\"`\n* `\"qa\"`\n* `\"production\"` You can access defined environment values in functions with[context.environment.values](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-environment-values) and in rule expressions with [%%environment.](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---environment) For more information, see [Configure an App Environment.](https://mongodb.com/docs/atlas/app-services/apps/environment/#std-label-app-environment) ## Summary * App Services Values and App Services Secrets are server-side constants you can use in your app.\n* App Services Values allow you to separate deployment-specific configuration data from the business logic of your app.\n* App Services Secrets store sensitive data. You cannot export or directly read a Secret. Instead, you access a Secret indirectly via a named App Services Value. ← [Relationships](https://mongodb.com/docs/atlas/app-services/schemas/relationships/ \"Previous Section\")[Define a Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/define-a-value/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/help/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Get Help On this page * [Overview](#overview)\n* [Professional Support](#professional-support)\n* [Community Forums](#community-forums)\n* [Stack Overflow](#stack-overflow)\n* [Feature Requests](#feature-requests) ## Overview Atlas App Services provides various resources for getting help with your App. ## Professional Support MongoDB offers professional support for App Services and Atlas. Paid support includes help with training, upgrades, and general technical support for issues in your database or app. We strongly recommend MongoDB's professional support for production apps and mission-critical use cases. To learn more about professional support, see [Atlas Support & Subscriptions.](https://www.mongodb.com/cloud/atlas/pricing/support-subscriptions?tck=docs%5Frealm) To contact support, visit the [MongoDB Help Center](https://support.mongodb.com/welcome?tck=docs%5Frealm). ## Community Forums The official [MongoDB Community Forums](https://www.mongodb.com/community/forums/c/realm/9) are a great place to meet other developers, ask and answer questions, and stay up-to-date with the latest App Services features and releases. You can also interact with MongoDB employees, like our community team, engineers, and product managers, who are active forum contributors. ## Stack Overflow MongoDB monitors & answers questions with the `realm` tag on Stack Overflow, a forum to ask programming questions and get help with specific errors. [Ask an App Services- or Realm-related question](https://stackoverflow.com/questions/ask?tags=realm) or read through the [existing questions](https://stackoverflow.com/questions/tagged/realm?sort=Newest&edited=true). ## Feature Requests To request a feature, check the status of your feedback, or see top feature requests from other users, check out the [MongoDB Feedback Engine for App Services](https://feedback.mongodb.com/forums/923521-realm). ← [Atlas App Services Changelog](https://mongodb.com/docs/atlas/app-services/release-notes/backend/ \"Previous Section\")",
  "https://www.mongodb.com/docs/atlas/app-services/schemas/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Schemas On this page * [Overview](#overview)\n* [What is a Schema?](#what-is-a-schema-)\n* [Why Define a Schema?](#why-define-a-schema-)\n* [Define a Schema](#define-a-schema)\n* [How App Services Enforces Schemas](#how-app-services-enforces-schemas)\n* [App Services Schema vs Built-In Schema Validation](#app-services-schema-vs-built-in-schema-validation) ## Overview ### What is a Schema? A schema is a JSON object that defines the structure and contents of your data. You can use Atlas App Services' BSON schemas, which extend the [JSON Schema](https://json-schema.org/) standard, to define your application's data model and validate documents whenever they're created, changed, or deleted. Schemas represent _types_ of data rather than specific values. App Services supports many built-in [schema types](https://mongodb.com/docs/atlas/app-services/schemas/types/#std-label-schema-types). These include primitives, like strings and numbers, as well as structural types, like objects and arrays, which you can combine to create schemas that represent custom _object types_. For example, this is a basic schema for data about cars and some car objects that conform to the schema: ### Why Define a Schema? Schemas are the specification for your application's data model. Once you've defined a schema, App Services provides you with additional tools and services to work with data that conforms to the schema. App Services uses schemas in many application services: * [Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync) uses schemas to sync data between realms and MongoDB Atlas. App Services can also generate idiomatic SDK object models for you based on your schemas.\n* The [GraphQL API](https://mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) uses schemas to automatically generate a GraphQL schema including types, queries, and mutations. You can extend your app's API with custom resolvers that reference the types defined by your schemas.\n* [Data Access Rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-rules) validate that data conforms to your schema before and after every request. If any document fails validation, App Services prevents or rolls back the entire request. ## Define a Schema A root-level collection schema can contain additional schemas that describe the type's properties. Each root-level schema is an `object` schema that has the following form: `| {                                           |\n| ------------------------------------------- |\n| \"bsonType\": \"object\",                       |\n| \"title\": \"<Type Name>\",                     |\n| \"required\": [\"<Required Field Name>\", ...], |\n| \"properties\": {                             |\n| \"<Field Name>\": <Schema>                    |\n| }                                           |\n| }                                           | ` You can use any of the supported [schema types](https://mongodb.com/docs/atlas/app-services/schemas/types/#std-label-schema-types) to configure the object's properties:\n\n ## Note To learn how to configure and deploy a schema in your app, see[Enforce a Schema.](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) ## How App Services Enforces Schemas App Services validates all write operations (inserts, updates, and deletes) on a MongoDB collection against its collection schema. It checks every document before and after every request to ensure that all properties conform to the schema and that no invalid changes occured. App Services evaluates the result of all document writes and compares them against the schema before committing the writes to your cluster. If the result of any write operation in a request does not match the schema, App Services returns an error to the user without applying any changes in the request. ## Example A collection has the following schema: ``` {   \"title\": \"person\",   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"name\": { \"bsonType\": \"string\" }   } } \n``` A user with permission to read and write all fields wants to update the `name` field of a particular document. They issue the following query: ```javascript collection.updateOne(   { \"_id\": BSON.ObjectId(\"5ae782e48f25b9dc5c51c4d0\") },   { \"$set\": { \"name\": 42 } } ) \n``` The query attempts to set the value of `name` to the number `42`, but the schema requires the value to be a `string`. App Services will reject this write operation even though the user had permission to update the document because the write result does not conform to the schema. ## App Services Schema vs Built-In Schema Validation A schema in App Services is **not the same** as [MongoDB's built-in schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/#std-label-schema-validation-overview). Both use the JSON schema standard with additional support for BSON types. However, App Services does not use your cluster's built-in schema and may interact with your cluster in a way that is incompatible with a built-in schema. If you want to use App Services schemas _and_ your cluster's built-in schema validation at the same time, consider the following: * Set your cluster's schema validation level to \"warn\" initially. Then, monitor activity and address existing warnings. Once you're comfortable that both schema validation layers are compatible, you can upgrade the validation level to \"error\".\n* If you're using [Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync), avoid required fields for embedded documents and arrays of embedded documents. The sync protocol may break a valid embedded object write into multiple equivalent writes that do not individually include all required fields.\n* If you're using Device Sync, avoid distinguishing between`undefined`, `null`, empty arrays, and embedded objects with no fields. The sync protocol treats these values as functional equivalents. If you need help in working with both schema validation layers simultaneously, contact [MongoDB Support](https://support.mongodb.com/welcome?tck=docs%5Frealm). ← [Define a Data Model](https://mongodb.com/docs/atlas/app-services/data-model/ \"Previous Section\")[Enforce a Schema](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/billing/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Billing On this page * [Overview](#overview)\n* [Monthly Free Tier](#monthly-free-tier)\n* [Invoicing and Payment](#invoicing-and-payment)\n* [Usage Types](#usage-types)\n* [App Services Requests](#app-services-requests)\n* [App Services Compute](#app-services-compute)\n* [Atlas Device Sync](#atlas-device-sync)\n* [Data Transfer](#data-transfer)\n* [Examples](#examples)\n* [Mobile Application](#mobile-application)\n* [Web Application](#web-application)\n* [Backend Application](#backend-application) ## Overview Atlas App Services Apps are billed according to how much they're used on a monthly basis. There are four independently-measured usage types that determine how much you pay each month: * [App Services Requests](#std-label-billing-requests), which measures the number of requests that App Services sends and receives from client applications and external services. Requests include function calls, trigger executions, and sync updates, but exclude user authentication and blocked or invalid requests.\n* [App Services Compute](#std-label-billing-compute), which measures the runtime and memory usage of all requests excluding sync and authentication.\n* [Atlas Device Sync](#std-label-billing-sync), which measures the total amount of time in which a client application is actively syncing.\n* [Data Transfer](#std-label-billing-data-transfer), which measures the amount of data that App Services sends to external services and client applications. ## Note ### Track Your Usage You can track an application's usage for the current month from the application dashboard in the App Services UI. ### Monthly Free Tier All App Services Apps in a MongoDB Atlas project share a single monthly free tier. All usage below the free tier thresholds in a given month is not billed. As soon as a project exceeds any monthly free tier threshold, App Services starts billing for additional usage of any kind for that project. #### Free tier thresholds App Services is free to use below the following monthly free tier thresholds: * 1,000,000 [requests](#std-label-billing-requests) or 500 hours of[compute](#std-label-billing-compute) or 10,000 hours of [sync](#std-label-billing-sync) runtime (whichever occurs first)\n* 10GB of [data transfer](#std-label-billing-data-transfer) ### Invoicing and Payment App Services is billed as part of MongoDB Atlas. All payment methods that work with Atlas can be used to pay for App Services, including prepaid Atlas Credits. Any costs associated with a linked Atlas data source, such as database operations and backup, are billed separately from App Services. See [MongoDB Atlas Billing](https://www.mongodb.com/docs/atlas/billing/#std-label-atlas-billing) for more information. ## Usage Types ### App Services Requests App Services counts the number of requests that an application receives and handles. Requests are billed at a set rate for each request. There are several types of requests:\n\n All incoming requests count toward your monthly usage except for the following: * Requests to an authentication provider\n* Requests blocked by an application's [IP Access List](https://mongodb.com/docs/atlas/app-services/security/network/#std-label-manage-ip-access)\n* Requests to an invalid HTTP endpoint **Price:** $2.00 / 1,000,000 requests ($0.000002 / request) **Formula:** (Function Executions + Trigger Executions + GraphQL/Webhook/HTTPS Endpoint Requests + Sync Updates) \\* $0.000002 **Free Tier Threshold:** 1,000,000 [requests](#std-label-billing-requests) or 500 hours of [compute](#std-label-billing-compute) or 10,000 hours of [sync](#std-label-billing-sync) runtime (whichever occurs first) ## Example ### Estimate Your Usage Consider answering the following questions to help estimate the number of requests that your application will receive each month. **Triggers** * How many times does this trigger execute each month? **Functions/GraphQL** * How many requests do you receive each user session?\n* How many monthly active users does your app have?\n* How many sessions does an average user open each month? **Atlas Device Sync Requests** * How many write operations do users issue each session?\n* How many updates do users receive each session?\n* How many devices or active users does your app have? ### App Services Compute App Services counts the total amount of time and memory that each non-sync application request takes to process. Compute is billed at a set rate for each millisecond of runtime. For large requests, this rate is multiplied by a factor that reflects the amount of memory the request used. The memory multiplier begins at 1 (i.e. it does not affect your billing rate) and increases by 1 for every 32MB of memory that a given request uses. **Price:** $10.00 / 500 runtime hours (\\~$0.000000005 / ms) **Formula:** (# Requests) \\* (Runtime (ms)) \\* (Memory (MB) / 32MB) \\* $0.000000005 / ms **Free Tier Threshold:** 1,000,000 [requests](#std-label-billing-requests) or 500 hours of [compute](#std-label-billing-compute) or 10,000 hours of [sync](#std-label-billing-sync) runtime (whichever occurs first) ## Example ### Estimate Your Usage Consider answering the following questions to help estimate the amount of compute time that your application will use each month. **Runtime** * How many sessions does a user open each month?\n* How many requests do you receive each session?\n* How long does each request take?\n* What does each request do?\n* How many requests do you make to MongoDB Atlas or another service?\n* Does a request handle heavy data processing? **Memory Usage** * How much in-memory data does your application process for each request?\n* How many MongoDB documents does a request affect? ### Atlas Device Sync App Services counts the total amount of time in which a client application user has an active connection to the sync server even if they are not transferring data at the time. Sync is billed at a set rate for each millisecond of sync runtime per user. **Price:** $0.08 / 1,000,000 runtime minutes ($0.00000008 / min) **Formula:** (# Active Users) \\* (Sync time (min / user)) \\* ($0.00000008 / min) **Free Tier Threshold:** 1,000,000 [requests](#std-label-billing-requests) or 500 hours of [compute](#std-label-billing-compute) or 10,000 hours of [sync](#std-label-billing-sync) runtime (whichever occurs first) ## Example ### Estimate Your Usage Consider answering the following questions to help estimate the amount of sync time that your application will use each month. **Sync Sessions** * How many monthly active users does your app have?\n* How much time is an average user online each month? ### Data Transfer App Services measures the total amount of data that your application sends out to client applications and external services. Data transfer is billed at a set rate for each gigabyte of data egress. **Price:** $0.12 per GB **Formula:** (Data sent to clients/services (GB)) \\* ($0.12 / GB)\n\n ## Note ### MongoDB Atlas Data Transfer Data transfer from a linked MongoDB Atlas data source to App Services is billed as an Atlas Data Egress charge. To learn more about Atlas egress rates, read the [Data Transfer](https://www.mongodb.com/docs/atlas/billing/data-transfer-costs/)billing documentation. ## Example ### Estimate Your Usage Consider answering the following questions to help estimate the amount of data that your application will transfer each month. **Data Transfer** * How many updates/requests does an average user issues each month?\n* How much data is sent to users per update/request?\n* How often is data sent to external services?\n* How much data might be sent in each external service call? ## Examples ### Mobile Application A group messaging application uses App Services to manage permissions and sync messages between users in the same group. The app has the following usage: * There are around 2,000 active group chats in any given month.\n* The average group chat has 4 users that each send around 900 messages each month.\n* Messages are usually small but may contain up to 2KB of data.\n* The average user has the app open for about 9 hours each month. The following calculations approximate the cost of running this application for one month:\n\n ## Note ### Free Tier Usage The way that free tier usage affects your bill depends on your consumption each month. For this example, we assume that all requests and activity are spread evenly throughout the month. On every day of a 30 day month this application would handle 960,000 requests, 2,400 sync hours, and 1.44 GB of data transfer. The app would hit the requests/compute/sync threshold on the second day of the month and the data transfer threshold on the seventh day. The free tier would cover the following usage in each area: * **App Services Requests:** 1,000,000 requests\n* **Atlas Device Sync:** 2,500 hours\n* **Data Transfer:** 10 GB ### Web Application A hardware store uses a web application that allows customers to browse and order items online. The app uses Atlas Functions and the GraphQL API to fetch items based on a user's search, get detailed information for specific items, and submit orders. The app has the following usage: * There are around 100,000 visitors each month\n* An average visitor performs 2 searches, looks at 10 items, and submits an order 20% of the time.\n* Search results, item data, and order requests contain 4KB or less The following calculations approximate the cost of running this application for one month:\n\n ## Note ### Free Tier Usage The way that free tier usage affects your bill depends on your consumption each month. For this example, we assume that all requests and activity are spread evenly throughout the month. On every day of a 30 day month this application would handle 41,290 requests, 1.3 compute hours, and 16.8 GB of data transfer. The app would hit the requests/compute threshold on the 24th day of the month and the data transfer threshold on the first day. The free tier would cover the following usage in each area: * **App Services Requests:** 1,000,000 requests\n* **App Services Compute:** 7.82 hours\n* **Data Transfer:** 10 GB ### Backend Application A regional pizza chain uses App Services to handle orders for all of its restaurants. The app has the following usage: * The chain has 25 stores and each store gets about 12,000 orders each month\n* For each order, a database trigger sends the customer an email receipt. Another trigger sends text message updates to the customer when their order is received, when it's sent out for delivery, and when it's about to be delivered.\n* A scheduled trigger runs every 5 minutes to monitor delivery times. If a delivery is taking too long, it sends a text message update to the user. About 10% of all deliveries take too long.\n* Orders vary in size but are no larger than 4KB\n\n ## Note ### Free Tier Usage The way that free tier usage affects your bill depends on your consumption each month. For this example, we assume that all requests and activity are spread evenly throughout the month. On every day of a 30 day month this application would handle 41,000 requests, 3.42 compute hours, and 0.164 GB of data transfer. The app would hit the requests/compute threshold on the 25th day of the month and would not exceed the data transfer free tier threshold. The free tier would cover the following usage in each area: * **App Services Requests:** 1,000,000 requests\n* **App Services Compute:** 83.41 hours\n* **Data Transfer:** 4.92 GB ← [Realm CLI v1](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-reference-v1/ \"Previous Section\")[Service Limitations](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/anonymous/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Anonymous Authentication On this page * [Overview](#overview)\n* [Account Linking](#account-linking)\n* [Configuration](#configuration)\n* [Examples](#examples)\n* [Summary](#summary) ## Overview The Anonymous authentication provider allows users to log in to your application without providing credentials. Anonymous user objects have a unique ID value but no other metadata fields or configuration options. ## Warning An Anonymous user object is not intended to persist data. Once a user logs out, the user cannot retrieve any previous user data. Potential use cases for anonymous authentication include: * Authenticating the readers of a blog or news service.\n* Allowing end users to try the features of an application before registering for an account.\n* Simplifying the creation of users while developing and testing the client application. ## Account Linking When someone authenticates anonymously, the provider generates an anonymous user object. If the app does not explicitly log this anonymous user out, the same anonymous user is reused. The anonymous user persists until either of these things occur: * Explicit logout.\n* User deletion. Atlas App Services deletes anonymous user objects that have been inactive for 90 days. To persist data associated with an Anonymous user, you can associate that existing Anonymous identity with a user account created by a different authentication provider. ## Important ### Anonymous user expiration App Services may delete an Anonymous user object that is 90 days old (or older). When an account is deleted, it is not recoverable and any associated user data is lost. Documents created or modified by the user remain unaffected. ## Configuration ## Note The anonymous authentication provider does not have any provider-specific configuration options. ## Examples For code examples that demonstrate how to register and log in using anonymous authentication, see the documentation for the Realm SDKs: * [C++ SDK](https://www.mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-login-anonymous)\n* [Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-login-anonymous)\n* [Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-login-anonymous)\n* [Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-anonymous-login)\n* [.NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-login-anonymous)\n* [Node SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-login-anonymous)\n* [React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-login-anonymous)\n* [Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-login-anonymous)\n* [Web SDK](https://www.mongodb.com/docs/realm/web/authenticate/#std-label-web-login-anonymous) ## Summary * Anonymous authentication allows users to interact with your application creating an identity.\n* To persist data from an anonymous session after a user creates an identity with a different authentication provider, you can link the two identities. ← [Authentication Providers](https://mongodb.com/docs/atlas/app-services/authentication/ \"Previous Section\")[Email/Password Authentication](https://mongodb.com/docs/atlas/app-services/authentication/email-password/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # API Key Authentication On this page * [Overview](#overview)\n* [Enable API Key Authentication](#enable-api-key-authentication)\n* [API Key User Objects](#api-key-user-objects)\n* [Server API Keys](#server-api-keys)\n* [Create a Server API Key](#create-a-server-api-key)\n* [User API Keys](#user-api-keys)\n* [Realm SDK Examples](#realm-sdk-examples) ## Overview The API Key [authentication provider](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)allows users to log in using generated keys. App Services supports the following two types of API keys: * **Server API keys**: API keys associated with server users that is created from the App Services CLI, API or UI.\n* **User API keys**: API keys created from the Realm SDKs associated with application users. API keys do not expire automatically. ## Enable API Key Authentication To work with API key users, you must first enable the API key authentication provider. The API Key authentication provider does not have any configuration options. ## API Key User Objects Every App Services user has a unique metadata object. The object is passed to Functions called by the user and rule expressions for requests made by the user. In API key user objects, the `type` field has the value `\"server\"`. For example: `| {                                       |\n| --------------------------------------- |\n| id: \"<Unique User ID>\",                 |\n| type: \"server\",                         |\n| data: <user data object>,               |\n| custom_data: <custom user data object>, |\n| identities: <array of user identities>, |\n| }                                       | ` You can use this field to evaluate if requests come from API keys. For more information, refer to [User Objects.](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) ## Server API Keys Server API keys are generated in a server-side context using one of the App Services CLI, API or UI. When you create a server API key, you also create an associated server user. You can provide a server key to external applications and services to allow them to authenticate directly with App Services. You can associate up to 100 server API keys with an app. ### Create a Server API Key You must enable the API key provider before you can create an API key. ## Important You must copy the server key's value as soon as you create it. Once you create the API key, you can no longer retrieve it. ## User API Keys You can generate user API keys with the Realm SDKs. User API keys are generated for specific application users by the Realm SDKs in client applications. You can then use the user API to authenticate as that user. You can allow devices or services to communicate with App Services on behalf of a user by associating a unique user API key with each device. User API keys are always associated with a non-anonymous user. Each user can associate up to 20 user API keys with their account. To learn how to generate user API keys, refer to the Realm SDK documentation. ## Realm SDK Examples For code examples that demonstrate how to register and log in using API Key authentication, see the documentation for the Realm SDKs:\n\n ← [Custom Function Authentication](https://mongodb.com/docs/atlas/app-services/authentication/custom-function/ \"Previous Section\")[Facebook Authentication](https://mongodb.com/docs/atlas/app-services/authentication/facebook/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Facebook Authentication On this page * [Overview](#overview)\n* [Configuration](#configuration)\n* [Set Up a Facebook App](#set-up-a-facebook-app)\n* [Create a Facebook App](#create-a-facebook-app)\n* [Enable Facebook Login](#enable-facebook-login)\n* [Add App Services as a Valid OAuth Redirect URI](#add-app-services-as-a-valid-oauth-redirect-uri)\n* [Configure the Facebook Authentication Provider](#configure-the-facebook-authentication-provider)\n* [Examples](#examples) ## Overview The Facebook authentication provider allows users to log in with their existing Facebook account through a companion Facebook application. When a user logs in, Facebook provides Atlas App Services with an [OAuth 2.0 access token](https://www.oauth.com/oauth2-servers/access-tokens/) for the user. App Services uses the token to identify the user and access approved data from the Facebook API on their behalf. For more information on Facebook Login, see [Facebook Login for Apps](https://developers.facebook.com/docs/facebook-login/overview). ## Configuration The Facebook authentication provider has the following configuration options:\n\n ## Set Up a Facebook App The Facebook authentication provider requires a [Facebook app](https://developers.facebook.com/docs/apps) to manage authentication and user permissions. The following steps walk through creating the app, setting up Facebook Login, and configuring the provider to connect with the app. 1 ### Create a Facebook App Follow Facebook's [official guide](https://developers.facebook.com/quickstarts/) to create a new Facebook app. 2 ### Enable Facebook Login From the app's Dashboard view, find the Facebook Login card and click Set Up. You should see a list of quickstart guides for each platform. Follow the guide for your platform to enable Facebook Login. ## Note App Services web applications do not require you to install the Facebook SDK to use the Facebook authentication provider. If you are incorporating Facebook Login into a web application you can skip any steps in the quickstart related to setting up the Facebook SDK for JavaScript. 3 ### Add App Services as a Valid OAuth Redirect URI When a user completes the login flow for your Facebook app they need to be redirected back to App Services. Facebook Login will only allow users to redirect to a pre-approved list of URIs. From the Facebook Login > Settings page, add an App Services authentication callback URL that corresponds to the [deployment region](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-region) of your application to the list of Valid OAuth Redirect URIs. The following table lists the callback URL for each region: | Region                        | App Services Authentication Callback URL                                   |\n| ----------------------------- | -------------------------------------------------------------------------- |\n| **Global**                    | https://realm.mongodb.com/api/client/v2.0/auth/callback                    |\n| **Virginia**(us-east-1)       | https://us-east-1.aws.realm.mongodb.com/api/client/v2.0/auth/callback      |\n| **Oregon**(us-west-2)         | https://us-west-2.aws.realm.mongodb.com/api/client/v2.0/auth/callback      |\n| **Ireland**(eu-west-1)        | https://eu-west-1.aws.realm.mongodb.com/api/client/v2.0/auth/callback      |\n| **Frankfurt**(eu-central-1)   | https://eu-central-1.aws.realm.mongodb.com/api/client/v2.0/auth/callback   |\n| **Mumbai**(ap-south-1)        | https://ap-south-1.aws.realm.mongodb.com/api/client/v2.0/auth/callback     |\n| **Singapore**(ap-southeast-1) | https://ap-southeast-1.aws.realm.mongodb.com/api/client/v2.0/auth/callback |\n| **Sydney**(ap-southeast-2)    | https://ap-southeast-2.aws.realm.mongodb.com/api/client/v2.0/auth/callback | 4 ### Configure the Facebook Authentication Provider To connect your Facebook app to App Services, find your Facebook app'sApp ID and App Secret values on theSettings > Basic page and add them to your authentication provider [configuration.](#std-label-auth-facebook-configuration) ## Examples For code examples that demonstrate how to register and log in using Facebook authentication, see the documentation for the Realm SDKs:\n\n ← [API Key Authentication](https://mongodb.com/docs/atlas/app-services/authentication/api-key/ \"Previous Section\")[Google Authentication](https://mongodb.com/docs/atlas/app-services/authentication/google/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/google/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Google Authentication On this page * [Overview](#overview)\n* [Set Up a Project in the Google API Console](#set-up-a-project-in-the-google-api-console)\n* [Create a Project in the Google API Console](#create-a-project-in-the-google-api-console)\n* [Generate OAuth Client Credentials](#generate-oauth-client-credentials)\n* [Configure the Google Authentication Provider](#configure-the-google-authentication-provider)\n* [Configure in App Services](#configure-in-app-services)\n* [Examples](#examples) ## Overview The Google authentication provider allows users to log in with their existing Google account through [Google Sign-In](https://developers.google.com/identity/). When a user logs in, Google provides Atlas App Services with an [OAuth 2.0 access token](https://www.oauth.com/oauth2-servers/access-tokens/) for the user. App Services uses the token to identify the user and access approved data from Google APIs on their behalf. ## Set Up a Project in the Google API Console You must set up a project in the Google API Console before you [configure Google Authentication in App Services](#std-label-auth-google-configuration). Follow the SDK-specific steps to set up Google Authentication in the Google API Console. The Google authentication provider requires a [project in the Google API Console](https://cloud.google.com/) to manage authentication and user permissions. The following steps walk through creating the project, generating OAuth credentials, and configuring the provider to connect with the project. 1 ### Create a Project in the Google API Console Follow Google's [official guide](https://cloud.google.com/resource-manager/docs/creating-managing-projects) to create a new GCP project. 2 ### Generate OAuth Client Credentials Follow Google's support guide on [Setting up OAuth 2.0](https://support.google.com/cloud/answer/6158849?hl=en) for your project. 3 ### Configure the Google Authentication Provider To connect your GCP project to App Services add the OAuth 2.0Client ID and Client Secret you generated in the previous step to your authentication provider [configuration.](#std-label-auth-google-configuration) ## Configure in App Services The Google authentication provider has the following configuration options:\n\n ## Examples For code examples that demonstrate how to register and log in using Google authentication, see the documentation for the Realm SDKs: * [C++ SDK](https://www.mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-login-google)\n* [Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-login-google)\n* [Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-login-google)\n* [Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-login-google)\n* [.NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-login-google)\n* [Node SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-login-google)\n* [React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-login-google)\n* [Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-login-google)\n* [Web SDK](https://www.mongodb.com/docs/realm/web/authenticate/#std-label-web-login-google) ← [Facebook Authentication](https://mongodb.com/docs/atlas/app-services/authentication/facebook/ \"Previous Section\")[Apple ID Authentication](https://mongodb.com/docs/atlas/app-services/authentication/apple/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Email/Password Authentication On this page * [Overview](#overview)\n* [Configuration](#configuration)\n* [User Confirmation](#user-confirmation)\n* [New User Account Status](#new-user-account-status)\n* [Send a Confirmation Email](#send-a-confirmation-email)\n* [Run a Confirmation Function](#run-a-confirmation-function)\n* [Automatically Confirm Users](#automatically-confirm-users)\n* [Password Resets](#password-resets)\n* [Send a Password Reset Email](#send-a-password-reset-email)\n* [Run a Password Reset Function](#run-a-password-reset-function)\n* [Examples](#examples)\n* [Summary](#summary) ## Overview Email/password authentication lets users register and login using an email address. Atlas App Services must confirm Email/Password users before they may log in. The following diagram shows the process flow for logging in: ![Email/password login flow diagram](https://mongodb.com/docs/atlas/app-services/images/email-password-login-flow.png) ## Note User email addresses are case-sensitive. For example, a user with the email address `TestAccount@example.com` could not log in using the`testaccount@example.com` address. ## Configuration ## User Confirmation Before an email/password user can authenticate, your app must register and confirm the user's new account. Registering an email/password user creates a new user object. App Services then requires confirmation of the account. You can select one of three methods to confirm a new user account: * [Send a Confirmation Email](#std-label-auth-send-a-confirmation-email)\n* [Run a Confirmation Function](#std-label-auth-run-a-confirmation-function)\n* [Automatically Confirm Users](#std-label-auth-automatically-confirm-users) The following diagram shows the process flow for confirming a user: ![Email/password confirmation flow diagram](https://mongodb.com/docs/atlas/app-services/images/email-password-confirmation-flow.png) ### New User Account Status A user account can be in one of 2 states: Pending and Confirmed. When the confirmation process is started, Atlas App Services creates a user account and sets the status to Pending Confirmation. In this state, the user cannot login. Because the email address is now associated with a user account, any attempt to re-register the same email will fail. With the account in the pending state, the user must confirm their account before logging in. When the user confirms their account, Atlas App Services sets the status to Confirmed and the user can log in. If you are automatically confirming users, the account is created with the status set to Confirmed and the user can log on immediately after registering. ## Warning Only use automatic confirmation when you are developing and testing your app. Production applications should always use a secure confirmation process. You can view a list of pending user accounts in the UI or via the App Services APIs: ### Send a Confirmation Email With this confirmation method, users must respond to an email upon registration. The email contains a link to a confirmation URL. The user must visit this link within 30 minutes to confirm that they control the email address. Configure the following settings to have App Services automatically send a confirmation email: * Email Confirmation URL: the base of the URL included in every confirmation email. App Services appends a unique `token` and`tokenId` to this URL. These serve as query parameters to create a unique link for every confirmation. To confirm the user, first extract these query parameters from the user's unique URL. Then, pass the `token` and `tokenId`to the Client SDK's `confirmUser` function.  \nMobile applications can handle email confirmation directly in the app. To do this, configure [deep linking](https://developer.android.com/training/app-links/deep-linking.html) in Android or [universal links](https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html)in iOS.\n* Email Confirmation Subject: the subject line for the email that App Services sends. This value is optional if omitted, App Services uses a default subject line instead. Custom email confirmation subjects can contain a maximum of 256 characters. ## Note\n\n For production apps, we recommend using a confirmation function rather than the built-in confirmation email method. Confirmation functions allow you to build entirely custom email confirmations. See[Run a Confirmation Function](#std-label-auth-run-a-confirmation-function) for more information. ### Run a Confirmation Function You can Run a Confirmation Function when a new user registers. App Services passes a confirmation token, a token ID, and the user's email to the function that you create. Your function then performs the logic you need to confirm the user, and then returns one of the following result objects, which are explained in more detail below: * `{ status: 'success' }`\n* `{ status: 'fail' }`\n* `{ status: 'pending' }` Within the function, you define custom logic to confirm users. For example, your function might: * Send custom confirmation emails from a specific domain. Send these with a particular template using an external service.\n* Read user permissions from a collection in [MongoDB Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container)or an external REST service.\n* Send confirmation messages through a service other than email, such as SMS. The custom confirmation function signature has one parameter. It is an object that contains user data and confirmation tokens. These fields are: | Field    | Description                                                                                                    |\n| -------- | -------------------------------------------------------------------------------------------------------------- |\n| username | The user's email address.                                                                                      |\n| token    | A unique value used to confirm the user's identity. You use this when calling the SDK's Confirm User function. |\n| tokenId  | A unique value used to confirm the user's identity. You use this when calling the SDK's Confirm User function. | The custom user confirmation function returns an object with a status field. The following table describes the potential values of this field:\n\n The following is an example of a user confirmation function that: 1. Checks that the email provided is a valid email.\n2. Confirms that the given email address has access to a particular service.\n3. Sends an SMS message to the user.\n4. If the message is sent successfully, informs Atlas App Services to create a new account with a Pending status. `| exports = ({ token, tokenId, username }) => {                     |\n| ----------------------------------------------------------------- |\n| // Validate the username                                          |\n| const isValidEmail = myCustomValidatorService.validate(username); |\n| // Check if the user has access to this service                   |\n| const isPrivileged =                                              |\n| myCustomAuthorizationService.hasAccess(username)                  |\n| // Send a message to the user so that they can confirm themselves |\n| const msgSendSuccessful = isValidEmail && isPrivileged            |\n| && mySmsService.send(username, token, tokenId)                    |\n| if ( msgSendSuccessful ) {                                        |\n| return { status: 'pending' };                                     |\n| } else {                                                          |\n| return { status: 'fail' };                                        |\n| }                                                                 |\n| }                                                                 | ` Unless the custom function automatically confirms the user, you must provide a means for the user to complete the confirmation process after the function fires. After completing any additional confirmation steps, call the SDK's Confirm User method to finalize the user account creation on Atlas App Services. ### Automatically Confirm Users You can configure the provider toAutomatically Confirm Users. When selected, App Services immediately confirms new Email/Password users after registration. ## Warning App Services does not validate automatically confirmed email addresses. As a result, there are a few reasons you may not be able to contact such users via email: * An automatically confirmed user's email address might not actually belong to that user. (e.g. a user could sign up as`steve.jobs@apple.com`)\n* A user's email address may not even be a valid email address. (e.g. a user could sign up as `my.name@gmail` or `asdavaskljj`) Exercise caution with this option. _Securely_ resetting the password of a user account with no valid contact information can be very difficult. ## Password Resets Users can choose one of two ways to handle password resets:\n\n ### Send a Password Reset Email You can configure the provider to Send a Password Reset Email.When a user requests a password reset, App Services sends a Password Reset URL to a user's email address. The user must visit this URL within 30 minutes. When you configure password reset emails, you can configure the following settings: * Password Reset URL: the base of the URL included in every password reset email. App Services appends a unique `token` and`tokenId` to this URL. These serve as query parameters to create a unique link for every password reset. To reset the user's password, extract these query parameters from the user's unique URL. Pass the token and tokenId to the Client SDK's `resetPassword` function.\n* Reset Password Email Subject: the subject line for the email that App Services sends. This value is optional: if omitted, App Services uses a default subject line instead. Custom password reset subjects can contain a maximum of 256 characters. ## Note ### Use Deep Links in Mobile Apps Mobile applications can handle password resets directly in the app. Configure [deep linking](https://developer.android.com/training/app-links/deep-linking.html)in Android or [universal links](https://developer.apple.com/library/content/documentation/General/Conceptual/AppSearch/UniversalLinks.html)in iOS. ### Run a Password Reset Function You can configure the provider to Run a Password Reset Function. You define a [Function](https://mongodb.com/docs/atlas/app-services/functions/) for App Services to run when you `callResetPasswordFunction()` in the SDK. App Services passes this function unique confirmation tokens and data about the user. Use these values to define custom logic to reset a user's password. App Services can immediately reset the user's password. Or you can require additional confirmation from the client application. You can use a custom password reset function to define your own password reset flows: * Send custom password reset emails from a specific domain with a particular template using an external service.\n* Interface with a MongoDB Atlas collection to implement a password reset \"cooldown period\". This can prevent too many password reset attempts on a single account in a particular time range.\n* Send custom password reset messages through a service other than email. App Services can automatically run a password reset function. Configure the following settings: * Function: the function run when an instance of the client SDK calls `callResetPasswordFunction`. This function must return an object containing a `status` key. The key maps to a string with one of the following values: `success`, `pending`, or`fail`. ## Note Using a password reset function causes the client SDK `sendResetPasswordEmail()`function to return an error. The password reset function may return a `pending` status. If so, you may still need to call `resetPassword()`. The custom password reset function signature is[variadic](https://en.wikipedia.org/wiki/Variadic%5Ffunction): it accepts any number of parameters. The first is always an object containing user data and confirmation tokens. All following parameters are custom parameters. They are passed into the Client SDK as an argument collection. For instance, the Client SDK call: ```javascript callResetPasswordFunction(\"myUsername\", \"newPassword\", [\"Security Question Answer 1\", \"Security Question Answer 2\", \"securityCode:0510\"]) \n``` Becomes this customized signature for the password reset function: ```javascript resetFunc({username, password, token, tokenId}, securityAnswer1, securityAnswer2, securitySMSCode) \n``` There are multiple elements of the custom argument array. Starting with the second parameter, these elements are passed into the password reset function. In the custom password reset function, an object must be passed as the first parameter. The following table describes the fields found in said object:\n\n The custom password reset function returns an object that contains a `status` field. The value of this `status` field may be one of:\n\n A custom password reset function is generally structured as follows: ```javascript exports = ({ token, tokenId, username, password }) => {    // check if the username corresponds to a real user    const isUser = myFakeValidator.validate(username);    // check if the user has requested a password reset too often recently    const isNotCoolingDown = myFakeCooldownService.canReset(username, 'myFakeService')    // send a message to the user in some way so that the user can confirm themselves    const msgSendSuccessful = isUser && isNotCoolingDown && myFakeMsgr.send(username, token, tokenId)    if ( msgSendSuccessful ) {       return { status: 'pending' };    } else {       return { status: 'fail' };    } } \n``` ## Warning The a Realm SDK function `callResetPasswordFunction()` is **not**authenticated. Its password recovery is intended only for users who cannot otherwise log into their account. As a result, you cannot associate any call to this function with a specific App Services user. Returning a`success` status permanently changes the password to the new value in the`password` parameter of the function. So returning `success` can result in _any user_ resetting the password of _any other application user_. For security, you should send the account owner a message via a trusted mode of communication and return `pending`. ## Examples For examples of registration and log in using email/password authentication, see the Realm SDKs: * [C++ SDK](https://www.mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-login-email-password)\n* [Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-login-email-password)\n* [Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-login-email-password)\n* [Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-email-password-login)\n* [.NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-login-email-password)\n* [Node SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-login-email-password)\n* [React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-login-email-password)\n* [Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-login-email-password)\n* [Web SDK](https://www.mongodb.com/docs/realm/web/authenticate/#std-label-web-login-email-password) ## Summary * Email/password authentication allows users to create an identity in your application based on a username and a password.\n* To enable Email/password authentication, your application should support a method of email [confirmation](#std-label-email-password-authentication-confirmation), and a method of[resetting a user's password](#std-label-email-password-authentication-password-resets). There are multiple implementation options for each of these requirements. ← [Anonymous Authentication](https://mongodb.com/docs/atlas/app-services/authentication/anonymous/ \"Previous Section\")[Custom JWT Authentication](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Custom Function Authentication On this page * [Overview](#overview)\n* [When to Use Custom Function Authentication](#when-to-use-custom-function-authentication)\n* [The Authentication Function](#the-authentication-function)\n* [Receive a Custom Credential Payload](#receive-a-custom-credential-payload)\n* [Return an Authenticated User ID](#return-an-authenticated-user-id)\n* [Throw an Error for Failed Authentication](#throw-an-error-for-failed-authentication)\n* [Set Up the Custom Function Provider](#set-up-the-custom-function-provider)\n* [Enable the Custom Function Provider](#enable-the-custom-function-provider)\n* [Define the Authentication Function](#define-the-authentication-function)\n* [Deploy the Updated Application](#deploy-the-updated-application)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Define the Authentication Function](#define-the-authentication-function-1)\n* [Add a Provider Configuration File](#add-a-provider-configuration-file)\n* [Deploy the Updated Application](#deploy-the-updated-application-1)\n* [Configure Custom User Data](#configure-custom-user-data)\n* [Log In from a Realm SDK](#log-in-from-a-realm-sdk) ## Overview The **custom function** authentication provider allows you to define a custom authentication flow using a [serverless function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions). You can use this provider to implement your own user authentication logic or integrate an external authentication system. ### When to Use Custom Function Authentication Custom function authentication is the most flexible form of authentication. However, it also requires you to manually define and configure the authentication flow yourself. Before you define a custom function provider, consider if you can one use of the [built-in authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) instead. Consider using the custom function provider in your app if: * You want to use an external authentication service that does not have a built-in provider. If the service uses JSON web tokens, consider creating a [Custom JWT](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) provider instead.\n* You want to customize the authentication process beyond what's available in a built-in provider. For example, you could use a service to send customized confirmation emails instead of the default email/password provider emails. ## Important Atlas App Services does not perform any data validation or authentication checks for the custom function provider. Make sure that you validate incoming data and that your authentication system performs appropriate authentication checks, such as requiring a password, [two-factor authentication](https://en.wikipedia.org/wiki/Multi-factor%5Fauthentication), or a[single sign-on](https://en.wikipedia.org/wiki/Single%5Fsign-on) token. ## The Authentication Function The authentication function is a JavaScript function that holds your custom user authentication code. It runs whenever a user logs in through the custom function provider. The function maps data provided at login, like a username and password or an access token, to a string that uniquely identifies the user in your external authentication system. For example, you could use the provided data to log in to an external service over HTTP or using a package from npm.\n\n  `` ### Receive a Custom Credential Payload The `payload` object passed to the function contains data that was included with the custom function provider credential in the client app. The function accepts any value provided from your client app, so the actual field names and values depend on your implementation. For examples of how to create a custom credential `payload` object using the Realm SDKs, refer to the documentation for each SDK: * [C++ SDK](https://www.mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-login-custom-function)\n* [Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-login-custom-function)\n* [Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-login-custom-function)\n* [Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-login-custom-function)\n* [.NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-login-custom-function)\n* [Node.js SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-login-custom-function)\n* [React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-login-custom-function)\n* [Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-login-custom-function)\n* [Web SDK](https://www.mongodb.com/docs/realm/web/authenticate/#std-label-web-login-custom-function) ### Return an Authenticated User ID If authentication is successful, the function should return a unique string identifier for the user. For example, you could return the user ID value used by your external authentication system. This is the user's_external ID_, which the provider uses to map from your custom system to your app's internal user accounts. ## Important The user's external ID is _not_ the same as the user's internal account ID, which is exposed as the `id` field of a user object. You access the user's internal ID with `%%user.id` in expressions,`context.user.id` in functions, and the `User.id` property in the SDKs. If an existing user is already associated with the external ID, the provider logs that user in. If the provider has no record of a given external ID, it creates a new[user account](https://mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts), adds a custom function provider identity, and then logs in the new user. The identity object for the custom function provider is stored in the[user object](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) and resembles the following: ``` {   \"id\": \"<Internal User Account ID>\",   \"identities\": [      {        \"providerType\": \"custom-function\",        \"id\": \"<External User ID>\",      }   ] } \n``` ## Example The authentication function should return a unique external ID as a string: ```javascript return \"5f650356a8631da45dd4784c\" \n``` You can also return an object that contains the external ID as its`id` value: ```javascript return { \"id\": \"5f650356a8631da45dd4784c\" } \n``` If you want to define a display name for the user, define it in the`name` field of the returned object: ```javascript return {   \"id\": \"5f650356a8631da45dd4784c\",   \"name\": \"James Bond\" } \n``` ### Throw an Error for Failed Authentication\n\n ```javascript const auth = require(\"some-external-auth-system\"); try {   const user = await auth.login(payload);   return user.id; } catch (err) {   throw new Error(`Authentication failed with reason: ${err.message}`); } \n``` ## Set Up the Custom Function Provider You can configure custom function authentication using any supported deployment method. ## Configure Custom User Data You can associate [custom data](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) in a MongoDB Atlas collection with user accounts in your app. This can be helpful if you often need to access a user's data but is not required to use the custom function provider. A user's custom data document may contain any data. For apps that use the custom function provider, we recommend storing both the user's internal user account ID and their external ID. For example, you might use the following format: ``` {   \"_id\": \"<Generated ObjectId>\",   \"user_id\": \"<Internal User ID>\",   \"external_id\": \"<External User ID>\" } \n``` You can use the following approach to create custom user documents for custom function provider users: 1. Configure custom user data for a collection in your linked cluster. The User ID field stores the user's internal account ID.  \n/auth/custom\\_user\\_data.json  \n```  \n{  \n  \"mongo_service_name\": \"mongodb-atlas\",  \n  \"database_name\": \"myApp\",  \n  \"collection_name\": \"users\",  \n  \"user_id_field\": \"user_id\",  \n  \"enabled\": true  \n}  \n```\n2. Configure the custom function authentication provider and return a unique external user ID from the authentication function. App Services stores this ID in the `id` field of the user's `custom-function`identity.  \n```javascript  \nexports = async function handleCustomFunctionAuth(payload) {  \n  const auth = require(\"some-external-auth-system\");  \n  const user = await auth.login(payload);  \n  return user.id;  \n};  \n```\n3. Set up an authentication trigger that listens for `CREATE` events from the `custom-function` provider. In the trigger function, add a new document to the custom user data collection that includes both the user's internal ID and external ID.  \n```javascript  \nexports = async function onNewCustomFunctionUser({ user }) {  \n  // This is the user's internal account ID that was generated by your app  \n  const internalId = user.id;  \n  // This is the external ID returned from the authentication function  \n  const customFunctionIdentity = user.identities.find((id) => {  \n    return id.provider_type === \"custom-function\";  \n  });  \n  const externalId = customFunctionIdentity.id;  \n  // Create a custom user data document for the user  \n  const mdb = context.services.get(\"mongodb-atlas\");  \n  const users = mdb.db(\"myApp\").collection(\"users\");  \n  return await users.insertOne({  \n    // Include both the internal ID and external ID  \n    user_id: internalId,  \n    external_id: externalId,  \n    // Add any other data you want to include  \n    created_at: new Date(),  \n  });  \n};  \n``` ## Log In from a Realm SDK To log in from a client application, use a Custom Function credential that contains your login payload data. For examples, refer to the documentation for a specific SDK:\n\n ← [Custom JWT Authentication](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/ \"Previous Section\")[API Key Authentication](https://mongodb.com/docs/atlas/app-services/authentication/api-key/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/apple/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Apple ID Authentication On this page * [Overview](#overview)\n* [What You'll Need](#what-you-ll-need)\n* [Configure Apple ID Authentication](#configure-apple-id-authentication)\n* [Examples](#examples) ## Overview The Apple ID authentication provider allows users to log in with their Apple ID credentials through [Sign in with Apple](https://developer.apple.com/sign-in-with-apple/). This authentication method uses the industry-standard [OAuth 2.0](https://oauth.net/2/)authorization protocol. When a user successfully logs in through Sign in with Apple, Apple returns a credential object that includes a [JSON Web Token](https://jwt.io/introduction) that the Apple ID provider uses to authenticate the user. If the user has granted permissions to your app, the credential object may also include the user's name and email address. For additional information on how to implement Sign in with Apple, check out: * The official [Sign in with Apple documentation](https://developer.apple.com/sign-in-with-apple/)on Apple's Developer Portal\n* The [Introducing Sign In with Apple](https://developer.apple.com/videos/play/wwdc2019/706)session from WWDC 2019\n* The associated [reference application](https://developer.apple.com/documentation/authenticationservices/adding%5Fthe%5Fsign%5Fin%5Fwith%5Fapple%5Fflow%5Fto%5Fyour%5Fapp). ## Note An iOS app that uses Apple ID authentication must target iOS 13 or newer. ## What You'll Need Before you can implement Apple ID authentication you will need the following: * An active [Apple Developer Program](https://developer.apple.com/programs/) account.\n* [Xcode 11](https://developer.apple.com/xcode/) or newer. ## Configure Apple ID Authentication When using Sign-in with Apple with Atlas App Services, you can configure the Apple authentication provider for _either_ a mobile application or a web application. If you would like to use Sign in with Apple for both, you could set up your own manual Sign in with Apple flow for either the web or mobile app. Then, use the JWT that returns with the [Custom JWT authentication provider](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication). In the [Realm SDKs](https://www.mongodb.com/docs/realm/sdk/#std-label-realm-sdks), you can then link the user identities for each authentication provider to a single user. To use Sign in with Apple exclusively with either a web or a mobile application, choose your application type and follow this guide. ## Examples For code examples that demonstrate how to register and log in using Apple authentication, see the documentation for the Realm SDKs:\n\n ← [Google Authentication](https://mongodb.com/docs/atlas/app-services/authentication/google/ \"Previous Section\")[Connect to MongoDB Data Sources](https://mongodb.com/docs/atlas/app-services/mongodb/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/tutorial/flutter/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Flutter Tutorial On this page * [Learning Objectives](#learning-objectives)\n* [Prerequisites](#prerequisites)\n* [Start with the Template](#start-with-the-template)\n* [Set up the Template App](#set-up-the-template-app)\n* [Open the App](#open-the-app)\n* [Explore the App Structure](#explore-the-app-structure)\n* [Run the App](#run-the-app)\n* [Check the Backend](#check-the-backend)\n* [Modify the Application](#modify-the-application)\n* [Add a New Property](#add-a-new-property)\n* [Set the Priority when Creating and Updating Items](#set-the-priority-when-creating-and-updating-items)\n* [Run and Test](#run-and-test)\n* [Update the subscription](#update-the-subscription)\n* [Run and Test](#run-and-test-1)\n* [Update Flexible Sync on the Server](#update-flexible-sync-on-the-server)\n* [Test the changes](#test-the-changes)\n* [Conclusion](#conclusion)\n* [What's Next?](#what-s-next-) The Realm Flutter SDK allows you to create a multi-platform applications with Dart and Flutter. This tutorial is based on the Flutter Flexible Sync Template App, named `flutter.todo.flex`, which illustrates the creation of a Todo application. This application enables users to: * Register their email as a new user account.\n* Sign in to their account with their email and password (and sign out later).\n* View, create, modify, and delete task items.\n* View all tasks, even where the user is not the owner. The template app also provides a toggle that simulates the device being in \"Offline Mode.\" This toggle lets you quickly test Device Sync functionality, emulating the user having no internet connection. However, you would likely remove this toggle in a production application. This tutorial adds on to the template app. You will add a new `priority` field to the existing `Item` model and update the [Flexible Sync subscription](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields) to only show items within a range of priorities. Depending on your experience with Flutter, this tutorial should take around 30 minutes. ## Learning Objectives This tutorial illustrates how you might adapt the template app for your own needs. You would not necessarily make this change given the current structure of the template app. In this tutorial, you will learn how to: * Update a Realm object model with a non-breaking change.\n* Update a Device Sync subscription\n* Add a queryable field to the Device Sync configuration on the server to change which data is synchronized. If you prefer to get started with your own application rather than follow a guided tutorial, check out the [Flutter Quick Start](https://www.mongodb.com/docs/realm/sdk/flutter/quick-start/#std-label-flutter-quick-start). It includes copyable code examples and the essential information that you need to set up a Realm Flutter SDK application. ## Prerequisites\n\n ## Note ### Supported Platforms You can build this tutorial app on the following platforms: * iOS\n* Android\n* macOS\n* Windows\n* Linux The Realm Flutter SDK does **not** support building web applications. ## Start with the Template This tutorial is based on the Flutter Flexible Sync Template App named`flutter.todo.flex`. We start with the default app and build new features on it. To learn more about the Template Apps, see [Template Apps.](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) If you don't already have an Atlas account, [sign-up](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Ftemplate%5Fapps) to deploy a Template App. ## Set up the Template App 1 ### Open the App Open the Flutter app with your code editor. If you downloaded the client as a `.zip` file or cloned the client GitHub repository, you must manually insert the App Services App ID in the appropriate place in your client. Follow theConfiguration instructions in the client `README.md`to learn where to insert your App ID. 2 ### Explore the App Structure In your code editor, take a few minutes to explore how the project is organized. This is a standard multi-platform Flutter application that has been modified for our specific use. Specifically, the following files contain important uses of the Realm Flutter SDK: | File                           | Purpose                                                          |\n| ------------------------------ | ---------------------------------------------------------------- |\n| lib/main.dart                  | Entry point into the app. Contains routing and state management. |\n| lib/realm/schemas.dart         | Defines Realm Database schema.                                   |\n| lib/realm/schemas.g.dart       | Generated Realm object class.                                    |\n| lib/realm/app\\_services.dart   | Handles interaction with Atlas App Services.                     |\n| lib/realm/realm\\_services.dart | Handles interaction with Realm Database and Atlas Device Sync.   |\n| lib/components/                | Component parts of app featuring Flutter widgets.                |\n| lib/screens/                   | Pages of the app.                                                | 3 ### Run the App Without making any changes to the code, you should be able to run the app in either the Android emulator, iOS Simulator, physical mobile device, or desktop emulator. Attach to a device and run the Flutter application. Once the app is running, register a new user account, and then add a new Item to your todo list. ## Tip For more information on running a Flutter app with development tools, refer to the [Flutter Test Drive documentation.](https://docs.flutter.dev/get-started/test-drive) 4 ### Check the Backend Log in to [MongoDB Atlas](http://cloud.mongodb.com). In theData Services tab, click on Browse Collections. In the list of databases, find and expand the todo database, and then theItem collection. You should see the document you created in this collection. ## Modify the Application 1 ### Add a New Property\n\n To do this, follow these steps: 1. In the `flutter.todo.flex` project, open the file`lib/realm/schemas.dart`.\n2. Add the following property to the `_Item` class:  \nlib/realm/schemas.dart  \n`| late int? priority; |  \n| ------------------- |  \n`\n3. Regenerate the `Item` Realm object class:  \n```shell  \nflutter pub run realm generate  \n``` 2 ### Set the Priority when Creating and Updating Items\n\n 3 ### Run and Test Before you run the application again, perform a [hot restart](https://docs.flutter.dev/development/tools/hot-reload#special-cases). This makes sure that the sync session restarts with the new schema and prevents sync errors. Then, Log in using the account you created earlier in this tutorial. You will see the one Item you previously created. Add a new Item, and you will see that you can now set the priority. Choose `High` for the priority and save the Item. Now switch back to the Atlas data page in your browser, and refresh the`Item` collection. You should now see the new Item with the `priority`field added and set to **1**. You will also notice that the existing Item now also has a `priority` field, and it is set to **null**, as shown in the following screenshot: ![Two items in a collection](https://mongodb.com/docs/atlas/app-services/images/dotnet-tutorial-two-new-items.png) ## Note ### Why Didn't This Break Sync? Adding a property to a Realm object is not a breaking change and therefore does not require a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets). The template app has Development Mode enabled, so changes to the client Realm object are reflected in the server-side schema. For more information, see[Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) and [Update Your Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-additive-changes-synced-schema) Now that we added the priority field, we want to update the Device Sync subscription to only sync Items marked as a High or Severe priority. 1 ### Update the subscription In the `lib/realm/realm_services.dart` file, we define the Flexible Sync subscription that defines which documents we sync with the user's device and account. Currently, we are syncing all all documents where the `owner` property matches the authenticated user. The current subscription: lib/realm/realm\\_services.dart ```dart   Future<void> updateSubscriptions() async {     realm.subscriptions.update((mutableSubscriptions) {       mutableSubscriptions.clear();       if (showAll) {         mutableSubscriptions.add(realm.all<Item>(), name: queryAllName);       } else {         mutableSubscriptions.add(             realm.query<Item>(r'owner_id == $0', [currentUser?.id]),             name: queryMyItemsName);       }     });     await realm.subscriptions.waitForSynchronization();   } \n``` Now we're going to change the subscription to only sync High and Severe priority Items. As you may recall, the priority field is of type `int`, where the highest priority (\"Severe\") has a value of 0, and the lowest priority (\"Low\") has a value of 3. We can make direct comparisons between an int and the priority property. To do so, we're going to refactor the subscription query to include Items where the priority is less than or equal to`PriorityLevel.high` (or 1). We will also give the subscription the new name`\"getMyHighPriorityItemsSubscription\"`. Update the subscription to delete the old subscription and add a new one that uses priority: lib/realm/realm\\_services.dart ```dart // ... imports class RealmServices with ChangeNotifier {   static const String queryAllName = \"getAllItemsSubscription\";   static const String queryMyItemsName = \"getMyItemsSubscription\";   static const String queryMyHighPriorityItemsName =       \"getMyHighPriorityItemsSubscription\";   bool showAll = false;   bool offlineModeOn = false;   bool isWaiting = false;   late Realm realm;   User? currentUser;   App app;   RealmServices(this.app) {     if (app.currentUser != null || currentUser != app.currentUser) {\n\n       realm = Realm(Configuration.flexibleSync(currentUser!, [Item.schema]));       showAll = (realm.subscriptions.findByName(queryAllName) != null);       // Check if subscription previously exists on the realm       final subscriptionDoesNotExists =           (realm.subscriptions.findByName(queryMyHighPriorityItemsName) ==               null);       if (realm.subscriptions.isEmpty || subscriptionDoesNotExists) {         updateSubscriptions();       }     }   }   Future<void> updateSubscriptions() async {     realm.subscriptions.update((mutableSubscriptions) {       mutableSubscriptions.clear();       if (showAll) {         mutableSubscriptions.add(realm.all<Item>(), name: queryAllName);       } else {         mutableSubscriptions.add(             realm.query<Item>(               r'owner_id == $0 AND priority <= $1',               [currentUser?.id, PriorityLevel.high],             ),             name: queryMyHighPriorityItemsName);       }     });     await realm.subscriptions.waitForSynchronization();   }   // ... other methods } \n``` 2 ### Run and Test Run the application again. Log in using the account you created earlier in this tutorial. You would expect to **not** see the first Item created, since doesn't have a priority. But it is in the list. If you check your application logs in the terminal, you will see an entry that looks something like this: ```shell \"Client provided query with bad syntax: unsupported query for table \"Item\":    key \"priority\" is not a queryable field\" (error_code=300, query_version=1) \n``` This message tells us that we have added a field to our subscription without configuring Flexible Sync to use that field. 3 ### Update Flexible Sync on the Server 1. Switch back to the Atlas page in your browser. Select theAtlas App Services tab and open the app you are using.\n2. In the left-hand navigation, choose Device Sync, and then click **OK** in the dialog box about Development Mode being enabled.\n3. Scroll down to the Select Queryable Fields section. In the dropdown labeled **Select or create a queryable field**, choose \"priority\". The priority field will be added to the fields shown:  \n![Priority field is now queryable.](https://mongodb.com/docs/atlas/app-services/images/dotnet-tutorial-priority-subscribed.png)\n4. Save your changes. 4 ### Test the changes Return to your Flutter app. To ensure the subscription is re-run, log out the current user, and then log in again. After an initial moment when Realm resyncs the document collection, you_might_ see an error message resembling the following: ``` The following RangeError was thrown building StreamBuilder<RealmResultsChanges<Item>>(dirty, state: _StreamBuilderBaseState<RealmResultsChanges<Item>, AsyncSnapshot<RealmResultsChanges<Item>>>#387c4): RangeError (index): Invalid value: Only valid value is 0: 3 \n``` This error can occur with the `StreamBuilder` widget as the subscription updates. In a production app, you could add error handling. But for the sake of this tutorial, just perform a hot refresh and the error will go away. Now you should see the new Item of High priority that you created.\n\n You'll note, too, that the document you initially created is not synced, because it has a priority of `null`. If you want this Item to be synced, you can edit the document in the Atlas UI and add a value for the priority field, or you can change your subscription to include documents with null values. We will also give the subscription the new name`\"getUserItemsWithHighOrNoPriority\"`. lib/realm/realm\\_services.dart ```dart class RealmServices with ChangeNotifier {   static const String queryAllName = \"getAllItemsSubscription\";   static const String queryMyItemsName = \"getMyItemsSubscription\";   static const String queryMyHighPriorityItemsName =       \"getMyHighPriorityItemsSubscription\";   static const String queryMyHighOrNoPriorityItemsName =       \"getMyHighOrNoPriorityItemsSubscription\";   bool showAll = false;   bool offlineModeOn = false;   bool isWaiting = false;   late Realm realm;   User? currentUser;   App app;   RealmServices(this.app) {     if (app.currentUser != null || currentUser != app.currentUser) {       currentUser ??= app.currentUser;       realm = Realm(Configuration.flexibleSync(currentUser!, [Item.schema]));       // Check if subscription previously exists on the realm       final subscriptionDoesNotExists =           realm.subscriptions.findByName(queryMyHighOrNoPriorityItemsName) ==               null;       if (realm.subscriptions.isEmpty || subscriptionDoesNotExists) {         updateSubscriptions();       }     }   }   Future<void> updateSubscriptions() async {     realm.subscriptions.update((mutableSubscriptions) {       mutableSubscriptions.clear();       if (showAll) {         mutableSubscriptions.add(realm.all<Item>(), name: queryAllName);       } else {         mutableSubscriptions.add(             realm.query<Item>(               r'owner_id == $0 AND priority IN {$1, $2, $3}',               [currentUser?.id, PriorityLevel.high, PriorityLevel.severe, null],             ),             name: queryMyHighPriorityItemsName);       }     });     await realm.subscriptions.waitForSynchronization();   }   // ... other methods } \n``` Again, when a `StreamBuilder` error occurs the first time you open the app with the new subscription, perform a hot refresh to see the expected data. ## Conclusion Adding a property to an existing Realm object is a non-breaking change, and Development Mode ensures that the schema change is reflected server-side. If you add or change a subscription to use an additional field, whether newly added or previously existent, you need to modify the Flexible Sync settings to enable querying against that field. ## What's Next? * Read our [Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/#std-label-flutter-intro) documentation.\n* Find developer-oriented blog posts and integration tutorials on the[MongoDB Developer Hub.](https://developer.mongodb.com)\n* Join the [MongoDB Community forum](https://developer.mongodb.com/community/forums/c/realm/9)to learn from other MongoDB developers and technical experts. ## Note ### Share Feedback How did it go? Use the Share Feedback tab at the bottom right of the page to let us know if this tutorial was helpful or if you had any issues.\n\n",
  "https://www.mongodb.com/docs/atlas/app-services/tutorial/dotnet/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # MAUI Tutorial On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Start with the Template](#start-with-the-template)\n* [Set up the Template App](#set-up-the-template-app)\n* [Open the App](#open-the-app)\n* [Explore the App Structure](#explore-the-app-structure)\n* [Run the App](#run-the-app)\n* [Check the Backend](#check-the-backend)\n* [Modify the Application](#modify-the-application)\n* [Add the Priority Property](#add-the-priority-property)\n* [Set the Priority when Creating or Modifying an Item](#set-the-priority-when-creating-or-modifying-an-item)\n* [Update the UI Elements](#update-the-ui-elements)\n* [Run and Test](#run-and-test)\n* [Update the subscription](#update-the-subscription)\n* [Run and Test](#run-and-test-1)\n* [Update Flexible Sync on the Server](#update-flexible-sync-on-the-server)\n* [Test the changes](#test-the-changes)\n* [Conclusion](#conclusion)\n* [What's Next?](#what-s-next-) ## Overview Realm provides a .NET SDK for creating multi-platform applications in C# with MAUI. This tutorial is based on the .NET Flexible Sync Template App, named `maui.todo.flex`, which illustrates the creation of a Todo application in MAUI. This application enables users to: * Register their email as a new user account.\n* Sign in to their account with their email and password (and sign out).\n* View, create, modify, and delete tasks. In this tutorial, you will add a new `Priority` field to the existing `Item` model and update the[Flexible Sync subscription](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields) to only show items within a range of priorities. Depending on your experience with MAUI, this tutorial should take around 30 minutes. ## Note ### Check Out the Quick Start If you prefer to get started with your own application rather than follow a guided tutorial, check out the [.NET Quick Start](https://www.mongodb.com/docs/realm/sdk/dotnet/quick-start/#std-label-dotnet-client-quick-start). It includes copyable code examples and the essential information that you need to set up an Atlas App Services backend. ## Prerequisites\n\n ## Start with the Template This tutorial is based on the MAUI Flexible Sync Template App named`maui.todo.flex`. We start with the default app and build new features on it. To learn more about the Template Apps, see [Template Apps.](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) If you don't already have an Atlas account, [sign-up](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Ftemplate%5Fapps) to deploy a Template App. ## Set up the Template App 1 ### Open the App Navigate to the directory where the Realm CLI created the template app and open the `realm-todo-app.sln` solution in Visual Studio. 2 ### Explore the App Structure In Visual Studio, take a few minutes to explore how the solution is organized. This is a organized like a standard MAUI[MVVM](https://learn.microsoft.com/en-us/dotnet/maui/xaml/fundamentals/mvvm)solution, with a single project containing the views, models, and view models. The app uses a single model, `Item`, which implements `IRealmObject`. We have three views, one for logging in (`LoginPage`), another for viewing Items (`ItemsPage`), and a third for editing and creating new items. Each view has a corresponding view model. In addition to the standard MVVM structure, we have centralized all of the Realm logic into a RealmService class, which is found in the \"Services\" folder. This architecture ensures we are sharing the same realm throughout. 3 ### Run the App Without making any changes to the code, you should be able to run the app in either the Android emulator or the iOS Simulator, or on a physical device. You don't need to make any changes because, when you set up the template in the App Services UI or with the CLI, Atlas App Services also set up a new backend. If you downloaded the template app, you will need to add your App Services app's ID. To do so, open the Services/RealmService.cs file and add your ID to the `private const string appId = \"appId\";` line. Run the app, register a new user account, and then add a new Item to your todo list. 4 ### Check the Backend Log in to [Atlas App Services](http://cloud.mongodb.com). In theData Services tab, click on Browse Collections. In the list of databases, find and expand the todo database, and then theItem collection. You should see the document you created in this collection. ## Modify the Application Now that you have confirmed everything is working as expected, we can add changes. In this tutorial, we have decided that we want to add a \"Priority\" property to each Item so that we can filter Items by their priorities. The Priority property will be mapped to a PriorityLevel enum to constrain the possible values. To do this, follow these steps: 1 ### Add the Priority Property 1. In the `RealmTodo` project, expand the `Models` folder and open the `Item` class file.\n2. Add the following public property:  \n`| [MapTo(\"priority\")]                |  \n| ---------------------------------- |  \n| public int? Priority { get; set; } |  \n`  \nNote that we have set this property as nullable, which will ensure that existing Items in our database (which do not have a Priority property) will continue to be available. 2 ### Set the Priority when Creating or Modifying an Item\n\n 3 ### Update the UI Elements 1. The final task is to add the UI elements needed to set and show the priority.  \nFirst, in the `ItemsPage.xaml`, we'll add a label to the ListView that shows the priority. Within the ViewCell, add a Label to display the item's priority:  \n```csharp  \n<Label Text=\"{Binding Priority}\"  \n   HorizontalOptions=\"Center\"  \n   VerticalOptions=\"Center\"/>  \n```\n2. In the `EditItemsPage.xaml`, we will add two UI elements: a Picker that enables the user to choose which priority level to set on the new Item and a label for the picker. Find the `Entry` element for setting the Summary and add the following elements below it:  \n```csharp  \n<Label Text=\"Priority:\"/>  \n<Picker x:Name=\"newItemPriority\" SelectedIndex=\"{Binding Priority}\">  \n   <Picker.Items>  \n         <x:String>Severe</x:String>  \n         <x:String>High</x:String>  \n         <x:String>Medium</x:String>  \n         <x:String>Low</x:String>  \n   </Picker.Items>  \n</Picker>  \n``` 4 ### Run and Test At this point, you can run the application again. Log in using the account you created earlier in this tutorial. You will see the one Item you previously created. Add a new Item, and you will see that you can now set the priority. Choose `High` for the priority and save the Item. Now switch back to the Atlas data page in your browser, and refresh the`Item` collection. You should now see the new Item with the `priority`field added and set to **1**. You will also notice that the existing Item now also has a `priority` field, and it is set to **null**, as shown in the following screenshot: ![Two items in a collection](https://mongodb.com/docs/atlas/app-services/images/dotnet-tutorial-two-new-items.png) ## Note ### Why Didn't This Break Sync? Adding a property to a Realm object is not a breaking change and therefore does not require a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets). The template app has Development Mode enabled, so changes to the client Realm object are reflected in the server-side schema. For more information, see[Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) and [Update Your Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-additive-changes-synced-schema) 1 ### Update the subscription In the `RealmService.cs` file, we define two Flexible Sync subscriptions. One shows only the items created by the current user, while the other shows all items from all users. We're going to add a new subscription that shows the current user's items that have a priority of 0 or 1.\n\n 2 ### Run and Test Run the application again. If prompted to do so, log in in using the account you created earlier in this tutorial. You will see the following dialog: ![No field for priority](https://mongodb.com/docs/atlas/app-services/images/no_pri_field.png) Before reading further, consider why we are seeing this error, and how you would go about fixing it. ## Note ### Hint You will see a similar error in your Atlas App Services app logs: ```shell \"query from client: \"{\\\"Item\\\":\\\"(owner_id == \\\\\\\"...\\\\\\\" and priority < 2)\\\"}\" could not be parsed: unsupported query for table \"Item\": key \"priority\" is not a queryable field (ProtocolErrorCode=300) \n``` 3 ### Update Flexible Sync on the Server As you may have figured out, we're trying to query on a field that has not been configured in the Flexible Sync settings in your Atlas app. Let's fix that. 1. Switch back to the Atlas page in your browser. Select theAtlas App Services tab and open the app you are using.\n2. In the left-hand navigation, choose Device Sync, and then click **OK** in the dialog box about Development Mode being enabled.\n3. Scroll down to the Select Queryable Fields section. In the dropdown labeled **Select or create a queryable field**, choose \"priority\". The priority field will be added to the fields shown:  \n![Priority field is now queryable.](https://mongodb.com/docs/atlas/app-services/images/dotnet-tutorial-priority-subscribed.png)\n4. Save your changes. 4 ### Test the changes Restart the app. You should expect to see any Items you have created that have a priority of \"High\" (1) or \"Severe\" (0). If you toggle the \"Show all tasks\" switch, all tasks by all users should appear. ## Conclusion Adding a property to an existing Realm object is a non-breaking change, and Development Mode ensures that the schema change is reflected server-side. If you add or change a subscription to use an additional field, whether newly- added or previously existent, you need to modify the Flexible Sync settings to enable querying against that field. ## What's Next? * Read our [.NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/#std-label-dotnet-intro) documentation.\n* Find developer-oriented blog posts and integration tutorials on the[MongoDB Developer Hub.](https://developer.mongodb.com)\n* Join the [MongoDB Community forum](https://developer.mongodb.com/community/forums/c/realm/9)to learn from other MongoDB developers and technical experts. ## Note ### Share Feedback How did it go? Use the Share Feedback tab at the bottom right of the page to let us know if this tutorial was helpful or if you had any issues. ← [Get Started](https://mongodb.com/docs/atlas/app-services/get-started/ \"Previous Section\")[Flutter Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/flutter/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/tutorial/backend/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Write a Serverless GitHub Contribution Tracker On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Create a New App](#create-a-new-app)\n* [Welcome New GitHub Contributors](#welcome-new-github-contributors)\n* [Create an Endpoint](#create-an-endpoint)\n* [Update Your Endpoint Function's Authentication Settings](#update-your-endpoint-function-s-authentication-settings)\n* [Connect the Endpoint to a GitHub Webhook](#connect-the-endpoint-to-a-github-webhook)\n* [Get a GitHub Access Token](#get-a-github-access-token)\n* [Store the Token as a Value](#store-the-token-as-a-value)\n* [Install the GitHub API Client](#install-the-github-api-client)\n* [Write the Endpoint Logic](#write-the-endpoint-logic)\n* [Test the Endpoint](#test-the-endpoint)\n* [Generate a Weekly Community Report](#generate-a-weekly-community-report)\n* [Specify Which Repos Should Generate Reports](#specify-which-repos-should-generate-reports)\n* [Create a Function that Generates Reports](#create-a-function-that-generates-reports)\n* [Generate And Save Reports Every Week](#generate-and-save-reports-every-week)\n* [Send Report Notifications](#send-report-notifications)\n* [Test the Report Triggers](#test-the-report-triggers)\n* [What's Next?](#what-s-next-)\n* [Keep Building](#keep-building)\n* [Explore the Documentation](#explore-the-documentation)\n* [Give Us Feedback](#give-us-feedback)\n* [Join the Community](#join-the-community) ## Overview _Estimated time to complete: 30 minutes_ In this tutorial, you will use Atlas App Services to build a serverless application that monitors GitHub repositories and tracks contributions. The App Services App that you build will have several features: * Keep track of users that have contributed to your project in a MongoDB Atlas collection.\n* Leave a comment that welcomes new contributors when they open a pull request or file an issue.\n* Generate and send a weekly report that summarizes contributions to your repository. After completing this tutorial, you will know how to do the following tasks: * Write and run serverless [functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) that handle your App's logic.\n* Automate scheduled tasks and respond to changing data with [Atlas Triggers.](https://mongodb.com/docs/atlas/app-services/triggers/#std-label-triggers)\n* Store and access static data, like API keys, in [Values.](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets)\n* Connect to an external service through an API ## Prerequisites You need the following before you can begin this tutorial: * A GitHub repository. The App you build will track contributions to this repository. You can [create a new repository](https://docs.github.com/en/repositories/creating-and-managing-repositories/creating-a-new-repository)for this tutorial or use an existing repo that you have admin access to.\n* A MongoDB Atlas cluster. If you don't already have a cluster, [sign up for MongoDB Atlas and create one for free.](https://account.mongodb.com/account/register?tck=docs%5Frealm) Also note that this tutorial doesn't use the [deployment draft](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deployment-draft)workflow. A deployment draft is a collection of App changes that you can deploy or discard as a single unit. Unless you disabled deployment drafts, you may need to save your changes to a draft and then deploy them manually. ## Create a New App First, you need to create an application in App Services. To create the App:\n\n ![The app creation screen with the app name set to \"github-tracker-tutorial\".](https://mongodb.com/docs/atlas/app-services/images/github-tutorial-create-app.png) ## Welcome New GitHub Contributors We'll connect the app to your GitHub repository using a [GitHub repository webhook](https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks). Webhooks let your App know whenever some event, like a new commit or pull request, happens in your repository. Each event runs a serverless function where you can do something in response. For this tutorial, we'll use the [GitHub REST API](https://docs.github.com/en/rest) to send a welcome message to contributors whenever they open their first pull request or issue on a repository. ### Create an Endpoint Webhooks work by sending a request about the event to a URL that your App controls. In your App, you'll need to expose a custom endpoint with a unique URL to receive and handle the webhook requests. To create the endpoint: 1. In the left navigation menu, click HTTPS Endpoints.\n2. Click Add An Endpoint.\n3. Name the endpoint route `/greetNewContributors`.\n4. Leave the HTTP method set to **POST**.\n5. For authorization, choose Require a Secret.\n6. Enter a new secret name and click Create to create a new secret. Then, enter`tutorial` as the secret value. This requires all incoming requests to include the query parameter `secret=tutorial` in the request URL.\n7. Create a new [Atlas Function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) for the endpoint and name it`endpoints/greetNewContributors`.\n8. For now, set up a basic handler that only responds to incoming calls without doing other work. Copy the following code into the Function body:  \n`| exports = async function greetNewContributors(request, response) { |  \n| ------------------------------------------------------------------ |  \n| return response                                                    |  \n| .setStatusCode(200)                                                |  \n| .setBody(\"Successfully received a GitHub webhook event\")           |  \n| }                                                                  |  \n`\n9. Click Save and deploy the endpoint.\n10. Under Operation Type, copy the endpoint callback URL. You'll need it to set up the GitHub webhook later. ### Update Your Endpoint Function's Authentication Settings Now that you've created the endpoint in your App, you need to change the authentication settings for the endpoint's Function so that the GitHub webhook is accepted. To update your Function's authentication settings: 1. In the left navigation menu, click Functions.\n2. Find your endpoint Function and select it.\n3. Click Settings.\n4. Under Authentication, change the authentication method to System.\n5. Click Save to deploy the Function. ### Connect the Endpoint to a GitHub Webhook With your endpoint Function ready to go, you need to set up a webhook in your GitHub repository that sends events to the endpoint. To create the webhook in your repository:\n\n To confirm that the webhook succesfully calls your endpoint, check your [application logs](https://mongodb.com/docs/atlas/app-services/activity/#std-label-logs)in App Services for entries with the type `Endpoint`. You can get there by clicking Logsin the left navigation menu. You can also check the [webhook's request logs](https://docs.github.com/en/developers/webhooks-and-events/webhooks/testing-webhooks)in GitHub under Recent Deliveries on the webhook's settings page. Each successful request has a green checkmark next to it. ![A log entry in GitHub that shows the custom endpoint's response to a ping event. The response has a status code of 200 and the response body says \"Successfully received a GitHub webhook event\".](https://mongodb.com/docs/atlas/app-services/images/github-tutorial-successful-webhook-delivery-1.png) ### Get a GitHub Access Token The webhook is now set up to send events from GitHub to your endpoint. However, to respond to events in the endpoint with the GitHub API you'll need an access token. This tutorial uses personal access tokens, but you could also set up a GitHub app and use that token instead. To [create a personal access token:](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) 1. Open your GitHub user settings (not your repository settings) and select Developer settings in the left navigation menu.\n2. In the left navigation menu, select Personal access tokens and then click Generate new token.\n3. Configure the token with a descriptive name and a reasonable expiration time. Since this is a tutorial, consider expiring the token after 7 days.\n4. Select the `repo` scope.\n5. Click Generate token.\n6. Copy the token somewhere secure where you can access it again. GitHub will never show you the token again after this point. ### Store the Token as a Value Back in your App, add a new Value to hold the personal access token you just generated. You'll be able to reference the Value from your endpoint without hardcoding the token into your Functions. To create the Value: 1. In the left navigation menu, click Values.\n2. Click Create New Value.\n3. Name the Value `GitHubAccessToken`.\n4. Leave the type set to Value.\n5. Paste the personal access token into the Value's input. The Value must be valid JSON, so make sure you have surrounding quotation marks.\n6. Click Save. ### Install the GitHub API Client The endpoint will interact with GitHub's REST API to leave comments. You could write and send HTTP requests directly to the API using the built-in `context.http` client or an external library. However, in this tutorial we use GitHub's official Node.js library called[Octokit](https://github.com/octokit/core.js) that wraps the API. Once installed, you'll be able to import the library from any Function in your App. To add the Octokit library to your App: 1. In the left navigation menu, click Functions.\n2. Select the Dependencies tab.\n3. Click Add Dependency.\n4. Enter the package name: `@octokit/request`.\n5. Click Add.\n6. Wait for App Services to install the package. The installation should complete in a few seconds, but may take up to a minute. ### Write the Endpoint Logic Now that you have an access token and have installed Octokit, you can update the endpoint Function to actually do something when it receives events. Specifically, the Function should: * Parse the incoming webhook event\n* Log the contribution in MongoDB\n* Add a comment through the GitHub API\n* Send an informative response back to GitHub To update the Function:\n\n ### Test the Endpoint The welcome message endpoint should now be fully set up. To test that it works correctly, open a new issue or pull request on the repository. The endpoint will add a new comment to the thread the first time you do this but won't add a welcome message on subsequent attempts. ![An example of the welcome comment in GitHub added by the endpoint.](https://mongodb.com/docs/atlas/app-services/images/github-tutorial-issue-comment.png) GitHub logs repository webhook requests, so you can also check the log entry in GitHub to confirm that everything is working properly. Each request log includes a response message from the endpoint. ![A log entry in GitHub that shows the custom endpoint's response for a first-time contributor](https://mongodb.com/docs/atlas/app-services/images/github-tutorial-successful-webhook-delivery-2.png) ## Tip If you want to reset the test, delete the document with your GitHub username from `community.contributions`. This lets the App \"forget\" that you've contributed before and it will welcome you on your next contribution. ## Generate a Weekly Community Report Your App is connected to GitHub, stores information about contributions, and welcomes new contributors. Now we'll extend it to automatically analyze and generate reports for your repository. ### Specify Which Repos Should Generate Reports Your App needs a way to know which repositories it should generate reports for every week. For this tutorial, we'll hardcode the list in a Value. Create a new Value called `GitHubProjects` that contains an array of objects. Each object specifies the `owner` and `repo` name of a GitHub repository. Make sure to include an entry for your repository. values/projects.json ``` [   { \"owner\": \"<GitHub Username>\", \"repo\": \"<Repository Name>\" } ] \n``` ### Create a Function that Generates Reports A report is a document that summarizes the contributions to a repository for some time period. We'll use a Function to create on-demand reports for a repo. Create a new Function named `generateCommunityReport` and add the following code: functions/generateCommunityReport.js ```javascript exports = async function generateCommunityReport({ owner, repo, startDate }) {   // Look up issues and pull requests that had activity   const octokit = require(\"@octokit/request\");   const { data: issuesWithActivity } = await octokit.request(     \"GET /repos/{owner}/{repo}/issues\",     {       headers: {         authorization: `token ${context.values.get(\"GitHubAccessToken\")}`,       },       owner: owner,       repo: repo,       since: startDate,     }   );   // Look up users that contributed to the repo   const atlas = context.services.get(\"mongodb-atlas\");   const contributors = atlas.db(\"community\").collection(\"contributors\");   const allContributors = await contributors     .find({       contributions: {         $elemMatch: {           date: { $gt: new Date(startDate) },           owner: owner,           repo: repo,         },       },     })     .toArray();   // Keep track of users who made their first contribution   const newContributors = allContributors.filter((c) => {     new Date(c.contributions[0].date) > new Date(startDate);   });   // Return a report with the data   return {     owner,     repo,     startDate,     issuesWithActivity,     allContributors,     newContributors,   }; }; \n``` ### Generate And Save Reports Every Week The Function you just created creates a report for a repository on-demand. However, at this point nothing calls the Function and the generated reports are not saved anywhere. To actually use it, we'll create a scheduled Atla Trigger that calls the Function once every week and saves the generated reports in your linked cluster. To create the Trigger:\n\n ### Send Report Notifications Your App will now automatically generate and save reports every week. However, the reports won't be very useful if nobody sees them. We'll create a database Trigger that listens for new reports and creates a formatted message that you can send to end users. To set up the messages: 1. In the left navigation menu, click Triggers.\n2. Click Add a Trigger.\n3. Leave the Trigger type set to Database.\n4. Name the Trigger `sendCommunityReport`.\n5. Add the Trigger to the `community.reports` collection and listen for Insert events.\n6. Enable Full Document to include each new report document in the change event passed to the Trigger Function.\n7. Create a new Function for the Trigger and name it`triggers/sendCommunityReport`.\n8. Copy the following code into the Function body:  \nfunctions/triggers/sendCommunityReport.js  \n```javascript  \nexports = async function sendCommunityReport(changeEvent) {  \n  // Pull out the report document from the database change event  \n  const report = changeEvent.fullDocument;  \n    // Format values from the report to include in the message  \n  const projectName = `${report.owner}/${report.repo}`;  \n  const moment = require(\"moment\");  \n  const formattedDate = moment(report.startDate).utc().format(\"MMMM Do, YYYY\");  \n  const numIssuesWithActivity = report.issuesWithActivity.length;  \n  const numContributors = report.allContributors.length;  \n  const numNewContributors = report.newContributors.length;  \n    // Create a message string that describes the data in the report  \n  const message = [  \n    `# Community contributions to ${projectName} since ${formattedDate}`,  \n    `Last week, there was activity on ${numIssuesWithActivity} issues and pull requests.`,  \n    `We had ${numContributors} people contribute, including ${numNewContributors} first time contributors.`,  \n  ].join(\"\\n\");  \n    // For this tutorial we'll just log the message, but you could use a  \n  // service to send it as an email or push notification instead.  \n  console.log(message);  \n};  \n```\n9. Click Save and deploy the Trigger. ### Test the Report Triggers Your App is set up to automatically generate, save, and send reports every week. To make sure that everything works, you can run this report flow manually. Open the Function editor for your scheduled Trigger,`triggers/generateAndSaveCommunityReports`, and then click theRun button. This should generate and save on-demand reports for every repo that you listed in the `GitHubProjects` Value. To confirm: 1. Check `community.reports` for the new report documents.\n2. Check your App's database Trigger logs to find the formatted message for each report ## What's Next? Congratulations! You've succesfully set up a serverless GitHub contribution tracker and reached the end of this tutorial. ### Keep Building If you want to keep developing, you can try to add some new features to the tracker. For example, you could: * Update the endpoint to handle more webhook event types like[issue\\_comment](https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#issue%5Fcomment) or[pull\\_request\\_review.](https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#pull%5Frequest%5Freview)\n* Update the weekly reports to include more information from the GitHub API.\n* Connect to an external service like [Twilio](https://www.twilio.com/) or [SendGrid](https://sendgrid.com/) to actually send the report via email or SMS instead of just logging it. ### Explore the Documentation App Services includes many services that can power your App. Check out the rest of the documentation to learn more about these services and how you can use them.\n\n ### Give Us Feedback We're always working to improve our docs and tutorials. If you have a suggestion or had issues with this tutorial, click Give Feedback at the bottom of this page to rate the tutorial and send us a comment. ### Join the Community The official [MongoDB Community Forums](https://www.mongodb.com/community/forums/c/realm/9) are a great place to meet other developers, ask and answer questions, and stay up-to-date with the latest App Services features and releases. ← [SwiftUI iOS Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/swiftui/ \"Previous Section\")[Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Custom JWT Authentication On this page * [Overview](#overview)\n* [Configuration](#configuration)\n* [Audience](#audience)\n* [Verification Method](#verification-method)\n* [Metadata Fields](#metadata-fields)\n* [JSON Web Tokens](#json-web-tokens)\n* [JWT Header](#jwt-header)\n* [JWT Payload](#jwt-payload)\n* [JWT Signature](#jwt-signature)\n* [Firebase JWT Authentication](#firebase-jwt-authentication)\n* [Configure Firebase Authentication](#configure-firebase-authentication)\n* [Configure App Services JWT Authentication](#configure-app-services-jwt-authentication)\n* [Log In to App Services Using Firebase JWT with Client SDK](#log-in-to-app-services-using-firebase-jwt-with-client-sdk)\n* [Examples](#examples)\n* [Walkthrough](#walkthrough)\n* [Prerequisites](#prerequisites)\n* [Procedure](#procedure)\n* [Summary](#summary) ## Overview The Custom JWT authentication provider allows users to authenticate with an authentication system that is independent from Atlas App Services. The external system must return a signed [JSON Web Token](https://jwt.io/introduction) that contains a unique ID value for the authenticated user. App Services uses the JWT to identify your application's users and authenticate their requests but does not impose any restrictions on the external authentication system's requirements or authentication methods. For example, the system could require the user to perform two factor authentication, provide specific credentials, or otherwise identify themself. ![Diagram of Custom JWT authentication architecture.](https://mongodb.com/docs/atlas/app-services/images/custom-auth-diagram.png) ## Configuration ### Audience The Audience of a JWT specifies its intended recipient. JWTs describe their audience in the `aud` claim. By default, App Services expects`aud` to contain the App ID of the App for which the provider is configured. If the external authentication system JWT specifies a different `aud`value, then you can configure the provider to use that value instead. You can input a single audience or multiple audiences as a comma-separated list. If you add multiple audiences, a toggle appears containing the following options: * `All of these audiences`: the JWT must include every audience in the list.\n* `Any one of these audiences`: the JWT only needs to include one audience from the list. ### Verification Method The Verification Method configures how the provider determines which signing algorithm and signing keys the external authentication system must use to sign each JWT. You can either [manually specify signing keys](#std-label-custom-jwt-authentication-configuration-manually-signing-keys)or [specify a JSON Web Key URI.](#std-label-custom-jwt-authentication-configuration-jwk-uri) #### Manually Specify Signing Keys You can manually configure the signing algorithm and specify one or more signing keys that the external authentication system may use to sign JWTs.\n\n #### Use a JWK URI Some external authentication systems provide a [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) that describes the signing algorithm and signing keys the system uses to sign JWTs. You can use the JWKS to configure the provider instead of manually specifying the signing algorithm and keys. When enabled, each token must include a[kid](#mongodb-data-kid) header that specifies the Key ID of a key from the JWKS. | Field                         | Description                                                                                                                                                                                                                                                        |\n| ----------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| Use JWK URI_config.useJWKURI_ | If true, configures App Services to use a signing algorithm and signing keys defined in a JWK orJWKS. The JWKS must be accessible at a URL that you specify.                                                                                                       |\n| JWK URI_config.jwkURI_        | A URL that hosts a JWK or JWKS that describes the signing method and signing keys the JWTs should use. The JWKS may specify up to three signing keys and must use the RS256 algorithm.![The JWK URI input](https://mongodb.com/docs/atlas/app-services/images/custom-jwt-jwk-uri.png) | ### Metadata Fields Metadata Fields are additional data that describe each user. App Services determines the value of each metadata field from the value of some field included in the JWT from the external authentication system. If you set the `name` field of a user, then App Services will use that field as the user's display name. App Services refreshes a user's metadata whenever they log in and exposes the fields in the `data` object of the[user object.](https://mongodb.com/docs/atlas/app-services/users/) ## Important ### 2048 Character Limit The length of a JWT token increases with the number of metadata fields in the token and the size of each field. **App Services limits the length of a JWT token to 2048 characters.** If you exceed this limit, App Services logs an error and the ticket is not processed.\n\n ## Example An external authentication system returns JWTs that include additional information about each user in the `user_data` field: ``` {   \"aud\": \"myapp-abcde\",   \"exp\": 1516239022,   \"sub\": \"24601\",   \"user_data\": {     \"name\": \"Jean Valjean\",     \"aliases\": [       \"Monsieur Madeleine\",       \"Ultime Fauchelevent\",       \"Urbain Fabre\"     ]   } } \n``` To include the values from the `user_data` field in each user's[user object](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects), you could specify the following metadata fields: | Path               | Field Name |\n| ------------------ | ---------- |\n| user\\_data.name    | name       |\n| user\\_data.aliases | aliases    | We can now access the mapped values directly from the [user object](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects), which would resemble the following for the given JWT: ``` {   \"id\": \"59fdd02846244cdse5369ebf\",   \"type\": \"normal\",   \"data\": {     \"name\": \"Jean Valjean\",     \"aliases\": [       \"Monsieur Madeleine\",       \"Ultime Fauchelevent\",       \"Urbain Fabre\"     ]   },   identities: [     {       \"id\": \"24601\",       \"provider_type\": \"custom-token\",       \"data\": {         \"name\": \"Jean Valjean\",         \"aliases\": [           \"Monsieur Madeleine\",           \"Ultime Fauchelevent\",           \"Urbain Fabre\"         ]       },     }   ] } \n``` ## JSON Web Tokens The external authentication system must return a [JSON web token](https://jwt.io/introduction/) that uniquely identifies the authenticated user. JSON web tokens are an industry standard (see [RFC 7519](https://tools.ietf.org/html/7519)) for securely representing claims between two parties. A JWT is a string that consists of three parts: a header, a payload and a signature and has the following form: ``` <header>.<payload>.<signature> \n``` ### JWT Header The header portion of the JWT consists of a `Base64UrlEncoded`document of the following form: ```javascript {   \"alg\": \"HS256\",   \"typ\": \"JWT\",   \"kid\": \"<JWK Key ID>\" } \n```\n\n ### JWT Payload The payload portion of the JWT consists of a `Base64UrlEncoded`document of the following form: ```javascript {   \"aud\": \"<realm app id>\"   \"sub\": \"<unique user id>\",   \"exp\": <NumericDate>,   \"iat\": <NumericDate>,   \"nbf\": <NumericDate>,   ... } \n``` | Field                                                                                                | Description                                                                                                                                                                                                                  |\n| ---------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| aud[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-data-aud \"Permalink to this definition\") | Required. The audience of the token. By default, App Services expects this value to be the App ID of your App. If your external authentication service returns a different aud value, you should specify that value instead. |\n| sub[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-data-sub \"Permalink to this definition\") | Required. The subject of the token. The value should be a unique ID for the authenticated user from your custom-built authentication system.                                                                                 |\n| exp[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-data-exp \"Permalink to this definition\") | Required. The Expiration date of the token. The value should be a NumericDate number indicating the time at which the token expires.NoteApp Services will not accept expired authentication tokens.                          |\n| iat[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-data-iat \"Permalink to this definition\") | Optional. The \"issued at\" date of the token. The value should be a NumericDate number that indicates the time after which the token is considered valid. This field is functionally identical to nbf.                        |\n| nbf[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-data-nbf \"Permalink to this definition\") | Optional. The \"not before\" date of the token. The value should be a NumericDate number that indicates the time before which the token is considered invalid. This field is functionally identical to iat.                    | ## Note\n\n * The required fields listed in this section map to the `User.identities.data` property for their Custom JWT provider identity.\n* The metadata fields listed in the [Custom JWT provider configuration](#std-label-custom-jwt-authentication-configuration) map to the `User.data` property.\n* Any optional fields not listed in the provider configuration are ignored and do not map to the user object. ### JWT Signature The signature portion of the JWT is a hash of the encoded token header and payload. To form the signature, concatenate the encoded header and payload with a period and sign the result with the Signing Keyspecified in the authentication provider [configuration](#std-label-custom-jwt-authentication-configuration) using the hashing algorithm specified in the `\"alg\"` field of the header. ``` HMACSHA256(   base64UrlEncode(header) + \".\" + base64UrlEncode(payload),   signingKey ) \n``` ## Firebase JWT Authentication You can use the [Firebase Authentication](https://firebase.google.com/docs/auth) service to authenticate users into App Services Apps as well as Firebase apps. Use App Services Custom JWT authentication to access App Services with Firebase credentials. To set up Firebase Authentication as your Custom JWT provider in App Services: 1 ### Configure Firebase Authentication Follow [the official docs](https://firebase.google.com/docs/auth) to set up Firebase Authentication for your project. 2 ### Configure App Services JWT Authentication For more details, refer to the [JWT authentication configuration documentation.](#std-label-config-custom-jwt) 3 ### Log In to App Services Using Firebase JWT with Client SDK Now that you've configured App Services to work with Firebase JWTs, you can log users in using Firebase and Realm SDKs in languages supported by both. 1. Log the user into Firebase. See the relevant [Firebase SDK documentation.](https://firebase.google.com/docs/auth)\n2. Retrieve the user's Firebase JWT. See the documentation on[using a client Firebase SDK to get a user's JWT.](https://firebase.google.com/docs/auth/admin/verify-id-tokens#retrieve%5Fid%5Ftokens%5Fon%5Fclients)\n3. Pass the Firebase JWT to a Realm SDK Custom JWT authentication method. For more information how to use Realm SDKs to perform Custom JWT authentication, refer to [Custom JWT Examples.](#std-label-custom-jwt-authentication-examples) ## Examples For code examples that demonstrate how to register and log in using Custom JWT authentication, see the documentation for the Realm SDKs: ## Walkthrough In this walkthrough, you will implement [Custom JWT Authentication](#std-label-config-custom-jwt)for your App Services App. You will learn how to: * Enable JWT Authentication\n* Use a third-party JWT provider to generate a valid token\n* Authenticate against the backend from a client application ### Prerequisites You can use any App Services App for this tutorial. If you do not have a test app to use, you can [create an app](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) or use one of the [Template Apps.](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) ### Procedure This procedure is divided into three logical steps: 1. Create a JWT token\n2. Enable and configure JWT Authentication in App Services\n3. Add authentication code to your client app #### Create a JWT Token For this tutorial, we will use a third-party website, [jwt.io](https://jwt.io/), to generate a JWT token. Go to [jwt.io](https://jwt.io/). Scroll down until you see the **Encoded**and **Decoded** headers. In the **Decoded** column, you will see three sections that comprise a JWT token: **Header**, **Payload**, and**Verify Signature** areas, each of which is explained in the next sections. ##### Header The header of a JWT informs consuming applications what algorithm was used to encode the token. The default, which we will use for this tutorial, is `HS256`. ## Note\n\n ##### Payload The Payload section contains the information that we need to configure for our App Services-specific needs. By default, three fields are included: `sub`,`name`, and `iat`. We will use these three, plus two more fields. The following table explains each field and the value expected:\n\n For this tutorial, we have created a JWT for a user named \"Caleb\". The token was issued at the time of writing and will expire in exactly 1 year, and is intended to be used by an App Services with an ID of \"boiboi-cul8r\". Our completed JSON payload looks like this: ```javascript {    \"sub\": \"1234567890\",    \"name\": \"Caleb\",    \"iat\": 1617313420,    \"exp\": 1648849420,    \"aud\": \"boiboi-cul8r\" } \n``` ##### Verify Signature The final step in creating the JWT is to add a 256-bit secret with which the token is encoded. In this last section, find the field with the placeholder text of \"your-256-bit-secret\". Paste in any 256-bit string value into this field. If you are uncertain what value to use, consider visiting a random key generator website, like [keygen.io](https://keygen.io/), and copy one of the 256-bit values that has been generated. ## Important The key you use must only contain ASCII letters, numbers, underscores, and hyphens, and must be between 32 and 512 characters long. ## Note Keep track of this secret, as you will need it in the next section when we configure App Services authentication. After pasting in your key, check the `secret base64 encoded` check box. At this point, you have generated a JWT key that can be used with — and only with — the App you specified. Copy this key from theEncoded box and temporarily save it in a text document. Your JWT will be 3 sections of values, separated by periods, and looks something like the following (your token will **not** match this!): ```shell eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. ⤶ eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkNhbGViIiwiaWF0IjoxNjE3MzEzNDIwLCJle ⤶ HAiOjE2NDg4NDk0MjAsImF1ZCI6ImJvaWJvaS1jeWFsOHIifQ. ⤶ GaIE4e6mGxlIBNnz4FcheFBUmxd25GK-rfOfF6F85rY \n``` #### Enable JWT Authentication in Your App If you are not currently logged in to [App Services](https://realm.mongodb.com?tck=docs%5Frealm)do so now and navigate to the App that you specified when generating the JWT in the previous section.\n\n #### Update Your Client to Use JWT Authentication The final step in this tutorial is to update your client application to use JWT authentication. The a Realm SDKs make this process straightforward, and while each language has its own specific implementation, the pattern they each use is the same: pass the generated token to a login call. For code examples that demonstrate JWT authentication, see the documentation for the Realm SDKs: * [C++ SDK](https://www.mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-login-custom-jwt)\n* [Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/users/authenticate/#std-label-flutter-login-custom-jwt)\n* [Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-login-custom-jwt)\n* [Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-login-jwt)\n* [.NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-login-custom-jwt)\n* [Node SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-login-custom-jwt)\n* [React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-login-custom-jwt)\n* [Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-login-custom-jwt)\n* [Web SDK](https://www.mongodb.com/docs/realm/web/authenticate/#std-label-web-login-custom-jwt) ## Summary * Custom JWT authentication allows you to identify your application's users via a JSON Web Token issued outside of App Services.\n* App Services expects JWT audience values to be the App ID of the App unless otherwise configured in the application.\n* App Services can verify JWTs using either[manually specified keys and signing algorithms](#std-label-custom-jwt-authentication-configuration-manually-signing-keys) or a[JSON Web Key URI.](#std-label-custom-jwt-authentication-configuration-jwk-uri)\n* You can pass custom [user data](#std-label-custom-jwt-authentication-configuration-metadata-fields) in your JWT that App Services refreshes whenever the user refreshes their token. ← [Email/Password Authentication](https://mongodb.com/docs/atlas/app-services/authentication/email-password/ \"Previous Section\")[Custom Function Authentication](https://mongodb.com/docs/atlas/app-services/authentication/custom-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/tutorial/swiftui/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # SwiftUI iOS Tutorial On this page * [Overview](#overview)\n* [Learning Objectives](#learning-objectives)\n* [Prerequisites](#prerequisites)\n* [Start with the Template](#start-with-the-template)\n* [Explore the Template App](#explore-the-template-app)\n* [Open the App](#open-the-app)\n* [Explore the App Structure](#explore-the-app-structure)\n* [Run the App](#run-the-app)\n* [Check the Backend](#check-the-backend)\n* [Modify the Application](#modify-the-application)\n* [Add a New Property](#add-a-new-property)\n* [Add a Property to the Model](#add-a-property-to-the-model)\n* [Set the Priority when Creating a New Item](#set-the-priority-when-creating-a-new-item)\n* [Run and Test](#run-and-test)\n* [Change the Subscription](#change-the-subscription)\n* [Update the subscription](#update-the-subscription)\n* [Run and Test](#run-and-test-1)\n* [Update Flexible Sync on the Server](#update-flexible-sync-on-the-server)\n* [Test the changes](#test-the-changes)\n* [Conclusion](#conclusion)\n* [What's Next?](#what-s-next-) ## Overview Realm provides a Swift SDK that allows you to create a native iOS mobile application with Swift or Objective-C. This tutorial is based on the SwiftUI Flexible Sync Template App, named `swiftui.todo.flex`, which illustrates the creation of a to-do list application. This application enables users to: * Register their email as a new user account.\n* Sign in to their account with their email and password (and sign out later).\n* View, create, modify, and delete their own tasks.\n* View all tasks, even where the user is not the owner. The template app also provides a toggle that simulates the device being in \"Offline Mode.\" This toggle lets you quickly test Device Sync functionality on the simulator, emulating the user having no internet connection. However, you would likely remove this toggle in a production application. This tutorial builds on the Template App. You will add a new `priority` field to the existing `Item` model and update the[Flexible Sync subscription](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields) to only show items within a range of priorities. Depending on your experience with SwiftUI, this tutorial should take around 30 minutes. ## Learning Objectives This tutorial illustrates how you might adapt the template app for your own needs. You would not necessarily make this change given the current structure of the template app. In this tutorial, you will learn how to: * Update a Realm object model with a non-breaking change.\n* Update a Device Sync subscription.\n* Add a queryable field to the Device Sync configuration on the server to change which data is synchronized. ## Tip If you prefer to get started with your own application rather than follow a guided tutorial, check out the [Swift Quick Start](https://www.mongodb.com/docs/realm/sdk/swift/quick-start/#std-label-ios-client-quick-start-with-sync). It includes copyable code examples and the essential information that you need to set up an Atlas App Services backend. For a SwiftUI-specific get started experience, refer to the [Realm Database with SwiftUI QuickStart.](https://www.mongodb.com/docs/realm/sdk/swift/swiftui-tutorial/#std-label-ios-swiftui-quick-start) ## Prerequisites\n\n ## Start with the Template This tutorial is based on the SwiftUI Flexible Sync Template App named`swiftui.todo.flex`. We start with the default app and build new features on it. To learn more about the Template Apps, see [Template Apps.](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) If you don't already have an Atlas account, [sign-up](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Ftemplate%5Fapps) to deploy a Template App. ## Explore the Template App 1 ### Open the App Open the frontend client's `App.xcodeproj` in Xcode. If you downloaded the client as a `.zip` file or cloned the client GitHub repository, you must manually insert the App Services App ID in the appropriate place in your client. Follow theConfiguration instructions in the client `README.md`to learn where to insert your App ID. 2 ### Explore the App Structure Take a few minutes to explore how the project is organized while Swift Package Manager downloads the latest version of the Realm Swift SDK. Within the App directory, you can see a few files worth noting:\n\n In this tutorial, you'll be working in the following files: | File                 | Purpose                                                                                              |\n| -------------------- | ---------------------------------------------------------------------------------------------------- |\n| Item.Swift           | This file, located at the root of the project, defines the Realm object we store in the database.    |\n| CreateItemView.swift | This file, located in the Views directory, provides the functionality to add a new item to the list. |\n| ContentView.Swift    | This file, located in the Views directory, defines the Flexible Sync subscription.                   | 3 ### Run the App Without making any changes to the code, you should be able to run the app in the iOS Simulator or on a physical device. Run the app, register a new user account, and then add a new Item to your todo list. 4 ### Check the Backend Log in to [Atlas App Services](http://cloud.mongodb.com). In theData Services tab, click on Browse Collections. In the list of databases, find and expand the todo database, and then theItem collection. You should see the document you created in this collection. ## Modify the Application ### Add a New Property 1 #### Add a Property to the Model Now that you have confirmed everything is working as expected, we can add changes. In this tutorial, we have decided that we want to add a \"priority\" property to each Item so that we can filter Items by their priorities. The priority property uses a PriorityLevel enum to constrain the possible values. To do this, follow these steps: 1. Open the `App.xcodeproj` in Xcode.\n2. Open the `Item.swift` class file.\n3. Add the following property to the `Item` class:  \n`| @Persisted var priority: PriorityLevel |  \n| -------------------------------------- |  \n`\n4. Also add a PriorityLevel `PersistableEnum` below the `Item` class:  \n```swift  \nclass Item: Object, ObjectKeyIdentifiable {  \n   @Persisted(primaryKey: true) var _id: ObjectId  \n   @Persisted var isComplete = false  \n   @Persisted var summary: String  \n   @Persisted var owner_id: String  \n   @Persisted var priority: PriorityLevel  \n}  \nenum PriorityLevel: Int, PersistableEnum, CaseIterable {  \n   case severe = 0  \n   case high = 1  \n   case medium = 2  \n   case low = 3  \n   var description: String {  \n      switch self {  \n      case .severe: return \"Severe\"  \n      case .high: return \"High\"  \n      case .medium: return \"Medium\"  \n      case .low: return \"Low\"  \n      }  \n   }  \n}  \n```  \n[PersistableEnum is the protocol](https://www.mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-ios-realm-enum) that marks enum types as persistable directly in Realm. We set the enum's type as `Int` here instead of `String` so we can query based on a numeric priority level later. We use a `description` computed property to display a string representation of the priority in the UI. 2 #### Set the Priority when Creating a New Item\n\n 3 #### Run and Test At this point, you can run the application again. Log in using the account you created earlier in this tutorial. You will see the one Item you previously created. Add a new Item, and you will see that you can now set the priority. Choose `High` for the priority and save the Item. Now switch back to the Atlas data page in your browser, and refresh the`Item` collection. You should now see the new Item with the `priority`field added and set to **1**. The existing Item does not have a `priority`field. ![Two items in a collection](https://mongodb.com/docs/atlas/app-services/images/swiftui-tutorial-two-new-items.png) ## Note ### Why Didn't This Break Sync? Adding a property to a Realm object is not a breaking change and therefore does not require a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets). The template app has Development Mode enabled, so changes to the client Realm object are reflected in the server-side schema. For more information, see[Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) and [Update Your Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-additive-changes-synced-schema) ### Change the Subscription 1 #### Update the subscription In the `ContentView.swift` file, we create the Flexible Sync subscription that defines which documents we sync with the user's device & account. Look for the `let config = user.flexibleSyncConfiguration(initialSubscriptions:`variable where we set the initial subscriptions. Within the `subscriptions.append()`method, you can see that we are currently subscribing to all documents where the `owner_id` property matches the authenticated user's id. We want to maintain that, but _only_ sync Items that are marked as High or Severe priority. This is why we set the `PriorityLevel` enum to type `Int`, where the highest priority (severe) has a value of 0, and the lowest priority (low) has a value of 3\\. We can make direct comparisons between an Int and the priority property. To do so, update the query statement to include documents where the priority is equal to or _less_ than PriorityLevel.High (or 1), as shown here. We'll also add the `reRunOnOpen` bool, and set it to `true`, to force the subscription query to recalculate which documents to sync every time we open the app. ```swift let config = user.flexibleSyncConfiguration(initialSubscriptions: { subs in    if let foundSubscription = subs.first(named: Constants.myItems) {       foundSubscription.updateQuery(toType: Item.self, where: {          $0.owner_id == user.id && $0.priority <= PriorityLevel.high       })    } else {       // No subscription - create it       subs.append(QuerySubscription<Item>(name: Constants.myItems) {          $0.owner_id == user.id && $0.priority <= PriorityLevel.high       })    } }, rerunOnOpen: true) \n``` 2 #### Run and Test Run the application again. Log in using the account you created earlier in this tutorial. You would expect the list to change, since we added the`reRunOnOpen` to force the subscription query to recalculate which documents to sync. If you check the console logs, you will see an entry that looks something like this: ```shell 2022-08-08 17:54:24.128249-0400 App[17920:237672] Sync: Connection[2]: Session[2]: Received QUERY_ERROR \"Client provided query with bad syntax: unsupported query for table \"Item\": key \"priority\" is not a queryable field\" (error_code=300, query_version=3) \n``` This message tells us that we have added a field to our subscription without configuring Flexible Sync to use that field. 3 #### Update Flexible Sync on the Server\n\n 4 #### Test the changes Return to your mobile app. Because we added `reRunOnOpen`, the app should re-sync only the documents that match the Flexible Sync query. After an initial moment when Realm resyncs the document collection, you will only see the new Item of High priority that you created. The Item document you initially created is not synced, because it does not have a `priority` field. If you want this Item to be synced, you can edit the document in the Atlas UI and add a value for the priority field. If you want to further test the functionality, you can create Items of various priorities. You will see that a new Item with a lower priority briefly appears in the list of Items and then disappears. The Sync error handler helpfully provides a message describing this behavior: ```shell ERROR \"Client attempted a write that is outside of permissions or query filters; it has been reverted\" \n``` You can also see this message in the console log. In this scenario, Realm creates the Item locally, syncs it with the backend, and then reverts the write because it doesn't meet the subscription rules. ## Conclusion Adding a property to an existing Realm object is a non-breaking change, and Development Mode ensures that the schema change is reflected server-side. If you add or change a subscription to use an additional field, whether newly added or previously existent, you need to modify the Flexible Sync settings to enable querying against that field. ## What's Next? * Consider adding the new `Priority` property to the `ItemList`, `ItemRow`, and `ItemDetail` Views.\n* Read our [Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/#std-label-ios-intro) and [SwiftUI](https://www.mongodb.com/docs/realm/sdk/swift/swiftui/#std-label-ios-swiftui-examples) documentation.\n* Find developer-oriented blog posts and integration tutorials on the[MongoDB Developer Hub.](https://developer.mongodb.com)\n* Join the [MongoDB Community forum](https://developer.mongodb.com/community/forums/c/realm/9)to learn from other MongoDB developers and technical experts. ## Note ### Share Feedback How did it go? Use the Share Feedback tab at the bottom right of the page to let us know if this tutorial was helpful or if you had any issues. ← [React Native Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/react-native/ \"Previous Section\")[Write a Serverless GitHub Contribution Tracker](https://mongodb.com/docs/atlas/app-services/tutorial/backend/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/tutorial/kotlin/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Android With Kotlin Tutorial On this page * [Overview](#overview)\n* [Learning Objectives](#learning-objectives)\n* [Prerequisites](#prerequisites)\n* [Start with the Template](#start-with-the-template)\n* [Set up the Template App](#set-up-the-template-app)\n* [Open the App](#open-the-app)\n* [Explore the App Structure](#explore-the-app-structure)\n* [Run the App](#run-the-app)\n* [Check the Backend](#check-the-backend)\n* [Modify the Application](#modify-the-application)\n* [Add a New Property to the Model](#add-a-new-property-to-the-model)\n* [Set the Priority when Creating a New Item](#set-the-priority-when-creating-a-new-item)\n* [Run and Test](#run-and-test)\n* [Change the Subscription](#change-the-subscription)\n* [Conclusion](#conclusion)\n* [What's Next?](#what-s-next-) ## Overview Realm provides a Kotlin SDK that allows you to create an Android mobile application with Kotlin using [Jetpack Compose](https://developer.android.com//jetpack/compose/documentation). This tutorial is based on the Kotlin Flexible Sync Template App, named `kotlin.todo.flex`, which illustrates the creation of a To-do Item List management application. This application enables users to: * Register their email as a new user account.\n* Sign in to their account with their email and password (and sign out later).\n* View, create, modify, and delete their own tasks.\n* View all tasks, even where the user is not the owner. The template app also provides a toggle that simulates the device being in \"Offline Mode.\" This toggle lets you quickly test Device Sync functionality on the simulator, emulating the user having no internet connection. However, you would likely remove this toggle in a production application. This tutorial adds functionality to the Template App. You will add a new `Priority` field to the existing `Item` model and update the[Flexible Sync subscription](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields) to only show items within a range of priorities. This example illustrates how you might adapt the template app for your own needs. Depending on your experience with Kotlin, this tutorial should take around 30 minutes. ## Learning Objectives This tutorial illustrates how you might adapt the template app for your own needs. In this tutorial, you will learn how to: * Update a Realm object model with a non-breaking change.\n* Update a Device Sync subscription.\n* Add a queryable field to the Device Sync configuration on the server to change which data is synchronized. ## Note ### Check Out the Quick Start If you prefer to get started with your own application rather than follow a guided tutorial, check out the [Kotlin Quick Start](https://www.mongodb.com/docs/realm/sdk/kotlin/quick-start/#std-label-kotlin-client-quick-start). It includes copyable code examples and the essential information that you need to set up an Atlas App Services backend. ## Prerequisites\n\n ## Start with the Template This tutorial is based on the Kotlin SDK Flexible Sync Template App named`kotlin.todo.flex`. We start with the default app and build new features on it. To learn more about the Template Apps, see [Template Apps.](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) If you don't already have an Atlas account, [sign-up](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Ftemplate%5Fapps) to deploy a Template App. ## Set up the Template App 1 ### Open the App In Android Studio, open the `kotlin.todo.flex` folder located in the`frontend` folder of the template app. If you downloaded the client as a `.zip` file or cloned the client GitHub repository, you must manually insert the App Services App ID in the appropriate place in your client. Follow theConfiguration instructions in the client `README.md`to learn where to insert your App ID. 2 ### Explore the App Structure Take a few minutes to explore the project organization while Android Studio indexes your project. Within the `app/java/com.mongodb.app`directory, you can see a few files worth noting: | File                    | Purpose                                                                                                                                                     |\n| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ComposeItemActivity.kt  | Activity class that defines the layout and provides functionality for opening a realm, writing Items to the realm, logging a user out, and closing a realm. |\n| ComposeLoginActivity.kt | Activity class that defines the layout and provides functionality for registering a user and logging a user in.                                             |\n| TemplateApp.kt          | Class that initializes the App Services App.                                                                                                                | In this tutorial, you'll be working in the following files:\n\n 3 ### Run the App Without making any changes to the code, you should be able to[run the app](https://developer.android.com/studio/run)on an Android Emulator using Android Studio or on a physical device. Run the app, register a new user account, and then add a new Item to your todo list. 4 ### Check the Backend Log in to [Atlas App Services](http://cloud.mongodb.com). In theData Services tab, click on Browse Collections. In the list of databases, find and expand the todo database, and then theItem collection. You should see the document you created in this collection. ## Modify the Application 1 ### Add a New Property to the Model Now that you have confirmed everything is working as expected, we can add changes. In this tutorial, we have decided that we want to add a \"priority\" property to each Item so that we can filter Items by their priority level. The priority property will be mapped to a `PriorityLevel` enum to constrain the possible values, and we will use the ordinal of each enum to correspond to the priority integer so we can query based on a numeric priority level later. To do this, follow these steps: 1. Within the `app/java/com.mongodb.app/domain` folder, open the `Item` class file.\n2. Add a `PriorityLevel` enum to constrain the possible values. Also add a `priority`property to the `Item` class, which sets the default priority to 3, indicating that it is a low-priority todo item:  \ndomain/Item.kt  \n`| // ... imports                                |  \n| --------------------------------------------- |  \n| enum class PriorityLevel() {                  |  \n| Severe, // priority 0                         |  \n| High,   // priority 1                         |  \n| Medium, // priority 2                         |  \n| Low     // priority 3                         |  \n| }                                             |  \n| class Item() : RealmObject {                  |  \n| @PrimaryKey                                   |  \n| var _id: ObjectId = ObjectId.create()         |  \n| var isComplete: Boolean = false               |  \n| var summary: String = \"\"                      |  \n| var owner_id: String = \"\"                     |  \n| var priority: Int = PriorityLevel.Low.ordinal |  \n| constructor(ownerId: String = \"\") : this() {  |  \n| owner_id = ownerId                            |  \n| }                                             |  \n| // ... equals() and hashCode() functions      |  \n| }                                             |  \n` 2\n\n\n\n 3 ### Run and Test At this point, you can rerun the application. Log in using the account you created earlier in this tutorial. You will see the one Item you previously created. Add a new Item, and you will see that you can now set the priority. Choose `High` for the priority and save the Item. Now switch back to the Atlas data page in your browser, and refresh the`Item` collection. You should now see the new Item with the `priority`field added and set to **1**. The existing Item does not have a `priority`field. ![Two items in a collection](https://mongodb.com/docs/atlas/app-services/images/swiftui-tutorial-two-new-items.png) ## Note ### Why Didn't This Break Sync? Adding a property to a Realm object is not a breaking change and therefore does not require a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets). The template app has Development Mode enabled, so changes to the client Realm object are reflected in the server-side schema. For more information, see[Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) and [Update Your Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-additive-changes-synced-schema) ### Change the Subscription 1 #### Update the subscription Within the `app/java/com.mongodb.app/data` folder, open the `SyncRepository.kt`file, where we define the Flexible Sync subscription. The subscription defines which documents we sync with the user's device and account. Find the`getQuery()` function. You can see that we are currently subscribing to two subscriptions: * `MINE`: All documents where the `ownerId` property matches the authenticated user.\n* `ALL`: All documents from all users. We want to update the `MINE` subscription to _only_ sync Items that are marked as High or Severe priority. As you may recall, the `priority` field is of type `int`, where the highest priority (\"Severe\") has a value of 0, and the lowest priority (\"Low\") has a value of 3\\. We can make direct comparisons between an integer and the priority property. To do so, edit the RQL statement to include documents where the priority is equal to or _less_ than PriorityLevel.High (or 1), as shown here: data/SyncRepository.kt ```kotlin private fun getQuery(realm: Realm, subscriptionType: SubscriptionType): RealmQuery<Item> =    when (subscriptionType) {          SubscriptionType.MINE -> realm.query(\"owner_id == $0 AND priority <= ${PriorityLevel.High.ordinal}\", currentUser.id)          SubscriptionType.ALL -> realm.query()    } \n``` We'll also force the subscription query to recalculate which documents to sync every time we open the app. To do this, find the `SyncConfiguration.Builder().initialSubscriptions()` function that our application calls on start. First add the `reRunOnOpen` parameter set to `true`, then set `updateExisting` to `true`, which allows the existing query to be updated. ```kotlin config = SyncConfiguration.Builder(currentUser, setOf(Item::class))    .initialSubscriptions(rerunOnOpen = true) { realm ->        // Subscribe to the active subscriptionType - first time defaults to MINE        val activeSubscriptionType = getActiveSubscriptionType(realm)        add(getQuery(realm, activeSubscriptionType), activeSubscriptionType.name, updateExisting = true)    }    .errorHandler { session: SyncSession, error: SyncException ->        onSyncError.invoke(session, error)    }    .waitForInitialRemoteData()    .build() \n``` 2 #### Run and Test Run the application again. Log in using the account you created earlier in this tutorial. Here, you'll notice an error if you check your[logs using Logcat](https://developer.android.com/studio/debug/am-logcat). You will see an entry that looks something like this: ```shell\n\n Client provided query with bad syntax: unsupported query for table \"Item\": key \"priority\" is not a queryable field \n``` This message tells us that we have added a field to our subscription without configuring Flexible Sync to use that field. 3 #### Update Flexible Sync on the Server 1. Switch back to the Atlas page in your browser. Select theAtlas App Services tab and open the app you are using.\n2. In the left-hand navigation, choose Device Sync, and then click **OK** in the dialog box about Development Mode being enabled.\n3. Scroll down to the Select Queryable Fields section. In the dropdown labeled **Select or create a queryable field**, choose \"priority\". The priority field will be added to the fields shown:  \n![Priority field is now queryable.](https://mongodb.com/docs/atlas/app-services/images/dotnet-tutorial-priority-subscribed.png)\n4. Save your changes. 4 #### Test the changes Return to your mobile app. After an initial moment when Realm re-syncs the document collection, you will see the new Item of High priority that you created. If you want to test the functionality further, you can create Items of various priorities. You'll note that if you try to add an Item with a priority lower than High, you will get a Toast message indicating you do not have permission. And if you check your[logs using Logcat](https://developer.android.com/studio/debug/am-logcat), you will see a message indicating the item was \"added successfully\", followed by a sync error: ```shell ERROR \"Client attempted a write that is outside of permissions or query filters; it has been reverted\" \n``` That's because, in this scenario, Realm creates the Item locally, syncs it with the backend, and then reverts the write because it doesn't meet the subscription rules. You'll note, too, that the document you initially created is not synced, because it has a priority of `null`. If you want this Item to be synced, you can edit the document in the Atlas UI and add a value for the priority field. ## Conclusion Adding a property to an existing Realm object is a non-breaking change, and Development Mode ensures that the schema change is reflected server-side. If you add or change a subscription to use an additional field, whether newly added or previously existent, you need to modify the Flexible Sync settings to enable querying against that field. ## What's Next? * Read our [Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/#std-label-kotlin-intro) documentation.\n* Find developer-oriented blog posts and integration tutorials on the[MongoDB Developer Hub.](https://developer.mongodb.com)\n* Join the [MongoDB Community forum](https://developer.mongodb.com/community/forums/c/realm/9)to learn from other MongoDB developers and technical experts. ## Note ### Share Feedback How did it go? Use the Share Feedback tab at the bottom right of the page to let us know if this tutorial was helpful or if you had any issues. ← [Flutter Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/flutter/ \"Previous Section\")[React Native Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/react-native/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/tutorial/react-native/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # React Native Tutorial On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Start with the Template App](#start-with-the-template-app)\n* [Set Up the Template App](#set-up-the-template-app)\n* [Install Dependencies](#install-dependencies)\n* [Build the App](#build-the-app)\n* [Test the App](#test-the-app)\n* [Get Familiar With the Template App](#get-familiar-with-the-template-app)\n* [Atlas App Services App](#atlas-app-services-app)\n* [React Native App](#react-native-app)\n* [Add a Priority Level Field](#add-a-priority-level-field)\n* [Define the Priority Levels](#define-the-priority-levels)\n* [Update the Item Data Model](#update-the-item-data-model)\n* [Add a Priority Picker](#add-a-priority-picker)\n* [Run and Test the App](#run-and-test-the-app)\n* [Update the Sync Subscription](#update-the-sync-subscription)\n* [Add a Mode Toggle to the UI](#add-a-mode-toggle-to-the-ui)\n* [Update the Sync Subscription](#update-the-sync-subscription-1)\n* [Test the App](#test-the-app-1)\n* [Update the Sync Configuration](#update-the-sync-configuration)\n* [Run the Completed App](#run-the-completed-app)\n* [What's Next?](#what-s-next-) ## Overview You can use the Realm React Native SDK and [@realm/react](https://www.npmjs.com/@realm/react)to build a mobile application with React Native. This tutorial walks you through how to build your own app that uses Flexible Sync. For this tutorial, we'll start with a pre-built TypeScript template application to see how everything fits together. The app is a pre-built template that includes a working React Native application (frontend) and its corresponding App Services App configuration files (backend). The template app is a basic to-do list application that lets users do various things to manage their tasks: * Create email/password accounts and log in and out of the app.\n* Create, read, update, and delete their own tasks.\n* View all tasks, even if the user is not the owner. After you've got the template app running, you will add a new `priority`field to the existing `Item` model and update the Flexible Sync subscription to only show items within a range of priorities. This example illustrates how you might adapt the template app for your own needs. You would not necessarily make this change given the current structure of the template app. The template app provides a toggle that simulates the device being in an offline mode. This toggle lets you quickly test Device Sync functionality, emulating the user having no internet connection. However, you would likely remove this toggle in a production application. This tutorial should take around 30 minutes. ## Note ### Check Out the Quick Start If you prefer to explore on your own rather than follow a guided tutorial, check out the [React Native Quick Start](https://www.mongodb.com/docs/realm/sdk/react-native/quick-start/#std-label-react-native-client-quick-start). It includes copyable code examples and the essential information that you need to set up a React Native app with Atlas Device Sync. ## Prerequisites\n\n ## Start with the Template App This tutorial is based on the React Native SDK Flexible Sync Template App named`react-native.todo.flex`. We start with the default app and build new features on it. To learn more about the Template Apps, see [Template Apps.](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps) If you don't already have an Atlas account, [sign-up](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Ftemplate%5Fapps) to deploy a Template App. ## Set Up the Template App Use the following steps to get the template app up and running on your computer: 1 ### Install Dependencies In your terminal, go to the directory that contains the client code. If you created the app with the App Services CLI, go to`realm-sync-tutorial/frontend/react-native.todo.flex`. Otherwise, go to the root of your downloaded or cloned project. Then run following commands to navigate to install the app's dependencies: `| npm install |\n| ----------- | ` To build and run the app on an iOS device or simulator, install the additional iOS dependencies with [CocoaPods.](https://guides.cocoapods.org/using/getting-started.html) ```shell npx pod-install \n``` 2 ### Build the App At this point, you should have a fully functional React Native app that can run on both iOS and Android. ## Tip If you're encountering an error or otherwise having issues, it's likely an issue with how your local environment is set up. Check out the official React Native[development environment setup](https://reactnative.dev/docs/environment-setup)guide and ensure that you've followed all the steps for your Development OS and Target OS. 3 ### Test the App When the build completes, you should have a functional app running on your simulator. In the app, register a new account and test the features: * Add a few to-do items to the list.\n* Press the checkbox on one or two items to mark them as complete.\n* Press the X on an item to delete it from the list.\n* Toggle internet connectivity in the app to simulate offline mode. If you connect to your Atlas Cluster and query the`todo.Item` collection you can see your App's data. As long as the React Native app is not in offline mode, new data and changes in the app automatically sync to the `todo.Item` collection. ## Tip To learn how to connect to your Atlas Cluster, see[Connect to a Database Deployment.](https://www.mongodb.com/docs/atlas/connect-to-database-deployment/#std-label-atlas-connect-to-deployment) Similarly, any changes in the collection automatically sync down to the React Native app. Try changing an item's completion status in your cluster - the React Native app will automatically update with the new value whenever a network connection is available. ## Tip To learn more about updating data in your cluster, see[Update Documents.](https://www.mongodb.com/docs/manual/tutorial/update-documents/#std-label-write-op-update) ## Get Familiar With the Template App Now that you have the template app running let's dive into the code to see what we're working with. ### Atlas App Services App The template app includes a fully configured App Services App in the`backend` directory. It has a unique `app_id` value in`realm_config.json` that client applications use to connect. It also includes the following pre-defined configurations: * A data source linked to your Atlas Cluster.\n* A data model for the `todo.Item` collection that matches the `Item`class in the React Native app.\n* An authentication provider that lets users register for and log in to your app with an email and password.\n* A flexible sync configuration with a single session role that allows users to read and write their own items and view other users' items. ### React Native App The React Native app is a fully configured mobile client that can run on iOS and Android devices. The app uses the official [@realm/react](https://www.npmjs.com/@realm/react) library. The library includes React hooks and components that let you connect to your Atlas App, read and write data, and automatically sync changes from other devices.\n\n\n\n ## Add a Priority Level Field Now that you're more familiar with what's already provided in the template app, let's write some code to implement a new feature. For this tutorial, we'll add a new `priority` property to the`Item` objects. This will let us organize to-dos by how important they are and allow us to focus only on the most important ones. 1 ### Define the Priority Levels We want to allow a small number of named priority levels, and we want to easily be able sort the levels. To do this, we'll use a helper function to define an `enum` object that maps a set of ordered level names to and from an integer that represents their priority. Add the following code directly under the import statements in`src/ItemSchema.tsx`: ```javascript function createEnum(arr) {   arr.forEach((p, i) => arr[p] = i);   return arr; } // Priority.High === 1 // Priority[Priority.High] === \"High\" export const Priority = createEnum([   \"Severe\",   \"High\",   \"Medium\",   \"Low\", ]) \n``` The priority levels in the `enum` are ordered from most important to least. The corresponding index value for each level increases from the most important, `Priority[0]`, to the least important,`Priority[3]`. This means that a higher priority level (meaning more important) has a lower index value. 2 ### Update the `Item` Data Model Now we have an `enum` that defines the possible values of the`priority` field. However, we still have to define the`priority` field in the `Item` class. Add the following lines to your code in `src/ItemSchema.tsx` to add `priority` to the `Item` data model: src/ItemSchema.tsx ```javascript export class Item extends Realm.Object<Item> {   _id!: BSON.ObjectId;   isComplete!: boolean;   summary!: string;   owner_id!: string;   priority!: string;   static schema: Realm.ObjectSchema = {     name: 'Item',     primaryKey: '_id',     properties: {       // This allows us to automatically generate a unique _id for each Item       _id: {type: 'objectId', default: () => new BSON.ObjectId()},       // All todo items will default to incomplete       isComplete: {type: 'bool', default: false},       summary: 'string',       owner_id: 'string',       priority: {         // Store the index value of the Priority enum rather than the name         type: 'int',         default: Priority.High       },     },   }; } \n``` ## Note ### Why Didn't This Break Sync At this point, your React Native `Item` model and its corresponding schema in your App Services App no longer agree. That's okay! Adding a property to a Realm object is not a breaking change and therefore does not require a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets). The template app has Development Mode enabled, so changes to the client Realm object are reflected in the server-side schema. For more information, see[Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) and[Update Your Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-additive-changes-synced-schema) 3 ### Add a Priority Picker Your app's data model now includes a `priority` for each `Item`object. Let's update the app UI so that you can choose a priority value when you add a new to-do to the list. First, we'll install an external library to implement the priority picker component. Run the following in your terminal inside of your project root: ```shell npm install @react-native-picker/picker \n``` If you're building for iOS, make sure to link the associated Cocoapods after you've installed the package: ```shell npx pod-install \n``` ## Tip\n\n Now that the package is fully installed, let's update the new to-do creation prompt component to use the picker. Add the following imports to the top of `src/CreateToDoPrompt.tsx`: ```javascript import {Picker} from '@react-native-picker/picker'; import {Priority} from './ItemSchema'; \n``` Then, modify the `CreateToDoPrompt` component: * Add `priority` to the `onSubmit()` props definition\n* Keep track of `priority` in a state hook\n* Connect the state to the `Picker` component that you imported\n* Pass `priority` to the `onSubmit()` handler src/CreateToDoPrompt.tsx ```javascript type Props = {   onSubmit(args: {summary: string; priority: string;}): void; }; export function CreateToDoPrompt(props: Props): React.ReactElement<Props> {   const {onSubmit} = props;   const [summary, setSummary] = useState('');   const [priority, setPriority] = useState(Priority.High);   return (     <View style={styles.modalWrapper}>       <Text h4 style={styles.addItemTitle}>         Add To-Do Item       </Text>       <Input         placeholder=\"What do you want to do?\"         onChangeText={(text: string) => setSummary(text)}         autoCompleteType={undefined}       />       <Picker         style={{width: '80%'}}         selectedValue={priority}         onValueChange={value => setPriority(value)}>         {Priority.map(priority  => (           <Picker.Item             key={priority}             label={priority}             value={Priority[priority]}            />         ))}       </Picker>       <Button         title=\"Save\"         buttonStyle={styles.saveButton}         onPress={() => onSubmit({summary, priority})}       />     </View>   ); } \n``` In `src/ItemListView.tsx`, modify the `createItem()` function to accept and use `priority`: src/ItemListView.tsx ```javascript const createItem = useCallback(   ({summary, priority}: {summary: string, priority: string}) => {     realm.write(() => {       return new Item(realm, {         summary,         owner_id: user?.id,         priority       });     });   },   [realm, user], ); \n``` Then, modify the create to-do submission handler to accept the`priority` level and pass it to `createItem()`: src/ItemListView.tsx ```javascript <CreateToDoPrompt   onSubmit={({summary, priority}) => {     setShowNewItemOverlay(false);     createItem({summary, priority});   }} /> \n``` Finally, modify the list item template to render the to-do's `priority`before the `summary`: src/ItemListView.tsx ```javascript <ListItem   key={`${item._id}`}   bottomDivider   topDivider   hasTVPreferredFocus={undefined}   tvParallaxProperties={undefined}>   <Text>{item.priority}</Text>   <ListItem.Title style={styles.itemTitle}>     {item.summary}   </ListItem.Title>   <ListItem.Subtitle style={styles.itemSubtitle}>     {item.owner_id === user?.id ? '(mine)' : ''}   </ListItem.Subtitle>\n\n     checked={item.isComplete}     checkedColor={COLORS.primary}     iconType=\"material\"     checkedIcon=\"check-box\"     uncheckedIcon=\"check-box-outline-blank\"     onPress={() => toggleItemIsComplete(item._id)}   />   <Button     type=\"clear\"     onPress={() => deleteItem(item._id)}     icon={       <Icon         type=\"material\"         name=\"clear\"         size={12}         color=\"#979797\"         tvParallaxProperties={undefined}       />     }   /> </ListItem> \n``` 4 ### Run and Test the App Your app should now allow users to set a priority level for new to-do items. Rebuild the app and open it. Add some new to-do items to confirm that you can choose a priority level and that the list displays each to-do's priority. ## Update the Sync Subscription The Device Sync protocol uses a flexible model where each sync client uses a standard RQL query to choose a subset of application data and then _subscribes_ to the subset. This automatically pulls the latest version of all data in the subset to the device and syncs changes to the data between devices. For example, the template app you're using has the following built-in subscription to items that the current user owns: src/ItemListView.tsx ```javascript realm.subscriptions.update(mutableSubs => {   mutableSubs.removeByName(itemSubscriptionName);   mutableSubs.add(     realm.objects(Item).filtered(`owner_id == \"${user?.id}\"`),     {name: ownItemsSubscriptionName},   ); }); \n``` You can customize the subscription during runtime to sync only the data that your app needs. Let's add a feature to demonstrate how. For this tutorial, we'll add a button that lets us toggle between two modes: one where the app syncs all to-do items and another where it only syncs important ones with a `priority` of High or Severe. 1 ### Add a Mode Toggle to the UI First, add a `useState()` hook to the `ItemListView` component to keep track of the current mode: ItemListView.tsx ```javascript const [showImportantOnly, setShowImportantOnly] = useState(false); \n``` Then, add a new button that toggles the mode to the bottom of the to-do list, after `<ListItem>`: src/ItemListView.tsx ```javascript <Button   title={showImportantOnly ? 'Show All' : 'Show Important Only'}   buttonStyle={{     ...styles.addToDoButton,     backgroundColor: showImportantOnly ? '#00A35C' : '#FFC010',   }}   onPress={() => setShowImportantOnly(showImportantOnly => !showImportantOnly)} /> \n``` 2 ### Update the Sync Subscription At this point, the app can switch modes in the UI, but we haven't done anything else so the modes are functionally identical. Let's update the sync subscription to only sync data relevant to the current mode. In the first `useEffect` of the `ItemListView` component, add code that checks the current mode and appends an additional`priority` filter to the query if the `showImportantOnly` mode is active: src/ItemListView.tsx ```javascript useEffect(() => {   if (showAllItems) {     realm.subscriptions.update(mutableSubs => {       mutableSubs.removeByName(ownItemsSubscriptionName);       mutableSubs.add(realm.objects(Item), {name: itemSubscriptionName});     });   } else if (showImportantOnly) {     realm.subscriptions.update(mutableSubs => {       mutableSubs.removeByName(itemSubscriptionName);       mutableSubs.add(         realm.objects(Item).filtered(`owner_id == \"${user?.id}\" && priority <= 1`),         {name: ownItemsSubscriptionName},\n\n     });   } else {     realm.subscriptions.update(mutableSubs => {       mutableSubs.removeByName(itemSubscriptionName);       mutableSubs.add(         realm.objects(Item).filtered(`owner_id == \"${user?.id}\"`),         {name: ownItemsSubscriptionName},       );     });   } }, [realm, user, showAllItems, showImportantOnly]); \n``` ## Important Don't forget to add `showImportantOnly` to the list of dependencies in the second argument of `useEffect`. 3 ### Test the App Your app is now set up to modify its sync subscription based on the current mode. However, if you run the app and switch to only showing important items, you'll see that the list doesn't change and a warning appears in the console: ``` Possible Unhandled Promise Rejection (id: 0): Error: Client provided query with bad syntax: unsupported query for table \"Item\": key \"priority\" is not a queryable field \n``` 4 ### Update the Sync Configuration We're getting a warning because a sync client can only filter a subscription based on a given field if that field is specifically listed as a queryable field in the Device Sync configuration of your App Services App. To get everything working, we need to add `priority` as a queryable field in the App's sync configuration. First, find the template app's `backend` directory and modify`sync/config.json`: ``` {     ...,     \"queryable_fields_names\": [         \"_id\",         \"owner_id\",         \"priority\"     ] } \n``` Then, run the following terminal command from within the`backend` directory to deploy the updated sync configuration: ```bash npx mongodb-realm-cli push \n``` 5 ### Run the Completed App Once your updated sync configuration is deployed, your app is complete and fully functional. Congratulations! Rebuild and run the app to make sure everything works. You should be able to create, complete, and delete to-do items as well as toggle between viewing all items and only important items. ## What's Next? * Read our [React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/#std-label-react-native-intro) documentation.\n* Find developer-oriented blog posts and integration tutorials on the [MongoDB Developer Hub.](https://developer.mongodb.com)\n* Join the [MongoDB Community forum](https://developer.mongodb.com/community/forums/c/realm/9) to learn from other MongoDB developers and technical experts. ## Note ### Share Feedback How did it go? Use the Share Feedback tab at the bottom right of the page to let us know if this tutorial was helpful or if you had any issues. ← [Android With Kotlin Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/kotlin/ \"Previous Section\")[SwiftUI iOS Tutorial](https://mongodb.com/docs/atlas/app-services/tutorial/swiftui/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # App Builder's Guide * [Device Sync Permissions Guide](https://mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/)\n* [Sync Atlas Data with Client](https://mongodb.com/docs/atlas/app-services/sync/app-builder/sync-data-in-atlas-with-client/)\n* [Sync Client Data with Atlas](https://mongodb.com/docs/atlas/app-services/sync/app-builder/sync-data-in-client-with-atlas/)\n* [Stream Data from Client to Atlas](https://mongodb.com/docs/atlas/app-services/sync/app-builder/stream-data-from-client-to-atlas/)\n* [Add Sync to a Local-Only App](https://mongodb.com/docs/atlas/app-services/sync/app-builder/local-to-sync/)\n* [Event Library](https://mongodb.com/docs/atlas/app-services/sync/app-builder/event-library/) ← [Get Started with Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/get-started/ \"Previous Section\")[Device Sync Permissions Guide](https://mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Go to Production with Atlas Device Sync * [Production Checklist](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-checklist/)\n* [Production Load Testing](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-load-testing/)\n* [Optimize Sync Atlas Usage](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/)\n* [Compact an Atlas Volume](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/compact-disk/) ← [Sync Errors](https://mongodb.com/docs/atlas/app-services/sync/error-handling/errors/ \"Previous Section\")[Device Sync Production Checklist](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-checklist/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Error Handling * [Client Reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/)\n* [Sync Errors](https://mongodb.com/docs/atlas/app-services/sync/error-handling/errors/) ← [Pause or Terminate Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/ \"Previous Section\")[Client Resets](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/details/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Technical Details * [Conflict Resolution](https://mongodb.com/docs/atlas/app-services/sync/details/conflict-resolution/)\n* [Atlas Device Sync Protocol](https://mongodb.com/docs/atlas/app-services/sync/details/protocol/) ← [Compact an Atlas Volume](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/compact-disk/ \"Previous Section\")[Conflict Resolution](https://mongodb.com/docs/atlas/app-services/sync/details/conflict-resolution/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/configure-device-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure Atlas Device Sync * [Enable Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/)\n* [Sync Settings](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/)\n* [Pause or Terminate Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/) ← [Data Model Mapping](https://mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/ \"Previous Section\")[Configure and Enable Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/configure-your-data-model/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure Your Data Model * [Sync Data Model Overview](https://mongodb.com/docs/atlas/app-services/sync/data-model/sync-schema-overview/)\n* [Create a Data Model](https://mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/)\n* [Generate SDK Object Models](https://mongodb.com/docs/atlas/app-services/sync/data-model/generate-sdk-object-models/)\n* [Update a Data Model](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/)\n* [Make Breaking Schema Changes](https://mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/)\n* [Data Model Mapping](https://mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/) ← [Event Library](https://mongodb.com/docs/atlas/app-services/sync/app-builder/event-library/ \"Previous Section\")[Sync Data Model Overview](https://mongodb.com/docs/atlas/app-services/sync/data-model/sync-schema-overview/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/get-started/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Get Started with Atlas Device Sync On this page * [Before You Start](#before-you-start)\n* [Configure Your Data Model](#configure-your-data-model)\n* [Choose an SDK](#choose-an-sdk)\n* [Define Data Model](#define-data-model)\n* [Define Data Access Patterns](#define-data-access-patterns)\n* [Choose a Sync Mode](#choose-a-sync-mode)\n* [Define Data Access Rules](#define-data-access-rules)\n* [Enable Sync](#enable-sync)\n* [Optimize Sync Data Usage](#optimize-sync-data-usage)\n* [Create Queries in Your Client Application](#create-queries-in-your-client-application) To sync data across devices, you [enable Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) for your App and then use the sync-related methods and properties in the SDKs. ## Tip ### Check out the tutorial If you prefer to learn by example, check out the App Services[tutorial](https://www.mongodb.com/docs/realm/tutorial/), which describes how to build a synced to-do list application with clients for common platforms that App Services supports. ## Before You Start * If you don't already have one, [sign up for a free MongoDB Atlas account.](https://www.mongodb.com/cloud/atlas/register?tck=docs%5Frealm)\n* Flexible Sync requires MongoDB version 5.0 or later. You can use a free shared M0 cluster to explore and develop your app. We recommend that you use a dedicated tier cluster (M10 and above) for production applications. You cannot use sync with a [serverless instance](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-serverless-caveats) or[Federated database instance](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats). [Partition-Based Sync](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync), requires a MongoDB Atlas cluster that runs MongoDB version 4.4 or later.\n* If you don't already have one, [create a new App](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) linked to your Atlas cluster. ## Configure Your Data Model ### Choose an SDK Realm is an object database optimized for mobile use cases. The[Realm SDKs](https://www.mongodb.com/docs/realm/sdk/#std-label-realm-sdks), available for multiple languages and platforms, include everything you need to work with synced \"realms\" in your client code. You can use multiple SDKs to work with the same set of synced data across devices and platforms. This guide focuses on configuring sync with an SDK. For in-depth documentation that includes details on how to install and use the Realm SDKs more generally, check out the SDK docs:\n\n ## Note The Realm Web SDK does not currently support Realm Database or Atlas Device Sync. However, you can query the same data in an Atlas cluster using either[MongoDB Data Access](https://www.mongodb.com/docs/realm/web/mongodb/#std-label-web-mongodb-data-access)or the [GraphQL API.](https://www.mongodb.com/docs/realm/web/graphql-apollo-react/#std-label-graphql-apollo-react) ### Define Data Model A synced realm uses object models that you define to determine the type of objects in the realm. Additionally, Sync requires a server-side document schema for each synced object type so that App Services can translate and apply changes between synced realms and MongoDB Atlas. To define your synced object models, do one of the following for each object type: * **Sync object models from an SDK:** In [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode), App Services automatically generates a document schema for each synced object type and assigns that schema to a collection in the linked cluster with the same name as the object type. Development mode lets you configure your synced data model from a client application using the same object models and code that you use in your production app. This is useful if you prefer a client-first approach that uses idiomatic object models in your preferred programming language.  \nFor a walkthrough of how to turn on Development Mode, see [Enable Development Mode.](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)\n* **Generate object models from a document schema:** App Services can automatically generate language-specific object models that you can use in your client applications. The generated models match the document schemas defined for your app's synced cluster. You can define these schemas manually or App Services can sample existing data in the cluster to create them automatically. This is useful if you prefer a server-first approach and/or plan to build apps with multiple SDKs.  \nFor a walkthrough of how to generate your object models based on server-side document schemas, see [Generate SDK Object Models.](https://mongodb.com/docs/atlas/app-services/sync/data-model/generate-sdk-object-models/#std-label-generate-sdk-object-models)  \nOnce you have the generated object models, you can copy them directly into your client application and use them the same way you would any regular object or struct in your preferred programming language. ## Define Data Access Patterns Once you have decided on your app's data model, you can define a data access pattern and access rules for your app's data. ### Choose a Sync Mode There are two Sync Modes: Flexible Sync and the older Partition-Based Sync. We recommend you use Flexible Sync. Client applications can query the queryable fields of a document to determine which objects to sync. Then, App Services applies rules and default roles to determine whether users can read or write the objects that match the query. ### Define Data Access Rules Data access rules determine which data to sync, as well as each user's ability to read and write data. Rules are closely linked to your app's data model. With Flexible Sync, you specify which data to sync through queries for matching objects in a client application. App Services then evaluates [roles and rules](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-roles) to determine which of those matching objects a user can read and write. You can define roles on specific collections. Default roles provide read and write permissions when more specific roles do not apply. Default roles apply to all collections an App can access, but you can restrict a role to a specific collection by specifying the collection name. ### Enable Sync When you enable Sync, you specify how clients can access data in your App. For a walkthrough of how to turn on sync, refer to [Configure and Enable Atlas Device Sync.](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) ### Optimize Sync Data Usage Device Sync syncs all data from collections with a defined[schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) in your Atlas cluster. If you do not specify a field in your schema, Device Sync will not sync that field to the clients.\n\n ### Create Queries in Your Client Application With Flexible Sync enabled, you can start creating queries from your client application. The Realm SDKs provide methods to create, update, and remove queries from the client application. The SDKs use **subscriptions** to maintain those queries on the client side. Through these subscriptions, your applications sync objects with the backend app and can watch for and react to changes. ← [Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/ \"Previous Section\")[App Builder's Guide](https://mongodb.com/docs/atlas/app-services/sync/app-builder/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/production-checklist/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Device Sync Production Checklist On this page * [Best Practices](#best-practices) ## Best Practices We recommend following these best practices to ensure optimal performance and a smooth user experience: Avoid breaking changes Once you've enabled sync, there are limitations on how you can modify your data model. Specifically, sync does not support breaking changes to your object types such as changing a given property's type. If you want to make a breaking change you need to terminate and re-enable sync with the updated data models. Define a client reset handler To recover from a serious error conditions where the client and server histories diverge, you should define a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets)handler when you open each synced realm with an SDK. Define a client maximum offline time The App Services backend uses a history of changes to underlying data to synchronize clients. Configure a [client maximum offline time](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time) to control the number of days of history stored by your App. Clients that have not synchronized in more than that number of days must perform a client reset the next time they connect to the backend. Deployment model and geographic regions Use a [local deployment model](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-local-deployment) when building a Device Sync application. Configure your App and MongoDB data source to run within the same geographic region and cloud provider. Atlas oplog Device Sync requires access to the [oplog](https://www.mongodb.com/docs/atlas/reference/atlas-oplog/) of your synced cluster. For best results, keep 48 hours of oplog for a cluster using Device Sync. App Services Schema Data Consistency If you create or modify Device Sync documents using another tool, such as the[mongo](https://www.mongodb.com/docs/manual/reference/mongo/#mongodb-binary-bin.mongo) shell or MongoDB Compass, be sure the documents validate against the App Services Schema for the collection. For more information, see[Unsynced Documents.](https://mongodb.com/docs/atlas/app-services/mongodb/internal-database-usage/#std-label-unsynced-documents) Disable or Manage Built-In Schema Validation A schema in App Services is **not the same** as [MongoDB's built-in schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/#std-label-schema-validation-overview). Device Sync may interact with your cluster in a way that is incompatible with a built-in schema. If you use schema validation on your cluster, you should either disable it in favor of App Services schemas or manage the two schema validation layers so that they're compatible. For more information, see [App Services Schema vs Built-In Schema Validation.](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schema-app-services-vs-built-in) Production Load Testing Measure performance and identify issues in a scaled-up production deployment with [Sync Production Load Testing.](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-load-testing/#std-label-sync-production-load-testing) Write Transaction Size When writing large amounts of data, consider using multiple small write transactions instead of a single larger transaction. Depending on your Atlas cluster version and configuration, write transactions greater than 16MB may be rejected by MongoDB and cause the sync operation to fail. ← [Go to Production with Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/ \"Previous Section\")[Sync Production Load Testing](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-load-testing/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/production-load-testing/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Sync Production Load Testing On this page * [Overview](#overview)\n* [Recommended Strategy](#recommended-strategy) ## Overview To **load test** is to simulate the requests that users will put on your app once your app is in production. The goal is to measure performance and to identify and resolve issues before they happen to a real user. ## Recommended Strategy Use the Node.js SDK to simulate a common single user's workload for your mobile app. For example, you can use the SDK to: * Open a set number of synced realms.\n* Make a certain number of writes to the synced realms.\n* Simulate backend server calls (for example, by calling Atlas Functions). The exact details of the simulation depend on your app's actual workload. For instance, you might open realms that already have initialized sync data on the server side to simulate read use cases. You might open different realms to simulate write workloads. These realms might be a mix of shared or private per-user realms depending on your use case. You can use a shared realm to test the conflict resolution speed and discover any problems. So, consider how you use Realm Database in your actual app to design your simulation. ## Note The Node.js SDK uses the same underlying C++ database and sync client as the mobile (iOS, Android, .NET, etc.) SDKs. Therefore, you can exercise the same code paths as in your production mobile app while benefiting from the headless, server environment of Node.js. You can then deploy the single-user simulation to hundreds or thousands of concurrent nodes in order to test a real multi-user workload. For example: * Package the app in a Docker container.\n* Deploy the container as part of a Kubernetes job.\n* Adjust the parameters of the job to match it to a real production workload.\n* Measure the time it takes to complete the Kubernetes job to calculate overall performance. There are a variety of cloud-based Kubernetes-as-a-service offerings that you can use. ← [Device Sync Production Checklist](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-checklist/ \"Previous Section\")[Optimize Sync Atlas Usage](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/compact-disk/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Compact an Atlas Volume On this page * [Overview](#overview)\n* [Steps to Compact and Reclaim Disk Space](#steps-to-compact-and-reclaim-disk-space)\n* [An Alternate Approach](#an-alternate-approach) ## Overview While Realm [data compaction](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-backend-compaction) defragments the storage space the realm file uses on a _client_, and also reduces the size of the`__realm_sync` database on Atlas clusters, it does not reduce the overall size of the Atlas cluster. Compacting the data on an Atlas volume involves several additional steps. ## Steps to Compact and Reclaim Disk Space You should use the following guidance for reducing Atlas disk space usage: 1. Enable Compaction in App Services  \nBefore reclaiming volume space, be sure that you have enabled Compaction on your Atlas App Services app. You set this by setting the Max Offline Time setting in the Atlas UI. For more information, see[Optimize Sync Atlas Usage.](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-optimize-sync-atlas-usage)  \n## Note  \n### Wait for Compaction  \nIf you are enabling compaction for the first time, you will need to wait for the compaction to happen before continuing. You can file a ticket with support if you want to ensure compaction has completed.\n2. Perform a Rolling Resync  \nPerform a rolling resync of your Atlas cluster, a process explained in[Resync a Member of a Replica Set.](https://www.mongodb.com/docs/manualtutorial/resync-replica-set-member/)  \nThe commands to do this are not available with Atlas. Instead, you can file a ticket with support to have this process done for you. ## An Alternate Approach A final approach you can take for reclaiming _some_ of your Atlas volume space is to run the `compact()` command. You run it on one of the secondary nodes and then the other secondary node(s). Finally, you perform a failover on the primary mode and then run `compact()`. For more information on this approach, refer to [How to use the compact() command in Atlas.](https://kb.corp.mongodb.com/article/000019602/) ## Note The `compact()` command may not reduce the volume size as much as performing a rolling resync. ← [Optimize Sync Atlas Usage](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/ \"Previous Section\")[Technical Details](https://mongodb.com/docs/atlas/app-services/sync/details/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/details/conflict-resolution/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Conflict Resolution On this page * [Overview](#overview)\n* [Rules of Conflict Resolution](#rules-of-conflict-resolution)\n* [Special Considerations](#special-considerations)\n* [Counters](#counters)\n* [Strings](#strings)\n* [Custom Conflict Resolution](#custom-conflict-resolution)\n* [Summary](#summary) ## Overview Conflicts arise when two or more users make changes to the same piece of data independently. This can happen due to latency between device and server or loss of connectivity. In this event, Atlas Device Sync automatically uses conflict resolution strategies to merge the changes. Specifically, Device Sync handles conflict resolution using [operational transformation](https://www.mongodb.com/docs/realm/sync/protocol/#operational-transformation), a set of rules that guarantee strong eventual consistency, meaning all clients' versions will eventually converge to identical states. This will be true even if changes were made in a different order. You must be aware of the rules to ensure consistent results, but the upside is that by following those rules, you can have devices work entirely offline and still converge on meaningful results when they meet. ## Rules of Conflict Resolution At a very high level, the rules are as follows: Deletes always win. If one side deletes an object it will always stay deleted, even if the other side has made changes to it later on. Last update wins. If two sides update the same property, Device Sync will keep the value from the most recent update. Inserts in lists are ordered by time. If two items are inserted at the same position, the item that was inserted first will end up before the other item. This means that if both sides append items to the end of a list, will include both items in order of insertion time. Primary keys designate object identity. If two sides both create objects of the same class with identical primary keys, they will be treated as instances of the same object. ## Example ### Conflict Resolution Example Matt and Sarah are working on data for their dog walking business. Matt deletes data on one of their client's dogs, Doug, as they no longer need to walk him. While Sarah is out without internet connection, she edits Doug's required walk time data on her local, offline version, as she does not know about Matt's deletion of Doug's data. Once Sarah regains internet connection, her change will be sent to the server. The server will send her Matt's deletion operation. As deletes always win according to Device Sync's conflict resolution rules, Matt's deletion is kept rather than Sarah's edit. The server will not send Sarah's edits to Matt's device. The data is again in agreement across Matt and Sarah's devices. ## Special Considerations ### Counters Using integers for counting is a special case. The way that most programming languages would implement an increment operation (like `v += 1`) is to read the value, increment the result, and then store it back. This will obviously not work if you have multiple parties doing incrementing simultaneously (they may both read 10, increment it to 11, and when it merged you would get a result of 11 rather than the intended 12). To support this common case, we offer a way to express whether you are incrementing (or decrementing) the value, giving enough hints so the merge can reach the correct result. You have the choice to update the entire value or edit it in a way that conveys more meaning, allowing you to get more precise control of the conflict resolution. ### Strings Device Sync interprets the value of a string as a whole and does not merge conflicts on a per-character basis. For example, this means that if a character or substring is inserted or deleted within a string, Device Sync will treat this as a replacement of the entire value of the string. ## Custom Conflict Resolution Generally speaking, the conflict resolution of Device Sync should work for most purposes, and you should not need to customize it. That said, the typical way to do custom conflict resolution is to change a property type from string to list. Each side can then add its updates to the list and apply any conflict resolution rules it wants directly in the data model. You can use this technique to implement max, min, first write wins, last write wins, or any other kind of resolution you can think of. ## Summary\n\n ← [Technical Details](https://mongodb.com/docs/atlas/app-services/sync/details/ \"Previous Section\")[Atlas Device Sync Protocol](https://mongodb.com/docs/atlas/app-services/sync/details/protocol/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/release-notes/backend/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Atlas App Services Changelog On this page * [2023 Releases](#2023-releases)\n* [2022 Releases](#2022-releases)\n* [2021 Releases](#2021-releases) ## 2023 Releases ### 24 February 2023 Release * Add additional `currentPasswordValid` parameter to [password reset function.](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-auth-run-a-password-reset-function)\n* Update Atlas Device Sync with Flexible Sync to [use the same rules and permissions](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/#std-label-device-sync-compatibility) as other services. This update is currently only applied to newly created Apps. On the week of 26 February, 2023, existing apps will have their Flexible Sync specific-rules migrated to use the same rules and permissions as other services. ### 08 February 2023 Release * Increase [App concurrent request limit](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations-request-traffic) from 5,000 to 10,000.\n* Configure [user creation function](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-user-creation-function) via the App Services UI.\n* [Change App deployment model](https://mongodb.com/docs/atlas/app-services/apps/change-deployment-models/#std-label-change-deployment-models) from the UI and API. ### 25 January 2023 Release * Authenticate Data API and HTTPS Endpoint requests [using Bearer Authentication.](https://mongodb.com/docs/atlas/app-services/data-api/authenticate/#std-label-data-api-bearer-authentication) ### 11 January 2023 Release * Configure [user creation function](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-user-creation-function) via the App Services CLI and Admin API. ## 2022 Releases ### 14 December 2022 Release * Raise [Atlas Function request timeout](https://mongodb.com/docs/atlas/app-services/functions/#std-label-function-constraints)from 150 seconds to 180 seconds.\n* Expiration times for refresh tokens can be[configured from the API.](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#operation/adminGetRefreshTokenExpiration)\n* Let users create Apps in AWS region Ohio (us-east-2) from the UI. ### 30 November 2022 Release * Remove maximum number of clients that can concurrently[listen to database change streams](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations-change-streams)based on cluster size.\n* Support [App Services deployments](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-regions) in the AWS region Ohio (aws-us-east-2).\n* [Authenticate Atlas Data API requests](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-endpoint-authenticate)with the `apiKey` authentication credential headers for API key authentication.\n* GraphQL API support for query on relationships nested in relationship arrays.\n* When creating or configuring your App in the UI, App Services selects the[App Services deployment region](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-regions) geographically closest to your selected Atlas data source as the default option. ### 17 November 2022 Release * Support [App Services deployments](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-regions) in the AWS region São Paulo (aws-sa-east-1).\n* Updated [Admin API](https://mongodb.com/docs/atlas/app-services/admin/api/v3/#std-label-admin-api) endpoint to fetch Atlas Triggers and Atlas Data API apps. ### 3 November 2022 Release\n\n ### 20 October 2022 Release * Added option to [auto-resume Database Triggers](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-automatically-resume-a-suspended-trigger)that were suspended because resume token was lost. ### 10 October 2022 Release * Increased [request timeout](https://mongodb.com/docs/atlas/app-services/functions/#std-label-function-constraints) from 120 seconds to 150 seconds. ### 23 September 2022 Release * Added [mongodb.admin()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-mongodb.admin) and [admin.getDBNames()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-admin.getDBNames) in Atlas Functions. ### 9 September 2022 Release * Support App Services deployments in the following [GCP regions:](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-regions)  \n   * Ohio (`us-central1`)  \n   * Virginia (`us-east4`)  \n   * Oregon (`us-west1`)  \n   * Belgium (`europe-west1`)  \n   * Mumbai (`asia-south1`)\n* Added support for [database.getCollectionNames()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-database.getCollectionNames) in Atlas Functions. ### 29 June 2022 Release * Introduced a refreshed UI for Rules. ### 15 June 2022 Release * Introduced ability to configure [field-level permissions with the Data API.](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-field-level-permissions) ### 7 June 2022 Release * Released Flexible Sync as GA.\n* Released [Asymmetric Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync), which optimizes Flexible Sync for write-heavy workloads.\n* Released [Data API](https://mongodb.com/docs/atlas/app-services/data-api/#std-label-data-api) as GA.\n* Introduced Data API for all Apps.\n* Introduced field-level permissions for Flexible Sync.\n* Introduced [local regions for Azure data sources.](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-regions) ### 19 May 2022 Release * Introduced option to encode HTTPS Endpoint responses as [EJSON or JSON.](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-endpoint-return-types)\n* Added support for serverless Atlas instances as data sources. Serverless instances do not yet support Triggers or Sync. ### 20 April 2022 Release * Introduced ability to accept null values as optional types in Realm Schema.\n* Added ability to download logs from the UI.\n* Added Flexible Sync support for queries using `BETWEEN` and the string operators `BEGINSWITH`, `ENDSWITH`, `CONTAINS`.\n* Added Flexible Sync support for queries on arrays of primitives. ### 25 March 2022 Release * Performance improvements for Functions, particularly aimed at decreasing the runtime for those dependencies that make external requests.\n* MongoDB Atlas moved to Let's Encrypt as the new Certificate Authority for TLS certificates for all App Services. ### 26 January 2022 Release * Visually refreshed the [Schema UI.](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema)\n* Introduced [Log Forwarding](https://mongodb.com/docs/atlas/app-services/activity/forward-logs/#std-label-forward-logs), which automatically stores your application's server-side logs in a MongoDB collection or sends them to an external service. ### 19 January 2022 Release * Introduced [Flexible Sync (preview)](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync), which allows clients to sync data without the need for partition keys. ## 2021 Releases ### 02 December 2021 Release\n\n ### 18 November 2021 Release * Requests blocked by an application's [IP Access List](https://mongodb.com/docs/atlas/app-services/security/network/#std-label-manage-ip-access) no longer count towards billing. ### 06 October 2021 Release * Added the ability to configure an [IP Access List.](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-create/#std-label-realm-cli-accessList-create)\n* Increased function [execution timeout](https://mongodb.com/docs/atlas/app-services/functions/#std-label-function-constraints) from 90 seconds to 120 seconds.\n* Added the ability to create apps with a Template Starter Application.\n* App Services Events are now available to view on the [Atlas Activity Feed](https://www.mongodb.com/docs/atlas/tutorial/activity-feed/). You can configure these events in the [Atlas Alert Settings.](https://www.mongodb.com/docs/atlas/configure-alerts/) ### 08 September 2021 Release * Increased [request limit](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations-request-traffic) from 3000 requests per second to 5000 requests per second.\n* Allows users to store non-Realm files in the App Services[app structure.](https://mongodb.com/docs/atlas/app-services/reference/config/#std-label-app-configuration)\n* Updates to documents that do not match an application's [schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas)can now enable Atlas Device Sync for those documents. ### 25 August 2021 Release * Introduced the ability to export and re-deploy the most recent 25 deploys. ### 11 August 2021 Release * Support the option of sending events using [Extended JSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/)in [AWS EventBridge Triggers](https://mongodb.com/docs/atlas/app-services/triggers/aws-eventbridge/#std-label-aws-eventbridge) to support sending additional data types such as`Decimal128`.\n* Display the generated data models in SDKs Data Models when [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)is enabled for Atlas Device Sync. ### 28 July 2021 Release * Deprecated the [Stitch JS SDK.](https://github.com/mongodb/stitch-js-sdk)\n* Released the [Trigger Preimages](https://mongodb.com/docs/atlas/app-services/mongodb/preimages/#std-label-preimages) option for GA. ### 15 July 2021 Release * Improved usability of the Admin UI Dashboard.\n* Released [mongodb-realm-cli 2.0.](https://mongodb.com/docs/atlas/app-services/cli/#std-label-realm-cli-quickstart) ### 02 July 2021 Release * Added [JWT Authentication](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) support for JWTs with multiple audiences.\n* Introduced support for bi-directional [GitHub Autodeploy.](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github)\n* Added the ability to link a Github repository on application create. ### 16 June 2021 Release * Introduced ability to link new data sources via [Github Autodeploy.](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github) ### 04 June 2021 Release * Improves performance of client requests to app servers.\n* Fixes an issue where aggregation pipelines did not support the `$set` operator.\n* Reduces \"Invalid Session\" logs. ← [GitHub Snippets \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/snippets/github/ \"Previous Section\")[Get Help](https://mongodb.com/docs/atlas/app-services/help/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/details/protocol/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Atlas Device Sync Protocol On this page * [Overview](#overview)\n* [Key Concepts](#key-concepts)\n* [Changeset](#changeset)\n* [Operational Transformation](#operational-transformation)\n* [Client File Identifier](#client-file-identifier)\n* [Network Security](#network-security)\n* [Sync Session Process](#sync-session-process)\n* [Client Connects to the App Server](#client-connects-to-the-app-server)\n* [Client Initiates a Sync Session](#client-initiates-a-sync-session)\n* [App Services Allocates a New Client File Identifier](#app-services-allocates-a-new-client-file-identifier)\n* [Client Sends a Client Identifier](#client-sends-a-client-identifier)\n* [Client Uploads & Downloads Sync Changesets](#client-uploads---downloads-sync-changesets)\n* [Client Terminates the Sync Session](#client-terminates-the-sync-session)\n* [Request Types](#request-types)\n* [Client -> Server Messages](#client----server-messages)\n* [Server -> Client Messages](#server----client-messages) ## Overview Atlas Device Sync uses a protocol to correctly and efficiently sync data changes in real time across multiple clients that each maintain their own local Realm files. The protocol defines a set of pre-defined [request types](#std-label-sync-request-types) as well as a [process](#std-label-sync-session-process)by which a client, like a Realm SDK, can connect to an Atlas App Services application server and sync data. ## Note The Realm SDKs internally implement and manage the sync protocol, so for most applications you don't need to understand the sync protocol to use Device Sync. This page covers the protocol at a high level and is not an implementation spec. ## Key Concepts ### Changeset A **changeset** is a list of instructions that describe granular modifications made to a known object state or version by one or more write operations. Changesets are the base unit of the sync protocol. Synced realm clients send changesets to the Device Sync server whenever they perform a write operation. The server sends each connected client the changesets for write operations executed by other clients. The Device Sync server accepts changesets from any connected sync client (including changes in a synced MongoDB cluster) at any time and uses an operational transformation algorithm to serialize changes into a linear order and resolve conflicting changesets before sending them to connected clients. ## Note ### Delta Sync When you make a change to a synced object, App Services does not re-upload the entire object. Instead, App Services sends only the difference (\"delta\") between before and after. The service compresses the deltas with [zlib](https://en.wikipedia.org/wiki/Zlib) compression. This reduces network load, which is especially useful in mobile network conditions. ### Operational Transformation An **operational transformation** is a function that, given two changesets, produces a third changeset that represents logically applying one of the given changesets after the other. Device Sync uses operational transformation to resolve conflicts between changesets from different sync clients that apply to the same base state. Realm is an offline-first local database even when sync is enabled, which means that any device may perform offline writes and upload the corresponding changesets later when network connectivity is re-established. The operational transformation algorithm is designed to gracefully handle changesets that arrive \"out of order\" with respect to the logical server clock such that every synced Realm file converges to the same version of each changed object. ## Tip An operational transformation on Realm changesets is analogous to a [rebase operation](https://git-scm.com/docs/git-rebase) in Git. ### Client File Identifier A **client file identifier** is a value that uniquely identifies a synced client Realm file and its corresponding server file. The server generates a client file identifier whenever an SDK requests one during its initial sync of a Realm file. Each identifier is a 64-bit, non-zero, positive signed integer strictly less than 2^63. ## Note The server guarantees that all identifiers generated on behalf of a particular server file are unique with respect to each other. The server is free to generate identical identifiers for two client files if they are associated with different server files. ### Network Security\n\n ## Sync Session Process To initiate, execute, and terminate a Device Sync session, a Realm SDK and application server send and receive a set of protocol-specific requests. The SDK negotiates a WebSocket connection over HTTP and then establishes a sync session by sending [BIND](#mongodb-sync-client-message-BIND) and [IDENT](#mongodb-sync-client-message-IDENT)requests to the server over the WebSocket connection. Once the session is established, the SDK and server send synced changesets for a given Realm file to each other via [UPLOAD](#mongodb-sync-client-message-UPLOAD) and[DOWNLOAD](#mongodb-sync-server-message-DOWNLOAD) messages. To end the session, the SDK sends an[UNBIND](#mongodb-sync-client-message-UNBIND) request. `| Realm SDK                      App Server |  |\n| ----------------------------------------- |  |\n| \\|                                        |  |\n| \\|  <---- 1. HTTP Handshake ----->        |  |\n| \\|                                        |  |\n| \\|  --------- 2. BIND ----------->        |  |\n| \\|                                        |  |\n| \\|  <-- 3. IDENT (first time) ----        |  |\n| \\|                                        |  |\n| \\|  --------- 4. IDENT ---------->        |  |\n| \\|                                        |  |\n| \\|  <---- 5. UPLOAD/DOWNLOAD ---->        |  |\n| \\|                                        |  |\n| \\|  --------- 6. UNBIND --------->        |  | ` 1 ### Client Connects to the App Server The sync protocol is primarily handled over a WebSocket connection between the SDK and the server. To establish a connection, the SDK sends a handshake HTTP request that includes the following: * a protocol version\n* a WebSocket key\n* a valid access token for an authenticated App Services application user The server sends an [HTTP 101 Switching Protocols](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101)response that specifies a WebSocket connection for the SDK. The rest of the sync protocol occurs over this connection. 2 ### Client Initiates a Sync Session To begin a sync session, a Realm SDK sends a [BIND](#mongodb-sync-client-message-BIND)request to a Device Sync server. The request identifies a specific local Realm Database file to sync and includes a WebSocket connection key that the server will use to open a bidirectional connection to the SDK. If the SDK is attempting to sync a particular Realm Database file for the first time, it does not yet possess a server-generated client identifier for the file. In this case, the [BIND](#mongodb-sync-client-message-BIND) request also indicates that the Device Sync server should allocate one. 3 ### App Services Allocates a New Client File Identifier\n\n An SDK only needs to request a client file identifier the first time it syncs each Realm Database file. For subsequent sync sessions, the SDK can use the persisted identifier. 4 ### Client Sends a Client Identifier Once an SDK has initiated a sync session with a [BIND](#mongodb-sync-client-message-BIND)request, it must identify the local Realm Database file that it wants to sync. To do this, the SDK sends the application server an [IDENT](#mongodb-sync-client-message-IDENT)message that contains the client file identifier. If the SDK has previously synced the realm with the server, it can specify the most recently synced server version to optimize the sync process. When it receives the [IDENT](#mongodb-sync-client-message-IDENT) message, the server establishes the session. The SDK and server can can now freely send upload and download sync changesets at any time. 5 ### Client Uploads & Downloads Sync Changesets Once a sync session is established, the SDK and server can freely send and receive [UPLOAD](#mongodb-sync-client-message-UPLOAD) and [DOWNLOAD](#mongodb-sync-server-message-DOWNLOAD)messages to sync changes whenever they occur. The SDK sends an [UPLOAD](#mongodb-sync-client-message-UPLOAD) message for every changeset it applies except for those that it received in a [DOWNLOAD](#mongodb-sync-server-message-DOWNLOAD)message from the server. When the server receives an [UPLOAD](#mongodb-sync-client-message-UPLOAD) message, it applies[operational transformations](#std-label-operational-transformations) to resolve any conflicts with other changesets and then applies the transformed changeset to the server version of the realm. This triggers the server to send[DOWNLOAD](#mongodb-sync-server-message-DOWNLOAD) messages to other connected clients, including the synced Atlas cluster which mirrors the server realm. A[DOWNLOAD](#mongodb-sync-server-message-DOWNLOAD) message groups one or more transformed changesets in chronological order from oldest to most recent according to the server's history. The SDK applies the changesets in the same order. 6 ### Client Terminates the Sync Session Once a sync session is established, Device Sync servers will continue to accept[UPLOAD](#mongodb-sync-client-message-UPLOAD) messages and send[DOWNLOAD](#mongodb-sync-server-message-DOWNLOAD) messages until the SDK terminates the session. To terminate a sync session, an SDK sends an [UNBIND](#mongodb-sync-client-message-UNBIND)request to the Device Sync server. ## Request Types ### Client -> Server Messages The following table describes the request types that a sync client can send to a Device Sync server:\n\n ### Server -> Client Messages The following table describes the request types that the Device Sync server can send to a sync client:\n\n ← [Conflict Resolution](https://mongodb.com/docs/atlas/app-services/sync/details/conflict-resolution/ \"Previous Section\")[Atlas GraphQL API](https://mongodb.com/docs/atlas/app-services/graphql/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Optimize Sync Atlas Usage On this page * [Overview](#overview)\n* [History](#history)\n* [Backend Compaction](#backend-compaction)\n* [Advanced Backend Compaction](#advanced-backend-compaction)\n* [Trimming](#trimming)\n* [Client Maximum Offline Time](#client-maximum-offline-time)\n* [Key Concepts](#key-concepts)\n* [Client Maximum Offline Time Does Not Immediately Influence Client Resets](#client-maximum-offline-time-does-not-immediately-influence-client-resets)\n* [Set the Client Maximum Offline Time](#set-the-client-maximum-offline-time)\n* [Optimizing Performance and Storage When Using Flexible Sync](#optimizing-performance-and-storage-when-using-flexible-sync)\n* [Summary](#summary) ## Overview Atlas Device Sync uses space in your app's synced Atlas cluster to store utility data for sync. This includes a history of changes to each realm. Atlas App Services minimizes that space usage via backend compaction, which runs automatically. You can optimize further by specifying a client maximum offline time, which enables advanced backend compaction. ## History The App Services backend keeps a history of [changes to underlying data](https://mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-changesets) for each realm, similar to the[MongoDB oplog](https://www.mongodb.com/docs/manual/core/replica-set-oplog/). App Services uses this history to synchronize data between the backend and clients. App Services stores history in your synced Atlas cluster. ## Backend Compaction **Backend compaction** is a maintenance process that automatically runs for all Apps. During compaction, the backend optimizes a realm's history by removing unneeded changesets. The process removes any instruction whose effect is later overwritten by a newer instruction. ## Note Flexible Sync uses [trimming](#std-label-trimming) instead of backend compaction. ## Example Consider the following realm history: Original History `| CREATE table1.object1        |\n| ---------------------------- |\n| UPDATE table1.object1.x = 4  |\n| UPDATE table1.object1.x = 10 |\n| UPDATE table1.object1.x = 42 | ` The following history would also converge to the same state, but without unneeded interim changes: Compacted History ``` CREATE table1.object1 UPDATE table1.object1.x = 42 \n``` Backend compaction: * reduces space usage in your Atlas cluster, since your history contains fewer instructions.\n* reduces the time and data usage of sync, since clients can converge on the same result with fewer instructions. Backend compaction runs regularly on all synced clusters as part of Device Sync. ### Advanced Backend Compaction **Advanced backend compaction** uses client sync states to further optimize a changeset. However, this optimization can prevent convergence for clients that have only seen a subset of history. As a result, advanced backend compaction only occurs for history older than the[client maximum offline time.](#std-label-client-maximum-offline-time) ## Example Consider the following realm history: Original History ``` CREATE table2.object2 CREATE table1.object1 DELETE table2.object2 \n``` Because there is a gap in time between the CREATE and DELETE operations for `table2.object2`, a client could have synchronized the CREATE, but not the DELETE. As a result, compaction can remove the CREATE, but not the DELETE: Compacted History ``` CREATE table1.object1 DELETE table2.object2 \n``` This guarantees client convergence. If the history didn't include the DELETE, clients that synced the CREATE would never delete `table2.object2`, but other clients would never create that object in the first place. Instead, all clients get a command to delete that object, and any clients who never created `table2.object2`in the first place ignore the DELETE. The following history uses advanced backend compaction to converge on the same state with even fewer steps: Advanced Compacted History ``` CREATE table1.obj1 \n```\n\n Advanced backend compaction only runs on Apps that specify a client maximum offline time. Only history older than the client maximum offline time experiences advanced backend compaction. ### Trimming When you set a client maximum offline time in an App that uses Flexible Sync, trimming deletes changes older than the client maximum offline time. This reduces storage requirements beyond even the optimization of advanced backend compaction. ## Client Maximum Offline Time The **client maximum offline time** controls the age limit of history optimized with [advanced backend compaction](#std-label-advanced-backend-compaction). This indirectly changes how long a client can remain offline between synchronization sessions with the backend. Clients that do not synchronize for more than the specified number of days may experience a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) the next time they connect with the backend. The lower the client maximum offline time, the sooner compaction can apply advanced backend compaction to history. The resulting optimizations usually result in less storage usage in the synced Atlas cluster. New Apps automatically enable client maximum offline time with a default value of 30 days. ## Warning ### Client Maximum Offline Time Causes Permanent Changes to History Client maximum offline time enables advanced backend compaction for older history. This kind of compaction permanently changes affected history, and can cause client resets in the future even after disabling the feature. ### Key Concepts Sync should always converge at the same end state on all clients. In order to converge during a sync, clients require the full history of changes beginning immediately after their last sync. When a client does not sync for a long period of time, advanced backend compaction can alter the history in ways that prevent the client from converging. Since synchronization relies on all clients converging on a common result, such a client cannot synchronize. ## Example Consider the following example that contains a CREATE and a DELETE for`table2.object2`: Original History ``` CREATE table2.object2 CREATE table1.object1 DELETE table2.object2 \n``` When this history becomes older than the client maximum offline time, advanced backend compaction optimizes the backend history into the following: Advanced Compacted History ``` CREATE table1.obj1 \n``` However, a client contains this subset of history, containing only the CREATE operation for `table2.object2`: Partial Client History ``` CREATE table2.object2 CREATE table1.object1 \n``` Since compaction pruned the DELETE operation for `table2.object2`, the client will never delete that object. The client cannot converge to the same state as the backend and all other clients. As a result, the client must complete a client reset before it can resume synchronization. In a client reset scenario, the client deletes the client-local copy of a realm and downloads the current state of that realm from the backend. Synchronization then resumes using the new copy of the realm. The client maximum offline time controls how long your backend waits before applying advanced backend compaction. After the specified number of days without syncing, clients may experience a client reset the next time they connect with the backend. Applications that do not specify the client maximum offline time never apply advanced backend compaction. This means that clients can connect after any period of time offline -- weeks, months, or even years -- and synchronize changes. As time passes, frequently-edited realms accumulate many changes. With a large changeset, synchronization requires more time and data usage. ### Client Maximum Offline Time Does Not Immediately Influence Client Resets Advanced backend compaction causes permanent, irreversible changes to history. As a result, increasing the client maximum offline time does not _immediately_ change the length of time before clients experience a client reset. Existing history has already been changed by advanced compaction, requiring a client reset. New history needs time to accumulate up to the new client maximum offline time. Disabling the client maximum offline time feature stops additional advanced backend compaction, but history that has already been changed by advanced compaction will permanently cause client resets in clients. Decreasing client maximum offline time also does not _immediately_change the length of time before clients experience a client reset. Client resets begin taking place earlier once the regularly scheduled compaction job applies advanced backend compaction to the newly eligible history. ### Set the Client Maximum Offline Time ## Optimizing Performance and Storage When Using Flexible Sync For Flexible Sync configuration, the amount of Atlas storage space used is directly proportional to the number of queryable fields you have set up. Queryable fields use storage on the backing Atlas cluster. The more queryable fields you configure, the more storage you use on the backing cluster.\n\n ## Example Your app may contain 20 or 30 collections, but you want to minimize the number of queryable fields. You can re-use queryable fields across collections in order to sync objects from every collection. For example, \"owner\\_id\" might be a field you want to query in multiple collections, but by having the same field name across collections, only one queryable field is used. For best performance, open a synced realm with a broad query. Then, add more refined queries to expose targeted sets of data in the client application. Slicing off working sets from a broad query provides better performance than opening multiple synced realms using more granular queries. When you configure queryable fields, consider the broad queries you use for Sync, and select fewer fields that support those broad queries. ## Example In a to-do list app, prefer broad queries such as `assignee == currentUser`or `projectName == selectedProject` for a Sync query. This gives you a couple of broad fields against which to Sync documents. In the client, you can further refine your query for things like tasks of a certain priority or completion status to slice off a working set. ## Summary * Device Sync uses space in your synced Atlas cluster to store change history.\n* Backend compaction reduces the space usage of this history.\n* Advanced backend compaction reduces the space usage of this history even more, but can cause client resets for clients who have not connected to the backend in more than the client maximum offline time (in days).\n* Apps that do not specify a client maximum offline time do not apply advanced backend compaction, so clients of any age can sync without experiencing a client reset.\n* Adding additional queryable fields to a flexible sync configuration will increase storage consumed on an Atlas Cluster. Using broad queries and selecting fewer fields that support broad queries decreases storage consumed. ← [Sync Production Load Testing](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/production-load-testing/ \"Previous Section\")[Compact an Atlas Volume](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/compact-disk/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure and Enable Atlas Device Sync On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Procedure](#procedure) ## Overview You can configure and enable Atlas Device Sync via the App Services UI, Realm CLI, or the Atlas App Services Admin API. You can update an existing configuration in the same way. If it is your first time enabling Device Sync, the UI is a great choice because it walks you through the required steps. You might want to alter your Atlas Device Sync configuration after you have already enabled Device Sync. You can update a configuration using the same procedure as enabling Device Sync in the first place. If you're using Flexible Sync mode, you can update your configuration without needing to terminate and re-enable Sync. If you're re-enabling Device Sync after pausing or terminating it, refer to[Resume](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-resume-sync) or [Re-Enable](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-re-enable-realm-sync) Device Sync. If you are using the older Partition-Based Sync mode, refer to[Alter Your Partition-Based Sync Configuration.](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-alter-partition-based-sync-config) ## Prerequisites If you haven't already decided how you want to configure your data model, see[Sync Data Model Overview.](https://mongodb.com/docs/atlas/app-services/sync/data-model/sync-schema-overview/#std-label-sync-schema-overview) Unless you are using [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode), you must specify at least one valid [schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) for a collection in the synced cluster before enabling Sync. At a minimum, the schema must define`_id` as a primary key. You should also include the field(s) you intend to use as your [queryable fields.](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields) For more details on how to define a schema, see [Enforce a Schema.](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) ## Procedure ## Note ### Flexible Sync Prerequisites Enabling Flexible Sync in Your App Services Application requires a non-sharded MongoDB Atlas cluster running [MongoDB 5.0 or greater](https://www.mongodb.com/docs/manual/release-notes/) ← [Configure Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure-device-sync/ \"Previous Section\")[Sync Settings](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Sync Settings On this page * [Available Settings](#available-settings)\n* [Sync Type](#sync-type)\n* [Development Mode](#development-mode)\n* [Cluster to Sync](#cluster-to-sync)\n* [Database Name (Development Mode Only)](#database-name--development-mode-only-)\n* [Queryable Fields](#queryable-fields)\n* [Permissions](#permissions)\n* [Asymmetric Sync](#asymmetric-sync)\n* [Client Max Offline Time](#client-max-offline-time)\n* [Client Recovery](#client-recovery)\n* [Sync Configuration File Reference](#sync-configuration-file-reference)\n* [Sync Config Object](#sync-config-object) This page explains the settings available when you [enable or configure Device Sync.](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) ## Available Settings ### Sync Type Atlas Device Sync has two sync modes: Flexible Sync and the older Partition-Based Sync. We recommend using Flexible Sync. For information about Partition-Based Sync, refer to [Partition-Based Sync.](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync) Flexible Sync lets you define a query in the client and sync only the objects that match the query. With client-side subscriptions, client applications can: * Maintain queries\n* React to changes\n* Add, change, or delete queries ### Development Mode **Development Mode** is a configuration setting that allows Device Sync to infer and update schemas based on client-side data models. This streamlines development, but should not be used in production. Development Mode speeds up development by allowing you to design [schemas](https://mongodb.com/docs/atlas/app-services/sync/configure-your-data-model/#std-label-configure-your-data-model) directly in client application code. When you sync a realm file, Atlas App Services maps every synced object type to its own collection in the database specified by[Database Name (Development Mode Only)](#std-label-sync-config-database-name). If you update the object model on the client side, App Services updates the collection schema to match. This lets you update objects in your client code as you develop your app. You can use [data access rules](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-sync-rules) with Development Mode. Note that schema changes ignore data access rules. This means that any client can update the backend schema by changing the client model. To learn more about how the Realm Object Schemas map to the App Services Schemas when using Development Mode, refer to [Data Model Mapping.](https://mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/#std-label-sync-data-model-mapping) For more information about modifying synced object schemas, including how to handle breaking changes, see: [Update Your Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) ## Important ### Disable Development Mode for Production Apps Development mode is a development utility that is not suitable for production use. Make sure that you turn off Development Mode before you make your app accessible in a production environment. ### Cluster to Sync The name of the Atlas cluster [data source](https://mongodb.com/docs/atlas/app-services/reference/config/data%5Fsources/#std-label-appconfig-data%5Fsources) where you want the synced data stored. Flexible Sync requires MongoDB 5.0\\. You cannot use Sync with a [serverless instance](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-serverless-caveats). In the UI, clusters display as gray and not-selectable when they do not meet the requirements for Flexible Sync. ### Database Name (Development Mode Only) When you enable [Development Mode](#std-label-development-mode), you specify a database to store synced objects. App Services creates new collections in this Development Mode database for every type of synced object. ## Example\n\n App Services continues creating new server-side schemas and collections for each new object type. If you later add a `Dog` object, that object will sync to a new `myapp.Dog` collection that App Services will create. ### Queryable Fields When you configure Flexible Sync, you specify field names that your client application can query. Fields that can be used in a subscription query are called **queryable fields**. You can automatically specify queryable fields by enabling [Development Mode](#std-label-development-mode). Development Mode allows App Services to automatically mark fields as queryable as they are used. Queryable fields apply across all collections in an App's Schema. You can use [rules and permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-flexible-sync-rules-and-permissions) to configure more granular access control on individual collections. The field names you provide are arbitrary strings. If an object type has a field whose name matches a field name you provided (and meets other eligibility criteria), that field becomes available to Device Sync to query. ## Example In a to-do list app, you might set `assignee` or `owner`as queryable fields. On the client side, you can then query for tasks whose `assignee` or `owner` matches the logged-in user. #### Eligible Field Types Flexible Sync only supports top-level primitive fields with a scalar type as queryable fields. You can also include arrays of these primitives as queryable fields. Flexible Sync does not support embedded objects or arrays of objects as queryable fields. ## Tip ### See also: Realm Query Language - Flexible Sync Limitations For information on the queries you can perform on these fields, see:[Flexible Sync RQL Limitations](https://www.mongodb.com/docs/realm/realm-query-language/#std-label-flexible-sync-rql-limitations) #### Reserved Field Names App Services reserves some keywords for the Realm Query Language and other purposes. You cannot use reserved keywords as field names. App Services reserves the following keywords with any capitalization: | andascascendingbeginswithbetweencontainsdescdescending | distinctendswithfalsepredicateinfinfinitylikelimit | nannilnullorsortsubquerytruepredicate |\n| ------------------------------------------------------ | -------------------------------------------------- | ------------------------------------- | ## Example You cannot use `descending`, `Descending`, `DESCENDING`, or`DeScEnDiNG` as a field name. App Services also reserves the following keywords with the given exact capitalization: | ALLANYB64FALSEINNONENOT | SOMETRUEallanyfalsein | nonenotoidsometrueuuid |\n| ----------------------- | --------------------- | ---------------------- | ## Example You cannot use `true` or `TRUE`, since both capitalizations are specifically reserved, but you can use `True` or `tRUE` as a field name. #### Performance and Storage Each queryable field adds additional metadata storage to your Atlas cluster and may lead to degraded write performance. You should have as few queryable fields as needed by your application. A good rule of thumb is to have at most 10 queryable fields. ## Tip ### See also:  Learn more about [optimizing performance and storage when using Flexible Sync.](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-optimizing-performance-and-storage-flexible-sync) #### Consequences of Adding or Removing Queryable Fields You can [update your Sync configuration](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-alter-your-sync-configuration) to add or remove queryable field names, but be aware of the following: When you add a queryable field, devices can only sync on that field once the device has caught up to the point in time in [Device Sync History](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-sync-history) where the field was added.\n\n ### Permissions Atlas Device Sync enforces role-based data access rules for all requests to a synced cluster. Rules are dynamic [JSON expressions](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that determine a user's ability to sync, view, and modify data. For details, see [Role-based Permissions.](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-sync-permissions) ### Asymmetric Sync Asymmetric Sync is a sync strategy for applications with heavy client-side insert-only workloads. You can enable it for one or more collections. It supports writing to any collection type, including an Atlas time-series collection. For example, an IoT app that frequently logs sensor data has a significant write workload and no read workload. The device may also be offline for extended periods of time. Asymmetric Sync bypasses some of the processing required for bi-directional sync, significantly improving write speed to an Atlas collection. Other use cases include writing immutable data, such as invoices from a retail app, or logging application events, neither of which requires conflict resolution. You can apply Asymmetric Sync to individual collections. This means your app can use Asymmetric Sync to write some data, but bi-directional Flexible Sync on other collections. Asymmetric Sync collections are only for writing data. You cannot use Flexible Sync queries against these collections. Instead, use [Connect to MongoDB Data Sources.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) After you have enabled Asymmetric Sync, you implement it in the client app via the client SDKs. Currently, the following Realm SDKs support Asymmetric Sync: * C++ SDK: [Stream Data to Atlas - C++ SDK (Alpha)](https://www.mongodb.com/docs/realm/sdk/cpp/sync/stream-data-to-atlas/#std-label-cpp-stream-data-to-atlas)\n* .NET SDK: [Unidirectional Data Sync - .NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/sync/asymmetric-sync/#std-label-dotnet-asymmetric-sync)\n* Node.js SDK: [Define an Asymmetric Object](https://www.mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-define-an-asymmetric-object)\n* React Native SDK: [Define an Asymmetric Object - React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/schemas/asymmetric-object/#std-label-react-native-define-an-asymmetric-object)\n* Swift SDK: [Stream Data to Atlas - Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/sync/stream-data-to-atlas/#std-label-swift-stream-data-to-atlas) ### Client Max Offline Time Client Maximum Offline Time determines how long the client can be offline between sync sessions. Changing this value enables you to balance offline access with storage used in the synced Atlas cluster. For more information, refer to[Client Maximum Offline Time.](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/optimize-sync-atlas-usage/#std-label-client-maximum-offline-time) ### Client Recovery Client Recovery enables the client to attempt to automatically perform a client reset while recovering data on the device. For more information, refer to[Recover Unsynced Changes.](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-recover-unsynced-changes) ## Sync Configuration File Reference You can find the Sync configuration file for your application in the `sync`directory of an [exported](https://mongodb.com/docs/atlas/app-services/apps/export/#std-label-export-app) app: `| app/            |\n| --------------- |\n| └── sync/       |\n| └── config.json | `\n\n sync/config.json ``` {   \"type\": \"flexible\",   \"development_mode_enabled\": <Boolean>,   \"service_name\": \"<Data Source Name>\",   \"database_name\": \"<Development Mode Database Name>\",   \"state\": <\"enabled\" | \"disabled\">,   \"client_max_offline_days\": <Number>,   \"is_recovery_mode_disabled\": <Boolean>,   \"queryable_fields_names\": [     <Array of String Field Names>   ],   \"permissions\": \"<Deprecated, Do Not Use>\" } \n``` The deprecated `permissions` field might still appear in your exported app's configuration. That might indicate your app has not automatically migrated to the [unified rule system yet](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/#std-label-unified-rule-migration). Please avoid deleting this field until your app has been migrated. ### Sync Config Object\n\n ← [Configure and Enable Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/ \"Previous Section\")[Pause or Terminate Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Pause or Terminate Sync On this page * [Overview](#overview)\n* [Pause Sync](#pause-sync)\n* [Procedure](#procedure)\n* [Resume Sync](#resume-sync)\n* [Procedure](#procedure-1)\n* [Terminate Sync](#terminate-sync)\n* [Procedure](#procedure-2)\n* [Re-Enable Sync](#re-enable-sync)\n* [Procedure](#procedure-3) ## Overview If you want to disable Atlas Device Sync for your app, you can temporarily pause or permanently terminate it. You can also re-enable Device Sync after disabling it. You can temporarily [pause](#std-label-pause-sync) Device Sync if you need to pause your cluster. With a temporary pause, you can[resume](#std-label-resume-sync) without resetting your [Device Sync configuration](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-appconfig-sync) or losing Device Sync metadata. You can permanently [terminate](#std-label-terminating-realm-sync) and[re-enable](#std-label-re-enable-realm-sync) Device Sync for troubleshooting or if you want to change your [Device Sync configuration.](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-appconfig-sync) ## Pause Sync You can pause Device Sync for a period of time without disabling it entirely. When you pause Device Sync, you stop syncing changes between Atlas and your application. ## Important If you need to pause your cluster, pause Device Sync first. Otherwise, you must [terminate](#std-label-terminating-realm-sync) and [re-enable](#std-label-re-enable-realm-sync) Device Sync and perform a client reset. Pausing Device Sync rejects any incoming client connections. This means that pausing Device Sync for your App stops syncing changes for all clients. To pause Device Sync from the client side, using logic that situationally pauses Device Sync during a session, see your preferred SDK: After pausing Device Sync, you can [re-enable it](#std-label-resume-sync). Pausing Device Sync maintains the configuration settings and all of the Device Sync metadata, which contains the sync history. When you re-enable paused Device Sync, your clients can reconnect normally. ## Warning If your [oplog](https://www.mongodb.com/docs/manual/core/replica-set-oplog/) rolls past the time that you paused Device Sync, you must terminate and re-enable Device Sync. For example, if you only keep 12 hours of oplog for your cluster, and you pause Device Sync for longer than 12 hours, you must terminate and re-enable Device Sync. Terminating and re-enabling paused Atlas Device Sync for your App erases Atlas Device Sync metadata and requires you to specify configuration settings again. Clients must perform a client reset when they reconnect after Atlas Device Sync has been terminated. For more information, see: [Terminate Sync.](#std-label-terminating-realm-sync) ### Procedure 1 #### Press the Pause Sync Button In the Device Sync tab of the App Services UI, press thePause Sync button. ![the pause sync button](https://mongodb.com/docs/atlas/app-services/images/press-pause-sync-button.png) 2 #### Confirm That You Want to Pause Sync In the modal that pops up, press the Pause Sync button. ![the pause sync model](https://mongodb.com/docs/atlas/app-services/images/pause-sync-modal.png) 3 #### Review Your Changes Press the Review & Deploy button in the blue notification bar telling you that changes have been made to your App Services app. ![\"Review & Deploy\" notification](https://mongodb.com/docs/atlas/app-services/images/pause-sync-review-and-deploy.png) 4 #### Deploy Your App to Pause Sync In the model that appears, review your changes and then press the greenDeploy button. ![Review Changes Model](https://mongodb.com/docs/atlas/app-services/images/pause-sync-deploy-button.png)\n\n ![Review Changes Model](https://mongodb.com/docs/atlas/app-services/images/pause-sync-deployment-successful.png) ## Resume Sync After you have paused Device Sync, you can resume it to begin syncing again for all clients. ## Warning If your [oplog](https://www.mongodb.com/docs/manual/core/replica-set-oplog/) rolls past the time that you paused Device Sync, you must terminate and re-enable Device Sync. For example, if you only keep 12 hours of oplog for your cluster, and you pause Device Sync for longer than 12 hours, you must terminate and re-enable Device Sync. Terminating and re-enabling paused Atlas Device Sync for your App erases Atlas Device Sync metadata and requires you to specify configuration settings again. Clients must perform a client reset when they reconnect after Atlas Device Sync has been terminated. For more information, see: [Terminate Sync.](#std-label-terminating-realm-sync) ### Procedure The process to resume Device Sync is the same as the process to re-enable Device Sync. However, when you pause Device Sync, App Services preserves your configuration settings and Device Sync metadata. To re-enable Device Sync, follow the steps in the [Configure and Enable Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) guide. You can skip the **Configure Sync**step. Clients do not need to perform a client reset when reconnecting after a pause. ## Terminate Sync If you have [enabled Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync), you may have to terminate and re-enable Device Sync under a few different circumstances: * An upgrade from a Shared Tier Atlas Cluster to a Shared or Dedicated instance\n* A move to an Atlas cluster that is distributed across regions/cloud providers\n* An upgrade to NVMe Atlas clusters\n* An [oplog](https://www.mongodb.com/docs/manual/core/replica-set-oplog/) rollover\n* A paused Device Sync session on a shared tier cluster due to infrequent usage\n* Troubleshooting, at the request of MongoDB Support\n* Altering a Partition-Based Sync configuration\n* Switching between Sync modes. For instance, if you are switching from Partition-Based Sync to Flexible Sync\n* Dropping a collection you've used with Sync. For example, if you have a `Team` collection that stores and syncs `Team` objects, and then you drop that collection, you must terminate and re-enable Sync. ## Warning ### Restore Sync after Terminating Sync When you terminate and re-enable Atlas Device Sync, clients can no longer Sync. Your client must implement a client reset handler to restore Sync. This handler can discard or attempt to recover unsynchronized changes. ### Procedure Terminate Device Sync in your App to stop syncing data across devices. 1 #### Press the Terminate Sync Button In the Sync tab of the App Services UI, click the redTerminate Sync button. ![the terminate sync button](https://mongodb.com/docs/atlas/app-services/images/click-terminate-sync-button.png) 2 #### Confirm That You Want to Terminate Sync In the modal that pops up, check that you want to terminate sync by clicking the I want to terminate Sync checkbox and then click theTerminate Sync button on the modal. ![the terminate sync model](https://mongodb.com/docs/atlas/app-services/images/terminate-sync-model.png) 3 #### Review Your Changes Click the Review & Deploy button in the blue notification bar telling you that changes have been made to your App Services app. ![\"Review & Deploy\" notification](https://mongodb.com/docs/atlas/app-services/images/terminating-sync-review-and-deploy.png) 4 #### Deploy Your App to Terminate Sync In the model that appears, review your changes and then click the greenDeploy button. ![Review Changes Model](https://mongodb.com/docs/atlas/app-services/images/terminating-sync-deploy-button.png) You have now terminated Device Sync and should get a green notification bar on the top of the Sync page that states that your deployment was successful. ![Review Changes Model](https://mongodb.com/docs/atlas/app-services/images/terminating-sync-deployment-successful.png) ## Re-Enable Sync\n\n ### Procedure When you pause Device Sync, App Services preserves your configuration settings, and you can skip the **Configure Sync** step. When you terminate Device Sync, or when the [oplog](https://www.mongodb.com/docs/manual/core/replica-set-oplog/) rolls past the time that you paused Device Sync, you must specify the configuration settings again. To re-enable Device Sync, follow the steps in the [Configure and Enable Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) guide. If you are re-enabling Device Sync after you have terminated it, you must perform a client reset in your client applications: ← [Sync Settings](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/ \"Previous Section\")[Error Handling](https://mongodb.com/docs/atlas/app-services/sync/error-handling/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/local-to-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Add Sync to a Local-Only App On this page * [Overview](#overview)\n* [Create an App](#create-an-app)\n* [Enable Authentication](#enable-authentication)\n* [Choose a Sync Mode](#choose-a-sync-mode)\n* [Update the Client App](#update-the-client-app)\n* [Copy Existing Data](#copy-existing-data)\n* [App Logic](#app-logic) ## Overview If you have a mobile app that uses a local realm and you want to convert the app to use Sync, there are a few steps you need to follow. You first need to set up an App backend. Then, make code changes in your client applications. In the following sections, you will learn to do the following on the backend: 1. Create a new App in MongoDB Atlas,\n2. Configure at least one authentication provider\n3. Choose a Sync type. And then, in your client app, you will: 1. Update your Realm object models,\n2. Connect to the new synced realm with a sync configuration file,\n3. Authenticate the user. Finally, if needed, you will also need to copy your local data to the new synced realm. ### Create an App To sync your data between devices and MongoDB Atlas, you first need to create an App. This App provides a gateway to the data and data security in the form of user authentication, data encryption, and access control. To get started creating the backend app, follow the steps in[Create an App.](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) ### Enable Authentication Atlas Device Sync requires authenticated users. Atlas App Services provides many different [Authentication Providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) such as email/password and OAuth; once you have configured one or more providers, you can then control exactly who has access to which data. To set up an authentication provider, choose one of the providers and follow the configuration steps for the provider(s) of your choice. ### Choose a Sync Mode There are two Sync Modes: Flexible Sync and the older [Partition-Based Sync](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync). We recommend using Flexible Sync. With Flexible Sync, clients synchronize subsets of data based on queries to**queryable fields**. When configuring Flexible Sync, you decide which fields clients can query upon. Development Mode allows App Services to deduce the queryable fields based on your queries. To learn more, follow the steps in[Procedure.](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync) ## Update the Client App Now that you have the backend set up for Device Sync, you need to make a few changes in your client app. Follow the steps in the Quick Start for your language/platform: * [Quick Start with Sync - Java SDK](https://www.mongodb.com/docs/realm/sdk/java/quick-start-sync/#std-label-java-client-quick-start-sync)\n* [Quick Start - Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/quick-start/#std-label-ios-client-quick-start-with-sync)\n* [Quick Start - .NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/quick-start/#std-label-dotnet-client-quick-start)\n* [Quick Start - React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/quick-start/#std-label-react-native-client-quick-start)\n* [Quick Start - Node.js SDK](https://www.mongodb.com/docs/realm/sdk/node/quick-start/#std-label-node-client-quick-start) ## Copy Existing Data ## Note ### Alternate SDK Implementations Some SDKs support an easier implementation for adding sync to a local-only realm than the steps outlined on this section.\n\n None of the data in your local realm automatically transfers to a new synced realm [\\[1\\]](#footnote-f1). You must copy the data you want to preserve to the new realm. The following diagram and steps outline the process for copying all of the data from a local realm to a synced realm. | \\[[1](#ref-f1-id1)\\] | With the exception of apps migrated from local to synced realms using the easier implementations outlined in \"Alternate SDK Implementations\". |\n| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------- | ### App Logic ![Flow chart showing the steps to convert from local to sync](https://mongodb.com/docs/atlas/app-services/images/local_to_sync.png) 1. Check if a synced realm already exists.\n2. If not, create one. Open a connection to it and to the local realm.\n3. Read each record from the local realm and modify it to match the schema of the synced realm.\n4. Copy the modified record to the new synced realm. Sync automatically copies the record to MongoDB Atlas when connected to your App.\n5. Confirm that all records you want to preserve are in the new realm.\n6. Delete the local realm file.\n7. On each subsequent app load, check if the local realm has been deleted. ← [Stream Data Unidirectionally from a Client to Atlas](https://mongodb.com/docs/atlas/app-services/sync/app-builder/stream-data-from-client-to-atlas/ \"Previous Section\")[Event Library](https://mongodb.com/docs/atlas/app-services/sync/app-builder/event-library/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/stream-data-from-client-to-atlas/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Stream Data Unidirectionally from a Client to Atlas On this page * [Set up Atlas Access](#set-up-atlas-access)\n* [Create an Atlas App Services App](#create-an-atlas-app-services-app)\n* [Configure Device Sync and Asymmetric Sync](#configure-device-sync-and-asymmetric-sync)\n* [Enable an Authentication Provider](#enable-an-authentication-provider)\n* [Add Sync to the Client Application](#add-sync-to-the-client-application)\n* [Connect the client to an App Services backend](#connect-the-client-to-an-app-services-backend)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Create Asymmetric Objects and Write Data](#create-asymmetric-objects-and-write-data) If you have a mobile or client application that produces a large volume of data you'd like to stream to MongoDB Atlas, you can sync data unidirectionally using Device Sync. We call the feature that enables this unidirectional sync**Asymmetric Sync**. You might want to sync data unidirectionally in IoT applications, such as a weather sensor sending data to the cloud. Asymmetric sync is also useful for writing other types of immutable data where you do not require conflict resolution, such as creating invoices from a retail app or logging application events. Asymmetric Sync is optimized to provide performance improvements for heavy client-side _insert-only_ workloads. You cannot read this data from the realm where you're streaming it. Follow these high-level steps to get started: ## Set up Atlas Access 1 ### Create an Atlas App Services App The App Services application is the gateway that enables your client device to connect to MongoDB Atlas. When you create an App, you name it, link it to an Atlas cluster, and specify the deployment model and deployment region that work best for your application. To learn how to create an App Services App, see [Create an App.](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) 2 ### Configure Device Sync and Asymmetric Sync Device Sync is the service that synchronizes data to Atlas and across your client devices. Device Sync, together with the Realm SDKs, automatically manages network connectivity, user permissions, and conflict resolution. The App Services app provides the built-in user authentication that Device Sync and the Realm SDKs leverage to secure your data. When you configure Device Sync, you specify the data source that the client devices can access as well as the permissions that determine what data a user can write. You can configure Device Sync via the [Atlas UI, the Atlas App Services Command Line Interface, or the App Services Admin API](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync). The first time you configure Device Sync, you may find it helpful to use the Atlas UI as it provides links and information about various settings and options. To enable Asymmetric Sync for one or more collections, you select the collection or collections in the Advanced Configurationsection of your Device Sync configuration. Only collections with an [App Services Schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) are available to select in this drop-down. If you have not yet created a schema for the collection that you want to sync unidirectionally, you can either: * Generate an App Services schema from your Realm object model. Refer to: [Create an App Services Schema from a Realm Object Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/#std-label-create-schema-from-rom)\n* Manually create an App Services Schema. For more information, refer to: [Enforce a Schema.](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) 3 ### Enable an Authentication Provider Your client devices must authenticate in order to access synced data. App Services provides several authentication providers, such as email/password or anonymous authentication, to enable your users to authenticate. Configure one or more of these authentication providers to enable authentication in your client application.\n\n ## Add Sync to the Client Application After this, you've got everything set up that you need on the Atlas side, and you can prepare your client application to sync data unidirectionally. 1 ### Connect the client to an App Services backend In your client application code, initialize an App client to connect your client to your App Services backend. This lets your client use App Services features like authentication, and enables opening a synced realm. 2 ### Authenticate a User Your client application user must be authenticated with the App Services backend in order to write synchronized data. Add logic to your client app to register and log in users. 3 ### Open a Synced Realm Once you have an authenticated user, you can open a synced instance of Realm Database to use for that user. Because Asymmetric Sync is write-only, you cannot define a Flexible Sync query to read data on the device. This differs from bidirectional Flexible Sync, where you would create a query subscription to determine what data to sync to the device. 4 ### Create Asymmetric Objects and Write Data The Realm SDKs provide a special type of object to use with Asymmetric Sync: an Asymmetric Object. Refer to the Realm SDK documentation for details on how to define Asymmetric Objects. Create and write Asymmetric Objects to a synced realm, and the Realm SDKs use Device Sync manage the process of streaming the data automatically. When the device has a network connection, the SDKs stream data to the App Services backend and into Atlas. When the device does not have a network connection, the data persists on the device and automatically uploads when the network connection is restored. ← [Sync Data in a Client Application with Atlas and Other Devices](https://mongodb.com/docs/atlas/app-services/sync/app-builder/sync-data-in-client-with-atlas/ \"Previous Section\")[Add Sync to a Local-Only App](https://mongodb.com/docs/atlas/app-services/sync/app-builder/local-to-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/errors/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Sync Errors On this page * [Overview](#overview)\n* [Sync Protocol Errors](#sync-protocol-errors)\n* [Partition-Based Sync Errors](#partition-based-sync-errors)\n* [Flexible Sync Errors](#flexible-sync-errors)\n* [MongoDB Translator Errors](#mongodb-translator-errors)\n* [MongoDB Connection Errors](#mongodb-connection-errors)\n* [Sync Client Errors](#sync-client-errors)\n* [Handle Sync Errors](#handle-sync-errors)\n* [Set the Client Log Level](#set-the-client-log-level) ## Overview While you develop applications using Atlas Device Sync, you may run into errors. This section lists common errors and describes how to and handle them. ## Note If you encounter an error not listed on this page, you can file a [support ticket](https://support.mongodb.com/welcome). ## Sync Protocol Errors The following table describes [Device Sync protocol](https://mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-sync-protocol)errors and how to handle them. Atlas App Services reports errors in your[Device Sync logs.](https://mongodb.com/docs/atlas/app-services/logs/)\n\n ### Partition-Based Sync Errors The following errors may occur when your App uses [Partition-Based Sync.](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync) | Error Name            | Description                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| ErrorIllegalRealmPath | This error indicates that the client attempted to open a realm with a partition value of the wrong type. For example, you might see the error message \"attempted to bind on illegal realm partition: expected partition to have type objectId but found string\".To recover from this error, ensure that the type of the partition value used to open the realm matches the partition key type in your Device Sync configuration. | ### Flexible Sync Errors The following errors may occur when your App uses [Flexible Sync.](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-flexible-sync)\n\n ## MongoDB Translator Errors The following errors may occur in the translation process between Device Sync and MongoDB Atlas.\n\n ## MongoDB Connection Errors If you enable Device Sync on a newly-created cluster, the operation may fail to parse the cluster URI. This happens because an SRV record for the cluster hasn't propagated yet. There are two possible workarounds, either: * Wait five minutes, then enable Atlas Device Sync.\n* Unlink and [re-link the cluster.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-link-a-data-source) ## Sync Client Errors The [sync protocol](https://mongodb.com/docs/atlas/app-services/sync/details/protocol/#std-label-sync-protocol) returns an [ERROR](https://mongodb.com/docs/atlas/app-services/sync/details/protocol/#mongodb-sync-server-message-ERROR)message when an error appears to have been caused by a connected client. Each message contains a code number and a description of the error. To see the full list of sync errors, refer to the [error code list](https://github.com/realm/realm-core/blob/master/doc/protocol.md#error-codes) in the Realm Database Core GitHub repository. ## Handle Sync Errors Every application that uses Sync needs a sync error handler. To learn more about sync error handling, see your preferred SDK: ## Set the Client Log Level You can specify the client log level. Setting the log level to `trace` or`debug` can help diagnose issues while your application is is in development. You can log general information or details about all sync events, or log only warnings or errors. ## Important Verbose logging negatively impacts performance. For production deployment, reduce the log level. For more information about available log levels, including how to set the client log level, see your preferred SDK. ← [Client Resets](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/ \"Previous Section\")[Go to Production with Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/go-to-production/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Client Resets On this page * [Overview](#overview)\n* [Handle a Client Reset](#handle-a-client-reset)\n* [Recover Unsynced Changes](#recover-unsynced-changes)\n* [Discard Unsynced Changes](#discard-unsynced-changes)\n* [Manual Client Reset](#manual-client-reset)\n* [Examples](#examples)\n* [Enable or Disable Recovery Mode](#enable-or-disable-recovery-mode) ## Overview A **client reset error** is a scenario where a client realm cannot sync data with the application backend. Clients in this state may continue to run and save data locally but cannot send or receive sync changesets until they perform a client reset. The Realm SDKs provide methods to automatically handle client resets under most scenarios. ## Warning By default, the client reset process attempts to recover unsynced changes that were successfully saved locally. When your client application has breaking schema changes, or if [Recovery Mode](#std-label-recover-unsynced-changes)is disabled on the server, the client reset process cannot recover unsynced data that may be persisted locally on the device. Client reset scenarios occur when the server's history is incompatible with the client's history. The most common causes of client resets are:\n\n ## Handle a Client Reset The SDKs automatically detect the need for client resets. They can automatically perform a client reset in most cases, except in the event of a breaking schema change. During an automatic client reset, the client: 1. Downloads a fresh copy of the realm from the backend.\n2. Performs a diff to figure out the steps required to bring the original (local) copy of the realm to the same state as the fresh copy of the backend.\n3. Applies that set of steps to transform the local realm into a state where it can sync with the backend.  \nIf there are no schema changes, or only non-breaking schema changes, the SDK attempts to recover all local changes that have not yet synced to the backend. It also applies any inserts, updates, and deletes from the backend that haven't yet synced to the client.  \nIf you have chosen to discard unsynced changes in the SDK, or if Recovery Mode cannot recover unsynced changes, the SDK can discard local changes that have not yet synced to the backend. Then it can apply any inserts, updates, and deletes from the backend that haven't yet synced to the client. To fall back to discard local changes, choose your preferred SDK's version of the `recoverOrDiscard` client reset mode.\n4. Discards the fresh copy. The app continues to use the original copy of the realm with the diff applied. In a breaking schema change, or if automatic client reset fails, the client reset falls back to a [manual client reset handler](#std-label-manual-client-reset)that your app must define. The Realm SDKs cannot automatically perform a client reset when you make a breaking schema change. Automatic client reset mode has several advantages compared to manual recovery: * Your application can perform a client reset without writing any custom logic, other than specifying the mode. You don't have to manually initiate the client reset or interact with the error object at all.\n* Your application can perform a client reset without closing any realms, disconnecting from the backend app, or manual restarts. This means you don't have to write any logic to handle these situations.\n* Application users receive notifications for changes as the local realm updates to match the state of the backend realm. ### Recover Unsynced Changes When **Client Recovery** is enabled in your Device Sync configuration - as it is by default - client applications can automatically recover unsynced changes. In most scenarios, the client application can detect that a client reset error has occurred and start an automated process to handle the client reset. After the client reset, the app can open and operate as usual. Client Recovery can recover unsynced data in client resets except where there has been a breaking schema change. Client Recovery applies[Client Reset Recovery Rules](#std-label-client-reset-recovery-rules) when determining how to integrate unsynced data from the device. You can choose to fall back to [Discard Unsynced Changes](#std-label-discard-unsynced-changes) in the event that the client cannot recover unsynced data. In this case, local data is discarded, but the client can automatically perform the client reset. To fall back to discard local changes, choose your preferred SDK's version of the `recoverOrDiscard` client reset mode. #### Client Reset Recovery Rules In a client reset that does not involve a breaking schema change, the Realm SDKs attempt to recover unsynced changes. The SDK integrates objects created locally that did not sync before the client reset. These rules determine how conflicts are resolved when both the backend and the client make changes to the same object: * If an object is deleted on the server, but is modified on the recovering client, the delete takes precedence and the client discards the update.\n* If an object is deleted on the recovering client, but not the server, then the client applies the delete instruction.\n* In the case of conflicting updates to the same field, the client update is applied. ### Discard Unsynced Changes ## Warning ### Deletes Unsynced Local Changes Permanently This client reset mode permanently deletes any changes made locally that have not yet synchronized to the backend. Do not use this client reset mode if your application needs to preserve unsynced changes.\n\n Discard Unsynced Changes mode cannot perform an automated client reset in the event of a breaking schema change. ### Manual Client Reset In the event of [a breaking schema change](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-breaking-change-quick-reference), Realm SDKs cannot automatically handle a client reset. You must define a manual client reset handler if you make breaking schema changes. In this scenario, a manual client reset handler should do something like tell the user to update the app. In Realm SDK versions that automatically handle client resets, a manual client reset only occurs in error scenarios where no meaningful recovery can occur. ### Examples For more information on performing a client reset, check out the client reset examples for your SDK: ## Enable or Disable Recovery Mode Recovery Mode is enabled by default in every Device Sync configuration. You can disable Recovery Mode, or re-enable it if you have previously disabled it. ← [Error Handling](https://mongodb.com/docs/atlas/app-services/sync/error-handling/ \"Previous Section\")[Sync Errors](https://mongodb.com/docs/atlas/app-services/sync/error-handling/errors/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/sync-data-in-atlas-with-client/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Sync Data in Atlas with a Client Application On this page * [Set up Atlas Access](#set-up-atlas-access)\n* [Create an Atlas App Services App](#create-an-atlas-app-services-app)\n* [Configure Device Sync](#configure-device-sync)\n* [Enable an Authentication Provider](#enable-an-authentication-provider)\n* [Generate Client Object Models](#generate-client-object-models)\n* [Add Sync to the Client Application](#add-sync-to-the-client-application)\n* [Connect the client to an App Services backend](#connect-the-client-to-an-app-services-backend)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Use the Synced Realm](#use-the-synced-realm) If your organization already has data in MongoDB Atlas, you can sync that data to client devices using Device Sync and Realm Database. Follow these high-level steps to get started: ## Set up Atlas Access 1 ### Create an Atlas App Services App The App Services application is the gateway that enables your client device to connect to MongoDB Atlas. When you create an App, you name it, link it to an Atlas cluster, and specify the deployment model and deployment region that work best for your application. To learn how to create an App Services App, see [Create an App.](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) 2 ### Configure Device Sync Device Sync is the service that manages synchronizing your Atlas data with your client devices. Device Sync, together with the Realm SDKs, automatically manages network connectivity, conflict resolution, user authentication, and user permissions and data access. When you configure Device Sync, you specify the data source that the client devices can access, as well as the permissions that determine what data a user can read and write. You can configure Device Sync via the [Atlas UI, the Atlas App Services Command Line Interface, or the App Services Admin API](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync). The first time you configure Device Sync, you may find it helpful to use the Atlas UI as it provides links and information about various settings and options. 3 ### Enable an Authentication Provider Your client users must authenticate in order to access synced data. App Services provides several authentication providers to enable your users to authenticate. Configure one or more of these authentication providers to enable authentication in your client application. You can configure authentication providers within the App Services App UI by selecting Authentication in the left navigation menu, and then click a provider to configure it. You can also configure authentication providers by editing the App Services configuration with the [Atlas App Services Command Line Interface](https://mongodb.com/docs/atlas/app-services/reference/config/auth/#std-label-appconfig-auth), or the [App Services Admin API.](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#tag/authproviders) 4 ### Generate Client Object Models When you already have data in Atlas, you can generate object models that match that data to use in your client application. To generate an object model, you must have an App Services schema. Once you have a schema, you can generate object models that match that schema. You can select a programming language to use to generate the schema, which you can then view and copy to use in your client application code. You can generate a schema from existing Atlas data using the App Services UI. For more information on how to do this, refer to:[Create a Realm Object Schema from an App Services Schema.](https://mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/#std-label-create-rom-from-schema) Once you have a schema, you can generate a Realm object model using the [App Services UI or the Atlas App Services Command Line Interface.](https://mongodb.com/docs/atlas/app-services/sync/data-model/generate-sdk-object-models/#std-label-generate-sdk-object-models) ## Add Sync to the Client Application\n\n 1 ### Connect the client to an App Services backend In your client application code, initialize an App client to connect your client to your App Services backend. This lets your client use App Services features like authentication, and enables opening a synced realm. 2 ### Authenticate a User Your client application user must be authenticated with the App Services backend in order to access synchronized data. Add logic to your client app to register and log in users. 3 ### Open a Synced Realm Once you have an authenticated user, you can open a synchronized instance of Realm Database to use for that user. You define a Flexible Sync query subscription in your client code to determine what data to sync to the client application. Device Sync looks for Atlas documents that match the query, which the user has permission to read and possibly write, and synchronizes those documents to the client device as Realm objects. You can add, remove, or update Flexible Sync query subscriptions to change the documents that sync to the device. 4 ### Use the Synced Realm The syntax to read, write, and watch for changes on a synced realm is identical to the syntax for non-synced realms. While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. When a user who has write permissions makes changes on the device, the data persists locally. When the user has a network connection, the data automatically syncs back to Atlas and other devices. For a quick guide to how to do common tasks with Realm Database, refer to the Realm SDK quick starts. If you prefer to study a working client app to learn, some of the SDKs provide [a working Device Sync app](https://mongodb.com/docs/atlas/app-services/reference/template-apps/#std-label-template-apps), which we call template apps. Optionally, you can go through SDK-specific tutorials that build on the Device Sync template app. ← [Device Sync Permissions Guide](https://mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/ \"Previous Section\")[Sync Data in a Client Application with Atlas and Other Devices](https://mongodb.com/docs/atlas/app-services/sync/app-builder/sync-data-in-client-with-atlas/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/sync-data-in-client-with-atlas/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Sync Data in a Client Application with Atlas and Other Devices On this page * [Set up Atlas Access](#set-up-atlas-access)\n* [Create an Atlas App Services App](#create-an-atlas-app-services-app)\n* [Configure Device Sync](#configure-device-sync)\n* [Enable an Authentication Provider](#enable-an-authentication-provider)\n* [Generate an App Services Schema](#generate-an-app-services-schema)\n* [Add Sync to the Client Application](#add-sync-to-the-client-application)\n* [Connect the client to an App Services backend](#connect-the-client-to-an-app-services-backend)\n* [Authenticate a User](#authenticate-a-user)\n* [Open a Synced Realm](#open-a-synced-realm)\n* [Copy Existing Data Into a Synced Realm](#copy-existing-data-into-a-synced-realm)\n* [Use the Synced Realm](#use-the-synced-realm) If you have a mobile or client application that uses Realm Database, and you would like to synchronize its data across other devices and back it up to MongoDB Atlas, you can do so using Device Sync. Follow these high-level steps to get started: ## Set up Atlas Access 1 ### Create an Atlas App Services App The App Services application is the gateway that enables your client device to connect to MongoDB Atlas. When you create an App, you name it, link it to an Atlas cluster, and specify the deployment model and deployment region that work best for your application. To learn how to create an App Services App, see [Create an App.](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) 2 ### Configure Device Sync Device Sync is the service that manages synchronizing data to Atlas and across your client devices. Device Sync, together with the Realm SDKs, automatically manages network connectivity, conflict resolution, user authentication, and user permissions and data access. When you configure Device Sync, you specify the data source that the client devices can access, as well as the permissions that determine what data a user can read and write. You can configure Device Sync via the [Atlas UI, the Atlas App Services Command Line Interface, or the App Services Admin API](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-flexible-sync). The first time you configure Device Sync, you may find it helpful to use the Atlas UI as it provides links and information about various settings and options. 3 ### Enable an Authentication Provider Your client users must authenticate in order to access synced data. App Services provides several authentication providers to enable your users to authenticate. Configure one or more of these authentication providers to enable authentication in your client application. You can configure authentication providers within the App Services App UI by selecting Authentication in the left navigation menu, and then click a provider to configure it. You can also configure authentication providers by editing the App Services configuration with the [Atlas App Services Command Line Interface](https://mongodb.com/docs/atlas/app-services/reference/config/auth/#std-label-appconfig-auth), or the [App Services Admin API.](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#tag/authproviders) 4 ### Generate an App Services Schema When you already have a client application that uses Realm Database, you can use your Realm Object Model to generate the App Services Schema that maps data between client devices and Atlas. You can do this by enabling Development Mode, a feature that reads your object model data from synced realm data, and generates a schema from that data. For more information on how to generate an App Services schema from your Realm object model, refer to: [Create an App Services Schema from a Realm Object Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/#std-label-create-schema-from-rom) ## Add Sync to the Client Application After this, you've got everything set up that you need on the Atlas side, and you can prepare your client application to sync data. If you already have a client application that persists data using Realm Database, you only need to add a few elements to synchronize that data across devices and with Atlas. 1\n\n In your client application code, initialize an App client to connect your client to your App Services backend. This lets your client use App Services features like authentication, and enables opening a synced realm. 2 ### Authenticate a User Your client application user must be authenticated with the App Services backend in order to access synchronized data. Add logic to your client app to register and log in users. 3 ### Open a Synced Realm Once you have an authenticated user, you can open a synchronized instance of Realm Database to use for that user. You define a Flexible Sync query subscription in your client code to determine what data to sync to the client application. Device Sync looks for Atlas documents that match the query, which the user has permission to read and possibly write, and synchronizes those documents to the client device as Realm objects. You can add, remove, or update Flexible Sync query subscriptions to change the documents that sync to the device. 4 ### Copy Existing Data Into a Synced Realm If you already have client data, you cannot add Device Sync directly to a non-synced realm. You must copy the data from the non-synced realm into the synced realm. If you do not have any client data, you can skip this step. Some of the SDKs provide methods that enable you to do this when you open a realm. However, many of the Realm SDKs do not currently support using these methods with Flexible Sync. If your SDK does not support copying a local realm to a Flexible Sync realm, you must write logic to iterate over each object in the non-synced realm and copy it into the synced realm. This is a one-time process. After you copy the data over, you can discard the non-synced Realm and open only the synced realm going forward. 5 ### Use the Synced Realm The syntax to read, write, and watch for changes on a synced realm is identical to the syntax for non-synced realms. While you work with local data, a background thread efficiently integrates, uploads, and downloads changesets. When a user who has write permissions makes changes on the device, the data persists locally. When the user has a network connection, the data automatically syncs back to Atlas and other devices. ← [Sync Data in Atlas with a Client Application](https://mongodb.com/docs/atlas/app-services/sync/app-builder/sync-data-in-atlas-with-client/ \"Previous Section\")[Stream Data Unidirectionally from a Client to Atlas](https://mongodb.com/docs/atlas/app-services/sync/app-builder/stream-data-from-client-to-atlas/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/event-library/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Event Library On this page * [Overview](#overview)\n* [Use Case](#use-case)\n* [How It Works](#how-it-works)\n* [Access Event Library Data](#access-event-library-data)\n* [Event Library Schema](#event-library-schema)\n* [Event Types](#event-types)\n* [Read Events](#read-events)\n* [Write Events](#write-events)\n* [Custom Events](#custom-events) ## Overview The Event Library enables developers to track what data the user sees and edits while using a Device Sync-enabled mobile application. The Event Library can record three types of events: * Read events\n* Write events\n* Custom events Developers can specify the read and write transactions to record. Additionally, you can configure custom events to record things like button presses, or what the user is seeing in the frontend application. This level of detail enables auditors or other interested parties to assess exactly what happened, and when. ### Use Case The Event Library provides the ability to perform audits to meet compliance requirements in heavily-regulated industries, such as healthcare or financial services. ## Example A nurse in a healthcare facility uses an app with the Event Library enabled. The app presents the nurse with real-time vital signs, information streamed in from the medical equipment, and the patient's historical treatment information. The app inherently enforces compliance, because its code blocks actions that the nurse should not take based on the data being viewed. The Event Library captures all the information that the nurse sees within the app interface, as well as the actions that the nurse takes after viewing that information. At some point, this nurse provides treatment to a patient that later exposes the facility to a malpractice lawsuit. The legal department must review the information that was available to the nurse during the treatment. The Event Library captures the digital data that the nurse viewed during treatment, as well as the actions he undertook. By reviewing this data, the legal team can assess whether the treatment was reasonable. Without this information, the legal department can't know and prove whether the nurse's actions were reasonable. ### How It Works The Event Library opens a separate \"event\" realm on the user's device. This realm has access to any user realm that the developer chooses to monitor with the Event Library. When developers implement the Event Library, they designate the types of events they want to record, as well as any custom metadata they want to append to the event recordings. When the client application runs, it records the designated user interactions to the \"event\" realm as read events, write events, or custom events. While the client device has a network connection, Atlas Device Sync synchronizes this event realm data to an `AuditEvent` collection in the linked Atlas data source. ## Tip ### See also:  For information on how to implement the Event Library in a client application, see: [Event Library - Swift SDK.](https://www.mongodb.com/docs/realm/sdk/swift/sync/event-library/#std-label-swift-event-library) ## Access Event Library Data The Event Library records event data in a collection called `AuditEvent`in your linked Atlas database. When you configure the Event Library, use [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to automatically create this collection and derive a schema from synced events. Remember to turn Development Mode off before taking your application to production. ### Event Library Schema Your `AuditEvent` collection must have a schema containing the following fields: | Field name  | Type     | Required |\n| ----------- | -------- | -------- |\n| \\_id        | ObjectId | Required |\n| activity    | String   | Required |\n| \\_partition | String   | Required |\n| timestamp   | Date     | Required |\n| event       | String   | Optional |\n| data        | String   | Optional | Additionally, the schema must contain an optional string field for each metadata key you use. For example:\n\n ` ## Tip ### See also:  For information on how to add a schema to your collection, see:[Enforce a Schema.](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) ## Example If you're not using any custom metadata, your schema might look like this: AuditEvent Collection Schema ``` {   \"title\": \"AuditEvent\",   \"bsonType\": \"object\",   \"required\": [     \"_id\",     \"_partition\",     \"timestamp\",     \"activity\"   ],   \"properties\": {     \"_id\": {       \"bsonType\": \"objectId\"     },     \"_partition\": {       \"bsonType\": \"string\"     },     \"timestamp\": {       \"bsonType\": \"date\"     },     \"activity\": {       \"bsonType\": \"string\"     },     \"event\": {       \"bsonType\": \"string\"     },     \"data\": {       \"bsonType\": \"string\"     }   } } \n``` ## Event Types The Event Library records three types of events: * Read events\n* Write events\n* Custom events ### Read Events The Event Library records data returned as the result of a query as read events. Read events also record any time a Realm object is instantiated, such as when following a link or looking an object up by primary key. The Event Library records read events as a JSON object with two fields: * `type`: stores the class name\n* `value`: stores an array of serialized objects Read events store values as follows: * _Single-object read events_: the value is an array that has a single element\n* _Objects matching a query_: the value is an array of all objects matching a query, even if the objects are never used\n* _Reads that occur during a write transaction_: the value is the data that the object has before the write transaction began; it does not reflect any changes that occur during the write event.\n* _Objects that do not exist when a write transaction begins_: objects that are created in a write transaction do not produce a read event at all. ## Important The Event Library cannot tell if only a subset of the query displays in the client application. For example, say the client application has a list view. The Event Library's read event doesn't record scrolling information; it records the read event as the full query result. Developers must use custom events to record when a client application displays only a subset of a query result. #### Read Event Combining A stream of every read event could produce a lot of \"duplicate\" events on the same objects that don't add information. To reduce these \"duplicate\" events, the Event Library discards and merges some events. The Event Library discards: * Queries which match no objects\n* Queries which match only newly-created objects\n* Object reads where the object is matched by a previous query The Event Library merges: * Multiple queries on the same table into a single merged query. #### Read Event Format A read event object has this format: ``` {   \"_id\": \"62b396f4ebe94d2b871889bb\",   \"_partition\":\"events-62b396f4ebe94d2b871889ba\",   \"activity\":\"read object\",   \"data\": \"{       \"type\":\"Person\",       \"value\": [{         \"_id\": \"62b396f4ebe94d2b871889b9\",         \"_partition\":\"\",         \"employeeId\":1,         \"name\":\"Anthony\"       }]   }\",   \"event\":\"read\",   \"timestamp\": 2022-06-23T14:54:37.756+00:00 } \n``` #### Embedded Object Read Events The Event Library represents embedded objects by creating a link in the parent object to the primary key of the embedded object. When the user does not follow the link, the primary key is the only representation of the embedded object. When the user does follow the link, the embedded object resolves within the parent object. This also produces a top-level object read for the embedded object.\n\n A `Person` object has an embedded object `Office` which contains details about the location where the person works. When we do not follow the link to view any of the `office` details, the parent `Person` object shows only the embedded object's object ID. Parent Object's data Payload with an Unfollowed Link for office ``` {   \"type\": \"Person\",   \"value\": [{     \"_id\": \"62b47624265ff7b58e9b204e\",     \"_partition\": \"\",     \"employeeId\": 1,     \"name\": \"Michael Scott\",     \"office\": \"62b47624265ff7b58e9b204f\"   }] } \n``` When we do follow the link to view details of the embedded `Office` object, this resolves the embedded object within the parent object. It _also_produces a second top-level read of just the child object - in this case, our `Office` object. Both Objects' data Payloads with a Followed Link for office ``` {   \"type\":\"Person\",   \"value\": [{     \"_id\": \"62b47975a33224558bdf8b4d\",     \"_partition\": \"\",     \"employeeId\": 1,     \"name\": \"Michael Scott\",     \"office\": {       \"_id\": \"62b47975a33224558bdf8b4e\",       \"_partition\": \"\",       \"city\": \"Scranton\",       \"locationNumber\": 123,       \"name\": \"Dunder Mifflin\"     }   }] } {   \"type\": \"Office\",   \"value\": [{     \"_id\": \"62b47975a33224558bdf8b4e\",     \"_partition\": \"\",     \"city\": \"Scranton\",     \"locationNumber\": 123,     \"name\": \"Dunder Mifflin\"   }] } \n``` ## Note ### Read event combining Read Event Combining may affect the objects you see when you query for an object and then later follow an embedded object link. In the example above, if you previously queried for the `Person`, that would produce an read event where the office object is unresolved within the person object; you'd see only the ObjectID in the initial read event. Then, if you later follow a link that resolves the embedded object, you'd see the separate top-level read for the embedded object, but would _not_ get the parent object read that shows the resolved embedded object within the parent object. ### Write Events The Event Library records write events when: * New objects are created\n* Existing objects are modified\n* Objects are deleted The write event records both the before and after state of the object. For new objects created, the before state is `null`. For deletes, the after state of the object is `null`. For each write transaction the client commits during an event recording scope, the Event Library records a single write event. This write event records all of the changes made during the write transaction. The payload is an object keyed on class names. Each object type which had any objects created, modified, or deleted has an entry. The Event Library records changes to an object type as an object with three arrays: * insertions: contain the serialized objects which were inserted, using the same serialization scheme as reads\n* modifications: report both the old and new values of each property\n* deletions: contain the serialized objects which were deleted, using the same serialization scheme as reads In a modification, the `newValue` object only includes properties which are different from the `oldValue` object. If a write transaction assigns to an object but does not actually change the value of any properties, #### Write Event Format A write event object has this format: Inserted object's data payload ``` {   \"Person\": {     \"insertions\": [{       \"_id\": \"62b47ead6a178a314ae0eb52\",       \"_partition\": \"\",       \"employeeId\": 1,       \"name\": \"Anthony\"     }]   } } \n``` Modified object's data payload ``` {   \"Person\":{     \"modifications\": [{       \"newValue\": {         \"name\": \"Tony\"\n\n       \"oldValue\": {         \"_id\": \"62b47d83cdac49f904c5737b\",         \"_partition\": \"\",         \"employeeId\": 1,         \"name\": \"Anthony\"       }     }]   } } \n``` Deleted object's data payload ``` {   \"Person\":{     \"deletions\":[{       \"_id\":\"62b47ead6a178a314ae0eb52\",       \"_partition\":\"\",       \"employeeId\":1,       \"name\":\"Tony\",       \"userId\":\"tony.stark@starkindustries.com\"     }]   } } \n``` ### Custom Events Custom events can record types of events that do not read or write to the database, such as: * When a specific screen displays\n* When the user clicks a button You can use custom events to give context to read and write events, such as recording a custom event when the client application displays a given screen. Then, you can infer that read and write events after the custom event recording the app screen loading all occurred on that app screen. Custom events can store whatever data a developer desires, or no data at all. Example of a custom event ``` {   \"_id\": \"62b4804c15659310991e5e0a\",   \"_partition\": \"events-62b4804b15659310991e5e09\",   \"activity\": \"login\",   \"event\": \"custom event\",   \"timestamp\": 2022-06-23T15:01:31.941+00:00 } \n``` ← [Add Sync to a Local-Only App](https://mongodb.com/docs/atlas/app-services/sync/app-builder/local-to-sync/ \"Previous Section\")[Configure Your Data Model](https://mongodb.com/docs/atlas/app-services/sync/configure-your-data-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Device Sync Permissions Guide On this page * [Using the Template Apps](#using-the-template-apps)\n* [About These Examples](#about-these-examples)\n* [Read & Write Own Data](#read---write-own-data)\n* [Write Own Data, Read All Data](#write-own-data--read-all-data)\n* [Administrator Privileges](#administrator-privileges)\n* [Enable & Configure Custom User Data](#enable---configure-custom-user-data)\n* [Set Up Admin Privileges](#set-up-admin-privileges)\n* [Restricted News Feed](#restricted-news-feed)\n* [Enable & Configure Custom User Data](#enable---configure-custom-user-data-1)\n* [Create Authentication Trigger Function](#create-authentication-trigger-function)\n* [Set Up Restricted Permissions](#set-up-restricted-permissions)\n* [Create subscribeToUser Function](#create-subscribetouser-function)\n* [Dynamic Collaboration](#dynamic-collaboration)\n* [Set Up Permissions](#set-up-permissions)\n* [Adding a Collaborator](#adding-a-collaborator)\n* [Security](#security)\n* [User Search](#user-search)\n* [Tiered Privileges](#tiered-privileges)\n* [Enable & Configure Custom User Data](#enable---configure-custom-user-data-2)\n* [Create Authentication Trigger Function](#create-authentication-trigger-function-1)\n* [Create joinTeam Function](#create-jointeam-function)\n* [Define Permissions](#define-permissions) This page shows how to set up your Device Sync app's permissions for the following common use cases: * [Read & Write Own Data](#std-label-read-write-own-data)\n* [Write Own Data, Read All Data](#std-label-write-own-data-read-all-data)\n* [Administrator Privileges](#std-label-admin-privileges)\n* [Restricted News Feed](#std-label-restricted-news-feed)\n* [Dynamic Collaboration](#std-label-dynamic-collaboration)\n* [Tiered Privileges](#std-label-tiered-privileges) ## Using the Template Apps You can get some of these permissions models up and running quickly with our Device Sync Permissions Guide template apps. Each template app comes with a backend and a Node.js demo client. The backend has all functions, permissions, and triggers set up as described here. The demo client connects to the backend and runs through a simple script to demonstrate how the backend works. You need an authenticated Realm CLI to use these templates. Realm CLI is available on `npm`. To install version 2 of the Realm CLI on your system, ensure that you have [Node.js](https://nodejs.org/en/download/)installed and then run the following command in your shell: `| npm install -g mongodb-realm-cli |\n| -------------------------------- | ` See [the CLI reference page](https://mongodb.com/docs/atlas/app-services/cli/#std-label-cli-auth-with-api-token) for login instructions. Once logged in, you can use the `apps create` command with the `--template`flag to instantiate a template. ```bash realm-cli apps create --template=TEMPLATE_NAME \n``` `TEMPLATE_NAME` can be one of the following:\n\n ## About These Examples The examples here use **default roles**. This means the same permissions rules apply to all collections in your app. As your app grows in complexity, you might need collection-specific roles that only apply to some collections and not others. In particular, if a rule expression in a default role uses a \"queryable field\" that doesn't exist on objects in a certain collection, you can override the rules for that collection by providing a collection-specific role. See[Role-based Permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-roles) for more information. ## Read & Write Own Data In this case, users may read or write their own data, but not other users' data. Consider a notes app where the user wants to persist and share notes across their own devices but keep them private to their user account. This strategy permits a user to create and edit a document if and only if that document's `owner_id` field equals the user's ID. To set up the \"Read & Write Own Data\" strategy, follow the general steps: 1. Log in to the Realm UI, and then click Sync in the left hand panel.\n2. Under Sync Type, choose Flexible.\n3. Set the toggle to enable Development Mode.\n4. Select the cluster you want to sync.\n5. Define a Database Name: select +Add a new database and type a name for the database Realm will use to store your synced objects. You can name it anything you want. A common strategy would be to name the database after the app you're making.\n6. Select Queryable Fields: type in `owner_id`. This allows your permissions expressions (which you'll set next) to use the any fields called `owner_id`.\n7. Skip Advanced Configuration, and then click Save Changes to enable Sync. Now you need to configure the permissions. Navigate to the Rulespage. Click the Default Roles and Filters button to edit the default roles. Use the template dropdown to select the template called \"Users can only read and write their own data\". This populates the rule expression box with the following: ``` {   \"name\": \"owner-read-write\",   \"apply_when\": {},   \"document_filters\": {     \"read\": { \"owner_id\": \"%%user.id\" },     \"write\": { \"owner_id\": \"%%user.id\" }   },   \"read\": true,   \"write\": true } \n``` Note that the `document_filters.read` and `document_filters.write`expressions use the `owner_id` field we marked as \"queryable\" above. It also uses the `%%user` [expansion](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expansions) to read the requesting user's id. App Services replaces (or \"expands\") the expansion at evaluation time with the corresponding value -- in this case, the user object. When evaluating permissions on a given document, App Services checks`document_filters.read` and `document_filters.write` before the corresponding top-level `read` or `write` expressions. For example, if`document_filters.write` evaluates to false, write access is denied; no subsequent rules are checked. However, if `document_filters.write` evaluates to true, App Services checks the top-level `write` expression. In this case,`write` is `true`, so write access is granted on the whole document. For more information, see [Device Sync-Compatible Permissions.](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/#std-label-device-sync-compatibility) ## Write Own Data, Read All Data In this case, users can read all data, but write only their own data. Consider a recipe app where users can read all recipes and add new recipes. The recipes they add can be viewed by everyone using the app. Users may update or delete only the recipes they contributed. To set up the \"Write Own Data, Read All Data\" strategy, follow these general steps:\n\n Now you need to configure the permissions. Navigate to the Rulespage. Click the Default Roles and Filters button to edit the default roles. Use the template dropdown to select the template called \"Users can read all data but only write their own data\". This populates the rule expression box with the following: ``` {   \"name\": \"owner-write\",   \"apply_when\": {},   \"document_filters\": {     \"read\": true,     \"write\": { \"owner_id\": \"%%user.id\" }   },   \"read\": true,   \"write\": true } \n``` Note that the `document_filters.read` expression is set to `true`, indicating that no matter which user is authenticated, they can read all of the data. The `document_filters.write` expression uses the `owner_id` field we marked as \"queryable\" above and uses the `%%user` [expansion](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expansions) to match against the requesting user's id. App Services replaces (\"expands\") the expansion at evaluation time with the corresponding value -- in this case, the user object. If and only if `document_filters.write` evaluates to true will App Services check the top-level `write` expression. When `document_filters.write`evaluates to false, write access is denied regardless of what the top-level`write` expression says. For more information, see[Device Sync-Compatible Permissions.](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/#std-label-device-sync-compatibility) ## Administrator Privileges In this permission strategy, users with a specific \"administrator\" role can read and write any document. Users who do not have the specified role can only read and write their own data. To make this strategy work, you first need to define which users have administrator permissions. Atlas Apps allow you to associate custom user data in your cluster with application users. Using this feature, you can create a document with a field that indicates whether the user has administrative privileges. While there are many ways to set this up, one approach is to add a boolean property called `isGlobalAdmin`, which is set to `true` for those users with the elevated permissions. Another is to create a string field called `role`, in which one of the expected values might be \"admin\". In the following example, the custom user object we'll create has an `_id`field, which corresponds to the user's ID, and 3 additional fields:`firstName`, `lastName`, and `isGlobalAdmin`: ``` {    \"_id\" : \"1234\",    \"firstName\": \"Lily\",    \"lastName\": \"Realmster\",    \"isGlobalAdmin\": true } \n``` ## Note When using custom user data for permissions, never allow the client to write the custom user data object. Doing so would allow any user to grant themselves any permission. Instead, use [system functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) on the server side to update the custom user data object. ### Enable & Configure Custom User Data Atlas App Services stores MongoDB documents that correspond to custom user data in a linked MongoDB Atlas cluster. When you configure custom user data for your application, you specify the cluster, database, collection, and finally a User ID field, which maps a custom user data document to an authenticated user's ID. To enable Custom User Data in the App Services UI, follow these steps:\n\n ## Tip ### See also:  [Custom User Data](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ### Set Up Admin Privileges After you have custom user data enabled, you can implement the Admin Privileges strategy. To do so, follow these general steps: 1. Log in to the Realm UI, and then click Sync in the left hand panel.\n2. Under Sync Type, choose Flexible.\n3. Set the toggle to enable Development Mode.\n4. Select the cluster you want to sync.\n5. Define a Database Name: select +Add a new database and type a name for the database Realm will use to store your synced objects. You can name it anything you want. A common strategy would be to name the database after the app you're making.\n6. Select Queryable Fields: type in `owner_id`. This allows your permissions expressions (which you'll set next) to use the any fields called `owner_id`.\n7. Skip Advanced Configuration, and then click Save Changes to enable Sync. Now you need to configure the permissions. Navigate to the Rulespage. Click the Default Roles and Filters button to edit the default roles. Use the template dropdown to select the template called \"Users can read and write their own data, admins can read and write all data\". This populates the rule expression box with the following: ``` [    {      \"name\": \"admin\",      \"apply_when\": {        \"%%user.custom_data.isGlobalAdmin\": true      },      \"document_filters\": {        \"read\": true,        \"write\": true      },      \"read\": true,      \"write\": true    },    {      \"name\": \"user\",      \"apply_when\": {},      \"document_filters\": {        \"read\": { \"owner_id\": \"%%user.id\" },        \"write\": { \"owner_id\": \"%%user.id\" }      },      \"read\": true,      \"write\": true    } ] \n``` ## Note ### Change the default settings This configuration has two default roles. The first defines the permissions for an administrator. Note that the auto-generated expression assumes there is a boolean field in the custom user data document named `isGlobalAdmin`. Depending on how you defined your custom user data document, you might need to change this. The second default role specifies the rules for all other users. The default is to restrict user access to read and write only their own data. You can change either or both of these fields to `true`, enabling users to read and/or write all data. See the previous sections to learn more about these strategies. ## Restricted News Feed ## Note ### Template Available! To use the backend template and get the demo client, run the following command: ```bash realm-cli apps create --name=restricted-feed --template=flex-sync-guides.restricted-feed \n``` **Custom User Data Configuration Bug Workaround:** Sometimes, the template generator does not copy the custom user data configuration to the new app correctly. You can fix this as follows: the `realm-cli apps create` command should have output some JSON about the app you just created. From this JSON, copy the \"url\" value (something like `https://realm.mongodb.com/groups/...`) and visit that URL in your browser. Log in if prompted. From the app dashboard, in the left-hand panel, click App Users. Click Custom User Data. Ensure Enable Custom User Data is `ON`. If it was not on, turn it on and enter \"mongodb-atlas\", \"Item\", and \"User\" forCluster Name, Database Name, and Collection Name, respectively. For User ID Field, enter `_id`. HitSave (or Save Draft, then [deploy](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-ui)). Next, in your terminal, go into the client directory, install the dependencies, and run the demo: ``` cd restricted-feed/frontend/flex-sync-guides.restricted-feed/ npm install npm run demo \n``` Read the output on your console to see what the demo is doing.\n\n Flexible Device Sync supports querying arrays, so we will create an array within a user data object. This array contains IDs of the authors that this user is authorized to \"follow\". We then set up a subscription that says, in essence, \"Give me all documents where I am the author, or the author's ID is in the array of authors in my custom user data.\" ## Important When a user subscribes or unsubscribes from an author, we update the array in the custom user data, but the changes don't take effect until the current session is closed and a new session is started. ## Note ### Size Limitations In this example, we are creating an array in the Custom User Data. The size of this array is not limited by App Services, but because the data is included in each request, we recommend keeping the size under 16KB, which is enough space for 1000 128-bit GUID-style user IDs. ## Note When using custom user data for permissions, never allow the client to write the custom user data object. Doing so would allow any user to grant themselves any permission. Instead, use [system functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) on the server side to update the custom user data object. ### Enable & Configure Custom User Data To enable Custom User Data in the App Services UI, follow these steps: 1. Click App Users in the left hand panel.\n2. Select the Custom User Data tab.\n3. Set the Enable Custom User Data toggle to On.\n4. Specify the following values:  \n   * Cluster Name: The name of a linked MongoDB cluster that will contain the custom user data database.  \n   * Database Name: The name of the MongoDB database that will contain the custom user data collection.  \n   * Collection Name: The name of the MongoDB collection that will contain custom user data.\n5. Specify the User ID field. Every document in the custom user data collection must have a field that maps to a specific user. The field must be present in every document that maps to a user, and must contain the user's ID _as a string_. We recommend that you use the standard `_id` field to store the user ID. MongoDB automatically places a constraint on the `_id` field, ensuring uniqueness.  \n## Note  \nIf two documents in this collection contain the same user ID value, App Services uses the first document that matches, which leads to unexpected results.\n6. Save and deploy the changes. ## Tip ### See also:  [Custom User Data](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ### Create Authentication Trigger Function We need to create a authentication trigger function that creates a custom user object when a user authenticates for the first time. To do so, follow these steps:\n\n ### Set Up Restricted Permissions In the custom user data object, create an array that holds the \\_id values of each author the user is following. In this example, we'll call it \"subscriptions\". Our user data object looks like the following, where Lily Realmster (`\"_id\": \"1234\"`) is subscribed to all documents written by users \"456\" and \"789\": ``` {    \"_id\" : \"1234\",    \"firstName\": \"Lily\",    \"lastName\": \"Realmster\",    \"user.custom_data.subscribedTo\": [      \"456\",      \"789\"    ] } \n``` You can now implement the Restricted Privileges strategy. To do so, follow these general steps: 1. Log in to the Realm UI, and then click Sync in the left hand panel.\n2. Under Sync Type, choose Flexible.\n3. Set the toggle to enable Development Mode.\n4. Select the cluster you want to sync.\n5. Define a Database Name: select +Add a new database and type a name for the database Realm will use to store your synced objects. You can name it anything you want. A common strategy would be to name the database after the app you're making.\n6. Select Queryable Fields: type in `owner_id`. This allows your permissions expressions (which you'll set next) to use the any fields called `owner_id`.\n7. Skip Advanced Configuration, and then click Save Changes to enable Sync. Now you need to configure the permissions. Navigate to the Rulespage. Click the Default Roles and Filters button to edit the default roles. Use the template dropdown to select the template called \"Users can only read and write their own data\". This populates the rule expression box with the following, which is not _exactly what we want_, but provides most of the logic for us: ``` {   \"name\": \"owner-read-write\",   \"apply_when\": {},   \"document_filters\": {     \"read\": { \"owner_id\": \"%%user.id\" },     \"write\": { \"owner_id\": \"%%user.id\" }   },   \"read\": true,   \"write\": true } \n``` Note that a user can currently read only their own documents (`\"read\": {\"owner_id\": \"%%user.id\"}`). We can change this to include documents whose authors have IDs in the user's \"subscribedTo\" array. To do so, we use the`$in` operator. The expression looks like this: ``` {   \"name\": \"owner-read-write\",   \"apply_when\": {},   \"document_filters\": {     \"read\": {       \"owner_id\": {         \"$in\": \"%%user.custom_data.subscribedTo\"       }     },     \"write\": { \"owner_id\": \"%%user.id\" }   },   \"read\": true,   \"write\": true } \n``` Update the rule expression box with this new logic and save the changes. Note: we changed the `document_filters.read` expression to only mention the authors in the subscribedTo array, but users still have \"read\" access to their own documents because of the `document_filters.read` expression. Whenever write access is granted, read access is implicitly granted. ### Create subscribeToUser Function We need a function that subscribes one user to another. Our permissions are set up to consider a subscriber \"subscribed\" to an author if the author's user ID is in the subscriber's custom user data \"subscribedTo\" array. The \"subscribeToUser\" function takes a user's email address, finds the corresponding user ID in the custom user data collection, and adds the ID to the requesting user's \"subscribedTo\" array. Note that this function will run under System authentication and writes to the custom user data. When using custom user data for permissions, clients must never be allowed to directly edit custom user data. Otherwise, any user could grant themselves any permissions. Instead, modify user data on the backend with a System function. The function should do whatever checks necessary to ensure the user's request for permissions is valid. To create the function, follow these steps:\n\n ## Dynamic Collaboration ## Note ### Template Available! To use the backend template and get the demo client, run the following command: ```bash realm-cli apps create --name=add-collaborators --template=flex-sync-guides.add-collaborators \n``` Next, go into the client directory, install the dependencies, and run the demo: ``` cd add-collaborators/frontend/flex-sync-guides.add-collaborators/ npm install npm run demo \n``` Read the output on your console to see what the demo is doing. In the Dynamic Collaboration strategy, users can create documents and add other users as editors of that document. Like the Read & Write Own Data strategy, this strategy permits a user to create and edit a document if that document's `owner_id` field equals the user's ID. Additionally, a user may edit the document if the document's `collaborators`array field contains their ID. ### Set Up Permissions To implement this strategy, follow these general steps: 1. Log in to the Realm UI, and then click Sync in the left hand panel.\n2. Under Sync Type, choose Flexible.\n3. Set the toggle to enable Development Mode.\n4. Select the cluster you want to sync.\n5. Define a Database Name: select +Add a new database and type a name for the database Realm will use to store your synced objects. You can name it anything you want. A common strategy would be to name the database after the app you're making.\n6. Select Queryable Fields: type in `owner_id`. This allows your permissions expressions (which you'll set next) to use the any fields called `owner_id`.\n7. Skip Advanced Configuration, and then click Save Changes to enable Sync. In the Select Queryable Fields field, type in `collaborators` as well. This will be the field that stores the IDs of users who may also read and write the document. Now you need to configure the permissions. Under Define Permissions, use the template dropdown to select the \"Custom (start from scratch)\". Paste the following into the rule expression box: ``` {   \"name\": \"collaborator\",   \"apply_when\": {},   \"document_filters\": {     \"read\": {       \"$or\": [         {           \"owner_id\": \"%%user.id\"         },         {           \"collaborators\": \"%%user.id\"         }       ]     },     \"write\": {       \"$or\": [         {           \"owner_id\": \"%%user.id\"         },         {           \"collaborators\": \"%%user.id\"         }       ]     }   },   \"read\": true,   \"write\": true } \n``` The \"write\" and \"read\" expressions are identical. Take a look at one of them.`$or` takes an array of options. We have two possible conditions where a user may write the document: * The `owner_id` field of the document equals the user's ID\n* The `collaborators` array field of the document contains the user's ID. Generally speaking, when a user is granted write permission, that user automatically gets read permission. However, we can't omit the`document_filters.read` expression because App Services requires both`document_filters.read` and `document_filters.write` to be defined for the role to be [Sync compatible.](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/#std-label-sync-compatible-roles) ### Adding a Collaborator A user can grant write access on their document to another user by adding that user's ID to the `collaborators` array field on their document. This can be done on the client side. ### Security We don't recommend using this model for highly sensitive data.\n\n ### User Search How exactly to get the other user's ID depends on the details of your app. For example, when a user wants to add another user to a document, you might have a search box that accepts an email address. If the given email address corresponds to another user, the client can add that user's ID to the document's`collaborators` array. Realm has no built-in way to search users. Generally, the flow for searching users is as follows: * Set up an authentication trigger to create a user document when a user registers. The user document contains information you'll use to look up later, such as the user's email address.\n* Create a function that queries the user data collection for a user.\n* Call the function from the client side when the user wants to find another user. To create an authentication trigger, follow these steps: 1. Log in to the Realm UI, and then click Triggers in the left hand panel.\n2. Click the Add a Trigger button.\n3. Set the Trigger Type toggle to Authentication.\n4. Under Trigger Details, specify the following values:  \n   * Name: \"onUserCreated\"  \n   * Enbaled: Switch toggle to \"On\"  \n   * Action Type: Select \"Create\"  \n   * Provider(s): Select \"Email/Password\", or whichever authentication provider(s) you are using  \n   * Select an Event Type: Select \"Function\"  \n   * Function: Select \"+New Function\", and then:  \n         * Function Name: \"onUserCreated\"  \n         * Function: Replace the placeholder text with the following function:  \n   ```javascript  \n   exports = function(authEvent) {  \n       const user = authEvent.user;  \n       const collection = context.services.get(\"mongodb-atlas\").db(\"Item\").collection(\"User\");  \n       const newDoc = {  \n         _id: user.id,  \n         email: user.data.email, // Useful for looking up user IDs by email later - assuming email/password auth is used  \n         team: \"\", // Used for tiered privileges  \n         isTeamAdmin: false, // Used for tiered privileges  \n         isGlobalAdmin: false, // Used for admin privileges  \n         subscribedTo: [], // Used for restricted feed  \n       };  \n       return collection.insertOne(newDoc);  \n   };  \n   ``` Next, create a system function called `findUser`: * Log in to the Realm UI, go to your Realm app, and then click Functions in the left hand panel.\n* Click the Create New Function button.\n* Provide a descriptive Name for your function.\n* Authentication: Select System. This allows your function to bypass permissions on your collections.\n* Log Function Arguments: Leave it `off`.\n* Authorization:  \n   * Can Evaluate: Leave it blank.  \n   * Private: Leave it `off`.\n* Click Save. This brings you to the Function Editor, where you can now enter some to run. ## Warning This configuration allows **anyone** to call this function. As a system function, this function bypasses access rules. Assume any client calling this function has malicious intent. In the Function Editor, paste the following code and save: ```javascript exports = async function(email) {   const collection = context.services.get(\"mongodb-atlas\")     .db(\"Item\").collection(\"User\");   const filter = {     email,   };   // Search for the user by email   const result = await collection.findOne(filter);   // Return corresponding user id or null   return result != null ? result._id : null; }; \n``` From your client, you can now call this function. The function's only argument is an email address string. If the email corresponds to a user, the function returns the user's ID. Otherwise, it returns null. ## Tiered Privileges ## Note ### Template Available! To use the backend template and get the demo client, run the following command:\n\n realm-cli apps create --name=tiered --template=flex-sync-guides.tiered \n``` **Custom User Data Configuration Bug Workaround:** Sometimes, the template generator does not copy the custom user data configuration to the new app correctly. You can fix this as follows: the `realm-cli apps create` command should have output some JSON about the app you just created. From this JSON, copy the \"url\" value (something like `https://realm.mongodb.com/groups/...`) and visit that URL in your browser. Log in if prompted. From the app dashboard, in the left-hand panel, click App Users. Click Custom User Data. Ensure Enable Custom User Data is `ON`. If it was not on, turn it on and enter \"mongodb-atlas\", \"Item\", and \"User\" forCluster Name, Database Name, and Collection Name, respectively. For User ID Field, enter `_id`. HitSave (or Save Draft, then [deploy](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-ui)). Next, in your terminal, go into the client directory, install the dependencies, and run the demo: ``` cd tiered/frontend/flex-sync-guides.tiered/ npm install npm run demo \n``` Read the output on your console to see what the demo is doing. In this permission strategy, we'll add special **roles** as well as rules. There are two roles: **a team member** and **a team administrator**. The rules are as follows: * Each user is a member of a team.\n* A user can read and write their own documents.\n* All members of the team can read all documents created by team members.\n* Each team has a team administrator, who has read & write permissions on every team document. To make this work, we need to do the following: * Enable custom user data\n* Create a trigger function to create a new custom user data object for each new user\n* Create a function to add a user to a team\n* Define the permissions ## Note When using custom user data for permissions, never allow the client to write the custom user data object. Doing so would allow any user to grant themselves any permission. Instead, use [system functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) on the server side to update the custom user data object. ### Enable & Configure Custom User Data To enable Custom User Data in the App Services UI, follow these steps: 1. Click App Users in the left hand panel.\n2. Select the Custom User Data tab.\n3. Set the Enable Custom User Data toggle to On.\n4. Specify the following values:  \n   * Cluster Name: The name of a linked MongoDB cluster that will contain the custom user data database.  \n   * Database Name: The name of the MongoDB database that will contain the custom user data collection.  \n   * Collection Name: The name of the MongoDB collection that will contain custom user data.\n5. Specify the User ID field. Every document in the custom user data collection must have a field that maps to a specific user. The field must be present in every document that maps to a user, and must contain the user's ID _as a string_. We recommend that you use the standard `_id` field to store the user ID. MongoDB automatically places a constraint on the `_id` field, ensuring uniqueness.  \n## Note  \nIf two documents in this collection contain the same user ID value, App Services uses the first document that matches, which leads to unexpected results.\n6. Save and deploy the changes. ### Create Authentication Trigger Function We need to create a authentication trigger function that creates a custom user object when a user authenticates for the first time. To do so, follow these steps:\n\n ### Create joinTeam Function We now need a function that adds a user to a team. Note that this function will run under System authentication and writes to the custom user data. It does not perform an upsert because the user custom data was created when the user successfully authenticated for the first time. To create the function, follow these steps: 1. Log in to the Realm UI, and then click Functions in the left hand panel.\n2. Click the Create New Function button.\n3. Specify the following values:  \n   * Name: \"joinTeam\"  \n   * Authentication: \"System\"\n4. Switch to the Function Editor tab and replace the placeholder text with the following code:  \n```javascript  \nexports = async function(userId, teamName) {  \n  const collection = context.services.get(\"mongodb-atlas\")  \n    .db(\"Item\").collection(\"User\");  \n  const filter = { _id: userId };  \n  const update = { $set: { team: teamName }};  \n  const options = { upsert: false };  \n  return collection.updateOne(filter, update, options);  \n};  \n``` ### Define Permissions The following permissions specify two roles: * **teamAdmin** applies only when the user's custom data has`isTeamAdmin: true`. If so, the user can read and write all documents where the document's `team` value matches the user's `team` value.\n* **teamMember** applies to every user. The user can write their own documents and read all documents where the document's `team` value matches the user's `team` value. ``` [    {      \"name\": \"admin\",      \"apply_when\": {        \"%%user.custom_data.isTeamAdmin\": true      },      \"document_filter\": {        \"read\": {          \"team\": \"%%user.custom_data.team\"        },        \"write\": {          \"team\": \"%%user.custom_data.team\"        }      },      \"read\": true,      \"write\": true    },    {      \"name\": \"user\",      \"apply_when\": {},      \"document_filters\": {        \"read\": {          \"team\": \"%%user.custom_data.team\"        },        \"write\": {          \"owner_id\": \"%%user.id\"        }      },      \"read\": true,      \"write\": true    } ] \n``` ## Note ### Take It Further This strategy can be expanded to support a \"globalAdmin\" role. The global admin would have read & read permissions on any doc created in any team. ## Tip ### See also: Authentication Triggers * [Authentication Triggers](https://mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-triggers)\n* [Custom User Data](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) ← [App Builder's Guide](https://mongodb.com/docs/atlas/app-services/sync/app-builder/ \"Previous Section\")[Sync Data in Atlas with a Client Application](https://mongodb.com/docs/atlas/app-services/sync/app-builder/sync-data-in-atlas-with-client/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/data-model/sync-schema-overview/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Sync Data Model Overview On this page * [Overview](#overview)\n* [Create a Data Model](#create-a-data-model)\n* [Update a Data Model](#update-a-data-model)\n* [Data Model Mapping](#data-model-mapping) ## Overview To use Atlas Device Sync you must define your data model in two formats: * **App Services Schema**: A server-side schema which defines your data in BSON. Device Sync uses the App Services Schema to convert your data to MongoDB documents and enforce validation and synchronize data between client devices and Atlas.\n* **Realm Object Schema**: Client-side schema of data defined using the Realm SDKs. Each Realm SDK defines the Realm Object Schema in its own language-specific way. The Realm SDKs use this schema to store data in Realm Database and synchronize data with Device Sync. The App Services Schema and Realm Object Schema must be consistent with each other to sync data using Device Sync. You can also sync data between clients using different Realm SDKs, as long as they implement the same Realm Object Schema. These Realm Object Schemas must all be consistent with the App Services Schema as well. For example, you have an iOS app and an Android app with their Realm Object Schemas defined using the Realm Swift SDK and the Realm Kotlin SDK, respectively. Both these mobile applications sync data using the same App Services App with Device Sync. The Swift SDK schema and the Kotlin SDK schema must both be consistent with the same App Services Schema. ## Create a Data Model You can create your Device Sync data model in a few ways. If you already have data in Atlas, you can generate an App Services Schema by sampling that data. You can then generate a Realm Object Schema for each Realm SDK. If you prefer to develop your Realm Object Schema using the Realm SDKs first, use Development Mode. When you use Development Mode, Device Sync automatically generates an App Services Schema when you sync data from a client using a Realm SDK. For more information on these approaches to modeling data, refer to [Create a Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/#std-label-create-sync-schema) ## Update a Data Model When developing an application using Atlas Device Sync, you may need to make changes to your data model. This means you also need to update your App Services Schema and Realm Object Schema. For more information on how to perform the different types of data model changes, refer to [Update a Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) ## Data Model Mapping To learn more about how the Realm Object Schemas map to the App Services Schemas when using Development Mode, refer to [Data Model Mapping.](https://mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/#std-label-sync-data-model-mapping) ← [Configure Your Data Model](https://mongodb.com/docs/atlas/app-services/sync/configure-your-data-model/ \"Previous Section\")[Create a Data Model](https://mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/data-model/generate-sdk-object-models/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Generate SDK Object Models On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Navigate to the SDKs Screen](#navigate-to-the-sdks-screen)\n* [Select the Data Models Tab](#select-the-data-models-tab)\n* [Select Your Data Model Language](#select-your-data-model-language)\n* [Copy the Data Models](#copy-the-data-models)\n* [Generate Data Models Based On Your Schema](#generate-data-models-based-on-your-schema)\n* [Confirm Options for Generating Data Models](#confirm-options-for-generating-data-models)\n* [Use Your Data Model](#use-your-data-model) ## Overview Atlas App Services can automatically translate your server-side document schemas to a Realm Object Schema that will work with your SDK of choice. You can generate the object models using either the App Services UI or CLI. ## Procedure ← [Create a Data Model](https://mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/ \"Previous Section\")[Update Your Data Model](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/data-model/create-a-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Create a Data Model On this page * [Overview](#overview)\n* [Create an App Services Schema from a Realm Object Model](#create-an-app-services-schema-from-a-realm-object-model)\n* [Create a Realm Object Schema from an App Services Schema](#create-a-realm-object-schema-from-an-app-services-schema)\n* [Further Reading](#further-reading) ## Overview You can create a schema for your App in one of two ways: * [Create an App Services Schema from a Realm Object Schema](#std-label-create-schema-from-rom): Alternatively, if you are developing mobile-first and do not already have data in your Atlas cluster, you can translate your Realm Object Schema into a schema for use with Atlas. Regardless of the approach that you take, when you configure both your Atlas cluster and Mobile application to use the respective data model, changes to the data model between the server and client are auto-updated.\n* [Create a Realm Object Schema from an Atlas App Services Schema](#std-label-create-rom-from-schema): If you have data in your[MongoDB Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container)cluster already, MongoDB generates a schema by sampling your data. Atlas App Services can then translate that schema into a Realm Object Schema to use in your mobile application with the Realm SDK. ## Create an App Services Schema from a Realm Object Model ## Note ### Link a MongoDB Atlas Data Source Your App must have at least one [linked data source](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) in order to create a schema. You cannot use Device Sync with a [serverless instance](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-serverless-caveats) or [Federated database instance.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats) 1 ### Enable Development Mode Sync First, [enable Development Mode.](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) You can alter or define a Realm Object Schema through your mobile client SDK. Changes to your Realm Object Schema are only allowed whenDevelopment Mode is on in the App Services UI. App Services will reflect these changes to your Realm Object Schema in your App Services Schema used for Atlas. 2 ### Edit Your Realm Object Schema As you continue to develop your application, you will need to modify your data model with it to enforce different data validation rules based on those changes. While Development Mode is on, you can edit your Realm Object Schema in your client code. Data Validation occurs when Development Mode is off, so App Services does not accept changes to your Realm Object Schema whileDevelopment Mode is not on. ## Important ### Primary Key \\_id Required To work with Atlas Device Sync, your data model **must** have a primary key field called `_id`. `_id` can be of type `string`, `int`, or`objectId`. ## Example A group is developing a social media application. When the group first developed their application, a user's birthday was a required field of the User's data model. However, due to privacy concerns over the amount of user data that is stored, management creates a new requirement to make the user's birthday field an optional field. Application developers turn on Development Modein the App Services UI and then edit their user model within their client code.\n\n ` Refer to the Realm SDK-specific documentation for creating Realm Object Schemas. * [Realm .NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/sync/add-sync-to-app/#std-label-dotnet-sync-changes-between-devices)\n* [Realm C++ SDK](https://www.mongodb.com/docs/realm/sdk/cpp/model-data/object-models/#std-label-cpp-object-models)\n* [Realm Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/realm-database/model-data/define-realm-object-schema/#std-label-flutter-define-realm-object-schema)\n* [Realm Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/define-a-realm-object-model/#std-label-java-define-a-realm-object-schema)\n* [Realm Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/realm-database/schemas/supported-types/#std-label-kotlin-supported-types)\n* [Realm Node.js SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/define-a-realm-object-model/#std-label-node-define-a-realm-object-schema)\n* [Realm React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/realm-database/define-a-realm-object-model/#std-label-react-native-define-a-realm-object-schema)\n* [Realm Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/model-data/define-model/object-models/#std-label-swift-object-models) 3 ### Update Your App Services Schema with the Realm Object Schema Changes While Development Mode is on, App Services doesn't validate writes against your data model, allowing you to freely update your Realm Object Model. When you turn off Development Mode, MongoDB App Services automatically updates your App Services Schema and starts to enforce data validation for your Atlas cluster based on it. Click the \"Turn Dev Mode Off\" button on the top banner or in theSync screen to turn off Development Mode. Once you turn off Development Mode, the \"Development Mode is OFF\" modal will appear. The modal indicates that App Services has stopped accepting new data model changes from clients. Click the \"View My Schema\" button on the modal to view your updated App Services Schema. ## Note To make future data model updates from your mobile client code, you can follow this procedure again. ![The banner in the UI that shows Development Mode is enabled](https://mongodb.com/docs/atlas/app-services/images/turn-off-dev-mode.png) click to enlarge ![The modal that confirms turning off Development Mode in the UI](https://mongodb.com/docs/atlas/app-services/images/view-my-json-schema.png) click to enlarge ## Create a Realm Object Schema from an App Services Schema ## Note ### Link a MongoDB Atlas Data Source Your app must have at least one [linked data source](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) in order to define an App Services data model. You cannot use sync with a [serverless instance](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-serverless-caveats) or [Federated database instance.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats) 1 ### Define an App Services Schema To get started, ensure you have an App Services Schema defined. App Services will translate this App Services Schema into a Realm Object Schema to be configured and utilized in your mobile application. ## Important ### Primary Key \\_id Required To work with Atlas Device Sync, your data model **must** have a primary key field called `_id`. `_id` can be of type `string`, `int`, `uuid`, `ObjectId`, or`objectId`. ## Important\n\n ## Note To learn how to define a schema for a collection in the synced cluster, see[Enforce a Schema.](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) 2 ### View the Realm Object Schema The Realm Object Schema defines and validates your data in your mobile client application. To view your Realm Object Schema, navigate to theSDKs page, where you can view your App Services Schema as a generated Realm Object Schema in your language of choice. ![The generated Realm Object Models and associated warnings in the UI](https://mongodb.com/docs/atlas/app-services/images/translate-jsonschema-into-realm-data-model.png) click to enlarge 3 ### View and Fix Schema Errors App Services may fail to generate some or all of your Realm Object Schema based on your App Services Schema. You can view a list of the errors in your App Services Schema that prevented App Services from generating the Realm Object Schema on the SDKspage of the App Services UI. Common errors include mismatched types, and differences in the way relationships are represented in the two respective models. For each error or warning, modify your App Services Schema to fix the specified issue. ![A detailed list in the UI of warnings and errors that occurred during model](https://mongodb.com/docs/atlas/app-services/images/schema-translation-errors-warnings.png) click to enlarge 4 ### Open a Realm with the Realm Object Schema You can use the generated Realm Object Schema in your client application. In order to begin enforcing data validation with your data model, you can open a realm with the Realm Object Schema. This will prevent improper data from entering your database from your mobile client. Click Copy on the right-hand side of the Realm Object Schema for the Object Model you want to integrate into your mobile application code. This will copy the Realm Object Schema code for the SDK of your choice into your clipboard. Open your mobile application code in your IDE and paste the Realm Object Schema code in. Refer to the Realm SDK-specific documentation to use the generated Realm Object Schema. * [Realm .NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/sync/add-sync-to-app/#std-label-dotnet-sync-changes-between-devices)\n* [Realm Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/sync/#std-label-flutter-sync)\n* [Realm Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/sync-changes-between-devices/#std-label-java-sync-data)\n* [Realm Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/sync/overview/#std-label-kotlin-sync-overview)\n* [Realm Node.js SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/sync-changes-between-devices/#std-label-node-sync-changes-between-devices)\n* [Realm React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/sync-data/overview/#std-label-react-native-realm-sync)\n* [Realm Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/sync/add-sync-to-app/#std-label-ios-sync-changes-between-devices) ## Further Reading * To learn more about how these schemas map to each other, refer to [Data Model Mapping.](https://mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/#std-label-sync-data-model-mapping)\n* To update an existing Sync data model, refer to [Update Your Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview)\n\n",
  "https://www.mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Make Breaking Schema Changes On this page * [Overview](#overview)\n* [Partner Collections](#partner-collections)\n* [Procedure](#procedure)\n* [Initialize Your Partner Collection with an Aggregation Pipeline](#initialize-your-partner-collection-with-an-aggregation-pipeline)\n* [Set up Database Triggers for Your Partner Collections](#set-up-database-triggers-for-your-partner-collections)\n* [Add Trigger Functions](#add-trigger-functions) ## Overview If you need to make changes to an object schema that is used in Atlas Device Sync, you can make [non-breaking](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-additive-changes-synced-schema) without any additional work. [Breaking changes](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-destructive-changes-synced-schema), however, require additional steps. A breaking or destructive change includes renaming an existing field or changing a field's data type. For more information, see [Update Your Data Model.](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-synced-schema-overview) If you need to make a breaking schema change, you have two choices: * [Terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend and then[re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) it from the start.\n* Create a [partner collection](#std-label-partner%5Fcollections), copy the old data to this new collection, and set up triggers to ensure data consistency.  \nThe remainder of this guide leads you through creating a partner collection. ## Warning ### Restore Sync after Terminating Sync When you terminate and re-enable Atlas Device Sync, clients can no longer Sync. Your client must implement a client reset handler to restore Sync. This handler can discard or attempt to recover unsynchronized changes. ## Partner Collections In the following procedure, the _initial_ collection uses the JSON Schema below for a `Task` collection. Note that the schema for the `Task` contains an`_id` field of type `objectId`: Task Schema `| {                      |\n| ---------------------- |\n| \"title\": \"Task\",       |\n| \"bsonType\": \"object\",  |\n| \"required\": [          |\n| \"_id\",                 |\n| \"name\"                 |\n| ],                     |\n| \"properties\": {        |\n| \"_id\": {               |\n| \"bsonType\": \"objectId\" |\n| },                     |\n| \"_partition\": {        |\n| \"bsonType\": \"string\"   |\n| },                     |\n| \"name\": {              |\n| \"bsonType\": \"string\"   |\n| }                      |\n| }                      |\n| }                      | ` The _new_ schema is the same, except we want the `_id` field to be a string:\n\n ``` {     \"title\": \"Task\",     \"bsonType\": \"object\",     \"required\": [         \"_id\",         \"name\"     ],     \"properties\": {         \"_id\": {             \"bsonType\": \"string\"         },         \"_partition\": {             \"bsonType\": \"string\"         },         \"name\": {             \"bsonType\": \"string\"         }     } } \n``` ## Procedure 1 ### Initialize Your Partner Collection with an Aggregation Pipeline Since breaking changes cannot be performed directly on a synced object schema, you must create a partner collection with a schema containing the required changes. You must ensure that the partner collection has the same data as the original collection so that newer clients can synchronize with older clients. The recommended approach to copying the data from your original collection to the new partner collection is to use the [Aggregation Framework.](https://www.mongodb.com/docs/manual/aggregation/) You can create and run an aggregation pipeline from the [mongo shell](https://www.mongodb.com/docs/manual/mongo/), by using the [/aggregation-pipeline-builder/](https://www.mongodb.com/docs/compass/current/aggregation-pipeline-builder/), or with the[/data-explorer/cloud-agg-pipeline/.](https://www.mongodb.com/docs/atlas/data-explorer/cloud-agg-pipeline/) The pipeline will have the following stages: 1. Match all the documents in the initial collection by passing an empty filter to the [$match operator.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/)\n2. Modify the fields of the initial collection by using an[aggregation pipeline operator](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). In the following example, the data is transformed using the [$addFields operator](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/). The `_id` field is transformed to a `string` type with the [$toString operator.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/toString/)\n3. Write the transformed data to the partner collection by using the[$out operator](https://www.mongodb.com/docs/manual/reference/operator/aggregation/out/) and specifying the partner collection name. In this example, we wrote the data to a new collection named `TaskV2`. Here the same pipeline as represented in the Atlas and Compass UIs. Note that both of these tools provide a preview of the changes; in this case, the conversion the `_id` field from an ObjectId to a string: ![Atlas UI for Aggregation Builder](https://mongodb.com/docs/atlas/app-services/images/agg-in-atlas.png) The following example shows the complete aggregation pipeline as it would look if you are using the [mongo shell](https://www.mongodb.com/docs/manual/mongo/) to do the conversion: Match All Documents in the Initial Collection and Output Them to the Partner Collection ```shell use \"<database-name>\" // switch the current db to the db that the Task collection is stored in collection = db.Task; collection.aggregate([   { $match: {} }, // match all documents in the Task collection   {     $addFields: { // transform the data       _id: { $toString: \"$_id\" }, // change the _id field of the data to a string type     },   },   { $out: \"TaskV2\" }, // output the data to a partner collection, TaskV2 ]); \n``` 2 ### Set up Database Triggers for Your Partner Collections\n\n To ensure that data is reflected in both collections, you set up a[database trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-create-a-database-trigger) on each collection. When data is written to one collection, the trigger's function performs the write to the partner collection. Follow the steps in the [database trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-create-a-database-trigger)documentation to create a trigger that copies data from the `Task` collection to the `TaskV2` collection for all operation types. Repeat these steps to create a second trigger that copies data from the `TaskV2` collection to the`Task` collection. The following image shows the first trigger being created: ![Create a Database Trigger to Copy Data from Task to TaskV2](https://mongodb.com/docs/atlas/app-services/images/trigger-copyTaskObjectToTaskV2.png) click to enlarge 3 ### Add Trigger Functions Triggers require backing functions that run when the trigger fires. In this case, we need to create two functions: a forward-migration function and a reverse-migration function. The forward migration trigger listens for inserts, updates, and deletes in the Task collection, modifies them to reflect the TaskV2 collection's schema, and then applies them to the TaskV2 collection. To listen for changes to the TaskV2 collection and apply them to the Task collection, write a reverse-migration function for the TaskV2 collection's trigger. The reverse migration follows the same idea as the previous step. In the forward-migration function, we check which operation has triggered the function: if the operation type is `Delete` (meaning a document has been deleted in the Task collection), the document is also deleted in the TaskV2 collection. If the operation type is a `Write` (inserted or modified) event, an aggregation pipeline is created. In the pipeline, the inserted or modified document in the Task collection is extracted using the[$match operator](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/). The extracted document is then transformed to adhere to the`TaskV2` collection's schema. Finally, the transformed data is written to the`TaskV2` collection by using the[$merge operator:](https://www.mongodb.com/docs/manual/reference/operator/aggregation/merge/) copyTaskObjectToTaskV2 function ```javascript exports = function (changeEvent) {   const db = context.services.get(\"mongodb-atlas\").db(\"ExampleDB\");   const collection = db.collection(\"Task\");   // If the event type is \"invalidate\", the next const throws an error.   // Return early to avoid this.   if (!changeEvent.documentKey) { return; }   // The changed document's _id as an integer:   const changedDocId = changeEvent.documentKey._id;   // If a document in the Task collection has been deleted,    // delete the equivalent object in the TaskV2 collection:   if (changeEvent.operationType === \"delete\") {     const tasksV2Collection = db.collection(\"TaskV2\");     // Convert the deleted document's _id to a string value      // to match TaskV2's schema:     const deletedDocumentID = changedDocId.toString();     return tasksV2Collection.deleteOne({ _id: deletedDocumentID })   }   // A document in the Task collection has been created,    // modified, or replaced, so create a pipeline to handle the change:   const pipeline = [     // Find the changed document data in the Task collection:     { $match: { _id: changeEvent.documentKey._id } },     {       // Transform the document by changing the _id field to a string:       $addFields: {         _id: { $toString: \"$_id\" },       },     },     // Insert the document into TaskV2, using the $merge operator      // to avoid overwriting the existing data in TaskV2:     { $merge: \"TaskV2\" }]   return collection.aggregate(pipeline); }; \n```\n\n copyTaskV2ObjectToTask function ```javascript exports = function (changeEvent) {   const db = context.services.get(\"mongodb-atlas\").db(\"ExampleDB\");   const collection = db.collection(\"TaskV2\");   // If the event type is \"invalidate\", the next const throws an error.   // Return early to avoid this.   if (!changeEvent.documentKey) { return; }   // The changed document's _id as a string:   const changedDocId = changeEvent.documentKey._id;   // If a document in the TaskV2 collection has been deleted,    // delete the equivalent object in the Task collection   if (changeEvent.operationType === \"delete\") {     const taskCollection = db.collection(\"Task\");     // Convert the deleted document's _id to an integer value     // to match Task's schema:     const deletedDocumentID = parseInt(changedDocId);     return taskCollection.deleteOne({ _id: deletedDocumentID })   }   // A document in the Task collection has been created,    // modified, or replaced, so create a pipeline to handle the change:   const pipeline = [     // Find the changed document data in the Task collection     { $match: { _id: changedDocId } },     {       // Transform the document by changing the _id field       $addFields: {         _id: { $toInt: \"$_id\" },       },     },     { $merge: \"Task\" }   ]   return collection.aggregate(pipeline); }; \n``` ← [Update Your Data Model](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/ \"Previous Section\")[Data Model Mapping](https://mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/mongodb/internal-database-usage/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Internal Database Usage Atlas App Services uses your linked MongoDB Atlas cluster to manage some internal operations. In general, you do not need to know about these operations to use App Services. ## System-Generated Cluster Users App Services automatically creates a [MongoDB user](https://www.mongodb.com/docs/manual/core/security-users/) for each app linked to a cluster. These users are for internal use only and cannot be edited or manually deleted. If you delete an App, the associated user will also be deleted. Users generated by App Services have names of the form:`mongodb-realm-<your app id>` ## Transactional Locks App Services connects to standard MongoDB Atlas clusters, which means that you can connect directly to a linked cluster using another tool such as the [mongo](https://www.mongodb.com/docs/manual/reference/mongo/#mongodb-binary-bin.mongo) shell or MongoDB Compass. There are no special considerations when reading data from a linked cluster with another tool. While running update operations, App Services temporarily adds a reserved field, `_id__baas_transaction`, to documents. Once a document is successfully updated, App Services removes this field. If you want to use another tool to modify data in a collection, ensure that you [$unset](https://www.mongodb.com/docs/manual/reference/operator/update/unset/) this field prior to making changes. For example, if you are using the [mongosh](https://www.mongodb.com/docs/mongodb-shell/) shell to update documents in the products collection, your command might resemble the following code: `| db.products.update(                       |\n| ----------------------------------------- |\n| { sku: \"unknown\" },                       |\n| { $unset: { _id__baas_transaction: \"\" } } |\n| )                                         | ` ## Unsynced Documents If a document in a [synced](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync) collection does not conform to the collection's schema, it cannot be synced to client apps. If there are 100,000 or more unsyncable documents, App Services pauses sync for the app. App Services stores a information about unsyncable documents in the`__realm_sync.unsynced_documents` collection. ## Important You can read from the `__realm_sync.unsynced_documents` collection, but you should not modify it in any way. A common cause for unsyncable documents is data added or modified outside of the context of your app. Consider the following scenario:\n\n **Summary** If your data is used by Sync clients but can also be created or modified outside of Atlas Device Sync, you must ensure those creations and modifications match the defined object schema on the collection. For documents that have failed, you can replace, update, or delete & re-add each document. ← [Document Preimages](https://mongodb.com/docs/atlas/app-services/mongodb/preimages/ \"Previous Section\")[Define a Data Model](https://mongodb.com/docs/atlas/app-services/data-model/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Update Your Data Model On this page * [Overview](#overview)\n* [Breaking vs. Non-Breaking Change Quick Reference](#breaking-vs.-non-breaking-change-quick-reference)\n* [Add an Object Type](#add-an-object-type)\n* [How to Add an Object Type](#how-to-add-an-object-type)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files)\n* [Add a Required Property](#add-a-required-property)\n* [How to Add a Required Property](#how-to-add-a-required-property)\n* [Handle Existing Atlas Documents](#handle-existing-atlas-documents)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-1)\n* [Add an Optional Property](#add-an-optional-property)\n* [How to Add an Optional Property](#how-to-add-an-optional-property)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-2)\n* [Remove an Object Type](#remove-an-object-type)\n* [How to Remove an Object Type](#how-to-remove-an-object-type)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-3)\n* [Remove a Required Property](#remove-a-required-property)\n* [How to Remove a Required Property](#how-to-remove-a-required-property)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-4)\n* [Remove an Optional Property](#remove-an-optional-property)\n* [How to Remove an Optional Property](#how-to-remove-an-optional-property)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-5)\n* [Change an Object Type Name](#change-an-object-type-name)\n* [How to Change an Object Type Name](#how-to-change-an-object-type-name)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-6)\n* [Change a Property Name](#change-a-property-name)\n* [How to Change a Property Name](#how-to-change-a-property-name)\n* [Handle Existing Atlas Documents](#handle-existing-atlas-documents-1)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-7)\n* [Change Property Type but Keep the Name](#change-property-type-but-keep-the-name)\n* [How to Change a Property Type but Keep the Name](#how-to-change-a-property-type-but-keep-the-name)\n* [Handle Existing Atlas Documents](#handle-existing-atlas-documents-2)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-8)\n* [Change Property from Optional to Required](#change-property-from-optional-to-required)\n* [How to Change a Property from Optional to Required](#how-to-change-a-property-from-optional-to-required)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-9)\n* [Change Property from Required to Optional](#change-property-from-required-to-optional)\n* [How to Change a Property from Required to Optional](#how-to-change-a-property-from-required-to-optional)\n* [Handle Client Realm Database Files](#handle-client-realm-database-files-10)\n* [Summary](#summary) ## Overview When developing an application using Atlas Device Sync, you may need to make changes to your schema at some point, such as when you need to: * Add a new property to an already-synced object\n* Remove a property from an already-synced object\n* Change the type stored in a property\n* Update an optional property to _required_\n\n Atlas App Services provides for non-breaking schema changes to synced realms, allowing old clients to sync with newer ones. Breaking schema changes, however, take some planning and work, and should be avoided whenever possible. Breaking schema changes are difficult because older clients (those that have not been updated to your new code and schema) still need access to the data via the old schema definition. Clients that are updated need to work with the new schema changes. ## Note ### Make breaking changes via the Atlas App Services UI Because breaking or destructive schema changes require special handling, App Services does not support making these changes via Realm CLI or automated deploy with GitHub. Instead, you should make breaking changes in the App Services UI. ## Breaking vs. Non-Breaking Change Quick Reference A breaking change is a change that you can make in your server-side schema that requires additional action to handle. Failing to handle these changes properly can result in clients being unable to open a realm, or the appearance of data loss when server-side documents are unable to sync to client-side applications. A non-breaking change is a change that you can make in your server-side schema or your object model without requiring additional handling in your app. App Services refers to these types of non-breaking changes as additive changes. They apply automatically to synced realms; you can make these non-breaking schema changes with no additional client-side configuration changes. ## Note ### Applying non-breaking changes to the client may require migration When you _only_ make non-breaking changes to the server-side schema, no additional action is required. However, if you then try to apply these changes to your client object model, you may need to perform a migration. If the client device has an existing realm file, you must perform a migration. For details, see the Modify an Object Schema page in your preferred SDK. This table shows whether each type of change is breaking or non-breaking when you make it only in the server-side schema or in the object model. Some changes that are non-breaking on the client-side are breaking on the server-side. Additionally, some changes that are non-breaking on the server-side schema may require additional handling when you apply them to the client-side object model. For more details, see relevant sections below.\n\n ## Tip ### Rename a property While renaming a property is a breaking change, some of the Realm SDKs offer a workaround to remap the property name. See[Change a Property Name](#std-label-schema-update-change-property-name) for more details. ## Add an Object Type You can add an object type to either the server-side schema or the client object model without doing any additional handling. ### How to Add an Object Type If you want to add an object type to both the server-side schema and the client object model, you can add the object type to the object model, and use [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to let App Services infer the server-side schema updates. Or you can manually add the object type to both the model and the schema. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data, you must increment the client schema version when you open the realm. For more information, see your preferred SDK's migration page. ## Note ### These changes may trigger a resync When you add a new object type, we retreive the documents for the collection and re-insert them into App Services to get the new values. This is expected behavior, but it does cause a temporary halt to propogating changes while this process is underway. ## Add a Required Property You can add a required property to the client object model without doing any additional handling. ## Warning ### Update existing documents If you add a new required property to the server-side schema, you must update existing documents with that new property or they do not sync to the client. This may give client users the impression that the data has been lost. ### How to Add a Required Property ## Note ### Consider adding an optional property Adding a required property to the server-side schema requires additional handling detailed below. If you add the property as optional, you can avoid the need to modify existing Atlas documents. If you want to add a required property to both the server-side schema and the client object model, you can add the required property to the object model, and use [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) to let App Services infer the server-side schema updates. Or you can manually add the required property to both the model and the schema. ## Important ### Even non-breaking changes can require terminating sync When there are more than 100,000 documents in the`__realm_sync.unsynced_documents` collection, App Services requires that you[terminate and re-enable sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync). When you add a required property, the re-sync process can push your collection over this limit. In this case, you must terminate and re-enable sync, even though the change you're making is a non-breaking change. ### Handle Existing Atlas Documents If you add a new required property to the server-side schema, you must update existing documents with that new property or they do not sync to the client. This may give client users the impression that the data has been lost. If an Atlas document does not have the new required property, the entire document no longer syncs to the client application. Resolve this issue by adding a new field to each document that matches the new schema, and populating it with a default value. After you've made these changes, the appropriate documents should once again sync to the client application. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data, you must increment the client schema version when you open the realm. For more information, see your preferred SDK's migration page. ## Note ### These changes may trigger a resync When you add a new required property, we retreive the documents for the collection that have new values per the updated schema. We iterate through those documents and re-insert them into App Services to get the new values. This is expected behavior, but it does cause a temporary halt to propogating changes while this process is underway. ## Add an Optional Property You can add an optional property to either the server-side schema or the client object model without doing any additional handling. ### How to Add an Optional Property\n\n ### Handle Client Realm Database Files If you already have a client-side realm file that contains data, you must increment the client schema version when you open the realm. For more information, see your preferred SDK's migration page. ## Note ### These changes may trigger a resync When you add a new optional property, we retreive the documents for the collection that have new values per the updated schema. We iterate through those documents and re-insert them into App Services to get the new values. This is expected behavior, but it does cause a temporary halt to propogating changes while this process is underway. ## Remove an Object Type If you remove an object type from the server-side schema, this is a breaking or destructive change. However, you can remove an object type from the object model as a non-breaking change. ### How to Remove an Object Type A breaking server-side schema change requires you to [terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend, and then [re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) sync. Breaking schema changes prevent applications from automatically recovering from a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-handle-a-client-reset). As a result, we do not recommend making breaking server-side schema changes. Instead, you can remove the object type from the client-side object model and leave it in place on the server-side schema. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data, you must increment the client schema version when you open the realm. For more information, see your preferred SDK's migration page. ## Remove a Required Property If you remove a required property from the server-side schema, this is a breaking or destructive change. However, you can remove a required property from the object model as a non-breaking change. ### How to Remove a Required Property A breaking server-side schema change requires you to [terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend, and then [re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) sync. This triggers a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets), which can result in client-side data loss. As a result, we do not recommend making breaking server-side schema changes. Instead, you can remove the property from the client-side object model and leave it in place on the server-side schema. To maintain backward compatibility, removing a property from a client-side object model does not delete the property from the database. Instead, new objects retain the removed property, but App Services automatically sets the property's value to `null`. App Services sets properties that are non-nullable to an appropriate empty value, such as a 0 for integer values or an empty string for string values. This is considered a non-breaking or additive change to the object model. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data, you must increment the client schema version when you open the realm. For more information, see your preferred SDK's migration page. ## Remove an Optional Property If you remove an optional property from the server-side schema, this is a breaking or destructive change. However, you can remove an optional property from the object model as a non-breaking change. ### How to Remove an Optional Property A breaking server-side schema change requires you to [terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend, and then [re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) sync. This triggers a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets), which can result in client-side data loss. As a result, we do not recommend making breaking server-side schema changes.\n\n To maintain backward compatibility, removing a property from a client-side object model does not delete the property from the database. Instead, new objects retain the removed property, but App Services automatically sets the property's value to `null`. App Services sets properties that are non-nullable to an appropriate empty value, such as a 0 for integer values or an empty string for string values. This is considered a non-breaking or additive change to the object model. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data, you must increment the client schema version when you open the realm. For more information, see your preferred SDK's migration page. ## Change an Object Type Name If you change an object type's name, this is a breaking or destructive change to both the server-side schema and the client-side object model. ### How to Change an Object Type Name A breaking server-side schema change requires you to [terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend, and then [re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) sync. Breaking schema changes prevent applications from automatically recovering from a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-handle-a-client-reset). As a result, we do not recommend making breaking server-side schema changes. Instead, you can let the existing collection remain in place with the existing schema, and create a partner collection with the new schema. A partner collection is a collection that contains the same data as the original collection, but has the new schema definition in place. Partner collections use database triggers to ensure that data flows in both directions, meaning that when one collection is written to, the other is also written to (with the data modifications required for the new schema). To implement a breaking schema change using the partner collection strategy, see [Make Breaking Schema Changes.](https://mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/#std-label-migrate-schema-partner-collection) If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, you must manually update the schema. [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)does not automatically update your schema for breaking changes. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data when you implement a schema change using the partner collection strategy, you must perform a migration when you open the realm. For more information, see your preferred SDK's migration page. If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, your client application must perform a [manual client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-manual-client-reset). You can define an error handler in your client application code to execute some custom logic in this scenario. ## Change a Property Name If you change a property's name, this is a breaking or destructive change to both the server-side schema and the client-side object model. ## Warning ### Update existing documents If you change a property name in the server-side schema, you must update existing documents with that new property name or they do not sync to the client. This may give client users the impression that the data has been lost. ### How to Change a Property Name ## Tip ### Change a property name While changing a property name is a breaking change in both the server-side schema and the client-side object model, some SDKs do offer an API to map the name defined in a model class to a different internal name. This allows you to avoid renaming a property and triggering migrations, but instead map the realm property name to something different to match your code. You can use this API in these SDKs:\n\n A breaking server-side schema change requires you to [terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend, and then [re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) sync. Breaking schema changes prevent applications from automatically recovering from a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-handle-a-client-reset). As a result, we do not recommend making breaking server-side schema changes. Instead, you can let the existing collection remain in place with the existing schema, and create a partner collection with the new schema. A partner collection is a collection that contains the same data as the original collection, but has the new schema definition in place. Partner collections use database triggers to ensure that data flows in both directions, meaning that when one collection is written to, the other is also written to (with the data modifications required for the new schema). To implement a breaking schema change using the partner collection strategy, see [Make Breaking Schema Changes.](https://mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/#std-label-migrate-schema-partner-collection) If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, you must manually update the schema. [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)does not automatically update your schema for breaking changes. ### Handle Existing Atlas Documents If you choose to terminate and re-enable sync, you must update existing Atlas documents to enable them to Sync with your client applications. Without this additional handling, those documents do not Sync and it may appear in the client that the data has been lost. If an Atlas document maintains the old property name, the entire document no longer syncs to the client application. You could resolve this issue in a few ways: * Change the old field name on each document to match the new schema\n* Add a new field to each document with a name that matches the new schema, and copy the value from the old field into it After you've made these changes, the appropriate documents should once again sync to the client application. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data when you implement a schema change using the partner collection strategy, you must perform a migration when you open the realm. For more information, see your preferred SDK's migration page. If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, your client application must perform a [manual client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-manual-client-reset). You can define an error handler in your client application code to execute some custom logic in this scenario. ## Change Property Type but Keep the Name If you change a property's type while keeping the name, this is a breaking or destructive change to both the server-side schema and the client-side object model. ## Warning ### Update existing documents If you change a property's type in the server-side schema, you must update existing documents with that new property type or they do not sync to the client. This may give client users the impression that the data has been lost. ### How to Change a Property Type but Keep the Name A breaking server-side schema change requires you to [terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend, and then [re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) sync. Breaking schema changes prevent applications from automatically recovering from a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-handle-a-client-reset). As a result, we do not recommend making breaking server-side schema changes. Instead, you can let the existing collection remain in place with the existing schema, and create a partner collection with the new schema.\n\n To implement a breaking schema change using the partner collection strategy, see [Make Breaking Schema Changes.](https://mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/#std-label-migrate-schema-partner-collection) If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, you must manually update the schema. [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)does not automatically update your schema for breaking changes. ### Handle Existing Atlas Documents If you choose to terminate and re-enable sync, you must update existing Atlas documents to enable them to Sync with your client applications. Without this additional handling, those documents do not Sync and it may appear in the client that the data has been lost. If an Atlas document maintains the old property type, the entire document no longer syncs to the client application. You could resolve this issue in a few ways: * Change the old field type on each document to match the new schema\n* Add a new field to each document with a type that matches the new schema, and copy the value from the old field into it, transforming its type After you've made these changes, the appropriate documents should once again sync to the client application. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data when you implement a schema change using the partner collection strategy, you must perform a migration when you open the realm. For more information, see your preferred SDK's migration page. If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, your client application must perform a [manual client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-manual-client-reset). You can define an error handler in your client application code to execute some custom logic in this scenario. ## Change Property from Optional to Required If you change a property from optional to required, this is a breaking or destructive change to both the server-side schema and the client-side object model. ### How to Change a Property from Optional to Required A breaking server-side schema change requires you to [terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend, and then [re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) sync. Breaking schema changes prevent applications from automatically recovering from a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-handle-a-client-reset). As a result, we do not recommend making breaking server-side schema changes. Instead, you can let the existing collection remain in place with the existing schema, and create a partner collection with the new schema. A partner collection is a collection that contains the same data as the original collection, but has the new schema definition in place. Partner collections use database triggers to ensure that data flows in both directions, meaning that when one collection is written to, the other is also written to (with the data modifications required for the new schema). To implement a breaking schema change using the partner collection strategy, see [Make Breaking Schema Changes.](https://mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/#std-label-migrate-schema-partner-collection) If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, you must manually update the schema. [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)does not automatically update your schema for breaking changes. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data when you implement a schema change using the partner collection strategy, you must perform a migration when you open the realm. For more information, see your preferred SDK's migration page.\n\n ## Change Property from Required to Optional If you change a property from required to optional, this is a breaking or destructive change to both the server-side schema and the client-side object model. ### How to Change a Property from Required to Optional A breaking server-side schema change requires you to [terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) in the backend, and then [re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync) sync. Breaking schema changes prevent applications from automatically recovering from a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-handle-a-client-reset). As a result, we do not recommend making breaking server-side schema changes. Instead, you can let the existing collection remain in place with the existing schema, and create a partner collection with the new schema. A partner collection is a collection that contains the same data as the original collection, but has the new schema definition in place. Partner collections use database triggers to ensure that data flows in both directions, meaning that when one collection is written to, the other is also written to (with the data modifications required for the new schema). To implement a breaking schema change using the partner collection strategy, see [Make Breaking Schema Changes.](https://mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/#std-label-migrate-schema-partner-collection) If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, you must manually update the schema. [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode)does not automatically update your schema for breaking changes. ### Handle Client Realm Database Files If you already have a client-side realm file that contains data when you implement a schema change using the partner collection strategy, you must perform a migration when you open the realm. For more information, see your preferred SDK's migration page. If you choose to terminate and re-enable sync instead of using the partner collection strategy to resolve this type of breaking change, your client application must perform a [manual client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-manual-client-reset). You can define an error handler in your client application code to execute some custom logic in this scenario. ## Summary * Non-breaking schema changes on synced realms are backward compatible, allowing old clients to sync with newer ones.\n* Non-breaking changes to the schema of a synced realm do not require any additional configuration. However, you may need to migrate client realm files even when making non-breaking changes.\n* Breaking changes are modifications to existing properties of a schema.\n* To perform breaking schema changes to a synced realm, create a partner collection with the necessary schema changes and manually copy the data from the first collection to the second collection.\n* To keep partner collections up-to-date with each other, set up database triggers to copy changed data from one collection to its partner.\n* You can implement a breaking change by terminating and re-enabling sync and performing a manual client reset, but it is not recommended. ← [Generate SDK Object Models](https://mongodb.com/docs/atlas/app-services/sync/data-model/generate-sdk-object-models/ \"Previous Section\")[Make Breaking Schema Changes](https://mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/mongodb/data-access/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Query Atlas from Client Apps On this page * [When to Use MongoDB Data Access](#when-to-use-mongodb-data-access)\n* [Set Up](#set-up)\n* [Create an App Services App](#create-an-app-services-app)\n* [Add an Authentication Provider](#add-an-authentication-provider)\n* [Add Rules to a Collection](#add-rules-to-a-collection)\n* [Add a Schema and Filters to Collection (Optional)](#add-a-schema-and-filters-to-collection--optional-)\n* [Query from Client Apps](#query-from-client-apps) You can query data in linked MongoDB Atlas clusters from client applications using standard MongoDB query language (MQL) syntax with **MongoDB Data Access**in the Realm SDKs. MongoDB Data Access secures data by enforcing your App's role-based access permissions, query filters, and document schemas. These features let you construct complex client-side queries with MQL while your data remains secure on the server. ## When to Use MongoDB Data Access You might want to use MongoDB Data Access in your application if: * You want to use an API like the MongoDB drivers\n* You want to write database queries in your client code instead of on a server\n* You want to construct ad hoc queries from the client device. You might want to use MongoDB Data Access **instead of** [Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync)in an application in these scenarios: * You are querying documents that are not or cannot be modeled in Realm Database.\n* You want to access collections that are not synced.\n* You do not want to persist data locally.\n* You are using the Realm Web SDK, which does not support Realm Database or Device Sync. As an alternative to MongoDB Data Access in **client-side** scenarios, you can use the following: * [Atlas Data API](https://mongodb.com/docs/atlas/app-services/data-api/#std-label-data-api)\n* [Atlas GraphQL API](https://mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) You can also use these APIs without a Realm SDK for your client app's programming language as long as the language has a HTTPS or GraphQL client. However, these APIs do not feature the same type-safe MQL syntax as the Realm SDKs' MongoDB Data Access. As alternative to MongoDB Data Access in **server-side** scenarios, you can use the following: * [MongoDB driver](https://www.mongodb.com/docs/drivers/). Using a MongoDB driver to connect to Atlas is the generally recommended server-side approach, as the drivers are more performant and flexible than connecting through App Services. If you would like to apply App Services Rules to driver operations, you can use the [App Services Wire Protocol.](https://mongodb.com/docs/atlas/app-services/mongodb/wire-protocol/#std-label-wire-protocol)\n* Atlas Data API\n* Atlas GraphQL API ## Set Up To use MongoDB Data Access from a Realm SDK, you must perform the following set up. 1 ### Create an App Services App Create an App Services App with a linked MongoDB data source. To learn more about App creation, refer to [Create an App](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app)and [Link a Data Source.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-link-a-data-source) 2 ### Add an Authentication Provider Add at least one authentication provider to the App. All MongoDB Data Access queries run in the context of an authenticated user. To learn more about enabling user authentication, refer to [Authentication Providers.](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) 3 ### Add Rules to a Collection To secure your client-side queries, you must add App Services Rules to any collections that you use with MongoDB Data Access. To learn how to add rules to collections, refer to [Define Roles & Permissions.](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-define-roles-and-permissions)\n\n 4 ### Add a Schema and Filters to Collection (Optional) In addition to rules, you can also add a schema and filters to collections that you query with MongoDB Data Access. [Schemas](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) define your App's data model and validate documents against it. Use filters to ensure that the clients only write data matching the schema to the database. [Filters](https://mongodb.com/docs/atlas/app-services/rules/filters/#std-label-filters) modify MongoDB queries before they are sent to the database so that queries only return a subset of results. For example, you could define a filter that modifies queries so that a user can only access data that they've written. While schemas and filters are not necessary to use MongoDB Data Access, you should add them to most production use cases. 5 ### Query from Client Apps For documentation on how to query MongoDB from the Realm SDKs, refer to the Realm MongoDB Data Access documentation: * [Query MongoDB - Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/mongodb-remote-access/#std-label-java-mongodb-data-access)\n* [Query MongoDB - .NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/app-services/mongodb-remote-access/#std-label-dotnet-mongodb-data-access)\n* [Query MongoDB - Node.js SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/query-mongodb/#std-label-node-mongodb-data-access)\n* [Query MongoDB - React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/app-services/query-mongodb/#std-label-react-native-mongodb-data-access)\n* [Query MongoDB - Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/app-services/mongodb-remote-access/#std-label-ios-mongodb-data-access)\n* [Query MongoDB - Web SDK](https://www.mongodb.com/docs/realm/web/mongodb/#std-label-web-mongodb-data-access) MongoDB Data Access **is not** supported in these Realm SDKs: * C++ SDK\n* Flutter SDK\n* Kotlin SDK ← [CRUD & Aggregation APIs](https://mongodb.com/docs/atlas/app-services/mongodb/crud-and-aggregation-apis/ \"Previous Section\")[Read Preference](https://mongodb.com/docs/atlas/app-services/mongodb/read-preference/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/mongodb/read-preference/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Read Preference On this page * [Overview](#overview)\n* [When To Specify Read Preference](#when-to-specify-read-preference)\n* [Procedure](#procedure)\n* [Navigate to the Cluster Configuration Screen](#navigate-to-the-cluster-configuration-screen)\n* [Specify a Cluster Read Preference](#specify-a-cluster-read-preference)\n* [Specify Read Preference Tags](#specify-read-preference-tags)\n* [Save the Cluster Configuration](#save-the-cluster-configuration)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Specify a Cluster Read Preference](#specify-a-cluster-read-preference-1)\n* [Specify Read Preference Tags](#specify-read-preference-tags-1)\n* [Deploy the Updated Data Source Configuration](#deploy-the-updated-data-source-configuration) ## Overview You can configure the [read preference](https://www.mongodb.com/docs/manual/core/read-preference/)for a [linked MongoDB Atlas cluster](https://mongodb.com/docs/atlas/app-services/mongodb/) to control the type of [replica set member](https://www.mongodb.com/docs/manual/core/replica-set-members/) that Atlas App Services routes database read requests to. You can also specify a [tag set](https://www.mongodb.com/docs/manual/core/read-preference/#replica-set-read-preference-tag-sets) to target specific members of the replica set. You cannot set the read preference on a [Federated data source.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats) By default, App Services uses a read preference of `primary`, which routes all read requests through the [primary node](https://www.mongodb.com/docs/manual/core/replica-set-primary/) of a replica set. ### When To Specify Read Preference The default read preference (`primary`) should be sufficient for most use cases. Consider specifying a cluster read preference when you need to do the following: * Read from a specific secondary that has a custom configuration, such as an analytics node with special indexes optimized for reporting workloads.\n* Read from a node in a specific region of a globally distributed replica set.\n* Maintain read availability during a replica set failover, i.e., continue to read potentially stale data when there is no `primary`node. ## Procedure ← [Query Atlas from Client Apps](https://mongodb.com/docs/atlas/app-services/mongodb/data-access/ \"Previous Section\")[Wire Protocol](https://mongodb.com/docs/atlas/app-services/mongodb/wire-protocol/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/sync/data-model/data-model-map/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Data Model Mapping On this page * [Overview](#overview)\n* [Databases, Collections, and Objects](#databases--collections--and-objects)\n* [Mapping with Development Mode](#mapping-with-development-mode)\n* [Mappings](#mappings)\n* [Type Name](#type-name)\n* [Property Types](#property-types)\n* [Array Properties](#array-properties)\n* [Embedded Objects](#embedded-objects)\n* [Sets](#sets)\n* [Dictionaries](#dictionaries)\n* [Relationships](#relationships)\n* [Example](#example)\n* [App Services Schema](#app-services-schema)\n* [Realm Object Schema](#realm-object-schema)\n* [Data in Atlas](#data-in-atlas) ## Overview This page contains information on how the App Services Schema used by Atlas Device Sync maps to the Realm Object Schema used by the Realm SDKs. To generate Realm SDK Schemas from your App Services Schemas, refer to [Generate SDK Object Models](https://mongodb.com/docs/atlas/app-services/sync/data-model/generate-sdk-object-models/#std-label-generate-sdk-object-models). To generate App Services Schemas from Realm SDK client code, refer to [Development Mode.](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) To learn more about how Device Sync uses these two schemas, refer to the [Sync Data Model Overview.](https://mongodb.com/docs/atlas/app-services/sync/data-model/sync-schema-overview/#std-label-sync-schema-overview) ## Databases, Collections, and Objects When you configure Device Sync, you [specify the data source](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-sync-config-data-source) where you want to store data. This data source may contain multiple databases, and each database may contain multiple collections. The [App Services schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) maps your Realm Database object names to collections in databases in your Device Sync data source. The`title` field in an App Services schema maps to the object type name in Realm Database. Because the `title` name determines the mapping between client objects and the appropriate Atlas collection, this name must be unique among all schemas in your synced data source. The `title` does not need to match the collection name. ## Example Consider an app with a database named `Pets`. It may contain multiple collections, such as `Canine` and `Feline`. The App Services schema for the `Canine` collection might resemble [the example below](#std-label-sync-app-services-schema-dog-example), where the `title` field of the schema is `Dog`. That would map a Realm Database object called`Dog` to the `Canine` collection in the `Pets` database. You could not have another schema whose `title` was `Dog` in the same cluster. For example, you could not sync an object with a `title`of `Dog` to both a `Debug` and a `Test` database in the same cluster. If you want to sync the same object to different collections for app development purposes, you must use different data sources - one cluster for development and a different cluster for production. ### Mapping with Development Mode When you [enable Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-enable-development-mode) in your Device Sync configuration, App Services can automatically create collections and schemas for Realm Database objects that you sync. It creates those collections in the [database you specify](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-sync-config-database-name) when you enable Development Mode. With Development Mode enabled, Sync looks for a collection whose App Services schema has a `title` that matches the name of your Realm Database object type. This collection could be in any database in your linked data source. It doesn't have to be in the database you add when you configure Development Mode.\n\n ## Example Consider an Atlas cluster with a database named `Pets`. It contains a`Feline` collection with existing data. In your application code, you define a new `Dog` object. You enable Development Mode, and specify the `Pets` database as the database in which to create collections for new object types. When you sync your new `Dog` object, App Services creates a `Dog` collection in the`Pets` database and creates a schema for it. The `title` of the object in the schema is `Dog`. If you later add a new `Person` object to your application code and then sync it, App Services creates a new collection for this`Person` object in the `Pets` database. If you wanted to create a collection for the `Person` object in a different database, you could [define a schema](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) for the `Person` object in a different database. Or you could disable and re-enable Development Mode, and select a different database in which to create new collections. ## Mappings ### Type Name The `title` field contains the name of the object type represented by the schema. This is equivalent to a class or schema name in a Realm SDK. The type name must be unique among all schemas in your synced cluster but is otherwise arbitrary and does not need to match the collection name. A conventional approach is to name each object type with a singular noun, like \"Dog\" or \"Person\". Schemas generated in development mode or by sampling existing documents use this convention. ## Note To work with Atlas Device Sync, type names cannot exceed 57 UTF-8 characters. ### Property Types You can configure the following constraints for a given property:\n\n Realm SDK data type documentation: ### Array Properties Both Realm Object Schemas and App Services Schemas support array properties. You can find information on using array data types in the Realm SDK documentation on defining a Realm Object Schema. For more information on modeling array properties in an App Services Schema, refer to [BSON Types - Array](https://mongodb.com/docs/atlas/app-services/schemas/types/#std-label-schema-type-array). App Services Schemas support certain constraints that Realm Object Schemas do not, such as specifying the minimum and maximum number of items. ### Embedded Objects Embedded objects are embedded as nested data inside of a parent object. An embedded object inherits the lifecycle of its parent object. It cannot exist as an independent Realm object. Realm SDK embedded object documentation: For more information on modeling to-one relationships in an App Services Schema, refer to [Embedded Object Relationships.](https://mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-relationships-embedded-object) ### Sets Realm Object Schemas and App Services Schemas both support the Set data type. A set is a collection of unique values. Realm SDK Set documentation: For more information on modeling sets in an App Services Schema, refer to [Set.](https://mongodb.com/docs/atlas/app-services/schemas/types/#std-label-schema-type-set) ### Dictionaries Realm Object Schemas and App Services Schemas both support the Dictionary data type. A set is a collection of unique values. A dictionary is a collection of dynamic and unique string keys paired with values of a given type. A dictionary is functionally an object or document without pre-defined field names. Realm SDK dictionary documentation: For more information on modeling dictionaries in an App Services Schema, refer to [Dictionary.](https://mongodb.com/docs/atlas/app-services/schemas/types/#std-label-schema-type-dictionary) ## Relationships Realm Object Schemas support the following types of relationships: * To-one relationships: A to-one relationship means that an object is related in a specific way to no more than one other object.\n* To-many relationships: A to-many relationship means that an object is related in a specific way to multiple objects.\n* Inverse relationships: An inverse relationship links an object back to any other objects that refer to it in a defined to-one or to-many relationship. App Services Schemas support to-one and to-many relationships. App Services Schemas _do not_ support inverse relationships. Realm SDK relationship documentation: For more information on modeling relationships in an App Services Schema, refer to [Relationships.](https://mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-relationships) ## Example This example shows how to model a `Dog` with Device Sync. ### App Services Schema This App Services Schema creates the `Dog` data model used by Device Sync.\n\n ` ### Realm Object Schema The following code examples create the `Dog` Realm Object Schema in each of the Realm SDKs. ### Data in Atlas An application using Device Sync for the `Dog` data model creates MongoDB documents in Atlas that looks like the following example. ```js {   \"_id\": ObjectId('616f44305a205add93ff1081'),   \"age\": 8,   \"breed\": \"Golden Retriever\",   \"name\": \"Jasper\" } \n``` ← [Make Breaking Schema Changes](https://mongodb.com/docs/atlas/app-services/sync/data-model/migrate-schema-partner-collection/ \"Previous Section\")[Configure Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure-device-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/mongodb/preimages/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Document Preimages On this page * [Overview](#overview)\n* [Performance](#performance)\n* [Enable Document Preimages](#enable-document-preimages)\n* [View Preimage-Enabled Collections](#view-preimage-enabled-collections)\n* [Disable Preimages for a Collection](#disable-preimages-for-a-collection) ## Overview Every [database trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-trigger) execution has a related change event. You can configure these change events to include**document preimages**. A preimage is a snapshot of a document _before_a change. ## Example Consider `updateOne` in a collection with preimages: `| pets.updateOne(      |\n| -------------------- |\n| { name: \"Fido\" },    |\n| { $inc: { age: 1 } } |\n| )                    | ` Preimages add the following data to write operation change events * the document preimage in the `fullDocumentBeforeChange` field  \nPreimage - the full document as it existed before the change  \n```  \n{  \n   \"name\": \"Fido\",  \n   \"age\": 3  \n}  \n```\n* the document postimage in the `fullDocument` field  \nPostimage - the full document immediately after the change  \n```  \n{  \n   \"name\": \"Fido\",  \n   \"age\": 4  \n}  \n``` ### Performance For clusters running MongoDB version 6.0 and newer, triggers use the cluster's built-in [change stream preimages](https://www.mongodb.com/docs/manual/changeStreams/#std-label-changeStreams)feature. Older versions of MongoDB store preimages directly in the oplog. Both of these add storage and compute overhead for each operation on the collection which may cause performance issues for collections with a high write throughput. ## Enable Document Preimages You can enable preimages when you [configure a database trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-create-a-database-trigger). Document Preimage is a setting on trigger configuration. Toggle this to enable document preimages for the collection. ## View Preimage-Enabled Collections To view the list of collections that store document preimages: 1. Navigate to the Linked Data Source configuration screen.\n2. Expand the Advanced Configuration section. This section contains the Preimage Preferences by Collectiontable. This table lists every collection that stores preimages in the oplog. Enabling preimages for a collection applies to all collections. This includes collections tied to triggers in a different App. Collections with no triggers that use preimages also appear here. ## Disable Preimages for a Collection You can disable collection-level preimages in the App Services UI. To disable preimages for a collection: 1. (Optional) Disable document preimages for triggers in the collection. Triggers with preimages continue to fire after disabling preimages. But they don't have the `fullDocumentBeforeChange` field in change events. This includes triggers in other App Services Apps.\n2. [Terminate sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync), if the collection is part of a synced cluster.\n3. View [the Preimage Preferences By Collection](#std-label-view-preimage-enabled-collections) table. Press theDisable button for a collection. This turns off preimages for that collection.\n4. [Re-enable Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-re-enable-realm-sync), if the collection is part of a synced cluster. ## Warning ### Restore Sync after Terminating Sync When you terminate and re-enable Atlas Device Sync, clients can no longer Sync. Your client must implement a client reset handler to restore Sync. This handler can discard or attempt to recover unsynchronized changes.\n\n",
  "https://www.mongodb.com/docs/atlas/app-services/mongodb/configure-advanced-rules/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure Advanced Rules On this page * [Overview](#overview)\n* [When To Use Advanced Mode](#when-to-use-advanced-mode)\n* [Procedure](#procedure)\n* [Navigate to the Collection Rules Screen](#navigate-to-the-collection-rules-screen)\n* [Convert to Advanced Mode](#convert-to-advanced-mode)\n* [Define the Collection Rules](#define-the-collection-rules)\n* [Save the Updated Collection Rules](#save-the-updated-collection-rules) ## Overview You can manually configure all aspects of a collection's rules by editing the underlying configuration document directly through the App Services UI. Advanced Mode refers to editing rules in this manner. ### When To Use Advanced Mode The default or \"Basic Mode\" rules editor in the App Services UI covers the majority of use cases for collection rules. However, there are times when you need more fine-grained control than the UI interface provides. Consider using Advanced Mode if you need to do the following: * Configure a role that can [only insert documents.](https://mongodb.com/docs/atlas/app-services/rules/examples/#std-label-role-template-insert-only)\n* Define field-level read or write permissions for a [field in an embedded document.](https://mongodb.com/docs/atlas/app-services/rules/examples/#std-label-role-template-embedded-documents)\n* Determine field-level write permissions dynamically using a [rule expression.](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) ## Warning Once you convert a collection's rules to Advanced Mode, you may not be able to switch back to editing that collection's rules through the Basic Mode interface. ## Procedure 1 ### Navigate to the Collection Rules Screen You can edit collection rules in Advanced Mode from the MongoDB rules screen in the App Services UI. To get to the rules screen for a collection, click Rules beneath Data Access in the left navigation menu and then select the collection from the list. ![Basic mode rules editor in the App Services UI](https://mongodb.com/docs/atlas/app-services/images/collection-rules-basic-mode.png) 2 ### Convert to Advanced Mode Click Advanced Mode in the top right corner of the collection rules interface. The UI will switch an editor that shows a preview of the underlying Advanced Mode rule configuration document. Click Convert to Advanced Mode and then clickConvert Rules to confirm. ![Advanced Mode preview in the App Services UI collection rules editor.](https://mongodb.com/docs/atlas/app-services/images/collection-rules-convert-to-advanced-mode.png) 3 ### Define the Collection Rules Once you have converted the collection to Advanced Mode you can edit the underlying configuration document. Collection rule configuration documents have the following form:\n\n `\n\n 4 ### Save the Updated Collection Rules Once you have finished editing the collection rules, clickSave. App Services will immediately begin using the new rule configuration you defined for all incoming queries on the collection. ← [Device Sync-Compatible Permissions](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/ \"Previous Section\")[Data Access Role Examples](https://mongodb.com/docs/atlas/app-services/rules/examples/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/values-and-secrets/access-a-value/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Access a Value ## Overview You can access an [Atlas App Services Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-value) from a [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) or an [Atlas Function.](https://mongodb.com/docs/atlas/app-services/functions/) ## Usage ### Reference a Value in a JSON Expression You can access a Value's stored data from a JSON expression using the [%%values](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---values) expansion. `| \"%%values.<Value Name>\" |\n| ----------------------- | ` ## Example The following JSON expression evaluates to `true` when the active user's id is included in the plain text array Value`adminUsers`: ```javascript { \"%%user.id\": { \"$in\": \"%%values.adminUsers\" } } \n``` ### Reference a Value in a Function You can access a Value's stored data from a Function using the [context.values](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-values) module. ```javascript context.values.get(\"<Value Name>\") \n``` ## Example The following Function returns `true` when the active user's id is included in the plain text array Value`adminUsers`: ```javascript exports = function() {     const adminUsers = context.values.get(\"adminUsers\");     const isAdminUser = adminUsers.indexOf(context.user.id) > 0;     return isAdminUser; } \n``` ## Tip ### See also: Reference an Environment Variable Trying to access an environment variable? Check out the function context documentation for more info on [context.environment.values.](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-environment-values) ## Summary * You can access an App Services Value from a [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) or from an [Atlas Function.](https://mongodb.com/docs/atlas/app-services/functions/) ← [Define and Manage Secrets](https://mongodb.com/docs/atlas/app-services/values-and-secrets/define-and-manage-secrets/ \"Previous Section\")[Define Data Access Permissions](https://mongodb.com/docs/atlas/app-services/rules/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/values-and-secrets/define-and-manage-secrets/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Define and Manage Secrets On this page * [Define a Secret](#define-a-secret)\n* [Create a New Secret](#create-a-new-secret)\n* [Define the Secret Value](#define-the-secret-value)\n* [Save and Deploy](#save-and-deploy)\n* [View Secrets](#view-secrets)\n* [Update a Secret](#update-a-secret)\n* [Access a Secret](#access-a-secret)\n* [Delete a Secret](#delete-a-secret) ## Define a Secret ## View Secrets ## Update a Secret ## Access a Secret You cannot directly read the value of a Secret after defining it. There are two ways to access a Secret that already exists in your app: 1. Link to the Secret by name in [Authentication Provider](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-auth-provider-list)and [Service configurations.](https://mongodb.com/docs/atlas/app-services/services/configure/services/#std-label-services-procedure)\n2. Expose the Secret with a [Secret Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/define-a-value/#std-label-define-value). You can access the Secret Value in function's with [context.values](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-values) or in a rule expression with[%%values.](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---values) ## Delete a Secret ← [Define a Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/define-a-value/ \"Previous Section\")[Access a Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/access-a-value/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/mongodb/wire-protocol/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Wire Protocol On this page * [Overview](#overview)\n* [Compatible Clients](#compatible-clients)\n* [Connection Strings](#connection-strings)\n* [Credentials](#credentials)\n* [Region](#region)\n* [Parameters](#parameters)\n* [Enable Wire Protocol Connections](#enable-wire-protocol-connections)\n* [Navigate to the Data Source Configuration Screen](#navigate-to-the-data-source-configuration-screen)\n* [Enable Connection Strings for the Cluster](#enable-connection-strings-for-the-cluster)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Enable Wire Protocol for the Cluster](#enable-wire-protocol-for-the-cluster)\n* [Deploy the Updated Data Source Configuration](#deploy-the-updated-data-source-configuration)\n* [Connect Over the Wire Protocol](#connect-over-the-wire-protocol)\n* [Connect to App Services with a Connection String](#connect-to-app-services-with-a-connection-string)\n* [Read and Modify Data](#read-and-modify-data)\n* [Call a Function](#call-a-function)\n* [Call a Service Action \\[DEPRECATED\\]](#call-a-service-action--deprecated-)\n* [Get the Logged In User's Data](#get-the-logged-in-user-s-data) ## Overview Atlas App Services natively implements a subset of the MongoDB wire protocol, which allows you to connect to an App through one of its [linked MongoDB Atlas data sources](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) using standard MongoDB drivers and tools. Clients use a specialized [App Services connection string](#std-label-connection-strings) to connect and send requests. App Services supports most client features over the wire protocol, including [role-based data access rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules),[functions](https://mongodb.com/docs/atlas/app-services/functions/), and [service actions.](https://mongodb.com/docs/atlas/app-services/reference/services/#std-label-service-actions) This is a good choice for languages that do not currently have a Realm SDK. The examples here are for Python, C++11, and the Mongo Shell. Any[MongoDB driver](https://www.mongodb.com/docs/drivers/) that supports the`appName` connection string parameter can use the wire protocol to connect to App Services. ## Note Federated data sources [do not support connections via the wire protocol.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats) ## Compatible Clients You can use the following tools and drivers to communicate with App Services using a connection string: * Version 4.0+ of the [mongo shell.](https://www.mongodb.com/docs/manual/mongo/)\n* Any MongoDB driver that supports the `appName` connection string parameter. All official MongoDB drivers support this parameter in their current releases. ## Note Connections to App Services over the wire protocol have access to the full functionality of the [MongoDB Service](https://mongodb.com/docs/atlas/app-services/mongodb/). However, App Services does not support all operations and features available in standard tools and clients. For details, see [MongoDB Service Limitations.](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations) ## Connection Strings To connect to App Services over the wire protocol, you must construct a[MongoDB connection string](https://www.mongodb.com/docs/manual/reference/connection-string/) that includes credentials for an application [user](https://mongodb.com/docs/atlas/app-services/users/) and an application-specific `appName` query parameter. ## Important ### URL Encoding\n\n App Services connection strings have the following form: `| mongodb://<credentials>@<region>.realm.mongodb.com:27020/?<parameters> |\n| ---------------------------------------------------------------------- | ` ### Credentials All operations that you issue over the wire protocol run in the context of a specific application user that you specify in the connection string. The user must be registered with one of the following authentication providers: * [Email/Password](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication)\n* [API Key](https://mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication)\n* [Custom JWT](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) The contents of connection string credentials depend on the authentication provider with which the user registered: ### Region The connection string must specify the [deployment region](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-regions) and cloud provider in which the App is hosted. Global Apps use the `global` region: ```shell mongodb://<credentials>@global.realm.mongodb.com:27020/?<parameters> \n``` Local Apps specify the cloud provider and region name using`<region>.<cloud>` format. For example, an app deployed to`aws-us-east-1` would use the following connection string: ```shell mongodb://<credentials>@us-east-1.aws.realm.mongodb.com:27020/?<parameters> \n``` ### Parameters App Services requires specific connection string options that identify the application you want to connect to and the authentication provider associated with the [credentials](#std-label-wire-protocol-credentials-userpass) that you provide. App Services connection strings have the following query parameters:\n\n ## Enable Wire Protocol Connections You must enable wire protocol connections for a linked clusters before you can connect to an App Services App with a connection string. ## Connect Over the Wire Protocol ### Connect to App Services with a Connection String To connect to App Services over the wire protocol, pass a[URL-encoded](https://en.wikipedia.org/wiki/Percent-encoding) [App Services connection string](#std-label-connection-strings) when you create a client, just as you would with a regular [connection string.](https://www.mongodb.com/docs/manual/reference/connection-string/) ### Read and Modify Data While connected to App Services over the wire protocol you can use standard MongoDB CRUD operations. App Services applies [role-based data access rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) to all queries in the context of the authenticated user specified in the connection string [credentials.](#std-label-wire-protocol-credentials) ### Call a Function You can call functions using the `callFunction` database command. | Command                                                                                                                           | Description                                                                                 | Prototype                                                              |\n| --------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |\n| callFunction[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-dbcommand-dbcmd.callFunction \"Permalink to this definition\") | Calls the specified [function](https://mongodb.com/docs/atlas/app-services/functions/) and returns any result. | {  callFunction: <function name>,  arguments: \\[<arg1>, <arg2>, ...\\]} | ### Call a Service Action \\[DEPRECATED\\] You can call service actions using the `callServiceFunction` database command.\n\n ### Get the Logged In User's Data You can get the [user object](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) for the authenticated user using the `userProfile` database command. | Command                                                                                                                         | Description                                                                            | Prototype          |\n| ------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------- | ------------------ |\n| userProfile[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-dbcommand-dbcmd.userProfile \"Permalink to this definition\") | Returns the [user object](https://mongodb.com/docs/atlas/app-services/users/) for the authenticated user. | {  userProfile: 1} | ← [Read Preference](https://mongodb.com/docs/atlas/app-services/mongodb/read-preference/ \"Previous Section\")[Document Preimages](https://mongodb.com/docs/atlas/app-services/mongodb/preimages/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/values-and-secrets/define-a-value/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Define a Value ## Overview You can define a new [Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-value) from the App Services UI or by importing an application directory that contains one or more Value configuration files. Select the tab below that corresponds to the method that you want to use. ## Procedure ## Summary * You can use the App Services UI or Realm CLI to create and define App Services Values. ← [Values & Secrets](https://mongodb.com/docs/atlas/app-services/values-and-secrets/ \"Previous Section\")[Define and Manage Secrets](https://mongodb.com/docs/atlas/app-services/values-and-secrets/define-and-manage-secrets/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/mongodb/crud-and-aggregation-apis/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # CRUD & Aggregation APIs On this page * [Overview](#overview)\n* [CRUD Operations](#crud-operations)\n* [Query Operators](#query-operators)\n* [Update Operators](#update-operators)\n* [Bulk Write Operations](#bulk-write-operations)\n* [Query Options](#query-options)\n* [Aggregation](#aggregation)\n* [Aggregation Methods](#aggregation-methods)\n* [Aggregation Pipeline Stage Availability](#aggregation-pipeline-stage-availability)\n* [Aggregation Pipeline Operator Availability](#aggregation-pipeline-operator-availability)\n* [Database Commands](#database-commands)\n* [Database Command Availability](#database-command-availability) ## Overview This page lists [MongoDB data source](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) support for MongoDB commands, operators, options, and aggregation stages. For information on how to read and write data in MongoDB from a function, see [Query MongoDB Atlas.](https://mongodb.com/docs/atlas/app-services/functions/mongodb/#std-label-functions-mongodb) For more information on supported features and limitations, see[Service Limitations.](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations) ## Note Support for an operation may depend on whether you're running the operation as an application user or as a system user. * A [user function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-user-functions) runs in the context of a specific application user and enforces data access permissions and schema validation, which makes some operations untenable.\n* A [system function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) runs as a generic system user and is not subject to rules or schema validation. Some operations are only available in system functions. ## CRUD Operations ### Query Operators Atlas App Services supports most [query operators](https://www.mongodb.com/docs/manual/reference/operator/query/) for queries that run in a[user function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-user-functions). However, some evaluation operators and all geospatial and bitwise operators are only available in [system functions.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) #### Comparison Operator Availability\n\n #### Logical Operator Availability | Operation                                                                 | User Function | System Function |\n| ------------------------------------------------------------------------- | ------------- | --------------- |\n| [$and](https://www.mongodb.com/docs/manual/reference/operator/query/and/) | Yes           | Yes             |\n| [$not](https://www.mongodb.com/docs/manual/reference/operator/query/not/) | Yes           | Yes             |\n| [$nor](https://www.mongodb.com/docs/manual/reference/operator/query/nor/) | Yes           | Yes             |\n| [$or](https://www.mongodb.com/docs/manual/reference/operator/query/or/)   | Yes           | Yes             | #### Array Operator Availability | Operation                                                                             | User Function | System Function |\n| ------------------------------------------------------------------------------------- | ------------- | --------------- |\n| [$all](https://www.mongodb.com/docs/manual/reference/operator/query/all/)             | Yes           | Yes             |\n| [$elemMatch](https://www.mongodb.com/docs/manual/reference/operator/query/elemMatch/) | Yes           | Yes             |\n| [$size](https://www.mongodb.com/docs/manual/reference/operator/query/size/)           | Yes           | Yes             | #### Element Operator Availability | Operation                                                                       | User Function | System Function |\n| ------------------------------------------------------------------------------- | ------------- | --------------- |\n| [$exists](https://www.mongodb.com/docs/manual/reference/operator/query/exists/) | Yes           | Yes             |\n| [$type](https://www.mongodb.com/docs/manual/reference/operator/query/type/)     | Yes           | Yes             | #### Evaluation Operator Availability\n\n #### Geospatial Operator Availability | Operation                                                                                     | User Function | System Function |\n| --------------------------------------------------------------------------------------------- | ------------- | --------------- |\n| [$geoIntersects](https://www.mongodb.com/docs/manual/reference/operator/query/geoIntersects/) | No            | Yes             |\n| [$geoWithin](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/)         | No            | Yes             |\n| [$near](https://www.mongodb.com/docs/manual/reference/operator/query/near/)                   | No            | Yes             |\n| [$nearSphere](https://www.mongodb.com/docs/manual/reference/operator/query/nearSphere/)       | No            | Yes             | #### Bitwise Operator Availability | Operation                                                                                   | User Function | System Function |\n| ------------------------------------------------------------------------------------------- | ------------- | --------------- |\n| [$bitsAllClear](https://www.mongodb.com/docs/manual/reference/operator/query/bitsAllClear/) | No            | Yes             |\n| [$bitsAllSet](https://www.mongodb.com/docs/manual/reference/operator/query/bitsAllSet/)     | No            | Yes             |\n| [$bitsAnyClear](https://www.mongodb.com/docs/manual/reference/operator/query/bitsAnyClear/) | No            | Yes             |\n| [$bitsAnySet](https://www.mongodb.com/docs/manual/reference/operator/query/bitsAnySet/)     | No            | Yes             | ### Update Operators App Services supports most [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) for queries that run in a[user function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-user-functions). However, some array update operators are only available in [system functions.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) #### Field Update Operator Availability\n\n #### Array Update Operator Availability | Operation                                                                                                                       | User Function | System Function |\n| ------------------------------------------------------------------------------------------------------------------------------- | ------------- | --------------- |\n| [$ (Positional Update)](https://www.mongodb.com/docs/manual/reference/operator/update/positional/)                              | Yes           | Yes             |\n| [$addToSet](https://www.mongodb.com/docs/manual/reference/operator/update/addToSet/)                                            | Yes           | Yes             |\n| [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/)                                                      | Yes           | Yes             |\n| [$pull](https://www.mongodb.com/docs/manual/reference/operator/update/pull/)                                                    | Yes           | Yes             |\n| [$push](https://www.mongodb.com/docs/manual/reference/operator/update/push/)                                                    | Yes           | Yes             |\n| [$pullAll](https://www.mongodb.com/docs/manual/reference/operator/update/pullAll/)                                              | Yes           | Yes             |\n| [$\\[\\] (All Positional Update)](https://www.mongodb.com/docs/manual/reference/operator/update/positional-all/)                  | Yes           | Yes             |\n| [$\\[element\\] (Filtered Positional Update)](https://www.mongodb.com/docs/manual/reference/operator/update/positional-filtered/) | Yes           | Yes             | #### Array Update Operator Modifiers Availability\n\n #### Bitwise Update Operator Availability | Operator                                                                   | User Function | System Function |\n| -------------------------------------------------------------------------- | ------------- | --------------- |\n| [$bit](https://www.mongodb.com/docs/manual/reference/operator/update/bit/) | Yes           | Yes             | ### Bulk Write Operations App Services supports bulk write operations using the same API as the[MongoDB Node.js driver.](http://mongodb.github.io/node-mongodb-native/3.6/) ## Tip App Services also provides the [collection.bulkWrite()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.bulkWrite)method for performing bulk write operations. #### Ordered Bulk Write Operation Availability You define ordered bulk operations by calling[collection.initializeOrderedBulkOp()](https://mongodb.github.io/node-mongodb-native/3.6/api/Collection.html#initializeOrderedBulkOp) and manipulating the[OrderedBulkOperation](https://mongodb.github.io/node-mongodb-native/3.6/api/OrderedBulkOperation.html) object that it returns. App Services supports the following `OrderedBulkOperation` methods: | Operation                                                                     | User Function | System Function |\n| ----------------------------------------------------------------------------- | ------------- | --------------- |\n| [execute](https://www.mongodb.com/docs/manual/reference/method/Bulk.execute/) | Yes           | Yes             |\n| [find](https://www.mongodb.com/docs/manual/reference/method/Bulk.find/)       | Yes           | Yes             |\n| [insert](https://www.mongodb.com/docs/manual/reference/method/Bulk.insert/)   | Yes           | Yes             | #### Unordered Bulk Write Operation Availability You define unordered bulk operations by calling[collection.initializeUnorderedBulkOp()](https://mongodb.github.io/node-mongodb-native/3.6/api/Collection.html#initializeUnorderedBulkOp) and manipulating the[OrderedBulkOperation](https://mongodb.github.io/node-mongodb-native/3.6/api/UnorderedBulkOperation.html) object that it returns. App Services supports the following `UnorderedBulkOperation` methods:\n\n ### Query Options App Services does not support configuring the following options for any CRUD operation in [user functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-user-functions). All query options are available in [system functions.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) #### Query Option Availability | Option                                                                                               | User Context | System Context |\n| ---------------------------------------------------------------------------------------------------- | ------------ | -------------- |\n| [Read Isolation (Read Concern)](https://www.mongodb.com/docs/manual/reference/read-concern/)         | No           | Yes            |\n| [Write Acknowledgment (Write Concern)](https://www.mongodb.com/docs/manual/reference/write-concern/) | No           | Yes            |\n| [Collation](https://www.mongodb.com/docs/manual/reference/collation/)                                | No           | Yes            | ## Aggregation ### Aggregation Methods App Services supports aggregation on the both the database and collection level using the following commands: * [db.aggregate()](https://www.mongodb.com/docs/manual/reference/method/db.aggregate/)\n* [db.collection.aggregate()](https://www.mongodb.com/docs/manual/reference/method/db.collection.aggregate/) ### Aggregation Pipeline Stage Availability App Services does not support the following [aggregation pipeline stages](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/) when you [run an aggregation pipeline](https://mongodb.com/docs/atlas/app-services/functions/mongodb/aggregate/#std-label-mongodb-aggregate) in the context of an[application user](https://mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts). All aggregation pipeline stages are available to the system user except for `$indexStats`.\n\n ## Note By default, `$merge` and `$out` route the entire aggregation operation to the cluster's primary node. If you want to force these stages to respect your configured cluster read preference, set the `enforceReadPref` option to`true`. ### Aggregation Pipeline Operator Availability App Services supports all [aggregation pipeline operators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/) when you [run an aggregation pipeline](https://mongodb.com/docs/atlas/app-services/functions/mongodb/aggregate/#std-label-mongodb-aggregate) in the [system user](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) context. App Services supports all pipeline operators in an [application user](https://mongodb.com/docs/atlas/app-services/users/#std-label-user-accounts) context with the following exceptions: | Operator                                                                                  | User Context | System Context |\n| ----------------------------------------------------------------------------------------- | ------------ | -------------- |\n| [$function](https://www.mongodb.com/docs/manual/reference/operator/aggregation/function/) | No           | Yes            | ## Database Commands App Services does not support any [database commands](https://www.mongodb.com/docs/manual/reference/command/) in the Client SDKs or [Functions](https://mongodb.com/docs/atlas/app-services/functions/). You can, however, call a limited subset of database commands when connected to a MongoDB cluster over the [App Services wire protocol.](https://mongodb.com/docs/atlas/app-services/mongodb/wire-protocol/#std-label-wire-protocol) The following [database commands](https://www.mongodb.com/docs/manual/reference/command/) are partially supported over the wire protocol. Unsupported options for each command are listed below. ## Note App Services Apps cannot run commands on the `admin` database. ### Database Command Availability\n\n | \\[[1](#ref-f1-id1)\\] | App Services supports allowDiskUse when run in a Function or Trigger with [system-level permissions.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) |\n| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ← [Connect to MongoDB Data Sources](https://mongodb.com/docs/atlas/app-services/mongodb/ \"Previous Section\")[Query Atlas from Client Apps](https://mongodb.com/docs/atlas/app-services/mongodb/data-access/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/dependencies/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # External Dependencies On this page * [Add an External Package](#add-an-external-package)\n* [Add Packages by Name and Version](#add-packages-by-name-and-version)\n* [Upload a Dependency Directory](#upload-a-dependency-directory)\n* [Import a Package in a Function](#import-a-package-in-a-function)\n* [Import a Full Module](#import-a-full-module)\n* [Import a Module Subfolder](#import-a-module-subfolder) An **external dependency** is a library that includes code that you can't or don't want to implement yourself. For example, you might use an official library for an external service or a custom implementation of a data structure or algorithm. Atlas App Services automatically transpiles dependencies and also supports most built-in Node.js modules. ## Note ### Create Your Own Modules Though most npm modules are written by third parties, you can also create and publish your own npm modules to house logic specific to your application. You can make your modules available to the Node.js community or reserve them for private use. For more information, check out npm's guide on [Contributing packages to the registry](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry). ## Add an External Package To import and use an external dependency, you first need to add the dependency to your application. You can either [add packages by name](#std-label-dependencies-add-by-name) or [upload a directory of dependencies.](#std-label-dependencies-upload-zip) ## Important ### Override Existing Dependencies You can only use one method at a time to specify the external packages your app can use. The most recent method that you used to specify dependencies is the source of truth and overrides previous specifications. For example, a package added by name through the UI overrides any copies of the same package that you've added previously, including those in an [uploaded dependency directory.](#std-label-dependencies-upload-zip) ### Add Packages by Name and Version You can add packages from the [npm registry](https://www.npmjs.com/) to your app by name. You can either add a specific version or use the latest version. ### Upload a Dependency Directory You can upload a zipped `node_modules` directory of packages to your app. Zipped dependency directories may not exceed 15MB. 1 #### Locally Install External Dependencies To upload external dependencies, you first need a local`node_modules` folder containing at least one Node.js package. You can use the following code snippet to install a dependency locally you would like to upload: `| npm install <package name> |\n| -------------------------- | ` If the `node_modules` folder does not already exist, this command automatically creates it. ## Note ### Alternative Methods of Installation You can also configure a `package.json` and run the`npm install` command to install all packages (and their dependencies) listed in your `package.json`. To learn more about npm and `node_modules`, consult the[npm documentation](https://docs.npmjs.com/cli/install). 2 #### Create a Dependency Archive Now that you've downloaded all of your npm modules, you need to package them up in an archive so you can upload them to App Services. Create an archive containing the `node_modules` folder: ```shell tar -czf node_modules.tar.gz node_modules/ \n``` ## Note ### Supported Archive Formats App Services supports `.tar`, `.tar.gz`, `.tgz`, and `.zip` archive formats. 3 #### Upload the Dependency Archive Once you've created an archive containing your dependencies, you can upload your dependency archive using the App Services UI or [realm-cli:](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) ## Import a Package in a Function You can import built-in modules and external packages that you've added to your app and then use them in your functions. To import a package, call `require()` with the package name from within the function body. ## Important ### Where Do I Import Modules?\n\n ### Import a Full Module ```javascript exports = () => {    const R = require(\"ramda\");    return R.map(x => x*2, [1,2,3]); } \n``` ### Import a Module Subfolder ```javascript exports = function(arg){    const cloneDeep = require(\"lodash/cloneDeep\");    var original = { name: \"Deep\" };    var copy = cloneDeep(original);    copy.name = \"John\";    console.log(`original: ${original.name}`);    console.log(`copy: ${copy.name}`);    return (original != copy); }; \n``` ← [Global Modules](https://mongodb.com/docs/atlas/app-services/functions/globals/ \"Previous Section\")[Test Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/test/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/mongodb/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Query MongoDB Atlas You can work with data in a linked [MongoDB Data Source](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources) from a function by using a built-in data source client. The client includes methods that allow you to read, write, and aggregate data. For examples of how to work with a data source in a function, refer to the following guides: * [Read Data from MongoDB Atlas](https://mongodb.com/docs/atlas/app-services/functions/mongodb/read/#std-label-mongodb-read)\n* [Write Data in MongoDB Atlas](https://mongodb.com/docs/atlas/app-services/functions/mongodb/write/#std-label-mongodb-write)\n* [Aggregate Data in MongoDB Atlas](https://mongodb.com/docs/atlas/app-services/functions/mongodb/aggregate/#std-label-mongodb-aggregate) For detailed reference information on available query and aggregation methods, see [MongoDB API Reference.](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#std-label-mongodb-api-reference) `| exports = async function() {                           |\n| ------------------------------------------------------ |\n| // 1. Get a data source client                         |\n| const mongodb = context.services.get(\"mongodb-atlas\"); |\n| // 2. Get a database & collection                      |\n| const db = mongodb.db(\"myDatabase\")                    |\n| const collection = db.collection(\"myCollection\")       |\n| // 3. Read and write data with MongoDB queries         |\n| await collection.insertOne({                           |\n| text: \"Hello, world!\",                                 |\n| author: context.user.id                                |\n| })                                                     |\n| return await collection.findOne({                      |\n| author: context.user.id                                |\n| })                                                     |\n| }                                                      | ` ← [Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/ \"Previous Section\")[Read Data from MongoDB Atlas - Functions](https://mongodb.com/docs/atlas/app-services/functions/mongodb/read/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/javascript-support/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # JavaScript Support On this page * [Syntax](#syntax)\n* [Built-In Objects](#built-in-objects)\n* [Built-In Methods & Properties](#built-in-methods---properties)\n* [Built-In Modules](#built-in-modules)\n* [Fully Supported Modules](#fully-supported-modules)\n* [Partially Supported Modules](#partially-supported-modules)\n* [Unsupported Modules](#unsupported-modules) [Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) fully support JavaScript ES5 syntax as well as most modern JavaScript features included in EcmaScript 2015 (ES6) and more recent releases. They can also access most Node.js built-in modules. ## Syntax\n\n ## Built-In Objects | Feature                                                                                                     | Supported |\n| ----------------------------------------------------------------------------------------------------------- | --------- |\n| [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/BigInt)         | No        |\n| [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map)               | Yes       |\n| [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise)       | Yes       |\n| [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Proxy)           | No        |\n| [Reflect](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Reflect)       | No        |\n| [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set)               | Yes       |\n| [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol)         | Yes       |\n| [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypedArray) | Yes       |\n| [WeakMap](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/WeakMap)       | Yes       |\n| [WeakSet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/WeakSet)       | No        | ## Built-In Methods & Properties\n\n ## Built-In Modules You can [import and use](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-import-external-dependencies) standard Node built-in modules in [functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions). Atlas Functions support most built-ins with either full or partial support. Some built-ins that are not suited for serverless workloads are not supported. ## Note The supported modules and partially supported modules are compatible with [Node API version 10.18.1](https://nodejs.org/docs/v10.18.1/api/). Avoid using APIs in these modules introduced after or deprecated since Node 10.18.1. ### Fully Supported Modules Atlas App Services fully supports the following built-in modules: * [assert](https://nodejs.org/docs/v10.18.1/api/assert.html)\n* [buffer](https://nodejs.org/docs/v10.18.1/api/buffer.html)\n* [events](https://nodejs.org/docs/v10.18.1/api/events.html)\n* [net](https://nodejs.org/docs/v10.18.1/api/net.html)\n* [os](https://nodejs.org/docs/v10.18.1/api/os.html)\n* [path](https://nodejs.org/docs/v10.18.1/api/path.html)\n* [punycode](https://github.com/bestiejs/punycode.js)  \n## Note  \nThe [built-in punycode module is deprecated](https://nodejs.org/docs/v10.18.1/api/punycode.html). However, App Services provide the [punycode](https://www.npmjs.com/package/punycode) module from `npm`automatically. You can import the module with:  \n`| const punycode = require(\"punycode\"); |  \n| ------------------------------------- |  \n`\n* [querystring](https://nodejs.org/docs/v10.18.1/api/querystring.html)\n* [stream](https://nodejs.org/docs/v10.18.1/api/stream.html)\n* [string\\_decoder](https://nodejs.org/docs/v10.18.1/api/string%5Fdecoder.html)\n* [timers](https://nodejs.org/docs/v10.18.1/api/timers.html)\n* [tls](https://nodejs.org/docs/v10.18.1/api/tls.html)\n* [tty](https://nodejs.org/docs/v10.18.1/api/tty.html)\n* [url](https://nodejs.org/docs/v10.18.1/api/url.html)\n* [zlib](https://nodejs.org/docs/v10.18.1/api/zlib.html) ### Partially Supported Modules App Services supports a subset of the functionality of the following modules. #### `dgram` App Services supports the following `dgram` APIs:\n\n App Services does **not** support the following `dgram` APIs: * [socket.ref](https://nodejs.org/api/dgram.html#dgram%5Fsocket%5Fref)\n* [socket.setTTL](https://nodejs.org/api/dgram.html#dgram%5Fsocket%5Fsetttl%5Fttl)\n* [socket.unref](https://nodejs.org/api/dgram.html#dgram%5Fsocket%5Funref) #### `dns` App Services supports the [dns](https://nodejs.org/docs/v10.18.1/api/dns.html) module with the following **exceptions**: * App Services does **not** support the [dns Promises API](https://nodejs.org/docs/v10.18.1/api/dns.html#dns%5Fdns%5Fpromises%5Fapi)\n* App Services does **not** support [resolver.cancel()](https://nodejs.org/docs/v10.18.1/api/dns.html#dns%5Fresolver%5Fcancel) #### `fs` App Services supports the following `fs` APIs: * [accessSync](https://nodejs.org/docs/v10.18.1/api/fs.html#fs%5Ffs%5Faccesssync%5Fpath%5Fmode)\n* [constants](https://nodejs.org/docs/v10.18.1/api/fs.html#fs%5Ffs%5Fconstants)\n* [lstatSync](https://nodejs.org/docs/v10.18.1/api/fs.html#fs%5Ffs%5Flstatsync%5Fpath%5Foptions)\n* [readFileSync](https://nodejs.org/docs/v10.18.1/api/fs.html#fs%5Ffs%5Freadfilesync%5Fpath%5Foptions)\n* [statSync](https://nodejs.org/docs/v10.18.1/api/fs.html#fs%5Ffs%5Fstatsync%5Fpath%5Foptions) #### `http`, `http/2` and `https` App Services supports all of the [http](https://nodejs.org/docs/v10.18.1/api/http.html)and [https](https://nodejs.org/docs/v10.18.1/api/https.html) APIs **except**for the [Server](https://nodejs.org/docs/v10.18.1/api/http.html#http%5Fclass%5Fhttp%5Fserver)class functionality. Similarly, App Services supports only the client-side APIs of[http/2.](https://nodejs.org/docs/v10.18.1/api/http2.html) #### `process` App Services supports the following `process` APIs: * [hrTime](https://nodejs.org/docs/v10.18.1/api/process.html#process%5Fprocess%5Fhrtime%5Ftime)\n* [nextTick](https://nodejs.org/docs/v10.18.1/api/process.html#process%5Fprocess%5Fnexttick%5Fcallback%5Fargs)\n* [version](https://nodejs.org/docs/v10.18.1/api/process.html#process%5Fprocess%5Fversion)\n* [versions](https://nodejs.org/docs/v10.18.1/api/process.html#process%5Fprocess%5Fversions) #### `util` App Services supports the [util](https://nodejs.org/docs/v10.18.1/api/util.html) module with the following **exceptions**:\n\n #### `crypto` App Services supports the [crypto](https://nodejs.org/api/crypto.html) module with the following **exceptions**: * App Services does **not** support [crypto.createDiffieHellman()](https://nodejs.org/api/crypto.html#crypto%5Fcrypto%5Fcreatediffiehellman%5Fprime%5Fprimeencoding%5Fgenerator%5Fgeneratorencoding)\n* App Services does **not** support [crypto.createDiffieHellmanGroup()](https://nodejs.org/api/crypto.html#crypto%5Fcrypto%5Fcreatediffiehellmangroup%5Fname)\n* App Services does **not** support [crypto.createECDH()](https://nodejs.org/api/crypto.html#crypto%5Fcrypto%5Fcreateecdh%5Fcurvename) ### Unsupported Modules Atlas Functions **do not** support the following built-in modules: * `child_process`\n* `cluster`\n* `domain`\n* `readline`\n* `v8`\n* `vm` ← [Handle Errors in Functions](https://mongodb.com/docs/atlas/app-services/functions/handle-errors/ \"Previous Section\")[Atlas Triggers](https://mongodb.com/docs/atlas/app-services/triggers/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/test/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Test Atlas Functions On this page * [Before You Begin](#before-you-begin)\n* [Unit Tests for Functions](#unit-tests-for-functions)\n* [Get a local copy of your App Services App](#get-a-local-copy-of-your-app-services-app)\n* [Create a new Function](#create-a-new-function)\n* [Write Function code](#write-function-code)\n* [Export Function for use in unit tests](#export-function-for-use-in-unit-tests)\n* [Unit test exported Function code](#unit-test-exported-function-code)\n* [Mock Services](#mock-services)\n* [Integration Tests for Functions](#integration-tests-for-functions)\n* [Create a test App](#create-a-test-app)\n* [Test in live environment](#test-in-live-environment) This page describes some strategies you can use to test your Atlas Functions. Due to differences between the Functions JavaScript runtime and the standard Node.js runtime, you must take some unique considerations into account when testing Functions. This page covers how to handle the uniqueness of Functions. ## Before You Begin 1. [Create an Atlas App Services App](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app)\n2. [Configure the CLI to work with your App](https://mongodb.com/docs/atlas/app-services/cli/#std-label-realm-cli) or[automate deployment with Github](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github) ## Unit Tests for Functions You can validate the functionality of your Functions with unit tests. Use any Node.js-compatible testing framework to test Functions. The examples on this page use the [Jest testing framework.](https://jestjs.io/) You must use [CommonJS modules](https://en.wikipedia.org/wiki/CommonJS) to write unit tests for Functions. 1 ### Get a local copy of your App Services App 2 ### Create a new Function Create a new Function. In the App's configuration files, create a new JavaScript file in the `functions` directory for your function. `| touch functions/hello.js |\n| ------------------------ | ` You also need to add configuration information for the Function to `functions/config.json`. ``` {     \"name\": \"hello\",     \"private\": false,     \"run_as_system\": true }, \n``` ## Tip ### See also:  For more information on creating a new Function, refer to [Define a Function.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-define-a-function) 3 ### Write Function code To make your Function code easy to test, keep it modular by separating its concerns into distinct components. You must keep all logic for the Function in the file you defined in the previous step. You cannot perform relative imports from other files in your project in a Function file. You can also [import dependencies using npm.](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) You must export your function by assigning it to `exports`. hello.js ```js function greet(word) {   return \"hello \" + word; } function greetWithPunctuation(word, punctuation) {   return greet(word) + punctuation; } // Function exported to App Services exports = greetWithPunctuation; \n``` 4 ### Export Function for use in unit tests To use your code to use in separate Node.js unit test files, you must use CommonJS `module.exports` syntax. This syntax is not compatible with the Functions runtime. The Atlas Functions environment does not provide the Node.js global `module`. To export modules to your unit tests while keeping the file compatible with Functions, wrap the the `module.exports` statement with a check to see if the global `module` object exists. functions/hello.js ```js function greet(word) {   return \"hello \" + word; } function greetWithPunctuation(word, punctuation) {   return greet(word) + punctuation; } // Function exported to App Services exports = greetWithPunctuation; // export locally for use in unit test\n\n   module.exports = { greet, greetWithPunctuation }; } \n``` 5 ### Unit test exported Function code Now you can write unit tests for the modules that you exported from the Function file. Create a test file for the Function file in a separate `test` directory somewhere in your project. ```shell mkdir -p test/unit touch test/unit/hello.test.js \n``` Import the modules you exported in the previous step and add unit tests. test/unit/hello.test.js ```js const { greet, greetWithPunctuation } = require(\"../../functions/hello\"); test(\"should greet\", () => {   const helloWorld = greet(\"world\");   expect(helloWorld).toBe(\"hello world\"); }); test(\"should greet with punctuation\", () => {   const excitedHelloWorld = greetWithPunctuation(\"world\", \"!!!\");   expect(excitedHelloWorld).toBe(\"hello world!!!\"); }); \n``` ### Mock Services To write unit tests for Functions that use the [global context object](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-function-context)or one of the [other global modules](https://mongodb.com/docs/atlas/app-services/functions/globals/#std-label-function-global-modules)that Functions expose, you must create mocks of their behavior. In this example, the Function references an [App Services Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-value)via `context.values.get()` and creates an ObjectId using the global module[BSON.](https://mongodb.com/docs/atlas/app-services/functions/globals/#std-label-bson) accessAppServicesGlobals.js ```js  function accessAppServicesGlobals() {    const mongodb = context.services.get(\"mongodb-atlas\");    const objectId = BSON.ObjectId()    // ... do stuff with these values  }  exports = accessAppServicesGlobals;  if (typeof module !== \"undefined\") {    module.exports = accessAppServicesGlobals;  } \n``` Attach these mocks to the Node.js global namespace. This lets you call the mocks in your unit tests the same way you do in the Functions runtime. ```js global.context = {   // whichever global context methods you want to mock.   // 'services', 'functions', values, etc. } // you can also mock other Functions global modules global.BSON = {   // mock methods } \n``` You may also want to declare and remove these mocks in setup and teardown blocks so that they do not pollute the global namespace. ```js  // adds context mock to global namespace before each test  beforeEach(() => {    global.context = {      // your mocking services    };  });  // removes context from global namespace after each test  afterEach(() => {    delete global.context;  });  test(\"should perform operation using App Services globals\", () => {    // test function that uses context  }); \n``` ## Example ### Mocking a Function that accesses context The function in this example accesses an App Services Value and returns it. helloWithValue.js ```js function greet() {   const greeting = context.values.get(\"greeting\"); // the greeting is 'beautiful world'   return \"hello \" + greeting; } exports = greet; if (typeof module !== \"undefined\") {   module.exports = greet; } \n``` Now create a test file `helloWithValue.test.js`. The test file contains the following: * Import the function exported from `helloWithValue.js`.\n* A mock of `context.values.get()`. Wrap the mock in set up and tear down blocks so that it does not pollute the global namespace.\n* A test of the imported function that uses the mock. helloWithValue.test.js ```js // import the function const greet = require(\"../../functions/helloWithValue\"); // wrap the mock in beforeEach/afterEach blocks to avoid // pollution of the global namespace beforeEach(() => {   // mock of context.values.get()   global.context = {     values: {       get: (val) => {         const valsMap = {           greeting: \"magnificent morning\",         };\n\n       },     },   }; }); afterEach(() => {   // delete the mock to not pollute global namespace   delete global.context; }); // test function using mock test(\"should greet with value\", () => {   const greeting = greet();   expect(greeting).toBe(\"hello magnificent morning\"); }); \n``` ## Integration Tests for Functions You should perform integration tests on all Functions before deploying them to production environments. This is especially important because the Atlas Function JavaScript runtime differs from the standard Node.js runtime. Unexpected errors can occur if you do not test functions deployed to App Services. There is no single way to write integration tests for Functions. As Functions can be used in a variety of different contexts for different purposes, each use case requires a different integration testing strategy. For example, the way you create an integration test for a Function that you invoke from a Realm client SDK is different from the way you test a GraphQL Custom Resolver Function, which is different from how you would test a Database Trigger Function. However, there are some general steps that you can take to writing integration tests for Functions. On a high level these steps are: 1. Create a testing App with the same configuration as your production App.\n2. Write integration tests that interact with your Functions deployed to a live testing environment. The remainder of this section explains how to implement integration tests for your App in more detail. ## Tip ### See also:  For more information on the unique aspects of the Functions JavaScript runtime, refer to: * [Function Constraints](https://mongodb.com/docs/atlas/app-services/functions/#std-label-function-constraints)\n* [JavaScript Support](https://mongodb.com/docs/atlas/app-services/functions/javascript-support/#std-label-js-support) For more information on the different use cases for Functions, refer to [When to Use Functions.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-when-to-use-functions) 1 ### Create a test App Create an App for testing purposes that has the same configuration as your production App, except using different data sources and backend configuration. For more information on how you can create multiple Apps with the same configuration, see [Configure an App Environment.](https://mongodb.com/docs/atlas/app-services/apps/environment/#std-label-app-environment) 2 ### Test in live environment Once you have deployed your test App, test its functionality using your preferred testing language and framework. The [Realm client SDKs](https://www.mongodb.com/docs/realm/introduction/#std-label-intro-realm-database) are useful for testing Apps. These SDKs provide first-class access to App Services. In your testing suite, you can connect to your testing App with a Realm SDK. Test the interaction with the App using the Realm SDK. ## Example ### Testing a Database Trigger Function This example uses the Realm Node.js SDK and the Jest testing framework to test a Database Trigger. The Trigger Function creates a [materialized view](https://en.wikipedia.org/wiki/Materialized%5Fview)of total sales for a product whenever a new sale is made. The Trigger fires every time an entry is added to the `sales` table. It increments the `total_sales` field on the `total_sales_materialized` table by one. The Database Trigger has the following configuration: triggers/materializeTotalSales.json ``` {   \"id\": \"62bb0d9f852c6e062432c454\",   \"name\": \"materializeTotalSales\",   \"type\": \"DATABASE\",   \"config\": {     \"operation_types\": [\"INSERT\"],     \"database\": \"store\",     \"collection\": \"sales\",     \"service_name\": \"mongodb-atlas\",     \"match\": {},     \"project\": {},     \"full_document\": true,     \"full_document_before_change\": false,     \"unordered\": false,     \"skip_catchup_events\": false   },   \"disabled\": false,   \"event_processors\": {     \"FUNCTION\": {       \"config\": {         \"function_name\": \"materializeTotalSales\"       }     }   } } \n``` The Trigger invokes the following Function: functions/materializeTotalSales.js ```js exports = function (changeEvent) {   const {\n\n   } = changeEvent;   const totalSalesMaterialization = context.services     .get(\"mongodb-atlas\")     .db(\"store\")     .collection(\"total_sales_materialized\");   totalSalesMaterialization.updateOne(     { _id: productId },     { $inc: { total_sales: 1 } },     { upsert: true }   ); }; \n``` This example tests the Trigger using the [Node.js Realm SDK](https://www.mongodb.com/docs/realm/sdk/node/#std-label-node-intro)to interact with MongoDB Atlas. You can also use any [Realm SDK](https://www.mongodb.com/docs/realm/sdk/#std-label-realm-sdks)with the MongoDB Query API or one of the [MongoDB drivers](https://www.mongodb.com/docs/drivers/)to query MongoDB Atlas to test a Database Trigger. test/integration/materializeTotalSales.test.js ```js const { app_id } = require(\"../../realm_config.json\"); const Realm = require(\"realm\"); const { BSON } = require(\"realm\"); let user; const app = new Realm.App(app_id); const sandwichId = BSON.ObjectId(); const saladId = BSON.ObjectId(); // utility function async function sleep(ms) {   await new Promise((resolve) => setTimeout(resolve, ms)); } // Set up. Creates and logs in a user, which you need to query MongoDB Atlas // with the Realm Node.js SDK beforeEach(async () => {   const credentials = Realm.Credentials.anonymous();   user = await app.logIn(credentials); }); // Clean up. Removes user and data created in the test. afterEach(async () => {   const db = user.mongoClient(\"mongodb-atlas\").db(\"store\");   await db.collection(\"sales\").deleteMany({});   await db.collection(\"total_sales_materialized\").deleteMany({});   await app.deleteUser(user); }); test(\"Trigger creates a new materialization\", async () => {   const sales = user     .mongoClient(\"mongodb-atlas\")     .db(\"store\")     .collection(\"sales\");   await sales.insertOne({     _id: BSON.ObjectId(),     productId: sandwichId,     price: 12.0,     timestamp: Date.now(),   });   // give time for the Trigger to execute on Atlas   await sleep(1000);   const totalSalesMaterialized = user     .mongoClient(\"mongodb-atlas\")     .db(\"store\")     .collection(\"total_sales_materialized\");   const allSandwichSales = await totalSalesMaterialized.findOne({     _id: sandwichId,   });   // checks that Trigger increments creates and increments total_sales   expect(allSandwichSales.total_sales).toBe(1); }); test(\"Trigger updates an existing materialization\", async () => {   const sales = user     .mongoClient(\"mongodb-atlas\")     .db(\"store\")     .collection(\"sales\");   await sales.insertOne({     _id: BSON.ObjectId(),     productId: saladId,     price: 15.0,     timestamp: Date.now(),   });   await sales.insertOne({     _id: BSON.ObjectId(),     productId: saladId,     price: 15.0,     timestamp: Date.now(),   });   // give time for Trigger to execute on Atlas   await sleep(1000);   const totalSalesMaterialized = user     .mongoClient(\"mongodb-atlas\")     .db(\"store\")     .collection(\"total_sales_materialized\");   const allSaladSales = await totalSalesMaterialized.findOne({     _id: saladId,   });   // checks that Trigger increments total_sales for each sale   expect(allSaladSales.total_sales).toBe(2); }); \n```\n\n",
  "https://www.mongodb.com/docs/atlas/app-services/functions/context/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Context On this page * [Overview](#overview)\n* [Get App Metadata (context.app)](#get-app-metadata--context.app-)\n* [Call a Function (context.functions)](#call-a-function--context.functions-)\n* [Check the App Environment (context.environment)](#check-the-app-environment--context.environment-)\n* [context.environment.values](#context.environment.values)\n* [Connect to a MongoDB Data Source or Third-Party Service (context.services)](#connect-to-a-mongodb-data-source-or-third-party-service--context.services-)\n* [Get Request Metadata (context.request)](#get-request-metadata--context.request-)\n* [Get User Data (context.user)](#get-user-data--context.user-)\n* [Reference a Value (context.values)](#reference-a-value--context.values-)\n* [Send an HTTP Request (context.http)](#send-an-http-request--context.http-) ## Overview [Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) have access to a global `context`object that contains metadata for the incoming requests and provides access to components and services that you've configured in your App Services App. The `context` object exposes the following interfaces:\n\n ## Get App Metadata (`context.app`) The `context.app` object contains metadata about the App that contains the Function. `| {                         |\n| ------------------------- |\n| \"id\": string,             |\n| \"clientAppId\": string,    |\n| \"name\": string,           |\n| \"projectId\": string,      |\n| \"deployment\": {           |\n| \"model\": string,          |\n| \"providerRegion\": string, |\n| },                        |\n| \"lastDeployed\": string,   |\n| \"hostingUri\": string,     |\n| }                         | ` `context.app.id`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.app.id \"Permalink to this definition\") The unique internal ID of the App that contains the Function. ## Example ``` \"60c8e59866b0c33d14ee634a\" \n``` `context.app.clientAppId`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.app.clientAppId \"Permalink to this definition\") The unique Client App ID for the App that contains the Function. ## Example ``` \"myapp-abcde\" \n``` `context.app.name`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.app.name \"Permalink to this definition\") The name of the App that contains the Function. ## Example ``` \"myapp\" \n``` `context.app.projectId`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.app.projectId \"Permalink to this definition\") The ID of the Atlas Project that contains the App. ## Example ``` \"5e1ec444970199272441a214\" \n``` `context.app.deployment`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.app.deployment \"Permalink to this definition\") An object that describes the App's [deployment model and region.](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-model) ## Example ``` {   \"model\": \"LOCAL\",   \"providerRegion\": \"aws-us-east-1\" } \n``` `context.app.lastDeployed`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.app.lastDeployed \"Permalink to this definition\") The date and time that the Atlas App was last deployed, formatted as an ISODate string. ## Example ```javascript \"2022-10-31T12:00:00.000Z\" \n``` `context.app.hostingUri`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.app.hostingUri \"Permalink to this definition\") If [static hosting](https://mongodb.com/docs/atlas/app-services/hosting/#std-label-static-hosting) is enabled, this value is the base URL for hosted assets. ## Example ``` \"myapp-abcde.mongodbstitch.com\" \n``` ## Call a Function (`context.functions`) You can call any [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) in your application through the `context.functions` interface.\n\n Calls a specific function and returns the result. ```javascript context.functions.execute(functionName, ...args) \n``` | Parameter    | Type   | Description                                                                                                                 |\n| ------------ | ------ | --------------------------------------------------------------------------------------------------------------------------- |\n| functionName | string | The name of the function.                                                                                                   |\n| args...      | mixed  | A variadic list of arguments to pass to the function. Each function parameter maps to a separate, comma-separated argument. | ## Example ```javascript // difference: subtracts b from a using the sum function exports = function(a, b) {     return context.functions.execute(\"sum\", a, -1 * b); }; \n``` ## Check the App Environment (`context.environment`) You can access information about your App's current [environment](https://mongodb.com/docs/atlas/app-services/apps/environment/#std-label-app-environment) configuration and access environment-specific values through the `context.environment` interface. `context.environment.tag`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.environment.tag \"Permalink to this definition\") The name of the app's current environment as a string. Possible values: * `\"\"`\n* `\"development\"`\n* `\"testing\"`\n* `\"qa\"`\n* `\"production\"` ## Example ```javascript exports = async function() {   switch(context.environment.tag) {     case \"\": {       return \"There is no current environment\"     }     case \"development\": {       return \"The current environment is development\"     }     case \"testing\": {       return \"The current environment is testing\"     }     case \"qa\": {       return \"The current environment is qa\"     }     case \"production\": {       return \"The current environment is production\"     }   } }; \n``` ### context.environment.values An object where each field maps the name of an [environment value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-environment-values) to its value in the current environment. ## Example ```javascript exports = async function() {   const baseUrl = context.environment.values.baseUrl }; \n``` ## Connect to a MongoDB Data Source or Third-Party Service (`context.services`) You can access a client for a linked MongoDB Atlas cluster or Federated data source through the `context.services` interface. You can also access third-party services, although this feature is deprecated. `context.services.get()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.services.get \"Permalink to this definition\") Gets a service client for the specified service or `undefined` if no such service exists. ```javascript context.services.get(serviceName) \n```\n\n ## Example Read and write data in MongoDB Atlas ```javascript exports = async function() {   // Get the cluster's data source client   const mdb = context.services.get(\"mongodb-atlas\");   // Reference a specific database/collection   const db = mdb.db(\"myApp\");   const collection = db.collection(\"myCollection\");   // Run a MongoDB query   return await collection.find({     name: \"Rupert\",     age: { $lt: 50 },   }) }; \n``` \\[Deprecated\\] Call third-party service actions ```javascript exports = async function() {   // Instantiate a service client for the HTTP Service named \"myHttpService\"   const http = context.services.get(\"myHttpService\");   // Call the HTTP service's get() action   try {     const response = await http.get({ url: \"https://www.mongodb.com\" });     return response.body.text()   } catch(err) {     // You might get an error if:     // - you passed invalid arguments     // - the service's rules prevent the action     console.error(err)   } }; \n``` ## Get Request Metadata (`context.request`) You can access information about the incoming request with the[context.request](#std-label-context-request) interface. ## Tip The `context.request` interface does not include request body payloads. In HTTPS endpoint functions, you can access the request body and other request details from the provided `request`argument. `context.request`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.request \"Permalink to this definition\") An object that contains information about the HTTP request that caused the function to execute. ```javascript {    \"remoteIPAddress\": <string>,    \"requestHeaders\": <object>,    \"webhookUrl\": <string>,    \"httpMethod\": <string>,    \"rawQueryString\": <string>,    \"httpReferrer\": <string>,    \"httpUserAgent\": <string>,    \"service\": <string>,    \"action\": <string> } \n```\n\n ## Example The following `context.request` document reflects a function call issued from `https://myapp.example.com/` by a user browsing with Chrome 73 on macOS High Sierra: ```javascript exports = function() {   return context.request } \n``` HIDE OUTPUT\n\n ` ## Get User Data (`context.user`) You can access information about the application or system user that called a function with the `context.user` interface. `context.user`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.user \"Permalink to this definition\") The [user object](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) of the authenticated user that called the function. ```javascript {     \"id\": <string>,     \"type\": <string>,     \"data\": <document>,     \"identities\": <array> } \n```\n\n ## Example The following `context.user` document reflects an[email/password](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication)user that is associated with a single [User API Key.](https://mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication-user-api-key) ```javascript exports = function() {   return context.user } \n``` HIDE OUTPUT ``` {   \"id\": \"5cbf68583025b12840664682\",   \"type\": \"normal\",   \"data\": {     \"email\": \"someone@example.com\",     \"name\": \"myApiKeyName\"   },   \"identities\": [     {       \"id\": \"5cbf68583025b12880667681\",       \"provider_type\": \"local-userpass\"     },     {       \"id\": \"5cbf6c6a922616045a388c71\",       \"provider_type\": \"api-key\"     }   ] } \n``` `context.runningAsSystem()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.runningAsSystem \"Permalink to this definition\") Evaluates to a boolean that is `true` if the function is running as a [system user](https://mongodb.com/docs/atlas/app-services/users/#std-label-system-user) and `false` otherwise. ```javascript exports = function() {   const isSystemUser = context.runningAsSystem()   if(isSystemUser) {     // Do some work that bypasses rules   } else {     // Do some work in the context of the user that called the function.   } } \n``` ## Reference a Value (`context.values`) You can access your app's static [values](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets) in a function with the `context.values` interface. `context.values.get(valueName)`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.values.get \"Permalink to this definition\") Gets the data associated with the provided value name or`undefined` if no such value exists. This data is either a plain text JSON value or a [secret](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-secret) exposed through a value. | Parameter | Type   | Description                                                                                         |\n| --------- | ------ | --------------------------------------------------------------------------------------------------- |\n| valueName | string | The name of the [value.](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets) | ## Example ```javascript exports = function() {   // Get a global value (or `undefined` if no value has the specified name)   const theme = context.values.get(\"theme\");   console.log(theme.colors)     // Output: { red: \"#ee1111\", blue: \"#1111ee\" }   console.log(theme.colors.red) // Output: \"#ee1111\" }; \n``` ## Send an HTTP Request (`context.http`) You can send HTTPS requests through a built-in client with the`context.http` interface. `context.http.get()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.http.get \"Permalink to this definition\")\n\n ```javascript exports = async function() {   const response = await context.http.get({ url: \"https://www.example.com/users\" })   // The response body is a BSON.Binary object. Parse it and return.   return EJSON.parse(response.body.text()); }; \n``` `context.http.post()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.http.post \"Permalink to this definition\") Sends an [HTTP POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) request to the specified URL. See [http.post()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.post/#mongodb-method-http.post) for detailed reference information, including parameter definitions and return types. ```javascript exports = async function() {   const response = await context.http.post({     url: \"https://www.example.com/messages\",     body: { msg: \"This is in the body of a POST request!\" },     encodeBodyAsJSON: true   })   // The response body is a BSON.Binary object. Parse it and return.   return EJSON.parse(response.body.text()); }; \n``` `context.http.put()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.http.put \"Permalink to this definition\") Sends an [HTTP PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT) request to the specified URL. See [http.put()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.put/#mongodb-method-http.put) for detailed reference information, including parameter definitions and return types. ```javascript exports = async function() {   const response = await context.http.put({     url: \"https://www.example.com/messages\",     body: { msg: \"This is in the body of a PUT request!\" },     encodeBodyAsJSON: true   })   // The response body is a BSON.Binary object. Parse it and return.   return EJSON.parse(response.body.text()); }; \n``` `context.http.patch()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.http.patch \"Permalink to this definition\") Sends an [HTTP PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) request to the specified URL. See [http.patch()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.patch/#mongodb-method-http.patch) for detailed reference information, including parameter definitions and return types. ```javascript exports = async function() {   const response = await context.http.patch({     url: \"https://www.example.com/diff.txt\",     body: { msg: \"This is in the body of a PATCH request!\" },     encodeBodyAsJSON: true   })   // The response body is a BSON.Binary object. Parse it and return.   return EJSON.parse(response.body.text()); }; \n``` `context.http.delete()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-context.http.delete \"Permalink to this definition\") Sends an [HTTP DELETE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE) request to the specified URL. See [http.delete()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.delete/#mongodb-method-http.delete) for detailed reference information, including parameter definitions and return types. ```javascript exports = async function() {   const response = await context.http.delete({ url: \"https://www.example.com/user/8675309\" }) }; \n```\n\n Sends an [HTTP HEAD](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD) request to the specified URL. See [http.head()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.head/#mongodb-method-http.head) for detailed reference information, including parameter definitions and return types. ```javascript exports = async function() {   const response = await context.http.head({ url: \"https://www.example.com/users\" })   // The response body is a BSON.Binary object. Parse it and return.   EJSON.parse(response.body.text()); }; \n``` ← [MongoDB API Reference](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/ \"Previous Section\")[Global Modules](https://mongodb.com/docs/atlas/app-services/functions/globals/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/mongodb/aggregate/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Aggregate Data in MongoDB Atlas - Functions On this page * [Overview](#overview)\n* [Data Model](#data-model)\n* [Run an Aggregation Pipeline](#run-an-aggregation-pipeline)\n* [Find Data with Atlas Search](#find-data-with-atlas-search)\n* [Aggregation Stages](#aggregation-stages)\n* [Filter Documents](#filter-documents)\n* [Group Documents](#group-documents)\n* [Project Document Fields](#project-document-fields)\n* [Add Fields to Documents](#add-fields-to-documents)\n* [Unwind Array Values](#unwind-array-values) ## Overview The examples on this page demonstrate how to use the MongoDB Query API in a function to aggregate documents in your Atlas cluster. MongoDB [aggregation pipelines](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/) run all documents in a collection through a series of data [aggregation stages](#std-label-mongodb-aggregation-stages) that allow you to filter and shape documents as well as collect summary data about groups of related documents. ## Note ### Supported Aggregation Stages Atlas App Services supports nearly all MongoDB aggregation pipeline stages and operators, but some stages and operators must be executed within a[system function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions). See [Aggregation Framework Limitations](https://mongodb.com/docs/atlas/app-services/mongodb/crud-and-aggregation-apis/#std-label-mongodb-crud-and-aggregation-apis-aggregation) for more information. ### Data Model The examples on this page use a collection named `store.purchases`that contains information about historical item sales in an online store. Each document contains a list of the purchased `items`, including the item `name` and the purchased `quantity`, as well as a unique ID value for the customer that purchased the items.\n\n ` #### Snippet Setup To use a code snippet in a [function](https://mongodb.com/docs/atlas/app-services/functions/), you must first instantiate a MongoDB collection handle: ```javascript exports = function() {   const mongodb = context.services.get(\"mongodb-atlas\");   const itemsCollection = mongodb.db(\"store\").collection(\"items\");   const purchasesCollection = mongodb.db(\"store\").collection(\"purchases\");   // ... paste snippet here ... } \n``` ## Run an Aggregation Pipeline You can execute an aggregation pipeline using the[collection.aggregate()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.aggregate) method. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet groups all documents in the `purchases` collection by their `customerId` value and aggregates a count of the number of items each customer purchases as well as the total number of purchases that they made. After grouping the documents the pipeline adds a new field that calculates the average number of items each customer purchases at a time,`averageNumItemsPurchased`, to each customer's document: ```javascript const pipeline = [   { \"$group\": {       \"_id\": \"$customerId\",       \"numPurchases\": { \"$sum\": 1 },       \"numItemsPurchased\": { \"$sum\": { \"$size\": \"$items\" } }   } },   { \"$addFields\": {       \"averageNumItemsPurchased\": {         \"$divide\": [\"$numItemsPurchased\", \"$numPurchases\"]       }   } } ] return purchasesCollection.aggregate(pipeline).toArray()   .then(customers => {     console.log(`Successfully grouped purchases for ${customers.length} customers.`)     for(const customer of customers) {       console.log(`customer: ${customer._id}`)       console.log(`num purchases: ${customer.numPurchases}`)       console.log(`total items purchased: ${customer.numItemsPurchased}`)       console.log(`average items per purchase: ${customer.averageNumItemsPurchased}`)     }     return customers   })   .catch(err => console.error(`Failed to group purchases by customer: ${err}`)) \n``` ### Find Data with Atlas Search You can run [Atlas Search](https://www.mongodb.com/docs/atlas/atlas-search/#std-label-fts-top-ref) queries on a collection with [collection.aggregate()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.aggregate) and the `$search` aggregation stage. ## Important App Services performs `$search` operations as a system user and enforces field-level rules on the returned search results. This means that a user may search on a field for which they do not have read access. In this case, the search is based on the specified field but no returned documents include the field. ```javascript exports = async function searchMoviesAboutBaseball() {   // 1. Get a reference to the collection you want to search.   const movies = context.services     .get(\"mongodb-atlas\")     .db(\"sample_mflix\")     .collection(\"movies\");   // 2. Run an aggregation with $search as the first stage.   const baseballMovies = await movies     .aggregate([       {         $search: {           text: {             query: \"baseball\",             path: \"plot\",           },         },       },       {         $limit: 5,       },       {         $project: {\n\n           title: 1,           plot: 1,         },       },     ])     .toArray();   return baseballMovies; }; \n``` HIDE OUTPUT\n\n ` ## Note ### $$SEARCH\\_META Variable Availability The [$$SEARCH\\_META](https://www.mongodb.com/docs/atlas/atlas-search/query-syntax/#aggregation-variable)aggregation variable is only available for functions that [run as system](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) or if the first role on the searched collection has its`apply_when` and `read` expressions set to `true`. If neither of these two scenarios apply, `$$SEARCH_META` is undefined and the aggregation will fail. ## Aggregation Stages ### Filter Documents You can use the [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) stage to filter incoming documents using standard MongoDB [query syntax.](https://www.mongodb.com/docs/manual/tutorial/query-documents/) ```javascript {   \"$match\": {     \"<Field Name>\": <Query Expression>,     ...   } } \n``` ## Example The following `$match` stage filters incoming documents to include only those where the `graduation_year` field has a value between`2019` and `2024`, inclusive. ```javascript {   \"$match\": {     \"graduation_year\": {       \"$gte\": 2019,       \"$lte\": 2024     },   } } \n``` ### Group Documents You can use the [$group](https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/) stage to aggregate summary data for groups of one or more documents. MongoDB groups documents based on the `_id` expression. ## Note You can reference a specific document field by prefixing the field name with a `$`. ```javascript {   \"$group\": {     \"_id\": <Group By Expression>,     \"<Field Name>\": <Aggregation Expression>,     ...   } } \n``` ## Example The following `$group` stage groups documents by the value of their`customerId` field and calculates the number of purchase documents that each `customerId` appears in. ```javascript {   \"$group\": {     \"_id\": \"$customerId\",     \"numPurchases\": { \"$sum\": 1 }   } } \n``` ### Project Document Fields You can use the [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) stage to include or omit specific fields from documents or to calculate new fields using[aggregation operators](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). To include a field, set its value to `1`. To omit a field, set its value to `0`. ## Note You cannot simultaneously omit and include fields other than `_id`. If you explicitly include a field other than `_id`, any fields you did not explicitly include are automatically omitted (and vice-versa). ```javascript {   \"$project\": {     \"<Field Name>\": <0 | 1 | Expression>,     ...   } } \n``` ## Example The following `$project` stage omits the `_id` field, includes the `customerId` field, and creates a new field named `numItems`where the value is the number of documents in the `items` array: ```javascript {   \"$project\": {     \"_id\": 0,     \"customerId\": 1,     \"numItems\": { \"$sum\": { \"$size\": \"$items\" } }   } } \n``` ### Add Fields to Documents You can use the [$addFields](https://www.mongodb.com/docs/manual/reference/operator/aggregation/addFields/) stage to add new fields with calculated values using [aggregation operators.](https://www.mongodb.com/docs/manual/reference/operator/aggregation/) ## Note `$addFields` is similar to [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) but does not allow you to include or omit fields. ## Example The following `$addFields` stages creates a new field named`numItems` where the value is the number of documents in the`items` array: ```javascript {\n\n     \"numItems\": { \"$sum\": { \"$size\": \"$items\" } }   } } \n``` ### Unwind Array Values You can use the [$unwind](https://www.mongodb.com/docs/manual/reference/operator/aggregation/unwind/) stage to aggregate individual elements of array fields. When you unwind an array field, MongoDB copies each document once for each element of the array field but replaces the array value with the array element in each copy. ```javascript {   $unwind: {     path: <Array Field Path>,     includeArrayIndex: <string>,     preserveNullAndEmptyArrays: <boolean>   } } \n``` ## Example The following `$unwind` stage creates a new document for each element of the `items` array in each document. It also adds a field called `itemIndex` to each new document that specifies the element's position index in the original array: ```javascript {   \"$unwind\": {     \"path\": \"$items\",     \"includeArrayIndex\": \"itemIndex\"   } } \n``` Consider the following document from the `purchases` collection: ```javascript {   _id: 123,   customerId: 24601,   items: [     { name: \"Baseball\", quantity: 5 },     { name: \"Baseball Mitt\", quantity: 1 },     { name: \"Baseball Bat\", quantity: 1 },   ] } \n``` If we apply the example `$unwind` stage to this document, the stage outputs the following three documents: ```javascript {   _id: 123,   customerId: 24601,   itemIndex: 0,   items: { name: \"Baseball\", quantity: 5 } }, {   _id: 123,   customerId: 24601,   itemIndex: 1,   items: { name: \"Baseball Mitt\", quantity: 1 } }, {   _id: 123,   customerId: 24601,   itemIndex: 2,   items: { name: \"Baseball Bat\", quantity: 1 } } \n``` ← [Write Data in MongoDB Atlas - Functions](https://mongodb.com/docs/atlas/app-services/functions/mongodb/write/ \"Previous Section\")[MongoDB API Reference](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/mongodb/write/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Write Data in MongoDB Atlas - Functions On this page * [Overview](#overview)\n* [Data Model](#data-model)\n* [Snippet Setup](#snippet-setup)\n* [Insert](#insert)\n* [Insert a Single Document (insertOne())](#insert-a-single-document--insertone---)\n* [Insert One or More Documents (insertMany())](#insert-one-or-more-documents--insertmany---)\n* [Update](#update)\n* [Update a Single Document (updateOne())](#update-a-single-document--updateone---)\n* [Update One or More Documents (updateMany())](#update-one-or-more-documents--updatemany---)\n* [Upsert Documents](#upsert-documents)\n* [Field Update Operators](#field-update-operators)\n* [Array Update Operators](#array-update-operators)\n* [Delete](#delete)\n* [Delete a Single Document (deleteOne())](#delete-a-single-document--deleteone---)\n* [Delete One or More Documents (deleteMany())](#delete-one-or-more-documents--deletemany---)\n* [Bulk Writes](#bulk-writes)\n* [Transactions](#transactions) ## Overview The examples on this page demonstrate how to use the MongoDB Query API in a function to insert, update, and delete data in your Atlas cluster. ## Note Federated data sources [do not support write operations.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats) ### Data Model The examples on this page use a collection named `store.items` that models various items available for purchase in an online store. Each item has a `name`, an inventory `quantity`, and an array of customer`reviews`. The JSON schema for store.items\n\n ` ### Snippet Setup To use a code snippet in a [function](https://mongodb.com/docs/atlas/app-services/functions/), you must first instantiate a MongoDB collection handle: ```javascript exports = function() {   const mongodb = context.services.get(\"mongodb-atlas\");   const itemsCollection = mongodb.db(\"store\").collection(\"items\");   const purchasesCollection = mongodb.db(\"store\").collection(\"purchases\");   // ... paste snippet here ... } \n``` ## Insert Insert operations take one or more documents and add them to a MongoDB collection. They return documents that describe the results of the operation. ### Insert a Single Document (`insertOne()`) You can insert a single document using the[collection.insertOne()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.insertOne) method. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet inserts a single item document into the `items` collection: ```javascript const newItem = {   \"name\": \"Plastic Bricks\",   \"quantity\": 10,   \"category\": \"toys\",   \"reviews\": [{ \"username\": \"legolover\", \"comment\": \"These are awesome!\" }] }; itemsCollection.insertOne(newItem)   .then(result => console.log(`Successfully inserted item with _id: ${result.insertedId}`))   .catch(err => console.error(`Failed to insert item: ${err}`)) \n``` ### Insert One or More Documents (`insertMany()`) You can insert multiple documents at the same time using the[collection.insertMany()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.insertMany) method. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet inserts multiple item documents into the `items` collection: ```javascript const doc1 = { \"name\": \"basketball\", \"category\": \"sports\", \"quantity\": 20, \"reviews\": [] }; const doc2 = { \"name\": \"football\",   \"category\": \"sports\", \"quantity\": 30, \"reviews\": [] }; return itemsCollection.insertMany([doc1, doc2])   .then(result => {     console.log(`Successfully inserted ${result.insertedIds.length} items!`);     return result   })   .catch(err => console.error(`Failed to insert documents: ${err}`)) \n``` ## Update Update operations find existing documents in a MongoDB collection and modify their data. You use standard MongoDB query syntax to specify which documents to update and [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/) to describe the changes to apply to matching documents. ## Note While running update operations, Atlas App Services temporarily adds a reserved field, `_id__baas_transaction`, to documents. If you modify data used by your app outside of App Services, you may need to unset this field. For more information, see [Transactional Locks.](https://mongodb.com/docs/atlas/app-services/mongodb/internal-database-usage/#std-label-transactional-locks) ### Update a Single Document (`updateOne()`) You can update a single document using the[collection.updateOne()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.updateOne) method. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet updates the `name`of a single document in the `items` collection from `lego` to`blocks` and adds a `price` of `20.99`: ```javascript const query = { \"name\": \"lego\" }; const update = {   \"$set\": {     \"name\": \"blocks\",     \"price\": 20.99,     \"category\": \"toys\"   } }; const options = { \"upsert\": false }; itemsCollection.updateOne(query, update, options)   .then(result => {     const { matchedCount, modifiedCount } = result;     if(matchedCount && modifiedCount) {\n\n     }   })   .catch(err => console.error(`Failed to update the item: ${err}`)) \n``` ### Update One or More Documents (`updateMany()`) You can update multiple documents in a collection using the[collection.updateMany()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.updateMany) method. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet updates all documents in the `items` collection by multiplying their `quantity` values by`10`: ```javascript const query = {}; const update = { \"$mul\": { \"quantity\": 10 } }; const options = { \"upsert\": false } return itemsCollection.updateMany(query, update, options)   .then(result => {     const { matchedCount, modifiedCount } = result;     console.log(`Successfully matched ${matchedCount} and modified ${modifiedCount} items.`)     return result   })   .catch(err => console.error(`Failed to update items: ${err}`)) \n``` ### Upsert Documents If an update operation does not match any document in the collection, you can automatically insert a single new document into the collection that matches the update query by setting the `upsert` option to`true`. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet updates a document in the `items` collection that has a `name` of `board game` by incrementing its `quantity` by `5`. The `upsert` option is enabled, so if no document has a `name` value of `\"board game\"` then MongoDB inserts a new document with the `name` field set to `\"board game\"` and the `quantity` value set to `5`: ```javascript const query = { \"name\": \"board games\" }; const update = { \"$inc\": { \"quantity\": 5 } }; const options = { \"upsert\": true }; itemsCollection.updateOne(query, update, options)   .then(result => {     const { matchedCount, modifiedCount, upsertedId } = result;     if(upsertedId) {       console.log(`Document not found. Inserted a new document with _id: ${upsertedId}`)     } else {       console.log(`Successfully increased ${query.name} quantity by ${update.$inc.quantity}`)     }   })   .catch(err => console.error(`Failed to upsert document: ${err}`)) \n``` ### Field Update Operators Field operators let you modify the fields and values of a document. #### Set the Value of a Field You can use the [$set](https://www.mongodb.com/docs/manual/reference/operator/update/set/)operator to set the value of a single field without affecting other fields in a document. ```javascript { \"$set\": { \"<Field Name>\": <Value>, ... } } \n``` #### Rename a Field You can use the [$rename](https://www.mongodb.com/docs/manual/reference/operator/update/rename/)operator to change the name of a single field in a document. ```javascript { \"$rename\": { \"<Current Field Name>\": <New Field Name>, ... } } \n``` #### Increment a Value You can use the [$inc](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)operator to add a specified number to the current value of a field. The number can be positive or negative. ```javascript { \"$inc\": { \"<Field Name>\": <Increment Number>, ... } } \n``` #### Multiply a Value You can use the [$mul](https://www.mongodb.com/docs/manual/reference/operator/update/mul/)operator to multiply a specified number with the current value of a field. The number can be positive or negative. ```javascript { \"$mul\": { \"<Field Name>\": <Multiple Number>, ... } } \n``` ### Array Update Operators Array operators let you work with values inside of arrays. #### Push an Element Into an Array\n\n ```javascript { \"$push\": { \"<Array Field Name>\": <New Array Element>, ... } } \n``` #### Pop the Last Element out of an Array You can use the [$pop](https://www.mongodb.com/docs/manual/reference/operator/update/pop/) operator to remove either the first or last element of an array field. Specify`-1` to remove the first element and `1` to remove the last element. ```javascript { \"$pop\": { \"<Array Field Name>\": <-1 | 1>, ... } } \n``` #### Add a Unique Element to an Array You can use the [$addToSet](https://www.mongodb.com/docs/manual/reference/operator/update/addToSet/) operator to add a value to an array field if that value is not already included in the array. If the value is already present, `$addToSet` does nothing. ```javascript { \"$addToSet\": { \"<Array Field Name>\": <Potentially Unique Value>, ... } } \n``` #### Remove Elements from an Array You can use the [$pull](https://www.mongodb.com/docs/manual/reference/operator/update/pull/)operator to remove all instances of any values that match a specified condition from an array field. ```javascript { \"$pull\": { \"<Array Field Name>\": <Value | Expression>, ... } } \n``` #### Update All Elements in an Array You can use the [$\\[\\] (All Positional Update)](https://www.mongodb.com/docs/manual/reference/operator/update/positional-all/) operator to update all elements in an array field: ## Example Consider a `students` collection that describes individual students in a class. The documents each include a `grades` field that contains an array of numbers: ``` { \"_id\" : 1, \"grades\" : [ 85, 82, 80 ] } { \"_id\" : 2, \"grades\" : [ 88, 90, 92 ] } { \"_id\" : 3, \"grades\" : [ 85, 100, 90 ] } \n``` The following update operation adds 10 to all values in the `grades` array of every student: ```javascript await students.updateMany(    {},    { $inc: { \"grades.$[]\": 10 } }, ) \n``` After the update, every grade value has increased by 10: ``` { \"_id\" : 1, \"grades\" : [ 15, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 18, 100, 102 ] } { \"_id\" : 3, \"grades\" : [ 15, 110, 100 ] } \n``` #### Update Specific Elements in an Array You can use the [$\\[element\\] (Filtered Positional Update)](https://www.mongodb.com/docs/manual/reference/operator/update/positional-filtered/) operator to update specific elements in an array field based on an array filter: ## Example Consider a `students` collection that describes individual students in a class. The documents each include a `grades` field that contains an array of numbers, some of which are greater than 100: ``` { \"_id\" : 1, \"grades\" : [ 15, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 18, 100, 102 ] } { \"_id\" : 3, \"grades\" : [ 15, 110, 100 ] } \n``` The following update operation sets all grade values greater than 100 to exactly 100: ```javascript await students.updateMany(    { },    {      $set: {        \"grades.$[grade]\" : 100      }    },    {      arrayFilters: [{ \"grade\": { $gt: 100 } }]    } ) \n``` After the update, all grade values greater than 100 are set to exactly 100 and all other grades are unaffected: ``` { \"_id\" : 1, \"grades\" : [ 15, 92, 90 ] } { \"_id\" : 2, \"grades\" : [ 18, 100, 100 ] } { \"_id\" : 3, \"grades\" : [ 15, 100, 100 ] } \n``` ## Delete Delete operations find existing documents in a MongoDB collection and remove them. You use standard MongoDB query syntax to specify which documents to delete. ### Delete a Single Document (`deleteOne()`)\n\n The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet deletes one document in the `items` collection that has a `name` value of `lego`: ```javascript const query = { \"name\": \"lego\" }; itemsCollection.deleteOne(query)   .then(result => console.log(`Deleted ${result.deletedCount} item.`))   .catch(err => console.error(`Delete failed with error: ${err}`)) \n``` ### Delete One or More Documents (`deleteMany()`) You can delete multiple items from a collection using the[collection.deleteMany()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.deleteMany) method. The following snippet deletes all documents in the `items` collection that do not have any `reviews`: ```javascript const query = { \"reviews\": { \"$size\": 0 } }; itemsCollection.deleteMany(query)   .then(result => console.log(`Deleted ${result.deletedCount} item(s).`))   .catch(err => console.error(`Delete failed with error: ${err}`)) \n``` ## Bulk Writes A bulk write combines multiple write operations into a single operation. You can issue a bulk write command using the[collection.bulkWrite()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.bulkWrite) method. ```javascript exports = async function(arg){     const doc1 = { \"name\": \"velvet elvis\", \"quantity\": 20, \"reviews\": [] };     const doc2 = { \"name\": \"mock turtleneck\",  \"quantity\": 30, \"reviews\": [] };     var collection = context.services.get(\"mongodb-atlas\")         .db(\"store\")         .collection(\"purchases\");     return await collection.bulkWrite(         [{ insertOne: doc1}, { insertOne: doc2}],         {ordered:true}); }; \n``` ## Transactions MongoDB supports [multi-document transactions](https://www.mongodb.com/docs/manual/core/transactions/) that let you read and write multiple documents atomically, even across collections. To perform a transaction:\n\n The following example creates two users, \"henry\" and \"michelle\", and a uses a transaction to move \"browniePoints\" between those users atomically: ```javascript exports = function () {   const client = context.services.get(\"mongodb-atlas\");   db = client.db(\"exampleDatabase\");   accounts = db.collection(\"accounts\");   browniePointsTrades = db.collection(\"browniePointsTrades\");   // create user accounts with initial balances   accounts.insertOne({ name: \"henry\", browniePoints: 42 });   accounts.insertOne({ name: \"michelle\", browniePoints: 144 });   // trade points between user accounts in a transaction   tradeBrowniePoints(     client,     accounts,     browniePointsTrades,     \"michelle\",     \"henry\",     5   );   return \"Successfully traded brownie points.\"; }; async function tradeBrowniePoints(   client,   accounts,   browniePointsTrades,   userAddPoints,   userSubtractPoints,   pointVolume ) {   // Step 1: Start a Client Session   const session = client.startSession();   // Step 2: Optional. Define options to use for the transaction   const transactionOptions = {     readPreference: \"primary\",     readConcern: { level: \"local\" },     writeConcern: { w: \"majority\" },   };   // Step 3: Use withTransaction to start a transaction, execute the callback, and commit (or abort on error)   // Note: The callback for withTransaction MUST be async and/or return a Promise.   try {     await session.withTransaction(async () => {       // Step 4: Execute the queries you would like to include in one atomic transaction       // Important:: You must pass the session to the operations       await accounts.updateOne(         { name: userSubtractPoints },         { $inc: { browniePoints: -1 * pointVolume } },         { session }       );       await accounts.updateOne(         { name: userAddPoints },         { $inc: { browniePoints: pointVolume } },         { session }       );       await browniePointsTrades.insertOne(         {           userAddPoints: userAddPoints,           userSubtractPoints: userSubtractPoints,           pointVolume: pointVolume,         },         { session }       );     }, transactionOptions);   } catch (err) {     // Step 5: Handle errors with a transaction abort     await session.abortTransaction();   } finally {     // Step 6: End the session when you complete the transaction     await session.endSession();   } } \n``` ← [Read Data from MongoDB Atlas - Functions](https://mongodb.com/docs/atlas/app-services/functions/mongodb/read/ \"Previous Section\")[Aggregate Data in MongoDB Atlas - Functions](https://mongodb.com/docs/atlas/app-services/functions/mongodb/aggregate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/handle-errors/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Handle Errors in Functions On this page * [Basic Error Handling](#basic-error-handling)\n* [View Logs](#view-logs)\n* [Retry Functions](#retry-functions)\n* [Recursively Call Function in Error Handling Blocks](#recursively-call-function-in-error-handling-blocks)\n* [Use Database Triggers to Retry](#use-database-triggers-to-retry) This page explains how to work with errors in Atlas Functions. ## Basic Error Handling You can handle Function errors using standard JavaScript error handling techniques like [try...catch statements.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch) `| function willThrowAndHandleError() {                              |\n| ----------------------------------------------------------------- |\n| try {                                                             |\n| throw new Error(\"This will always happen\");                       |\n| } catch (err) {                                                   |\n| console.error(\"An error occurred. Error message:\" + err.message); |\n| }                                                                 |\n| }                                                                 |\n| exports = willThrowAndHandleError;                                | ` ## View Logs You can view records of all Function executions including which an error prevented successful execution in [App Service Logs.](https://mongodb.com/docs/atlas/app-services/activity/#std-label-logs) Depending on how a Function is invoked, it shows up differently in the logs. For example, [logs for Functions called by Atlas Triggers](https://mongodb.com/docs/atlas/app-services/logs/trigger/#std-label-logs-trigger)show up in the logs as \"Triggers\" while [logs for Functions called from a Realm client SDK](https://mongodb.com/docs/atlas/app-services/logs/function/#std-label-logs-function)show up in the logs as \"Functions\". For more information, refer to the [Log entry type documentation.](https://mongodb.com/docs/atlas/app-services/activity/#std-label-logs) ## Retry Functions Atlas Functions do not have built-in retry behavior. You can add custom retry behavior. For example, you might want to add retry behavior if the third-party service that your Function calls has intermittent connectivity, and you want the Function to re-execute even if the third-party service is temporarily down. This section describes the following strategies to add retry behavior to your Functions: * [Recursively Call Functions in Error Handling Blocks](#std-label-functions-recursive-call)\n* [Use Database Triggers to Retry Functions](#std-label-functions-database-trigger-retry) ### Recursively Call Function in Error Handling Blocks You can handle operations that might fail by calling a Function recursively. On a high-level, this process includes the following components:\n\n The following table describes some advantages and disadvantages of handling Function retries with the recursive call strategy. | Advantages                                                                                                    | Disadvantages                                                         |\n| ------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |\n| All retry logic occurs within one function.Function can return a value after a retry.Minimal additional code. | All retries must occur within a single Function's max execution time. | The following code example demonstrates an implementation of retrying a Function by using recursion in error-handling blocks. ```js // Utility function to suspend execution of current process async function sleep(milliseconds) {   await new Promise((resolve) => setTimeout(resolve, milliseconds)); } // Set variables to be used by all calls to `mightFail` // Tip: You could also store `MAX_RETRIES` and `THROTTLE_TIME_MS` // in App Services Values const MAX_RETRIES = 5; const THROTTLE_TIME_MS = 5000; let currentRetries = 0; let errorMessage = \"\"; async function mightFail(...inputVars) {   if (currentRetries === MAX_RETRIES) {     console.error(       `Reached maximum number of retries (${MAX_RETRIES}) without successful execution.`     );     console.error(\"Error Message:\", errorMessage);     return;   }   let res;   try {     // operation that might fail     res = await callFlakyExternalService(...inputVars);   } catch (err) {     errorMessage = err.message;     // throttle retries     await sleep(THROTTLE_TIME_MS);     currentRetries++;     res = await mightFail(...inputVars);   }   return res; } exports = mightFail; \n``` ### Use Database Triggers to Retry You can also retry Functions by using a [Database Trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-trigger) to execute retries and a MongoDB collection to track previously-failed executions. On a high-level, this process includes the following components: * **Main Function** that executes the logic you want to retry, wrapped in the handler function (see below bullet point).\n* **Failed execution tracker MongoDB collection**that tracks failed executions of the main Function.\n* **Handler Function** that invokes the main Function and logs when the function fails to the failed execution tracker collection.\n* **Database Trigger Function** that reruns the handler function whenever the handler function adds an error to the failed execution tracker collection. You can support multiple main functions with one set of a handler Function, execution tracker collection, and Database Trigger Function.\n\n 1 #### Create a Function to handle execution retry First, create the handler Function `handleRetry` that invokes the main Function. `handleRetry` accepts the following parameters: | Parameter       | Type                | Description                                                             |\n| --------------- | ------------------- | ----------------------------------------------------------------------- |\n| functionToRetry | JavaScript Function | Function to retry.                                                      |\n| functionName    | String              | Name of the function you want to retry.                                 |\n| operationId     | ObjectId            | Unique identifier for the main function's execution, including retries. |\n| previousRetries | Number              | How many times the main function has previously been tried.             |\n| ...args         | Rest parameters     | Indefinite number of arguments passed to the main function.             | `handleRetry` performs the following operations: 1. Attempts to execute `functionToRetry` in a `try` statement. If the execution is successful, `handleRetry` returns the value returned by `functionToRetry`.\n2. If the execution of `functionToRetry` in the previous step throws an error, the `catch` statement handles the error as follows:  \n   1. Checks if the number of previous retries equals the maximum permitted number of retries. If the two numbers are the same, then the function throws an error because the max retries has been reached. The function no longer attempts to retry.  \n   2. Build a function execution log entry object to insert into the database.  \n   3. Get a reference to the failed execution tracker collection.  \n   4. Insert the function log exection log entry into the failed execution tracker collection. This insertion operation causes the Database Trigger Function, which you will make in the next step, to fire. The main function is passed as the argument `functionToRetry`.`handleRetry` attempts to execute the main Function. If the execution fails, this function attempts to retry the main function. 2 #### Create retry database trigger Now add the code for the Function that the Trigger invokes. The function `retryOperation` takes as a parameter `logEntry`, the document that the retry handler posted to the failed execution tracker collection. Then, `retryOperation` uses [context.functions.execute()](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-functions)to invoke the main function with information from `logEntry`. 3 #### Write Function to retry Now that you have the function handler and the retry Database Trigger Function, you can write the main function. In the following example, the Function randomly throws an error when performing addition. The JavaScript functions that execute this logic are the following: * `getRandomOneTwoThree()`: Helper function for generating errors for the example.\n* `additionOrFailure()`: Function with the main logic. The invocation of `additionOrFailure()` wrapped by the retry handler occurs in the exported function `additionWithRetryHandler()`.**All** functions that use the retry handler function should resemble this function. You must include the correct parameters to make this function work with the rest of the retry logic. These parameters are:\n\n The body of `additionWithRetryHandler` is the retry handler `handleRetry`invoked by `context.functions.execute()`, which in turn invokes `additionOrFailure`. The arguments you pass to context.functions.execute() are the following: | Argument          | Type                | Description                                                                                                                                    |\n| ----------------- | ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |\n| \"handleRetry\"     | String              | Name of the Function you defined to invoke the main function and post to the retry logs if the main function doesn't properly execute.         |\n| additionOrFailure | JavaScript function | The main function that handleRetry() invokes.                                                                                                  |\n| operationId       | BSON.ObjectId       | Passed in as argument from the parameter operationId of additionWithRetryHandler().                                                            |\n| retries           | Number              | Passed in as argument from the parameter retries of additionWithRetryHandler().                                                                |\n| ...args           | Spread arguments    | Zero or more arguments to pass to the function with main logic. Passed in as argument from the parameter ...args of additionWithRetryHandler() | Now when you invoke `additionWithRetryHandler`, the Function will retry if it fails. ← [Test Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/test/ \"Previous Section\")[JavaScript Support](https://mongodb.com/docs/atlas/app-services/functions/javascript-support/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/mongodb/read/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Read Data from MongoDB Atlas - Functions On this page * [Overview](#overview)\n* [Data Model](#data-model)\n* [Snippet Setup](#snippet-setup)\n* [Query Methods](#query-methods)\n* [Find a Single Document (findOne())](#find-a-single-document--findone---)\n* [Find One or More Documents (find())](#find-one-or-more-documents--find---)\n* [Count Documents in the Collection (count())](#count-documents-in-the-collection--count---)\n* [Query Patterns](#query-patterns)\n* [Find by Document ID](#find-by-document-id)\n* [Find by Date](#find-by-date)\n* [Match a Root-Level Field](#match-a-root-level-field)\n* [Match Multiple Fields](#match-multiple-fields)\n* [Match an Embedded Document Field](#match-an-embedded-document-field)\n* [Match an Array of Values](#match-an-array-of-values)\n* [Match an Array Element](#match-an-array-element)\n* [Query Operators](#query-operators)\n* [Compare Values](#compare-values)\n* [Evaluate a Logical Expression](#evaluate-a-logical-expression)\n* [Evaluate a Regular Expression](#evaluate-a-regular-expression) ## Overview The examples on this page demonstrate how to use the MongoDB Query API in a function to read documents from your Atlas cluster. Learn about the [methods](#std-label-mongodb-query-methods) that you can call to query data, the [operators](#std-label-mongodb-query-operators)that let you write expressive match filters, and some [patterns](#std-label-mongodb-query-patterns) for combining them to handle common use cases. ### Data Model The examples on this page use a collection named `store.items` that models various items available for purchase in an online store. Each item has a `name`, an inventory `quantity`, and an array of customer`reviews`. The JSON schema for store.items\n\n ` ### Snippet Setup To use a code snippet in a [function](https://mongodb.com/docs/atlas/app-services/functions/), you must first instantiate a MongoDB collection handle: ```javascript exports = function() {   const mongodb = context.services.get(\"mongodb-atlas\");   const itemsCollection = mongodb.db(\"store\").collection(\"items\");   const purchasesCollection = mongodb.db(\"store\").collection(\"purchases\");   // ... paste snippet here ... } \n``` ## Query Methods ### Find a Single Document (`findOne()`) You can find a single document using the [collection.findOne()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.findOne)method. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet finds a single document from the `items` collection that has a `quantity` greater than or equal to `25`: ```javascript const query = { \"quantity\": { \"$gte\": 25 } }; const projection = {  \"title\": 1,  \"quantity\": 1, } return itemsCollection.findOne(query, projection)   .then(result => {     if(result) {       console.log(`Successfully found document: ${result}.`);     } else {       console.log(\"No document matches the provided query.\");     }     return result;   })   .catch(err => console.error(`Failed to find document: ${err}`)); \n``` ### Find One or More Documents (`find()`) You can find multiple documents using the [collection.find()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.find)method. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet finds all documents in the `items` collection that have at least one review and returns them sorted by `name` with the `_id` field omitted: ```javascript const query = { \"reviews.0\": { \"$exists\": true } }; const projection = { \"_id\": 0 }; return itemsCollection.find(query, projection)   .sort({ name: 1 })   .toArray()   .then(items => {     console.log(`Successfully found ${items.length} documents.`)     items.forEach(console.log)     return items   })   .catch(err => console.error(`Failed to find documents: ${err}`)) \n``` ### Count Documents in the Collection (`count()`) You can count documents in a collection using the[collection.count()](https://mongodb.com/docs/atlas/app-services/functions/mongodb/api/#mongodb-method-collection.count) method. You can specify a query to control which documents to count. If you don't specify a query, the method counts all documents in the collection. The following [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) snippet counts the number of documents in the `items` collection that have at least one review: ```javascript return itemsCollection.count({ \"reviews.0\": { \"$exists\": true } })   .then(numDocs => console.log(`${numDocs} items have a review.`))   .catch(err => console.error(\"Failed to count documents: \", err)) \n``` ## Query Patterns ### Find by Document ID You can query a collection to find a document that has a specified ID. MongoDB automatically stores each document's ID as an `ObjectId` value in the document's `_id` field. ```javascript { \"_id\": <ObjectId> } \n``` ## Example The following query matches a document in the collection that has an`_id` value of `5ad84b81b8b998278f773c1b`: ```javascript { \"_id\": BSON.ObjectId(\"5ad84b81b8b998278f773c1b\") } \n``` ### Find by Date You can query a collection to find documents that have a field with a specific date value, or query for a documents within a range of dates. ```javascript { \"<Date Field Name>\": <Date | Expression> } \n```\n\n The following query matches documents in the collection that have a`createdAt` date of January 23, 2019: ```javascript { \"createdAt\": new Date(\"2019-01-23T05:00:00.000Z\") } \n``` ## Example The following query matches documents in the collection that have a`createdAt` date some time in the year 2019: ```javascript {   \"createdAt\": {     \"$gte\": new Date(\"2019-01-01T00:00:00.000Z\"),     \"$lt\": new Date(\"2020-01-01T00:00:00.000Z\"),   } } \n``` ### Match a Root-Level Field You can query a collection based on the value of a root-level field in each document. You can specify either a specific value or a nested expression that MongoDB evaluates for each document. For more information, see the [Query Documents](https://www.mongodb.com/docs/manual/tutorial/query-documents/) tutorial in the MongoDB Server Manual. ```javascript { \"<Field Name>\": <Value | Expression> } \n``` ## Example The following query matches documents where the `name` field has a value of `Basketball`: ```javascript { \"name\": \"Basketball\" } \n``` ### Match Multiple Fields You can specify multiple query conditions in a single query document. Each root-level field of a query document maps to a field in the collection. MongoDB only returns documents that fulfill all query conditions. For more information, see the [Query on Embedded/Nested Documents](https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/) tutorial in the MongoDB Server Manual. ```javascript {   \"<Field Name 1>\": <Value | Expression>,   \"<Field Name 2>\": <Value | Expression> } \n``` ## Example The following query matches documents where the `name` field has a value of `Basketball` and the `quantity` value is greater than zero: ```javascript {   \"name\": \"Basketball\",   \"quantity\": { \"$gt\": 0 } } \n``` ### Match an Embedded Document Field You can query a collection based on the value of embedded document fields. To specify an embedded document field, use multiple nested query expressions or standard document [dot notation.](https://www.mongodb.com/docs/manual/core/document/#dot-notation) For more information, see the [Query on Embedded/Nested Documents](https://www.mongodb.com/docs/manual/tutorial/query-embedded-documents/) tutorial in the MongoDB Server Manual. Nested Query Expressions ```javascript { \"<Field Name>\": { \"<Nested Field Name>\": <Value | Expression> } } \n``` Dot Notation ```javascript { \"<Field Name>.<Nested Field Name>\": <Value | Expression> } \n``` ## Example The following query matches documents where the first review in the`reviews` array was left by someone with the username`JoeMango`: ```javascript {   \"reviews.0.username\": \"JoeMango\" } \n``` ### Match an Array of Values You can query a collection based on all the elements contained in an array field. If you query an array field for a specific array of values, MongoDB returns documents where the array field _exactly matches_ the specified array of values. If you want MongoDB to return documents where the array field _contains_all elements in the specified array of values, use the [$all](https://www.mongodb.com/docs/manual/reference/operator/query/all/) operator. For more information, see the [Query an Array](https://www.mongodb.com/docs/manual/tutorial/query-arrays/) tutorial in the MongoDB Server Manual. ```javascript { \"<Array Field Name>\": [<Value>, ...] } \n``` ## Example The following query matches documents where the `reviews` array contains exactly one element and the element matches the specified document: ```javascript {   \"reviews\": [{ username: \"JoeMango\", comment: \"This rocks!\" }] } \n``` ## Example The following query matches documents where the `reviews` array contains one or more elements that match all of the the specified documents: ```javascript {   \"reviews\": {     \"$all\": [{ username: \"JoeMango\", comment: \"This rocks!\" }]   } } \n``` ### Match an Array Element\n\n If you query an array field with a query expression that has multiple conditions, MongoDB returns documents where _any combination_ of the array's elements satisfy the expression. If you want MongoDB to return documents where a _single_ array element satisfies all of the expression conditions, use the [$elemMatch](https://www.mongodb.com/docs/manual/reference/operator/query/elemMatch/) operator. For more information, see the [Query an Array](https://www.mongodb.com/docs/manual/tutorial/query-arrays/) tutorial in the MongoDB Server Manual. ```javascript { \"<Array Field Name>\": <Value | Expression> } \n``` ## Example The following query matches documents where both conditions in the embedded expression are met by _any combination_ of elements in the`reviews` array. The specified `username` and `comment` values do not need to be in the same document: ```javascript {   \"reviews\": {     \"username\": \"JoeMango\",     \"comment\": \"This is a great product!\"   } } \n``` ## Example The following query matches documents where both conditions in the embedded expression are met by a _single_ element in the `reviews`array. The specified `username` and `comment` must be in the same document: ```javascript {   \"reviews\": {     \"$elemMatch\": {       \"username\": \"JoeMango\",       \"comment\": \"This is a great product!\"     }   } } \n``` ## Query Operators ### Compare Values You can use a [comparison operator](https://www.mongodb.com/docs/manual/reference/operator/query-comparison/) to compare the value of a document field to another value. ```javascript { \"<Field Name>\": { \"<Comparison Operator>\": <Comparison Value> } } \n``` The following comparison operators are available:\n\n ## Example The following query matches documents where `quantity` is greater than zero and less than or equal to ten. ```javascript {   \"quantity\": { \"$gt\": 0, \"$lte\": 10 } } \n``` ### Evaluate a Logical Expression You can use a [logical operator](https://www.mongodb.com/docs/manual/reference/operator/query-logical/) to evaluate multiple expressions for a single field. ```javascript {   \"<Field Name>\": {     \"<Logical Operator>\": [<Expression>, ...]   } } \n``` The following logical operators are available: | Logical Operator                                                          | Description                                                                               |\n| ------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |\n| [$and](https://www.mongodb.com/docs/manual/reference/operator/query/and/) | Matches documents where the value of a field matches _all_ of the specified expressions.  |\n| [$or](https://www.mongodb.com/docs/manual/reference/operator/query/or/)   | Matches documents where the value of a field matches _any_ of the specified expressions.  |\n| [$nor](https://www.mongodb.com/docs/manual/reference/operator/query/or/)  | Matches documents where the value of a field matches _none_ of the specified expressions. |\n| [$not](https://www.mongodb.com/docs/manual/reference/operator/query/not/) | Inverts the boolean result of the specified logical expression.                           | ## Example The following query matches documents where either `quantity` is greater than zero or there are no more than five documents in the`reviews` array. ```javascript {   \"$or\": [     { \"quantity\": { \"$gt\": 0 } },     { \"reviews\": { \"$size\": { \"$lte\": 5 } } }   ] } \n``` ### Evaluate a Regular Expression You can use the [$regex](https://www.mongodb.com/docs/manual/reference/operator/query/regex/) query operator to return documents with fields that match a[regular expression](https://en.wikipedia.org/wiki/Regular%5Fexpression). To avoid ambiguity with the `$regex` EJSON type, you must use a [BSON.BSONRegExp](https://mongodb.com/docs/atlas/app-services/functions/globals/#std-label-bson-regexp) object. ```javascript {   \"<Field Name>\": {     \"$regex\": BSON.BSONRegExp(<RegEx String>, <RegEx Options>)   } } \n``` ## Example The following query matches documents where the `name` value contains the substring `ball` (case-insensitive). ```javascript {   \"name\": { \"$regex\": BSON.BSONRegExp(\".+ball\", \"i\") } } \n``` ← [Query MongoDB Atlas](https://mongodb.com/docs/atlas/app-services/functions/mongodb/ \"Previous Section\")[Write Data in MongoDB Atlas - Functions](https://mongodb.com/docs/atlas/app-services/functions/mongodb/write/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/activity/view-logs/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # View Application Logs On this page * [App Services UI](#app-services-ui)\n* [Filter Logs](#filter-logs)\n* [Limit the Number of Log Entries](#limit-the-number-of-log-entries)\n* [Download Logs](#download-logs)\n* [App Services CLI](#app-services-cli)\n* [View Recent Logs](#view-recent-logs)\n* [Tail Logs in Real Time](#tail-logs-in-real-time)\n* [View Error Logs](#view-error-logs)\n* [Filter Logs by Type](#filter-logs-by-type)\n* [View Logs for a Date Range](#view-logs-for-a-date-range)\n* [App Services API](#app-services-api)\n* [Get Recent Logs](#get-recent-logs)\n* [Get Logs for a Date Range](#get-logs-for-a-date-range)\n* [Get Paginated Logs](#get-paginated-logs) ## App Services UI You can view, filter, search, and download an application's logs in the App Services UI. To see your App's logs, click Logs in the left navigation menu. ![View Logs in the App Services UI](https://mongodb.com/docs/atlas/app-services/images/logs-ui.png) ### Filter Logs Drop-down menus enable filtering by predefined types of log entry, the status of entries. You can also specify a date range, filter by user ID, and show only entries associated with a specific request ID. ### Limit the Number of Log Entries In the text field with the placeholder text Max # of Logs, enter the maximum number of results you want to display on the page. If there are more records beyond your limit, you will see a Load More button at the bottom of the list of log entries. ### Download Logs Click the download button, to the right of the Apply button, to download the log entries that meet your filter criteria (or all log entries if you haven't specified any filters). When you click this button, a dialog appears confirming the filters that will be applied and prompting you to (optionally) limit the number of results. The resulting collection of log entries is in a .zip file that contains a single JSON file. ![Download Logs in the App Services UI](https://mongodb.com/docs/atlas/app-services/images/logs-ui-download.png) ## App Services CLI You can access an application's logs in your terminal or a shell script with the App Services CLI. ### View Recent Logs To return the 100 most recent log entries for your application, run `realm-cli logs list`. `| realm-cli logs list |\n| ------------------- | ` ### Tail Logs in Real Time You can use the `--tail` flag to open a stream that displays application logs as they come in. ```shell realm-cli logs list --tail \n``` ### View Error Logs You can use the `--errors` flag to view only error logs. If you don't specify the flag, the command returns both error logs and regular logs. ```shell realm-cli logs list --errors \n``` ### Filter Logs by Type You can use the `--type` flag to view logs of one or more specific types. If you don't specify a type, the command returns logs of all types. The following types are valid: * `auth`\n* `function`\n* `push`\n* `service`\n* `trigger`\n* `graphql`\n* `sync`\n* `schema` ```shell realm-cli logs list --type=function --type=trigger \n``` ### View Logs for a Date Range You can use the `--start` and `--end` flags to view logs from a range of dates. The flags accept ISODate strings and you can use them separately or together. ```shell realm-cli logs list --start=\"2021-01-01T00:00:00.000+0000\" --end=\"2021-02-01T00:00:00.000+0000\" \n``` ## App Services API\n\n To use the Admin API you'll need your Project ID, App ID, and authentication credentials. To learn how to find these, see[Project & Application IDs](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#section/Project-and-Application-IDs) and [Get Authentication Tokens.](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#section/Get-Authentication-Tokens) The examples in this section use the following helper functions in a[Function:](https://mongodb.com/docs/atlas/app-services/functions/) ```javascript async function authenticate(publicApiKey, privateApiKey) {   const result = await context.http.post({     url: `${ADMIN_API_BASE_URL}/auth/providers/mongodb-cloud/login`,     headers: {       \"Content-Type\": [\"application/json\"],       \"Accept\": [\"application/json\"],     },     body: {       \"username\": publicApiKey,       \"apiKey\": privateApiKey,     },     encodeBodyAsJSON: true   })   return EJSON.parse(result.body.text()); } function formatQueryString(queryParams) {   const params = Object.entries(queryParams);   return params.length > 0     ? \"?\" + params.map(([a, b]) => `${a}=${b}`).join(\"&\")     : \"\" } \n``` ### Get Recent Logs To return the 100 most recent log entries for your application, call the Logging endpoint with no additional parameters: ```javascript const ADMIN_API_BASE_URL = \"https://realm.mongodb.com/api/admin/v3.0\"; exports = async function() {   // Get values that you need for requests   const projectId = \"<Atlas Project ID>\";   const appId = \"<App ID>\";   const publicApiKey = \"<Atlas Public API Key>\";   const privateApiKey = \"<Atlas Private API Key>\";   // Authenticate with the Atlas API Key   const { access_token } = await authenticate(publicApiKey, privateApiKey);   // Get logs for your App   const logsEndpoint = `${ADMIN_API_BASE_URL}/groups/${projectId}/apps/${appId}/logs`;   const  request = {     \"url\": logsEndpoint,     \"headers\": {       \"Authorization\": [`Bearer ${access_token}`]     }   };   const result = await context.http.get(request);   const logs = EJSON.parse(result.body.text());   return logs; } \n``` ### Get Logs for a Date Range To return log entries for a specific date range, call the Logging endpoint with either or both of the `start_date` and `end_date`fields: ## Note ### Result Pagination If the date range that you specify includes more than 100 log entries, you will need to run multiple queries to access all of the entries. To learn how, see [Get Paginated Logs.](#std-label-logging-get-paginated-logs) ```javascript const ADMIN_API_BASE_URL = \"https://realm.mongodb.com/api/admin/v3.0\"; exports = async function() {   // Get values that you need for requests   const projectId = \"<Atlas Project ID>\";   const appId = \"<App ID>\";   const publicApiKey = \"<Atlas Public API Key>\";   const privateApiKey = \"<Atlas Private API Key>\";   // Authenticate with the Atlas API Key   const { access_token } = await authenticate(publicApiKey, privateApiKey);   // Get logs for your App   const logsEndpoint = `${ADMIN_API_BASE_URL}/groups/${projectId}/apps/${appId}/logs`;   const  request = {     \"url\": logsEndpoint + formatQueryString({       start_date: \"2019-07-01\",       end_date: \"2019-07-31\",\n\n     \"headers\": {       \"Authorization\": [`Bearer ${access_token}`]     }   };   const result = await context.http.get(request);   const logs = EJSON.parse(result.body.text());   return logs; } \n``` ### Get Paginated Logs App Services returns a maximum of 100 log entries for each request. If a query matches more than 100 log entries, the API returns the first \"page\" of 100 results and include additional parameters in the response that you can provide to get the next page(s) of up to 100 entries. ## Note ### Paginated Responses A paginated response resembles the following document, where`nextEndDate` and `nextSkip` are optional: ``` {   logs: [<Log Entry>, ...],   nextEndDate: \"<End date of the next page>\",   nextSkip: <Offset of the next page>, } \n``` ```javascript const ADMIN_API_BASE_URL = \"https://realm.mongodb.com/api/admin/v3.0\"; exports = async function() {   // Get values that you need for requests   const projectId = \"<Atlas Project ID>\";   const appId = \"<App ID>\";   const publicApiKey = \"<Atlas Public API Key>\";   const privateApiKey = \"<Atlas Private API Key>\";   // Authenticate with the Atlas API Key   const { access_token } = await authenticate(publicApiKey, privateApiKey);   // Get logs for your App   const pager = new LogPager(projectId, appId, access_token);   const firstPage = await pager.getNextPage();   const secondPage = await pager.getNextPage(firstPage);   const thirdPage = await pager.getNextPage(secondPage);   const allLogs = await pager.getAllLogs(); } class LogPager {   constructor(projectId, appId, access_token, queryParams={}) {     this.logsEndpoint = `${ADMIN_API_BASE_URL}/groups/${projectId}/apps/${appId}/logs`;     this.queryParams = queryParams;     this.authHeaders = { Authorization: [`Bearer ${access_token}`] }   }   async getNextPage(prevPage) {     const { nextEndDate, nextSkip } = prevPage || {};     if(prevPage && !nextEndDate) {       throw new Error(\"Paginated API does not have any more pages.\")     }     const request = {       \"headers\": this.authHeaders,       \"url\": this.logsEndpoint + formatQueryString({         ...this.queryParams,         end_date: nextEndDate,         skip: nextSkip,       }),     }     const result = await context.http.get(request);     const nextPage = EJSON.parse(result.body.text());     return nextPage   }   async getAllLogs() {     // Note: If your query parameters match too many logs this might time out     let logs = []     let hasNext = true;     let prevPage = null     while(hasNext) {       const page = await getNextPage(prevPage);       logs = logs.concat(page.logs);       hasNext = page.nextEndDate       prevPage = page     }     return logs;   } } \n``` ← [Monitor App Activity](https://mongodb.com/docs/atlas/app-services/activity/ \"Previous Section\")[Forward Logs to a Service](https://mongodb.com/docs/atlas/app-services/activity/forward-logs/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/globals/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Global Modules On this page * [Utilities](#utilities)\n* [JSON Web Tokens (utils.jwt)](#json-web-tokens--utils.jwt-)\n* [Cryptography (utils.crypto)](#cryptography--utils.crypto-)\n* [JSON (JavaScript Object Notation)](#json--javascript-object-notation-)\n* [EJSON (Extended JSON)](#ejson--extended-json-)\n* [BSON (Binary JSON)](#bson--binary-json-)\n* [BSON.ObjectId](#bson.objectid)\n* [BSON.BSONRegExp](#bson.bsonregexp)\n* [BSON.Binary](#bson.binary)\n* [BSON.MaxKey](#bson.maxkey)\n* [BSON.MinKey](#bson.minkey)\n* [BSON.Int32](#bson.int32)\n* [BSON.Long](#bson.long)\n* [BSON.Double](#bson.double)\n* [BSON.Decimal128](#bson.decimal128) All [functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) have access to built-in global modules that support common data transformation, encoding, and processing work. You can access the modules in your function source code via global variables specific to each module. ## Tip ### See also:  These global modules are _not_ the same as the Node.js built-in modules. For more information on supported Node.js modules, including how to import them, see [Built-in Module Support.](https://mongodb.com/docs/atlas/app-services/functions/javascript-support/#std-label-js-support-builtin-modules)\n\n ## Utilities ### JSON Web Tokens (`utils.jwt`) You can create and read [JSON Web Tokens](https://jwt.io/introduction) with the `utils.jwt` interface. | Method                                                 | Description                                                                               |\n| ------------------------------------------------------ | ----------------------------------------------------------------------------------------- |\n| [utils.jwt.encode()](#mongodb-method-utils.jwt.encode) | Generates an encoded JSON Web Token string for a givenpayload, signingMethod, and secret. |\n| [utils.jwt.decode()](#mongodb-method-utils.jwt.decode) | Decodes the payload of a JSON Web Token string.                                           | `utils.jwt.encode()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-utils.jwt.encode \"Permalink to this definition\") Generates an encoded JSON Web Token string for the `payload` based on the specified `signingMethod` and `secret`. `| utils.jwt.encode(          |\n| -------------------------- |\n| signingMethod: string,     |\n| payload: object,           |\n| secret: string,            |\n| customHeaderFields: object |\n| ): string                  | `\n\n | Returns: | A JSON Web Token string encoded for the provided payload. |\n| -------- | --------------------------------------------------------- | ## Example Consider the following JWT claims object: ``` {   \"sub\": \"1234567890\",   \"name\": \"Joe Example\",   \"iat\": 1565721223187 } \n``` We can encode the claims object as a JWT string by calling`utils.jwt.encode()`. The following function encodes the JWT using the `HS512` signing method and the secret`\"SuperSecret\"`: ```javascript exports = function() {   const signingMethod = \"HS512\";   const payload = {     \"sub\": \"1234567890\",     \"name\": \"Joe Example\",     \"iat\": 1565721223187   };   const secret = \"SuperSecret\";   return utils.jwt.encode(signingMethod, payload, secret); } \n``` HIDE OUTPUT `| \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvZSBTY2htb2UiLCJpYXQiOjE1NjU3MjEyMjMxODd9.-QL15ldu2BYuJokNWT6YRiwZQIiIpvq6Kyv-C6qslNdNiUVxo8zqLJZ1iEkNf2yZKMIrQuMCtIC1tzd2H31AxA\" |\n| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ` `utils.jwt.decode()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-utils.jwt.decode \"Permalink to this definition\") Decodes the `payload` of the provided JSON Web Token string. The value of `key` must correspond to the secret value that was used to encode the JWT string. ``` utils.jwt.decode(    jwtString: string,    key: string,    returnHeader: boolean ): object \n```\n\n | Returns: | If returnHeader is false, returns the decoded EJSON payload.If returnHeader is true, returns an object that contains the [JOSE header](https://tools.ietf.org/html/rfc7515#section-4) in theheader field and the decoded EJSON payload in the payloadfield.{  \"header\": {    \"<JOSE Header Field>\": <JOSE Header Value>,    ...  },  \"payload\": {    \"<JWT Claim Field>\": <JWT Claim Value>,    ...  }} |\n| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ## Example Consider the following signed JWT string: ``` \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvZSBTY2htb2UiLCJpYXQiOjE1NjU3MjEyMjMxODd9.-QL15ldu2BYuJokNWT6YRiwZQIiIpvq6Kyv-C6qslNdNiUVxo8zqLJZ1iEkNf2yZKMIrQuMCtIC1tzd2H31AxA\" \n``` The JWT was signed using the `HS512` signing method with the secret value `\"SuperSecret\"`. We can decode the JWT's claims object `utils.jwt.decode()`. The following function decodes the JWT string into an EJSON object: ```javascript exports = function(jwtString) {   const key = \"SuperSecret\";   return utils.jwt.decode(jwtString, key, false, [\"HS512\"]); } \n``` HIDE OUTPUT ``` {   \"sub\": \"1234567890\",   \"name\": \"Joe Example\",   \"iat\": { \"$numberDouble\": 1565721223187 } } \n``` ### Cryptography (`utils.crypto`) You can encrypt, decrypt, sign, and verify data using cryptographic algorithms with the `utils.crypto` interface.\n\n `utils.crypto.encrypt()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-utils.crypto.encrypt \"Permalink to this definition\") Generates an encrypted text string from the provided text using the specified encryption method and key. ``` utils.crypto.encrypt(   encryptionType: string,   message: string,   key: string ): BSON.Binary \n``` | Parameter      | Type   | Description                                                                                                                                                                                     |\n| -------------- | ------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| encryptionType | string | The type of encryption with which to encrypt the message. The following encryption types are supported:[AES Encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) (\"aes\") |\n| message        | string | The text string that you want to encrypt.                                                                                                                                                       |\n| key            | string | A cryptographic key used to encrypt the text. The key you should use depends on the encryption method:Encryption TypeEncryption KeyAESA 16-byte, 24-byte, or 32-byte random string              | | Returns: | A [BSON Binary](#std-label-bson-binary) object that contains the text string encrypted with the specified encryption type and key. |\n| -------- | ---------------------------------------------------------------------------------------------------------------------------------- | ## Example Assume that we have defined a [value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets)named `aesEncryptionKey` that contains the following 32-byte AES encryption key: ``` \"603082712271C525E087BD999A4E0738\" \n``` With this AES key, we can encrypt a message into a base64 string using the following function: ```javascript exports = function() {   const message = \"MongoDB is great!\"   const key = context.values.get(\"aesEncryptionKey\");   const encryptedMessage = utils.crypto.encrypt(\"aes\", message, key);   return encryptedMessage.toBase64(); } \n``` HIDE OUTPUT ``` \"WPBuIvJ6Bity43Uh822dW8QlVYVJaFUiDeUjlTiJXzptUuTYIKPlXekBQAJb\" \n``` `utils.crypto.decrypt()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-utils.crypto.decrypt \"Permalink to this definition\") Decrypts the provided text string using the specified encryption type and key. If both the encryption type and key are the same as those used to encrypt, this returns the original, unencrypted text. ``` utils.crypto.decrypt(   encryptionType: string,\n\n   key: string ): BSON.Binary \n``` | Parameter        | Type                                  | Description                                                                                                                                                                                              |\n| ---------------- | ------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| encryptionType   | string                                | The type of encryption that was used to encrypt the provided text. The following encryption types are supported:[AES Encryption](https://en.wikipedia.org/wiki/Advanced%5FEncryption%5FStandard) (\"aes\") |\n| encryptedMessage | [BSON.Binary](#std-label-bson-binary) | A BSON Binary that encodes the encrypted text string that you want to decrypt.                                                                                                                           |\n| key              | string                                | A cryptographic key used to decrypt the text. The key you should use depends on the encryption type:Encryption TypeEncryption KeyAESA 16-byte, 24-byte, or 32-byte random string                         | | Returns: | A [BSON Binary](#std-label-bson-binary) object that contains the decrypted message.If the provided encrypted message was encrypted with the specified method and key, then the decrypted message is identical to the original message. |\n| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ## Example Assume that we have defined a [Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/) named`aesEncryptionKey` that contains the following 32-byte AES encryption key: ``` \"603082712271C525E087BD999A4E0738\" \n``` We can use this AES key to decrypt any base64 string that was encrypted with the same key using the following function: ```javascript exports = function(encryptedMessage) {   // The encrypted message must be a BSON.Binary   if(typeof encryptedMessage === \"string\") {     encryptedMessage = BSON.Binary.fromBase64(encryptedMessage)   }   const key = context.values.get(\"aesEncryptionKey\");   const decryptedMessage = utils.crypto.decrypt(\"aes\", encryptedMessage, key);   return decryptedMessage.text(); } \n``` HIDE OUTPUT ``` \"MongoDB is great!\" \n``` `utils.crypto.sign()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-utils.crypto.sign \"Permalink to this definition\")\n\n ``` utils.crypto.sign(   encryptionType: string,   message: string,   privateKey: string,   signatureScheme: string ): BSON.Binary \n```\n\n | Returns: | A [BSON.Binary](#std-label-bson-binary) [cryptographic signature](https://en.wikipedia.org/wiki/Digital%5Fsignature) for the message signed using the specified private key. |\n| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ## Example Assume that we have defined a [value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets)named `rsaPrivateKey` that contains the following RSA private key: ``` -----BEGIN RSA PRIVATE KEY----- MIICXAIBAAKBgQDVsEjse2qO4v3p8RM/q8Rqzloc1lee34yoYuKZ2cemuUu8Jpc7 KFO1+aJpXdbSPZNhGLdANn8f2oMIZ1R9hgEJRn/Qm/YyC4RPTGg55nzHqSlziNZJ JAyEUyU7kx5+Kb6ktgojhk8ocZRkorM8FEylkrKzgSrfay0PcWHPsKlmeQIDAQAB AoGAHlVK1L7kLmpMbuP4voYMeLjYE9XdVEEZf2GiFwLSE3mkJY44033y/Bb2lgxr DScOf675fFUAEK59ATlhxfu6s6rgx+g9qQQ+mL74YZWPqiZHBPjyMRaBalDVC4QF YJ+DopFcB8hY2ElXnbK70ALmVYNjw3RdmC97h0YfOsQcWW0CQQD18aeuPNicVnse Ku22vvhvQYlabaQh4xdkEIxz1TthZj48f61wZwEMipYqOAc5XEtDlNnxgeipv0yF RHstUjwXAkEA3m0Br/U/vC9evuXppWbONana08KLgfELyd3Uw9jG7VKJZTBH5mS8 7CB68aEF8egrJpo8Ss8BkWrvCxYDb4Y77wJAUlbOMZozVtvpKidrIFR9Lho91uWA Hsw9h4W20AzibXBig7SnJ0uE4WMAdS/+0yhgFkceVCmO8E2YW8Gaj4jJjwJASxtg AHy+ItuUEL4uIW4Pn8tVW0BMP3qX0niXyfI/ag/+2S5uePv3V3y4RzNqgH83Yved +FziWKpVQdcTHeuj/QJBAJl1G3WFruk0llIoKKbKljaEiCm1WCTcuEPbdOtkJYvO 9ZYQg/fji70FERkq2KHtY7aLhCHzy0d4n9xgE/pjV+I= -----END RSA PRIVATE KEY----- \n``` With this RSA key, we can sign a message using the following function: ```javascript exports = function() {   const message = \"MongoDB is great!\"   const rsaPrivateKey = context.values.get(\"rsaPrivateKey\");   const signature = utils.crypto.sign(\"rsa\", message, rsaPrivateKey, \"pss\");   return signature.toBase64(); } \n``` HIDE OUTPUT ```\n\n \n``` `utils.crypto.verify()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-utils.crypto.verify \"Permalink to this definition\") Checks that the provided signature is valid for the specified message and public key. If the signature is valid, it guarantees that the signer has access to the corresponding private key and that the message content has not been altered since it was signed. ``` utils.crypto.verify(   encryptionType: string,   message: string,   publicKey: string,   signature: BSON.Binary,   signatureScheme: string ): boolean \n```\n\n | Returns: | A boolean that, if true, indicates whether or not the signature is valid for the provided message and public key. |\n| -------- | ----------------------------------------------------------------------------------------------------------------- | ## Example We received a message with a signature in [BSON.Binary](#std-label-bson-binary) format and want to verify that the message was signed with the private key that corresponds to the sender's RSA public key: ``` -----BEGIN RSA PUBLIC KEY----- MIGJAoGBANWwSOx7ao7i/enxEz+rxGrOWhzWV57fjKhi4pnZx6a5S7wmlzsoU7X5 omld1tI9k2EYt0A2fx/agwhnVH2GAQlGf9Cb9jILhE9MaDnmfMepKXOI1kkxDIRT JTuTHn4pvqS2CiOGTyhxlGSiszwUTKWSsrOBKt9rLQ9xYc+wqWZ5AgMBAAE= -----END RSA PUBLIC KEY----- \n``` With this RSA key, we can verify a message signed with the correspdoning private key using the following function: ```javascript exports = function() {   const rsaPublicKey = context.values.get(\"rsaPublicKey\");   const message = \"MongoDB is great!\"   const signature = BSON.Binary.fromBase64(\"SpfXcJwPbypArt+XuYQyuZqU52YCAY/sZj2kiuin2b6/RzyM4Ek3n3spOtqZJqxn1tfQavxIX4V+prbs74/pOaQkCLekl9Hoa1xOzSKcGoRd8U+n1+UBY3d3cyODGMpyr8Tim2HZAeLPE/D3Q36/K+jpgjvrJFXsJoAy5/PV7iEGV1fkzogmZtXWDcUUBBTTNPY4qZTzjNhL4RAFOc7Mfci+ojE/lLsNaumUVU1/Eky4vasmyjqunm+ULCcRmgWtGDMGHaQV4OXC2LMUe9GOqd3Q9ghCe0Vlhn25oTh8cXoGpd1Fr8wolNa//9dUqSM+QYDpZJXGLShX/Oa8mPwJZKDKHtqrS+2vE6S4dDWR7zKDza+DeovOeCih71QyuSYMXSz+WWGgfLzv/syhmUXP/mjqgLmJU6Kwg5htajDoylpzLC0BLGT4zDZEwBrq/AjwRs/EPjYdFgGCt1WCbbVlDyXvvH1ekDrzACzumhiMSZNNa+ZH3JmMJxTCQWDfiTeAfkauaaZHKIj2q2/QE7vuAhNcVPJ2YgpXnvnQHJpEZBc/Y3Q6JLxom6+cGC4P//9d++r2cwzXIkqD+wSGZVSVtpm5CLtWMRSK5FX2dv16bM+LE8ozoRvtMUDTrQ8SSSDGxyuYbvN9b2fYYPcWpCMchqOBXV6eZGoMldaHX3Qy5h8=\")   const isValid = utils.crypto.verify(\"rsa\", message, rsaPublicKey, signature, \"pss\");   return isValid; // true if the signature matches, else false } \n``` HIDE OUTPUT ``` true \n``` `utils.crypto.hmac()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-utils.crypto.hmac \"Permalink to this definition\")\n\n ``` utils.crypto.hmac(   input: string,   secret: string,   hash_function: string,   output_format: string ): string \n``` | Parameter      | Type   | Description                                                                                                                              |\n| -------------- | ------ | ---------------------------------------------------------------------------------------------------------------------------------------- |\n| input          | string | The input for which you would like to generate a signature.                                                                              |\n| secret         | string | The secret key to use when generating the signature.                                                                                     |\n| hash\\_function | string | The name of the hashing function to use when generating the signature. The following functions are supported: \"sha1\",\"sha256\", \"sha512\". |\n| output\\_format | string | The format of the generated signature. Can be either\"hex\" for a hex string, or \"base64\" for a Base64 string.                             | | Returns: | The signature of the input, in the format specified byoutput\\_format. |\n| -------- | --------------------------------------------------------------------- | ## Example The following function generates a sha256 signature as a base 64 string: ```javascript exports = function() {   const signature = utils.crypto.hmac(     \"hello!\",     \"super-secret\",     \"sha256\",     \"base64\"   )   return signature } \n``` HIDE OUTPUT ``` \"SUXd6PRMaTXXgBGaGsIHzaDWgTSa6C3D44lRGrvRak0=\" \n``` `utils.crypto.hash()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-utils.crypto.hash \"Permalink to this definition\") Generates a hash value for the provided input using the specified hash function. ``` utils.crypto.hash(   hash_function: string,   input: string | BSON.Binary ): BSON.Binary \n``` | Parameter      | Type                  | Description                                                                                      |\n| -------------- | --------------------- | ------------------------------------------------------------------------------------------------ |\n| hash\\_function | string                | The name of the hashing function. The following functions are supported: \"sha1\",\"sha256\", \"md5\". |\n| input          | string or BSON.Binary | Required. The input for which you would like to generate a hash value.                           |\n\n ## Example The following function hashes an input string with sha256: ```javascript exports = function() {   return utils.crypto.hash(     \"sha256\",     \"hello!\"   ) } \n``` HIDE OUTPUT ``` \"zgYJL7lI2f+sfRo3bkBLJrdXW8wR7gWkYV/vT+w6MIs=\" \n``` ## JSON (JavaScript Object Notation) The `JSON` global module provides [JSON methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/JSON) to serialize and deserialize standard JavaScript objects. | Method                                             | Description                                              |\n| -------------------------------------------------- | -------------------------------------------------------- |\n| [JSON.parse()](#mongodb-method-JSON.parse)         | Parse a serialized JSON string into a JavaScript object. |\n| [JSON.stringify()](#mongodb-method-JSON.stringify) | Serialize a JavaScript object into a JSON string.        | `JSON.parse()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-JSON.parse \"Permalink to this definition\") Parses the provided JSON string and converts it to a JavaScript object. ``` JSON.parse(jsonString: string): object \n``` | Parameter  | Type                                                                                                | Description                                                   |\n| ---------- | --------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- |\n| jsonString | [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String) | A serialized string representation of a standard JSON object. | | Returns: | A standard JavaScript object generated from the provided JSON string. |\n| -------- | --------------------------------------------------------------------- | ## Example The following function converts a serialized JSON string into an equivalent JavaScript object: ```javascript exports = function() {   const jsonString = `{     \"answer\": 42,     \"submittedAt\": \"2020-03-02T16:50:24.475Z\"   }`;   return JSON.parse(jsonString); } \n``` HIDE OUTPUT ``` {   \"answer\": 42,   \"submittedAt\": \"2020-03-02T16:50:24.475Z\" } \n``` `JSON.stringify()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-JSON.stringify \"Permalink to this definition\") Serializes the provided JavaScript object to a JSON string. ``` JSON.stringify(json: object): string \n```\n\n | Returns: | A string representation of the provided JavaScript object. |\n| -------- | ---------------------------------------------------------- | ## Example The following function serializes a JavaScript object into an equivalent JSON string: ```javascript exports = function() {   const jsonObject = {     answer: 42,     submittedAt: new Date(\"2020-03-02T16:46:47.977Z\")   };   return JSON.stringify(jsonObject); } \n``` HIDE OUTPUT ``` \"{\\\"answer\\\":42,\\\"submittedAt\\\":\\\"2020-03-02T16:46:47.977Z\\\"}\" \n``` ## EJSON (Extended JSON) The `EJSON` global module is similar to [JSON](#std-label-json) but preserves additional [Extended JSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/) type information. EJSON is a superset of standard JSON that adds additional support for types that are available in [BSON](#std-label-bson) but not included in the[JSON specification](https://www.json.org/). | Method                                               | Description                                                       |\n| ---------------------------------------------------- | ----------------------------------------------------------------- |\n| [EJSON.parse()](#mongodb-method-EJSON.parse)         | Parse a serialized Extended JSON string into a JavaScript object. |\n| [EJSON.stringify()](#mongodb-method-EJSON.stringify) | Serialize a JavaScript object into an ExtendedJSON string.        | `EJSON.parse()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-EJSON.parse \"Permalink to this definition\") Parses the provided [EJSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/) string and converts it to a JavaScript object. ``` EJSON.parse(ejsonString: string): object \n``` | Parameter   | Type   | Description                                                    |\n| ----------- | ------ | -------------------------------------------------------------- |\n| ejsonString | string | A serialized string representation of an Extended JSON object. | | Returns: | A JavaScript object representation of the provided EJSON string. |\n| -------- | ---------------------------------------------------------------- | ## Example The following function converts a serialized EJSON string into an equivalent JavaScript object: ```javascript exports = function() {   const ejsonString = `{     \"answer\": {       \"$numberLong\": \"42\"     },     \"submittedAt\": {       \"$date\": {         \"$numberLong\": \"1583167607977\"       }     }   }`;   return EJSON.parse(ejsonString); } \n``` HIDE OUTPUT ``` {   \"answer\": {     \"$numberLong\": \"42\"   },   \"submittedAt\": {     \"$date\": {       \"$numberLong\": \"1583167607977\"     }   } } \n``` `EJSON.stringify()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-EJSON.stringify \"Permalink to this definition\") Serializes the provided JavaScript object to an [EJSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/) string. ``` EJSON.stringify(json: object): string \n```\n\n | Returns: | A string representation of the provided EJSON object. |\n| -------- | ----------------------------------------------------- | ## Example The following function serializes a JavaScript object into an equivalent EJSON string: ```javascript exports = function() {   const jsonObject = {     answer: 42,     submittedAt: new Date(\"2020-03-02T16:46:47.977Z\")   };   return EJSON.stringify(jsonObject); } \n``` HIDE OUTPUT ``` \"{\\\"answer\\\":{\\\"$numberLong\\\":\\\"42\\\"},\\\"submittedAt\\\":{\\\"$date\\\":{\\\"$numberLong\\\":\\\"1583167607977\\\"}}}\" \n``` ## BSON (Binary JSON) The `BSON` global module allows you to create typed BSON objects and convert them between various data formats and encodings. [BSON](https://en.wikipedia.org/wiki/BSON), or Binary JSON, is the data format used internally by MongoDB databases. It encodes a binary representation of document data structures using a superset of the standard JSON types. For more information, refer to the [BSON specification.](http://bsonspec.org/) | Type                                          | Description                                                  |\n| --------------------------------------------- | ------------------------------------------------------------ |\n| [BSON.ObjectId](#std-label-bson-objectid)     | Represent an ObjectId value                                  |\n| [BSON.BSONRegExp](#std-label-bson-regexp)     | Represent a regular expression                               |\n| [BSON.Binary](#std-label-bson-binary)         | Represent a binary data structure                            |\n| [BSON.MaxKey](#std-label-bson-maxkey)         | Represent a value that compares higher than all other values |\n| [BSON.MinKey](#std-label-bson-minkey)         | Represent a value that compares lower than all other values  |\n| [BSON.Int32](#std-label-bson-int32)           | Represent a 32-bit signed integer                            |\n| [BSON.Long](#std-label-bson-long)             | Represent a 64-bit signed integer                            |\n| [BSON.Double](#std-label-bson-double)         | Represent a 64-bit floating point number                     |\n| [BSON.Decimal128](#std-label-bson-decimal128) | Represent a 128-bit floating point number                    | ### BSON.ObjectId The `BSON.ObjectId` type represents a 12-byte MongoDB `ObjectId`identifier. `BSON.ObjectId()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.ObjectId \"Permalink to this definition\") Constructs a `BSON.ObjectId` object that encodes an[ObjectId](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) ```\n\n \n``` | Parameter | Type   | Description                                                  |\n| --------- | ------ | ------------------------------------------------------------ |\n| id        | string | Optional. A 12-byte string or a string of 24 hex characters. | | Returns: | A BSON.ObjectId object that encodes the specified[ObjectId](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) string or a generated ObjectId string if none was specified. |\n| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ## Example ```javascript const objectId = new BSON.ObjectId(\"5e58667d902d38559c802b13\"); const generatedObjectId = new BSON.ObjectId(); \n``` ### BSON.BSONRegExp The `BSON.BSONRegExp` type represents a [regular expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular%5FExpressions). You can use a`BSON.BSONRegExp` object with the `$regex` query operator to[perform a regular expression query](https://mongodb.com/docs/atlas/app-services/functions/mongodb/read/#std-label-query-operators-regex) on a MongoDB collection. `BSON.BSONRegExp()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.BSONRegExp \"Permalink to this definition\") Constructs a `BSON.BSONRegExp` object from a regular expression string. You can optionally specify configuration flags. ``` BSON.BSONRegExp(pattern: string, flags: string) \n``` | Parameter | Type   | Description                                                                                                                                                                    |\n| --------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| pattern   | string | A [regular expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular%5FExpressions) pattern.                                                           |\n| flags     | string | Optional. One or more [regular expression flags.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular%5FExpressions#Advanced%5Fsearching%5Fwith%5Fflags%5F2) | | Returns: | A BSON.BSONRegExp object that encodes the provided regular expression pattern and flags. |\n| -------- | ---------------------------------------------------------------------------------------- | ## Example ```javascript const regex = BSON.BSONRegExp(\"the great\", \"ig\"); \n``` ### BSON.Binary The `BSON.Binary` type represents a binary-encoded data string. `BSON.Binary.fromHex()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.Binary.fromHex \"Permalink to this definition\") Constructs a `BSON.Binary` object from data represented as a hexadecimal string. ``` BSON.Binary.fromHex(   hexString: string,   subType?: number ): BSON.Binary \n```\n\n | Returns: | A BSON.Binary object that encodes the provided hexadecimal string. |\n| -------- | ------------------------------------------------------------------ | ## Example ```javascript const binary = BSON.Binary.fromHex(\"54657374206d65737361676520706c656173652069676e6f7265=\"); \n``` `BSON.Binary.prototype.toHex()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.Binary.prototype.toHex \"Permalink to this definition\") Converts the `BSON.Binary` object into a hexadecimal string. ``` BSON.Binary.prototype.toHex(): string \n``` | Returns: | A hexadecimal string representation of the providedBSON.Binary object. |\n| -------- | ---------------------------------------------------------------------- | ## Example ```javascript export = function() {   const binary = BSON.Binary.fromHex(      \"54657374206d65737361676520706c656173652069676e6f7265=\"    );   const hexString = binary.toHex();   return hexString } \n``` HIDE OUTPUT ``` \"54657374206d65737361676520706c656173652069676e6f7265=\" \n``` `BSON.Binary.fromBase64()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.Binary.fromBase64 \"Permalink to this definition\") Constructs a `BSON.Binary` object from data represented as a base64 string. ``` BSON.Binary.fromBase64(   base64String: string,   subType?: number ): BSON.Binary \n``` | Parameter    | Type    | Description                                                                                                                                                                                                                                                          |\n| ------------ | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| base64String | string  | A string of base64 encoded characters.NoteString PaddingThe base64-encoded string must include either one or two equals signs (\\=), referred to as \"padding\", at the end of the string.BSON.Binary.fromBase64() does not support unpadded strings.                   |\n| subType      | integer | Optional. The type of data encoded in the hexadecimal string. The value must be in the range 0-255 where 0, the default value, represents a generic binary. For a full list of supported subtypes, refer to the [BSON specification.](http://bsonspec.org/spec.html) | | Returns: | A BSON.Binary object that encodes the provided base64 string. |\n| -------- | ------------------------------------------------------------- | ## Example ```javascript const binary = BSON.Binary.fromBase64(\"VGVzdCBtZXNzYWdlIHBsZWFzZSBpZ25vcmU=\"); \n```\n\n Converts a `BSON.Binary` object into a base64 string. ``` BSON.Binary.prototype.toBase64(): string \n``` | Returns: | A base64 string representation of the BSON.Binary object. |\n| -------- | --------------------------------------------------------- | ## Example ```javascript const binary = BSON.Binary.fromBase64(\"VGVzdCBtZXNzYWdlIHBsZWFzZSBpZ25vcmU=\"); const base64String = binary.toBase64(); \n``` `BSON.Binary.prototype.text()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.Binary.prototype.text \"Permalink to this definition\") Converts the `BSON.Binary` object into a UTF-8 string. ``` BSON.Binary.prototype.text(): string \n``` | Returns: | A UTF-8 string representation of the provided BSON.Binaryobject. |\n| -------- | ---------------------------------------------------------------- | ## Example ```javascript const binary = BSON.Binary.fromBase64(\"VGVzdCBtZXNzYWdlIHBsZWFzZSBpZ25vcmU=\"); const decodedString = binary.text(); \n``` ### BSON.MaxKey The `BSON.MaxKey` type represents a value that compares higher than all other BSON values. ## Example ```javascript await collection.findOne({ date: { $lt: BSON.MaxKey } }); \n``` ### BSON.MinKey The `BSON.MinKey` type represents a value that compares lower than all other BSON values. ## Example ```javascript await collection.findOne({ date: { $gt: BSON.MinKey } }); \n``` ### BSON.Int32 The `BSON.Int32` type represents a 32-bit signed integer. `BSON.Int32()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.Int32 \"Permalink to this definition\") Constructs a `BSON.Int32` object from a 32-bit number. ``` BSON.Int32(low32: number): BSON.Int32 \n``` | Parameter | Type   | Description      |\n| --------- | ------ | ---------------- |\n| low32     | number | A 32-bit number. | | Returns: | A BSON.Int32 object that encodes the specified integer. Returns 0 if no arguments are supplied. |\n| -------- | ----------------------------------------------------------------------------------------------- | ## Example ```javascript const int32 = BSON.Int32(42); \n``` ### BSON.Long The `BSON.Long` type represents a 64-bit signed integer. `BSON.Long(low32, high32)`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.Long \"Permalink to this definition\") ``` BSON.Long(low32: number, high32: number): BSON.Long \n``` Constructs a `BSON.Long` object from two 32-bit integers that represent the low 32 bits and the high 32 bits in the 64-bit `Long`integer. | Parameter | Type    | Description                                                                                                |\n| --------- | ------- | ---------------------------------------------------------------------------------------------------------- |\n| low32     | integer | Optional. The long integer's 32 low bits. These bits represent the least significant digits of the number. |\n| high32    | integer | Optional. The long integer's 32 high bits. These bits represent the most significant digits of the number. | | Returns: | A BSON.Long object that encodes the specified integer. Returns 0 if no arguments are supplied.BSON.Long encodes using the following formula:(high32 \\* (2\\*\\*32)) \\+ low32 |\n| -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ## Example\n\n const long = BSON.Long(600206158, 342); \n``` ### BSON.Double The `BSON.Double` type represents a 64-bit (8-byte) floating point number. ## Important ### Use Decimal128 for Money `BSON.Double` is subject to floating point rounding errors, so it is not recommended for use cases where decimal values must round exactly, e.g. financial data. For these cases, use[BSON.Decimal128](#std-label-bson-decimal128) instead. `BSON.Double(double)`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.Double \"Permalink to this definition\") Constructs a `BSON.Double` object from a 64-bit decimal value. ``` BSON.Double(double: number): BSON.Double \n``` | Parameter | Type   | Description             |\n| --------- | ------ | ----------------------- |\n| double    | number | A 64-bit decimal value. | | Returns: | A BSON.Double object that encodes the specified double. Returns 0 if no argument is supplied. |\n| -------- | --------------------------------------------------------------------------------------------- | ## Example ```javascript const double = BSON.Double(1234.5678); \n``` ### BSON.Decimal128 The `BSON.Decimal128` type represents a 128-bit (16-byte) floating point number. This type is intended for use cases where decimal values must round exactly, e.g. financial data. `BSON.Decimal128.fromString(decimalString)`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-BSON.Decimal128.fromString \"Permalink to this definition\") Constructs a `BSON.Decimal128` from a string representation of a decimal number. ``` BSON.Decimal128(decimalString: string): BSON.Decimal128 \n``` | Parameter     | Type   | Description                                                        |\n| ------------- | ------ | ------------------------------------------------------------------ |\n| decimalString | string | A string representing a decimal number, e.g. \"1234.5678910123456\". | | Returns: | A BSON.Decimal128 that encodes the provided decimal value. |\n| -------- | ---------------------------------------------------------- | ## Example ```javascript const double = BSON.Decimal128.fromString(\"1234.5678910123456\"); \n``` ← [Context](https://mongodb.com/docs/atlas/app-services/functions/context/ \"Previous Section\")[External Dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/activity/alerts/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Activity Feed & Atlas App Services Alerts On this page * [Introduction](#introduction)\n* [Project Activity Feed](#project-activity-feed)\n* [Filter Activities](#filter-activities)\n* [App Services Alerts](#app-services-alerts)\n* [Default Alerts](#default-alerts)\n* [Custom App Services Alerts](#custom-app-services-alerts) ## Introduction MongoDB Atlas provides an Activity Feed that displays events for each[project](https://www.mongodb.com/docs/atlas/organizations-projects/#std-label-projects). Atlas App Services activities are included in this feed. To view and/or download only App Services events, you can specify a filter, as described below. ## Project Activity Feed There are two ways to access the Project Activity Feed: through the Atlas UI, and through the Atlas API. The following Atlas documentation pages describe each approach: * [View Activity Feed in the UI](https://www.mongodb.com/docs/atlas/tutorial/activity-feed/)\n* [Get All Project Events through the API](https://www.mongodb.com/docs/atlas/reference/api/events-projects-get-all/) ### Filter Activities App Services activities are a subset of[Atlas alerts](https://www.mongodb.com/docs/atlas/alerts/). You can filter the Project Activity Feed results to show only App Services events, or a subset of App Services events. To do this, click theFilter by event(s) menu and check App Services. In the right-hand side of the menu, you will see all App Services events selected. Deselect any that you do not want to see. The feed list automatically updates with each change you make. ![Filter App Services activities in the Atlas UI](https://mongodb.com/docs/atlas/app-services/images/activity-feed-filter-events.png) ## Note ### Filtering By App Services Application The Activity Feed does not support filtering events by App Services application, but each event (and its corresponding alert) provides context and routing information for the appropriate application. The **Category** for all App Services activities is \"App Services\"; within that category, there are several **Events**:\n\n ## App Services Alerts There are default alerts that map to three of the activities listed above. In addition, you can create custom alerts for the other App Services activities. ### Default Alerts Default App Services alerts trigger a notification and email to the Project Owners. The three default App Services alerts occur when: * An Atlas Device Sync process fails and cannot be restarted\n* A trigger fails and cannot be restarted\n* An App Services Application hits an overall request rate limit ### Custom App Services Alerts For any activity that is not mapped to a default alert, you can set a custom alert at the Project level. You create App Services alerts in the same way you [create other Atlas alerts](https://www.mongodb.com/docs/atlas/configure-alerts/). When creating a new alert, in the \"Alert if\" section, select App Services from theTarget. ← [Forward Logs to a Service](https://mongodb.com/docs/atlas/app-services/activity/forward-logs/ \"Previous Section\")[App Log Types](https://mongodb.com/docs/atlas/app-services/logs/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/activity/forward-logs/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Forward Logs to a Service On this page * [Overview](#overview)\n* [Why Should I Configure Log Forwarding?](#why-should-i-configure-log-forwarding-)\n* [How is Log Forwarding Billed?](#how-is-log-forwarding-billed-)\n* [Set Up a Log Forwarder](#set-up-a-log-forwarder)\n* [1\\. Create a Log Forwarder](#1.-create-a-log-forwarder)\n* [2\\. Choose Which Logs to Forward](#2.-choose-which-logs-to-forward)\n* [3\\. Configure Log Batching](#3.-configure-log-batching)\n* [5\\. Define an Action](#5.-define-an-action)\n* [6\\. Save and Deploy your Changes](#6.-save-and-deploy-your-changes)\n* [Restart a Suspended Log Forwarder](#restart-a-suspended-log-forwarder) ## Overview You can configure a log forwarder to automatically store your application's server-side logs in a MongoDB collection or send them to an external service. Atlas App Services can forward logs individually as they're created or batch logs together to reduce overhead. A log forwarder consists of the following components: * An **action** that controls how and where App Services forwards logs.\n* A **filter** that controls which logs App Services forwards.\n* A **policy** that controls whether App Services batches logs or forwards them individually. ### Why Should I Configure Log Forwarding? Consider setting up a log forwarder if you need to do any of the following: * Store logs for longer than App Services's retention period of 10 days.\n* Integrate logs into an external logging service\n* Access logs in Atlas Search, Online Archive, and Charts ### How is Log Forwarding Billed? Each log forward action invocation (on either an individual log or a batch) is billed as one [App Services request.](https://mongodb.com/docs/atlas/app-services/billing/#std-label-billing-requests) ## Set Up a Log Forwarder ### 1\\. Create a Log Forwarder ### 2\\. Choose Which Logs to Forward App Services can forward all of your app's logs or send only a subset to the target collection or service. You control this subset for each log forwarder by defining filters for the log type (e.g. functions, sync, etc.) and status (i.e. success or error) that invoke the forwarder's action. ## Important App Services only forwards a given log if both its type _and_ status are specified in the filter. For example, consider a forwarder that filters for `sync` logs with an `error` status. The filter _would_ forward the following log: `| { \"type\": \"sync\", \"status\": \"error\", ... } |\n| ------------------------------------------ | ` The filter _would not_ forward the following logs: ``` { \"type\": \"sync\", \"status\": \"success\", ... } { \"type\": \"schema\", \"status\": \"error\", ... } \n``` ### 3\\. Configure Log Batching App Services can combine multiple logs in to a single batched request to reduce overhead. The way that App Services groups logs into batches is controlled by a batching policy. App Services supports the following batching policies: * **No Batching:** App Services forwards logs individually as their corresponding requests occur.\n* **Batching:** The forwarder groups documents into a batch as they happen. Each batch may include up to 100 log entries. When a batch is full, App Services forwards the entire batch in a single request. App Services forwards logs at least once a minute regardless of the number of logs in the current batch. ### 5\\. Define an Action A log forwarder can automatically store logs in a linked MongoDB collection or call a custom function that sends the logs to an external service. #### Store Logs in a MongoDB Collection #### Forward Logs with a Custom Function To forward logs to an external service, [write a function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-define-a-function) that accepts an array of log objects and calls the service through an API, SDK, or library. ## Note Depending on your batching policy and log frequency, App Services may call a log forwarding function with an array of up to 100 log objects.\n\n /functions/<function name>.js ```javascript exports = async function(logs) {   // `logs` is an array of 1-100 log objects   // Use an API or library to send the logs to another service.   await context.http.post({     url: \"https://api.example.com/logs\",     body: logs,     encodeBodyAsJSON: true   }); } \n``` Once you've written the log forwarding function, you can assign it to a log forwarder by name. ### 6\\. Save and Deploy your Changes ## Restart a Suspended Log Forwarder A log forwarder may suspend in response to an event that prevents it from continuing, such as a network disruption or a change to the underlying cluster that stores the logs. Once suspended, a forwarder cannot be invoked and does not forward any logs. You can restart a suspended log forwarder from the Logs > Forwarding screen of the App Services UI. ## Note If a log forwarder is suspended, App Services sends the project owner an email alerting them of the issue. ← [View Application Logs](https://mongodb.com/docs/atlas/app-services/activity/view-logs/ \"Previous Section\")[Activity Feed & Atlas App Services Alerts](https://mongodb.com/docs/atlas/app-services/activity/alerts/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Authentication Triggers On this page * [Create an Authentication Trigger](#create-an-authentication-trigger)\n* [Configuration](#configuration)\n* [Authentication Events](#authentication-events)\n* [Example](#example)\n* [Additional Examples](#additional-examples) An authentication trigger fires when a user interacts with an[authentication provider](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers). You can use authentication triggers to implement advanced user management. Some uses include: * Storing new user data in your linked cluster\n* Maintaining data integrity upon user deletion\n* Calling a service with a user's information when they log in. ## Create an Authentication Trigger ## Configuration Authentication Triggers have the following configuration options:\n\n ## Authentication Events Authentication events represent user interactions with an authentication provider. Each event corresponds to a single user action with one of the following operation types: | Operation Type | Description                                        |\n| -------------- | -------------------------------------------------- |\n| LOGIN          | Represents a single instance of a user logging in. |\n| CREATE         | Represents the creation of a new user.             |\n| DELETE         | Represents the deletion of a user.                 | Authentication event objects have the following form: `| {                                |\n| -------------------------------- |\n| \"operationType\": <string>,       |\n| \"providers\": <array of strings>, |\n| \"user\": <user object>,           |\n| \"time\": <ISODate>                |\n| }                                | `\n\n ## Example An online store wants to store custom metadata for each of its customers in [Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container). Each customer needs a document in the `store.customers` collection. Then, the store can record and query metadata in the customer's document. The collection must represent each customer. To guarantee this, the store creates an Authentication Trigger. This Trigger listens for newly created users in the [email/password](https://mongodb.com/docs/atlas/app-services/authentication/email-password/) authentication provider. Then, it passes the[authentication event object](#std-label-authentication-events) to its linked function, `createNewUserDocument`. The function creates a new document which describes the user and their activity. The function then inserts the document into the `store.customers` collection. createNewUserDocument ```javascript exports = async function(authEvent) {   const mongodb = context.services.get(\"mongodb-atlas\");   const customers = mongodb.db(\"store\").collection(\"customers\");   const { user, time } = authEvent;   const isLinkedUser = user.identities.length > 1;   if(isLinkedUser) {     const { identities } = user;     return users.updateOne(       { id: user.id },       { $set: { identities } }     )   } else {     return users.insertOne({ _id: user.id, ...user })      .catch(console.error)   }   await customers.insertOne(newUser); } \n``` ### Additional Examples For additional examples of Triggers integrated into an App Services App, checkout the [example Triggers on Github.](https://github.com/mongodb/atlas-app-services-examples/tree/main/triggers-examples) ← [Database Triggers](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/ \"Previous Section\")[Scheduled Triggers](https://mongodb.com/docs/atlas/app-services/triggers/scheduled-triggers/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/triggers/disable/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Disable a Trigger On this page * [Overview](#overview)\n* [Find the Trigger](#find-the-trigger)\n* [Disable the Trigger](#disable-the-trigger)\n* [Deploy Your Changes](#deploy-your-changes)\n* [Pull Your App's Latest Configuration Files](#pull-your-app-s-latest-configuration-files)\n* [Verify that the Trigger Configuration File Exists](#verify-that-the-trigger-configuration-file-exists)\n* [Disable the Trigger](#disable-the-trigger-1)\n* [Deploy Your Changes](#deploy-your-changes-1)\n* [Restoring from a Snapshot](#restoring-from-a-snapshot) ## Overview Triggers may enter a suspended state in response to an event that prevents the Trigger's change stream from continuing, such as a network disruption or change to the underlying cluster. When a Trigger enters a suspended state, it does not receive change events and will not fire. ## Note In the event of a suspended or failed trigger, Atlas App Services sends the project owner an email alerting them of the issue. You can suspend a Trigger from the Atlas App Services UI or by importing an application directory with [realm-cli.](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) ## Restoring from a Snapshot Consider the following scenario: 1. A database trigger is disabled or suspended.\n2. New documents are added while the trigger is disabled.\n3. The database is restored from a snapshot to a time prior to the new documents being added.\n4. The database trigger is restarted. In this case, the trigger picks up all of the newly-added documents and fires for each document. It will not fire again for events that have already been processed. ## Note If a previously-enabled database trigger is running during snapshot restoration, you will see an error in the Edit Trigger section of the Atlas UI because the trigger cannot connect to the Atlas cluster during the restore process. Once snapshot restoration completes, the error disappears and the trigger continues to execute normally. ← [Scheduled Triggers](https://mongodb.com/docs/atlas/app-services/triggers/scheduled-triggers/ \"Previous Section\")[Send Trigger Events to AWS EventBridge](https://mongodb.com/docs/atlas/app-services/triggers/aws-eventbridge/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/triggers/scheduled-triggers/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Scheduled Triggers On this page * [Create a Scheduled Trigger](#create-a-scheduled-trigger)\n* [Configuration](#configuration)\n* [CRON Expressions](#cron-expressions)\n* [Expression Syntax](#expression-syntax)\n* [Format](#format)\n* [Field Values](#field-values)\n* [Example](#example)\n* [Performance Optimization](#performance-optimization)\n* [Additional Examples](#additional-examples) Scheduled triggers allow you to execute server-side logic on a[regular schedule that you define](#std-label-CRON-expressions). You can use scheduled triggers to do work that happens on a periodic basis, such as updating a document every minute, generating a nightly report, or sending an automated weekly email newsletter. ## Create a Scheduled Trigger ## Configuration Scheduled Triggers have the following configuration options: | Field                                   | Description                                                                                                                                                |\n| --------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Trigger Typetype: <string>              | Required. The type of the Trigger.For scheduled Triggers, this value should be set to SCHEDULED.                                                           |\n| Trigger Namename: <string>              | Required. The name of the Trigger.                                                                                                                         |\n| Linked Functionfunction\\_name: <string> | Required. The name of the Function that the Trigger executes whenever it fires.NoteA scheduled Trigger does not pass any arguments to its linked Function. |\n| Scheduleconfig.schedule: <string>       | Required. The [CRON expression](#std-label-CRON-expressions)that Atlas App Services uses to determine when to fire the Trigger.                            | ## CRON Expressions CRON expressions are user-defined strings that use standard[cron](https://en.wikipedia.org/wiki/Cron) job syntax to define when a [scheduled trigger](https://mongodb.com/docs/atlas/app-services/triggers/scheduled-triggers/) should execute. App Services executes Trigger CRON expressions based on [UTC time](https://en.wikipedia.org/wiki/Coordinated%5FUniversal%5FTime). Whenever all of the fields in a CRON expression match the current date and time, App Services fires the trigger associated with the expression. ## Expression Syntax ### Format CRON expressions are strings composed of five space-delimited fields. Each field defines a granular portion of the schedule on which its associated trigger executes:\n\n `\n\n ### Field Values Each field in a CRON expression can contain either a specific value or an expression that evaluates to a set of values. The following table describes valid field values and expressions:\n\n ## Example An online store wants to generate a daily report of all sales from the previous day. They record all orders in the `store.orders` collection as documents that resemble the following: ``` {   _id: ObjectId(\"59cf1860a95168b8f685e378\"),   customerId: ObjectId(\"59cf17e1a95168b8f685e377\"),   orderDate: ISODate(\"2018-06-26T16:20:42.313Z\"),   shipDate: ISODate(\"2018-06-27T08:20:23.311Z\"),   orderContents: [     { qty: 1, name: \"Earl Grey Tea Bags - 100ct\", price: Decimal128(\"10.99\") }   ],   shippingLocation: [     { location: \"Memphis\", time: ISODate(\"2018-06-27T18:22:33.243Z\") },   ] } \n``` To generate the daily report, the store creates a scheduled Trigger that fires every day at `7:00 AM UTC`. When the Trigger fires, it calls its linked Atlas Function,`generateDailyReport`, which runs an aggregation query on the `store.orders` collection to generate the report. The Function then stores the result of the aggregation in the`store.reports` collection. generateDailyReport ```javascript exports = function() {   // Instantiate MongoDB collection handles   const mongodb = context.services.get(\"mongodb-atlas\");   const orders = mongodb.db(\"store\").collection(\"orders\");   const reports = mongodb.db(\"store\").collection(\"reports\");   // Generate the daily report   return orders.aggregate([     // Only report on orders placed since yesterday morning     { $match: {         orderDate: {           $gte: makeYesterdayMorningDate(),           $lt: makeThisMorningDate()         }     } },     // Add a boolean field that indicates if the order has already shipped     { $addFields: {         orderHasShipped: {           $cond: {             if: \"$shipDate\", // if shipDate field exists             then: 1,             else: 0           }         }     } },     // Unwind individual items within each order     { $unwind: {         path: \"$orderContents\"     } },     // Calculate summary metrics for yesterday's orders     { $group: {         _id: \"$orderDate\",         orderIds: { $addToSet: \"$_id\" },         numSKUsOrdered: { $sum: 1 },         numItemsOrdered: { $sum: \"$orderContents.qty\" },         totalSales: { $sum: \"$orderContents.price\" },         averageOrderSales: { $avg: \"$orderContents.price\" },         numItemsShipped: { $sum: \"$orderHasShipped\" },     } },     // Add the total number of orders placed     { $addFields: {         numOrders: { $size: \"$orderIds\" }     } }   ]).next()     .then(dailyReport => {       reports.insertOne(dailyReport);     })     .catch(err => console.error(\"Failed to generate report:\", err)); }; function makeThisMorningDate() {   return setTimeToMorning(new Date()); } function makeYesterdayMorningDate() {   const thisMorning = makeThisMorningDate();   const yesterdayMorning = new Date(thisMorning);   yesterdayMorning.setDate(thisMorning.getDate() - 1);   return yesterdayMorning; } function setTimeToMorning(date) {   date.setHours(7);   date.setMinutes(0);   date.setSeconds(0);\n\n   return date; } \n``` ## Performance Optimization Use the Query API with a a [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/)expression to reduce the number of documents your Function looks at. This helps your Function improve performance and not reach[Function memory limits.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-function-constraints) [Refer the Example section for a Scheduled Trigger using a $match expression.](#std-label-scheduled-trigger-example) ### Additional Examples For additional examples of Triggers integrated into an App Services App, checkout the [example Triggers on Github.](https://github.com/mongodb/atlas-app-services-examples/tree/main/triggers-examples) ← [Authentication Triggers](https://mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/ \"Previous Section\")[Disable a Trigger](https://mongodb.com/docs/atlas/app-services/triggers/disable/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/triggers/database-triggers/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Database Triggers On this page * [Create a Database Trigger](#create-a-database-trigger)\n* [Configuration](#configuration)\n* [Database Change Events](#database-change-events)\n* [Suspended Triggers](#suspended-triggers)\n* [Automatically Resume a Suspended Trigger](#automatically-resume-a-suspended-trigger)\n* [Manually Resume a Suspended Trigger](#manually-resume-a-suspended-trigger)\n* [Last Cluster Time Processed](#last-cluster-time-processed)\n* [Example](#example)\n* [Performance Optimization](#performance-optimization)\n* [Disable Event Ordering for Burst Operations](#disable-event-ordering-for-burst-operations)\n* [Disable Collection-Level Preimages](#disable-collection-level-preimages)\n* [Use Match Expressions to Limit Trigger Invocations](#use-match-expressions-to-limit-trigger-invocations)\n* [Use Project Expressions to Reduce Input Data Size](#use-project-expressions-to-reduce-input-data-size) Database Triggers allow you to execute server-side logic whenever a document is added, updated, or removed in a linked MongoDB Atlas cluster. Unlike SQL data triggers, which run on the database server, triggers run on a serverless compute layer that scales independently of the database server. Triggers automatically call [Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions)and can forward events to external handlers through AWS EventBridge. Use database triggers to implement event-driven data interactions. For example, you can automatically update information in one document when a related document changes or send a request to an external service whenever a new document is inserted. Database triggers use MongoDB [change streams](https://www.mongodb.com/docs/manual/changeStreams/)to watch for real-time changes in a collection. A change stream is a series of [database events](#std-label-database-events) that each describe an operation on a document in the collection. Your app opens a single change stream for each collection with at least one enabled trigger. If multiple triggers are enabled for a collection they all share the same change stream. You control which operations cause a trigger to fire as well as what happens when it does. For example, you can run a function whenever a specific field of a document is updated. The function can access the entire change event, so you always know what changed. You can also pass the change event to [AWS EventBridge](https://mongodb.com/docs/atlas/app-services/triggers/aws-eventbridge/#std-label-aws-eventbridge) to handle the event outside of Atlas. Triggers support [$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) expressions to filter change events and [$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/)expressions to limit the data included in each event. ## Important ### Change Stream Limitations There are limits on the total number of change streams you can open on a cluster, depending on the cluster's size. Refer to [change stream limitations](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/#std-label-mongodb-service-limitations-change-streams) for more information. You cannot define a database trigger on a [serverless instance](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-serverless-caveats) or [Federated database instance](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats) because they do not support change streams. ## Create a Database Trigger ## Configuration Database Triggers have the following configuration options:\n\n ## Database Change Events Database change events represent individual changes in a specific collection of your linked MongoDB Atlas cluster. Every database event has the same operation type and structure as the[change event](https://www.mongodb.com/docs/manual/reference/change-events/) object that was emitted by the underlying change stream. Change events have the following operation types: | Operation Type | Description                                                           |\n| -------------- | --------------------------------------------------------------------- |\n| INSERT         | Represents a new document added to the collection.                    |\n| UPDATE         | Represents a change to an existing document in the collection.        |\n| REPLACE        | Represents a new document that replaced a document in the collection. |\n| DELETE         | Represents a document deleted from the collection.                    | Database change event objects have the following general form: ``` {    _id : <ObjectId>,    \"operationType\": <string>,    \"fullDocument\": <document>,    \"fullDocumentBeforeChange\": <document>,    \"ns\": {       \"db\" : <string>,       \"coll\" : <string>    },    \"documentKey\": {      \"_id\": <ObjectId>    },    \"updateDescription\": <document>,    \"clusterTime\": <Timestamp> } \n``` ## Suspended Triggers Database Triggers may enter a suspended state in response to an event that prevents the Trigger's change stream from continuing. Events that can suspend a Trigger include: * [invalidate events](https://www.mongodb.com/docs/manual/reference/change-events/#invalidate-event)such as `dropDatabase`, `renameCollection`, or those caused by a network disruption.\n* the **resume token** required to resume the change stream is no longer in the cluster [oplog](https://www.mongodb.com/docs/manual/core/replica-set-oplog/). The App logs refer to this as a `ChangeStreamHistoryLost` error. In the event of a suspended or failed trigger, Atlas App Services sends the project owner an email alerting them of the issue. ### Automatically Resume a Suspended Trigger You can configure a Trigger to automatically resume if the Trigger was suspended because the resume token is no longer in the oplog. The Trigger does not process any missed change stream events between when the resume token is lost and when the resume process completes. ### Manually Resume a Suspended Trigger When you manually resume a suspended Trigger, your App attempts to resume the Trigger at the next change stream event after the change stream stopped. If the resume token is no longer in the cluster oplog, the Trigger must be started without a resume token. This means the Trigger begins listening to new events but does not process any missed past events. You can adjust the oplog size to keep the resume token for more time after a suspension by [scaling your Atlas cluster](https://www.mongodb.com/docs/atlas/scale-cluster/). Maintain an oplog size a few times greater than your cluster's peak oplog throughput (GB/hour) to reduce the risk of a suspended trigger's resume token dropping off the oplog before the trigger executes. View your cluster's oplog throughput in the **Oplog GB/Hour** graph in the[Atlas cluster metrics.](https://www.mongodb.com/docs/atlas/monitor-cluster-metrics/) You can attempt to restart a suspended Trigger from the App Services UI or by importing an application directory with [realm-cli.](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) ## Last Cluster Time Processed\n\n The difference between the latest execution and the last cluster time processed represents the latency between when an event occurs in your database, and when the Trigger finishes responding to that event. If latency is consistently large, you can reduce it with the following mitigations: * Optimize the Trigger's Linked Function to speed up execution.\n* If your Trigger uses Event Ordering, consider switching ordering off to reduce latency.\n* Add resources by upgrading your MongoDB Atlas cluster. ## Example An online store wants to notify its customers whenever one of their orders changes location. They record each order in the `store.orders`collection as a document that resembles the following: ``` {   _id: ObjectId(\"59cf1860a95168b8f685e378\"),   customerId: ObjectId(\"59cf17e1a95168b8f685e377\"),   orderDate: ISODate(\"2018-06-26T16:20:42.313Z\"),   shipDate: ISODate(\"2018-06-27T08:20:23.311Z\"),   orderContents: [     { qty: 1, name: \"Earl Grey Tea Bags - 100ct\", price: NumberDecimal(\"10.99\") }   ],   shippingLocation: [     { location: \"Memphis\", time: ISODate(\"2018-06-27T18:22:33.243Z\") },   ] } \n``` To automate this process, the store creates a database Trigger that listens for `UPDATE` change events in the `store.orders` collection. When the trigger observes an `UPDATE` event, it passes the[change event object](#std-label-database-events) to its associated Function,`textShippingUpdate`. The Function checks the change event for any changes to the `shippingLocation` field and, if it was updated, sends a text message to the customer with the new location of the order. textShippingUpdate ```javascript exports = async function (changeEvent) {   // Destructure out fields from the change stream event object   const { updateDescription, fullDocument } = changeEvent;   // Check if the shippingLocation field was updated   const updatedFields = Object.keys(updateDescription.updatedFields);   const isNewLocation = updatedFields.some(field =>     field.match(/shippingLocation/)   );   // If the location changed, text the customer the updated location.   if (isNewLocation) {     const { customerId, shippingLocation } = fullDocument;     const twilio = context.services.get(\"myTwilioService\");     const mongodb = context.services.get(\"mongodb-atlas\");     const customers = mongodb.db(\"store\").collection(\"customers\");     const { location } = shippingLocation.pop();     const customer = await customers.findOne({ _id: customer_id })     twilio.send({       to: customer.phoneNumber,       from: context.values.get(\"ourPhoneNumber\"),       body: `Your order has moved! The new location is ${location}.`     });   } }; \n``` ## Performance Optimization ### Disable Event Ordering for Burst Operations Consider disabling event ordering if your trigger fires on a collection that receives short bursts of events (e.g. inserting data as part of a daily batch job). Ordered Triggers wait to execute a Function for a particular event until the Functions of previous events have finished executing. As a consequence, ordered Triggers are effectively rate-limited by the run time of each sequential Trigger function. This may cause a significant delay between the database event and the Trigger firing if a sufficiently large number of Trigger executions are currently in the queue. Unordered Triggers execute functions in parallel if possible, which can be significantly faster (depending on your use case) but does not guarantee that multiple executions of a Trigger Function occur in event order. ### Disable Collection-Level Preimages Document preimages require your cluster to record additional data about each operation on a collection. Once you enable preimages for any trigger on a collection, your cluster stores preimages for every operation on the collection. The additional storage space and compute overhead may degrade trigger performance depending on your cluster configuration. To avoid the storage and compute overhead of preimages, you must disable preimages for the entire underlying MongoDB collection. This is a separate setting from any individual trigger's preimage setting.\n\n To learn how, see [Disable Preimages for a Collection.](https://mongodb.com/docs/atlas/app-services/mongodb/preimages/#std-label-disable-collection-preimages) ### Use Match Expressions to Limit Trigger Invocations In the Match Expression field, limit the number of Trigger invocations by using Match expressions. The Trigger is only invoked if the document meets the criteria of the[$match](https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/) expression. ## Example The following Match Expression configures a trigger to fire only if the change event object specifies that the `status` field in a document changed. ```javascript {   \"updateDescription.updatedFields.status\": {     \"$exists\": true   } } \n``` ### Use Project Expressions to Reduce Input Data Size In the Project Expression field, limit the number of fields that the Trigger processes by using a[$project](https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/) expression. ## Note ### Project is inclusive only When using Triggers, a projection expression is inclusive _only_. Project does not support mixing inclusions and exclusions. The project expression must be inclusive because Triggers require you to include `operationType`. If you want to exclude a single field, the projection expression must include every field _except_ the one you want to exclude. You can only explicitly exclude `_id`, which is included by default. ## Example A trigger is configured with the following Project Expression: ``` {   \"_id\": 0,   \"operationType\": 1,   \"updateDescription.updatedFields.status\": 1 } \n``` The change event object that App Services passes to the trigger function only includes the fields specifed in the projection, as in the following example: ``` {   \"operationType\": \"update\",   \"updateDescription\": {     \"updatedFields\": {       \"status\": \"InProgress\"     }   } } \n``` #### Additional Examples For additional examples of Triggers integrated into an App Services App, checkout the [example Triggers on Github.](https://github.com/mongodb/atlas-app-services-examples/tree/main/triggers-examples) ← [Atlas Triggers](https://mongodb.com/docs/atlas/app-services/triggers/ \"Previous Section\")[Authentication Triggers](https://mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Convert Webhooks to HTTPS Endpoints On this page * [Overview](#overview)\n* [Automatically Convert Existing HTTP Webhooks](#automatically-convert-existing-http-webhooks)\n* [Manually Convert GitHub and Twilio Webhooks](#manually-convert-github-and-twilio-webhooks)\n* [GitHub Webhooks](#github-webhooks)\n* [Twilio Webhooks](#twilio-webhooks)\n* [Update Callback URLs in Client Apps & Services](#update-callback-urls-in-client-apps---services)\n* [Differences between Webhooks and Their Converted Endpoints](#differences-between-webhooks-and-their-converted-endpoints) ## Overview The Atlas App Services third-party service webhooks are deprecated in favor of custom HTTPS endpoints. HTTPS endpoints are functionally almost identical to webhooks but are now a first-class service. This guide walks through converting your app's existing webhooks and updating external apps that call them. For new webhooks or callback URLs, you should define an HTTPS endpoint. ## Automatically Convert Existing HTTP Webhooks App Services can automatically convert any existing HTTP service webhooks in your app into HTTPS endpoints. This conversion is one-way which means that you cannot convert HTTPS endpoints back into webhooks. The conversion process does not delete the original webhooks so incoming webhook requests will continue to execute after the conversion. To run the webhook to HTTPS endpoint conversion process for all webhooks in your application: 1. Click HTTPS Endpoints in the left navigation menu of the App Services UI.\n2. Click the Convert button.\n3. Confirm that you want to run the conversion. ![Convert all Endpoints in UI](https://mongodb.com/docs/atlas/app-services/images/confirmation_converting_webhooks.png) ## Note The converted HTTPS endpoints are independent from their source webhooks. If you choose to edit a webhook after running the conversion, you can run the conversion again with the \"Convert & Override\" option to propogate those changes to your new endpoints. ## Manually Convert GitHub and Twilio Webhooks App Services cannot automatically convert GitHub and Twilio webhooks to HTTPS endpoints because they use deprecated client libraries. However, you can manually migrate webhooks from these services to new HTTPS endpoints. ### GitHub Webhooks To migrate a GitHub webhook to an HTTPS endpoint: 1. Create a new HTTPS endpoint\n2. Copy the existing GitHub webhook code into the new endpoint's function\n3. Update your code to parse the incoming request body instead of using the pre-parsed GitHub payload.  \nBefore: A GitHub webhook with a pre-parsed payload  \n`| exports = async function(payload, response) {    |  \n| ------------------------------------------------ |  \n| // Webhooks only provide the parsed request body |  \n| const { commits, pusher, repository } = payload; |  \n| // ... your code here                            |  \n| }                                                |  \n`  \nAfter: An HTTPS endpoint that parses the GitHub payload  \n```javascript  \nexports = async function(payload, response) {  \n  // Endpoints pass an entire request payload, not just a parsed body  \n  const { commits, pusher, repository } = JSON.parse(payload.body.text());  \n  // ... your code here  \n}  \n``` ### Twilio Webhooks To migrate a Twilio webhook to an HTTPS endpoint:\n\n ## Update Callback URLs in Client Apps & Services HTTPS endpoints use a different URL scheme than service webhooks. You should update any apps or services that call your webhooks to instead call the converted HTTPS endpoint URL. Existing webhooks URLs will continue to accept requests and execute their associated functions after you've run the conversion. This means that you can gradually migrate to the new URLs without breaking existing workflows. To migrate to the converted HTTPS endpoint URLs: 1. Identify all client apps and services that call service webhooks\n2. For each app or service, modify the source code or configuration to use the new URLs.\n3. Monitor your app's logs for [service webhook](https://mongodb.com/docs/atlas/app-services/logs/service/#std-label-logs-webhooks)records to look for any active webhook callers that you missed.\n4. Once all clients are updated with the new URLs, delete the deprecated webhooks from your app. ## Example To migrate a service's integration from an App Services webhook to the converted HTTPS endpoint, modify the service's external configuration for outgoing webhook requests to point to the converted endpoint URL. Deprecated HTTP Service Webhook URL ``` https://webhooks.mongodb-realm.com/api/client/v2.0/app/myapp-abcde/service/myHttpService/incoming_webhook/handleIncomingEvent \n``` Converted HTTPS Endpoint URL ``` https://data.mongodb-api.com/app/myapp-abcde/endpoint/myHttpService/handleIncomingEvent \n``` ## Differences between Webhooks and Their Converted Endpoints If you configured your converted HTTPS endpoint to use Respond with Resultand the webhook function it's based on returns a value but does not invoke `response.setBody()`, the generated endpoint includes the function's return value as its response body. The webhook, in contrast, only returns a body specified by `response.setBody()`. ## Example ```javascript exports = function({ query, headers, body}, response){    response.setStatusCode(200);    return \"Hello world\"; }; \n``` The webhook for this function only responds with status code `200` without a body. For the endpoint, if you enable **Respond with Result**, the endpoint responds with status code `200` _and_ the body `\"Hello world\"`. If you don't enable **Respond with Result**, the endpoint only responds with status code `200`. ← [Replace Services with npm Modules](https://mongodb.com/docs/atlas/app-services/services/replace-with-npm-modules/ \"Previous Section\")[Call a Service Action \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/call-a-service-action/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/triggers/aws-eventbridge/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Send Trigger Events to AWS EventBridge On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Begin Setup of the MongoDB Partner Event Source](#begin-setup-of-the-mongodb-partner-event-source)\n* [Configure the Trigger](#configure-the-trigger)\n* [Associate the Trigger Event Source with an Event Bus](#associate-the-trigger-event-source-with-an-event-bus)\n* [Example Event](#example-event)\n* [Performance Optimization](#performance-optimization) ## Overview MongoDB offers an [AWS Eventbridge](https://aws.amazon.com/eventbridge/) partner event source that lets you send Atlas Trigger events to an event bus instead of calling an Atlas Function. You can configure any Trigger to send events to EventBridge. All you need to send Trigger events to EventBridge is an AWS account ID. This guide walks through finding your account ID, configuring the Trigger, and associating the Trigger event source with an event bus. ## Note ### Official AWS Partner Event Source Guide This guide is based on Amazon's [Receiving Events from a SaaS Partner](https://docs.aws.amazon.com//eventbridge/latest/userguide/create-partner-event-bus.html)documentation. ## Procedure ## Note The AWS put entry for an EventBridge trigger event must be smaller than 256 KB. [Learn how to reduce the size of your PutEvents entry in the Performance Optimization section.](#std-label-send-aws-eventbridge-performance-optimization) 1 ### Begin Setup of the MongoDB Partner Event Source To send trigger events to AWS EventBridge, you need the AWS account ID of the account that should receive the events. Open the [Amazon EventBridge console](https://console.aws.amazon.com/events/) and clickPartner event sources in the navigation menu. Search for the MongoDB partner event source and then clickSet up. ![The MongoDB partner event source in EventBridge](https://mongodb.com/docs/atlas/app-services/images/eventbridge-set-up-mongodb-source.png) On the MongoDB partner event source page, clickCopy to copy your AWS account ID to the clipboard. ![The prompt to copy your AWS account ID in EventBridge](https://mongodb.com/docs/atlas/app-services/images/eventbridge-copy-aws-account-id.png) 2 ### Configure the Trigger Once you have the AWS account ID, you can configure a trigger to send events to EventBridge. ## Note ### Supported AWS Regions For a full list of supported AWS regions, refer to Amazon's[Receiving Events from a SaaS Partner](https://docs.aws.amazon.com//eventbridge/latest/userguide/create-partner-event-bus.html)guide. 3 ### Associate the Trigger Event Source with an Event Bus Go back to the EventBridge console and choose Partner event sources in the navigation pane. In the Partner event sources table, find and select the Pending trigger source and then clickAssociate with event bus. ![The MongoDB partner event sources table in EventBridge](https://mongodb.com/docs/atlas/app-services/images/eventbridge-partner-event-sources-table.png) On the Associate with event bus screen, define any required access permissions for other accounts and organizations and then click Associate. ![The screen to associate the MongoDB event source with an event bus in EventBridge](https://mongodb.com/docs/atlas/app-services/images/eventbridge-associate-with-event-bus.png) Once confirmed, the status of the trigger event source changes fromPending to Active, and the name of the event bus updates to match the event source name. You can now start creating rules that trigger on events from that partner event source. For more information, see [Creating a Rule That Triggers on a SaaS Partner Event.](https://docs.aws.amazon.com//eventbridge/latest/userguide/create-rule-partner-events.html) ![The MongoDB partner event sources table in EventBridge showing the active trigger event source](https://mongodb.com/docs/atlas/app-services/images/eventbridge-partner-event-sources-table-active.png) ## Example Event The following object configures a trigger to send events to AWS Eventbridge:\n\n ` ## Performance Optimization The AWS put entry for an EventBridge trigger event must be smaller than 256 KB. For more information, see the [AWS Documentation to calculate Amazon PutEvents event entry size.](http://docs.aws.amazon.com/eventbridge/latest/userguide/eb-putevent-size.html) When using Database Triggers, the Project Expression can be useful reduce the document size before sending messages to EventBridge. This expression lets you include only specified fields, reducing document size. [Learn more in the Database Trigger Project Expression documentation.](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-triggers-project-expression) ← [Disable a Trigger](https://mongodb.com/docs/atlas/app-services/triggers/disable/ \"Previous Section\")[Develop & Deploy Apps](https://mongodb.com/docs/atlas/app-services/apps/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/http/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # HTTP Service \\[Deprecated\\] On this page * [Overview](#overview)\n* [Configuration Parameters](#configuration-parameters)\n* [Service Actions](#service-actions)\n* [Incoming Webhooks](#incoming-webhooks)\n* [Configuration](#configuration)\n* [Request Payload](#request-payload)\n* [Example Webhook Function](#example-webhook-function) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview The Atlas App Services HTTP Service is a generic interface that enables you to communicate with any service that is available over HTTP, such as those that provide a REST API. This is useful when you need to use a service that does not have a custom service built-in to App Services. * To send an outbound HTTP request, call one of the [HTTP actions.](#std-label-http-service-actions)\n* To handle incoming requests from an external service, [configure an incoming webhook](https://mongodb.com/docs/atlas/app-services/services/configure/service-webhooks/) and provide it to the service, if possible. See the [incoming webhooks](#std-label-http-webhooks) section on this page for an example. ## Configuration Parameters You will need to provide values for the following parameters when you[create an HTTP service interface:](https://mongodb.com/docs/atlas/app-services/services/configure/services/) | Parameter                 | Description                                                                                                         |\n| ------------------------- | ------------------------------------------------------------------------------------------------------------------- |\n| Service Name_config.name_ | The name of this HTTP service interface. This must be unique from all other service interfaces in your application. | ## Service Actions The HTTP service in App Services provides the following actions that you can call in [functions](https://mongodb.com/docs/atlas/app-services/functions/) and in the SDKs. Each action maps to a standard [HTTP request method.](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) For instructions on using an HTTP service action, see [Call a Service Action.](https://mongodb.com/docs/atlas/app-services/services/call-a-service-action/) ## Note You must enable a service action in a [service rule](https://mongodb.com/docs/atlas/app-services/services/configure/service-rules/) before you can call it.\n\n ## Incoming Webhooks ## Note ### Convert HTTP Webhooks to Endpoints HTTP Service webhoooks are deprecated in favor of custom HTTPS endpoints. You can automatically migrate your existing webhooks to endpoints in one-click. To learn how, see [Convert Webhooks to HTTPS Endpoints.](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-migrate-http-webhooks-to-endpoints) ### Configuration\n\n ### Request Payload App Services automatically passes a `payload` document as the first argument to incoming webhook functions. In an HTTP Service incoming webhook the`payload` object represents an incoming HTTP request and has the following form: `| {                             |\n| ----------------------------- |\n| \"query\": <query parameters>,  |\n| \"headers\": <request headers>, |\n| \"body\": <request body (BSON)> |\n| }                             | ` | Field   | Description                                                                                                                                                                                                                                                                                                                                                                       |\n| ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| query   | A document where each field corresponds to a [query parameter](https://en.wikipedia.org/wiki/Query%5Fstring) that the external service included in the webhook URL.ExampleA request sent to a webhook URL with the query parameterssomeParameter=42&anotherParameter=hello would have the following query document:\"query\": {  \"someParameter\": 42,  \"anotherParameter\": \"hello\"} |\n| headers | A document where each field corresponds to an [HTTP header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) that the external service included in the webhook URL.ExampleA request sent to a webhook URL with a Content-Type: application/json header would have the following headersdocument:\"headers\": {  \"Content-Type\": \\[\"application/json\"\\]}                   |\n| body    | A [BSON.Binary](https://mongodb.com/docs/atlas/app-services/functions/globals/#std-label-bson) object encoded from the request body. You can access the request body by serializing the binary object to a string and then parsing the string to EJSON:const body \\= EJSON.parse(payload.body.text())                                                                                                | ### Example Webhook Function The following webhook function inserts incoming data into a MongoDB collection and returns the `insertedId` in the response `body`. ```javascript exports = function(payload, response) {   const mongodb = context.services.get(\"mongodb-atlas\");\n\n   requestLogs.insertOne({     body: EJSON.parse(payload.body.text()),     query: payload.query   }).then(result => {     response.setStatusCode(201);     response.setBody(result.insertedId);   }) }; \n``` ← [Configure Service Rules \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/configure/service-rules/ \"Previous Section\")[http.get()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.get/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/github/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # GitHub Service \\[Deprecated\\] On this page * [Overview](#overview)\n* [Configuration Parameters](#configuration-parameters)\n* [Service Actions](#service-actions)\n* [Incoming Webhooks](#incoming-webhooks)\n* [Configuration](#configuration)\n* [Request Payload](#request-payload)\n* [Example Webhook Function](#example-webhook-function)\n* [Configure GitHub](#configure-github)\n* [Add a Webhook to a GitHub Repository](#add-a-webhook-to-a-github-repository) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview GitHub is a web-based development platform for hosting and reviewing Git repositories. The Atlas App Services GitHub service allows your application to react to events in a GitHub repository, such as new pull requests or issues. ## Configuration Parameters You will need to provide values for the following parameters when you[create a GitHub service interface:](https://mongodb.com/docs/atlas/app-services/services/configure/services/) | Parameter                 | Description                                                                                                           |\n| ------------------------- | --------------------------------------------------------------------------------------------------------------------- |\n| Service Name_config.name_ | The name of this GitHub service interface. This must be unique from all other service interfaces in your application. | ## Service Actions GitHub Services do not provide any service actions. Use an[incoming webhook](#std-label-github-incoming-webhooks) to respond to events in your GitHub repo. ## Incoming Webhooks ## Note ### Convert GitHub Webhooks to Endpoints GitHub Service webhoooks are deprecated in favor of custom HTTPS endpoints. To learn how to migrate your existing GitHub webhooks to endpoints, see [Convert Webhooks to HTTPS Endpoints.](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-migrate-github-webhooks-to-endpoints) GitHub can invoke one or more webhooks whenever a particular event occurs in a repository. If you'd like to learn more about GitHub's webhook functionality, including detailed reference information about GitHub event types, see GitHub's [Webhook](https://developer.github.com//webhooks)documentation. ### Configuration\n\n ### Request Payload App Services automatically passes a `payload` document as the first argument to incoming webhook functions. In a GitHub Service incoming webhook the`payload` object represents the GitHub event that caused GitHub to call the webhook. ## Note The exact content of GitHub `payload` documents varies depending on the event type that it represents. For a detailed description of a specific event type's payload document, refer to GitHub's[Event Types & Payloads](https://developer.github.com/v3/activity/events/types)documentation. ### Example Webhook Function The following webhook function inserts incoming data into a MongoDB collection. `` | exports = function(payload) {                                           |\n| ----------------------------------------------------------------------- |\n| const mongodb = context.services.get(\"mongodb-atlas\");                  |\n| const requestlogs = mongodb.database(\"test\").collection(\"requestlogs\"); |\n| return requestlogs                                                      |\n| .insertOne({                                                            |\n| \"commits\": payload.commits,                                             |\n| \"pushed_by\": payload.pusher,                                            |\n| \"repo\": payload.repository.html_url                                     |\n| })                                                                      |\n| .then(({ insertedId }) => `Inserted document with _id: ${insertedId}`)  |\n| }                                                                       |  `` The `payload` document is passed by the GitHub service and contains information from the request. ## Configure GitHub ### Add a Webhook to a GitHub Repository 1. Log into [GitHub.](https://github.com/)\n2. Navigate to the repository that you want to subscribe to.\n3. Click the Settings tab of the repository and selectWebhooks from the left hand menu.\n4. Click Add Webhook.\n5. Add the webhook URL to the Payload URL field.\n6. Set the content type to `application/json`.\n7. Enter the GitHub Secret. This should match the value you provided in the webhook configuration.\n8. Choose the type of events that you want to subscribe to.\n9. Click Add webhook. ← [AWS Service \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/aws/ \"Previous Section\")[AWS S3 Snippets \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/snippets/s3/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/aws/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # AWS Service \\[Deprecated\\] On this page * [Overview](#overview)\n* [Configuration Parameters](#configuration-parameters)\n* [Service Actions](#service-actions)\n* [AWS Service Rules](#aws-service-rules)\n* [Rule Conditions](#rule-conditions)\n* [Example](#example)\n* [Usage](#usage)\n* [Call an AWS Service from an Atlas Function](#call-an-aws-service-from-an-atlas-function)\n* [Supported AWS Services](#supported-aws-services) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview [Amazon Web Services (AWS)](https://aws.amazon.com/) provides an extensive collection of cloud-based services. Atlas App Services provides a generic AWS service that enables you to connect to many of these services. ## Configuration Parameters You will need to provide values for the following parameters when you[create an AWS service interface:](https://mongodb.com/docs/atlas/app-services/services/configure/services/)\n\n ## Tip ### See also:  * [Managing Access Keys for Your AWS Account](https://docs.aws.amazon.com/general/latest/gr/managing-aws-access-keys.html)\n* [Create IAM Users](https://docs.aws.amazon.com/IAM/latest/UserGuide/best-practices.html#create-iam-users) ## Service Actions Each AWS service has different actions that you can perform on that service. App Services uses the action names specified in the [AWS SDK for Go](https://docs.aws.amazon.com/sdk-for-go/api/) for each service. ## Note App Services uses the same names (and casing) for the AWS services and actions as the AWS Go SDK. For each supported AWS service, App Services supports any action that: 1. Takes a single input parameter.\n2. Returns one of two objects: an output object, or an error. For example, the `S3` service includes a [PutObject](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#S3.PutObject)action. App Services supports this action because it takes a single input type of [PutObjectInput](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#PutObjectInput), and returns either a [PutObjectOutput](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#PutObjectOutput) or an error. ## AWS Service Rules You must specify rules to enable the AWS services and actions. Each rule applies to a single service API, plus one or all actions on that service. As with other service rules in App Services, a rule must evaluate to `true` to enable the action. For example, the following rule enables all actions on the Kinesis service: ![AWS Kinesis rule.](https://mongodb.com/docs/atlas/app-services/images/aws-kinesis-rule.png) ## Note The default value of the Whenfield contains only empty brackets, which means the rule will always evaluate to `true`, and therefore all calls to the action are valid. This rule can also be expressed as the following [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions). Note that in the array of `actions`, the asterisk (`*`) after the service name indicates that all actions of that service are enabled: `| {                  |\n| ------------------ |\n| \"name\": \"kinesis\", |\n| \"actions\": [       |\n| \"kinesis:*\"        |\n| ]                  |\n| }                  | ` ## Rule Conditions For each service action, the rule you create may include any of the properties of the input object for that action as a condition for validating the rule. The `%%args` expansion provides access to these properties. ### Example #### `S3 PutObject` The `S3` service includes the [PutObject](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#S3.PutObject)action, which takes an input object of type of [PutObjectInput](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#PutObjectInput). You can reference any of the properties on the`PutObjectInput` object in a rule's When expression with the[%%args](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---args) expansion. Using the `Bucket` property of the `PutObjectInput` object, you can create a rule that enables the `PutObject` action on the S3 service, but restricts the action to a list of approved buckets. In this example, we use a user-defined constant called `myS3Buckets` for the list of approved bucket names: ![AWS S3 rule](https://mongodb.com/docs/atlas/app-services/images/aws-s3-rule.png) This can also be expressed as the following JSON: ```javascript {    \"name\": \"s3\",    \"actions\": [       \"s3:PutObject\"    ],    \"when\": {\n\n             \"$in\": \"%%values.myS3Buckets\"       }    } } \n``` #### `S3 GetObject` The `S3` service includes the [GetObject](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#S3.GetObject)action, which takes an input object of type of [GetObjectInput](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#GetObjectInput). You can reference any of the properties on the`GetObjectInput` object in a rule's When expression with the[%%args](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---args) expansion. In the following example, we create a rule that enables the `GetObject`action on a specific bucket called `realmReadWritableBucket`: ![AWS S3 rule](https://mongodb.com/docs/atlas/app-services/images/aws-s3-getobject-rule.png) This can also be expressed as the following JSON: ```javascript {    \"name\": \"s3\",    \"actions\": [       \"s3:GetObject\"    ],    \"when\": {       \"%%args.Bucket\": {             \"$in\": \"realmReadWritableBucket\"       }    } } \n``` ## Usage You can call an AWS service from an Atlas Function and from the SDKs. The following sections show each of these processes. ### Call an AWS Service from an Atlas Function The following examples show how to call various AWS services from within an Atlas Function. In each example, it is assumed the named service has already been created. #### S3 Service ##### `S3 PutObject` ```javascript exports = async function() {   const s3 = context.services.get('MyAwsService').s3(\"us-east-1\");   const result = await s3.PutObject({     \"Bucket\": \"my-bucket\",     \"Key\": \"example\",     \"Body\": \"hello there\"   });   console.log(EJSON.stringify(result));   return result; }; \n``` ##### `S3 GetObject` ```javascript exports = async function(arg) {    const s3 = context.services.get('MyAwsService').s3(\"us-east-1\");    const result = await s3.GetObject({       \"Bucket\": \"realmReadWritableBucket\",       \"Key\": \"coffee.jpeg\"    });    console.log(EJSON.stringify(result));    return result; }; \n``` ##### `S3 PresignURL` ```javascript exports = function(){   const s3 = context.services.get(\"MyAwsService\").s3(\"us-east-1\");   const presignedUrl = s3.PresignURL({    \"Bucket\": \"my-s3-bucket-name\",    \"Key\": \"/some/path\",    // HTTP method that is valid for this signed URL. Can use PUT for uploads, or GET for downloads.    \"Method\": \"GET\",    // Duration of the lifetime of the signed url, in milliseconds    \"ExpirationMS\": 30000,   })   return presignedUrl }; \n``` Refer to the [S3 API Reference](https://docs.aws.amazon.com/sdk-for-go/api/service/s3) for implementation details. ## Important ### Object Size Limitation App Services supports a maximum file size of 4 Megabytes when working with AWS S3 objects. #### Kinesis Service ```javascript exports = async function(event) {   const kinesis = context.services.get('MyAwsService').kinesis(\"us-east-1\");   const result = await kinesis.PutRecord({     Data: JSON.stringify(event.fullDocument),     StreamName: \"realmStream\",     PartitionKey: \"1\"   });   console.log(EJSON.stringify(result));   return result; }; \n```\n\n #### Lambda Service ```javascript exports = async function() {   const lambda = context.services.get('MyAwsService').lambda(\"us-east-1\");   const result = await lambda.Invoke({     FunctionName: \"myLambdaFunction\",     Payload: context.user.id   });   console.log(result.Payload.text());   return EJSON.parse(result.Payload.text()); }; \n``` Refer to the [Lambda API Reference](https://docs.aws.amazon.com/sdk-for-go/api/service/lambda) for implementation details. #### SES Service ```javascript exports = async function(){   const ses = context.services.get('MyAwsService').ses(\"us-east-1\");   const result = await ses.SendEmail({     Source: \"sender@example.com\",     Destination: { ToAddresses: [\"docs@mongodb.com\"] },     Message: {       Body: {         Html: {           Charset: \"UTF-8\",           Data: `This is a message from user ${context.user.id}`         }       },       Subject: {         Charset: \"UTF-8\",         Data: \"Test Email Please Ignore\"       }     }   });   console.log(EJSON.stringify(result));   return result; }; \n``` Refer to the [SES API Reference](https://docs.aws.amazon.com/sdk-for-go/api/service/ses) for implementation details. ## Supported AWS Services Your App can connect to the following AWS services: * Athena\n* Batch\n* CloudWatch\n* Comprehend\n* EC2\n* Firehose\n* Glacier\n* IOT\n* Kinesis\n* Lambda\n* Lex Runtime Service\n* Machine Learning\n* Mobile Analytics\n* Polly\n* RDS\n* Redshift\n* Rekognition\n* S3\n* SES\n* Step Functions (SFN)\n* SNS\n* SQS\n* Textract ← [twilio.send()](https://mongodb.com/docs/atlas/app-services/services/twilio-actions/send/ \"Previous Section\")[GitHub Service \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/github/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/call-a-service-action/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Call a Service Action \\[Deprecated\\] On this page * [Overview](#overview)\n* [Call from a Function](#call-from-a-function) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview You can call actions associated with a [service](https://mongodb.com/docs/atlas/app-services/reference/services/) from Atlas Functions, including incoming webhooks and triggers, or directly from a connected client application. Each service action is available as a method on its respective service client. ## Note You must [configure a service rule](https://mongodb.com/docs/atlas/app-services/services/configure/service-rules/) that enables an action before you can call it. The examples in this section demonstrate calling the [post()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.post/) action from the HTTP Service. Each service action follows a similar pattern but has distinct parameters. For details on the parameters and usage of a specific action, refer to that action's reference page. ## Call from a Function To call a service action from a [function:](https://mongodb.com/docs/atlas/app-services/functions/) 1. Instantiate a service client from [function context](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-services) using the `context.services` interface.\n2. Call the method associated with the action. `| const http = context.services.get(\"myHttpService\");  |\n| ---------------------------------------------------- |\n| http.post({                                          |\n| \"url\": \"https://www.example.com\",                    |\n| \"headers\": { \"Content-Type\": [\"application/json\"] }, |\n| \"body\": { \"msg\": \"Hello from a service action!\" }    |\n| })                                                   |\n| .then(() => \"Successfully sent the post request!\")   | ` ← [Convert Webhooks to HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/ \"Previous Section\")[Webhook Requests & Responses \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/webhook-requests-and-responses/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/replace-with-npm-modules/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Replace Services with npm Modules On this page * [Overview](#overview)\n* [HTTP Service](#http-service)\n* [node-fetch](#node-fetch)\n* [axios](#axios)\n* [Twilio Service](#twilio-service)\n* [AWS Service](#aws-service)\n* [S3](#s3)\n* [Kinesis](#kinesis)\n* [Lambda](#lambda)\n* [SES](#ses) ## Overview You should migrate deprecated third-party service integrations to use the corresponding official libraries available from [npm](https://www.npmjs.com/). The sections later on this page contain details and examples for each service. To migrate from a deprecated service: 1. [Add a library](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-add-external-dependencies) for the service from`npm` to your app.\n2. [Import the library](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-import-external-dependencies) in your functions. Replace any calls to the built-in service actions with calls to the corresponding methods in the imported library.\n3. If the service has webhooks, [convert them to HTTPS endpoints.](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) ## HTTP Service Replace HTTP requests sent through an [HTTP Service](https://mongodb.com/docs/atlas/app-services/services/http/#std-label-http-service)client with calls to an HTTP library like [node-fetch](https://www.npmjs.com/package/node-fetch) or [axios.](https://www.npmjs.com/package/axios) ### node-fetch `| npm i node-fetch@^2 |\n| ------------------- | ` ## Important Atlas App Services does not support v3 of `node-fetch`. Use v2 instead. Before ```javascript exports = async function() {   const http = context.services.get(\"myHttp\");   const response = await http.get({     url: \"https://www.example.com\",     headers: { \"Content-Type\": [ \"application/json\" ] }   })   return response.body.text() } \n``` After (node-fetch) ```javascript exports = async function() {   const fetch = require(\"node-fetch\"); // require calls must be in exports function   const response = await fetch(\"https://www.example.com\", {     method: \"GET\",     headers: { \"Content-Type\": \"application/json\" }   })   return response.text() } \n``` ### axios ```shell npm i axios \n``` Before ```javascript exports = async function() {   const http = context.services.get(\"myHttp\");   const response = await http.get({     url: \"https://www.example.com\",     headers: { \"Content-Type\": [ \"application/json\" ] }   })   return response.body.text() } \n``` After (axios) ```javascript exports = async function() {   const axios = require(\"axios\"); // require calls must be in exports function   const response = await axios.get(\"https://www.example.com\", {     headers: { \"Content-Type\": \"application/json\" }   })   return response.data } \n``` ## Twilio Service Replace calls through a [Twilio Service](https://mongodb.com/docs/atlas/app-services/services/twilio/#std-label-twilio-service) client with calls to the official [Twilio Node Helper Library.](https://www.twilio.com/docs/libraries/node) ```shell npm i twilio \n```\n\n Before ```javascript exports = async function() {   const twilio = context.services.get(\"myTwilio\");   twilio.send({     to: \"+15558675309\",     from: \"+15551234567\",     body: \"Hello from App Services!\",   }); } \n``` After ```javascript exports = async function() {   // Note: require calls must be in the exported function   const twilio = require('twilio')(     // Your Account SID and Auth Token from https://www.twilio.com/console     // Specify the same Twilio credentials as the service configuration     context.values.get(\"TwilioAccountSID\"),     context.values.get(\"TwilioAuthToken\"),   )   await twilio.messages.create({     to: \"+15558675309\",     from: \"+15551234567\",     body: \"Hello from App Services!\",   }) } \n``` ## AWS Service Replace calls through an [AWS Service](https://mongodb.com/docs/atlas/app-services/services/aws/#std-label-aws-service) client with calls to the official [AWS JavaScript SDK.](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/welcome) ```shell npm i aws-sdk \n``` ## Important App Services does not yet support version 3 of the AWS SDK. Use the version 2 SDK to replace the deprecated AWS Service in your functions. To authenticate AWS requests, store your Access Key ID and Secret Access Key as [values](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets). You can then access them within functions and pass them to the SDK. ### S3 Before ```javascript exports = async function() {   const s3 = context.services.get(\"myAWS\").s3(\"us-east-1\");   const putResult = await s3.PutObject({     Bucket: \"bucketName\",     Key: \"keyName\",     Body: EJSON.stringify({ hello: \"world\" }),   });   const getResult = await s3.GetObject({     Bucket: \"bucketName\",     Key: \"keyName\",   }); } \n``` After ```javascript exports = async function() {   const S3 = require('aws-sdk/clients/s3'); // require calls must be in exports function   const s3 = new S3({     accessKeyId: context.values.get(\"awsAccessKeyId\"),     secretAccessKey: context.values.get(\"awsSecretAccessKey\"),     region: \"us-east-1\",   });   // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#putObject-property   const putResult = await s3.putObject({     Bucket: \"bucketName\",     Key: \"keyName\",     Body: EJSON.stringify({ hello: \"world\" }),   }).promise();   // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#getObject-property   const getResult = await s3.getObject({     Bucket: \"bucketName\",     Key: \"keyName\",   }).promise(); } \n``` ### Kinesis Before ```javascript exports = async function() {   const kinesis = context.services.get(\"myAWS\").kinesis(\"us-east-1\");   const putResult = await kinesis.PutRecord({     Data: EJSON.stringify({ hello: \"world\" }),     StreamName: \"myStream\",     PartitionKey: \"myPartition\",   }); } \n``` After ```javascript exports = async function() {   const Kinesis = require('aws-sdk/clients/kinesis'); // require calls must be in exports function   const kinesis = new Kinesis({     accessKeyId: context.values.get(\"awsAccessKeyId\"),     secretAccessKey: context.values.get(\"awsSecretAccessKey\"),     region: \"us-east-1\",\n\n   // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Kinesis.html#putRecord-property   const putResult = await kinesis.putRecord({     Data: EJSON.stringify({ hello: \"world\" }),     StreamName: \"myStream\",     PartitionKey: \"myPartition\",   }).promise(); } \n``` ### Lambda Before ```javascript exports = async function() {   const lambda = context.services.get('MyAwsService').lambda(\"us-east-1\");   const invokeResult = await lambda.Invoke({     FunctionName: \"myLambdaFunction\",     Payload: EJSON.stringify({ hello: \"world\" }),   }); }; \n``` After ```javascript exports = async function() {   const Lambda = require('aws-sdk/clients/lambda'); // require calls must be in exports function   const lambda = new Lambda({     accessKeyId: context.values.get(\"awsAccessKeyId\"),     secretAccessKey: context.values.get(\"awsSecretAccessKey\"),     region: \"us-east-1\",   });   // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Lambda.html#invoke-property   const invokeResult = await lambda.invoke({     FunctionName: \"myLambdaFunction\",     Payload: EJSON.stringify({ hello: \"world\" }),   }).promise(); } \n``` ### SES Before ```javascript exports = async function() {   const ses = context.services.get('MyAwsService').ses(\"us-east-1\");   const sendResult = await ses.SendEmail({     Source: \"sender@example.com\",     Destination: { ToAddresses: [\"receiver@example.com\"] },     Message: {       Body: {         Html: {           Charset: \"UTF-8\",           Data: `This is a message from user ${context.user.id} sent through AWS SES`         }       },       Subject: {         Charset: \"UTF-8\",         Data: \"Test Email Please Ignore\"       },     },   }); }; \n``` After ```javascript exports = async function() {   const SES = require('aws-sdk/clients/ses'); // require calls must be in exports function   const ses = new SES({     accessKeyId: context.values.get(\"awsAccessKeyId\"),     secretAccessKey: context.values.get(\"awsSecretAccessKey\"),     region: \"us-east-1\",   });   // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/SES.html#sendEmail-property   const sendResult = await ses.sendEmail({     Source: \"sender@example.com\",     Destination: { ToAddresses: [\"receiver@example.com\"] },     Message: {       Body: {         Html: {           Charset: \"UTF-8\",           Data: `This is a message from user ${context.user.id} sent through AWS SES`         }       },       Subject: {         Charset: \"UTF-8\",         Data: \"Test Email Please Ignore\"       },     },   }).promise(); } \n``` ← [Third-Party Services \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/reference/services/ \"Previous Section\")[Convert Webhooks to HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/webhook-requests-and-responses/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Webhook Requests & Responses \\[Deprecated\\] On this page * [Overview](#overview)\n* [Request Validation Methods](#request-validation-methods)\n* [Payload Signature Verification](#payload-signature-verification)\n* [Secret as a Query Parameter](#secret-as-a-query-parameter)\n* [Webhook Response Object](#webhook-response-object) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview Depending on the service, [incoming webhooks](https://mongodb.com/docs/atlas/app-services/reference/services/#std-label-incoming-webhooks)offer several ways to validate requests and customize the response that Atlas App Services sends back to the external service. ## Request Validation Methods To validate that a webhook request is coming from a trusted source, some external services require that incoming requests incorporate a secret string in one of several prescribed manners. Other services, like the[HTTP service](https://mongodb.com/docs/atlas/app-services/services/http/), allow you to optionally require request validation. There are two type of Request Validation for webhooks:[Payload Signature Verification](#std-label-webhook-verify-payload-signature)and [Secret as a Query Parameter.](#std-label-webhook-secret-query-parameter) ## Note For maximum security, programmatically generate the `secret` string using a secure package such as the [Python secrets module](https://docs.python.org/3/library/secrets.html). Make sure that you do not publish the secret or include it in your version control system. ### Payload Signature Verification The Verify Payload Signature request validation option requires that incoming requests include a hexadecimal-encodedHMAC SHA-256 hash generated from the request body and `secret` string in the`X-Hook-Signature` header. ## Example Consider the following webhook request body and secret: `| const body = { \"message\":\"MESSAGE\" } |\n| ------------------------------------ |\n| const secret = 12345                 | ` The following [Atlas Function](https://mongodb.com/docs/atlas/app-services/functions/) generates the hash for this `body` and `secret`: ```javascript // Generate an HMAC request signature exports = function(secret, body) {   // secret = the secret validation string   // body = the webhook request body   return utils.crypto.hmac(EJSON.stringify(body), secret, \"sha256\", \"hex\"); } // Returns: \"828ee180512eaf8a6229eda7eea72323f68e9c0f0093b11a578b0544c5777862\" \n``` The hash value must be assigned to the `X-Hook-Signature` HTTP request header on every request: ``` X-Hook-Signature:sha256=<hex-encoded-hash> \n``` To test that the request was properly signed, we could run the following `curl` command: ```shell curl -X POST \\\n\n   -H \"X-Hook-Signature:sha256=828ee180512eaf8a6229eda7eea72323f68e9c0f0093b11a578b0544c5777862\" \\   -d '{\"message\":\"MESSAGE\"}' \\   <webhook URL> \n``` ### Secret as a Query Parameter The Require Secret as Query Param request validation option requires that incoming requests include the specified `secret` string as a [query parameter](https://en.wikipedia.org/wiki/Query%5Fstring)appended to the end of the URL. ## Example Consider a webhook configured to use a secret value of`12345`. All requests must be made to the webhook URL appended with the secret as a query parameter: ``` <webhook URL>?secret=12345 \n``` To test that requests to this URL are properly verified, we could run the following `curl` command: ``` curl -H \"Content-Type: application/json\" \\      -d '{ \"message\": \"HELLO\" }' \\      -X POST '<webhook URL>?secret=12345' \n``` ## Webhook Response Object App Services automatically passes a `response` object that represents the webhook's HTTP response as the second argument to webhook Function. The following table lists the available methods for modifying the`response` object:\n\n ← [Call a Service Action \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/call-a-service-action/ \"Previous Section\")[Configure Third-Party Services \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/configure/services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/snippets/github/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # GitHub Snippets \\[Deprecated\\] On this page * [Overview](#overview)\n* [Log All Commits in MongoDB](#log-all-commits-in-mongodb)\n* [Automatically Comment On New Pull Requests](#automatically-comment-on-new-pull-requests) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview The code snippets on this page cover demonstrate how you can respond to events in a GitHub repository through the [GitHub Service](https://mongodb.com/docs/atlas/app-services/services/github/). All of the snippets require a GitHub Service interface with rules that allow the service actions used in the snippet. If your app does not have a GitHub Service interface, [create one](https://mongodb.com/docs/atlas/app-services/services/configure/services/) before using these snippets. ## Log All Commits in MongoDB This [GitHub incoming webhook](https://mongodb.com/docs/atlas/app-services/services/github/#std-label-github-incoming-webhooks) function records all commits pushed to a repo in MongoDB based on a[PushEvent](https://developer.github.com/v3/activity/events/types/#pushevent) payload from GitHub.\n\n  `` ## Automatically Comment On New Pull Requests This [GitHub incoming webhook](https://mongodb.com/docs/atlas/app-services/services/github/#std-label-github-incoming-webhooks) function adds a comment to new pull requests that thanks users for submitting. The webhook accepts a [PullRequestEvent](https://developer.github.com/v3/activity/events/types/#pullrequestevent) payload from GitHub and uses an [HTTP service](https://mongodb.com/docs/atlas/app-services/services/http/) client to[create a comment](https://developer.github.com/v3/issues/comments/#create-a-comment)through the GitHub API. ```javascript exports = async function(pullRequest) {   // Get information about the PR from the PullRequestEvent   const { action, repository, pull_request: pr } = pullRequest;   // Only run if this is a new PR   if (action !== \"opened\") { return }   // Construct the GitHub API URL for this PR's Comments   const pr_comments_url = {     scheme: \"https\",     host: \"api.github.com\",     path: `/repos/${repository.owner.login}/${repository.name}/issues/${pr.number.$numberInt}/comments`,   };   // Specify GitHub API Basic Authentication Fields and Headers   const github_basic_auth = {     username: context.values.get(\"github-credentials\").username,     password: context.values.get(\"github-credentials\").password,   };   const headers = {     // OPTIONAL: Include this header if your security settings require a 2fa code     \"X-GitHub-OTP\": [\"<2fa Code>\"]   };   // Specify the comment text   const body = EJSON.stringify({     body: `Thank you for submitting a pull request, ${pr.user.login}!`   });   try {     // Get an HTTP service client. The service rules should allow you     // to send POST requests to `https://api.github.com`.     const http = context.services.get(\"<HTTP Service Name>\");     // Send the Request to GitHub     const request = { ...github_basic_auth, ...pr_comments_url, headers, body };     const result = await http.post(request);     // Check for a Successful Result     if (result.statusCode == 201) {       return \"Successfully commented on the pull request!\";     } else {       throw new Error(`Received a bad result status from GitHub: ${result.body.text()}`);     }   } catch (err) {     console.error(\"Something went wrong while posting the comment.\", err);   } }; \n``` ← [AWS S3 Snippets \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/snippets/s3/ \"Previous Section\")[Atlas App Services Changelog](https://mongodb.com/docs/atlas/app-services/release-notes/backend/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/functions/mongodb/api/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # MongoDB API Reference On this page * [mongodb.admin()](#mongodb.admin--)\n* [admin.getDBNames()](#admin.getdbnames--)\n* [mongodb.db()](#mongodb.db--)\n* [database.getCollectionNames()](#database.getcollectionnames--)\n* [database.collection()](#database.collection--)\n* [collection.find()](#collection.find--)\n* [collection.findOne()](#collection.findone--)\n* [collection.findOneAndUpdate()](#collection.findoneandupdate--)\n* [collection.findOneAndReplace()](#collection.findoneandreplace--)\n* [collection.findOneAndDelete()](#collection.findoneanddelete--)\n* [collection.insertOne()](#collection.insertone--)\n* [collection.insertMany()](#collection.insertmany--)\n* [collection.updateOne()](#collection.updateone--)\n* [collection.updateMany()](#collection.updatemany--)\n* [collection.deleteOne()](#collection.deleteone--)\n* [collection.deleteMany()](#collection.deletemany--)\n* [collection.aggregate()](#collection.aggregate--)\n* [collection.count()](#collection.count--)\n* [collection.distinct()](#collection.distinct--)\n* [collection.bulkWrite()](#collection.bulkwrite--) ## mongodb.admin() `mongodb.admin()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-mongodb.admin \"Permalink to this definition\") Gets a handle for the `admin` database in a linked MongoDB data source. You can use this to run MongoDB admin commands like[admin.getDBNames().](#mongodb-method-admin.getDBNames) `| const mongodb = context.services.get(\"mongodb-atlas\"); |\n| ------------------------------------------------------ |\n| const admin = mongodb.admin();                         | ` ### Parameters ``` admin(): AdminDatabase \n``` ### Return Value The `mongodb.admin()` method returns an `AdminDatabase` object. The object contains helper methods that wrap a subset of MongoDB database commands. See [admin.getDBNames().](#mongodb-method-admin.getDBNames) ## admin.getDBNames() `admin.getDBNames()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-admin.getDBNames \"Permalink to this definition\") Returns a list of database names in a MongoDB data source. ## Important ### System Functions Only This method is only available in [system functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions). You cannot call this method from a function that runs in the context of an application user. ```javascript const mongodb = context.services.get(\"mongodb-atlas\"); const admin = mongodb.admin(); const dbNames = admin.getDBNames(); \n``` ### Parameters ``` getDBNames(): string[] \n``` ### Return Value The `admin.getDBNames()` method returns an array of strings where each element is the name of a database in the data source. ## mongodb.db() `mongodb.db()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-mongodb.db \"Permalink to this definition\") Gets a handle for a database in a linked MongoDB data source. ```javascript const mongodb = context.services.get(\"mongodb-atlas\"); const db = mongodb.db(\"myDB\"); \n``` ### Parameters ``` db(name: string): Database \n```\n\n ### Return Value The `mongodb.db()` method returns a `Database` object that allows you to access collections in the specified database. See [database.collection()](#mongodb-method-database.collection) ## database.getCollectionNames() `database.getCollectionNames()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-database.getCollectionNames \"Permalink to this definition\") Returns a list of collection names in the database. ## Important ### System Functions Only This method is only available in [system functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions). You cannot call this method from a function that runs in the context of an application user. ```javascript const mongodb = context.services.get(\"mongodb-atlas\"); const db = mongodb.db(\"myDB\"); const collectionNames = db.getCollectionNames(); \n``` ### Parameters ``` getCollectionNames(): string[] \n``` ### Return Value The `database.getCollectionNames()` method returns an array of strings where each element is the name of a collection in the database. ## database.collection() `database.collection()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-database.collection \"Permalink to this definition\") Gets a handle for a collection in a linked MongoDB data source from a[database](#mongodb-method-mongodb.db) handle. ```javascript const mongodb = context.services.get(\"mongodb-atlas\"); const db = mongodb.db(\"myDB\"); const collection = db.collection(\"myCollection\"); \n``` ### Parameters ``` collection(name: string): Collection \n``` | Parameter | Type   | Description                 |\n| --------- | ------ | --------------------------- |\n| name      | string | The name of the collection. | ### Return Value The `database.collection()` method returns a collection object that allows you to query the specified collection. ## collection.find() `collection.find()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.find \"Permalink to this definition\") Finds all documents in a collection or view that match the provided query filters. Returns a cursor object that allows you to access matching documents. ```javascript const query = { \"reviews.0\": { \"$exists\": true } }; const projection = { \"_id\": 0 }; return itemsCollection.find(query, projection)   .sort({ name: 1 })   .toArray()   .then(items => {     console.log(`Successfully found ${items.length} documents.`)     items.forEach(console.log)     return items   })   .catch(err => console.error(`Failed to find documents: ${err}`)) \n``` ### Parameters ``` find(    query?: object,    projection?: object,    options?: object ): Cursor \n```\n\n ### Return Value The `collection.find()` method returns a cursor object that points to any documents that match the specified query. You can manipulate and access documents in the query result set with the following cursor methods:\n\n ## Note You cannot return a cursor from a function. Instead, evaluate the cursor using `cursor.next()` or `cursor.toArray()` and return the result. ## collection.findOne() `collection.findOne()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.findOne \"Permalink to this definition\") Finds a single document from a collection or view. If multiple documents match the query, this returns the first matching document according to the query's sort order or natural order. ```javascript const query = { \"quantity\": { \"$gte\": 25 } }; const projection = {  \"title\": 1,  \"quantity\": 1, } return itemsCollection.findOne(query, projection)   .then(result => {     if(result) {       console.log(`Successfully found document: ${result}.`);     } else {       console.log(\"No document matches the provided query.\");     }     return result;   })   .catch(err => console.error(`Failed to find document: ${err}`)); \n``` ### Parameters ``` findOne(    query?: object,    projection?: object,    options?: object ): Promise<object | null> \n```\n\n ### Return Value The `collection.findOne()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to the first document in the collection that matches the query. If no documents match the specified query, the promise resolves to `null`. ``` Promise<object | null> \n``` ## collection.findOneAndUpdate() `collection.findOneAndUpdate()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.findOneAndUpdate \"Permalink to this definition\") Updates a single document in a collection or view and returns the document in either its pre-update or post-update form. Unlike [collection.updateOne()](#mongodb-method-collection.updateOne), this action allows you to atomically find, modify, and return a document with the same command. This avoids the risk of other update operations changing the document between separate [find](#std-label-mongodb-collection-find) and [update](#std-label-mongodb-collection-updateOne) operations. ```javascript // Find the document that describes \"lego\" const query = { \"name\": \"lego\" }; // Set some fields in that document const update = {   \"$set\": {     \"name\": \"blocks\",     \"price\": 20.99,     \"category\": \"toys\"   } }; // Return the updated document instead of the original document const options = { returnNewDocument: true }; return itemsCollection.findOneAndUpdate(query, update, options)   .then(updatedDocument => {     if(updatedDocument) {       console.log(`Successfully updated document: ${updatedDocument}.`)     } else {       console.log(\"No document matches the provided query.\")     }     return updatedDocument   })   .catch(err => console.error(`Failed to find and update document: ${err}`)) \n``` ### Parameters ``` findOneAndUpdate(    query: object,    update: object,    options?: object ): Promise<object | null> \n```\n\n ### Return Value The `collection.findOneAndUpdate()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a single document that the query overwrote. If no documents match the specified query, the promise resolves to `null`. ``` Promise<object | null> \n``` ## Note You can specify whether to return the pre-replacement or post-replacement version of the document by setting the value of`options.returnNewDocument`. By default, `returnNewDocument` is`false`, which indicates that the promise should resolve to the_pre-update_ version of the document. ## collection.findOneAndReplace() `collection.findOneAndReplace()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.findOneAndReplace \"Permalink to this definition\") Overwrites a single document in a collection or view and returns the document in either its pre-replacement or post-replacement form. Unlike [collection.updateOne()](#mongodb-method-collection.updateOne), this action allows you to atomically find, modify, and return a document with the same command. This avoids the risk of other update operations changing the document between separate [find](#std-label-mongodb-collection-find) and [update](#std-label-mongodb-collection-updateOne) operations. ```javascript // Find the document that describes \"lego\" const query = { \"name\": \"lego\" }; // Replace it with a new document const replacement = {     \"name\": \"blocks\",     \"price\": 20.99,     \"category\": \"toys\" }; // Return the original document as it was before being replaced const options = { \"returnNewDocument\": false }; return itemsCollection.findOneAndReplace(query, replacement, options)   .then(replacedDocument => {     if(replacedDocument) {       console.log(`Successfully replaced the following document: ${replacedDocument}.`)     } else {       console.log(\"No document matches the provided query.\")     }     return updatedDocument   })   .catch(err => console.error(`Failed to find and replace document: ${err}`)) \n``` ### Parameters ``` findOneAndReplace(    query: object,    replacement: object,    options?: object ): Promise<object | null> \n```\n\n ### Return Value The `collection.findOneAndReplace()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a single document that the query overwrote. If no documents match the specified query, the promise resolves to `null`. ``` Promise<object | null> \n``` ## Note You can specify whether to return the pre-replacement or post-replacement version of the document by setting the value of`options.returnNewDocument`. By default, `returnNewDocument` is`false`, which indicates that the promise should resolve to the_pre-update_ version of the document. ## collection.findOneAndDelete() `collection.findOneAndDelete()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.findOneAndDelete \"Permalink to this definition\") Removes a single document from a collection and returns the deleted document as it was immediately before it was deleted. Unlike [collection.updateOne()](#mongodb-method-collection.updateOne), this action allows you to atomically find, modify, and return a document with the same command. This avoids the risk of other update operations changing the document between separate [find](#std-label-mongodb-collection-find) and [update](#std-label-mongodb-collection-updateOne) operations. ```javascript // Find the first document that has a quantity greater than 25 const query = { \"quantity\": { \"$gte\": 25 } }; // Sort the documents in order of descending quantity before // deleting the first one. const options = {   \"sort\": { \"quantity\": -1 } } return itemsCollection.findOneAndDelete(query, options)   .then(deletedDocument => {     if(deletedDocument) {       console.log(`Successfully deleted document that had the form: ${deletedDocument}.`)     } else {       console.log(\"No document matches the provided query.\")     }     return deletedDocument   })   .catch(err => console.error(`Failed to find and delete document: ${err}`)) \n``` ### Parameters ``` findOneAndDelete(    query: object,    options?: object ): Promise<object | null> \n```\n\n ### Return Value The `collection.findOneAndDelete()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a single document that the query deleted. If no documents match the specified query, the promise resolves to `null`. ``` Promise<object | null> \n``` ## collection.insertOne() `collection.insertOne()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.insertOne \"Permalink to this definition\") Inserts a single document into a collection and returns the `_id` of the inserted document. ```javascript const newItem = {   \"name\": \"Plastic Bricks\",   \"quantity\": 10,   \"category\": \"toys\",   \"reviews\": [{ \"username\": \"legolover\", \"comment\": \"These are awesome!\" }] }; itemsCollection.insertOne(newItem)   .then(result => console.log(`Successfully inserted item with _id: ${result.insertedId}`))   .catch(err => console.error(`Failed to insert item: ${err}`)) \n``` ### Parameters ``` insertOne(document: object): Promise<object> \n``` | Parameter | Type   | Description                               |\n| --------- | ------ | ----------------------------------------- |\n| document  | object | A document to insert into the collection. | ### Return Value The `collection.insertOne()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a document that describes the insert operation. ``` Promise<object> \n``` | Value             | Type   | Description                                                                       |\n| ----------------- | ------ | --------------------------------------------------------------------------------- |\n| result.insertedId | string | The \\_id value of the document that the insert operation added to the collection. | ## collection.insertMany() `collection.insertMany()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.insertMany \"Permalink to this definition\") Inserts one or more documents into a collection and returns a list that contains the `_id` value for each inserted document. ```javascript const doc1 = { \"name\": \"basketball\", \"category\": \"sports\", \"quantity\": 20, \"reviews\": [] }; const doc2 = { \"name\": \"football\",   \"category\": \"sports\", \"quantity\": 30, \"reviews\": [] }; return itemsCollection.insertMany([doc1, doc2])   .then(result => {     console.log(`Successfully inserted ${result.insertedIds.length} items!`);     return result   })   .catch(err => console.error(`Failed to insert documents: ${err}`)) \n``` ### Parameters ``` insertMany(   document: object,   options?:  { ordered?: boolean }, ): Promise<object> \n```\n\n ### Return Value The `collection.insertMany()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a document that describes the insert operation. ``` Promise<object> \n``` | Value                               | Type   | Description                                                                                                                                                  |\n| ----------------------------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| result.insertedIds: Array<ObjectID> | string | An array that contains the \\_id values for all documents that the insert operation added to the collection in the order that they were passed to the method. | ## collection.updateOne() `collection.updateOne()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.updateOne \"Permalink to this definition\") Updates a single document in a collection and returns metadata about the operation. ```javascript const query = { \"name\": \"football\" }; const update = {   \"$push\": {     \"reviews\": {       \"username\": \"tombradyfan\",       \"comment\": \"I love football!!!\"     }   } }; const options = { \"upsert\": false }; itemsCollection.updateOne(query, update, options)   .then(result => {     const { matchedCount, modifiedCount } = result;     if(matchedCount && modifiedCount) {       console.log(`Successfully added a new review.`)     }   })   .catch(err => console.error(`Failed to add review: ${err}`)) \n``` ### Parameters ``` updateOne(    query: object,    update: object,    options?: object ): Promise<object> \n```\n\n ### Return Value The `collection.updateOne()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a document that describes the update operation. ``` Promise<object> \n``` | Value                | Type   | Description                                                                                                                                                                     |\n| -------------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| result.matchedCount  | number | The number of documents in the collection that match the provided query.                                                                                                        |\n| result.modifiedCount | number | The number of documents in the collection that were modified by the update operation.                                                                                           |\n| result.upsertedId    | string | The \\_id value of the document inserted by an upsert operation. This value is only present when the upsert option is enabled and the update query does not match any documents. | ## collection.updateMany() `collection.updateMany()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.updateMany \"Permalink to this definition\") Updates one or more documents in a collection and returns metadata about the operation. ```javascript const query = {}; const update = { \"$mul\": { \"quantity\": 10 } }; const options = { \"upsert\": false } return itemsCollection.updateMany(query, update, options)   .then(result => {     const { matchedCount, modifiedCount } = result;     console.log(`Successfully matched ${matchedCount} and modified ${modifiedCount} items.`)     return result   })   .catch(err => console.error(`Failed to update items: ${err}`)) \n``` ### Parameters ``` updateMany(    query: object,    update: object,    options?: object ): Promise<object> \n```\n\n ### Return Value The `collection.updateMany()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a document that describes the update operation. ``` Promise<object> \n``` | Value                | Type   | Description                                                                                                                                                                     |\n| -------------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| result.matchedCount  | number | The number of documents in the collection that match the provided query.                                                                                                        |\n| result.modifiedCount | number | The number of documents in the collection that were modified by the update operation.                                                                                           |\n| result.upsertedId    | string | The \\_id value of the document inserted by an upsert operation. This value is only present when the upsert option is enabled and the update query does not match any documents. | ## collection.deleteOne() `collection.deleteOne()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.deleteOne \"Permalink to this definition\") Removes a single document from a collection. ```javascript const query = { \"name\": \"lego\" }; itemsCollection.deleteOne(query)   .then(result => console.log(`Deleted ${result.deletedCount} item.`))   .catch(err => console.error(`Delete failed with error: ${err}`)) \n``` ### Parameters ``` deleteOne(    query: object,    options?: object ): Promise<object> \n```\n\n ### Return Value The `collection.deleteOne()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a document that describes the delete operation. ``` Promise<object> \n``` | Value               | Type   | Description                                                                          |\n| ------------------- | ------ | ------------------------------------------------------------------------------------ |\n| result.deletedCount | number | The number of documents in the collection that were deleted by the delete operation. | ## collection.deleteMany() `collection.deleteMany()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.deleteMany \"Permalink to this definition\") Remove one or more documents from a collection. ```javascript const query = { \"reviews\": { \"$size\": 0 } }; itemsCollection.deleteMany(query)   .then(result => console.log(`Deleted ${result.deletedCount} item(s).`))   .catch(err => console.error(`Delete failed with error: ${err}`)) \n``` ### Parameters ``` deleteMany(    query: object,    options?: object ): Promise<object> \n```\n\n ### Return Value The `collection.deleteMany()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to a document that describes the delete operation. ``` Promise<object> \n``` | Value               | Type   | Description                                                                          |\n| ------------------- | ------ | ------------------------------------------------------------------------------------ |\n| result.deletedCount | number | The number of documents in the collection that were deleted by the delete operation. | ## collection.aggregate() `collection.aggregate()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.aggregate \"Permalink to this definition\") Executes an [aggregation](https://www.mongodb.com/docs/manual/aggregation/) pipeline and returns a cursor that allows you to access the pipeline's output documents. ```javascript const pipeline = [   { \"$group\": {       \"_id\": \"$customerId\",       \"numPurchases\": { \"$sum\": 1 },       \"numItemsPurchased\": { \"$sum\": { \"$size\": \"$items\" } }   } },   { \"$addFields\": {       \"averageNumItemsPurchased\": {         \"$divide\": [\"$numItemsPurchased\", \"$numPurchases\"]       }   } } ] return purchasesCollection.aggregate(pipeline).toArray()   .then(customers => {     console.log(`Successfully grouped purchases for ${customers.length} customers.`)     for(const customer of customers) {       console.log(`customer: ${customer._id}`)       console.log(`num purchases: ${customer.numPurchases}`)       console.log(`total items purchased: ${customer.numItemsPurchased}`)       console.log(`average items per purchase: ${customer.averageNumItemsPurchased}`)     }     return customers   })   .catch(err => console.error(`Failed to group purchases by customer: ${err}`)) \n``` ### Parameters ``` aggregate(    pipeline: object[],    options?: object ): Cursor \n```\n\n ### Return Value The `collection.aggregate()` method returns a cursor object that points to any documents output from the final stage of the aggregation pipeline. You can manipulate and access documents in the aggregation result set with the following methods: | Method              | Description                                                                                                                                                                                                                                                                                                                                            |\n| ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| cursor.next()       | Iterates the cursor and returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to the next document in the cursor. If the cursor is exhausted, the promise resolves to undefined.Examplecollection.aggregate(pipeline).next()  .then(doc \\=> console.log(\"next document\", doc)) |\n| cursor.toArray()    | Iterates the cursor to exhaustion and returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to an array that contains all of the iterated documents.Examplecollection.aggregate(pipeline).toArray()  .then(docs \\=> console.log(\"all documents\", docs))                        |\n| cursor.skip(amount) | Specifies a number of matching documents to omit from the aggregation result set. MongoDB omits documents from the result set in sort order until it has skipped the specified number.NoteYou cannot call this method after retrieving one or more documents using cursor.next() or cursor.toArray().                                                  | ## Note You cannot return a cursor from a function. Instead, evaluate the cursor using `cursor.next()` or `cursor.toArray()` and return the result. ## collection.count() `collection.count()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.count \"Permalink to this definition\") Returns the number of documents in a collection or view that match a given query. ```javascript return itemsCollection.count({ \"reviews.0\": { \"$exists\": true } })   .then(numDocs => console.log(`${numDocs} items have a review.`))   .catch(err => console.error(\"Failed to count documents: \", err)) \n``` ### Parameters ``` count(    query?: object,    options?: object ): Promise<number> \n```\n\n ### Return Value The `collection.count()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to the integer number of documents in the collection that match the query. ```javascript Promise<number> \n``` | Value                          | Description                                                              |\n| ------------------------------ | ------------------------------------------------------------------------ |\n| Count ResultnumDocs: <integer> | The number of documents in the collection that match the provided query. | ## collection.distinct() `collection.distinct()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.distinct \"Permalink to this definition\") Finds documents that match a given query filter and returns a list of distinct values for a specific field across all matched documents. ```javascript 1 const taskCollection = context.services.get(\"mongodb-atlas\") 2   .db(\"tracker\").collection(\"tasks\"); 3 4 return taskCollection.distinct(\"status\", {}) 5   .then(results => { 6       console.log(JSON.stringify(results)); 7       console.log(results.length); 8   }) 9   .catch(err => console.error(err)) \n``` ### Parameters ``` distinct(    field: string,    query: object,    options?: object ): Promise<any[]> \n```\n\n ### Return Value The `collection.distinct()` method returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to an array of distinct values. ``` Promise<any[]> \n``` ## collection.bulkWrite() `collection.bulkWrite()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-collection.bulkWrite \"Permalink to this definition\") Runs multiple insert, update, and delete operations on a collection with a single call. Within the `bulkWrite()` function, you can specify one or more of the following write operations: * insertOne\n* updateOne\n* updateMany\n* deleteOne\n* deleteMany\n* replaceOne ## Note A bulk write can only operate on a single collection. ```javascript exports = async function(arg){     const doc1 = { \"name\": \"velvet elvis\", \"quantity\": 20, \"reviews\": [] };     const doc2 = { \"name\": \"mock turtleneck\",  \"quantity\": 30, \"reviews\": [] };     var collection = context.services.get(\"mongodb-atlas\")         .db(\"store\")         .collection(\"purchases\");     return await collection.bulkWrite(         [{ insertOne: doc1}, { insertOne: doc2}],         {ordered:true}); }; \n``` ### Parameters ``` bulkWrite(   operations: object[],   options?: object ): Promise<null> \n```\n\n ### Return Value The `collection.bulkWrite()` function returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) that resolves to`null`. ``` Promise<null> \n``` ← [Aggregate Data in MongoDB Atlas - Functions](https://mongodb.com/docs/atlas/app-services/functions/mongodb/aggregate/ \"Previous Section\")[Context](https://mongodb.com/docs/atlas/app-services/functions/context/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/snippets/s3/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # AWS S3 Snippets \\[Deprecated\\] On this page * [Overview](#overview)\n* [Upload an Image to S3](#upload-an-image-to-s3)\n* [Get an Image From S3](#get-an-image-from-s3) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview The code snippets on this page demonstrate how to work with Amazon Simple Storage Service through the [AWS Service](https://mongodb.com/docs/atlas/app-services/services/aws/). All of the snippets require an AWS Service interface with a configuration of AWS Service rules that allow the service actions used in the snippet. You can run these snippets yourself by copying this code into an [Atlas Function.](https://mongodb.com/docs/atlas/app-services/functions/) If your app does not have an AWS Service interface, [create one](https://mongodb.com/docs/atlas/app-services/services/configure/services/) before using these snippets. ## Upload an Image to S3 This [Atlas Function](https://mongodb.com/docs/atlas/app-services/functions/) uploads a Base64 encoded image to AWS S3 using the [PutObject](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#S3.PutObject) action.\n\n ` ### Function Parameters\n\n ## Get an Image From S3 This [Atlas Function](https://mongodb.com/docs/atlas/app-services/functions/) retrieves an object from AWS S3 using the [GetObject](https://docs.aws.amazon.com/sdk-for-go/api/service/s3/#S3.GetObject) action. ```javascript exports = function(bucket, fileName) {   // Instantiate an S3 service client   const s3Service = context.services.get('myS3Service').s3('us-east-1');   // Get the object from S3   return s3Service.GetObject({     'Bucket': bucket,     'Key': fileName,   })   .then(getObjectOutput => {     console.log(getObjectOutput);     // {     //   ETag: <string>, // The object's S3 entity tag     //   Body: <binary>, // The object data     //   ContentType: <string>, // The object's MIME type     // }     const base64EncodedImage = getObjectOutput.Body     return base64EncodedImage   })   .catch(console.error); }; \n``` ### Function Parameters | Parameter | Type   | Description                                               |\n| --------- | ------ | --------------------------------------------------------- |\n| bucket    | string | The name of the S3 bucket that will hold the image.       |\n| fileName  | string | The name of the image file, including its file extension. | ← [GitHub Service \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/github/ \"Previous Section\")[GitHub Snippets \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/snippets/github/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/twilio/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Twilio Service \\[Deprecated\\] On this page * [Overview](#overview)\n* [Configuration Parameters](#configuration-parameters)\n* [Service Actions](#service-actions)\n* [Incoming Webhooks](#incoming-webhooks)\n* [Configuration](#configuration)\n* [Request Payload](#request-payload)\n* [Example Webhook Function](#example-webhook-function)\n* [Configure Twilio](#configure-twilio)\n* [Create a Messaging Service](#create-a-messaging-service)\n* [Add a Webhook to a Twilio Project](#add-a-webhook-to-a-twilio-project) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview Twilio provides messaging, voice, and chat services for web and mobile apps. The Atlas App Services Twilio service supports integrating Twilio's_Programmable SMS_ service into your application. * To send an outbound text message, use the [send()](https://mongodb.com/docs/atlas/app-services/services/twilio-actions/send/) action.\n* To handle and optionally respond to incoming text messages,[create an incoming webhook](https://mongodb.com/docs/atlas/app-services/services/configure/service-webhooks/) and[add it to a Twilio messaging service](#std-label-configure-twilio-add-webhook). See the [incoming webhooks](#std-label-twilio-webhooks) section on this page for an example. ## Note To use Twilio with App Services, you must have a Twilio Phone Number registered to a messaging service associated with your Twilio account. You can create a new number from the Numberspage of the Twilio dashboard, or by following Twilio's[Programmable SMS Quickstart](https://www.twilio.com/docs/quickstart?filter-product=sms) guide. ## Configuration Parameters You will need to provide values for the following parameters when you[create a Twilio service interface:](https://mongodb.com/docs/atlas/app-services/services/configure/services/)\n\n ## Service Actions The Twilio service in App Services provides the following actions which are available in [functions](https://mongodb.com/docs/atlas/app-services/functions/) and in the SDKs: For instructions on using a service action, see [Call a Service Action.](https://mongodb.com/docs/atlas/app-services/services/call-a-service-action/) | Action                                                                                             | Description                                       |\n| -------------------------------------------------------------------------------------------------- | ------------------------------------------------- |\n| [twilio.send()](https://mongodb.com/docs/atlas/app-services/services/twilio-actions/send/#mongodb-method-twilio.send) | Sends a text message to a specified phone number. | ## Incoming Webhooks ## Note ### Convert Twilio Webhooks to Endpoints Twilio Service webhoooks are deprecated in favor of custom HTTPS endpoints. To learn how to migrate your existing Twilio webhooks to endpoints, see [Convert Webhooks to HTTPS Endpoints.](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-migrate-twilio-webhooks-to-endpoints) Incoming webhooks for the Twilio service enable your App to handle incoming text messages. Once you've created an incoming webhook, you can add it to a Twilio messaging service to handle incoming messages for that service. ### Configuration\n\n ### Request Payload App Services automatically passes a `payload` document as the first argument to incoming webhook functions. In a Twilio Service incoming webhook the`payload` object represents an incoming SMS message and has the following form: `| {                                    |\n| ------------------------------------ |\n| \"From\": \"<Sender's Phone Number>\",   |\n| \"To\":   \"<Receiver's Phone Number>\", |\n| \"Body\": \"<SMS Body>\"                 |\n| }                                    | ` | Field | Description                                                                                                                                                                                         |\n| ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| From  | A string that contains the [E.164-formatted](https://www.twilio.com/docs/glossary/what-e164) phone number that sent the incoming text message.                                                      |\n| To    | A string that contains the [E.164-formatted](https://www.twilio.com/docs/glossary/what-e164) phone number associated with your Twilio messaging service that the incoming text message was sent to. |\n| Body  | A string that contains the content of the incoming text message.                                                                                                                                    | ## Example A text message sent from the phone number `(555)867-5309` to the Twilio phone number `(805)716-6646` with the message `\"Hello! How are you?\"` would be represented by the following `payload`document: ``` {   \"From\": \"+15558675309\",   \"To\": \"+18057166646\",   \"Body\": \"Hello! How are you?\" } \n``` ### Example Webhook Function The following webhook function stores text messages sent to a Twilio phone number in a MongoDB collection and sends a text message response to the phone number that sent the text. ```javascript exports = async function(payload, response) {   // const { To, From, Body } = payload;   const mongodb = context.services.get(\"mongodb-atlas\");   const texts = mongodb.db(\"demo\").collection(\"texts\");   try {     // Save the text message body, to number, and from number     const { insertedId } = await texts.insertOne(payload);     // Send the user a confirmation text message     response.setBody(`Saved your text message with _id: ${insertedId}`);   } catch (error) {\n\n     response.setBody(`Failed to save your text message: ${error}`);   } } \n``` ## Configure Twilio ### Create a Messaging Service 1. Log in to [Twilio](https://www.twilio.com/login).\n2. Click Programmable SMS in the left navigation menu of your Twilio project.\n3. Click SMS > Messaging Services.\n4. Click Create new Messaging Service.\n5. Enter a Friendly Name and Use Case\n6. Click Create ### Add a Webhook to a Twilio Project 1. Click Programmable SMS in the left navigation menu of your Twilio project.\n2. Click SMS > Messaging Services.\n3. Click the messaging service that you want to use.\n4. On the messaging service configuration page, check thePROCESS INBOUND MESSAGES box.\n5. Enter the incoming webhook URL in the Request URL box.\n6. Click Save. Your App is now integrated with Twilio's SMS messaging service. Send a message to your Twilio phone number to invoke the incoming webhook for your App. ← [http.head()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.head/ \"Previous Section\")[twilio.send()](https://mongodb.com/docs/atlas/app-services/services/twilio-actions/send/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/twilio-actions/send/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # twilio.send() On this page * [Definition](#definition)\n* [Usage](#usage)\n* [Example](#example)\n* [Parameters](#parameters)\n* [Return Value](#return-value)\n* [Rule Templates](#rule-templates)\n* [Users Can Send Only Messages from a Specific Phone Number](#users-can-send-only-messages-from-a-specific-phone-number)\n* [Users Can Only Send Messages to a Limited Set of Phone Numbers](#users-can-only-send-messages-to-a-limited-set-of-phone-numbers)\n* [Users Can Only Send Messages to Themselves](#users-can-only-send-messages-to-themselves) ## Definition `twilio.send()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-twilio.send \"Permalink to this definition\") Sends an SMS text message with Twilio. ## Usage ## Note To send or receive messages via the [Twilio API for WhatsApp](https://www.twilio.com/whatsapp), prepend the `to` or `from` numbers with `whatsapp:`. `| to: \"whatsapp:+15558675309\",   |\n| ------------------------------ |\n| from: \"whatsapp:+15551234567\", | ` ### Example ### Parameters ### Return Value The `twilio.send()` action does not return a value. ## Rule Templates ### Users Can Send Only Messages from a Specific Phone Number ``` {   \"%%args.from\": \"+15551234\" } \n``` ### Users Can Only Send Messages to a Limited Set of Phone Numbers ``` {   \"%%args.to\": {     \"$in\": [       \"+15551234\",       \"+18675309\"     ]   } } \n``` ### Users Can Only Send Messages to Themselves ``` {   \"%%true\": {     \"%function\": {       \"name\": \"isCurrentUsersPhoneNumber\",       \"arguments\": [         \"%%args.to\"       ]     }   } } \n``` ## Note This template calls an example function named`isCurrentUsersPhoneNumber` that does the following: 1. Accepts the phone number provided in the `to` argument\n2. Queries MongoDB for a user document that matches the current user's id\n3. Compares the provided phone number to the number listed in the user document\n4. Returns the boolean result of the comparison ```javascript exports = function(toPhone) {   const mdb = context.services.get('mongodb-atlas');   const users = mdb.db('demo').collection('users');   const user = users.findOne({ _id: context.user.id });   return user.phoneNumber === toPhone; } \n``` ← [Twilio Service \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/twilio/ \"Previous Section\")[AWS Service \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/aws/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/configure/service-rules/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure Service Rules \\[Deprecated\\] On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Create a New Rule](#create-a-new-rule)\n* [Configure the Rule](#configure-the-rule)\n* [Save the Configured Rule](#save-the-configured-rule)\n* [Pull Your App's Latest Configuration Files](#pull-your-app-s-latest-configuration-files)\n* [Create a Service Rule Directory](#create-a-service-rule-directory)\n* [Create and Configure a New Service Rule](#create-and-configure-a-new-service-rule)\n* [Deploy the Rule](#deploy-the-rule) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview In order to call a service action, you must first define a [service rule](https://mongodb.com/docs/atlas/app-services/reference/services/#std-label-service-rules) that enables and configures the capabilities of the action. You can define service rules from the Atlas App Services UI or by[importing](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-cli) a service configuration directory that contains a rule configuration file. Select the tab below that corresponds to the method you want to use. ## Procedure ← [Configure Service Webhooks \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/configure/service-webhooks/ \"Previous Section\")[HTTP Service \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/http/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/http-actions/http.put/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # http.put() On this page * [Definition](#definition)\n* [Usage](#usage)\n* [Example](#example)\n* [Parameters](#parameters)\n* [Return Value](#return-value)\n* [Rule Templates](#rule-templates)\n* [Users Can Only Send Requests to a Specific Host](#users-can-only-send-requests-to-a-specific-host)\n* [Requests URLs Must Include a Specific Query Parameter](#requests-urls-must-include-a-specific-query-parameter)\n* [Request Bodies Must Include a Specific Field](#request-bodies-must-include-a-specific-field)\n* [Request Bodies Must Include Fields with Specific Values](#request-bodies-must-include-fields-with-specific-values) ## Definition `http.put()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-http.put \"Permalink to this definition\") Sends an [HTTP PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT) request to the specified URL using the Atlas App Services [HTTP Service.](https://mongodb.com/docs/atlas/app-services/services/http/) ## Usage ### Example ### Parameters #### Alternative URL Parameters If you need to specify the individual components of the request's target URL, omit the `url` field and specify the components as root-level fields. The following URL component fields are available: `| <scheme>://<host>/<path>?<query>#<fragment> |\n| ------------------------------------------- | ` ``` {    \"scheme\": <string>,    \"host\": <string>,    \"path\": <string>,    \"query\": <document>,    \"fragment\": <string>,    \"username\": <string>,    \"password\": <string> } \n```\n\n ### Return Value The `http.put()` action returns a promise that resolves to a document with the following form: ```javascript {    \"status\": <string>,    \"statusCode\": <integer>,    \"contentLength\": <integer>,    \"headers\": <document>,    \"cookies\": <array>,    \"body\": <binary> } \n```\n\n #### Request Authentication You can authenticate an outbound HTTP request using one of the standard[HTTP authentication schemes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication). Atlas App Services supports the following authentication schemes: ##### Basic Authentication HTTP [basic authentication](https://en.wikipedia.org/wiki/Basic%5Faccess%5Fauthentication)requires that incoming requests include a valid username and password for the requested service. You can specify the user credentials in the`username` and `password` fields of the request document, directly in a `url` string, or in an [Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) HTTP header. ## Example The following examples demonstrate three equivalent ways to authenticate an HTTP service request using basic authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. You would pass one of these objects as an argument to the given HTTP method. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\" } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\" } \n``` Include an Authorization Header ```javascript {   \"url\": \"https://www.example.com\",   \"headers\": {     \"Authorization\": [       `Basic ${BSON.Binary.fromText(\"MyUser:Mypassw0rd\").toBase64()}`     ]   } } \n``` ##### Digest Authentication HTTP [digest authentication](https://en.wikipedia.org/wiki/Digest%5Faccess%5Fauthentication)requires that incoming requests include an authorization key based on a random [nonce](https://en.wikipedia.org/wiki/Cryptographic%5Fnonce) value returned from the server. App Services can automatically construct the key and authorize requests given a valid username and password. To configure a request to use digest authentication, set the`digestAuth` field to `true` and specify the user credentials in the`username` and `password` fields of the request document or directly in a `url` string. ## Example The following examples demonstrate two equivalent ways to authenticate an HTTP service request using digest authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\",   \"digestAuth\": true } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\",   \"digestAuth\": true } \n``` ## Rule Templates ### Users Can Only Send Requests to a Specific Host ``` {   \"%%args.url.host\": \"example.com\" } \n``` ### Requests URLs Must Include a Specific Query Parameter ``` {   \"%%args.url.query.someParameter\": \"importantValue\" } \n``` ### Request Bodies Must Include a Specific Field ``` {   \"body.name\": { \"%exists\": 1 } } \n``` ### Request Bodies Must Include Fields with Specific Values ``` {   \"body.city\": \"New York City\" } \n``` ← [http.post()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.post/ \"Previous Section\")[http.patch()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.patch/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/http-actions/http.get/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # http.get() On this page * [Definition](#definition)\n* [Usage](#usage)\n* [Example](#example)\n* [Parameters](#parameters)\n* [Return Value](#return-value)\n* [Rule Templates](#rule-templates)\n* [Users Can Only Send Requests to a Specific Host](#users-can-only-send-requests-to-a-specific-host)\n* [Requests URLs Must Include a Specific Query Parameter](#requests-urls-must-include-a-specific-query-parameter)\n* [Requests Must Be To A Specific Path](#requests-must-be-to-a-specific-path) ## Definition `http.get()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-http.get \"Permalink to this definition\") Sends an [HTTP GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET) request to the specified URL using the Atlas App Services [HTTP Service.](https://mongodb.com/docs/atlas/app-services/services/http/) ## Usage ### Example ### Parameters #### Alternative URL Parameters If you need to specify the individual components of the request's target URL, omit the `url` field and specify the components as root-level fields. The following URL component fields are available: `| <scheme>://<host>/<path>?<query>#<fragment> |\n| ------------------------------------------- | ` ``` {    \"scheme\": <string>,    \"host\": <string>,    \"path\": <string>,    \"query\": <document>,    \"fragment\": <string>,    \"username\": <string>,    \"password\": <string> } \n```\n\n ### Return Value The `http.get()` action returns a promise that resolves to a document with the following form: ```javascript {    \"status\": <string>,    \"statusCode\": <integer>,    \"contentLength\": <integer>,    \"headers\": <document>,    \"cookies\": <array>,    \"body\": <binary> } \n```\n\n #### Request Authentication You can authenticate an outbound HTTP request using one of the standard[HTTP authentication schemes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication). Atlas App Services supports the following authentication schemes: ##### Basic Authentication HTTP [basic authentication](https://en.wikipedia.org/wiki/Basic%5Faccess%5Fauthentication)requires that incoming requests include a valid username and password for the requested service. You can specify the user credentials in the`username` and `password` fields of the request document, directly in a `url` string, or in an [Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) HTTP header. ## Example The following examples demonstrate three equivalent ways to authenticate an HTTP service request using basic authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. You would pass one of these objects as an argument to the given HTTP method. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\" } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\" } \n``` Include an Authorization Header ```javascript {   \"url\": \"https://www.example.com\",   \"headers\": {     \"Authorization\": [       `Basic ${BSON.Binary.fromText(\"MyUser:Mypassw0rd\").toBase64()}`     ]   } } \n``` ##### Digest Authentication HTTP [digest authentication](https://en.wikipedia.org/wiki/Digest%5Faccess%5Fauthentication)requires that incoming requests include an authorization key based on a random [nonce](https://en.wikipedia.org/wiki/Cryptographic%5Fnonce) value returned from the server. App Services can automatically construct the key and authorize requests given a valid username and password. To configure a request to use digest authentication, set the`digestAuth` field to `true` and specify the user credentials in the`username` and `password` fields of the request document or directly in a `url` string. ## Example The following examples demonstrate two equivalent ways to authenticate an HTTP service request using digest authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\",   \"digestAuth\": true } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\",   \"digestAuth\": true } \n``` ## Rule Templates ### Users Can Only Send Requests to a Specific Host ``` {   \"%%args.url.host\": \"example.com\" } \n``` ### Requests URLs Must Include a Specific Query Parameter ``` {   \"%%args.url.query.someParameter\": \"importantValue\" } \n``` ### Requests Must Be To A Specific Path ``` {   \"%%args.url.scheme: \"https\",   \"%%args.url.host\" : \"www.example.com\",   \"%%args.url.path\" : \"/api/v1.0/messages\" } \n``` ← [HTTP Service \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/http/ \"Previous Section\")[http.post()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.post/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/http-actions/http.patch/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # http.patch() On this page * [Definition](#definition)\n* [Usage](#usage)\n* [Example](#example)\n* [Parameters](#parameters)\n* [Return Value](#return-value)\n* [Rule Templates](#rule-templates)\n* [Users Can Only Send Requests to a Specific Host](#users-can-only-send-requests-to-a-specific-host)\n* [Requests URLs Must Include a Specific Query Parameter](#requests-urls-must-include-a-specific-query-parameter)\n* [Request Bodies Must Include a Specific Field](#request-bodies-must-include-a-specific-field)\n* [Request Bodies Must Include Fields with Specific Values](#request-bodies-must-include-fields-with-specific-values) ## Definition `http.patch()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-http.patch \"Permalink to this definition\") Sends an [HTTP PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH) request to the specified URL using the Atlas App Services [HTTP Service.](https://mongodb.com/docs/atlas/app-services/services/http/) ## Usage ### Example ### Parameters #### Alternative URL Parameters If you need to specify the individual components of the request's target URL, omit the `url` field and specify the components as root-level fields. The following URL component fields are available: `| <scheme>://<host>/<path>?<query>#<fragment> |\n| ------------------------------------------- | ` ``` {    \"scheme\": <string>,    \"host\": <string>,    \"path\": <string>,    \"query\": <document>,    \"fragment\": <string>,    \"username\": <string>,    \"password\": <string> } \n```\n\n ### Return Value The `http.patch()` action returns a promise that resolves to a document with the following form: ```javascript {    \"status\": <string>,    \"statusCode\": <integer>,    \"contentLength\": <integer>,    \"headers\": <document>,    \"cookies\": <array>,    \"body\": <binary> } \n```\n\n #### Request Authentication You can authenticate an outbound HTTP request using one of the standard[HTTP authentication schemes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication). Atlas App Services supports the following authentication schemes: ##### Basic Authentication HTTP [basic authentication](https://en.wikipedia.org/wiki/Basic%5Faccess%5Fauthentication)requires that incoming requests include a valid username and password for the requested service. You can specify the user credentials in the`username` and `password` fields of the request document, directly in a `url` string, or in an [Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) HTTP header. ## Example The following examples demonstrate three equivalent ways to authenticate an HTTP service request using basic authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. You would pass one of these objects as an argument to the given HTTP method. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\" } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\" } \n``` Include an Authorization Header ```javascript {   \"url\": \"https://www.example.com\",   \"headers\": {     \"Authorization\": [       `Basic ${BSON.Binary.fromText(\"MyUser:Mypassw0rd\").toBase64()}`     ]   } } \n``` ##### Digest Authentication HTTP [digest authentication](https://en.wikipedia.org/wiki/Digest%5Faccess%5Fauthentication)requires that incoming requests include an authorization key based on a random [nonce](https://en.wikipedia.org/wiki/Cryptographic%5Fnonce) value returned from the server. App Services can automatically construct the key and authorize requests given a valid username and password. To configure a request to use digest authentication, set the`digestAuth` field to `true` and specify the user credentials in the`username` and `password` fields of the request document or directly in a `url` string. ## Example The following examples demonstrate two equivalent ways to authenticate an HTTP service request using digest authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\",   \"digestAuth\": true } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\",   \"digestAuth\": true } \n``` ## Rule Templates ### Users Can Only Send Requests to a Specific Host ``` {   \"%%args.url.host\": \"example.com\" } \n``` ### Requests URLs Must Include a Specific Query Parameter ``` {   \"%%args.url.query.someParameter\": \"importantValue\" } \n``` ### Request Bodies Must Include a Specific Field ``` {   \"body.name\": { \"%exists\": 1 } } \n``` ### Request Bodies Must Include Fields with Specific Values ``` {   \"body.city\": \"New York City\" } \n``` ← [http.put()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.put/ \"Previous Section\")[http.delete()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/configure/services/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure Third-Party Services \\[Deprecated\\] On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Create a New Service](#create-a-new-service)\n* [Enter Configuration Values](#enter-configuration-values)\n* [Authenticate a MongoDB Atlas User](#authenticate-a-mongodb-atlas-user)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Create a Service Configuration Directory](#create-a-service-configuration-directory)\n* [Add a Service Configuration File](#add-a-service-configuration-file)\n* [Import the Service](#import-the-service) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview You can create and configure interfaces for all [external service](https://mongodb.com/docs/atlas/app-services/reference/services/) from the App Services UI or by [importing](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-cli) a service configuration directory. Select the tab below that corresponds to the method you want to use. ## Procedure ← [Webhook Requests & Responses \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/webhook-requests-and-responses/ \"Previous Section\")[Configure Service Webhooks \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/configure/service-webhooks/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/http-actions/http.post/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # http.post() On this page * [Definition](#definition)\n* [Usage](#usage)\n* [Example](#example)\n* [Parameters](#parameters)\n* [Return Value](#return-value)\n* [Rule Templates](#rule-templates)\n* [Users Can Only Send Requests to a Specific Host](#users-can-only-send-requests-to-a-specific-host)\n* [Requests URLs Must Include a Specific Query Parameter](#requests-urls-must-include-a-specific-query-parameter)\n* [Request Bodies Must Include a Specific Field](#request-bodies-must-include-a-specific-field)\n* [Request Bodies Must Include Fields with Specific Values](#request-bodies-must-include-fields-with-specific-values) ## Definition `http.post()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-http.post \"Permalink to this definition\") Sends an [HTTP POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) request to the specified URL using the Atlas App Services [HTTP Service.](https://mongodb.com/docs/atlas/app-services/services/http/) ## Usage ### Example ### Parameters #### Alternative URL Parameters If you need to specify the individual components of the request's target URL, omit the `url` field and specify the components as root-level fields. The following URL component fields are available: `| <scheme>://<host>/<path>?<query>#<fragment> |\n| ------------------------------------------- | ` ``` {    \"scheme\": <string>,    \"host\": <string>,    \"path\": <string>,    \"query\": <document>,    \"fragment\": <string>,    \"username\": <string>,    \"password\": <string> } \n```\n\n ### Return Value The `http.post()` action returns a promise that resolves to a document with the following form: ```javascript {    \"status\": <string>,    \"statusCode\": <integer>,    \"contentLength\": <integer>,    \"headers\": <document>,    \"cookies\": <array>,    \"body\": <binary> } \n```\n\n #### Request Authentication You can authenticate an outbound HTTP request using one of the standard[HTTP authentication schemes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication). Atlas App Services supports the following authentication schemes: ##### Basic Authentication HTTP [basic authentication](https://en.wikipedia.org/wiki/Basic%5Faccess%5Fauthentication)requires that incoming requests include a valid username and password for the requested service. You can specify the user credentials in the`username` and `password` fields of the request document, directly in a `url` string, or in an [Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) HTTP header. ## Example The following examples demonstrate three equivalent ways to authenticate an HTTP service request using basic authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. You would pass one of these objects as an argument to the given HTTP method. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\" } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\" } \n``` Include an Authorization Header ```javascript {   \"url\": \"https://www.example.com\",   \"headers\": {     \"Authorization\": [       `Basic ${BSON.Binary.fromText(\"MyUser:Mypassw0rd\").toBase64()}`     ]   } } \n``` ##### Digest Authentication HTTP [digest authentication](https://en.wikipedia.org/wiki/Digest%5Faccess%5Fauthentication)requires that incoming requests include an authorization key based on a random [nonce](https://en.wikipedia.org/wiki/Cryptographic%5Fnonce) value returned from the server. App Services can automatically construct the key and authorize requests given a valid username and password. To configure a request to use digest authentication, set the`digestAuth` field to `true` and specify the user credentials in the`username` and `password` fields of the request document or directly in a `url` string. ## Example The following examples demonstrate two equivalent ways to authenticate an HTTP service request using digest authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\",   \"digestAuth\": true } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\",   \"digestAuth\": true } \n``` ## Rule Templates ### Users Can Only Send Requests to a Specific Host ``` {   \"%%args.url.host\": \"example.com\" } \n``` ### Requests URLs Must Include a Specific Query Parameter ``` {   \"%%args.url.query.someParameter\": \"importantValue\" } \n``` ### Request Bodies Must Include a Specific Field ``` {   \"body.name\": { \"%exists\": 1 } } \n``` ### Request Bodies Must Include Fields with Specific Values ``` {   \"body.city\": \"New York City\" } \n``` ← [http.get()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.get/ \"Previous Section\")[http.put()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.put/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/configure/service-webhooks/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure Service Webhooks \\[Deprecated\\] On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Set Up a New Webhook](#set-up-a-new-webhook)\n* [Name the New Webhook](#name-the-new-webhook)\n* [Configure User Authentication](#configure-user-authentication)\n* [Select the Webhook's HTTP Method](#select-the-webhook-s-http-method)\n* [Configure the Webhook Response](#configure-the-webhook-response)\n* [Specify an Authorization Expression](#specify-an-authorization-expression)\n* [Specify the Request Validation Method](#specify-the-request-validation-method)\n* [Write the Webhook Function](#write-the-webhook-function)\n* [Save the Webhook](#save-the-webhook)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Add a Webhook Configuration Directory](#add-a-webhook-configuration-directory)\n* [Add a Webhook Configuration File](#add-a-webhook-configuration-file)\n* [Name the New Webhook](#name-the-new-webhook-1)\n* [Configure User Authentication](#configure-user-authentication-1)\n* [Specify the Webhook's HTTP Method](#specify-the-webhook-s-http-method)\n* [Configure the Webhook Response](#configure-the-webhook-response-1)\n* [Specify an Authorization Expression](#specify-an-authorization-expression-1)\n* [Specify the Request Validation Method](#specify-the-request-validation-method-1)\n* [Add the Webhook Function Source Code](#add-the-webhook-function-source-code)\n* [Deploy the Incoming Webhook Configuration](#deploy-the-incoming-webhook-configuration) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview Some external services allow you to create [incoming webhooks](https://mongodb.com/docs/atlas/app-services/reference/services/#std-label-service-webhooks) that external clients can call over HTTP. You can create webhooks for these services from the App Services UI or with Realm CLI. Select the tab below that corresponds to the method you want to use. ## Procedure ← [Configure Third-Party Services \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/configure/services/ \"Previous Section\")[Configure Service Rules \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/configure/service-rules/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/http-actions/http.head/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # http.head() On this page * [Definition](#definition)\n* [Usage](#usage)\n* [Example](#example)\n* [Parameters](#parameters)\n* [Return Value](#return-value)\n* [Rule Templates](#rule-templates)\n* [Users Can Only Send Requests to a Specific Host](#users-can-only-send-requests-to-a-specific-host)\n* [Requests URLs Must Include a Specific Query Parameter](#requests-urls-must-include-a-specific-query-parameter)\n* [Requests Must Be to a Specific Path](#requests-must-be-to-a-specific-path) ## Definition `http.head()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-http.head \"Permalink to this definition\") Sends an [HTTP HEAD](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD) request to the specified URL using the Atlas App Services [HTTP Service.](https://mongodb.com/docs/atlas/app-services/services/http/) ## Usage ### Example ### Parameters #### Alternative URL Parameters If you need to specify the individual components of the request's target URL, omit the `url` field and specify the components as root-level fields. The following URL component fields are available: `| <scheme>://<host>/<path>?<query>#<fragment> |\n| ------------------------------------------- | ` ``` {    \"scheme\": <string>,    \"host\": <string>,    \"path\": <string>,    \"query\": <document>,    \"fragment\": <string>,    \"username\": <string>,    \"password\": <string> } \n```\n\n ### Return Value The `http.head()` action returns a promise that resolves to a document with the following form: ```javascript {    \"status\": <string>,    \"statusCode\": <integer>,    \"contentLength\": <integer>,    \"headers\": <document>,    \"cookies\": <array>,    \"body\": <binary> } \n```\n\n #### Request Authentication You can authenticate an outbound HTTP request using one of the standard[HTTP authentication schemes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication). Atlas App Services supports the following authentication schemes: ##### Basic Authentication HTTP [basic authentication](https://en.wikipedia.org/wiki/Basic%5Faccess%5Fauthentication)requires that incoming requests include a valid username and password for the requested service. You can specify the user credentials in the`username` and `password` fields of the request document, directly in a `url` string, or in an [Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) HTTP header. ## Example The following examples demonstrate three equivalent ways to authenticate an HTTP service request using basic authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. You would pass one of these objects as an argument to the given HTTP method. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\" } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\" } \n``` Include an Authorization Header ```javascript {   \"url\": \"https://www.example.com\",   \"headers\": {     \"Authorization\": [       `Basic ${BSON.Binary.fromText(\"MyUser:Mypassw0rd\").toBase64()}`     ]   } } \n``` ##### Digest Authentication HTTP [digest authentication](https://en.wikipedia.org/wiki/Digest%5Faccess%5Fauthentication)requires that incoming requests include an authorization key based on a random [nonce](https://en.wikipedia.org/wiki/Cryptographic%5Fnonce) value returned from the server. App Services can automatically construct the key and authorize requests given a valid username and password. To configure a request to use digest authentication, set the`digestAuth` field to `true` and specify the user credentials in the`username` and `password` fields of the request document or directly in a `url` string. ## Example The following examples demonstrate two equivalent ways to authenticate an HTTP service request using digest authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\",   \"digestAuth\": true } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\",   \"digestAuth\": true } \n``` ## Rule Templates ### Users Can Only Send Requests to a Specific Host ``` {   \"%%args.url.host\": \"example.com\" } \n``` ### Requests URLs Must Include a Specific Query Parameter ``` {   \"%%args.url.query.someParameter\": \"importantValue\" } \n``` ### Requests Must Be to a Specific Path ``` {   \"%%args.url.scheme: \"https\",   \"%%args.url.host\" : \"www.example.com\",   \"%%args.url.path\" : \"/api/v1.0/messages\" } \n``` ← [http.delete()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.delete/ \"Previous Section\")[Twilio Service \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/services/twilio/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/services/http-actions/http.delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # http.delete() On this page * [Definition](#definition)\n* [Usage](#usage)\n* [Example](#example)\n* [Parameters](#parameters)\n* [Return Value](#return-value)\n* [Rule Templates](#rule-templates)\n* [Users Can Only Send Requests to a Specific Host](#users-can-only-send-requests-to-a-specific-host)\n* [Requests URLs Must Include a Specific Query Parameter](#requests-urls-must-include-a-specific-query-parameter)\n* [Requests Must Be To A Specific Path](#requests-must-be-to-a-specific-path) ## Definition `http.delete()`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#mongodb-method-http.delete \"Permalink to this definition\") Sends an [HTTP DELETE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE) request to the specified URL using the Atlas App Services [HTTP Service.](https://mongodb.com/docs/atlas/app-services/services/http/) ## Usage ### Example ### Parameters #### Alternative URL Parameters If you need to specify the individual components of the request's target URL, omit the `url` field and specify the components as root-level fields. The following URL component fields are available: `| <scheme>://<host>/<path>?<query>#<fragment> |\n| ------------------------------------------- | ` ``` {    \"scheme\": <string>,    \"host\": <string>,    \"path\": <string>,    \"query\": <document>,    \"fragment\": <string>,    \"username\": <string>,    \"password\": <string> } \n```\n\n ### Return Value The `http.delete()` action returns a promise that resolves to a document with the following form: ```javascript {    \"status\": <string>,    \"statusCode\": <integer>,    \"contentLength\": <integer>,    \"headers\": <document>,    \"cookies\": <array>,    \"body\": <binary> } \n```\n\n #### Request Authentication You can authenticate an outbound HTTP request using one of the standard[HTTP authentication schemes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication). Atlas App Services supports the following authentication schemes: ##### Basic Authentication HTTP [basic authentication](https://en.wikipedia.org/wiki/Basic%5Faccess%5Fauthentication)requires that incoming requests include a valid username and password for the requested service. You can specify the user credentials in the`username` and `password` fields of the request document, directly in a `url` string, or in an [Authorization](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization) HTTP header. ## Example The following examples demonstrate three equivalent ways to authenticate an HTTP service request using basic authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. You would pass one of these objects as an argument to the given HTTP method. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\" } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\" } \n``` Include an Authorization Header ```javascript {   \"url\": \"https://www.example.com\",   \"headers\": {     \"Authorization\": [       `Basic ${BSON.Binary.fromText(\"MyUser:Mypassw0rd\").toBase64()}`     ]   } } \n``` ##### Digest Authentication HTTP [digest authentication](https://en.wikipedia.org/wiki/Digest%5Faccess%5Fauthentication)requires that incoming requests include an authorization key based on a random [nonce](https://en.wikipedia.org/wiki/Cryptographic%5Fnonce) value returned from the server. App Services can automatically construct the key and authorize requests given a valid username and password. To configure a request to use digest authentication, set the`digestAuth` field to `true` and specify the user credentials in the`username` and `password` fields of the request document or directly in a `url` string. ## Example The following examples demonstrate two equivalent ways to authenticate an HTTP service request using digest authentication. The examples all use the username `MyUser` and the password`Mypassw0rd`. Specify Credentials Directly (Best Method) ``` {   \"scheme\": \"https\",   \"username\": \"MyUser\",   \"password\": \"Mypassw0rd\",   \"domain\": \"www.example.com\",   \"digestAuth\": true } \n``` Embed Credentials in the URL ``` {   \"url\": \"https://MyUser:Mypassw0rd@www.example.com\",   \"digestAuth\": true } \n``` ## Rule Templates ### Users Can Only Send Requests to a Specific Host ``` {   \"%%args.url.host\": \"example.com\" } \n``` ### Requests URLs Must Include a Specific Query Parameter ``` {   \"%%args.url.query.someParameter\": \"importantValue\" } \n``` ### Requests Must Be To A Specific Path ``` {   \"%%args.url.scheme: \"https\",   \"%%args.url.host\" : \"www.example.com\",   \"%%args.url.path\" : \"/api/v1.0/messages\" } \n``` ← [http.patch()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.patch/ \"Previous Section\")[http.head()](https://mongodb.com/docs/atlas/app-services/services/http-actions/http.head/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/users/manage/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Manage User Accounts On this page * [Overview](#overview)\n* [Delete a User](#delete-a-user)\n* [Manually Delete a User](#manually-delete-a-user)\n* [Delete a User in the SDK](#delete-a-user-in-the-sdk)\n* [Delete a User with a Custom Function](#delete-a-user-with-a-custom-function)\n* [Disable a User](#disable-a-user)\n* [Enable a User](#enable-a-user) ## Overview You can manage your application's user accounts with the App Services UI, App Services CLI, Admin API, or Realm SDKs. ## Delete a User You can completely remove a user from your application, including any metadata and authentication provider identities. Deleting a user also immediately ends any [sessions](https://mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) associated with that user. ## Tip If you don't want to delete the user's account, you can [disable their account](#std-label-disable-user) to temporarily suspend their access. ### Manually Delete a User You can use the App Services UI, CLI, or Admin API to manually remove a user account. ## Note App Services does not automatically delete any data in your linked MongoDB Atlas cluster that you have associated with a deleted user. For example, if your application allows users to create data that linked to a user by including their ID in an `owner_id` field, deleting the user object does not delete the user-created linked data. To remove all traces of a deleted user, you must manually delete or modify any such documents. ### Delete a User in the SDK You can give users the option to delete their own account from a client application when you use the Realm SDKs to delete users. ### Delete a User with a Custom Function You can write a custom function to delete a user. You might want to do this if your SDK does not yet support the delete users API. [Create a function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-define-a-function) similar to our example below that uses Application Authentication. You might want to incorporate error handling in the event that the function does not successfully authenticate, or it cannot delete the calling user. For this example function, we have [created values and secrets for the adminApiPublicKey and adminApiPrivateKey](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-values-and-secrets). We would then add the [Project and Application IDs](https://mongodb.com/docs/atlas/app-services/apps/metadata/#std-label-app-metadata) to the `apiUrl`. We can then [call this function from the SDK](https://mongodb.com/docs/atlas/app-services/functions/#std-label-call-function-from-client-sdks). The example function below does not take any arguments, and deletes the user who calls the function. ## Tip If your app uses [Email/Password Authentication](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication), consider that you may want to delete pending users, which involves a second endpoint: * [Delete users](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#operation/adminDeleteUser)\n* [Delete pending users](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#operation/adminDeletePendingEmailPasswordUser)\n\n  `` ## Disable a User You can temporarily disable a user, which prevents the user from logging in and invalidates any of the user's existing access and refresh tokens. You can[enable](#std-label-enable-user) a disabled user to let them log in again. ## Enable a User You can enable a [disabled user](#std-label-disable-user) to let them log in again. ← [Read User Metadata](https://mongodb.com/docs/atlas/app-services/users/read-metadata/ \"Previous Section\")[Manage User Sessions](https://mongodb.com/docs/atlas/app-services/users/sessions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/users/read-metadata/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Read User Metadata On this page * [Overview](#overview)\n* [Schema](#schema)\n* [Find Users](#find-users)\n* [Filter Users](#filter-users)\n* [View User Data](#view-user-data)\n* [View a User's Devices](#view-a-user-s-devices)\n* [View a User's Provider Data](#view-a-user-s-provider-data)\n* [View a User's Activity Log](#view-a-user-s-activity-log)\n* [Summary](#summary) ## Overview Atlas App Services represents each application user internally with a**User Object** that includes a unique ID and additional metadata that describes the user. You can access user objects: * With the App Services UI, CLI, or Admin API to [find](#std-label-find-users)and [filter](#std-label-filter-users) users.\n* In the App Services UI by [viewing user data.](#std-label-view-user-data)\n* In a [Function](https://mongodb.com/docs/atlas/app-services/functions/) by accessing the [context.user](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-user) interface.\n* In a [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) with the [%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user)expansion.\n* In [Android](https://www.mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-authenticate), [iOS](https://www.mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-authenticate-users), [Node](https://www.mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-authenticate-users),[React Native](https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-authenticate-users), and[.NET](https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-authenticate) client applications using a Realm SDK. ## Schema User objects have the following form:\n\n `\n\n ## Note In general, App Services creates a user object for a given user the first time that they authenticate. If you create a test [Email/Password](https://mongodb.com/docs/atlas/app-services/users/create/)user through the App Services UI, App Services creates that user's user object immediately. ## Find Users ## Filter Users You can specify filters that limit a list of users to a subset of users that satisfy the filter conditions. ## View User Data ### View a User's Devices When a user connects to your application, Atlas App Services[logs information](https://mongodb.com/docs/atlas/app-services/logs/authentication/#std-label-authentication-logs) similar to the following: ![A detail view for a specific user that lists devices they've used with your app](https://mongodb.com/docs/atlas/app-services/images/devices.png) Logged information includes: * The device platform, which will be either an http client (\"chrome\", \"firefox\", \"phantomjs\", etc.) or a mobile OS (\"ios\", \"android\", etc.)\n* The platform version.\n* Your app version on the device.\n* A unique device ID. To view this information, from the list of users, expand any user and then expand Devices. ### View a User's Provider Data Whenever a user connects to your application and authenticates using one of the authentication providers you have enabled, App Services logs the provider data. ![A detail view for a specific user that lists metadata about them from an authentication provider](https://mongodb.com/docs/atlas/app-services/images/provider.png) You can view this collection of Provider Data from within the list of users by doing the following: 1. Find a user in the list of users.\n2. Expand the user, and then expand the Provider Data. ### View a User's Activity Log App Services logs every request made by each of your App users, including executed function calls. Also, if a function writes to the log using `console.log`, `console.warn`, or `console.error`, these entries will be included within the function's log output. ![A detail view for a specific user that shows a log of their interactions with your app](https://mongodb.com/docs/atlas/app-services/images/user_log.png) To view a user's request logs, follow these steps: 1. Select App Users from the left navigation menu.\n2. Under the Users tab, find a user in the list and click on the ellipsis (`...`).\n3. Click View activity. This will redirect you to a log of requests made by that specific user. You can expand an entry to view details for that request. ## Summary * The user object contains relevant information about the user that you can use in your app logic.\n* The exact information contained in the user object depends on the [authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) used.\n* You can search for users in the `Users` page of the App Services UI.\n* App Services logs information such as user's connected devices, provider data, and activity log. ← [Define Custom User Metadata](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/ \"Previous Section\")[Manage User Accounts](https://mongodb.com/docs/atlas/app-services/users/manage/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/users/custom-metadata/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Define Custom User Metadata On this page * [Overview](#overview)\n* [Custom User Data](#custom-user-data)\n* [Create and Manage Custom User Data](#create-and-manage-custom-user-data)\n* [Secure Custom User Data](#secure-custom-user-data)\n* [User Creation Function](#user-creation-function)\n* [Enable Custom User Data](#enable-custom-user-data)\n* [Access Custom User Data from a Client Application](#access-custom-user-data-from-a-client-application)\n* [Authentication Provider Metadata](#authentication-provider-metadata)\n* [Configure Authentication Provider Metadata](#configure-authentication-provider-metadata)\n* [Access User Metadata from a Client Application](#access-user-metadata-from-a-client-application) ## Overview You can associate custom metadata with each user of your App. For example, you might store a user's preferred language, date of birth, or any other information that you want to associate with the user. You can source the metadata for a user from two sources: * A collection in MongoDB Atlas that stores custom user data. You can associate each user with a document in the collection by their user ID. You can store arbitrary data in each document.\n* An authentication provider. If the provider uses JSON Web Tokens, such as Google, Facebook, or a custom provider, you can define metadata fields in the provider configuration that associate data from the user's JWT with their user account. ## Custom User Data You can store arbitrary data about your application users in a MongoDB collection. Your App maps each user to a document in the collection by querying a specific field for the user's ID. When a user authenticates, your App looks up the user's data and includes it in their access token. Consider a user with the ID `\"63ed2dbe5960df2af7fd216e\"`. If your custom user data collection was set up to store the user's ID in the`userId` field, the user would map to the following document: `| {                                         |\n| ----------------------------------------- |\n| \"_id\": \"63ed2e4fb7f367c92578e526\",        |\n| \"user_id\": \"63ed2dbe5960df2af7fd216e\",    |\n| \"preferences\": {                          |\n| \"preferDarkMode\": true                    |\n| },                                        |\n| \"dateOfBirth\": \"1989-03-11T00:00:00.000Z\" |\n| }                                         | ` When you use custom user data, keep the following things in mind: * **Store One Document Per User**: Documents that contain user data must include the user's ID in a specific field. If multiple documents specify the same user's ID, App Services only exposes the data from the document that was inserted first.\n* **Keep Custom User Data Small**: The user's full custom user document is included in their access token. In general, aim to keep custom user data documents small (say, less than 16KB). Other services might limit the HTTP header size, which means that larger custom user data objects can cause integration issues.\n* **Custom Data May Be Stale**: A user's custom data is _sourced_ from a MongoDB collection but is stored in and read from a user's authentication access token. If a user has a valid access token when the underlying document changes, their custom data in that session does not update until they refresh their access token or re-authenticate. ### Create and Manage Custom User Data\n\n * Automatically create a document for each user when they register for your application using a [user creation function](#std-label-user-creation-function). This function runs before the user is issued an access token, so the data you add will be in the access token on their first login.\n* Use an [authentication trigger](https://mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-triggers) to update a user's custom data when they register or log in and to delete their data if their account is deleted. Triggers run asynchronously and may finish after the user's access token is created.\n* Use a [scheduled trigger](https://www.mongodb.com/docs/atlas/triggers/#std-label-scheduled-triggers) to periodically update or delete custom user data.\n* Manually create, update, and delete documents in the collection using standard CRUD operations from a Function, a Realm SDK, a MongoDB driver or MongoDB Compass. ### Secure Custom User Data If your App's custom user data includes personal or private user information, you should restrict access to the custom user data collection. Consider using one of the following permission models to restrict read and write access to privileged users only: * A user may read or write their own custom user data document. Deny read and write access to all other documents.  \n## Example  \nThe following collection configuration has one role that grants a user read and write access to a document if and only if their ID is contained in the document's `user_id` field.  \nA custom user data collection configuration  \n```  \n{  \n  \"database\": \"<Database Name>\",  \n  \"collection\": \"<Collection Name>\",  \n  \"roles\": [  \n    {  \n      \"name\": \"ThisUser\",  \n      \"apply_when\": { \"user_id\": \"%%user.id%%\" },  \n      \"insert\": false,  \n      \"read\": true,  \n      \"write\": true,  \n      \"search\": false,  \n      \"delete\": false  \n    }  \n  ],  \n  \"filters\": []  \n}  \n```\n* No user may read or write any custom user data documents. Instead, use a system function to manage custom user data on behalf of users. ### User Creation Function You can define a Function that runs every time a new user successfully registers but before their new user account is created. If the function throws or otherwise errors, the user account creation fails. This lets you ensure that users always have custom data associated with them once created. The function receives a [user metadata object](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) as its only argument. You can use this create a new custom user data document for the user. ```javascript exports = async function onUserCreation(user) {   const customUserDataCollection = context.services     .get(\"mongodb-atlas\")     .db(\"myapp\")     .collection(\"users\");   try {     await customUserDataCollection.insertOne({       // Save the user's account ID to your configured user_id_field       user_account_id: user.id,       // Store any other user data you want       favorite_color: \"blue\",     });   } catch (e) {     console.error(`Failed to create custom user data document for user:${user.id}`);     throw e   } } \n``` ## Tip Once you've configured a user creation function, App Services prevents you from deleting the function. If you want to delete the function, first change your custom user data configuration to use a different user creation function. ### Enable Custom User Data ### Access Custom User Data from a Client Application For code examples that demonstrate how to access and update custom user data from the client application, see the documentation for the Realm SDKs:\n\n ## Authentication Provider Metadata Atlas App Services can read user metadata from authentication providers. Then, App Services exposes each user's data in a field of their [user object](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects). For example, you might want to access a user's name, email, birthday, or gender. You can configure App Services to request metadata with the access token when users log in. You can access that data from the logged-in user's object with a client SDK. You can define the metadata to request when you configure authentication providers. Specify optional metadata fields that you want to access through the user's account. These metadata fields vary depending on provider. | Provider   | Metadata fields                                                                                                                                                                                                      |\n| ---------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Facebook   | namefirst\\_namelast\\_namepicturegenderbirthdaymin\\_agemax\\_ageemail                                                                                                                                                  |\n| Google     | namefirst\\_namelast\\_namepictureemail                                                                                                                                                                                |\n| Custom JWT | Any field in the JWT as specified by the Custom JWT provider's[metadata fields](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication-configuration-metadata-fields)configuration. | ### Configure Authentication Provider Metadata ### Access User Metadata from a Client Application For code examples that demonstrate how to access user metadata data from the client application, see the documentation for the Realm SDKs:\n\n ← [Create an App User](https://mongodb.com/docs/atlas/app-services/users/create/ \"Previous Section\")[Read User Metadata](https://mongodb.com/docs/atlas/app-services/users/read-metadata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/users/create/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Create an App User On this page * [Overview](#overview)\n* [Identity](#identity)\n* [Link to Existing Accounts](#link-to-existing-accounts)\n* [Create an Email/Password User](#create-an-email-password-user)\n* [Create an Email/Password User in the SDK](#create-an-email-password-user-in-the-sdk)\n* [Manually Create an Email/Password User](#manually-create-an-email-password-user)\n* [Confirm a User](#confirm-a-user)\n* [Re-run the User Confirmation Workflow](#re-run-the-user-confirmation-workflow)\n* [Summary](#summary) ## Overview Atlas App Services provides various [authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)to log users into your app. For most providers, App Services automatically creates a user account the first time a user authenticates through the provider. The only exception is[email/password user authentication](#std-label-create-email-password-user), which requires registering and confirming a user before the user can authenticate. ## Tip ### Apple Account Deletion Requirements Apple [requires that applications distributed through the App Store](https://developer.apple.com/app-store/review/guidelines/#5.1.1) must give any user who creates an account the option to delete the account. Whether that app uses an authentication method where you must manually register a user, such as email/password authentication, or one that automatically creates a user, such as Sign-In with Apple, an app distributed through the App Store must implement [user account deletion.](https://mongodb.com/docs/atlas/app-services/users/manage/#std-label-delete-user) ## Identity When you first log in with an authentication provider, App Services creates a[user object](https://mongodb.com/docs/atlas/app-services/users/read-metadata/#std-label-user-objects) that contains a unique identity ID and[provider-specific metadata](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-auth-provider-metadata) about the user. ### Link to Existing Accounts A single user object can have more than one identity. You can use the Realm SDKs to link identities to existing user accounts. This allows users to log in to a single account with more than one provider. For more information, see the documentation on linking identities for your preferred SDK: ## Create an Email/Password User When you use [email/password user authentication](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication), you must first register a user, which creates the user object. You can register users in your client application using your preferred SDK or you can manually create email/password users. After registering the user, you must [confirm the user](#std-label-confirm-user)before they can authenticate. ### Create an Email/Password User in the SDK Each SDK offers an API that enables you to register an email/password user. After registering the user, you must confirm the user before the they can authenticate. For code examples that demonstrate how to manage email/password users in the client application, see the documentation for the Realm SDKs:\n\n ### Manually Create an Email/Password User You can create a new [Email/Password](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) user from the App Services UI, CLI, or Admin API. Manually-created users bypass any configured user confirmation flows. ## Tip Manually creating a user can be useful for testing and debugging your application in development. ## Confirm a User You must confirm the email address of new[Email/Password users](https://mongodb.com/docs/atlas/app-services/authentication/email-password/)before they are permitted to log into App Services. The exact method of confirmation depends upon your provider configuration, but typically involves a[handshake process](https://en.wikipedia.org/wiki/Handshaking) between the user and your application. You can read more about Email/Password user confirmation at [Email/Password Confirmation.](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication-confirmation) Sometimes, users are unable to complete the confirmation process. For example: * An overzealous spam filter might block App Services email confirmation emails.\n* A proxy or web blocker could prevent a user from activating the`confirmUser` client SDK function via the client application.\n* An implementation error could cause the client application's user confirmation page to fail for specific use cases. To help you work around cases like this, you can confirm users manually using the App Services UI or the Admin API: ## Re-run the User Confirmation Workflow A few circumstances can lead to incomplete Email/Password user confirmation workflows: * An email is caught by a spam filter, not delivered due to a bug, or accidentally deleted by a prospective App Services user.\n* A custom confirmation function is unable to communicate with an unconfirmed user due to a bug or oversight.\n* An unconfirmed user forgot to visit their confirmation link within 30 minutes of receiving their login tokens, and the tokens expired. Users caught in this situation appear stuck in an unconfirmed state. Since an existing account has their email registered to it, users cannot create a new account with the same email address. Also, they cannot log into an account that is not confirmed. Applications that use the built-in email confirmation service of App Services can use the `resendConfirmationEmail` Client SDK method to send a new email with a new confirmation link to the user, allowing them to confirm their account and log in. Calling this method will result in an error by any application using a confirmation flow other than `send a confirmation email`. There is no such specific method to re-run a custom confirmation function. Instead, App Services has a method to trigger a re-run of whatever the current Email/Password user confirmation workflow happens to be. You can manually re-run the currently selected user confirmation flow using the App Services UI or the [App Services Admin API:](https://mongodb.com/docs/atlas/app-services/admin/api/v3/) ## Summary * For all providers except for Email/Password authentication, App Services automatically creates a user object the first time a user authenticates.\n* You can log in to a single account with more than one provider by using the Realm SDKs to link identities.\n* The Email/Password authentication provider requires users to create an account the first time they connect to your App.\n* Email/Password users must be confirmed manually through the App Services UI or Admin API.\n* Users caught in an incomplete Email/Password confirmation workflow must re-run the confirmation through the App Services UI or Admin API. ← [Authenticate & Manage Users](https://mongodb.com/docs/atlas/app-services/users/ \"Previous Section\")[Define Custom User Metadata](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/users/sessions/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Manage User Sessions On this page * [Overview](#overview)\n* [Get a User Session Access Token](#get-a-user-session-access-token)\n* [Get a User Access Token Over HTTPS](#get-a-user-access-token-over-https)\n* [Get a User Access Token from a Realm SDK](#get-a-user-access-token-from-a-realm-sdk)\n* [Refresh a User Session Access Token](#refresh-a-user-session-access-token)\n* [Refresh a User Access Token Over HTTPS](#refresh-a-user-access-token-over-https)\n* [Refresh a User Access Token from a Realm SDK](#refresh-a-user-access-token-from-a-realm-sdk)\n* [Configure Refresh Token Expiration](#configure-refresh-token-expiration)\n* [Verify & Decode a User Access Token](#verify---decode-a-user-access-token)\n* [End a User Session](#end-a-user-session)\n* [Revoke a User's Sessions](#revoke-a-user-s-sessions) ## Overview App Services manages [user sessions](https://mongodb.com/docs/atlas/app-services/users/#std-label-user-sessions) with access tokens and refresh tokens. An access token allows anyone that has the token to use the session it's associated with for up to 30 minutes. A refresh token lets you generate a new access token for a session even if the previous token has already expired. The Realm SDKs automatically manage user access and refresh tokens for you when they connect to App Services. You may want to manage sessions yourself if you're connecting to an API service like the Data API or GraphQL. ## Get a User Session Access Token You can authenticate a user and receive a user access token directly over HTTPS or through a session managed by a Realm SDK. ### Get a User Access Token Over HTTPS You can get an access token by sending an authentication request directly to App Services over HTTPS. The authentication endpoint accepts an HTTPS POST request with a JSON body that contains the user's login credentials. If the credentials are valid, the response contains a user access token. 1 #### Find Your App's Client API Base URL Your App's authentication endpoint URL depends on the App's deployment model. Select your App's deployment model to see how to construct the base URL. You can find the base URL programmatically with the App location endpoint. The response body includes the base URL as the `hostname` field. `| curl 'https://realm.mongodb.com/api/client/v2.0/app/<AppID>/location' |\n| --------------------------------------------------------------------- | ` HIDE OUTPUT `| {                                                         |\n| --------------------------------------------------------- |\n| \"deployment_model\": \"LOCAL\",                              |\n| \"location\": \"US-VA\",                                      |\n| \"hostname\": \"https://us-east-1.aws.realm.mongodb.com\",    |\n| \"ws_hostname\": \"wss://ws.us-east-1.aws.realm.mongodb.com\" |\n| }                                                         | ` 2 #### Choose an Authentication Provider Append the login endpoint path for a specific authentication provider to the base URL to get the endpoint URL: ``` <Base URL>/auth/providers/<ProviderType>/login \n``` Replace `<ProviderType>` with one of the following authentication provider types:\n\n 3 #### Authenticate a User Send an HTTPS POST request to the authentication endpoint with a JSON body that contains the user's login credentials for the provider type. If the authentication request succeeds, the response body includes`access_token` and `refresh_token` values for the user. The`access_token` is a JSON Web Token (JWT) that you can use to authenticate requests. ``` {   \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJiYWFzX2RldmljZV9pZCI6IjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsImJhYXNfZG9tYWluX2lkIjoiNWVlYTg2NjdiY2I0YzgxMGI2NTFmYjU5IiwiZXhwIjoxNjY3OTQwNjE4LCJpYXQiOjE2Njc5Mzg4MTgsImlzcyI6IjYzNmFiYTAyMTcyOGI2YzFjMDNkYjgzZSIsInN0aXRjaF9kZXZJZCI6IjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsInN0aXRjaF9kb21haW5JZCI6IjVlZWE4NjY3YmNiNGM4MTBiNjUxZmI1OSIsInN1YiI6IjYzNmFiYTAyMTcyOGI2YzFjMDNkYjdmOSIsInR5cCI6ImFjY2VzcyJ9.pyq3nfzFUT-6r-umqGrEVIP8XHOw0WGnTZ3-EbvgbF0\",\n\n   \"user_id\": \"636aba021728b6c1c03db7f9\" } \n``` ### Get a User Access Token from a Realm SDK In the Realm SDKs, you can access a logged in user's access token from their `User` object. The SDKs automatically refresh expired access tokens for SDK operations and you can manually refresh it by calling a method. To learn more, refer to the documentation for your Realm SDK: * [Realm C++ SDK](https://www.mongodb.com/docs/realm/sdk/cpp/users/authenticate-users/#std-label-cpp-get-a-user-access-token)\n* [Realm Flutter SDK](https://www.mongodb.com/docs/realm/sdk/flutter/users/access-token/#std-label-flutter-access-token)\n* [Realm Java SDK](https://www.mongodb.com/docs/realm/sdk/java/examples/authenticate-users/#std-label-java-get-user-access-token)\n* [Realm Kotlin SDK](https://www.mongodb.com/docs/realm/sdk/kotlin/app-services/authenticate-users/#std-label-kotlin-access-token)\n* [Realm .NET SDK](https://www.mongodb.com/docs/realm/sdk/dotnet/manage-users/authenticate/#std-label-dotnet-retrieve-current-user)\n* [Realm Node.js SDK](https://www.mongodb.com/docs/realm/sdk/node/examples/authenticate-users/#std-label-node-get-user-access-token)\n* [Realm React Native SDK](https://www.mongodb.com/docs/realm/sdk/react-native/manage-users/authenticate-users/#std-label-react-native-get-user-access-token)\n* [Realm Swift SDK](https://www.mongodb.com/docs/realm/sdk/swift/users/authenticate-users/#std-label-ios-get-a-user-access-token)\n* [Web SDK](https://www.mongodb.com/docs/realm/web/authenticate/#std-label-web-get-user-access-token) ## Refresh a User Session Access Token Access tokens expire 30 minutes after they are granted. When an access token expires, you must get a new access token to continue sending requests. You could acquire a new access token by logging the user in again, but that would require the user to re-enter their credentials. Instead, you can use the refresh token associated with the user's session to get a new access token that's valid for another 30 minutes. You get the refresh token in the [same response as the access token](#std-label-get-access-token) after a successful login. ### Refresh a User Access Token Over HTTPS The session refresh endpoint accepts a `POST` request that includes the refresh token in the `Authorization` header. The endpoint URL depends on your App's deployment model. ### Refresh a User Access Token from a Realm SDK The Realm SDKs automatically refresh a logged in user's access token if the token is expired at the time of a request. The SDKs also allow you to manually refresh a user's access token by calling a method on the `User` object. To learn more, refer to the documentation for your Realm SDK:\n\n ## Configure Refresh Token Expiration By default, refresh tokens expire 60 days after they are issued. You can configure this time for your App's refresh tokens to be anywhere between 30 minutes and 180 days. There are two exceptions: * Anonymous user refresh tokens do not expire, though anonymous user accounts are deleted after 90 days of inactivity.\n* Custom JWT refresh token expiration is determined by the `exp` value of the user's JWT. ## Note You can currently only configure refresh token expiration with the Admin API. Call your App's [Set User Refresh Token Expiration Time](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#operation/adminSetRefreshTokenExpiration) Admin API endpoint with the `expiration_time_seconds` field of the request body set to your desired expiration time. ```bash curl -X POST \\   https://realm.mongodb.com/api/admin/v3.0/groups/{groupId}/apps/{appId}/security/refresh_token_expiration \\   --data-raw '{     \"expiration_time_seconds\": 864000   }' \n``` If you successfully update the refresh token expiration time, the endpoint returns a `204` response. ## Verify & Decode a User Access Token You can decode an access token to verify that it has the correct format and has a valid signature. The decoded response includes other information like when the access token expires. Call your App's [Verify and decode an access token](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#operation/adminVerifyUserAccessToken) Admin API endpoint with the token in the `token` field of the request body. ```bash curl -X POST \\   https://realm.mongodb.com/api/admin/v3.0/groups/{groupId}/apps/{appId}/users/verify_token \\   --data-raw '{     \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJiYWFzX2RldmljZV9pZCI6IjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsImJhYXNfZG9tYWluX2lkIjoiNWNkYjEyNDA4ZTIzMmFjNGY5NTg3ZmU4IiwiZXhwIjoxNjc2NTExMjgyLCJpYXQiOjE2NzY1MDk0ODIsImlzcyI6IjYzZWQ4MTJhNDNiZTcyYzE3NmFhNWQyMyIsInN0aXRjaF9kZXZJZCI6IjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsInN0aXRjaF9kb21haW5JZCI6IjVjZGIxMjQwOGUyMzJhYzRmOTU4N2ZlOCIsInN1YiI6IjYzZWQ4MTJhNDNiZTcyYzE3NmFhNWQyMSIsInR5cCI6ImFjY2VzcyJ9.7kHO9wjWvIaD3VewDyPhLyb-oRc7wTYZdD9-hroF-H4\"   }' \n``` HIDE OUTPUT ``` {   \"sub\": \"63ed812a43be72c176aa5d21\",   \"exp\": 1676511282,   \"iat\": 1676509482,   \"iss\": \"63ed812a43be72c176aa5d23\",   \"domain_id\": \"5cdb12408e232ac4f9587fe8\",   \"device_id\": \"000000000000000000000000\" } \n``` If the token is valid, you'll receive a `200` response. If the token is valid but expired, the response indicates that the token is expired rather than containing the decoded JWT. ``` \"token expired\" \n```\n\n ``` {   \"error\": \"signature is invalid\" } \n``` ## End a User Session Once a session has been established you cannot end it individually, though you can [revoke all of a user's active sessions.](#std-label-revoke-user-sessions) You can effectively end a user session by deleting all copies of the access token and refresh token. This prevents further access to the session and requires the user to authenticate and start a new session to continue. Each Realm SDK has a `User.logOut()` method that deletes local copies of the access token and refresh token and invalidates the refresh token so that it can't be used to get a new access token. If a user account is [deleted](https://mongodb.com/docs/atlas/app-services/users/manage/#std-label-delete-user), either by an administrator or by the user, then all of the user's sessions are automatically revoked. ## Important ### Keep Tokens Secure Even if you delete and invalidate all copies of a token that you have, that does **not** end the active session on the server. If a malicious user copied the access token before it was deleted, they could use the token to make requests for up to 30 minutes until it expires. These requests would appear to come from the user who \"logged out\". ## Revoke a User's Sessions You can revoke all of a user's current sessions. This invalidates the session access and refresh tokens and prevents the user from making any requests on any device until they log in again. If a user account is deleted, either by an administrator or by the user, then all of the user's sessions are automatically revoked. ← [Manage User Accounts](https://mongodb.com/docs/atlas/app-services/users/manage/ \"Previous Section\")[Authentication Providers](https://mongodb.com/docs/atlas/app-services/authentication/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/rules/examples/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Define Data Access Permissions ## Overview In traditional applications, an application server exposes an API to client applications and handles database queries on their behalf. To prevent malicious, improper, or incorrect read and write operations, clients don't query the database directly. Atlas App Services provides a configurable and dynamic permissions engine that enables you to run a MongoDB query from client applications while transparently preventing unauthorized reads and writes. Permissions are defined for entire collections in a linked MongoDB Atlas cluster and apply to individual documents in the collection dynamically based on the [application user](https://mongodb.com/docs/atlas/app-services/users/) that issues a query or uses Device Sync. You can also define default rules that serve as a fallback for any collection that doesn't have its own rules. ## Note Federated data sources [do not support rules or schemas](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats). You can only access a Federated data source from a system function. ## Key Concepts To understand how the permissions engine works and how to configure it for your use case, see [Role-based Permissions.](https://mongodb.com/docs/atlas/app-services/rules/roles/) You define permissions with [Rule Expressions](https://mongodb.com/docs/atlas/app-services/rules/expressions/), a domain-specific language built on JSON. You can optimize the performance of the permissions engine with filters. See[Filter Incoming Queries.](https://mongodb.com/docs/atlas/app-services/rules/filters/) If you're using Device Sync (Flexible Mode), permissions work a bit differently. See [Device Sync-Compatible Permissions](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/) for important considerations. The default or \"Basic Mode\" rules editor in the App Services UI covers the majority of use cases for collection rules. However, there are times when you need more fine-grained control than the UI interface provides. In those times, see [Configure Advanced Rules.](https://mongodb.com/docs/atlas/app-services/mongodb/configure-advanced-rules/) Finally, to help you put these concepts into practice, we have provided some[Data Access Role Examples.](https://mongodb.com/docs/atlas/app-services/rules/examples/) ← [Access a Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/access-a-value/ \"Previous Section\")[Role-based Permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/rules/filters/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Filter Incoming Queries On this page * [Overview](#overview)\n* [How App Services Applies Filters](#how-app-services-applies-filters)\n* [Define Filters](#define-filters)\n* [Procedure](#procedure) ## Overview A **filter** modifies an incoming MongoDB query to return only a subset of the results matched by the query. Adding a filter to a collection allows you to control the shape of queried documents and can improve query performance. Filters add additional query parameters and omit fields from query results_before_ Atlas App Services runs the query. Every filter has three components: * An \"apply when\" [expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that determines if the filter applies to an incoming request. You can use variables like[%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user) and [%%request](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---request) in the \"apply when\" expression. However, you cannot use expansions that refer to a document like[%%root](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---root) because App Services evaluates the \"apply when\" expression before reading any documents.\n* An optional query [expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions), which merges with the existing query of any request the filter applies to.\n* An optional projection document, which uses standard MongoDB projection syntax and merges with the existing projection of any request the filter applies to. ## How App Services Applies Filters App Services evaluates and applies filters for every MongoDB request where rules apply, such as: * A query on a collection.\n* A write to a document.\n* The start of a Device Sync session. Multiple filters may apply to a single request. A filter applies to a given request if its \"apply when\" [expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) evaluates to true given that request's context. If a filter applies to a request, App Services merges the filter's query or projection into the requested operation's existing query and projection. App Services applies filters to the request _before_ it sends the request to MongoDB. ## Example A collection contains several million documents and has one role with the following \"apply when\" expression: `| { \"owner_id\": \"%%user.id\" } |\n| --------------------------- | ` If no filter is applied, App Services will evaluate a role for each document that the query matches. We know that App Services will withhold any document that does not have the user's id as the value of the`owner_id` field, so we save time and compute resources by applying an additional query predicate that excludes those documents before App Services evaluates any roles: | Apply When         | Query                        | Projection |\n| ------------------ | ---------------------------- | ---------- |\n| { \"%%true\": true } | { \"owner\\_id\": \"%%user.id\" } | {}         | ## Define Filters You can use filters to optimize queries, minimize compute overhead, and secure sensitive data. Filters are most useful for cross-cutting concerns that affect some or all of your queries. Consider using filters if you want a centralized system to: * Restrict queries to a subset of all documents\n* Omit sensitive data or unused fields ## Example In a voting app where some users have agreed to anonymously share their vote, you could use the following filter to constrain all queries to an anonymous subset of the existing data: ### Procedure You can define filters for specific collections in your linked cluster from the App Services UI or by deploying configuration files with Realm CLI: ## Note This guide requires a linked [MongoDB Atlas data source.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources)\n\n",
  "https://www.mongodb.com/docs/atlas/app-services/rules/sync-compatibility/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Device Sync-Compatible Permissions On this page * [Sync-Compatible Roles](#sync-compatible-roles)\n* [Sync-Compatible Expressions](#sync-compatible-expressions)\n* [Sync-Compatible Expansions](#sync-compatible-expansions)\n* [Permission Changes](#permission-changes)\n* [Unified Rules System](#unified-rules-system) When using [Device Sync (Flexible Mode)](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync), there are special considerations when using the permissions system. The older Partition-Based Sync uses a completely different permissions system. See [Partition-Based Rules and Permissions](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-rules-and-permissions) if you are using Partition-Based Sync. For a guide to setting up Flexible Sync with common permissions models, see the[Device Sync Permissions Guide.](https://mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/#std-label-flexible-sync-permissions-guide) ## Sync-Compatible Roles If Device Sync (Flexible Mode) is enabled, an assigned [role](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-roles) must be **Sync compatible**. If the role is not Sync compatible, but its \"apply when\" evaluated to true, other roles are not considered; access is denied. A role is not Sync compatible if any of the following conditions are true: * `document_filters.read` or `document_filters.write` are undefined.\n* A document filter, insert, or delete expression: - References a field that is not a [queryable field](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields)\\- Uses an expansion other than `%%true`, `%%false`, `%%values`, `%%environment`, or `%%user`\\- Uses the `%function` operator\n* Top-level `read`, top-level `write`, or field-level permissions are not boolean literals (`true` or `false`).\n* Field-level permissions are specified for the `_id` field. ### Sync-Compatible Expressions When Device Sync is enabled, expressions may only refer to the [queryable fields](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-queryable-fields) of your data model. If a role refers to any other fields, it becomes Sync incompatible and cannot be used with Device Sync. Because a Sync-enabled App assigns roles at the start of a Sync session before any specific documents are queried, you can't refer to a document or its field values in an \"apply when\" expression. ### Sync-Compatible Expansions When using Device Sync, some [expansions](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expansions) are not supported. The following table specifies which expansions are Sync compatible in either the \"apply when\" or rule expressions:\n\n ## Important App Services causes a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) if anything about the role changed since the previous session. At the start of a session, App Services expands all expansions in the \"apply when\", `document_filters.read`, and `document_filters.write` expressions and stores the result. This has the following implications: * If the value changes during a session, App Services continues to use the value as it was at the time of session start.\n* On the next session, if the value is different from what it was at the start of this session, App Services causes a client reset.\n* You cannot use the [%function](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-operator--function) operator in read and write rules. Functions would not operate on a per-document basis.\n* You cannot store permissions information (such as \"which document IDs may this user access?\") in the user object. ### Permission Changes If a user's permissions have changed since the last Sync session, Sync triggers a [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets) and re-downloads all data with the new permissions applied. A user's permissions might change in the following situations: * You [updated the Data Source configuration](https://mongodb.com/docs/atlas/app-services/reference/config/data%5Fsources/#std-label-appconfig-data%5Fsources) to modify the rules.\n* Your rules reference [custom user data](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) to determine permissions dynamically, and the value of that custom user data has changed since the last Sync session. A client reset will **not** be triggered in the following cases: * Adding a new collection to an App Services Schema and defining permissions for the new namespace or using default roles. This will not trigger a client reset because permissions have not been applied previously.\n* Configuring custom permissions for the new collection in the same [draft](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-ui) as the new schema. Conversely, deploying a draft with permission changes after you deploy the schema will lead to a client reset, since default permissions were applied in the initial deployment. ### Unified Rules System Prior to February 23, 2023, Device Sync (Flexible Mode) rules existed in the`permissions` field of the [Sync configuration](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-sync-configuration-reference). For new apps and automatically migrated apps, these permissions now exist in the same configuration files as the non-Sync permissions. For reference, the following changes take place in the migration (you should not have to migrate apps manually): * Move `permissions.defaultRoles` to the `default_rule.json` file in the data source configuration directory at `data_sources/<data-source-name>/`.\n* Move any collection-specific rules to the `rules.json` file in the respective collection configuration directories at`data_sources/<data-source-name>/<database-name>/<collection-name>/`.\n* Rename `defaultRoles` to `roles`.\n* Rename `applyWhen` to `apply_when`.\n* Move sync `read` and `write` into `document_filters.read` and`document_filters.write`. Ensure both `document_filters.read` and`document_filters.write` are defined.\n* Add the following to the roles, adjusting for your use case. You can only use`true` or `false`. Generally, you probably want `true`. The`document_filters` will restrict read and write access on a per-document level.  \n`| \"read\": true,   |  \n| --------------- |  \n| \"write\": true,  |  \n| \"insert\": true, |  \n| \"delete\": true, |  \n| \"search\": true  |  \n` This does not apply to apps using Partition-Based Sync. Their permissions configuration remains in the Sync configuration.\n\n",
  "https://www.mongodb.com/docs/atlas/app-services/security/developer-access/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Manage Developer Access To create, update, or delete an App, you must have access to the MongoDB Atlas project that contains the App. App Services determines developer access permissions for a given MongoDB Cloud user based on their assigned [project roles.](https://www.mongodb.com/docs/atlas/access/manage-project-access/) The following table describes the access permissions associated with a given project role: | Project Role    | Access Permissions                                               |\n| --------------- | ---------------------------------------------------------------- |\n| Project Owner   | Full read-write access for all Apps associated with the project. |\n| All Other Roles | Read-only access for all Apps associated with the project.       | ## Note For more information about adding users and teams to Atlas, see[Atlas Users and Teams.](https://www.mongodb.com/docs/cloud-manager/tutorial/manage-users/) ## Allow Non-Owner Access You cannot directly modify an App without the Project Owner role in your Atlas project. However, this role includes broad permissions that may be too permissive for your organization. To allow non-owners to modify an App, you can proxy the changes through a source control system or CI/CD pipeline with more fine-grained permissions. For example, you could enable [Automatic GitHub Deployment](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github) and have developers push changes to the repository instead of directly to the App. ← [Configure Network Security](https://mongodb.com/docs/atlas/app-services/security/network/ \"Previous Section\")[Monitor App Activity](https://mongodb.com/docs/atlas/app-services/activity/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/rules/roles/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Role-based Permissions On this page * [Overview](#overview)\n* [What are Permissions?](#what-are-permissions-)\n* [Document-Level Permissions](#document-level-permissions)\n* [Field-Level Permissions](#field-level-permissions)\n* [Read Permissions Flowchart](#read-permissions-flowchart)\n* [Write Permissions Flowchart](#write-permissions-flowchart)\n* [Roles](#roles)\n* [How App Services Assigns Roles](#how-app-services-assigns-roles)\n* [Without Device Sync](#without-device-sync)\n* [With Device Sync](#with-device-sync)\n* [Apply When Expressions](#apply-when-expressions)\n* [Document Filters](#document-filters)\n* [Role Order](#role-order)\n* [Sync Compatibility](#sync-compatibility)\n* [Define Roles & Permissions](#define-roles---permissions) ## Overview You secure your App's data by defining **roles** that are automatically assigned to incoming user requests and Device Sync sessions. Each role has fine-grained data access permissions and dynamic conditions that determine when the role applies. For examples of how you might configure permissions for common scenarios with Device Sync, see the [Device Sync Permissions Guide.](https://mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/#std-label-flexible-sync-permissions-guide) If you're using the older Partition-Based Device Sync, rules and roles work differently. To configure Partition-Based Sync permissions, see[Partition-Based Sync Permissions.](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync-permissions) ### What are Permissions? A **permission** is a status that Atlas App Services assigns to individual users to control what they can and cannot do with your app's data. App Services uses both document-level and field-level permissions: * [Document-level permissions](#std-label-document-level-permissions)control whether a user can insert, delete, modify, and search for a specific document in a MongoDB collection.\n* [Field-level permissions](#std-label-field-level-permissions)control whether a user can read or write the data in specific fields of a document. ### Document-Level Permissions A role's document-level permissions determine which actions that affect the entire document can be performed. These permissions always apply to the entire document regardless of the content. A role can have the following document-level permissions: * **Insert**: You can insert new documents.\n* **Delete**: You can delete existing documents.\n* **Search**: You can search for the document using [Atlas Search.](https://www.mongodb.com/docs/atlas/atlas-search/#std-label-fts-top-ref) ### Field-Level Permissions A role's field-level permissions determine whether a user can read or write fields within the document. These permissions only affect the field they apply to, so a user can have read or write access to only a subset of the entire document. You can define field-level permissions for specific fields and default read/write permissions for any additional fields that you don't explicitly define. ### Read Permissions Flowchart The following diagram shows how App Services determines whether a user can read a given document: ![Read permissions flowchart](https://mongodb.com/docs/atlas/app-services/images/rules-read.png) click to enlarge ### Write Permissions Flowchart The following diagram shows how App Services determines whether a user can write a given document: ![Write permissions flowchart](https://mongodb.com/docs/atlas/app-services/images/rules-write.png) click to enlarge ## Roles A **role** is a named set of permissions that a user may have for documents in a MongoDB collection. A role has an \"apply when\" [expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions)that determines whether App Services should assign the role to a user. Roles also have a set of document- and field-level permissions that a user has when assigned the role.\n\n ## Example Consider a collection named `employees` where each employee has their own document with all of their employment data. This collection might have two roles: **Employee** and **Manager**. We're not using Device Sync, so App Services selects a role on a per-document basis. * If a user requests their own document, their role is **Employee**. An employee can read and write their own data but can't create or delete their own documents.\n* If a user requests a document for someone whose name is listed in the user's `manages` arrays, their role is **Manager**. A manager can read and write their direct reports' data and can create and delete their documents.\n* If a user is neither an **Employee** nor a **Manager** for a given document, then they have no role and cannot read, write, or search that document. ### How App Services Assigns Roles App Services assigns roles at different times depending on whether you're using[Device Sync (Flexible Mode)](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync) or not. When using Device Sync, App Services assigns roles at the start of a Sync session for each collection to be synced; otherwise, App Services assigns roles on a per-document basis. A Sync session is the period of time between opening and closing a Sync connection. Whether using Device Sync or not, you can define a set of roles that are specific to collections and default roles that apply to any other unspecified collection. To assign a role, App Services evaluates each role's \"apply when\" expression in the order that you specified them. The first role whose \"apply when\" expression evaluates to true becomes the assigned role. If no role matches, access is denied. ![Role Assignment Flowchart](https://mongodb.com/docs/atlas/app-services/images/rules-role-assignment.png) click to enlarge ### Without Device Sync When not using Device Sync, App Services dynamically assigns roles for every document. The user is assigned a separate role, or no role, for each document that matches the incoming query. First, your App evaluates and applies [filters](https://mongodb.com/docs/atlas/app-services/rules/filters/#std-label-filters) and then runs the query. ## Example The following request causes App Services to evaluate a role for every document in the`restaurants` collection where the `city` field is set to `\"Chicago\"`: `| db.restaurants.updateMany(            |\n| ------------------------------------- |\n| { \"city\": \"Chicago\" },                |\n| { \"$set\": { \"city\": \"Chicago, IL\" } } |\n| );                                    | ` For each document returned by the query, your App evaluates possible roles in [role order](#std-label-role-order) and assigns the first applicable role, if any. A role applies to a given document if its \"apply when\"[expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) evaluates to `true` when run against the document. The set of roles that a user can use for a given request depends on the collection they're accessing. If the collection has a set of collection-level roles defined, then a user may have any of those roles. If there are no collection-level roles, the request falls back to the data source's default roles. ## Example An employee will always be on their own team, so both the **Employee** and**Teammate** roles apply to them for their own document. However, they can use only one role, so we want to use **Employee** because it's more specific. To configure this, specify **Employee** earlier than **Teammate** in the collection's role definitions: ### With Device Sync When using Device Sync, App Services assigns roles at the beginning of each Flexible Sync session for each synced collection. The role determines which permissions apply to each collection for the duration of a session. App Services assigns at most one role per collection. If you did not specify roles for a given synced collection, App Services uses the default roles instead. If no role applies for a collection, the user cannot sync (or read or write) any entries in that collection.\n\n There are some special considerations when using Device Sync with regard to the permissions system. See [Device Sync-Compatible Permissions.](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/#std-label-device-sync-compatibility) For a guide to setting up Flexible Sync with common permissions models, see the[Device Sync Permissions Guide.](https://mongodb.com/docs/atlas/app-services/sync/app-builder/device-sync-permissions-guide/#std-label-flexible-sync-permissions-guide) ### Apply When Expressions A role's \"apply when\" expression is a [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that determines whether the role should be assigned. You can use expression variables to make roles dynamic. For example, you can use the[%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user) expansion to refer to the specific user that issued the request. This lets you customize your data access permissions on a per-user basis. When not using Device Sync, you can refer to the current document for which a role is being assigned. For example, you can use [%%root](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---root). This lets you customize your data access permissions on a per-document basis. ### Document Filters The role's `document_filters` expressions determine whether the role's subsequent document- and field-level permissions may be evaluated at all. This is required for Device Sync. Note: App Services evaluates document filters on a per-document basis. These are not to be confused with the top-level query [filters.](https://mongodb.com/docs/atlas/app-services/rules/filters/#std-label-filters) ### Role Order The roles for a given collection each have a position that determines the order in which they are evaluated and applied. Each role's apply when expression is evaluated in role order until a role applies or no roles remain. A user may only have one role per document in a given query. Role order determines which role applies in the event that multiple roles' \"apply when\" expressions are true. Therefore, when defining roles, put the most specific roles first. ### Sync Compatibility If Device Sync (Flexible Mode) is enabled, an assigned role must be **sync compatible**. See [Sync-Compatible Roles](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/#std-label-sync-compatible-roles) for details. ## Define Roles & Permissions You can configure your app's data access rules from the App Services UI or by deploying configuration files with Realm CLI: ← [Define Data Access Permissions](https://mongodb.com/docs/atlas/app-services/rules/ \"Previous Section\")[Rule Expressions](https://mongodb.com/docs/atlas/app-services/rules/expressions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/security/network/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure Network Security On this page * [Overview](#overview)\n* [Transport Layer Security (TLS)](#transport-layer-security--tls-)\n* [Firewall Configuration](#firewall-configuration)\n* [AWS](#aws)\n* [Azure](#azure)\n* [GCP](#gcp)\n* [Communicate from the Client to the Sync Server](#communicate-from-the-client-to-the-sync-server)\n* [Allowed Request Origins](#allowed-request-origins)\n* [IP Access List](#ip-access-list)\n* [Find Your IP Address](#find-your-ip-address)\n* [View IP Access List Entries](#view-ip-access-list-entries)\n* [Create an IP Access List Entry](#create-an-ip-access-list-entry)\n* [Edit an IP Access List Entry](#edit-an-ip-access-list-entry)\n* [Delete an IP Access List Entry](#delete-an-ip-access-list-entry)\n* [API Access List](#api-access-list) ## Overview App Services uses a range of network security protocols to prevent unauthorized access to your data. You can: * Configure TLS to secure network requests to and from your application.\n* Define IP addresses from which all outbound requests originate.\n* Define and manage URLs and IP addresses from which inbound requests may originate. ## Transport Layer Security (TLS) App Services uses [TLS 1.3](https://datatracker.ietf.org/doc/html/rfc8446)to secure all network requests to and from your application, including: * Apps that connect from a Realm SDK.\n* Data API and GraphQL requests sent over HTTPS.\n* Queries and operations on a linked MongoDB Atlas data source. The TLS certificate is pre-defined and cannot be customized or disabled. ## Firewall Configuration App Services only sends outbound requests from a set list of IP addresses. The exact list depends on the cloud provider that the app server is deployed to. You can copy the IP addresses listed in this section to an allowlist for incoming requests on your firewall. You can download a computer-friendly list of all IP addresses used by App Services in [JSON](https://www.mongodb.com/docs/realm-sdks/mongodb/AtlasAppServicesPublicIPs.json)or [CSV](https://www.mongodb.com/docs/realm-sdks/mongodb/AtlasAppServicesPublicIPs.csv)format. You can also find cloud-provider-specific JSON and CSV files in the following sections. ## Note If you run a function from the Atlas App Services UI, the request originates from the server nearest to you, not the region the app is deployed to. ### AWS Download AWS IP Addresses: [JSON](https://www.mongodb.com/docs/realm-sdks/mongodb/AtlasAppServicesPublicIPsAWS.json), [CSV](https://www.mongodb.com/docs/realm-sdks/mongodb/AtlasAppServicesPublicIPsAWS.csv) Outbound requests from an app deployed to AWS will originate from one of the following IP addresses: AWS outbound IP addresses\n\n ` ### Azure Download Azure IP Addresses: [JSON](https://www.mongodb.com/docs/realm-sdks/mongodb/AtlasAppServicesPublicIPsAzure.json), [CSV](https://www.mongodb.com/docs/realm-sdks/mongodb/AtlasAppServicesPublicIPsAzure.csv) Outbound requests from an app deployed to Azure will originate from one of the following IP addresses: Azure outbound IP addresses ``` 20.105.25.17 20.212.99.191 20.24.112.135 20.53.104.226 20.84.232.59 20.96.47.95 40.112.209.0 52.149.111.83 \n``` ### GCP Download GCP IP Addresses: [JSON](https://www.mongodb.com/docs/realm-sdks/mongodb/AtlasAppServicesPublicIPsGCP.json), [CSV](https://www.mongodb.com/docs/realm-sdks/mongodb/AtlasAppServicesPublicIPsGCP.csv) Outbound requests from an app deployed to GCP will originate from one of the following IP addresses: GCP outbound IP addresses ``` 34.150.239.218 34.69.118.121 34.78.133.163 34.82.246.143 34.93.58.231 \n``` ## Note The above IP lists only apply to outgoing requests from Atlas Functions, including triggers and HTTPS endpoints that make outgoing requests. For requests that originate from the Sync server, we recommend allowlisting the entire subnet of the App's Deployment Region and cloud provider. You can find the Deployment Region in the App Services UI under App Settings > General > Deployment Region. ## Communicate from the Client to the Sync Server When you use Device Sync, you can use DNS filtering to allow connections from the Sync client to the Sync server. Using DNS filtering, you can access`*.realm.mongodb.com` via HTTPS or port 443. ## Allowed Request Origins You can define this [configuration option](https://mongodb.com/docs/atlas/app-services/reference/config/app/#std-label-appconfig-app) in the app-level `realm_config.json` file. This field accepts an array of URLs that incoming requests may originate from. If you define any allowed request origins, then App Services blocks any incoming request from an origin that is not listed. ## IP Access List App Services allows client requests from the enabled entries in the app's[IP access list](#std-label-manage-ip-access). Allowed requests will still use App Services's authentication and authorization rules. When you add IP access list entries, App Services blocks any request originating from an IP that is not on the access list. ## Important By default, any newly-created App allows access from any client IP by adding an access list entry for 0.0.0.0/0\\. If you delete this entry, no client can access your App from any IP address. ### Find Your IP Address ### View IP Access List Entries ### Create an IP Access List Entry ### Edit an IP Access List Entry ### Delete an IP Access List Entry ## API Access List When you [create an Atlas API key](https://www.mongodb.com/docs/atlas/configure-api-access/#std-label-atlas-prog-api-key)for project or organization access from the Realm CLI or the App Services Admin API, you can specify IP addresses that can use this API key. If you specify an IP address, App Services blocks any request originating from an IP address that is not on the access list. ## Note ### Backend Encryption All internal communication between App Services and Atlas is encrypted with x509 certificates. ← [Secure Your App](https://mongodb.com/docs/atlas/app-services/security/ \"Previous Section\")[Manage Developer Access](https://mongodb.com/docs/atlas/app-services/security/developer-access/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Deployment Models & Regions On this page * [Overview](#overview)\n* [Deployment Models](#deployment-models)\n* [Global Deployment](#global-deployment)\n* [Local Deployment](#local-deployment)\n* [Cloud Deployment Regions](#cloud-deployment-regions) ## Overview When you first create an App, you must select a[deployment type](#std-label-realm-deployment-models) that determines where your application's data is stored and processed. You can deploy your App globally or limit the deployment to a specific[cloud deployment region.](#std-label-deployment-regions) ## Deployment Models ### Global Deployment A globally deployed App is hosted across the world in all of the following AWS regions: * Ireland (IE) - `aws-eu-west-1`\n* Oregon (US-OR) - `aws-us-west-2`\n* Sydney (AU) - `aws-ap-southeast-2`\n* Virginia (US-VA) - `aws-us-east-1` An App can handle most types of requests from any region. For example, any region can run serverless functions, evaluate rules, validate object schemas, or authenticate users. All write operations to a linked MongoDB data source are handled within a single region that you specify when you create the App. You can choose any global region to handle writes, but should generally choose the region closest to your MongoDB cluster. If a server in another region needs to handle a write request, it forwards the request to the configured write region, which adds latency to the write operation. Realm SDKs automatically execute application requests, such as reading user information or calling a function, in the global deployment region that's closest to the user that issued the request. Requests sent to a global URL (e.g. with the Data API or GraphQL) are forwarded to the closest server at the DNS level. Requests sent to a region-specific URL execute in that region regardless of the user's location. ### Local Deployment A locally deployed App is available in a single cloud provider region. All requests and MongoDB write operations are handled exclusively in the region, which you specify when you create the App. You can deploy to any region, but should generally choose the region closest to your application's users. ## Cloud Deployment Regions You can deploy your App to cloud regions hosted around the world by the major cloud providers. Support for a given region depends on your [deployment model](#std-label-realm-deployment-models). Global deployment has fewer supported regions than local deployment. If you don't specify a region when creating or configuring your App, App Services selects the region geographically closest to your selected data source. App Services supports the following regions:\n\n ← [Change Deployment Models](https://mongodb.com/docs/atlas/app-services/apps/change-deployment-models/ \"Previous Section\")[Authenticate & Manage Users](https://mongodb.com/docs/atlas/app-services/users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/rules/expressions/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Define Data Access Permissions ## Overview In traditional applications, an application server exposes an API to client applications and handles database queries on their behalf. To prevent malicious, improper, or incorrect read and write operations, clients don't query the database directly. Atlas App Services provides a configurable and dynamic permissions engine that enables you to run a MongoDB query from client applications while transparently preventing unauthorized reads and writes. Permissions are defined for entire collections in a linked MongoDB Atlas cluster and apply to individual documents in the collection dynamically based on the [application user](https://mongodb.com/docs/atlas/app-services/users/) that issues a query or uses Device Sync. You can also define default rules that serve as a fallback for any collection that doesn't have its own rules. ## Note Federated data sources [do not support rules or schemas](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats). You can only access a Federated data source from a system function. ## Key Concepts To understand how the permissions engine works and how to configure it for your use case, see [Role-based Permissions.](https://mongodb.com/docs/atlas/app-services/rules/roles/) You define permissions with [Rule Expressions](https://mongodb.com/docs/atlas/app-services/rules/expressions/), a domain-specific language built on JSON. You can optimize the performance of the permissions engine with filters. See[Filter Incoming Queries.](https://mongodb.com/docs/atlas/app-services/rules/filters/) If you're using Device Sync (Flexible Mode), permissions work a bit differently. See [Device Sync-Compatible Permissions](https://mongodb.com/docs/atlas/app-services/rules/sync-compatibility/) for important considerations. The default or \"Basic Mode\" rules editor in the App Services UI covers the majority of use cases for collection rules. However, there are times when you need more fine-grained control than the UI interface provides. In those times, see [Configure Advanced Rules.](https://mongodb.com/docs/atlas/app-services/mongodb/configure-advanced-rules/) Finally, to help you put these concepts into practice, we have provided some[Data Access Role Examples.](https://mongodb.com/docs/atlas/app-services/rules/examples/) ← [Access a Value](https://mongodb.com/docs/atlas/app-services/values-and-secrets/access-a-value/ \"Previous Section\")[Role-based Permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/deploy-github/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Deploy Automatically with GitHub On this page * [Overview](#overview)\n* [Prerequisites](#prerequisites)\n* [Enable Automatic Deployment with GitHub](#enable-automatic-deployment-with-github)\n* [Install the Atlas App Services GitHub App](#install-the-atlas-app-services-github-app)\n* [Specify a GitHub Repository](#specify-a-github-repository)\n* [Initialize the Repository](#initialize-the-repository)\n* [Enable Automatic Deployment](#enable-automatic-deployment)\n* [Make Changes to Your Application](#make-changes-to-your-application)\n* [Commit and Push Your Changes](#commit-and-push-your-changes)\n* [Make Changes from the UI](#make-changes-from-the-ui)\n* [Avoid Making Changes from the CLI](#avoid-making-changes-from-the-cli)\n* [Summary](#summary) ## Overview You can configure an Atlas App Services App to automatically deploy whenever you push App configuration files to a [GitHub](https://github.com/)repository. You can clone the GitHub repository to your computer and then use standard Git commands to pull down the latest versions and deploy new changes. ## Prerequisites * A [GitHub](https://github.com/) account and repository. The repository should either be empty or contain an exported configuration directory for an existing App. For information on how to create an empty repository, see GitHub's [create a repo](https://help.github.com/en/articles/create-a-repo) guide.\n* An installed copy of the Git CLI. If you do not have `git`installed, see the official guide for [Installing Git](https://git-scm.com/book/en/v1/Getting-Started-Installing-Git).\n* A [MongoDB Atlas](https://www.mongodb.com/realm?tck=docs%5Frealm#atlas-form-container) [Programmatic API Key](https://www.mongodb.com/docs/atlas/configure-api-access/#programmatic-api-keys)to authenticate and authorize access to your app's underlying Git repo. If you have not yet generated a programmatic API key for your Atlas organization, do so now. ## Enable Automatic Deployment with GitHub 1 ### Install the Atlas App Services GitHub App In order to automatically deploy based on a GitHub repository, Atlas App Services requires that you install a GitHub app that has, at minimum, read access to the repository. To install the app, click Deployment in the left navigation menu of the App Services UI. Select the Configuration tab and then click Install App Services on GitHub. A new browser window will open to the GitHub application installation flow. ## Note ### GitHub Authentication GitHub may require you to provide your GitHub account credentials before you can install the app. Select the GitHub account or organization for which you want to install the app: ![GitHub Application install location screen](https://mongodb.com/docs/atlas/app-services/images/github-app-install-location.png) Specify one or more repositories for which you want to grant App Services read access. You can either select specific repositories or grant access to all of your repositories on GitHub. Select the repositories you want to use and then click Install. ![GitHub Application permissions request screen](https://mongodb.com/docs/atlas/app-services/images/github-app-install-permissions.png) After you install the application, click Authorize to finish connecting App Services to GitHub. This leads you to a github permissions screen, where you will click Authorize App Services. ![GitHub Application authorization request screen](https://mongodb.com/docs/atlas/app-services/images/authorize-mdb-realm-github.png) ## Note ### GitHub Permissions You can manage permissions for the App Services GitHub application from the [Installed GitHub Apps](https://github.com/settings/installations) page in your GitHub settings. 2 ### Specify a GitHub Repository Once you have linked your GitHub account to your App, you can specify a repository that App Services should automatically deploy. Specify theRepository, Branch, and Directory that contain the App's configuration files and then click Save.\n\n ## Note The list of repositories will only contain repos that you have granted App Services read access to. 3 ### Initialize the Repository Clone a local copy of the Git repository that you specified: `| git clone https://github.com/<organization>/<repo>.git |\n| ------------------------------------------------------ | ` The configured branch and directory must contain configuration files that define your application. You can create the configuration manually or [export the application directory](https://mongodb.com/docs/atlas/app-services/apps/export/#std-label-export-app) of an existing app. Add the application directory to the repository and then commit the changes: ```shell git add -A git commit -m \"Adds App Services Application Directory\" \n``` Once you have committed the latest version of the application to the repository, push it to your GitHub repository: ```shell git push origin <branch name> \n``` 4 ### Enable Automatic Deployment After you have specified a repository to deploy and initialized it with the latest version of your app, you need to enable automatic deployment to begin deploying it. On the Configuration tab of the Deploypage, click Enable Automatic Deployment. In the modal that appears, click Enable Automatic Deployment to confirm your selection. ![Enable Automatic GitHub Deployment in the App Services UI](https://mongodb.com/docs/atlas/app-services/images/enable-automatic-deployment.png) 5 ### Make Changes to Your Application A deployment contains one or more changes that you have made to your application since the previous deployment. Make any additions, modifications, or deletions to the repository that you want to include in your deployment. Refer to the [App Configuration](https://mongodb.com/docs/atlas/app-services/reference/config/#std-label-app-configuration) reference page and individual component reference pages for details on the structure and schema of your application directory. ## Important ### Do not make breaking schema changes via automated deploy Because [breaking - also called destructive - schema changes](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-destructive-changes-synced-schema) require special handling, App Services does not support making breaking schema changes via automated deploy with GitHub. Instead, you should make breaking changes from the App Services UI. 6 ### Commit and Push Your Changes Once you have updated your application configuration, you can deploy the updates as a new version of your App by pushing them to the GitHub repo that you specified. If Automatic GitHub Deployment is enabled, App Services immediately deploys the latest commit for the configured branch and directory. When you are ready to deploy, commit all of the files that you want to include and then push them to GitHub: ```shell git add -A git commit -m \"<commit message>\" git push origin <branch name> \n``` Once you successfully push your changes to GitHub, App Services immediately deploys a new version of your application that matches the state of the latest commit. Client applications will automatically use the newest version, so make sure that you also update your client code to use the new version if necessary. ## Note ### Deployment History You can see the currently deployed version of your application as well as a historical log of previous deployments in the [Deployment History](https://mongodb.com/docs/atlas/app-services/apps/#std-label-deployment-history) table in the App Services UI. ## Make Changes from the UI Automatic GitHub deployment does not prevent you from making changes to your App from the App Services UI. You can make changes to your app via the UI, and App Services automatically commits changes back to your linked GitHub repository. ## Tip If your linked GitHub repository contains new commits that are not reflected in your App Services UI changes, App Services can't automatically commit those changes to your repo. However, you can use theExport button to download the updated configuration files to your local machine, and then you push them manually to your GitHub repository. When changes are committed to your linked GitHub repository, you'll see aCommit: <commit-hash> link in your app's Deployment History. ![GitHub repository selection](https://mongodb.com/docs/atlas/app-services/images/deploy-history-link-to-github-commit.png) You can click that link to view the commit in GitHub. The `mongodb-realm`bot appears as the commit author. ![GitHub repository selection](https://mongodb.com/docs/atlas/app-services/images/realm-ui-deploy-changes-in-github.png) ## Avoid Making Changes from the CLI With automatic GitHub deployment enabled, avoid making changes to your app with Realm CLI because:\n\n ## Summary * You can deploy your App by modifying a repo hosted on GitHub.\n* While Automatic GitHub Deployment is enabled, App Services immediately deploys the latest commit. To deploy, commit your changes locally, then push them to your repo on GitHub.\n* When you make changes via the App Services UI after enabling Automatic GitHub Deployment, those changes are automatically committed back to your linked repository.\n* Do not use Realm CLI to update configuration files after enabling Automatic GitHub Deployment. ← [Configure an App Environment](https://mongodb.com/docs/atlas/app-services/apps/environment/ \"Previous Section\")[Set Up a CI/CD Pipeline](https://mongodb.com/docs/atlas/app-services/apps/cicd/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/metadata/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Get App Metadata On this page * [Find Your App ID](#find-your-app-id)\n* [Find Your Atlas Project ID](#find-your-atlas-project-id) ## Find Your App ID Every App has a unique ID. You use App IDs to specify which app you want to use or modify. You can find your Project ID in the App Services UI or use the Admin API or App Services CLI to find it programmatically. ## Find Your Atlas Project ID Every App is associated with a single Atlas project. You use the project's unique Project ID value, sometimes referred to as a \"Group ID\", to identify and work with your App programatically. You can find your Project ID in the Atlas UI or use the Atlas Admin API or Atlas CLI to find it programmatically. ← [Create an App](https://mongodb.com/docs/atlas/app-services/apps/create/ \"Previous Section\")[Update an App](https://mongodb.com/docs/atlas/app-services/apps/update/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/rollback/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Roll Back a Deployment On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Procedure](#procedure)\n* [View Your App's Deployment History](#view-your-app-s-deployment-history)\n* [Redeploy a Deployment](#redeploy-a-deployment)\n* [Confirm Rollback Success](#confirm-rollback-success)\n* [Authenticate a MongoDB Atlas User](#authenticate-a-mongodb-atlas-user)\n* [Find the Deployment ID](#find-the-deployment-id)\n* [Redeploy the App](#redeploy-the-app) ## Overview You can roll back an App's configuration to a previously deployed version. App Services can automatically redeploy any of an App's 25 most recent deployments. For older deployments, you must manually get and deploy the configuration files (e.g. from source control). A redeploy rolls back your application's configuration to match the earlier version. It does not modify or redeploy your [hosted files.](https://mongodb.com/docs/atlas/app-services/hosting/#std-label-static-hosting) ## Before You Begin ## Procedure ← [Delete an App](https://mongodb.com/docs/atlas/app-services/apps/delete/ \"Previous Section\")[Export an App](https://mongodb.com/docs/atlas/app-services/apps/export/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/change-deployment-models/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Change Deployment Models On this page * [Overview](#overview)\n* [Run a Deployment Migration](#run-a-deployment-migration)\n* [Before You Begin](#before-you-begin)\n* [Procedure](#procedure)\n* [Deployment Migration Process](#deployment-migration-process) ## Overview You can change an existing App's deployment configuration to deploy it in a new model, region, and/or cloud provider. For example, you might switch your App from a global deployment to a specific local AWS region or switch an App deployed in the Eastern USA from AWS to Azure. For a list of all available options, see [Deployment Models & Regions.](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-model) To move an existing App, you begin a **Deployment Migration** that automatically moves your App's data and configuration to the new configuration. The migration process is designed to be as seamless as possible but requires up to 30 minutes of downtime. You can monitor the migration status but no requests will be processed until the migration is complete. For more information, see [Deployment Migration Process.](#std-label-deployment-migration-process) If you connect to your App from a Realm SDK, you must update your SDK to a version that supports changing deployment models. If you change deployment models before upgrading, the SDK will not be able to connect and requests will fail. ## Important ### Contact MongoDB Support We recommend that you contact MongoDB technical support if you are planning to change your deployment model for a production App. To learn how, visit the [MongoDB Support](https://www.mongodb.com/support) portal. ## Run a Deployment Migration You can begin a deployment migration at any time. Only one migration may be in progress at a time for a single App. If you try to start a migration while another is in progress, the new migration does not run and fails with an error. ### Before You Begin ### Procedure ## Deployment Migration Process Deployment migrations move your App's data and configuration to one or more new regions in a series of stages. At each stage, the process migrates a portion of your App to the new model and cleans up any artifacts from the previous model. A deployment migration moves through the following stages in order: 1. `\"started\"`: the migration has been started\n2. `\"downtime\"`: the App is unavailable while the migration is in progress\n3. `\"enabling_event_subscriptions\"`: the App's Triggers and Device Sync translators are being enabled\n4. `\"cleanup\"`: deployment artifacts are being cleaned up\n5. The migration is complete and can be in one of two states:  \n   * `\"successful\"`: the migration completed successfully  \n   * `\"failed\"`: the migration failed The migration process does not affect any application data stored in a MongoDB Atlas cluster. The migration process migrates the following components of your App: * User accounts\n* App configuration files\n* Triggers\n* API Services\n* Device Sync translators The migration process **does not** migrate the following data: * Application logs\n* Deployment drafts\n* Data stored in a MongoDB Atlas cluster ← [Set Up a CI/CD Pipeline](https://mongodb.com/docs/atlas/app-services/apps/cicd/ \"Previous Section\")[Deployment Models & Regions](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/export/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Export an App On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Procedure](#procedure)\n* [Output](#output) ## Overview You can download a directory of your App's configuration files by exporting them. This allows you to save your App's configuration in source control and to work locally with Realm CLI and your preferred text editor. The exported directory contains configuration files for most components of your App, including Data Sources, Functions, Triggers, and other services. For more information on the contents of an exported App, see[App Configuration.](https://mongodb.com/docs/atlas/app-services/reference/config/#std-label-app-configuration) The export does not include any [Secrets](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-secret). If you create a new App based on exported configuration files, you must manually add Secrets to the new App. For more information, see[Copy an App.](https://mongodb.com/docs/atlas/app-services/apps/copy/#std-label-copy-app) ## Before You Begin ## Procedure ## Output An exported App contains configuration files for every component of the App. For detailed information about each type of configuration file, see[App Configuration.](https://mongodb.com/docs/atlas/app-services/reference/config/#std-label-app-configuration) An exported configuration directory has the following structure:\n\n ` ← [Roll Back a Deployment](https://mongodb.com/docs/atlas/app-services/apps/rollback/ \"Previous Section\")[Configure an App Environment](https://mongodb.com/docs/atlas/app-services/apps/environment/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/update/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Update an App On this page * [Overview](#overview)\n* [Update an Existing App](#update-an-existing-app)\n* [Deployment Drafts](#deployment-drafts) ## Overview You can update an existing App by changing its underlying configuration and then deploying those changes. There are multiple ways you can do this: * The App Services Admin UI: a web application built into MongoDB Atlas. It includes a graphical interface for anything you want to configure in your App.\n* The Realm CLI: a command line tool that you can use to configure and deploy your App locally. You work directly with your App's underlying[configuration files.](https://mongodb.com/docs/atlas/app-services/reference/config/#std-label-app-configuration)\n* The Admin API: a REST API that you can use to configure and deploy your App programmatically. Admin API requests read and write your App's underlying configuration files.\n* Automatic GitHub Deployment: a GitHub integration that syncs your App configuration with a GitHub repository. You can use GitHub to manage your App's configuration files and deploy your App by pushing changes to the repository. ## Update an Existing App ### Before You Begin ### Procedure ## Deployment Drafts A deployment draft is a set of one or more updates to your App that you can apply or discard as a single group. Deploying a draft is useful when your changes include services or functions that interact with each other. The App Services UI uses deployment drafts by default. While enabled, any changes you make to your App's configuration in the App Services UI are added to a draft that you [manually deploy](#std-label-deploy-ui). You can [disable UI drafts](#std-label-disable-deployment-drafts) if you prefer to deploy immediately when you save in the UI. The Realm CLI and [GitHub Deployment](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github) both automatically create and deploy drafts for you. When you run the CLI[push](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-push/#std-label-realm-cli-push) command or `git push` to your deployment branch, the CLI or GitHub app creates a diff of your local configuration files against the currently deployed configuration. Then it creates and deploys a draft based on the diff. The App Services Admin API allows you to manually create and deploy drafts. To learn how, see [Deploy a Group of Changes.](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#tag/deploy/Draft-and-Deploy-a-Group-of-Changes) ### Draft Conflicts Avoid having multiple users make conflicting changes in UI or API drafts at the same time. If there are multiple concurrent drafts that contain conflicting changes, you will not be able to deploy one or more of the drafts. For example, if you deploy changes through the API but have an existing UI draft with conflicting changes, your UI draft will become invalid and you will not be able to deploy it. To recover from a conflict, you can download configuration files for a UI draft from the Deployment page. You can use these as a reference to reapply changes in the UI or deploy the changes directly with the CLI or Admin API. ### Disable UI Deployment Drafts You can disable UI drafts if you prefer to deploy immediately when you save in the UI. This setting does not prevent you from manually creating drafts with the Admin API. ← [Get App Metadata](https://mongodb.com/docs/atlas/app-services/apps/metadata/ \"Previous Section\")[Copy an App](https://mongodb.com/docs/atlas/app-services/apps/copy/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/cicd/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Set Up a CI/CD Pipeline On this page * [Overview](#overview)\n* [Pipeline Stages](#pipeline-stages)\n* [Development](#development)\n* [Staging](#staging)\n* [Production](#production)\n* [Build Tasks](#build-tasks)\n* [Configure the Environment](#configure-the-environment)\n* [Set Up Realm CLI](#set-up-realm-cli)\n* [Create an App](#create-an-app)\n* [Update an App](#update-an-app)\n* [Run Tests Against the App](#run-tests-against-the-app)\n* [Clean Up the Job](#clean-up-the-job) ## Overview Many developers use [continuous integration, delivery, and deployment pipelines](https://en.wikipedia.org/wiki/CI/CD) to automatically test and publish their applications whenever they make changes. This is most common and useful for larger apps where multiple people work on the codebase in parallel using a shared version control system like git. This guide covers the high level stages common to most CI/CD pipelines and describes what you might do in each stage. Further, it includes a list of common tasks and actions you might perform within your pipelines to configure and test your Atlas App Services Apps. ## Tip ### See a real example with GitHub Actions If you'd like to see an example CI/CD pipeline that manages testing, deployment, and other tasks for a real application, check out the article[How to Build CI/CD Pipelines for App Services Apps Using GitHub Actions](https://www.mongodb.com/developer/how-to/build-ci-cd-pipelines-realm-apps-github-actions/)on the MongoDB Developer Hub. ## Pipeline Stages At a high level most pipelines share a common pattern of moving through multiple stages that each handle different concerns. ### Development The Development stage is the first step for creating new features and fixing bugs in an App. In this stage you work with your application's configuration files and source code to implement your desired changes. To develop new features for an existing app: 1. Fork the main app and [deploy a new development copy](#std-label-sdlc-create-app). This instance will have a different App ID than your production app. You can also use [environment value templates](https://mongodb.com/docs/atlas/app-services/reference/config/template-expansions/#std-label-config-expansions) to use development data sources and other services that are not linked to production.\n2. Develop your application. This could involve updating or adding a client app screen, adding a new database trigger, or any other application features. You can use [Development Mode](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) if you need to make changes to your synced Realm Object Schema.\n1. Run automated tests locally to ensure that your code does not introduce any new errors. Tests that pass locally do not guarantee that your app is free of integration bugs, but increase confidence that your changes do not include any regressions or unintended behavior. ### Staging The Staging stage, which you might also call QA (Quality Assurance), Testing, or Pre-Production, is a step that simulates your development changes in an environment that is as similar to production as possible. This gives you a usable version of your app for review and can help you catch integration bugs with live services without affecting production data. The specifics of your staging deployment depend on your application's needs. However, you can use the following high level procedure to set it up:\n\n ### Production The Production stage is the final deployment step where your modified app is deployed into your production environment. Ideally at this stage you have already tested your changes locally and in staging to confirm that they are safe to deploy. You can either deploy to production manually or automatically as part of your CI/CD workflow by [updating your production app.](#std-label-sdlc-update-app) ## Build Tasks This section outlines common tasks that you will perform in your CI/CD pipeline. You may not always do all of these tasks depending on your use case and pipeline stage, but in general most pipelines will perform all of these at least once. ### Configure the Environment The configuration and code for your app should generally be similar between development stages. However, you'll want to change the value of certain configuration options depending on the environment. Determine what stage you're building and set the appropriate configuration values. For example, you might configure the app with the App ID of a new app in the Development stage or use your production App ID in the Production stage. `| # Use the production App ID for the main branch                                    |\n| ---------------------------------------------------------------------------------- |\n| export REALM_APP_ID=\"myapp-abcde\"                                                  |\n| # Use a staging App ID for the QA branch                                           |\n| export REALM_APP_ID=\"myapp-staging-fghij\"                                          |\n| # Use a new App ID for development branches - you'll need to create the app first! |\n| export REALM_APP_ID=\"myapp-dev-zyxwv\"                                              | ` ## Tip ### Find Your App ID You might not always be able to hardcode your App ID. You can look up a specific App ID with Realm CLI. For an example, see [Create an App.](#std-label-sdlc-create-app) ### Set Up Realm CLI [Realm CLI](https://mongodb.com/docs/atlas/app-services/cli/#std-label-realm-cli) is the easiest way to programmatically create, configure, and manage App Services Apps. You should [install](https://mongodb.com/docs/atlas/app-services/cli/#std-label-install-realm-cli)and use the latest version in your deployment scripts. ```bash npm install -g mongodb-realm-cli \n``` You'll also need a MongoDB Atlas public/private API key pair to authenticate and use the CLI. For more information and a walkthrough of how to get an API key, see [Programmatic API Keys.](https://www.mongodb.com/docs/atlas/configure-api-access/#programmatic-api-keys) To log in, save your API keys in a new named profile configuration and then log in with that profile: \\~/.config/realm-cli/<Profile Name>.yaml ``` <Profile Name>:   public_api_key: \"<MongoDB Atlas Public API Key>\"   private_api_key: \"<MongoDB Atlas Private API Key>\"   atlas_base_url: \"https://cloud.mongodb.com\"   realm_base_url: \"https://realm.mongodb.com\"   telemetry_mode: \"\" \n``` ```bash realm-cli login --profile=\"<Profile Name>\" \n``` ## Tip Make sure to use the `--profile` flag in all of your commands, otherwise Realm CLI won't recognize that you're logged in. ### Create an App\n\n To use a new app for your development or staging branch: 1. **Create a New App**  \nPush a new app based on your branch of the app's [configuration files:](https://mongodb.com/docs/atlas/app-services/reference/config/#std-label-app-configuration)  \n```bash  \ncd path/to/realmApp  \nrealm-cli push -y --project=\"<MongoDB Atlas Project ID>\" # e.g. --project=\"609ea544934fe445460219a2\"  \n```\n2. **Save the App ID**  \nThe new app has a unique App ID value that you'll need to identify it later in your pipeline and in your client app. You should save the value to an environment variable, file, or other location.  \n```bash  \n# Save to an environment variable  \noutput=$(realm-cli app describe)  \napp_id=$(echo $output | sed 's/^.*client_app_id\": \"\\([^\"]*\\).*/\\1/')  \nexport REALM_APP_ID=app_id  \n# Save to a file  \necho $REALM_APP_ID > ./clients/ios/realm-app-id.txt  \n``` ### Update an App You can use Realm CLI to update an existing app, like a shared staging app or your production deployment. The app already exists, so you should be able to look up its App ID. To update an existing app, specify its App ID in the `--remote` flag: ```bash realm-cli push --remote=$REALM_APP_ID -y \n``` ### Run Tests Against the App Your app should include automated unit and integration test suites that you can run to verify that everything works. The specifics of your test setup will vary depending upon your app, but you may need to run tests across multiple platforms using a variety of simulators. If you have integration tests, you could checkout previous releases and run your integration tests against the current version of the App to ensure backwards compatibility. ### Clean Up the Job At the end of a CI/CD stage or pipeline you may want to clean up resources that you created specifically for that test. For example, if you create a new Development or Staging app, you might delete the apps and any databases associated with them once your changes are merged. Alternatively, you would not want to clean up your production app or a persistent staging app if you use one. Before you clean up, consider what resources may be useful in future. For example, you could choose to skip deleting apps and their databases if your tests fail. That way you can manually investigate the issue and find any app settings or data that caused the failure. ← [Deploy Automatically with GitHub](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/ \"Previous Section\")[Change Deployment Models](https://mongodb.com/docs/atlas/app-services/apps/change-deployment-models/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/copy/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Copy an App On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Procedure](#procedure) ## Overview You can make a copy of an existing App by reusing the App's configuration files and manually porting Secrets. You might want to copy an application if: * You use feature branches for development. Use a unique copy of the App for each feature branch to avoid conflicts.\n* You run tests against a working version of the App. You can copy an App for each test run to to ensure a consistent start state.\n* You deploy the same app to clusters across regions using a [local deployment model](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-local-deployment). You can copy an App to serve multiple regions locally. ## Before You Begin ## Procedure ## Warning If [Automatic GitHub Deploymeny](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github) is enabled, do not push changes to your App with Realm CLI. For more information, see [Avoid Making Changes from the CLI.](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github-make-changes-cli) ← [Update an App](https://mongodb.com/docs/atlas/app-services/apps/update/ \"Previous Section\")[Delete an App](https://mongodb.com/docs/atlas/app-services/apps/delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/schemas/remove-a-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Remove a Schema On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Navigate to the Collection Schema Screen](#navigate-to-the-collection-schema-screen)\n* [Remove the Schema for a Collection](#remove-the-schema-for-a-collection)\n* [Remove All Schemas](#remove-all-schemas) ## Overview When you make [breaking changes](https://mongodb.com/docs/atlas/app-services/sync/data-model/update-schema/#std-label-destructive-changes-synced-schema)to your schema, you must remove the existing schema. You must do this after you [terminate Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) and before you[re-enable](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-re-enable-realm-sync) it. This guide shows you how to remove the schema. ## Procedure 1 ### Navigate to the Collection Schema Screen In the left navigation menu, click Schema beneath Data Access to open the schema editor. Atlas App Services scans your linked cluster for existing collections and lists them on the left side of the schema editor. By default, you see all the collections in your linked Atlas cluster. Any collection that has a schema shows a bolded name in this list, while a collection with no schema shows a light-gray, italicized name. From here, you can remove the schema for a single collection, or remove the schema for all collections. 2 ### Remove the Schema for a Collection 1. Hover over the collection name, and a ... menu appears.\n2. When you click this ... element, you get two options. One of them is to Delete Schema from this Collection. Choose this option.\n3. A modal pops up asking you to confirm that you want to delete the schema for the collection. Press the Delete button.\n4. If you have already terminated Device Sync, App Services deletes the schema. If you have not yet [terminated Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync), a modal displays, letting you know that this is a destructive change and clients will experience a [Client Reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets). If you'd like to continue, press the Save Changes & Reinitialize Sync. At this point, the collection no longer has a schema, and you can choose to [generate a schema](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) or[enable Development Mode.](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-development-mode) 3 ### Remove All Schemas If breaking changes impact multiple collections and you don't want to remove the schema collection-by-collection, you may remove all the schemas in a linked Atlas cluster. The first item in the Collections pane is the name of the linked data source. You can see a ... menu next to the name. 1. Select the ... element.\n2. You can see a few options; the last of which isDelete Schemas from All Collections. Select this option.\n3. A modal pops up asking you to confirm that you want to delete all schemas for the data source. Press the Delete button. ← [Enforce a Schema](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/ \"Previous Section\")[Schema Types](https://mongodb.com/docs/atlas/app-services/schemas/types/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/environment/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure an App Environment On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Procedure](#procedure) ## Overview App Environments are a way to organize your development workflow and effectively reuse code. You can use App Environments to define different multiple versions of global configuration values and then switch between them by changing the App's current environment. App Services supports a set of built-in environment names that each represent a stage of your development workflow: * `\"\"`\n* `\"development\"`\n* `\"testing\"`\n* `\"qa\"`\n* `\"production\"` ### Environment Values For each environment, you can define a set of _environment values_ that are available to your application when that environment is active. For example, you might use different values for an API's `baseUrl`configuration depending on whether you're developing a new feature or deploying to production. The values for an environment are stored as a single JSON object. You can set the field names and corresponding values to whatever you want. You can access values from the current environment by field name: * Use [context.environment](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-environment) in Functions.\n* Use [%%environment](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---environment) in rule expressions.\n* Use [Templated Configurations](https://mongodb.com/docs/atlas/app-services/reference/config/template-expansions/#std-label-config-expansions) in your App's configuration files. ### How to Use Environments Environment tags each represent a specific stage of your development process. You can define a separate App for each environment, where each App uses the same set of configuration files but has a distinct environment tag. To learn how, see [Copy an App.](https://mongodb.com/docs/atlas/app-services/apps/copy/#std-label-copy-app) For example, a typical development process may have three development stages: `development`, `testing`, and `production`. You could use a separate App for each stage and use different environment values for each App. You can also use unique applications to test individual feature branches. For example, you might have a core `development` App that developers fork for their feature branches. When a feature branch moves into testing, you can use the core `testing` App instead. To learn how to incorporate environments into your CI/CD workflow, see[Set Up a CI/CD Pipeline](https://mongodb.com/docs/atlas/app-services/apps/cicd/#std-label-ci-cd-pipeline). For a full example that manages testing, deployment, and other tasks for a real application, see: [How to Build CI/CD Pipelines for App Services Apps using GitHub Actions.](https://www.mongodb.com/developer/how-to/build-ci-cd-pipelines-realm-apps-github-actions/) ![Diagram showing different App Services Apps for each branch](https://mongodb.com/docs/atlas/app-services/images/realm-app-environments-in-workflow.png) click to enlarge ## Before You Begin ## Procedure ← [Export an App](https://mongodb.com/docs/atlas/app-services/apps/export/ \"Previous Section\")[Deploy Automatically with GitHub](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Delete an App ## Overview You can delete an App Services App from the App Services UI, CLI, or Admin API. ## Before You Begin ## Procedure ← [Copy an App](https://mongodb.com/docs/atlas/app-services/apps/copy/ \"Previous Section\")[Roll Back a Deployment](https://mongodb.com/docs/atlas/app-services/apps/rollback/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/apps/create/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Create an App On this page * [Overview](#overview)\n* [Before You Begin](#before-you-begin)\n* [Procedure](#procedure) ## Overview You can create a new App Services App from the App Services UI, CLI, or Admin API. An App Services App is a managed backend instance that contains your application's services. Each app belongs to a specific Atlas project. To create an App in a project, you must be logged in to [MongoDB Atlas](https://cloud.mongodb.com/user/register?tck=docs%5Frealm) and have**Project Owner** permissions. ## Before You Begin ## Procedure ← [Develop & Deploy Apps](https://mongodb.com/docs/atlas/app-services/apps/ \"Previous Section\")[Get App Metadata](https://mongodb.com/docs/atlas/app-services/apps/metadata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Enforce a Schema On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Navigate to the Collection Schema Screen](#navigate-to-the-collection-schema-screen)\n* [Generate a Schema](#generate-a-schema)\n* [Add Field-Level Schema Definitions](#add-field-level-schema-definitions)\n* [Add Change Validation Expressions](#add-change-validation-expressions)\n* [Save the Schema](#save-the-schema)\n* [Validate Documents Against the Schema](#validate-documents-against-the-schema)\n* [Log In to MongoDB Cloud](#log-in-to-mongodb-cloud)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Define the Schema](#define-the-schema)\n* [Define Change Validation](#define-change-validation)\n* [Deploy the Updated Schema](#deploy-the-updated-schema)\n* [Validate Null Types](#validate-null-types) ## Overview You can control the shape and contents of documents in a collection by defining a [schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). Schemas let you require specific fields, control the type of a field's value, and validate changes before committing write operations. This guide shows you how to define, configure, and deploy a schema for a linked MongoDB Atlas collection. ## Note Federated data sources [do not support rules or schemas](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats). You can only access a Federated data source from a system function. ## Procedure ## Validate Null Types App Services's default behavior is to only accept a single type for each field. Schema fields are not nullable by default because `null` is a unique[BSON type.](https://www.mongodb.com/docs/manual/reference/bson-types/) You can configure App Services to pass schema validation when you use `null`values with optional fields. Enabling null type validation allows the value for a field to be persisted as the type in the schema or the [BSON null](https://www.mongodb.com/docs/manual/reference/bson-types/) type. If you do not enable null type schema validation, App Services rejects `null`values passed to optional fields. Even if you enable null type validation, required fields are never nullable. To enable null type schema validation in the App Services UI: 1. In the left navigation menu below the Manage header, select App Settings.\n2. On the General tab, navigate to the Null Type Schema Validationsection. Toggle the switch to ON.\n3. Click the Save button. ← [Schemas](https://mongodb.com/docs/atlas/app-services/schemas/ \"Previous Section\")[Remove a Schema](https://mongodb.com/docs/atlas/app-services/schemas/remove-a-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/schemas/relationships/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Relationships On this page * [Overview](#overview)\n* [Cardinality](#cardinality)\n* [To-One](#to-one)\n* [To-Many](#to-many)\n* [Embedded Object Relationships](#embedded-object-relationships)\n* [Embedded Object to Another Collection](#embedded-object-to-another-collection)\n* [Embedded Object Within a List](#embedded-object-within-a-list)\n* [Define a Relationship](#define-a-relationship)\n* [1\\. Define Schemas](#1.-define-schemas)\n* [2\\. Create a New Relationship](#2.-create-a-new-relationship)\n* [3\\. Configure the Relationship](#3.-configure-the-relationship)\n* [4\\. Deploy the Relationship](#4.-deploy-the-relationship) ## Overview A relationship is a connection between two documents. Relationships allow you to reference and query related documents in read and write operations, even if the documents are in separate databases or collections. You define a relationship for a \"source\" MongoDB collection and link to documents in a \"foreign\" collection. Atlas App Services automatically resolves relationships in synced SDK data models and GraphQL operations by replacing the values in a source field with the foreign documents that they reference. ## Important ### Relationships cannot span partitions In an app that uses[Partition-Based Sync](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-partition-based-sync), an object can only have a relationship with other objects _in the same partition_. The objects can exist in different databases and collections (within the same cluster) as long as the partition key value matches. To understand how partitions can span multiple databases and collections, see [Partition-Based Sync.](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/#std-label-sync-partitions) Relationships are unidirectional and don't enforce uniqueness or other foreign key constraints. If you reference a non-existent foreign value in a source field, App Services automatically omits the reference from resolved relationships. ## Example Consider an application that has two collections:\n\n The app defines this relationship on the `customers` collection. It points from the array of account id values stored in the `accounts`field to the `account_id` field of each document in the`accounts` collection. ``` {   \"accounts\": {     \"ref\": \"#/realm/mongodb-atlas/sample_analytics/accounts\",     \"foreign_key\": \"account_id\",     \"is_list\": true   } } \n``` With this relationship defined, App Services can return a customer and all of their accounts in the same GraphQL query. Without a relationship, the query would return a list of just `account_id` values instead of the full `Account` objects. ``` query CustomerAccounts {   customer(query: { username: \"Elizabeth Ray\" }) {     username     accounts {       account_id       products     }   } } \n``` ## Cardinality A relationship's cardinality determines the number of foreign documents that it can reference. App Services supports two relationship cardinalities: \"to-one\" and \"to-many\". ### To-One A to-one relationship links each source document with either a single document or an array of documents from the foreign collection. To indicate that a relationship has \"to-one\" cardinality, set`is_list` to `false`: data\\_sources/mongodb-atlas/example/pets/relationships.json ``` {   \"owner\": {     \"ref\": \"#/relationship/mongodb-atlas/example/people\",     \"foreign_key\": \"_id\",     \"is_list\": false   } } \n``` App Services automatically replaces source values with the referenced objects or a null value in resolved GraphQL types and SDK models: ### To-Many A to-many relationship links each source document with a list of documents from the foreign collection. To indicate that a relationship has \"to-many\" cardinality, set`is_list` to `true`: data\\_sources/mongodb-atlas/example/people/relationships.json ``` {   \"pets\": {     \"ref\": \"#/relationship/mongodb-atlas/example/pets\",     \"foreign_key\": \"_id\",     \"is_list\": true   } } \n``` App Services automatically replaces source values with the referenced objects or a null value in resolved GraphQL types and SDK models: ## Embedded Object Relationships Embedded Objects can have relationships with foreign collections. Use dot notation to access properties in embedded objects. ### Embedded Object to Another Collection An embedded object can have a relationship with an object in a foreign collection. ``` {   \"title\": \"Person\",   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"pet\": {       \"bsonType\":\"object\",       \"properties\": {         \"favoriteToyBrand\": { \"bsonType\": \"objectId\" }       }     }     // ...additional model properties   } } \n``` Use dot notation to specify the embedded object property that has a relationship with the foreign collection. Then, you can specify the foreign collection details and foreign key field. ``` { \"pet.favoriteToyBrand\":    {       \"ref\": \"#/relationship/mongodb-atlas/example/ToyBrand\",       \"foreign_key\": \"_id\",       \"is_list\": false } } \n``` ### Embedded Object Within a List An embedded object that is within a list property can have a relationship with a foreign collection. ## Important The GraphQL API does not currently support embedded object relationships. You can resolve embedded object relationships with Atlas Device Sync and in the Realm SDKs. ``` {   \"title\": \"Person\",   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"pets\": {       \"bsonType\":\"array\",       \"items\": {         \"bsonType\": \"object\",         \"properties\": {           \"favoriteToyBrand\": { \"bsonType\": \"objectId\" }         }       }     }\n\n   } } \n``` To access a embedded object property contained in a list, use:`field1.[].field2`, e.g. `pets.[].favoriteToyBrand`. From there, you can specify the foreign collection details and foreign key field. ## Tip ### Use the same syntax with dictionaries and sets You can use this same `field1.[].field2` syntax when creating relationships within dictionaries and sets. ``` {   \"pets.[].favoriteToyBrand\": {     \"ref\": \"#/relationship/mongodb-atlas/example/ToyBrand\",     \"foreign_key\": \"_id\",     \"is_list\": false   } } \n``` ## Note ### Primitives versus lists, dictionaries, and sets in relationships In the example above, `is_list` is set to false. The field at the end of the relationship string here is a primitive, not a list. The embedded object is _contained_ in a list, but the `favoriteToyBrand` property itself is not a dictionary, set or list. ## Define a Relationship When you define a relationship, keep these limitations in mind: * The reference field must not be `_id`\n* The reference field must not be a `required` field\n* The foreign key must be the `_id` field of the collection the field is referencing ### 1\\. Define Schemas In order to define a relationship, you must have a schema defined for both the source collection and the foreign collection. To learn how to define schemas, see [Enforce a Schema.](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) ### 2\\. Create a New Relationship You define a relationship for collections in a linked MongoDB data source alongside the schema. ### 3\\. Configure the Relationship A relationship definition maps from a field included in the source collection's schema and points to a field of the same type in the foreign collection's schema. ### 4\\. Deploy the Relationship ← [Schema Types](https://mongodb.com/docs/atlas/app-services/schemas/types/ \"Previous Section\")[Values & Secrets](https://mongodb.com/docs/atlas/app-services/values-and-secrets/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/upgrade-shared-cluster/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Upgrade a Shared Tier Cluster On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Shut Down All Running Emulators](#shut-down-all-running-emulators)\n* [Terminate Atlas Device Sync](#terminate-atlas-device-sync)\n* [Upgrade Your Cluster](#upgrade-your-cluster) ## Overview Atlas App Services allows you to upgrade your shared tier cluster (**M0**, **M2**, and**M5**) to a dedicated cluster. Upgrade your cluster before releasing an Atlas Device Sync application by completing the following steps. ## Note Using a shared tier cluster on a production application is not recommended. To avoid data loss, upgrade to a dedicated tier cluster before releasing your application. ## Warning ### Restore Sync after Terminating Sync When you terminate and re-enable Atlas Device Sync, clients can no longer Sync. Your client must implement a client reset handler to restore Sync. This handler can discard or attempt to recover unsynchronized changes. ## Procedure 1 ### Shut Down All Running Emulators Before upgrading your cluster, end any client application's Sync Connection. To do this, shut down all emulators, simulators, and terminals that are running your realm application. 2 ### Terminate Atlas Device Sync To terminate Atlas Device Sync, follow the instructions for [Terminating Atlas Device Sync.](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) 3 ### Upgrade Your Cluster Click the Upgrade green button under the Enhance Your Experience heading of the Data Services tab. ![The modal that confirms turning off Atlas Device Sync in the UI](https://mongodb.com/docs/atlas/app-services/images/upgrade-cluster-start.png) click to enlarge Configure your upgraded cluster settings in the following screen and then click Review Changes. To learn more about the pricing of the various Atlas cluster tiers, see the [billing](https://mongodb.com/docs/atlas/app-services/billing/) page. ![The configuration settings to upgrade your cluster tier](https://mongodb.com/docs/atlas/app-services/images/upgrade-cluster-settings.png) click to enlarge Review your upgraded cluster changes, and click the green Apply Changes button. ![The configuration settings review screen to upgrade your cluster tier](https://mongodb.com/docs/atlas/app-services/images/review-upgraded-cluster-changes.png) click to enlarge A blue header will appear, indicating the progress of the cluster migration operation. ![The cluster migration operation progress indication header](https://mongodb.com/docs/atlas/app-services/images/cluster-migration-progress-header.png) click to enlarge Finally, reenable [Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-realm-sync) to resume your application development, testing, and roll-out. ← [Third-Party Licenses](https://mongodb.com/docs/atlas/app-services/reference/third-party-licenses/ \"Previous Section\")[Partition-Based Sync](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/schemas/types/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Schema Types On this page * [All Schema Types](#all-schema-types)\n* [BSON Types](#bson-types)\n* [Array](#array)\n* [Boolean](#boolean)\n* [Mixed](#mixed)\n* [Number](#number)\n* [Object](#object)\n* [ObjectId](#objectid)\n* [String](#string)\n* [UUID](#uuid)\n* [Binary Data](#binary-data)\n* [Realm Database Types](#realm-database-types)\n* [Set](#set)\n* [Dictionary](#dictionary)\n* [Dictionary of a BSON Type](#dictionary-of-a-bson-type)\n* [Dictionary of Mixed BSON Types](#dictionary-of-mixed-bson-types)\n* [Dictionary of Embedded Objects](#dictionary-of-embedded-objects) ## All Schema Types The following fields are available for all BSON schemas regardless of type: `| {                                                  |\n| -------------------------------------------------- |\n| \"bsonType\": \"<BSON Type>\" \\| [\"<BSON Type>\", ...], |\n| \"type\": \"<JSON Type>\" \\| [\"<JSON Type>\", ...],     |\n| \"enum\": [<Value 1>, <Value 2>, ...],               |\n| \"description\": \"<Descriptive Text>,                |\n| \"title\": \"<Short Description>\"                     |\n| }                                                  | `\n\n ## BSON Types ### Array An `array` contains multiple values of a specific type. BSON `array` schemas use the standard [JSON Schema array](https://json-schema.org/understanding-json-schema/reference/array.html)format. ``` {   \"bsonType\": \"array\",   \"items\": <Schema Document> | [<Schema Document>, ...],   \"additionalItems\": <boolean> | <Schema Document>,   \"maxItems\": <integer>,   \"minItems\": <integer>,   \"uniqueItems\": <boolean> } \n```\n\n ### Boolean A `bool` is either `true` or `false`. ``` { \"bsonType\": \"bool\" } \n``` ### Mixed A `mixed` field may contain any schema type except for [arrays](#std-label-schema-type-array), [embedded objects](#std-label-schema-type-object),[sets](#std-label-schema-type-set), and [dictionaries](#std-label-schema-type-dictionary). App Services does not enforce a consistent type across documents, so two different documents may have values of different types. Mixed fields can represent relationships. Sync translates these relationships to MongoDB as a [DBRef](https://www.mongodb.com/docs/manual/reference/database-references/) to preserve the database name, collection name, and primary key of the link. ``` { \"bsonType\": \"mixed\" } \n``` ### Number A `number` generically configures some type of number. BSON schemas extend[JSON Schema numerics](https://json-schema.org/understanding-json-schema/reference/numeric.html)with additional types to define integers, floats, and decimals. ``` {   \"bsonType\": \"number\" | \"int\" | \"long\" | \"double\" | \"decimal\",   \"multipleOf\": <number>,   \"maximum\": <number>,   \"exclusiveMaximum\": <boolean>,   \"minimum\": <number>,   \"exclusiveMinimum\": <boolean> } \n``` | Field Name       | Description                                                                                                                                              |\n| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| multipleOf       | An integer divisor of the field value. For example, ifmultipleOf is set to 3, 6 is a valid value but7 is not.                                            |\n| maximum          | The maximum value of the number.                                                                                                                         |\n| exclusiveMaximum | Default: falseIf true, the field value must be strictly less than themaximum value. If false, the field value may also be equal to the maximum value.    |\n| minimum          | The minimum value of the number.                                                                                                                         |\n| exclusiveMinimum | Default: falseIf true, the field value must be strictly greater than theminimum value. If false, the field value may also be equal to the minimum value. | ### Object\n\n ``` {   \"bsonType\": \"object\",   \"title\": \"<Type Name>\",   \"required\": [\"<Required Field Name>\", ...],   \"properties\": {     \"<Field Name>\": <Schema Document>   },   \"minProperties\": <integer>,   \"maxProperties\": <integer>,   \"patternProperties\": {     \"<Field Name Regex>\": <Schema Document>   },   \"additionalProperties\": <boolean> | <Schema Document>,   \"dependencies\": {     \"<Field Name>\": <Schema Document> | [\"<Field Name>\", ...]   } } \n```\n\n ## Note ### Model Dictionaries With the object Schema Type To model [dictionaries](#std-label-schema-type-dictionary), use the `object` schema type with `additionalProperties` set to the object type of the values stored in the dictionary. ### ObjectId An `objectId` is a 12-byte identifier for [BSON](https://www.mongodb.com/docs/manual/reference/bson-types/) objects. ObjectId values are most commonly used as the unique `_id` values of documents in a MongoDB collection or objects in a synced realm. ``` { \"bsonType\": \"objectId\" } \n``` ### String A `string` is text encoded as a series of characters. BSON `string` schemas use the standard [JSON Schema string](https://json-schema.org/understanding-json-schema/reference/string.html)format. ``` {   \"bsonType\": \"string\",   \"maxLength\": <integer>,   \"minLength\": <integer>,   \"pattern\": \"<Regular Expression>\" } \n``` | Field Name | Description                                                   |\n| ---------- | ------------------------------------------------------------- |\n| maxLength  | The maximum number of characters in the string.               |\n| minLength  | The minimum number of characters in the string.               |\n| pattern    | A regular expression string that must match the string value. | ### UUID A `uuid` (Universal Unique Identifier) is a [standardized](https://tools.ietf.org/html/rfc4122)16-byte unique object identifier. ``` { \"bsonType\": \"uuid\" } \n``` ### Binary Data A `binData` is a piece of unstructured binary data. Maps to the [binary BSON type](https://bsonspec.org/spec.html). Always uses subtype 0. ``` { \"bsonType\": \"binData\" } \n``` ## Realm Database Types ### Set A set is a collection of unique values. A set schema is an `array` schema where `uniqueItems` is set to `true`. ``` {    \"bsonType\": \"array\",    \"uniqueItems\": true,    \"items\": {       \"bsonType\": \"long\"    } } \n``` ### Dictionary A dictionary is a collection of dynamic and unique `string` keys paired with values of a given type. A dictionary is functionally an object or document without pre-defined field names. A dictionary schema is an `object` schema where `properties` is not defined and the value of `additionalProperties` is a schema for the dictionary value's type. #### Dictionary of a BSON Type To store a dictionary with values of a BSON type, set `additionalProperties`to the type's schema. ``` {    \"bsonType\": \"object\",       \"additionalProperties\": {          \"bsonType\": \"string\"       }    } } \n``` #### Dictionary of Mixed BSON Types To store a dictionary with [mixed](#std-label-schema-type-mixed) values, set`additionalProperties` to `true`: ``` {    \"bsonType\": \"object\",       \"additionalProperties\": true    } } \n``` Alternatively, you can define a full `mixed` schema: ``` {    \"bsonType\": \"object\",       \"additionalProperties\": {          \"bsonType\": \"mixed\"       }    } } \n``` #### Dictionary of Embedded Objects To store a dictionary with embedded object values, define an `object` schema with the `title` field set to the embedded object's type name: ``` {    \"bsonType\": \"object\",       \"additionalProperties\": {          \"bsonType\": \"object\",          \"title\": “Address”,\n\n            \"streetNumber\": { \"bsonType\": \"string\" },            \"street\": { \"bsonType\": \"string\" },            \"city\": { \"bsonType\": \"string\" },            \"province\": { \"bsonType\": \"string\" },            \"country\": { \"bsonType\": \"string\" },            \"postalCode\": { \"bsonType\": \"string\" }          }    } } \n``` ← [Remove a Schema](https://mongodb.com/docs/atlas/app-services/schemas/remove-a-schema/ \"Previous Section\")[Relationships](https://mongodb.com/docs/atlas/app-services/schemas/relationships/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/service-limitations/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Service Limitations On this page * [Overview](#overview)\n* [Aggregation](#aggregation)\n* [Atlas](#atlas)\n* [Batch Loading](#batch-loading)\n* [Federated database instances](#federated-database-instances)\n* [Serverless Instances](#serverless-instances)\n* [Sharded Clusters](#sharded-clusters)\n* [Time Series Collections](#time-series-collections)\n* [Private Endpoints](#private-endpoints)\n* [Change Streams](#change-streams)\n* [Database Commands](#database-commands)\n* [MongoDB Version Requirements](#mongodb-version-requirements)\n* [Query Options](#query-options)\n* [Query Results](#query-results)\n* [Request Traffic](#request-traffic)\n* [Rules](#rules)\n* [Static Hosting](#static-hosting)\n* [Sync - Concurrent Workloads](#sync---concurrent-workloads) ## Overview Atlas App Services has several guidelines to keep in mind when architecting how your tools and clients interact with MongoDB through App Services. Keep this guidance in mind when deciding how to structure queries, selecting which CRUD and aggregation operations to use, and determining how to handle concurrent workloads. ## Aggregation App Services supports all [aggregation pipeline stages](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/) in[system functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions) except for `$currentOp`and `$indexStats`. For security reasons, only a subset of aggregation pipeline stages are supported in [user functions.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-user-functions) For a list of pipeline stages that are available and their allowed function context, see [Aggregation.](https://mongodb.com/docs/atlas/app-services/mongodb/crud-and-aggregation-apis/#std-label-mongodb-crud-and-aggregation-apis-aggregation) ## Atlas ### Batch Loading When data is bulk/batch loaded into MongoDB Atlas, you may see a delay in data appearing on devices while App Services processes changes. ### Federated database instances You can link a [Federated database instance](https://www.mongodb.com/atlas/data-federation?tck=docs%5Frealm) to your app as a MongoDB data source. However, there are some caveats to keep in mind when working with Atlas Data Federation: * Federated data sources [do not support write operations.](https://www.mongodb.com/docs/atlas/data-federation/supported-unsupported/mql-support/)\n* You can only access a Federated data source from a [system function.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions)\n* You cannot connect to a Federated data source via the [wire protocol.](https://mongodb.com/docs/atlas/app-services/mongodb/wire-protocol/#std-label-wire-protocol)\n* You cannot define [roles and permissions](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-define-roles-and-permissions) for a Federated data source.\n* You cannot set a [read preference](https://mongodb.com/docs/atlas/app-services/mongodb/read-preference/#std-label-read-preference) for a Federated data source.\n* You cannot create a [database trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-trigger) on a Federated data source.\n* You cannot use a Federated data source as your app's [Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync) cluster. ### Serverless Instances\n\n * You cannot create a [database trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-trigger) on a serverless instance.\n* You cannot use a serverless instance as your app's [Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync) cluster.\n* You cannot watch collections for changes data sources that are serverless MongoDB Atlas instances. ### Sharded Clusters Atlas Device Sync does not currently support sharded MongoDB Atlas clusters. However, you can add a sharded cluster as a data source and access it from a[function.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) ### Time Series Collections [Time series collections](https://www.mongodb.com/docs/manual/core/timeseries-collections/) do not yet support [change streams](https://www.mongodb.com/docs/manual/changeStreams/). Therefore, you cannot define triggers on a time series collection. You can use time series collections with Atlas Device Sync, but only[Asymmetric Sync](https://mongodb.com/docs/atlas/app-services/sync/app-builder/stream-data-from-client-to-atlas/#std-label-stream-data-from-client-to-atlas) is supported. ## Private Endpoints App Services does not currently support [private endpoints.](https://www.mongodb.com/docs/atlas/security-private-endpoint/) ## Change Streams App Services limits the total number of change streams open against a given cluster across all Apps based on the cluster's size. The following table lists the limitations for each cluster size: | Cluster Size                        | Maximum Number of Change Streams |\n| ----------------------------------- | -------------------------------- |\n| Free Tier (M0)                      | 5                                |\n| Shared Clusters (M2/M5)             | 10                               |\n| Small, Dedicated Clusters (M10/M20) | 100                              |\n| Standard Clusters (M30/M40)         | 1000                             |\n| Standard Clusters (M50 \\- M90)      | 2500                             |\n| High-Power Clusters (M100+)         | 2500                             | ## Note App Services opens a single change stream on each collection that is associated with a [Database Trigger](https://mongodb.com/docs/atlas/app-services/triggers/database-triggers/#std-label-database-trigger), [Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync), or `watch()` operation. ## Important ### Usage Recommendation To minimize the number of open change streams: * Start Watch and Sync operations only when necessary. Close any open Watch and Sync streams immediately when they're no longer necessary.\n* Avoid data models that require you to Watch or Sync an unbounded number of collections. ## Database Commands\n\n ## MongoDB Version Requirements You can access most of the CRUD and Aggregation functionality of MongoDB version 3.6 with the [MongoDB service](https://mongodb.com/docs/atlas/app-services/mongodb/); however, App Services does not support all operations and features available in standard tools and clients. For a list of specific MongoDB operations that are available when you connect to MongoDB through App Services, see[the CRUD & Aggregation API reference.](https://mongodb.com/docs/atlas/app-services/mongodb/crud-and-aggregation-apis/#std-label-mongodb-crud-and-aggregation-apis) Device Sync requires MongoDB Atlas clusters to run specific versions of MongoDB: * Partition-Based Sync requires MongoDB 4.4.0 or greater.\n* Flexible Sync requires MongoDB 5.0.0 or greater. ## Query Options App Services supports all query options in [system functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-system-functions). App Services does not support certain options for CRUD operations run from [user functions](https://mongodb.com/docs/atlas/app-services/functions/#std-label-user-functions). For a list of specific options that are available when you connect to MongoDB through App Services, see [Query Options.](https://mongodb.com/docs/atlas/app-services/mongodb/crud-and-aggregation-apis/#std-label-mongodb-crud-and-aggregation-apis-query-options) ## Query Results MongoDB queries executed through App Services can return a maximum of 50,000 documents. If you need to return more documents, consider paginating your query. ## Request Traffic App Services limits request traffic to 10,000 concurrent requests. Any requests made beyond this limit return an HTTP response status code of[429 - Too Many Requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429). You can request a higher limit by [filing a support ticket.](https://support.mongodb.com/welcome) ## Rules Device Sync supports [Sync rules](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-sync-rules). Device Sync does not support [roles/field-level rules](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-define-roles-and-permissions) at this time. ## Static Hosting App Services enforces a 25MB maximum file size constraint on[static hosting.](https://mongodb.com/docs/atlas/app-services/hosting/) ## Sync - Concurrent Workloads Writing: For improved performance, you may want to limit the number of concurrent writes to a single MongoDB document. App Services has no hard limit to the number of users concurrently writing data to a MongoDB document. However, with more than 30 concurrent writers, you may see delays in syncing or conflict resolution. Reading: Frontend clients reading from a global realm can scale past tens of thousands of concurrent users. ## Tip ### Scalability When you intend to have many concurrent writers, have each writer work on a separate document. ← [Billing](https://mongodb.com/docs/atlas/app-services/billing/ \"Previous Section\")[Template Apps](https://mongodb.com/docs/atlas/app-services/reference/template-apps/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/third-party-licenses/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Third-Party Licenses On this page * [Overview](#overview)\n* [IntelRDFPMathLib20U2](#intelrdfpmathlib20u2) ## Overview Atlas App Services uses third-party libraries or other resources that may be distributed under licenses different than the MongoDB software. App Services depends upon the following third-party packages. These packages are licensed as shown in the following list. ## IntelRDFPMathLib20U2 The Intel® Decimal Floating-Point Math Library uses the following license: `| Copyright (c) 2018, Intel Corp.                                                  |\n| -------------------------------------------------------------------------------- |\n| All rights reserved.                                                             |\n| Redistribution and use in source and binary forms, with or without modification, |\n| are permitted provided that the following conditions are met:                    |\n| * Redistributions of source code must retain the above copyright notice, this    |\n| list of conditions and the following disclaimer.                                 |\n| * Redistributions in binary form must reproduce the above copyright notice,      |\n| his list of conditions and the following disclaimer in the documentation         |\n| and/or other materials provided with the distribution.                           |\n| * Neither the name of Intel Corporation nor the names of its contributors        |\n| may be used to endorse or promote products derived from this software            |\n| without specific prior written permission.                                       |\n| THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND  |\n| ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    |\n| WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           |\n| DISCLAIMED.                                                                      |\n| IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  |\n| INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,   |\n| BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    |\n| DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  |\n| LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  |\n| OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF        |\n| ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                                       | `\n\n",
  "https://www.mongodb.com/docs/atlas/app-services/reference/push-notifications/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Push Notifications \\[Deprecated\\] On this page * [Overview](#overview)\n* [Management Interface](#management-interface)\n* [Send a Push Notification](#send-a-push-notification)\n* [Set Up Clients to Receive Push Notifications](#set-up-clients-to-receive-push-notifications)\n* [Rule Templates](#rule-templates)\n* [Notifications Must Have a Specific Title](#notifications-must-have-a-specific-title)\n* [Notifications Must Be for a Specific Topic](#notifications-must-be-for-a-specific-topic)\n* [Notifications Can Only Be Sent To a Limited Set of User IDs](#notifications-can-only-be-sent-to-a-limited-set-of-user-ids)\n* [Push Notification Rules](#push-notification-rules)\n* [Notification Document Fields](#notification-document-fields) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Overview Atlas App Services supports integrating mobile (Android and iOS) apps with the Firebase Cloud Messaging (FCM) service to provide push notifications. You configure and send notification messages from within the App Services console, while clients register with `Firebase Cloud Messaging (FCM)` for messages sent to specific topics. ## Management Interface The Push Notifications screen in the App Services UI lets you write notification drafts, send notifications to users, and define[notification rules.](#std-label-notification-rules) There are four tabs in the Push Notifications screen:\n\n ## Send a Push Notification You can send new Push Notifications from the Push Notifications page. Click the Send New Notification button to open the Send New Notification dialog. In this dialog, you provide the notification message, label, and the relevant topic audience. ![Sending a new Push Notification](https://mongodb.com/docs/atlas/app-services/images/new-push-message.png) ## Set Up Clients to Receive Push Notifications ## Rule Templates ### Notifications Must Have a Specific Title `| {                                                              |\n| -------------------------------------------------------------- |\n| \"%%args.notification.title\": \"Test Notification Please Ignore\" |\n| }                                                              | ` ### Notifications Must Be for a Specific Topic ``` {   \"%%args.to\": \"%%values.validTopics\" } \n``` ### Notifications Can Only Be Sent To a Limited Set of User IDs ``` {   \"%%true\": {     \"%function\": {       \"name\": \"allUserIdsAreValid\",       \"arguments\": [         \"%%args.userIds\"       ]     }   } } \n``` ## Note This template calls an example function named`allUserIdsAreValid` that does the following: 1. Accepts the list of User IDs provided in the `userIds` argument\n2. Queries MongoDB for a user document that matches the current user's id\n3. Compares the provided phone number to the number listed in the user document\n4. Returns the boolean result of the comparison ```javascript exports = function(toPhone) {   const mdb = context.services.get('mongodb-atlas');   const users = mdb.db('demo').collection('users');   const user = users.findOne({ _id: context.user.id });   return user.phoneNumber === toPhone; } \n``` ## Push Notification Rules To specify rules for Push Notifications, click on the Rulestab on the Push Notifications page. ## Note Unlike other services in App Services, rules for push notifications are optional. By default, all push notifications are allowed. However, once you specify a rule, the restrictions imposed by that rule will take effect. The Push Notifications rules permit the following arguments. You can access them with the `\"%%args\"` expansion:\n\n ### Notification Document Fields The following table lists the fields of the `notification` document that is available as a permitted field for Push Notifications rules. To access one of these fields in a rule, use`\"%%args.notification.<field>\"`.\n\n ← [Partition-Based Sync](https://mongodb.com/docs/atlas/app-services/reference/partition-based-sync/ \"Previous Section\")[Third-Party Services \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/reference/services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/metrics/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # App Services Metrics Reference On this page * [Metric Format](#metric-format)\n* [Units](#units)\n* [Available Metrics](#available-metrics) App Services provides a variety of metrics related to App Services and Device Sync. You can access your metrics data with the Admin API's[Retrieve App Services metrics](https://www.mongodb.com/docs/atlas/app-services/admin/api/v3/#tag/metrics/operation/adminGetMetrics) endpoint. The exact metrics returned may be subject to change. ## Metric Format When you request metrics, you specify a start time, end time, and time granularity such as \"hourly\". The response contains a list of **measurement**objects, one for each metric listed below. Each measurement object contains a list of **data points** that represent that metric's value at a specific time. For example, you request hourly metrics from 12:00am to 11:59pm Tuesday. App Services sends back a list of measurements. Each measurement contains about 24 data points (one for each hour between start and end time). The value field of each data point is the value of that metric at the time specified by the timestamp. ## Units App Services expresses each metric in one of the following units: * BYTES\\_PER\\_SECOND\n* MILLISECONDS\n* SCALAR\n* SCALAR\\_PER\\_SECOND A **scalar** is a singular value representing a magnitude or count. Its exact interpretation depends on the metric. A **scalar per second** represents a count over time (\"rate\"). The value is effectively the total count since the previous data point divided by the number of seconds since the previous data point. Some scalar per second values are expressed as a 95th percentile. This means that the measurement for the given metric is below the given value 95% of the time and above it the other 5% of the time. ## Available Metrics\n\n ← [Application Configuration Files (Legacy)](https://mongodb.com/docs/atlas/app-services/reference/config/legacy/ \"Previous Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # App Configuration Every component of an Atlas App Services App is fully defined and configured using structured JSON configuration and JavaScript source code files. * `.json` files define and configure specific components in your app. Every JSON configuration file conforms to a specific schema for the type of component it configures.\n* `.js` files define serverless application logic used in functions, triggers, HTTPS endpoints, and custom resolvers. ## Important ### Reserved File Names You can include arbitrarily named files in your realm app config, with a few exceptions. The following filenames are used to define and configure components in your App:`stitch.json`, `config.json`, `realm_config.json`, and `app_config.json`. Files with these names must conform to a specific schema for their component type. Using these file names when the file's content fails to conform to that schema throws an error when you import the app using the CLI. Refer to this section for reference information about configuring these files. You'll work directly with configuration files if you prefer to develop and[deploy](https://mongodb.com/docs/atlas/app-services/apps/#std-label-deploy) locally instead of through the App Services UI. A complete directory of configuration files has the following root-level files and directories: `| app/                  |\n| --------------------- |\n| ├── realm_config.json |\n| ├── auth/             |\n| ├── data_sources/     |\n| ├── environments/     |\n| ├── functions/        |\n| ├── graphql/          |\n| ├── hosting/          |\n| ├── http_endpoints/   |\n| ├── log_forwarders/   |\n| ├── services/         |\n| ├── sync/             |\n| ├── triggers/         |\n| └── values/           | ` For detailed descriptions and examples of each component type's configuration and source code files, refer to the type's page in this section: * [App Services App](https://mongodb.com/docs/atlas/app-services/reference/config/app/)\n* [Users & Authentication Providers](https://mongodb.com/docs/atlas/app-services/reference/config/auth/)\n* [MongoDB Data Sources](https://mongodb.com/docs/atlas/app-services/reference/config/data%5Fsources/)\n* [Environment Values](https://mongodb.com/docs/atlas/app-services/reference/config/environments/)\n* [Functions](https://mongodb.com/docs/atlas/app-services/reference/config/functions/)\n* [GraphQL](https://mongodb.com/docs/atlas/app-services/reference/config/graphql/)\n* [Static Hosting](https://mongodb.com/docs/atlas/app-services/reference/config/hosting/)\n* [HTTP Endpoints](https://mongodb.com/docs/atlas/app-services/reference/config/http%5Fendpoints/)\n* [Log Forwarders](https://mongodb.com/docs/atlas/app-services/reference/config/log%5Fforwarders/)\n* [Third-Party Services](https://mongodb.com/docs/atlas/app-services/reference/config/services/)\n* [Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/reference/config/sync/)\n* [Triggers](https://mongodb.com/docs/atlas/app-services/reference/config/triggers/)\n* [Values](https://mongodb.com/docs/atlas/app-services/reference/config/values/) ← [Reference](https://mongodb.com/docs/atlas/app-services/reference/ \"Previous Section\")[App Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/app/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/template-apps/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Template Apps On this page * [Overview](#overview)\n* [Create a Template App](#create-a-template-app)\n* [Get a Template App Client](#get-a-template-app-client)\n* [Template Apps Available](#template-apps-available) ## Overview You can get up and running with an Atlas App Services App using one of our premade template apps. Template apps bring together many of the building blocks available in Atlas App Services and start you off with a prebuilt app that you can customize. [Sign-up to Deploy a Template App](https://www.mongodb.com/realm/register?tck=docs%5FCTA%5Frealm%5Ftemplate%5Fapps) ## Create a Template App You can create a template app using the UI on the Atlas App Services site, the Realm CLI, or the Admin API. Choose the tab for whichever option is most convenient for you. ## Get a Template App Client Some of the template apps come with working clients to explore and build on when creating your applications. You can access these clients through the Atlas App Services UI, Realm CLI, or GitHub. ## Template Apps Available\n\n ← [Service Limitations](https://mongodb.com/docs/atlas/app-services/reference/service-limitations/ \"Previous Section\")[Third-Party Licenses](https://mongodb.com/docs/atlas/app-services/reference/third-party-licenses/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/services/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Third-Party Services \\[Deprecated\\] On this page * [Introduction](#introduction)\n* [Concepts](#concepts)\n* [Service Clients \\[Deprecated\\]](#service-clients--deprecated-)\n* [Service Actions \\[Deprecated\\]](#service-actions--deprecated-)\n* [Service Rules \\[Deprecated\\]](#service-rules--deprecated-)\n* [Incoming Webhooks \\[Deprecated\\]](#incoming-webhooks--deprecated-)\n* [Guides](#guides)\n* [Built-In Services](#built-in-services)\n* [Reference Documentation](#reference-documentation) ## Important ### Third Party Services & Push Notifications Deprecation Third party services and push notifications in App Services have been deprecated in favor of creating HTTP endpoints that use [external dependencies](https://mongodb.com/docs/atlas/app-services/functions/dependencies/#std-label-external-dependencies) in functions. Webhooks have been renamed to [HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) with no change in behavior. You should[migrate](https://mongodb.com/docs/atlas/app-services/services/convert-webhooks-to-endpoints/#std-label-convert-webhooks-to-endpoints) existing Webhooks. Existing services will continue to work until **1 Aug 2023**. Because third party services and push notifications are now deprecated, they have been removed by default from the App Services UI. If you need to manage an existing third party service or push notification, you can add the configurations back to the UI by doing the following: * In the left navigation, under the Manage section, clickApp Settings.\n* Enable the toggle switch next toTemporarily Re-Enable 3rd Party Services, and then save your changes. ## Introduction Modern applications often use multiple external services to handle complex use cases, such as messaging, analytics, and data management. You can connect to these services through Atlas App Services by creating and configuring service interfaces. Service interfaces specify the connection details for a specific external service and enable you to define the scope of that service's capabilities with custom [service rules](#std-label-service-rules). Once you've configured an interface for a service, you can instantiate a[service client](#std-label-service-clients) that connects to the interface and exposes the service's [actions](#std-label-service-actions) as methods. You can also create [incoming webhooks](#std-label-service-webhooks) that enable external services to communicate directly with your App over HTTP. ## Note ### Built-In Service Clients App Services includes clients for certain external services, such as [Twilio](https://mongodb.com/docs/atlas/app-services/services/twilio/) and [AWS](https://mongodb.com/docs/atlas/app-services/services/aws/). You can also use the [HTTP service](https://mongodb.com/docs/atlas/app-services/services/http/) to create a custom interface for any external service that offers a REST API. ## Concepts ### Service Clients \\[Deprecated\\] A service client is an object that connects to a service interface and enables you to call [actions](#std-label-service-actions) associated with the service. You can instantiate service clients in [functions](https://mongodb.com/docs/atlas/app-services/functions/) (using [function context](https://mongodb.com/docs/atlas/app-services/functions/context/#std-label-context-services)) as well as in your client application code. For details on instantiating and using service clients, see [Call a Service Action.](https://mongodb.com/docs/atlas/app-services/services/call-a-service-action/) ### Service Actions \\[Deprecated\\] A service action is a method that handles a specific use case for a particular service, such as [sending a text message](https://mongodb.com/docs/atlas/app-services/services/twilio-actions/send/) with Twilio or[putting an object](https://mongodb.com/docs/atlas/app-services/services/aws/#std-label-aws-usage-s3) to an AWS S3 bucket. Actions encapsulate implementation details like request authentication and HTTP methods behind semantic methods that are specific to each service.\n\n ## Important **App Services blocks all service actions by default.** You must[configure a service rule](https://mongodb.com/docs/atlas/app-services/services/configure/service-rules/) that enables a particular action before you can call it. ### Service Rules \\[Deprecated\\] A service rule is an [expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that App Services evaluates to determine whether or not a user can execute one or more [actions](#std-label-service-actions) in a service. For example, you could create a [Twilio](https://mongodb.com/docs/atlas/app-services/services/twilio/) rule that only lets users send a text message from a specific phone number or an [AWS](https://mongodb.com/docs/atlas/app-services/services/aws/) rule that prevents users from putting objects to an S3 bucket that is not included in a list of approved buckets. ## Note ### Expression Variables [Expression variables](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) are variables that you can include in service rules to represent dynamic information about your application and an action's execution. You can configure service rules based on the authenticated user that called an action ([%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user)) and the arguments that they provided ([%%args](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---args)). You can also create complex rules that [call a Function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-call-function-json-expression)([%function](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-operator--function)) and evaluate based on the Function's return value. ### Incoming Webhooks \\[Deprecated\\] An incoming webhook is a custom handler for events that originate from an external service, such as when someone opens a new pull request on[GitHub](https://mongodb.com/docs/atlas/app-services/services/github/) or sends a text message to a[Twilio](https://mongodb.com/docs/atlas/app-services/services/twilio/) phone number. Get started with incoming webhooks by [configuring a service webhook.](https://mongodb.com/docs/atlas/app-services/services/configure/service-webhooks/) Incoming webhooks consist of two primary components: the webhook URL and the webhook Function.\n\n ## Guides | Guide                                                                                       | Description                                                                                   |\n| ------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |\n| [Configure Third-Party Services](https://mongodb.com/docs/atlas/app-services/services/configure/services/)     | Learn how to create a new external service interface.                                         |\n| [Configure Service Webhooks](https://mongodb.com/docs/atlas/app-services/services/configure/service-webhooks/) | Learn how to configure and execute an incoming webhook to handle events in external services. |\n| [Configure Service Rules](https://mongodb.com/docs/atlas/app-services/services/configure/service-rules/)       | Learn how to safely expose a service action for use in a function or client application.      |\n| [Call a Service Action](https://mongodb.com/docs/atlas/app-services/services/call-a-service-action/)           | Learn how to call a service action from a function or client application.                     | ## Built-In Services | Subject                                                     | Description                                                                                                                                                    |\n| ----------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [Twilio Service](https://mongodb.com/docs/atlas/app-services/services/twilio/) | Includes service configuration parameters, directions for adding a webhook to Twilio, and additional information about Twilio service actions.                 |\n| [HTTP Service](https://mongodb.com/docs/atlas/app-services/services/http/)     | Includes additional information about HTTP service actions and webhooks.                                                                                       |\n| [AWS Service](https://mongodb.com/docs/atlas/app-services/services/aws/)       | Includes service configuration parameters, additional information about specifc AWS service actions, and generic directions for connecting to any AWS service. |\n| [GitHub Service](https://mongodb.com/docs/atlas/app-services/services/github/) | Includes service configuration parameters, directions for adding a webhook to GitHub, and guidance on validating incoming requests from GitHub.                | ## Reference Documentation\n\n ← [Push Notifications \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/reference/push-notifications/ \"Previous Section\")[Replace Services with npm Modules](https://mongodb.com/docs/atlas/app-services/services/replace-with-npm-modules/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/log_forwarders/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Log Forwarder Configuration Files You define log forwarder configuration files in the `/log_forwarders`directory. `| app/                |\n| ------------------- |\n| └── log_forwarders/ |\n| └── <Name>.json     | ` log\\_forwarders/<name>.json ``` {   \"name\": \"<name>\",   \"log_types\": [ \"<type>\", ... ],   \"log_statuses\": [ \"<status>\", ... ],   \"policy\": { batching policy },   \"action\": { action configuration } } \n```\n\n ← [HTTP Endpoint Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/http%5Fendpoints/ \"Previous Section\")[Third-Party Service Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/graphql/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # GraphQL Configuration Files On this page * [Service Configuration](#service-configuration)\n* [Custom Resolver Configuration](#custom-resolver-configuration) You can configure the [GraphQL API](https://mongodb.com/docs/atlas/app-services/graphql/#std-label-graphql-api) for your application in the `graphql` directory: `| app/                     |\n| ------------------------ |\n| └── graphql/             |\n| ├── config.json          |\n| └── custom_resolvers     |\n| └── <resolver name>.json | ` ## Service Configuration graphql/config.json ``` {   \"use_natural_pluralization\": <Boolean> } \n``` | Field                              | Description                                                                                                                                                                                                                                                                                                                                                                                 |\n| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| use\\_natural\\_pluralizationBoolean | If true, Atlas App Services uses the common English pluralization of a type name whenever possible.If false, or if App Services cannot determine a natural pluralization, the default plural type is the singular type with an\"s\" appended to the end.ExampleApp Services can use either a natural plural or a default plural for a generated \"mouse\" type:Natural: \"mice\"Default: \"mouses\" | ## Custom Resolver Configuration graphql/custom\\_resolvers/<resolver name>.json ``` {   \"on_type\": \"<Parent Type Name>\",   \"field_name\": \"<Resolver Field Name>\",   \"function_name\": \"<Resolver Function Name>\",   \"input_type\": \"<Input Type Name>\" | { <JSON Schema> },   \"input_type_format\": \"<Input Type Format>\",   \"payload_type\": \"<Payload Type Name>\" | { <JSON Schema> },   \"payload_type_format\": \"<Payload Type Format>\", } \n```\n\n ← [Function Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/functions/ \"Previous Section\")[Static Hosting Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/hosting/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/environments/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Environment Value Configuration Files On this page * [Environment Configuration](#environment-configuration) `| app/                    |\n| ----------------------- |\n| └── environments/       |\n| ├── no-environment.json |\n| ├── development.json    |\n| ├── testing.json        |\n| ├── qa.json             |\n| └── production.json     | ` ## Environment Configuration You can define variable values for each [environment](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-environment-values)in a `.json` file within the `/environments` directory that uses the environment name as its file name. Atlas App Services supports the following environments: * `\"\"`\n* `\"development\"`\n* `\"testing\"`\n* `\"qa\"`\n* `\"production\"` environments/<environment name>.json ``` {   \"values\": {     \"<Value Name>\": <Value>   } } \n``` | Field        | Description                                                                                                       |\n| ------------ | ----------------------------------------------------------------------------------------------------------------- |\n| valuesObject | An object where each property maps the name of an environment value name to its value in the current environment. | ← [MongoDB Data Source Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/data%5Fsources/ \"Previous Section\")[Function Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/functions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Atlas Device Sync Configuration Files You can configure [Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/#std-label-sync) for your application in the `sync`directory: `| app/            |\n| --------------- |\n| └── sync/       |\n| └── config.json | ` Refer to [Sync Configuration File Reference](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-appconfig-sync) for details. ← [Third-Party Service Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/services/ \"Previous Section\")[Trigger Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/triggers/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/legacy/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Application Configuration Files (Legacy) On this page * [Overview](#overview)\n* [When Will I Use Configuration Files?](#when-will-i-use-configuration-files-)\n* [Directory Structure](#directory-structure)\n* [Application Configuration](#application-configuration)\n* [Configuration](#configuration)\n* [Authentication Providers](#authentication-providers)\n* [Configuration](#configuration-1)\n* [Functions](#functions)\n* [Configuration](#configuration-2)\n* [Source Code](#source-code)\n* [MongoDB Services](#mongodb-services)\n* [Service Configuration](#service-configuration)\n* [Synced Cluster Configuration](#synced-cluster-configuration)\n* [MongoDB Collection Rules (Non-Sync)](#mongodb-collection-rules--non-sync-)\n* [External Services](#external-services)\n* [Service Configuration](#service-configuration-1)\n* [Service Rules](#service-rules)\n* [Incoming Webhooks](#incoming-webhooks)\n* [Triggers](#triggers)\n* [Configuration](#configuration-4)\n* [Hosting](#hosting)\n* [Metadata Configuration](#metadata-configuration)\n* [Values](#values)\n* [Configuration](#configuration-5) ## Note ### Legacy Page This page describes an older configuration file format still used by some existing applications. For an up-to-date description of Atlas App Services configuration files, see [App Configuration.](https://mongodb.com/docs/atlas/app-services/reference/config/#std-label-app-configuration) ## Overview App Services uses JSON files and source code files to define and configure every component of an application. Each component has a specific configuration file schema and every application uses a standard file structure to organize the configuration files. ### When Will I Use Configuration Files? Every App is composed of a collection of configuration files, so you use application configuration files whenever you create or modify an App. If you use the App Services UI then you rarely deal directly with the configuration files themselves, but other deployment methods, like [Realm CLI](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-cli) and [GitHub](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github) allow you to define and edit the configuration files directly. ### Directory Structure The following figure shows a high-level view of an App's directory structure:\n\n ` ## Application Configuration Application-level configuration information is defined in a single document named `config.json` stored in your application's root directory. ``` yourRealmApp/ └── config.json \n``` ### Configuration config.json ```javascript {   \"app_id\": \"\",   \"name\": \"\",   \"security\": {     \"allowed_request_origins\": [\"<Origin URL>\"]   },   \"hosting\": {     \"enabled\": <boolean>,     \"custom_domain\": \"<Custom Domain Name>\",     \"app_default_domain\": \"<Default Domain Name>\"   },   \"custom_user_data_config\": {     \"enabled\": <Boolean>     \"mongo_service_id\": \"<MongoDB Service ID>\",     \"database_name\": \"<Database Name>\",     \"collection_name\": \"<Collection Name>\",     \"user_id_field\": \"<Field Name>\"   }   \"deployment_model\": \"<Deployment Model Type>\",   \"location\": \"<Deployment Cloud Region Name>\",   \"config_version\": <Version Number> } \n```\n\n ## Authentication Providers [Authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers)are defined in your application's `/auth_providers`directory. Each provider is defined in its own JSON file named after the provider. For detailed information on configuring and using a specific authentication provider, see that provider's reference page. ``` yourRealmApp/ └── auth_providers/     └── <provider name>.json \n``` ### Configuration <provider name>.json ``` {   \"id\": \"<Provider ID>\",   \"name\": \"<Provider Name>\",   \"type\": \"<Provider Type>\",   \"disabled\": <Boolean>,   \"config\": {     \"<Configuration Option>\": <Configuration Value>   },   \"secret_config\": {     \"<Configuration Option>\": \"<Secret Name>\"   },   \"metadata_fields\": [{     \"required\": <Boolean>,     \"name\": \"Field Name\"   }] } \n```\n\n ## Functions Atlas Functions are defined in a sub-directory of your application's`/functions` directory. Each function maps to its own subdirectory with the same name as the function. Each function is configured in `config.json` and has its source code defined in `source.js`. ``` yourRealmApp/ └── functions/     └── <function name>/         ├── config.json         └── source.js \n``` ### Configuration config.json ``` {   \"id\": \"<Function ID>\",   \"name\": \"<Function Name>\",   \"private\": <Boolean>,   \"can_evaluate\": <Rule Expression>,   \"disable_arg_logs\": <Boolean>,   \"run_as_system\": <Boolean>,   \"run_as_user_id\": \"<App Services User ID>\",   \"run_as_user_id_script_source\": \"<Function Source Code>\" } \n```\n\n ### Source Code source.js ```javascript exports = function() {   // function code }; \n``` ## MongoDB Services Every [MongoDB Atlas data source](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-sources)linked to your app is configured as a service in the `/services`directory. Each data source maps to its own sub-directory with the same name as the service. The primary service configuration for a MongoDB Atlas data source is`config.json`, which defines connection parameters and sync rules. If the data source is not a [synced cluster](https://mongodb.com/docs/atlas/app-services/sync/) or[Federated database instance](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats), then you can define collection-level rules in the `/rules` sub-directory. ``` yourRealmApp/ └── services/     └── <MongoDB Service Name>/         ├── config.json         └── rules/             └── <rule name>.json \n``` ## Important MongoDB Service names are not necessarily the same as their linked data source's name in Atlas. You define the service name for a data source when you link it to your application. For linked clusters, the default MongoDB service name is `mongodb-atlas`. For Federated data sources, the default service name is`mongodb-datafederation`. ### Service Configuration The configuration file to link an Atlas cluster should have the following form: config.json ``` {   \"id\": \"<Service ID>\",   \"name\": \"<Service Name>\",   \"type\": \"mongodb-atlas\",   \"config\": {     \"clusterName\": \"<Atlas Cluster Name>\",     \"readPreference\": \"<Read Preference>\",     \"wireProtocolEnabled\": <Boolean>,     \"sync\": <Sync Configuration>   } } \n``` The configuration file for a Federated data source should have the following form: config.json ``` {   \"id\": \"<Service ID>\",   \"name\": \"<Service Name>\",   \"type\": \"datalake\",   \"config\": {      \"dataLakeName\": \"<Federated database instance name>\"    }  } \n``` Exactly one of `config.dataLakeName` and `config.clusterName` is required, depending on whether you are linking a cluster or a Federated data source.\n\n ### Synced Cluster Configuration The `config.sync` field of `config.json` determines if a cluster is[synced](https://mongodb.com/docs/atlas/app-services/sync/) and, if it is, defines the rules for sync operations on the cluster. config.json ``` {   ...,   \"config\": {     ...,     \"sync\": {       \"state\": <Boolean>,       \"development_mode_enabled\": <Boolean>,       \"database_name\": \"<Development Mode Database Name>\",       \"partition\": {         \"key\": \"<Partition Key Field Name>\",         \"type\": \"<Partition Key Value Type>\",         \"permissions\": {           \"read\": <JSON Expression>,           \"write\": <JSON Expression>         }       }     }   } } \n```\n\n ### MongoDB Collection Rules (Non-Sync) For non-synced clusters, you can define collection-level rules that App Services evaluates dynamically for each request. Each collection's rules are stored in a`rules.json` file in that collection's configuration subdirectory, which is`data_sources/<data-source-name>/<database-name>/<collection-name>/`. ## Note Federated data sources [do not support rules or schemas](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats). You can only access a Federated data source from a system function. <database.collection>.json ``` {   \"id\": \"<Rule ID>\",   \"database\": \"<Database Name>\",   \"collection\": \"<Collection Name>\",   \"roles\": [<Role>],   \"schema\": <Document Schema>,   \"filters\": [<Filter>], } \n```\n\n ## External Services [3rd party services](https://mongodb.com/docs/atlas/app-services/reference/services/) are defined in the `/services`directory. Each service maps to its own sub-directory with the same name as the service. Each service directory contains the following: * `config.json`: a service configuration file\n* `/rules`: a sub-directory of service rule configurations\n* `/incoming_webhooks`: a sub-directory of webhook configurations (if the service supports webhooks, i.e. HTTP, GitHub, or Twilio) ``` yourRealmApp/ └── services/     └── <services name>/         ├── config.json         ├── incoming_webhooks/         │   ├── config.json         │   └── source.js         └── rules/             └── <rule name>.json \n``` ### Service Configuration config.json ``` {   \"id\": \"<Service ID>\",   \"name\": \"<Service Name>\",   \"type\": \"<Service Type>\",   \"config\": {     \"<Configuration Option>\": <Configuration Value>   },   \"secret_config\": {     \"<Configuration Option>\": \"<Secret Name>\"   }, } \n```\n\n ### Service Rules Rules for a specific external service are defined in the `/<service name>/rules` sub-directory. Each rule maps to its own JSON file with the same name as the rule. <rule name>.json ``` {   \"id\": \"<Rule ID>\",   \"name\": \"<Rule Name>\",   \"actions\": [\"<Service Action Name>\"],   \"when\": <JSON Rule Expression> } \n``` | Field                | Description                                                                                                                                             |\n| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| idString             | A string that uniquely identifies the rule. App Services automatically generates a unique ID for a rule when you create it.                             |\n| nameString           | The name of the service rule. The name may be at most 64 characters long and can only contain ASCII letters, numbers, underscores, and hyphens.         |\n| actionsArray<String> | A list of service actions that the rule applies to. The specific actions available depend on the service type.                                          |\n| whenDocument         | A [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that evaluates to true when the rule applies to a given request. | ### Incoming Webhooks Incoming webhooks for a specific service are defined in the`/<service name>/incoming_webhooks/` sub-directory. Incoming webhooks use the [same configuration format as function](#std-label-legacy-appschema-functions) but have additional configuration parameters. #### Configuration config.json ``` {   \"id\": \"<Function ID>\",   \"name\": \"<Function Name>\",   \"private\": <Boolean>,   \"can_evaluate\": <Rule Expression>,   \"disable_arg_logs\": <Boolean>,   \"run_as_system\": <Boolean>,   \"run_as_user_id\": \"<App Services User ID>\",   \"run_as_user_id_script_source\": \"<Function Source Code>\",   \"respond_result\": <Boolean>,   \"options\": {     \"httpMethod\": \"<HTTP Method>\",     \"validationMethod\": \"<Webhook Validation Method>\",     \"secret\": \"<Webhook Secret>\"   } } \n```\n\n #### Source Code source.js ```javascript exports = function() {   // webhook function code }; \n``` ## Triggers [Triggers](https://mongodb.com/docs/atlas/app-services/triggers/) are defined in your application's`/triggers` directory. Each trigger is defined in its own JSON file with the same name as the trigger. ``` yourRealmApp/ └── triggers/     └── <trigger name>.json \n``` ### Configuration <trigger name>.json ``` {   \"id\": \"<Trigger ID>\",   \"name\": \"<Trigger Name>\",   \"type\": \"<Trigger Type>\",   \"function_name\": \"<Trigger Function Name>\",   \"config\": {     \"<Configuration Option>\": <Configuration Value>   },   \"disabled\": <Boolean>, } \n```\n\n ## Hosting Files that you want to [host on Atlas App Services](https://mongodb.com/docs/atlas/app-services/hosting/) should be included in your application's `/hosting` directory. Each file will be uploaded with the metadata defined in `metadata.json`. You can [configure the metadata](https://mongodb.com/docs/atlas/app-services/hosting/configure-file-metadata/)for each hosted file in `metadata.json`. This metadata configuration file is an array of documents that each correspond to a single hosted file's metadata attributes. ``` yourRealmApp/ └── hosting/     ├── metadata.json     └── files/         └── <files to host> \n``` ### Metadata Configuration metadata.json ``` [   {     \"path\": \"<File Resource Path>\",     \"attrs\": [{       \"name\": \"<Attribute Type>\",       \"value\": \"<Attribute Value>\"     }]   } ] \n```\n\n ## Note If you do not specify a `Content-Type` metadata attribute for a hosted file, Atlas App Services will attempt to automatically add a `Content-Type`attribute to it based on the file extension. For example, App Services would automatically add the attribute`Content-Type: application/html` to the file `myPage.html`. ## Values Values are defined in your application's `/values` directory. Each value is defined in its own JSON file named after the value. ``` yourRealmApp/ └── values/     └── <value name>.json \n``` ### Configuration <value name>.json ``` {   \"id\": \"<Value ID>\",   \"name\": \"<Value Name>\",   \"from_secret\": <boolean>,   \"value\": <Stored JSON Value|Secret Name> } \n```\n\n ← [Create Template Configurations with Expansions](https://mongodb.com/docs/atlas/app-services/reference/config/template-expansions/ \"Previous Section\")[App Services Metrics Reference](https://mongodb.com/docs/atlas/app-services/reference/metrics/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/triggers/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Trigger Configuration Files On this page * [General Configuration](#general-configuration)\n* [Database Triggers](#database-triggers)\n* [Authentication Triggers](#authentication-triggers)\n* [Scheduled Triggers](#scheduled-triggers) `| app/                    |\n| ----------------------- |\n| └── triggers/           |\n| └── <trigger name>.json | ` ## General Configuration All triggers conform to a base schema with specific variations depending on the trigger type. The following fields exist in _all_ trigger configuration files: triggers/<trigger name>.json ``` {   \"name\": \"<Trigger Name>\",   \"type\": \"<Trigger Type>\",   \"config\": {},   \"function_name\": \"<Trigger Function Name>\",   \"disabled\": <Boolean> } \n```\n\n ## Database Triggers Database trigger configurations conform to the base trigger schema with additional configuration options that specify which collection to watch and when to fire the trigger. The following fields exist in _database_ trigger configuration files: triggers/<trigger name>.json ``` {   \"name\": \"<Trigger Name>\",   \"type\": \"DATABASE\",   \"config\": {     \"service_name\": \"<MongoDB Service Name>\",     \"database\": \"<Database Name>\",     \"collection\": \"<Collection Name>\",     \"operation_types\": [\"<Operation Type>\", ...],     \"full_document\": <boolean>,     \"full_document_before_change\": <boolean>,     \"tolerate_resume_errors\": <boolean>,     \"unordered\": <boolean>,     \"match\": { <Match Filter> },     \"project\": { <Projection Filter> },   },   \"function_name\": \"<Trigger Function Name>\",   \"disabled\": <Boolean> } \n```\n\n ## Authentication Triggers Authentication trigger configurations conform to the base trigger schema with additional configuration options that specify which auth providers to watch and when to fire the trigger. The following fields exist in _authentication_ trigger configuration files: triggers/<trigger name>.json ``` {   \"name\": \"<Trigger Name>\",   \"type\": \"AUTHENTICATION\",   \"config\": {     \"operation_type\": [\"<Operation Type>\", ...],     \"providers\": [\"<Provider Type>\", ...],   },   \"function_name\": \"<Trigger Function Name>\",   \"disabled\": <Boolean> } \n``` | Field                        | Description                                                                                                                                                                                                                                                                            |\n| ---------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| config.operation\\_typeString | The [authentication operation type](https://mongodb.com/docs/atlas/app-services/triggers/authentication-triggers/#std-label-authentication-event-operation-types) that causes the trigger to fire.Valid operations types:\"LOGIN\"\"CREATE\"\"DELETE\"                                                          |\n| config.providersString\\[\\]   | A list of [authentication provider](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) types that the trigger watches.Valid provider types:\"anon-user\"\"local-userpass\"\"api-key\"\"custom-token\"\"custom-function\"\"oauth2-facebook\"\"oauth2-google\"\"oauth2-apple\" | ## Scheduled Triggers Scheduled trigger configurations conform to the base trigger schema with additional configuration options that specify the schedule on which the trigger fires. The following fields exist in _scheduled_ trigger configuration files: triggers/<trigger name>.json ``` {   \"name\": \"<Trigger Name>\",   \"type\": \"SCHEDULED\",   \"config\": {     \"schedule\": \"<CRON expression>\"   },   \"function_name\": \"<Trigger Function Name>\",   \"disabled\": <Boolean> } \n```\n\n ← [Atlas Device Sync Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/sync/ \"Previous Section\")[Value Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/values/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/values/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Value Configuration Files On this page * [Configuration](#configuration) You can define static [values](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-value) in the `/values` directory. Each value is defined in its own JSON file with the same name as the value. `| app/                  |\n| --------------------- |\n| └── values/           |\n| └── <value name>.json | ` ## Configuration <value name>.json ``` {   \"id\": \"<Value ID>\",   \"name\": \"<Value Name>\",   \"from_secret\": <boolean>,   \"value\": <Stored JSON Value|Secret Name> } \n```\n\n ← [Trigger Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/triggers/ \"Previous Section\")[Create Template Configurations with Expansions](https://mongodb.com/docs/atlas/app-services/reference/config/template-expansions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/template-expansions/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Create Template Configurations with Expansions On this page * [Define a Template](#define-a-template)\n* [Define Environment Values](#define-environment-values)\n* [Define an Expansion Replacement](#define-an-expansion-replacement)\n* [Specify an Environment](#specify-an-environment)\n* [Create a New Templated App](#create-a-new-templated-app)\n* [Development Workflow](#development-workflow) Atlas App Services supports a replacement operator (`%()`) that dynamically resolves JSON expansions like [%%environment](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---environment) in your [configuration files](https://mongodb.com/docs/atlas/app-services/reference/config/#std-label-app-configuration). When you create a new app with configuration files that include expansions (either with [Realm CLI](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-cli) or through[GitHub](https://mongodb.com/docs/atlas/app-services/apps/deploy-github/#std-label-deploy-github)), App Services automatically resolves the expansions and uses the resolved configuration files to create the app. ## Important Configuration files that use the replacement operator are _templates_. App Services does not resolve the expansions after it creates the app. Instead, it uses a copy of the configuration files that reflect the resolved values at the time the app was created. ## Define a Template 1 ### Define Environment Values You can use expansions to template any environment. For each environment that you use, define values that you reference in your configuration files. ## Example The following environments configure different MongoDB Atlas cluster names: environments/development.json `| {                                  |\n| ---------------------------------- |\n| \"values\": {                        |\n| \"clusterName\": \"atlas-development\" |\n| }                                  |\n| }                                  | ` environments/production.json ``` {   \"values\": {     \"clusterName\": \"atlas-production\"   } } \n``` 2 ### Define an Expansion Replacement You can reference any environment value from a configuration file with the`%()` replacement operator and the [%%environment](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---environment)expansion. Define expansions for each configuration file you want to template. ## Example The following template configuration file for the `mongodb-atlas` data source uses expansions to dynamically resolve `clusterName` based on the environment: data\\_sources/mongodb-atlas/config.json ``` {   \"name\": \"mongodb-atlas\",   \"type\": \"mongodb-atlas\",   \"config\": {     \"clusterName\": \"%(%%environment.values.clusterName)\",     \"readPreference\": \"primaryPreferred\",     \"wireProtocolEnabled\": true   } } \n``` 3 ### Specify an Environment Choose which environment to deploy your app to and then update the app configuration with the environment name: realm\\_config.json ``` {   \"name\": \"MyApp\",   \"environment\": \"development\",   \"deployment_model\": \"LOCAL\",   \"location\": \"aws-us-east-1\" } \n``` ## Tip If you do not specify an environment, `%%environment`expansions resolve to values in`environments/no-environment.json`. 4 ### Create a New Templated App You can now use your templated configuration files to create a new app in your chosen environment. ## Example App Services uses the template configuration to generate new, resolved configuration files on import: ```shell realm-cli push \n```\n\n ``` {   \"name\": \"mongodb-atlas\",   \"type\": \"mongodb-atlas\",   \"config\": {     \"clusterName\": \"atlas-development\",     \"readPreference\": \"primaryPreferred\",     \"wireProtocolEnabled\": true   } } \n``` ## Development Workflow You can use configuration expansions for any App, but the most useful case is for teams that develop a production application with source code files stored in an external version control system like GitHub. You can create independent apps to develop features or test changes and use expansions to customize the apps based on their environment. 1. [Create a copy](https://mongodb.com/docs/atlas/app-services/apps/copy/#std-label-copy-app) of the common template with the environment set to `development`. If you're using Git, create a new branch on GitHub and check out a local copy.\n2. Make changes and test them locally against the development app. Any changes you make to the app won't affect the production app, though they may still read and write production data sources and services unless you configure alternatives.\n3. Commit changes and merge them back to production. You can set up a CI/CD pipeline, which may itself create an app in the `test` environment, to validate and merge your changes into the production branch.\n4. Once your changes are merged, you can safely delete the development app and clean up any other associated services. ← [Value Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/values/ \"Previous Section\")[Application Configuration Files (Legacy)](https://mongodb.com/docs/atlas/app-services/reference/config/legacy/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/auth/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # User & Authentication Provider Configuration Files On this page * [Authentication Providers](#authentication-providers)\n* [Configuration](#configuration)\n* [Custom User Data](#custom-user-data) `| app/                      |\n| ------------------------- |\n| └── auth/                 |\n| ├── providers.json        |\n| └── custom_user_data.json | ` ## Authentication Providers ### Configuration You can enable and configure [authentication providers](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) in `/auth/providers.json`. Each field of the configuration is the name of a provider type and contains a configuration object for that provider. Authentication provider configurations share a common structure but each provider type uses a unique set of configuration fields. ## Tip You can find detailed information on a specific provider's configuration on that provider's reference page. For a list of all provider reference pages, see [Authentication Providers.](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) /auth/providers.json ```javascript {   \"<Provider Name>\": {     \"name\": \"<Provider Name>\",     \"type\": \"<Provider Type>\",     \"disabled\": <Boolean>,     \"config\": {       \"<Configuration Option>\": \"<Configuration Value>\"     },     \"secret_config\": {       \"<Configuration Option>\": \"<Secret Name>\"     },     \"metadata_fields\": [       {         \"required\": <Boolean>,         \"name\": \"Field Name\"       },       ...     ],     \"redirect_uris\": [\"<Application Redirect URI>\", ...]   },   ... } \n```\n\n ## Custom User Data You can configure the [custom user data](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data)collection for your app in `/auth/custom_user_data.json`. /auth/custom\\_user\\_data.json ```javascript {   \"enabled\": <Boolean>,   \"mongo_service_name\": \"<MongoDB Data Source Name>\",   \"database_name\": \"<Database Name>\",   \"collection_name\": \"<Collection Name>\",   \"user_id_field\": \"<Field Name>\",   \"on_user_creation_function_name\": \"<Function Name>\" } \n```\n\n ← [App Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/app/ \"Previous Section\")[MongoDB Data Source Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/data%5Fsources/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/functions/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Function Configuration Files On this page * [Function Manifest](#function-manifest)\n* [Function Source Code](#function-source-code) `| app/              |\n| ----------------- |\n| └── functions/    |\n| ├── config.json   |\n| └── <function>.js | ` ## Function Manifest Every [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions) in your app has a corresponding metadata entry in the function manifest file: `/functions/config.json`. ## Tip Atlas App Services automatically adds functions to the manifest on import if they don't already have a configuration defined. If you're okay with the default settings, you can skip defining the configuration for a function and let App Services do it for you. The manifest will include the generated configurations the next time you export or pull your app. functions/config.json ``` [   {     \"name\": \"<Function Name>\",     \"private\": <Boolean>,     \"can_evaluate\": { <JSON Expression> },     \"disable_arg_logs\": <Boolean>,     \"run_as_system\": <Boolean>,     \"run_as_user_id\": \"<App Services User ID>\",     \"run_as_user_id_script_source\": \"<Function Source Code>\"   },   ... ] \n```\n\n ## Function Source Code You define a function's source code in a `.js` file within the `/functions`directory that uses the function name as its file name. Each file must export the main function that runs whenever a request calls the function. ## Important All of your function source code files must be in the `/functions`directory. App Services does not recognize functions nested in subdirectories of`/functions`. /functions/<function name>.js ```javascript exports = function addOne(input) {   if(typeof input !== \"number\") {     throw new Error(\"You must call addOne() with a number\");   }   return input + 1; }; \n``` ← [Environment Value Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/environments/ \"Previous Section\")[GraphQL Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/graphql/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/partition-based-sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Partition-Based Sync On this page * [Overview](#overview)\n* [Key Terms](#key-terms)\n* [Partition](#partition)\n* [Partition Key](#partition-key)\n* [Change a Partition Key](#change-a-partition-key)\n* [Partition Value](#partition-value)\n* [Enable Partition-Based Sync](#enable-partition-based-sync)\n* [Before You Begin](#before-you-begin)\n* [Procedure](#procedure)\n* [Navigate to the Sync Configuration Screen](#navigate-to-the-sync-configuration-screen)\n* [Select Development Details](#select-development-details)\n* [Choose a Partition Key](#choose-a-partition-key)\n* [Define Read & Write Permissions](#define-read---write-permissions)\n* [Check Default Advanced Configuration Behaviors](#check-default-advanced-configuration-behaviors)\n* [Turn On Sync](#turn-on-sync)\n* [Authenticate a MongoDB Atlas User](#authenticate-a-mongodb-atlas-user)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Add a Sync Configuration](#add-a-sync-configuration)\n* [Choose a Partition Key](#choose-a-partition-key-1)\n* [Define Read & Write Permissions](#define-read---write-permissions-1)\n* [Specify Values for Sync Optimization](#specify-values-for-sync-optimization)\n* [Deploy the Sync Configuration](#deploy-the-sync-configuration)\n* [Select a Cluster to Sync](#select-a-cluster-to-sync)\n* [Choose a Partition Key](#choose-a-partition-key-2)\n* [Define Read & Write Permissions](#define-read---write-permissions-2)\n* [Specify Values for Sync Optimization](#specify-values-for-sync-optimization-1)\n* [Deploy the Sync Configuration](#deploy-the-sync-configuration-1)\n* [Partition-Based Rules and Permissions](#partition-based-rules-and-permissions)\n* [Partition-Based Sync Rule Behavior](#partition-based-sync-rule-behavior)\n* [Partition-Based Sync Permissions](#partition-based-sync-permissions)\n* [Key Concepts](#key-concepts)\n* [Read Permissions](#read-permissions)\n* [Write Permissions](#write-permissions)\n* [Permission Strategies](#permission-strategies)\n* [Global Permissions](#global-permissions)\n* [Permissions for Specific Partitions](#permissions-for-specific-partitions)\n* [Permissions for Specific Users](#permissions-for-specific-users)\n* [Permissions Based on User Data](#permissions-based-on-user-data)\n* [Function Rules](#function-rules)\n* [Partition Strategies](#partition-strategies)\n* [Firehose Strategy](#firehose-strategy)\n* [User Strategy](#user-strategy)\n* [Team Strategy](#team-strategy)\n* [Channel Strategy](#channel-strategy)\n* [Region Strategy](#region-strategy)\n* [Bucket Strategy](#bucket-strategy)\n* [Asymmetric Sync?](#asymmetric-sync-)\n* [Partition-Based Sync Configuration](#partition-based-sync-configuration)\n* [Alter Your Partition-Based Sync Configuration](#alter-your-partition-based-sync-configuration) ## Overview\n\n In [Partition-Based Sync](#std-label-partition-based-sync), documents in a synced cluster form a \"partition\" by having the same value for a field designated as \"partition key\". All documents in a partition have the same read/write permissions for a given user. In Partition-Based Sync, you define a partition key whose value determines whether the user can read or write a document. App Services evaluates a set of rules to determine whether users can read or write to a given partition. App Services directly maps a partition to individual synced `.realm` files. Each object in a synced realm has a corresponding document in the partition. ## Example Consider an inventory management application using Partition-Based Sync. If you use `store_number` as the partition key, each store can read and write documents pertaining to its inventory. An example of the permissions for this type of app might be: `| { \"%%partition\": \"Store 42\" } |\n| ----------------------------- | ` Store employees could have read and write access to documents whose store number is Store 42. Customers, meanwhile, could have read-only access to store inventory. In the client, you pass a value for the partition key when opening a synced realm. App Services then syncs objects whose partition key value matches the value passed in from the client application. ## Example Based on the store inventory example above, the SDK might pass in`store42` as the `partitionValue` in the sync configuration. This would sync any InventoryItem whose `partitionValue` was`store42`. You can use [custom user data](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) to indicate whether a logged-in user is a store employee or a customer. Store employees would have read and write permission for the `store42`data set, while customers would have only read permission for the same data set. ```javascript const config = {   schema: [InventoryItem], // predefined schema   sync: {     user: app.currentUser, // already logged in user     partitionValue: \"store42\",   }, }; try {   const realm = await Realm.open(config);   realm.close(); } catch (err) {   console.error(\"failed to open realm\", err.message); } \n``` ## Key Terms ### Partition A **partition** is a collection of objects that share the same partition key value. A MongoDB Atlas cluster consists of several remote servers. These servers provide the storage for your synced data. The Atlas cluster stores documents in collections. Each MongoDB collection maps to a different Realm object type. Each document in a collection represents a specific Realm object. A synced realm is a local file on a device. A synced realm may contain some or all the objects relevant to the end user. A client app may use more than one synced realm to access all the objects that the application needs. Partitions link objects in Realm Database to documents in MongoDB. When you initialize a synced realm file, one of its parameters is a partition value. Your client app creates objects in the synced realm. When those objects sync, the partition value becomes a field in the MongoDB documents. The value of this field determines which MongoDB documents the client can access. At a high level: * A partition maps to a subset of the documents in a synced cluster.\n* All documents in a partition have the same read/write permissions for a given user.\n* Atlas App Services maps each partition to an individual synced `.realm` file.\n* Each object in a synced realm has a corresponding document in the partition. ![A diagram that explains partitioning using groups of shapes and colors. MongoDB collections group by shape (equivalent to object types) while realms group by color (equivalent to partition value).](https://mongodb.com/docs/atlas/app-services/images/partitioning.png) Partitions shape data in an Atlas <<https://www.mongodb.com/realm?tck=realm-docs#atlas-form-container>\\>\\`\\_ cluster. Each shape represents an object type. Partitions are determined by each shape's `color`: red, green, or blue. ### Partition Key A **partition key** is a named field that you specify when you[configure Atlas Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/enable-sync/#std-label-enable-sync). Device Sync uses this key to determine which partition contains a given document. Depending on your data model and the complexity of your app, your partition key could be either:\n\n You can make the partition key required or optional on your objects. App Services maps any object that does not include a partition key to a default partition - _null partition_. Consider the following when choosing a partition key: * Partition keys must be one of these types: `String`, `ObjectID`,`Long`, or `UUID`.\n* App Services clients should never modify the partition value directly. You cannot use any field that clients can modify as a partition key.\n* Partition keys use the same field name in every synced document. The partition key should not collide with any field name in any object's model. ## Example The following schemas demonstrate natural and synthetic partition keys: * The `owner_id` field is a natural key because it's already part of the app's data model.\n* The `_partition` field is a synthetic key because its only purpose is to serve as a partition key. An app can only specify a single partition key, but either of these fields could work depending on your use case: ``` {   \"title\": \"note\",   \"bsonType\": \"object\",   \"required\": [     \"_id\",     \"_partition\",     \"owner_id\",     \"text\"   ],   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"_partition\": { \"bsonType\": \"string\" },     \"owner_id\": { \"bsonType\": \"string\" },     \"text\": { \"bsonType\": \"string\" }   } } {   \"title\": \"notebook\",   \"bsonType\": \"object\",   \"required\": [     \"_id\",     \"_partition\",     \"owner_id\",     \"notes\"   ],   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"_partition\": { \"bsonType\": \"string\" },     \"owner_id\": { \"bsonType\": \"string\" },     \"notes\": {       \"bsonType\": \"array\",       \"items\": { \"bsonType\": \"objectId\" }     }   } } \n``` #### Change a Partition Key Your app's partition key is a central part of a Sync-enabled app's data model. When you set a partition key in your Sync configuration, you cannot later reassign the key's field. If you need to change a partition key, you must terminate sync. Then, you can enable it again with the new partition key. However, this requires all client applications to reset and sync data into new realms. ## Warning ### Restore Sync after Terminating Sync When you terminate and re-enable Atlas Device Sync, clients can no longer Sync. Your client must implement a client reset handler to restore Sync. This handler can discard or attempt to recover unsynchronized changes. ### Partition Value A **partition value** is a value of the partition key field for a given document. Documents with the same partition value belong to the same partition. They sync to the same realm file, and share user-level data access permissions. A partition's value is the identifier for its corresponding synced realm. You specify the partition's value when you open it as a synced realm in the client. If you change a partition value in Atlas, App Services interprets the change as two operations: * A delete from the old partition.\n* An insert into the new partition. ## Warning If you change a document's partition value, you lose client-side unsynced changes to the object. ## Enable Partition-Based Sync ### Before You Begin You will need the following to enable Partition-Based Sync: * An App Services App. To learn how to create an App, see [Create an App.](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app)\n* A linked Atlas data source. To learn how to add a data source, see[Link a Data Source.](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-link-a-data-source) ### Procedure ## Partition-Based Rules and Permissions\n\n ### Partition-Based Sync Rule Behavior Sync rules apply to specific partitions and are coupled to your app's data model by the partition key. Consider the following behavior when designing your schemas to ensure that you have appropriate data access granularity and don't accidentally leak sensitive information. * Sync rules apply dynamically based on the user. One user may have full read & write access to a partition while another user has only read permissions or is unable to access the partition entirely. You control these permissions by defining [JSON expressions.](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions)\n* Sync rules apply equally to all objects in a partition. If a user has read or write permission for a given partition then they can read or modify all synced fields of any object in the partition.\n* Write permissions require read permissions, so a user with write access to a partition also has read access regardless of the defined read permission rules. ### Partition-Based Sync Permissions App Services enforces dynamic, user-specific read and write permissions to secure the data in each [partition](#std-label-sync-partitions). You define permissions with[JSON rule expressions](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that control whether or not a given user has read or write access to the data in a given partition. App Services evaluates a user's permissions every time they open a synced realm. ## Tip Your rule expressions can use JSON expansions like[%%partition](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---partition) and [%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user) to dynamically determine a user's permissions based on the context of their request. ### Key Concepts #### Read Permissions A user with read permissions for a given partition can view all fields of any object in the corresponding synced realm. Read permissions do not permit a user to modify data. #### Write Permissions A user with write permissions for a given partition can modify the value of any field of any object in the corresponding synced realm. Write permissions require read permissions, so any user that can modify data can also view that data before and after it's modified. ### Permission Strategies You can structure your read and write permission expressions as a set of permission strategies that apply to your [partition strategy](#std-label-partition-strategies). The following strategies outline common approaches that you might take to define sync read and write permissions for your app. #### Global Permissions You can define global permissions that apply to all users for all partitions. This is, in essence, a choice to not implement user-specific permissions in favor of universal read or write permissions that apply to all users. To define a global read or write permission, specify a boolean value or a[JSON expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that always evaluates to the same boolean value. | Example            | Description                                                                                         |\n| ------------------ | --------------------------------------------------------------------------------------------------- |\n| true               | The expression true means that all users have the given access permissions for all partitions.      |\n| false              | The expression false means that no users have the given access permissions for any partitions.      |\n| { \"%%true\": true } | This expression always evaluates to true, so it's effectively the same as directly specifying true. | #### Permissions for Specific Partitions You can define permissions that apply to a specific partition or a groups of partitions by explicitly specifying their partition values.\n\n #### Permissions for Specific Users You can define permissions that apply to a specific user or a group of users by explicitly specifying their ID values. | Example                                                                                                                                    | Description                                                                                                                              |\n| ------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- |\n| { \"%%user.id\": \"5f4863e4d49bd2191ff1e623\" }                                                                                                | This expression means that the user with id\"5f4863e4d49bd2191ff1e623\" has the given access permissions for data in any partition.        |\n| {  \"%%user.id\": {    \"$in\": \\[      \"5f4863e4d49bd2191ff1e623\",      \"5f48640dd49bd2191ff1e624\",      \"5f486417d49bd2191ff1e625\"    \\]  }} | This expression means that any user with one of the specified user ID values has the given access permissions for data in any partition. | #### Permissions Based on User Data You can define permissions that apply to users based on specific data defined in their [custom user data](https://mongodb.com/docs/atlas/app-services/users/custom-metadata/#std-label-custom-user-data) document, metadata fields, or other data from an authentication provider. | Example                                                  | Description                                                                                                                                               |\n| -------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| { \"%%user.custom\\_data.readPartitions\" : \"%%partition\" } | This expression means that a user has read access to a partition if the partition value is listed in the readPartitionsfield of their custom user data.   |\n| { \"%%user.data.writePartitions\" : \"%%partition\" }        | This expression means that a user has write access to a partition if the partition value is listed in thedata.writePartitions field of their user object. | #### Function Rules\n\n | Example                                                                                                                                                                                                                                                                                                                                                                                                                | Description                                                                                                                                                                                                                                                                                                    |\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| {  \"%%true\": {    \"%function\": {      \"name\": \"canReadPartition\",      \"arguments\": \\[\"%%partition\"\\]    }  }}// canReadPartitionexports \\= async (partition) \\=\\> {  const cluster \\= context.services.get(\"mongodb-atlas\");  const permissions \\= cluster    .db(\"myApp\")    .collection(\"permissions\");  const { canRead } \\= await permissions.findOne({ partition });  return canRead.includes(context.user.id);} | This expression calls the canReadPartition function and passes in the partition value as its first and only argument. The function looks up the user's permissions for the partition from a MongoDB collection and then returns a boolean that indicates if the user can read data in the requested partition. | ## Partition Strategies A **partition strategy** is a key/value pattern to divide objects into partitions. Different use cases call for different partition strategies. You can compose partition strategies within the same app to form a larger strategy. This enables you to handle arbitrarily complex use cases.\n\n When developing a partition strategy, consider: * **Data Security:** Users may need different read and write access permissions to subsets of data. Consider the permissions users need for types of documents. A user has the same permissions for every document in a partition.\n* **Storage Capacity:** Your client apps may have limited on-device storage on some devices and platforms. A partition strategy should take storage limitations into account. Make sure a user can store their synced data on their device. ## Tip ### Combine Strategies You can use a partition key name like `_partition` with a query string as the value. This lets you use multiple strategies in the same app. For example: ```javascript _partitionKey: \"user_id=abcdefg\" _partitionKey: \"team_id=1234&city='New York, NY'\" \n``` You can use functions and rule expressions to parse the string. Sync can determine whether a user has access to a partition based on the combined strategy. ### Firehose Strategy A firehose partition strategy groups all documents into a single partition. With this structure, every user syncs all of your app's data to their device. This approach is functionally a decision to not partition data. This works for basic applications or small public data sets. * **Data Security.** All data is public to clients with a realm that uses the partition. If a user has read or write access to the partition, they can read or write _any_ document.\n* **Storage Capacity.** Every user syncs every document in the partition. All data must fit within your most restrictive storage limitation. Use this strategy only when data sets are small and do not grow quickly. One way to create a firehose is to set the partition key as an optional field. Don't include a value for this field in any document. App Services maps any document that doesn't include a partition value to the **null partition**. You can also set a **static partition value**. This is when the partition value doesn't change based on the user or data. For example, realms across all clients could use the partition value `\"MyPartitionValue\"`. ## Example An app lets users browse scores and statistics for local high school baseball games. Consider the following documents in the `games` and`teams` collections: ```javascript collection games: [   { teams: [\"Brook Ridge Miners\", \"Southside Rockets\"], score: { ... }, date: ... }   { teams: [\"Brook Ridge Miners\", \"Uptown Bombers\"], score: { ... }, date: ... }   { teams: [\"Brook Ridge Miners\", \"Southside Rockets\"], score: { ... }, date: ... }   { teams: [\"Southside Rockets\", \"Uptown Bombers\"], score: { ... }, date: ... }   { teams: [\"Brook Ridge Miners\", \"Uptown Bombers\"], score: { ... }, date: ... }   { teams: [\"Southside Rockets\", \"Uptown Bombers\"], score: { ... }, date: ... } ] collection teams: [   { name: \"Brook Ridge Miners\" }   { name: \"Southside Rockets\" }   { name: \"Uptown Bombers\" } ] \n``` The total number of games is small. A small number of local teams only play a few games each year. Most devices should be able to download all game data for easy offline access. In this case, the firehose strategy is appropriate. The data is public and documents don't need a partition key. The strategy maps the collections to the following realms: ```javascript realm null: [   Game { teams: [\"Brook Ridge Miners\", \"Southside Rockets\"], score: { ... }, date: ... }   Game { teams: [\"Brook Ridge Miners\", \"Uptown Bombers\"], score: { ... }, date: ... }   Game { teams: [\"Brook Ridge Miners\", \"Southside Rockets\"], score: { ... }, date: ... }   Game { teams: [\"Southside Rockets\", \"Uptown Bombers\"], score: { ... }, date: ... }   Game { teams: [\"Brook Ridge Miners\", \"Uptown Bombers\"], score: { ... }, date: ... }   Game { teams: [\"Southside Rockets\", \"Uptown Bombers\"], score: { ... }, date: ... }   Team { name: \"Brook Ridge Miners\" }   Team { name: \"Southside Rockets\" }   Team { name: \"Uptown Bombers\" } ] \n``` ### User Strategy\n\n * **Data Security.** Data in a user partition is specific to a given user. It may contain information private to that user. Each user syncs only their own partition. Other users cannot access documents in the partition.\n* **Storage Capacity.** Each user only syncs data from their own partition. Their data must fit within their device's storage constraints. Use this strategy only when each user has a manageable amount of data. ## Example A music streaming app stores data about playlists and song ratings for each user. Consider the following documents in the `playlists` and `ratings`collections: ```javascript collection playlists: [   { name: \"Work\", owner_id: \"dog_enthusiast_95\", song_ids: [ ... ] }   { name: \"Party\", owner_id: \"cat_enthusiast_92\", song_ids: [ ... ] }   { name: \"Soup Tunes\", owner_id: \"dog_enthusiast_95\", song_ids: [ ... ] }   { name: \"Disco Anthems\", owner_id: \"PUBLIC\", song_ids: [ ... ] }   { name: \"Deep Focus\", owner_id: \"PUBLIC\", song_ids: [ ... ] } ] collection ratings: [   { owner_id: \"dog_enthusiast_95\", song_id: 3, rating: -1 }   { owner_id: \"cat_enthusiast_92\", song_id: 1, rating: 1 }   { owner_id: \"dog_enthusiast_95\", song_id: 1, rating: 1 } ] \n``` Every document includes the `owner_id` field. This is a good partition key for a user partition strategy. It naturally maps documents to individual users. This limits the data on each device to playlists and ratings for the device's user. * Users have read and write access to their user realm. This contains playlists they have created and ratings that they've given to songs.\n* Every user has read access to the realm for partition value `PUBLIC`. This contains playlists that are available to all users. The strategy maps the collections to the following realms: ```javascript realm dog_enthusiast_95: [   Playlist { name: \"Work\", owner_id: \"dog_enthusiast_95\", song_ids: [ ... ] }   Playlist { name: \"Soup Tunes\", owner_id: \"dog_enthusiast_95\", song_ids: [ ... ] }   Rating { owner_id: \"dog_enthusiast_95\", song_id: 3, rating: -1 }   Rating { owner_id: \"dog_enthusiast_95\", song_id: 1, rating: 1 } ] realm cat_enthusiast_92: [   Playlist { name: \"Party\", owner_id: \"cat_enthusiast_92\", song_ids: [ ... ] }   Rating { owner_id: \"cat_enthusiast_92\", song_id: 1, rating: 1 } ] realm PUBLIC: [   Playlist { name: \"Disco Anthems\", owner_id: \"PUBLIC\", song_ids: [ ... ] }   Playlist { name: \"Deep Focus\", owner_id: \"PUBLIC\", song_ids: [ ... ] } ] \n``` ### Team Strategy A team partition strategy groups private documents shared by a team of users. A team might include a store location's employees or a band's members. Each team has a partition specific to that group. All users in the team share access and ownership of the team's documents. * **Data Security.** Data in a team partition is specific to a given team. It may contain data private to the team but not to a member of the team. Each user syncs partitions for the teams they belong to. Users not in a team cannot access documents in the team's partition.\n* **Storage Capacity:** Each user only syncs data from their own teams. The data from a user's teams must fit within their device's storage constraints. Use this strategy when users belong to a manageable number of teams. If users belong to many teams, the combined realms could contain a lot of data. You may need to limit the number of team partitions synced at a time. ## Example An app lets users create projects to collaborate with other users. Consider the following documents in the `projects`and `tasks` collections: ```javascript collection projects: [\n\n   { name: \"API\", owner_id: \"api-team\", task_ids: [ ... ] } ] collection tasks: [   { status: \"complete\", owner_id: \"api-team\", text: \"Import dependencies\" }   { status: \"inProgress\", owner_id: \"api-team\", text: \"Create app MVP\" }   { status: \"inProgress\", owner_id: \"api-team\", text: \"Investigate off-by-one issue\" }   { status: \"todo\", owner_id: \"api-team\", text: \"Write tests\" }   { status: \"inProgress\", owner_id: \"cli-team\", text: \"Create command specifications\" }   { status: \"todo\", owner_id: \"cli-team\", text: \"Choose a CLI framework\" } ] \n``` Every document includes the `owner_id` field. This is a good partition key for a team partition strategy. It naturally maps documents to individual teams. This limits the data on each device. Users only have projects and tasks that are relevant to them. * Users have read and write access to partitions owned by teams where they're a member.\n* Data stored in a `teams` or `users` collection can map users to team membership:  \n```javascript  \ncollection teams: [  \n  { name: \"cli-team\", member_ids: [ ... ] }  \n  { name: \"api-team\", member_ids: [ ... ] }  \n]  \ncollection users: [  \n  { name: \"Joe\", team_ids: [ ... ] }  \n  { name: \"Liz\", team_ids: [ ... ] }  \n  { name: \"Matt\", team_ids: [ ... ] }  \n  { name: \"Emmy\", team_ids: [ ... ] }  \n  { name: \"Scott\", team_ids: [ ... ] }  \n]  \n``` The strategy maps the collections to the following realms: ```javascript realm cli-team: [   Project { name: \"CLI\", owner_id: \"cli-team\", task_ids: [ ... ] }   Task { status: \"inProgress\", owner_id: \"cli-team\", text: \"Create command specifications\" }   Task { status: \"todo\", owner_id: \"cli-team\", text: \"Choose a CLI framework\" } ] realm api-team: [   Project { name: \"API\", owner_id: \"api-team\", task_ids: [ ... ] }   Task { status: \"complete\", owner_id: \"api-team\", text: \"Import dependencies\" }   Task { status: \"inProgress\", owner_id: \"api-team\", text: \"Create app MVP\" }   Task { status: \"inProgress\", owner_id: \"api-team\", text: \"Investigate off-by-one issue\" }   Task { status: \"todo\", owner_id: \"api-team\", text: \"Write tests\" } ] \n``` ### Channel Strategy A channel partition strategy groups documents for a common topic or domain. Each topic or domain has its own partition. Users can choose to access or subscribe to specific channels. A name or ID may identify these channels in a public list. * **Data Security.** Data in a channel partition is specific to a topic or area. Users can choose to access these channels. You can limit a user's access to a subset of channels. You could prevent users from accessing channels entirely. When user has read or write permission for a channel, they can access any document in the partition.\n* **Storage Capacity.** Users can choose to sync data from any allowed channel. All data from a user's channels must fit within their device's storage constraints. Use this strategy to partition public or semi-private data sets. This strategy breaks up data sets that would not fit within storage constraints. ## Example An app lets users create chatrooms based on topics. Users can search for and join channels for any topic that interests them. Consider these documents in the `chatrooms` and `messages` collections: ```javascript collection chatrooms: [   { topic: \"cats\", description: \"A place to talk about cats\" }   { topic: \"sports\", description: \"We like sports and we don't care who knows\" } ] collection messages: [   { topic: \"cats\", text: \"Check out this cute pic of my cat!\", timestamp: 1625772933383 }\n\n   { topic: \"sports\", text: \"Did you catch the game last night?\", timestamp: 1625772965383 }   { topic: \"sports\", text: \"Yeah what a comeback! Incredible!\", timestamp: 1625772970383 }   { topic: \"sports\", text: \"I can't believe how they scored that goal.\", timestamp: 1625773000383 } ] \n``` Every document includes the `topic` field. This is a good partition key for a channel partition strategy. It naturally maps documents to individual channels. This reduces the data on each device. Data only contains messages and metadata for channels the user has chosen. * Users have read and write access to chatrooms where they're subscribed. Users can change or delete any message - even those sent by other users. To limit write permissions, you could give users read-only access. Then, handle sending messages with a serverless function.\n* Store the use's subscribed channels in either the `chatrooms`or `users` collection:  \n```javascript  \ncollection chatrooms: [  \n  { topic: \"cats\", subscriber_ids: [ ... ] }  \n  { topic: \"sports\", subscriber_ids: [ ... ] }  \n]  \ncollection users: [  \n  { name: \"Joe\", chatroom_ids: [ ... ] }  \n  { name: \"Liz\", chatroom_ids: [ ... ] }  \n  { name: \"Matt\", chatroom_ids: [ ... ] }  \n  { name: \"Emmy\", chatroom_ids: [ ... ] }  \n  { name: \"Scott\", chatroom_ids: [ ... ] }  \n]  \n``` The strategy maps the collections to the following realms: ```javascript realm cats: [   Chatroom { topic: \"cats\", description: \"A place to talk about cats\" }   Message { topic: \"cats\", text: \"Check out this cute pic of my cat!\", timestamp: 1625772933383 }   Message { topic: \"cats\", text: \"Can anybody recommend a good cat food brand?\", timestamp: 1625772953383 } ] realm sports: [   Chatroom { topic: \"sports\", description: \"We like sports and we don't care who knows\" }   Message { topic: \"sports\", text: \"Did you catch the game last night?\", timestamp: 1625772965383 }   Message { topic: \"sports\", text: \"Yeah what a comeback! Incredible!\", timestamp: 1625772970383 }   Message { topic: \"sports\", text: \"I can't believe how they scored that goal.\", timestamp: 1625773000383 } ] \n``` ### Region Strategy A region partition strategy groups documents related to a location or region. Each partition contains documents specific to those areas. * **Data Security.** Data is specific to a given geographic area. You can limit a user's access to their current region. Alternately, give access to data on a region-by-region basis.\n* **Storage Capacity.** Storage needs vary depending on size and usage patterns for the region. Users might only sync data in their own region. The data for any region should fit within a device's storage constraints. If users sync multiple regions, partition into smaller subregions. This helps avoid syncing unneeded data. ## Example An app lets users search for nearby restaurants and order from their menus. Consider the following documents in the `restaurants`collection: ```javascript collection restaurants: [   { city: \"New York, NY\", name: \"Joe's Pizza\", menu: [ ... ] }   { city: \"New York, NY\", name: \"Han Dynasty\", menu: [ ... ] }   { city: \"New York, NY\", name: \"Harlem Taste\", menu: [ ... ] }   { city: \"Chicago, IL\", name: \"Lou Malnati's\", menu: [ ... ] }   { city: \"Chicago, IL\", name: \"Al's Beef\", menu: [ ... ] }   { city: \"Chicago, IL\", name: \"Nando's\", menu: [ ... ] } ] \n``` Every document includes the `city` field. This is a good partition key for a region partition strategy. It naturally maps documents to specific physical areas. This limits data to messages and metadata for a user's current city. Users have read access to restaurants in their current region. You could determine the user's region in your application logic. The strategy maps the collections to the following realms: ```javascript realm New York, NY: [\n\n  { city: \"New York, NY\", name: \"Han Dynasty\", menu: [ ... ] }  { city: \"New York, NY\", name: \"Harlem Taste\", menu: [ ... ] } ] realm Chicago, IL: [  { city: \"Chicago, IL\", name: \"Lou Malnati's\", menu: [ ... ] }  { city: \"Chicago, IL\", name: \"Al's Beef\", menu: [ ... ]  }  { city: \"Chicago, IL\", name: \"Nando's\", menu: [ ... ]  } ] \n``` ### Bucket Strategy A bucket partition strategy groups documents by range. When documents range along a dimension, a partition contains a subrange. Consider time-based bucket ranges. Triggers move documents to new partitions when they fall out of their bucket range. * **Data Security.** Limit users to read or write only specific buckets. Data may flow between buckets. Consider access permissions for a document across all possible buckets.\n* **Storage Capacity.** Storage needs vary based on size and usage patterns for each bucket. Consider which buckets users need to access. Limit the size of buckets to fit within a device's storage constraints. If users sync many buckets, partition into smaller buckets. This helps avoid syncing unneeded data. ## Example An IoT app shows real-time views of sensor readings several times a second. Buckets derive from the number of seconds since the reading came in. Consider these documents in the `readings` collection: ```javascript collection readings: [   { bucket: \"0s<t<=60s\", timestamp: 1625773000383 , data: { ... } }   { bucket: \"0s<t<=60s\", timestamp: 1625772970383 , data: { ... } }   { bucket: \"0s<t<=60s\", timestamp: 1625772965383 , data: { ... } }   { bucket: \"60s<t<=300s\", timestamp: 1625772953383 , data: { ... } }   { bucket: \"60s<t<=300s\", timestamp: 1625772933383 , data: { ... } } ] \n``` Every document includes the `bucket` field. This field maps documents to specific time ranges. A user's device only contains sensor readings for the window they view. * Users have read access to sensor readings for any time bucket.\n* Sensors use client apps with write access to upload readings. The strategy maps the collections to the following realms: ```javascript realm 0s<t<=60s: [   Reading { bucket: \"0s<t<=60s\", timestamp: 1625773000383 , data: { ... } }   Reading { bucket: \"0s<t<=60s\", timestamp: 1625772970383 , data: { ... } }   Reading { bucket: \"0s<t<=60s\", timestamp: 1625772965383 , data: { ... } } ] realm 60s<t<=300s: [   Reading { bucket: \"60s<t<=300s\", timestamp: 1625772953383 , data: { ... } }   Reading { bucket: \"60s<t<=300s\", timestamp: 1625772933383 , data: { ... } } ] \n``` ## Asymmetric Sync? [Asymmetric Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/sync-settings/#std-label-optimize-asymmetric-sync) is a feature of Flexible Sync and cannot be enabled on apps that use Partition-Based Sync. ## Partition-Based Sync Configuration When you use [Partition-Based Sync](#std-label-partition-based-sync), your Atlas App Services app uses this Sync configuration: sync/config.json ``` {   \"type\": \"partition\",   \"state\": <\"enabled\" | \"disabled\">,   \"development_mode_enabled\": <Boolean>,   \"service_name\": \"<Data Source Name>\",   \"database_name\": \"<Development Mode Database Name>\",   \"partition\": {     \"key\": \"<Partition Key Field Name>\",     \"type\": \"<Partition Key Type>\",     \"permissions\": {       \"read\": { <Expression> },       \"write\": { <Expression> }     }   },   \"last_disabled\": <Number>,   \"client_max_offline_days\": <Number>,\n\n } \n```\n\n ## Alter Your Partition-Based Sync Configuration You must [Terminate Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-terminating-realm-sync) and[Re-enable Device Sync](https://mongodb.com/docs/atlas/app-services/sync/configure/pause-or-terminate-sync/#std-label-re-enable-realm-sync) to make changes to your Partition-Based Device Sync Configuration. While you are re-enabling Atlas Device Sync, you can specify a new Partition Key, or changes to your Read/Write Permissions. Making changes to your Device Sync configuration while terminating and re-enabling Device Sync will trigger a client reset. To learn more about handling client resets, read the [client reset](https://mongodb.com/docs/atlas/app-services/sync/error-handling/client-resets/#std-label-client-resets)documentation. ← [Upgrade a Shared Tier Cluster](https://mongodb.com/docs/atlas/app-services/reference/upgrade-shared-cluster/ \"Previous Section\")[Push Notifications \\[Deprecated\\]](https://mongodb.com/docs/atlas/app-services/reference/push-notifications/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/services/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Third-Party Service Configuration Files `| app/                 |\n| -------------------- |\n| └── services/        |\n| └── <Service Name>/  |\n| ├── config.json      |\n| └── rules/           |\n| └── <Rule Name>.json | ` ## Service Configuration config.json ``` {    \"name\": \"<Service Name>\",    \"type\": \"<Service Type>\",    \"config\": {       \"<Configuration Option>\": <Configuration Value>    },    \"secret_config\": {       \"<Configuration Option>\": \"<Secret Name>\"    }, } \n```\n\n ### Service Rules Rules for a specific external service are defined in the `/<service name>/rules` sub-directory. Each rule maps to its own JSON file with the same name as the rule. <rule name>.json ``` {   \"name\": \"<Rule Name>\",   \"actions\": [\"<Service Action Name>\"],   \"when\": { <JSON Expression> } } \n``` | Field                | Description                                                                                                                                                                              |\n| -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| nameString           | The name of the service rule. The name may be at most 64 characters long and can only contain ASCII letters, numbers, underscores, and hyphens.                                          |\n| actionsArray<String> | A list of [service actions](https://mongodb.com/docs/atlas/app-services/reference/services/#std-label-service-actions) that the rule applies to. The specific actions available depend on the service type. |\n| whenDocument         | A [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that evaluates to true when the rule applies to a given request.                                  | ← [Log Forwarder Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/log%5Fforwarders/ \"Previous Section\")[Atlas Device Sync Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/app/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # App Configuration Files On this page * [Configuration](#configuration) You can configure high-level features of your application in`realm_config.json`. `| app/                  |\n| --------------------- |\n| └── realm_config.json | ` ## Configuration /realm\\_config.json ```javascript {   \"app_id\": \"<App ID>\",   \"name\": \"<App Name>\",   \"config_version\": <Version Number>,   \"environment\": \"<Environment Name>\",   \"allowed_request_origins\": [\"<Origin URL>\", ...],   \"deployment_model\": \"<Deployment Model Type>\",   \"location\": \"<Deployment Cloud Region Name>\" } \n```\n\n ← [App Configuration](https://mongodb.com/docs/atlas/app-services/reference/config/ \"Previous Section\")[User & Authentication Provider Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/auth/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/hosting/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Static Hosting Configuration Files On this page * [Hosting Configuration](#hosting-configuration)\n* [File Metadata](#file-metadata) `| app/                |\n| ------------------- |\n| └── hosting/        |\n| ├── config.json     |\n| ├── metadata.json   |\n| └── files/          |\n| └── <files to host> | ` ## Hosting Configuration You can enable and configure [static file hosting](https://mongodb.com/docs/atlas/app-services/hosting/) for your application in `hosting/config.json`. config.json ``` {   \"enabled\": <Boolean>,   \"custom_domain\": \"<Custom Domain Name>\",   \"app_default_domain\": \"<Default Domain Name>\" } \n``` | Field Name                 | Description                                                                                                                        |\n| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |\n| enabledBoolean             | If true, [static hosting](https://mongodb.com/docs/atlas/app-services/hosting/) is enabled for your app.                                              |\n| custom\\_domainString       | The [custom domain name](https://mongodb.com/docs/atlas/app-services/hosting/use-a-custom-domain-name/) for your application's hosted files.          |\n| app\\_default\\_domainString | The default domain for your application's hosted files. Atlas App Services automatically sets this value and you cannot change it. | ## File Metadata You can define metadata for any hosted file by adding an entry to`hosting/metadata.json`. metadata.json ``` [   {     \"path\": \"<File Resource Path>\",     \"attrs\": [       {         \"name\": \"<Attribute Type>\",         \"value\": \"<Attribute Value>\"       },       ...     ]   },   ... ] \n```\n\n ## Note If you do not specify a `Content-Type` metadata attribute for a hosted file, Atlas App Services will attempt to automatically add a `Content-Type`attribute to it based on the file extension. For example, App Services would automatically add the attribute`Content-Type: application/html` to the file `myPage.html`. ← [GraphQL Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/graphql/ \"Previous Section\")[HTTP Endpoint Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/http%5Fendpoints/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/http_endpoints/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # HTTP Endpoint Configuration Files `| app/                             |\n| -------------------------------- |\n| └── http_endpoints/              |\n| ├── config.json                  |\n| ├── data_api_config.json         |\n| └── [Deprecated] <Service Name>/ |\n| ├── config.json                  |\n| ├── rules/                       |\n| │   └── <Rule Name>.json         |\n| └── incoming_webhooks/           |\n| └── <Webhook Name>/              |\n| ├── config.json                  |\n| └── source.js                    | ` ## Custom HTTPS Endpoint Configuration Define the configurations for your all of your app's [custom HTTPS endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/#std-label-https-endpoints) as an array in `http_endpoints/config.json`. ``` [   {     \"route\": \"<Endpoint route name>\",     \"http_method\": \"<HTTP method>\",     \"function_name\": \"<Endpoint function name\",     \"validation_method\": \"<Authorization scheme>\",     \"secret_name\": \"<Validation Secret Name>\",     \"respond_result\": <boolean>,     \"fetch_custom_user_data\": <boolean>,     \"create_user_on_auth\": <boolean>,     \"disabled\": <boolean>   } ] \n```\n\n ## Data API Configuration Define the configuration for your app's generated [Data API endpoints](https://mongodb.com/docs/atlas/app-services/data-api/generated-endpoints/#std-label-data-api-endpoints) in `http_endpoints/data_api_config.json`. ``` {   \"disabled\": <boolean>,   \"versions\": [\"v1\"],   \"return_type\": \"EJSON\" | \"JSON\",   \"create_user_on_auth\": <boolean>,   \"run_as_system\": <boolean>,   \"run_as_user_id\": \"<User Account ID>\",   \"run_as_user_id_script_source\": \"<Function Source Code>\" } \n```\n\n ## \\[Deprecated\\] HTTP Service Configuration Deprecated legacy HTTP services are grouped into named services within`/http_endpoints`. http\\_endpoints/<Service Name>/config.json ``` {   \"name\": \"<Service Name>\",   \"type\": \"http\",   \"config\": {} } \n``` | Field        | Description                                                                                                                                             |\n| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| nameString   | The name of the HTTP endpoints service. This must be unique among all HTTP endpoint services in the app and match the name of its containing directory. |\n| typeString   | For HTTP endpoints, this value is always \"http\".                                                                                                        |\n| configString | Additional configuration options for the service. HTTP Endpoints currently have no additional configuration options.                                    | ## \\[Deprecated\\] Service Action Rules You define [service action rules](https://mongodb.com/docs/atlas/app-services/reference/services/#std-label-service-rules) in the service's`rules/` sub-directory. Each rule maps to its own `.json` configuration file with the same name as the rule. http\\_endpoints/<Service Name>/rules/<Rule Name>.json ``` {   \"name\": \"<Rule Name>\",   \"actions\": [\"<Service Action Name>\"],   \"when\": { <JSON Rule Expression> } } \n``` | Field                | Description                                                                                                                                             |\n| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| nameString           | The name of the service rule. The name may be at most 64 characters long and can only contain ASCII letters, numbers, underscores, and hyphens.         |\n| actionsArray<String> | A list of [HTTP actions](https://mongodb.com/docs/atlas/app-services/services/http/#std-label-http-service-actions) that the rule applies to.                              |\n| whenDocument         | A [rule expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) that evaluates to true when the rule applies to a given request. | ## \\[Deprecated\\] Incoming Webhooks ### Configuration http\\_endpoints/<Service Name>/incoming\\_webhooks/<Webhook Name>/config.json ``` {   \"name\": \"<Webhook Name>\",   \"can_evaluate\": { <JSON Expression> },\n\n   \"run_as_user_id\": \"<App Services User ID>\",   \"run_as_user_id_script_source\": \"<Function Source Code>\",   \"fetch_custom_user_data\": <Boolean>,   \"create_user_on_auth\": <Boolean>,   \"respond_result\": <Boolean>,   \"options\": {     \"httpMethod\": \"<HTTP Method>\",     \"validationMethod\": \"<Webhook Validation Method>\",     \"secret\": \"<Webhook Secret>\"   } } \n```\n\n ### Source Code You define a webhook function's source code in a `source.js` file within the webhook directory. Each file must export the main function that runs whenever a request calls the webhook. http\\_endpoints/<Service Name>/incoming\\_webhooks/<Webhook Name>/source.js ```javascript exports = async function (payload, response) {   // Convert the webhook body from BSON to an EJSON object   const body = EJSON.parse(payload.body.text());   // Execute application logic, such as working with MongoDB   if (body.someField) {     const mdb = context.services.get(\"mongodb-atlas\");     const requests = mdb.db(\"demo\").collection(\"requests\");     const { insertedId } = await requests.insertOne({       someField: body.someField,     });     // Respond with an affirmative result     response.setStatusCode(200);     response.setBody(`Successfully saved \"someField\" with _id: ${insertedId}.`);   } else {     // Respond with a malformed request error     response.setStatusCode(400);     response.setBody(`Could not find \"someField\" in the webhook request body.`);   }   // This return value does nothing because we already modified the response object.   // If you do not modify the response object and you enable *Respond with Result*,   // App Services will include this return value as the response body.   return { msg: \"finished!\" }; }; \n``` ← [Static Hosting Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/hosting/ \"Previous Section\")[Log Forwarder Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/log%5Fforwarders/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/graphql/cli/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Run GraphQL Operations from a CLI On this page * [Overview](#overview)\n* [Run a Query](#run-a-query)\n* [Run a Mutation](#run-a-mutation) ## Overview You can access your App's [Atlas GraphQL API](https://mongodb.com/docs/atlas/app-services/graphql/expose-data/)through a terminal or command line interface. GraphQL operates over HTTP, so the CLI can be a standard HTTP client, like `curl`, or a specialized GraphQL CLI, like [graphqurl.](https://github.com/hasura/graphqurl) To send GraphQL requests to your app, you'll need the following: * Your App ID.\n* A valid user access token. For details on how to get an access token, see[Authenticate GraphQL Requests.](https://mongodb.com/docs/atlas/app-services/graphql/authenticate/) ## Run a Query ## Run a Mutation ← [Define a Custom Resolver](https://mongodb.com/docs/atlas/app-services/graphql/custom-resolvers/ \"Previous Section\")[Atlas Data API](https://mongodb.com/docs/atlas/app-services/data-api/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/graphql/expose-data/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Expose Data in a Collection On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [1\\. Configure Roles for the Collection](#1.-configure-roles-for-the-collection)\n* [2\\. Define a Schema for Documents in the Collection](#2.-define-a-schema-for-documents-in-the-collection)\n* [3\\. Define Relationships to Other Collections](#3.-define-relationships-to-other-collections)\n* [4\\. Name the Data Type](#4.-name-the-data-type)\n* [Next Steps](#next-steps) ## Overview You can expose data from a MongoDB collection to client applications through the Atlas GraphQL API. Atlas App Services automatically generates GraphQL types and resolvers based on the [collection schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) and enforces [collection rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-rules) for all GraphQL operations. ## Procedure ### 1\\. Configure Roles for the Collection App Services enforces [collection rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-mongodb-rules) for all incoming GraphQL requests, so you need to define at least one [collection role](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-define-roles-and-permissions) with the permissions that your application requires. All GraphQL requests include an authentication token that identifies the logged in App Services user that sent the request. App Services evaluates a role for every document included in a GraphQL operation and only returns fields and documents that the user has permission to see. If App Services omits a field, the field has a `null` value in the returned document. ### 2\\. Define a Schema for Documents in the Collection GraphQL requires that all data conforms to a well-defined type, so you must [define a schema](https://mongodb.com/docs/atlas/app-services/schemas/enforce-a-schema/#std-label-enforce-a-schema) for documents in the collection. App Services automatically generates[GraphQL types and resolvers](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/) for documents in the collection based on the collection schema and regenerates new types whenever the schema changes. ## Note ### Automatically Generate a Schema App Services can generate a collection schema for you based on a sample of existing documents in the collection. If you don't have existing data, you can insert a new document that has a mock implementation of the fields you want to include in your schema and then generate a schema based on the mock. ### 3\\. Define Relationships to Other Collections You can define [relationships](https://mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-relationships) that connect each document in the collection to one or more documents in a foreign collection. To learn how to define a relationship, see[Define a Relationship.](https://mongodb.com/docs/atlas/app-services/schemas/relationships/#std-label-define-a-relationship) Relationships allow you to fluently reference and query related documents in GraphQL read and write operations. For example, you can query for a person and include the full document for each of their children from the same `people` collection:\n\n ` ### 4\\. Name the Data Type App Services names the GraphQL types that it generates based on the data type that documents in the collection conform to. You can configure the name of the GraphQL types by setting the `title` field in a schema to the name of the data type that the schema defines. There are three situations where you can set the `title` field: * You can define the type name for each document in a collection by setting `title` at the root level of the schema. If you don't specify a title, App Services uses the name of the collection instead.\n* You can define the type name for an embedded object by setting`title` in the embedded object schema.\n* You can define the type name for a field that has a defined relationship by setting `title` in the field schema. App Services uses the`title` instead of the defined field name when it resolves relationships in GraphQL. ``` {   \"title\": \"movie\",   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"title\": { \"bsonType\": \"string\" },     \"year\": { \"bsonType\": \"int\" },     \"director\": { \"bsonType\": \"int\" }   } } \n``` ## Note ### Singular and Plural Types App Services generates two [GraphQL queries](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-query-resolvers) for each collection: * A **singular** query that finds a specific document in the collection. The query uses the same name as the schema's `title`. If the schema's`title` is a plural noun, App Services attempts to use its singular form as determined by the [Rails ActiveSupport inflection rules.](https://github.com/rails/rails/blob/master/activesupport/lib/active%5Fsupport/inflections.rb)\n* A **plural** query that finds a subset of all documents in the collection. If possible, the query uses the plural form of the singular query name. If App Services is unable to pluralize the name or if the pluralized name is the same as the singular name, the plural query uses the same name as the singular query with an additional `\"s\"` appended to the end. ## Example The following schema is configured for the `laboratory.mice`collection: ``` {   \"title\": \"Mouse\",   \"bsonType\": \"object\",   \"properties\": {     \"_id\": { \"bsonType\": \"objectId\" },     \"name\": { \"bsonType\": \"string\" },     \"age\": { \"bsonType\": \"int\" }   } } \n``` App Services generates two queries, `mouse` (singular) and `mice`(plural), based on the schema: ``` query Mice {   mouse(query: { _id: \"5ebe6819197003ddb1f74475\" }) {     name     age   }   mice {     name     age   } } \n``` ## Next Steps Once you have defined a schema for the collection, App Services automatically exposes the documents in the collection through the GraphQL API. You can now connect from a client application and execute queries and mutations. ## Tip ### See also:  * [Apollo Client (React) - Web SDK](https://www.mongodb.com/docs/realm/web/graphql-apollo-react/#std-label-graphql-apollo-react)\n* [Run GraphQL Operations from a CLI](https://mongodb.com/docs/atlas/app-services/graphql/cli/) ← [Atlas GraphQL API](https://mongodb.com/docs/atlas/app-services/graphql/ \"Previous Section\")[Authenticate GraphQL Requests](https://mongodb.com/docs/atlas/app-services/graphql/authenticate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/graphql/authenticate/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Authenticate GraphQL Requests On this page * [Overview](#overview)\n* [Bearer Authentication](#bearer-authentication)\n* [Credential Headers](#credential-headers)\n* [Email/Password](#email-password)\n* [API Key](#api-key)\n* [Custom JWT](#custom-jwt) ## Overview The GraphQL API requires that incoming requests include authentication information for the user making the request. This lets the API enforce rules and validate document schemas for each operation. Requests must include authentication data in specific request headers. App Services uses the following process to authenticate a given request: 1. Check for an `Authorization` header. If it's present, the request must use [Bearer Authentication](#std-label-graphql-bearer-authentication)with a valid user access token. If the token is invalid, the request fails.\n2. If the `Authorization` header is not present, check for[Credential Headers](#std-label-graphql-credential-headers). The headers must contain valid Email/Password, API Key, or Custom JWT credentials for an App user. ## Note You must [enable an authentication provider](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) before users can authenticate with it. ## Bearer Authentication The GraphQL API supports Bearer Authentication, which lets you authenticate a request by including a valid user access token in the`Authorization` header. To learn how to get and manage an access token, see [Manage User Sessions.](https://mongodb.com/docs/atlas/app-services/users/sessions/#std-label-manage-user-sessions) The Authorization header uses the following format: `| Authorization: Bearer <AccessToken> |\n| ----------------------------------- | ` For example, the following request uses Bearer Authentication: ```shell curl -X POST 'https://realm.mongodb.com/api/client/v2.0/app/<AppID>/graphql' \\    --header 'Authorization: Bearer <AccessToken>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"query\": \"query AllMovies {\\n  movies {\\n    title\\n    year\\n  }\\n}\"    }' \n``` In general, bearer authentication with an access token has higher throughput and is more secure than credential headers. Use an access token instead of credential headers when possible. The token lets you run multiple requests without re-authenticating the user. It also lets you send requests from a web browser that enforces [CORS.](https://en.wikipedia.org/wiki/Cross-origin%5Fresource%5Fsharing) ## Important ### Don't Use API Keys in User-Facing Clients If you're authenticating from a browser or another user-facing client application, avoid using an API key to log in. Instead, use another authentication provider that takes user-provided credentials. Never store API keys or other sensitive credentials locally. Bearer authentication is useful for: * sending requests from a web browser.\n* sending multiple requests without storing user credentials or prompting the user on each request.\n* sending requests from an app that also uses a [Realm SDK](https://www.mongodb.com/docs/realm/sdk/#std-label-realm-sdks) to authenticate users. ## Credential Headers You can authenticate a GraphQL request by including the user's login credentials in the request headers. The exact headers to include depend on the authentication provider. Credential headers are useful for: * requests sent from a server-side application\n* requests sent from a command-line tool\n* manual or test requests sent from a GraphQL client like Postman ## Important You cannot use credential headers to authenticate requests sent from a web browser due to [Cross-Origin Resource Sharing](https://en.wikipedia.org/wiki/Cross-origin%5Fresource%5Fsharing) restrictions. Instead, to authenticate GraphQL requests from a browser, use [Bearer Authentication.](#std-label-graphql-bearer-authentication) ### Email/Password\n\n ```shell curl -X POST 'https://realm.mongodb.com/api/client/v2.0/app/<AppID>/graphql' \\    --header 'email: <EmailAddress>' \\    --header 'password: <Password>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"query\": \"query AllMovies {\\n  movies {\\n    title\\n    year\\n  }\\n}\"    }' \n``` ### API Key To authenticate a GraphQL request with an [API Key](https://mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication), include the API key in the request's`apiKey` header. ```shell curl -X POST 'https://realm.mongodb.com/api/client/v2.0/app/<AppID>/graphql' \\    --header 'apiKey: <APIKey>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"query\": \"query AllMovies {\\n  movies {\\n    title\\n    year\\n  }\\n}\"    }' \n``` ## Important ### Don't Use API Keys in User-Facing Clients If you're authenticating from a browser or another user-facing client application, avoid using an API key to log in. Instead, use another authentication provider that takes user-provided credentials. Never store API keys or other sensitive credentials locally. ### Custom JWT To authenticate a GraphQL request as a [Custom JWT](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) user, include the JWT string in the request's `jwtTokenString` header. ```shell curl -X POST 'https://realm.mongodb.com/api/client/v2.0/app/<AppID>/graphql' \\    --header 'jwtTokenString: <JWT>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"query\": \"query AllMovies {\\n  movies {\\n    title\\n    year\\n  }\\n}\"    }' \n``` ← [Expose Data in a Collection](https://mongodb.com/docs/atlas/app-services/graphql/expose-data/ \"Previous Section\")[GraphQL Types, Resolvers, and Operators](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/reference/config/data_sources/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # MongoDB Data Source Configuration Files On this page * [Service Configuration](#service-configuration)\n* [MongoDB Clusters](#mongodb-clusters)\n* [Federated database instances](#federated-database-instances)\n* [Databases & Collections](#databases---collections)\n* [Collection Schema](#collection-schema)\n* [Relationships](#relationships)\n* [Default Rules](#default-rules)\n* [Collection Rules](#collection-rules)\n* [Rule Configurations](#rule-configurations)\n* [Roles](#roles)\n* [Filters](#filters) `| app/                   |\n| ---------------------- |\n| └── data_sources/      |\n| └── <service name>/    |\n| ├── config.json        |\n| └── <database>/        |\n| └── <collection>/      |\n| ├── schema.json        |\n| ├── relationships.json |\n| └── rules.json         | ` ## Service Configuration ### MongoDB Clusters config.json ``` {   \"name\": \"<Service Name>\",   \"type\": \"mongodb-atlas\",   \"config\": {     \"clusterName\": \"<Atlas Cluster Name>\",     \"readPreference\": \"<Read Preference>\",     \"wireProtocolEnabled\": <Boolean>   } } \n```\n\n ### Federated database instances /data\\_sources/<Service Name>/config.json ``` {   \"name\": \"<Service Name>\",   \"type\": \"datalake\",   \"config\": {      \"dataLakeName\": \"<Federated database instance name>\"    } } \n``` | Field                     | Description                                                                                                                                                                                                                                                 |\n| ------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| nameString                | Required. Default: mongodb-datafederationThe service name used to refer to the Federated database instance within this App Services app. The name may be at most 64 characters long and must only contain ASCII letters, numbers, underscores, and hyphens. |\n| typeString                | Required. For a Federated database instance, this value is always \"datalake\".                                                                                                                                                                               |\n| config.dataLakeNameString | Required. The name of the Federated database instance in Atlas.                                                                                                                                                                                             | ## Databases & Collections ### Collection Schema If you want to enforce a [schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas) for a collection, define a`schema.json` configuration file that contains a JSON schema for the documents. The root level schema must be an [object schema](https://mongodb.com/docs/atlas/app-services/schemas/types/#std-label-schema-type-object), which has the following form: /data\\_sources/<data source>/<database>/<collection>/schema.json ``` {   \"title\": \"<Object Type Name>\",\n\n   \"properties\": {     \"<Property Name>\": { <Schema> },     ...   } } \n``` ### Relationships /data\\_sources/<data source>/<database>/<collection>/relationships.json ``` {   \"<Source Field Name>\": {     \"ref\": \"#/relationship/<Data Source Name>/<Database Name>/<Collection Name>\",     \"source_key\": \"<Source Field Name>\",     \"foreign_key\": \"<Foreign Field Name>\",     \"is_list\": <Boolean>   },   ... } \n```\n\n ## Example An ecommerce app defines a relationship between two collections: each document in `store.orders` references one or more documents in the`store.items` collection by including item `_id` values in the order's`items` array. Both collection are in the same linked cluster (`mongodb-atlas`) and database (`store`). The relationship is defined for the `orders` collection: /data\\_sources/mongodb-atlas/store/orders/relationships.json ``` {   \"items\": {     \"ref\": \"#/relationship/mongodb-atlas/store/items\",     \"source_key\": \"items\",     \"foreign_key\": \"_id\",     \"is_list\": true   } } \n``` ### Default Rules You can define default rules that apply to all collections in a data source that don't have more specific [collection-level rules](#std-label-config-collection-rules) defined. You define default rules in the data source's `default_rule.json`configuration file at `data_sources/<data-source-name>/default_rule.json`. /data\\_sources/<data source>/default\\_rule.json ``` {   \"roles\": [<Role>],   \"filters\": [<Filter>] } \n``` | Field                | Description                                                    |\n| -------------------- | -------------------------------------------------------------- |\n| rolesArray<Role>     | An array of [Role](#std-label-role-config) configurations.     |\n| filtersArray<Filter> | An array of [Filter](#std-label-filter-config) configurations. | ### Collection Rules If the data source is not a [Federated data source](https://mongodb.com/docs/atlas/app-services/mongodb/#std-label-data-federation-caveats), then you can define collection-level rules in a collection's `rules.json`configuration file. /data\\_sources/<data source>/<database>/<collection>/rules.json ``` {   \"database\": \"<Database Name>\",   \"collection\": \"<Collection Name>\",   \"roles\": [<Role>],   \"filters\": [<Filter>] } \n``` | Field                | Description                                                    |\n| -------------------- | -------------------------------------------------------------- |\n| databaseString       | The name of the database that holds the collection.            |\n| collectionString     | The name of the collection.                                    |\n| rolesArray<Role>     | An array of [Role](#std-label-role-config) configurations.     |\n| filtersArray<Filter> | An array of [Filter](#std-label-filter-config) configurations. | ## Rule Configurations ### Roles ``` {    \"name\": \"<Role Name>\",    \"apply_when\": { Expression },    \"document_filters\": {      \"read\": { Expression },      \"write\": { Expression }    },    \"read\": { Expression },    \"write\": { Expression },    \"insert\": { Expression },    \"delete\": { Expression },    \"search\": <Boolean>,    \"fields\": {       \"<Field Name>\": {          \"read\": { Expression },          \"write\": { Expression },          \"fields\": { Embedded Fields }       },       ...    },    \"additional_fields\": {      \"read\": { Expression },\n\n    } } \n```\n\n ### Filters ```javascript {   \"name\": \"<Filter Name>\",   \"apply_when\": { Expression },   \"query\": { MongoDB Query },   \"projection\": { MongoDB Projection } } \n```\n\n ← [User & Authentication Provider Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/auth/ \"Previous Section\")[Environment Value Configuration Files](https://mongodb.com/docs/atlas/app-services/reference/config/environments/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/function/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Function Logs On this page * [Overview](#overview)\n* [Log Format](#log-format)\n* [Fields](#fields)\n* [Error Fields](#error-fields) ## Overview Function logs are created whenever a user calls an Atlas Function using a Realm SDK. While you can execute Functions with a[Trigger](https://mongodb.com/docs/atlas/app-services/triggers/#std-label-triggers), only functions directly called from an SDK generate logs of the function type. ## Log Format Function log entries have the following form: `| Logs:                              |\n| ---------------------------------- |\n| [                                  |\n| <log line>,                        |\n| <log line>,                        |\n| ...                                |\n| ]                                  |\n| {                                  |\n| \"arguments\": [                     |\n| <arg1>,                            |\n| <arg2>                             |\n| ],                                 |\n| \"name\": <function name>,           |\n| \"service\": \"\"                      |\n| }                                  |\n| Function Call Location: <location> |\n| Compute Used: <number> bytes•ms    |\n| Remote IP Address: <ip address>    |\n| SDK: <sdk>                         |\n| Platform Version: <version>        | ` ## Fields\n\n ## Error Fields Log entries created by unsuccessful operations may feature additional fields for debugging purposes. These include the following: | Field       | Description                                                                                     |\n| ----------- | ----------------------------------------------------------------------------------------------- |\n| Error       | A brief description of an error.                                                                |\n| Stack Trace | A printout of an exception stack trace.                                                         |\n| Details     | Extra information about an execution, including action, reason, service name, and service type. | ← [Endpoint Logs](https://mongodb.com/docs/atlas/app-services/logs/endpoint/ \"Previous Section\")[Schema Logs](https://mongodb.com/docs/atlas/app-services/logs/schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/trigger/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Trigger Logs On this page * [Overview](#overview)\n* [Log Format](#log-format)\n* [Fields](#fields)\n* [Error Fields](#error-fields) ## Overview Trigger logs are created whenever Atlas App Services executes a Function via a[Trigger.](https://mongodb.com/docs/atlas/app-services/triggers/) ## Log Format Trigger log entries have the following form: `| Logs:                           |\n| ------------------------------- |\n| [                               |\n| <log line>,                     |\n| <log line>,                     |\n| ...                             |\n| ]                               |\n| See Function. See Trigger.      |\n| Compute Used: <number> bytes•ms | ` ## Fields | Field                      | Description                                                                                                |\n| -------------------------- | ---------------------------------------------------------------------------------------------------------- |\n| Compute Used               | The computational load of the operation.                                                                   |\n| Logs                       | A list of console.log outputs. App Services saves the first 512 bytes of the first 25 console.log() calls. |\n| See Function. See Trigger. | Links to the Trigger that launched this event as well as the Function that was run by this event.          | ## Error Fields Log entries created by unsuccessful operations may feature additional fields for debugging purposes. These include the following: | Field | Description                      |\n| ----- | -------------------------------- |\n| Error | A brief description of an error. | ← [Service Logs](https://mongodb.com/docs/atlas/app-services/logs/service/ \"Previous Section\")[Host Files](https://mongodb.com/docs/atlas/app-services/hosting/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/authentication/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Authentication Logs On this page * [Overview](#overview)\n* [Log Format](#log-format)\n* [Fields](#fields)\n* [Error Fields](#error-fields) ## Overview Atlas App Services creates authentication logs whenever a user is created, deleted, or logs in. ## Log Format Authentication log entries have the following form: `| Remote IP Address: <ip address>    |\n| ---------------------------------- |\n| SDK: <sdk name>                    |\n| Platform Version: <version number> | ` ## Fields Remote IP Address SDK Platform Version\n\n ## Error Fields Log entries created by unsuccessful operations may feature additional fields for debugging purposes. These include the following: | Field | Description                      |\n| ----- | -------------------------------- |\n| Error | A brief description of an error. | ← [App Log Types](https://mongodb.com/docs/atlas/app-services/logs/ \"Previous Section\")[Change Stream Logs](https://mongodb.com/docs/atlas/app-services/logs/changestream/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Schema Logs On this page * [Overview](#overview)\n* [Fields](#fields) ## Overview Events related to your App's Atlas Schema create schema logs. This includes both breaking (destructive) and non-breaking (additive) schema updates to tables and fields, as well as the collection scans used to automatically generate schemas based on the form of existing documents. ### Fields\n\n ← [Function Logs](https://mongodb.com/docs/atlas/app-services/logs/function/ \"Previous Section\")[Service Logs](https://mongodb.com/docs/atlas/app-services/logs/service/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/sync/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Device Sync Logs On this page * [Overview](#overview)\n* [Connections](#connections)\n* [Sessions](#sessions)\n* [MongoDB Atlas Sync Events](#mongodb-atlas-sync-events)\n* [Fields](#fields) ## Overview Atlas Device Sync creates sync logs whenever a user interacts with Sync. This includes writing data to Atlas App Services from clients, reading changes from App Services to clients, and starting or ending a connection. ### Connections Every user communicates with App Services using a _connection_. Each connection uses a single websocket to push and pull information to and from a single user. Logging in a user using any authentication provider starts a connection. Logging out that user ends the connection. ### Sessions Users download and upload changes to a synced realm using a _session_. Instantiating a local instance of a synced realm starts a session. Destroying that realm object ends the session. ### MongoDB Atlas Sync Events Every sync event is associated with a user identity that tells you exactly which user caused the event to occur. However, you may notice some sync events that aren't associated with any specific user. These events include downloaded changes from all clients as well as as well as any change made in MongoDB Atlas. Any sync event that does not include a user ID is part of the MongoDB Atlas data synchronization process. You may see a large number of MongoDB Atlas synchronization events when you initialize sync if your cluster already contains a large amount of data. ### Fields\n\n ← [Change Stream Logs](https://mongodb.com/docs/atlas/app-services/logs/changestream/ \"Previous Section\")[Endpoint Logs](https://mongodb.com/docs/atlas/app-services/logs/endpoint/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/changestream/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Change Stream Logs On this page * [Overview](#overview)\n* [Log Format](#log-format)\n* [Fields](#fields) ## Overview Change Stream log events are created whenever a user opens or closes a change stream on a linked data source using the `watch()` API. ## Log Format Change Stream log entries have the following form: `| {                                  |\n| ---------------------------------- |\n| \"arguments\": [                     |\n| {                                  |\n| \"collection\": <collection>,        |\n| \"database\": <database>,            |\n| \"filter\": {                        |\n| \"documentKey._id\": {               |\n| \"$in\": [                           |\n| {                                  |\n| \"$oid\": <uid>                      |\n| }                                  |\n| ]                                  |\n| }                                  |\n| },                                 |\n| \"useCompactEvents\": <bool>         |\n| }                                  |\n| ],                                 |\n| \"name\": \"watch\",                   |\n| \"service\": \"mongodb-atlas\"         |\n| }                                  |\n| Function Call Location: <location> |\n| Remote IP Address: <ip address>    |\n| SDK: <sdk>                         |\n| Platform Version: <version>>       | ` ## Fields\n\n ← [Authentication Logs](https://mongodb.com/docs/atlas/app-services/logs/authentication/ \"Previous Section\")[Device Sync Logs](https://mongodb.com/docs/atlas/app-services/logs/sync/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/endpoint/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Endpoint Logs On this page * [Overview](#overview)\n* [Log Format](#log-format)\n* [Fields](#fields)\n* [Error Fields](#error-fields) ## Overview Endpoint logs are created whenever a user calls an[HTTPS Endpoint.](https://mongodb.com/docs/atlas/app-services/data-api/#std-label-data-api) ## Log Format Endpoint log entries have the following form: `| Logs:                                 |\n| ------------------------------------- |\n| [                                     |\n| <log line>,                           |\n| <log line>,                           |\n| ...                                   |\n| ]                                     |\n| {                                     |\n| \"arguments\": [                        |\n| <arg1>,                               |\n| <arg2>                                |\n| ],                                    |\n| \"name\": <function name>,              |\n| }                                     |\n| Function Call Location: <location>    |\n| Endpoint Query Arguments: <arguments> |\n| Endpoint Headers: <headers>           |\n| Compute Used: <number> bytes•ms       |\n| Remote IP Address: <ip address>       | ` ## Fields\n\n ## Error Fields Log entries created by unsuccessful operations may feature additional fields for debugging purposes. These include the following: | Field             | Description                                                               |\n| ----------------- | ------------------------------------------------------------------------- |\n| Error             | A brief description of an error.                                          |\n| Remote IP Address | The IP Address that sent the request to the endpoint. (e.g. 52.21.89.200) | ← [Device Sync Logs](https://mongodb.com/docs/atlas/app-services/logs/sync/ \"Previous Section\")[Function Logs](https://mongodb.com/docs/atlas/app-services/logs/function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/graphql/custom-resolvers/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Define a Custom Resolver On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Create a New Custom Resolver](#create-a-new-custom-resolver)\n* [Define the Resolver Field Name](#define-the-resolver-field-name)\n* [Define the Parent Type](#define-the-parent-type)\n* [Define the Input Type](#define-the-input-type)\n* [Define the Payload Type](#define-the-payload-type)\n* [Define the Resolver Function](#define-the-resolver-function)\n* [Save and Deploy the Resolver](#save-and-deploy-the-resolver)\n* [Custom Resolver Examples](#custom-resolver-examples)\n* [Scenario & Schemas](#scenario---schemas)\n* [Custom Query Resolver](#custom-query-resolver)\n* [Custom Mutation](#custom-mutation)\n* [Computed Properties](#computed-properties) ## Overview You can define custom resolvers that extend the GraphQL API for your app's use cases. Custom resolvers allow you to define new root-level operations that are more complex or specific than the generated [query](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-query-resolvers) and [mutation](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-mutation-resolvers)resolvers. You can also add new computed fields to [generated document types](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-document-types) that dynamically evaluate a result whenever an operation reads a document of the extended type. ## Procedure 1 ### Create a New Custom Resolver In the App Services UI, click GraphQL in the navigation sidebar and then select the Custom Resolvers tab. Click the Add a Custom Resolver button to open the configuration screen for a new custom resolver. ![The custom resolvers screen in the App Services UI](https://mongodb.com/docs/atlas/app-services/images/graphql-add-a-custom-resolver.png) 2 ### Define the Resolver Field Name Specify App Servicese name for the resolver in the GraphQL Field Name input. App Services exposes the custom resolver in its parent type using this name, so the name should describe what the resolver does in a way that is useful to developers who work with the GraphQL API. ![The GraphQL Field Name input in the App Services UI](https://mongodb.com/docs/atlas/app-services/images/custom-resolver-graphql-field-name.png) 3 ### Define the Parent Type App Services exposes every custom resolver as a field on a parent type. The parent type can be a root-level [query](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-query-resolvers),[mutation](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-mutation-resolvers), or a [generated document type.](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-document-types) In the Parent Type dropdown, select one of the following options:\n\n 4 ### Define the Input Type A custom resolver can accept input parameters from the incoming query or mutation. You can use an existing [generated input type](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-input-types) or define a new custom input type specifically for the resolver. If you specify an input type, App Services exposes the `input` parameter in the custom resolver's generated GraphQL schema definition as an optional parameter that accepts the specified input type. If you don't specify an input type, the custom resolver does not accept any arguments. In the Input Type dropdown, select one of the following options:\n\n 5 ### Define the Payload Type All GraphQL resolvers must return a payload that conforms to a specific type in the schema. For a custom resolver, you can use an existing [generated document type](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/#std-label-graphql-document-types), define a new custom payload type specifically for the resolver, or use a default payload. App Services includes the specified payload type in the custom resolver's generated GraphQL schema definition. In the Payload Type dropdown, select one of the following options:\n\n 6 ### Define the Resolver Function When a user calls a custom resolver App Services executes the resolver function and returns the result, which must conform to the resolver'sPayload Type. App Services passes the function any input data from the operation, if applicable. If the resolver is a computed property on a document type, App Services passes the function the specific document that the resolver was called on. A custom resolver function has one of two possible signatures, depending on whether or not it accepts an input: To define the resolver function, click the Function dropdown and either select an existing function or create a new one. ![A custom resolver configured to use the `myCustomResolver` function](https://mongodb.com/docs/atlas/app-services/images/custom-resolver-function.png) 7 ### Save and Deploy the Resolver Once you have configured the resolver, click Save and deploy your application. Once deployed, you can call the custom resolver through the GraphQL API. ## Custom Resolver Examples ### Scenario & Schemas Consider a hypothetical dashboard that a sales team uses to show various statistics and other performance metrics for a given time period. The dashboard uses the custom resolvers in this section to handle some of its specific use cases. The resolvers all reference `Sale` documents, which have the following schema: ### Custom Query Resolver The sales team's hypothetical dashboard uses a custom query resolver that returns aggregated sales data for a specific month. App Services generates schema definitions for the resolver's custom input and payload types and adds the resolver to its parent type, the root-level `Query`: ``` type Query {   averageSaleForMonth(input: AverageSaleForMonthInput): AverageSaleForMonthPayload } input AverageSalesForMonthInput {   month: String!;   year: String!; } type AverageSaleForMonthPayload {   month: String!;   year: String!;   averageSale: Float!; } \n``` #### Configuration The resolver uses the following configuration:\n\n #### Example Usage To call this custom query, you could use the following operation and variables: ``` query GetAverageSaleForMonth($averageSaleInput: AverageSaleForMonthInput!) {   averageSaleForMonth(input: $averageSaleInput) {     month     year     averageSale   } } \n``` ``` {   \"variables\": {     \"averageSaleInput\": { month: \"March\", year: \"2020\" }   } } \n``` ### Custom Mutation The sales team's hypothetical dashboard uses a custom mutation resolver that adds a string note to a specific `Sale` document, identified by its `_id`. App Services generates schema definitions for the resolver's custom input type and adds the resolver to its parent type, the root-level `Mutation`: ``` type Mutation {   addNoteToSale(input: AddNoteToSaleInput): Sale } input AddNoteToSaleInput {   sale_id: ObjectId!;   note: String!; } \n``` #### Configuration The resolver uses the following configuration:\n\n #### Example Usage To call this custom query, you could use the following operation and variables: ``` mutation AddNoteToSale($addNoteToSaleInput: AddNoteToSaleInput) {   addNoteToSale(input: $addNoteToSaleInput) {     _id     customer_id     month     year     saleTotal     notes   } } \n``` ``` {   \"variables\": {     \"addNoteToSaleInput\": {       \"sale_id\": \"5f3c2779796615b661fcdc25\",       \"note\": \"This was such a great sale!\"     }   } } \n``` ### Computed Properties The sales team's hypothetical dashboard uses a custom resolver that adds a new computed property to each `Sale` document. When an operation requests the computed field for a given `Sale`, the resolver queries an external system and returns support cases filed by the associated customer. App Services generates schema definitions for the resolver's custom payload type and adds the resolver to its parent type, `Sale`: ``` type Sale {   _id: ObjectId!   customer_id: String!   year: String!   month: String!   saleTotal: Float!   notes: [String]   customerSupportCases: [CustomerSupportCase] } type CustomerSupportCase {   caseId: String!   description: String! } \n``` #### Configuration The resolver uses the following configuration:\n\n #### Example Usage To use this custom computed property, you could run the following operation: ``` query GetSalesWithSupportCases {   sales {     _id     customer_id     year     month     saleTotal     notes     customerSupportCases {       caseId       description     }   } } \n``` ← [GraphQL Types, Resolvers, and Operators](https://mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/ \"Previous Section\")[Run GraphQL Operations from a CLI](https://mongodb.com/docs/atlas/app-services/graphql/cli/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/logs/service/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Service Logs On this page * [Overview](#overview)\n* [MongoDB Atlas](#mongodb-atlas)\n* [Fields](#fields)\n* [Error Fields](#error-fields)\n* [Webhook / HTTP Service](#webhook---http-service)\n* [Fields](#fields-1)\n* [Error Fields](#error-fields-1) ## Overview Service logs are created by whenever a user interacts with[External Services](https://mongodb.com/docs/atlas/app-services/reference/services/). The fields present in Service log entries are determined by the service that emitted the log. ## MongoDB Atlas [MongoDB Atlas](https://mongodb.com/docs/atlas/app-services/mongodb/) is offered as a first-class service within Atlas App Services. Service log entries have the following form:\n\n ` ### Fields\n\n ### Error Fields Log entries created by unsuccessful operations may feature additional fields for debugging purposes. These include the following: | Field       | Description                                                                                     |\n| ----------- | ----------------------------------------------------------------------------------------------- |\n| Error       | A brief description of an error.                                                                |\n| Stack Trace | A printout of an exception stack trace.                                                         |\n| Details     | Extra information about an execution, including action, reason, service name, and service type. | ## Webhook / HTTP Service [Webhook](https://mongodb.com/docs/atlas/app-services/services/webhook-requests-and-responses/) log entries adhere to the following form: ```javascript Logs: [    <log line>,    <log line>,    ... ] Function Call Location: <location> Compute Used: <number> bytes•ms Remote IP Address: <ip address> \n``` ### Fields | Field                  | Description                                                                                                                 |\n| ---------------------- | --------------------------------------------------------------------------------------------------------------------------- |\n| Remote IP Address      | The IP Address that sent the request to App Services. (e.g. 52.21.89.200)                                                   |\n| Compute Used           | The [computational load](https://mongodb.com/docs/atlas/app-services/billing/#std-label-billing-compute) of the operation measured in byte-ms. |\n| Function Call Location | The data center in which the function was executed.                                                                         |\n| Logs                   | A list of console.log outputs. App Services saves the first 512 bytes of the first 25 console.log() calls.                  | ### Error Fields Log entries created by unsuccessful operations may feature additional fields for debugging purposes. These include the following:\n\n ← [Schema Logs](https://mongodb.com/docs/atlas/app-services/logs/schema/ \"Previous Section\")[Trigger Logs](https://mongodb.com/docs/atlas/app-services/logs/trigger/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/enable-hosting/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Enable Hosting On this page * [Overview](#overview)\n* [Procedure](#procedure) ## Overview ## Important ### Static Hosting Requires a Paid-Tier Atlas Cluster To enable static hosting, you must have a paid-tier (i.e. `M2` or higher) Atlas cluster linked to your app as a data source. For more information on Atlas cluster tiers, see [Create a Cluster.](https://www.mongodb.com/docs/atlas/tutorial/create-new-cluster/) You need to enable static hosting for your application before you can upload and access content. You can enable static hosting from the App Services UI. ## Procedure Enable hosting from the UI with the following procedure: 1 ### Navigate to the Hosting Configuration Page To open the hosting configuration page, click Hosting in the left navigation menu of the App Services UI. 2 ### Enable Hosting On the Hosting configuration page, click Enable Hosting. App Services will begin provisioning hosting for your application. ## Note It may take a few minutes for App Services to finish provisioning hosting for your application once you've enabled it. You can [upload content to App Services](https://mongodb.com/docs/atlas/app-services/hosting/upload-content-to-app-services/) immediately, but you will need to wait for provisioning to complete before App Services serves your files. ← [Host Files](https://mongodb.com/docs/atlas/app-services/hosting/ \"Previous Section\")[Configure File Metadata](https://mongodb.com/docs/atlas/app-services/hosting/configure-file-metadata/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/host-a-single-page-application/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Host a Single-Page Application On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Upload Your Built Application to App Services](#upload-your-built-application-to-app-services)\n* [Configure App Services to Serve Your Application](#configure-app-services-to-serve-your-application)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Add Your Built Application Code](#add-your-built-application-code)\n* [Configure App Services to Serve Your Application](#configure-app-services-to-serve-your-application-1)\n* [Deploy the Updated Hosting Configuration](#deploy-the-updated-hosting-configuration) ## Overview Many web applications built with modern frameworks, like React, Vue, and Angular, are single-page applications (SPAs) that dynamically handle routing and rendering client-side instead of fetching each rendered page from the server. You can use Atlas App Services to host your SPA and serve it to clients. To host your app, you need to specify that it's a SPA in App Services. By default, App Services handles requests for a given resource by returning the file hosted at the specified resource path or a 404 if no file matches the path. However, SPAs render in a single, specific HTML file so all requests should return that file regardless of the requested resource path. This guide covers how you can configure App Services Hosting to redirect all resource requests to a single file to support the SPA pattern. ## Note ### 404 Errors in Single-Page Apps When [single-page application hosting](https://mongodb.com/docs/atlas/app-services/hosting/host-a-single-page-application/) is enabled, App Services always returns an HTTP 200 response with the app root regardless of the requested route. This means that you cannot [specify a custom 404 page](https://mongodb.com/docs/atlas/app-services/hosting/use-a-custom-404-page/) for a SPA. Instead, you should include custom code in your application to handle invalid routes. ## Procedure ← [Flush the CDN Cache](https://mongodb.com/docs/atlas/app-services/hosting/flush-the-cdn-cache/ \"Previous Section\")[Upload Content to Atlas App Services](https://mongodb.com/docs/atlas/app-services/hosting/upload-content-to-app-services/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/graphql/types-and-resolvers/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # GraphQL Types, Resolvers, and Operators On this page * [Overview](#overview)\n* [Scalar Types](#scalar-types)\n* [Document Types](#document-types)\n* [Field Mapping](#field-mapping)\n* [BSON Type Mapping](#bson-type-mapping)\n* [Input Types](#input-types)\n* [QueryInput](#queryinput)\n* [InsertInput](#insertinput)\n* [UpdateInput](#updateinput)\n* [RelationInput](#relationinput)\n* [SortByInput](#sortbyinput)\n* [Query Resolvers](#query-resolvers)\n* [Find a Single Document](#find-a-single-document)\n* [Find Multiple Documents](#find-multiple-documents)\n* [Mutation Resolvers](#mutation-resolvers)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Update a Single Document](#update-a-single-document)\n* [Update Multiple Documents](#update-multiple-documents)\n* [Upsert a Single Document](#upsert-a-single-document)\n* [Replace a Single Document](#replace-a-single-document)\n* [Delete a Single Document](#delete-a-single-document)\n* [Delete Multiple Documents](#delete-multiple-documents) ## Overview Atlas App Services automatically generates a GraphQL schema for any collection that has a defined [schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). For each collection, App Services generates the following: * A [document type](#std-label-graphql-document-types) that represents a single document in the collection\n* A set of [queries](#std-label-graphql-query-resolvers) and [mutations](#std-label-graphql-mutation-resolvers) that allow you to access and manipulate documents in the collection.\n* A set of [input types](#std-label-graphql-input-types) that allow you to filter queries, modify specific fields, and sort results. ## Note ### Example Collection Schema This page includes examples that demonstrate generated values based on the following schema for a `movies` collection:\n\n ` ## Scalar Types App Services supports all of the standard [GraphQL scalar types](https://graphql.org/learn/schema/#scalar-types) and also generates the `ObjectId` scalar. The following scalar types are supported: * `ObjectId`: An [ObjectId](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) value serialized as a string\n* `Boolean`: `true` or `false`\n* `String`: A UTF‐8 character sequence\n* `Int`: A signed 32‐bit integer\n* `Long`: A signed 64‐bit integer\n* `Float`: A signed double-precision floating-point value\n* `DateTime`: An [RFC 3339](https://tools.ietf.org/html/3339) UTC DateTime (e.g. \"2020-09-01T15:38:14.918Z\") ## Document Types App Services generates a single [GraphQL type](https://graphql.org/learn/schema/) for the documents in a collection based on the collection schema. The type uses the name set in the `title` field of the schema or the collection name if no `title`is specified. ``` type Movie {   _id: ObjectId   title: String!   year: Int   rated: String   runtime: Int   director: String   cast: [String] } \n``` ### Field Mapping App Services attempts to map fields in your collection schema directly to fields in your GraphQL types. The [definition of valid names](https://spec.graphql.org/June2018/#sec-Names) described in the GraphQL spec does not support all possible valid document field names, so App Services applies the following transformation rules to determine field names in generated GraphQL types: * strip unsupported characters\n* strip leading numbers\n* convert to camel case\n* omit fields that begin with a double underscore (e.g. `__myField`) ### BSON Type Mapping The GraphQL type system is similar but not identical to the BSON types that you can use in a [schema](https://mongodb.com/docs/atlas/app-services/schemas/#std-label-schemas). App Services automatically attempts to map between the BSON types in your schema and supported GraphQL types. If a field type does not have a GraphQL equivalent, App Services does not include the field in the generated GraphQL document type. The following table lists BSON types that you can use in a schema and the GraphQL types that they map to: | JSON/BSON Type | GraphQL Type |\n| -------------- | ------------ |\n| objectId       | ObjectId     |\n| int            | Int          |\n| long           | Int          |\n| double         | Float        |\n| decimal        | Float        |\n| date           | DateTime     |\n| timestamp      | DateTime     | ## Note JSON supports two types that represent \"no value\": `undefined` and`null`. The GraphQL spec supports `null` but not `undefined`, so your app converts `undefined` values in the following way: * If a document field is explicitly set to `undefined` then the corresponding GraphQL type is an empty object, i.e. `{}`.\n* If the field name is not defined for the document at all, or if the value is explicitly set to `null`, then the corresponding GraphQL type is `null`. ## Input Types GraphQL uses [input types](https://graphql.org/learn/schema/#input-types) to represent parameters that you pass to queries and mutations. This is a standard approach used by all GraphQL APIs to define unambiguous, type-safe user inputs. ### QueryInput A `QueryInput` object defines a set of one or more conditions that a document must meet in order to be included in a query. The object may include fields from the document type as well as any of the _operator fields_ that App Services automatically generates based on each field's type.\n\n #### Comparison Operator Fields A comparison operator field allows you to define a condition that is more complex than exact equality, such as a range query. App Services generates a set of comparison operator fields for every field in the document type based on the field type. Each comparison operator typically applies to only a subset of all field types, so App Services only generates operator fields for valid combinations. A comparison operator field evaluates to `true` for a given document if the value of the field in the document satisfies the operator condition relative to the specified value. Comparison operator fields have the following form: ``` <Field Name>_<Operator>: <Operator Value> \n```\n\n #### Logical Operator Fields A logical operator field allows you to define logical combinations of independent `QueryInput` objects. App Services generates root-level logical operator fields for all `QueryInput` types. A logical operator field evaluates to `true` for a given document if the evaluated result of all specified `QueryInput` objects satisfy the operator condition. Logical operator fields have the following form: ``` <Operator>: [<QueryInput>, ...] \n``` | Operator | Operator Value Type | Description                                                                                                                                                                                                                                                                    |\n| -------- | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| AND      | \\[QueryInput!\\]     | Finds documents that match _all_ of the provided QueryInput objects.ExampleThis query finds all movies that are rated PG-13 _and_ have a runtime of less than 120 minutes:query {  movies(query: { AND: \\[{ rated: \"PG-13\" }, { runtime\\_lt: 120 }\\] }) {    title    year  }} |\n| OR       | \\[QueryInput!\\]     | Finds documents that match _any_ of the provided QueryInput objects.ExampleThis query finds all movies that are rated either G or PG-13:query {  movies(query: { OR: \\[{ rated: \"G\" }, { rated: \"PG-13\" }\\] }) {    title    year  }}                                          | #### Element Operator Fields An element operator field allows you to define a boolean condition that describes a field in the document. App Services generates a set of element operator fields for every field in the document type. An element operator field evaluates to `true` for a given document if the result of evaluating the operator condition on the field in the document matches the specified boolean value. Element operator fields have the following form: ``` <Field Name>_<Operator>: <Operator Value> \n```\n\n ### InsertInput An `InsertInput` object defines a document to insert into a collection. The document must conform to the GraphQL document type and include all required fields. ## Example The following mutation includes an `InsertInput` with several fields that are all defined in the `Movie` document type. The `Movie` type requires all documents to have a `title` field, so the `InsertInput` must include one. The mutation inserts a new movie named \"My Fake Film\". ``` insertOneMovie(input: {   title: \"My Fake Film\",   rated: \"UNRATED\",   year: 2020 }) {   title } \n``` ### UpdateInput An `UpdateInput` object defines a new value for one or more fields in a document. The updated document includes the new field values. Any fields that you do not specify remain unchanged. The updated values must conform to the GraphQL document type. ## Example The following mutation includes an `UpdateInput` that sets the `title`field to \"My Super Real Film\". ``` updateOneMovie(   query: { title: \"My Fake Film\" }   set: { title: \"My Super Real Film\" } ) {   title } \n``` ### RelationInput A `RelationInput` defines a new set of related documents for a relationship field in the mutated document. You can reference documents that already exist in the related collection with the `link` field or insert new documents into the related collection with the `create` field. You cannot use both `link` and `create` at the same time. If both are specified, the `create` operation takes precedence and the`link` is ignored. ``` type RelationInput {   link: [ObjectId]   create: [InsertInput] } \n``` ## Example The following mutation includes an `UpdateInput` that modifies the`reviews` field. The field contains an array of `_id` values for documents in a separate `reviews` collection for to the field has a defined relationship. The mutation sets the relationship to point to one newly created document and two existing documents in the `reviews` collection. ``` updateOneMovie(   query: { title: \"My Fake Film\" }   set: {     reviews: {       link: [\"\", \"\"]       create: []     }   } ) {   title } \n``` ### SortByInput A `SortByInput` enum defines a sort order for documents returned by a query. You can sort in ascending and descending order by any root-level field that does not have a type of `object` or `array`. The GraphQL API does not support nested sorts. App Services generates two sort enum values for each field. Each value is a fully-capitalized identifier that combines the field name and the sort direction, either `ASC` or `DESC`. ## Example The following query returns movies sorted by the year they were released with the most recent movies listed first. ``` movies(sortBy: YEAR_DESC) {   title } \n``` ## Query Resolvers App Services generates two [GraphQL queries](#std-label-graphql-query-resolvers)for each collection: * A **singular** query that finds a specific document in the collection.\n* A **plural** query that finds all documents in the collection. You can filter a plural query to include only the subset of documents in a collection that match a `QueryInput`. ### Find a Single Document The single document query field uses the same name as the data type that the collection contains. It returns a single document of the queried type and accepts the following parameters:\n\n ``` query {   movie(query: { title: \"The Matrix\" }) {     title     year     runtime     director   } } \n``` ### Find Multiple Documents The multiple document query field uses the same name as the data type that the collection contains but has an additional `\"s\"` appended to the type name. It returns an array of documents of the queried type and accepts the following parameters:\n\n ``` query {   movies(     query: { year: 2000 }     limit: 100     sortBy: TITLE_ASC   ) {     title     year     runtime     director   } } \n``` ## Mutation Resolvers App Services generates a set of mutations for the documents in each collection. These allow you insert, modify, and delete one or more documents. ### Insert a Single Document The single document insert mutation field uses the name`insertOne<Type>` where `<Type>` is the singular name of the data type that the collection contains. It returns the inserted document and accepts the following parameters: | Parameter | Type                                         | Description                                                                                                                                                                                                                                                                       |\n| --------- | -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| data      | [InsertInput!](#std-label-input-type-insert) | Required. A document to insert into the collection. If the collection schema marks a field as required then this document must include a valid value for that field. App Services automatically converts GraphQL types in the InsertInput object into their respective BSON type. | ``` mutation {   insertOneMovie(data: {     title: \"Little Women\"     director: \"Greta Gerwig\"     year: 2019     runtime: 135   }) {     _id     title   } } \n``` ### Insert Multiple Documents The multiple document insert mutation field uses the name`insertMany<Type>s` where `<Type>` is the singular name of the data type that the collection contains. It returns the inserted document and accepts the following parameters:\n\n ``` mutation {   insertManyMovies(data: [     {       title: \"Little Women\"       director: \"Greta Gerwig\"       year: 2019       runtime: 135     },     {       title: \"1917\"       director: \"Sam Mendes\"       year: 2019       runtime: 119     }   ]) {     _id     title   } } \n``` ### Update a Single Document The single document update mutation field uses the name`updateOne<Type>` where `<Type>` is the singular name of the data type that the collection contains. It returns the updated document and accepts the following parameters:\n\n ``` mutation {   updateOneMovie(     query: { title: \"The Room\" }     set: { runtime: 99 }   ) {     _id     title   } } \n``` ### Update Multiple Documents The multiple document update mutation field uses the name`updateMany<Type>s` where `<Type>` is the singular name of the data type that the collection contains. It returns an `UpdateManyPayload`document that describes the number of fields that were matched and modified and accepts the following parameters: | Parameter | Type                                         | Description                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| --------- | -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| query     | [QueryInput](#std-label-input-type-query)    | Optional. An object that configures which documents in the collection to update. The object may specify one or more fields from the data type and must include a value for each field. The query matches all documents that include the specified field values.If you do not specify a query argument then the mutation updates the first document in the result set, which is likely but not guaranteed to be the most recently inserted document. |\n| set       | [UpdateInput!](#std-label-input-type-update) | Required. An object that defines a new value for one or more fields in the document. The updated document will include the new field values. Any fields that you do not specify remain unchanged. App Services automatically converts GraphQL types in theUpdateInput object into their respective BSON type.                                                                                                                                       | ``` mutation {   updateManyMovies(     query: { director: \"Tommy Wiseau\" }     set: { director: \"Tom Wiseau\" }   ) {     matchedCount     modifiedCount   } } \n```\n\n The single document upsert mutation field uses the name`upsertOne<Type>` where `<Type>` is the singular name of the data type that the collection contains. This resolver updates a document that matches the query parameter and inserts a new document if none match the query. It returns the upserted document and accepts the following parameters: | Parameter | Type                                         | Description                                                                                                                                                                                                                                                                                                                                                                          |\n| --------- | -------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| query     | [QueryInput](#std-label-input-type-query)    | Optional. An object that configures which document to update. The object may specify one or more fields from the data type and must include a value for each field. The query matches all documents that include the specified field values.If you do not specify a query argument or no documents match, then the mutation inserts the document specified in the dataparameter.     |\n| data      | [InsertInput!](#std-label-input-type-insert) | Required. The document to insert if the query does not match any existing documents. If the query does match a document replaces the queried document. If the collection schema marks a field as required then this document must include a valid value for that field. App Services automatically converts GraphQL types in the InsertInput object into their respective BSON type. | ``` mutation {   upsertOneMovie(     query: { title: \"Blacksmith Scene\" }     data: {       title: \"Sandcastles in the Sand\",       director: \"Robin Scherbatsky\"       runtime: 90       year: 2002     }   ) {     _id     title   } } \n``` ### Replace a Single Document The single document replacement mutation field uses the name`replaceOne<Type>` where `<Type>` is the singular name of the data type that the collection contains. It returns the replaced document and accepts the following parameters:\n\n ``` mutation {   replaceOneMovie(     query: { title: \"Blacksmith Scene\" }     data: {       title: \"Sandcastles in the Sand\",       director: \"Robin Scherbatsky\"       runtime: 90       year: 2002     }   ) {     _id     title   } } \n``` ### Delete a Single Document The single document delete mutation field uses the name`deleteOne<Type>` where `<Type>` is the singular name of the data type that the collection contains. It returns the deleted document and accepts the following parameters: | Parameter | Type                                      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| --------- | ----------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| query     | [QueryInput](#std-label-input-type-query) | Required. An object that configures which document in the collection to delete. The object may specify one or more fields from the data type and must include a value for each field. The query matches all documents that include the specified field values.If the query matches multiple documents, the mutation deletes the first document in the result set, which is likely but not guaranteed to be the most recently inserted document. | ``` mutation {   deleteOneMovie(query: { title: \"The Room\" }) {     _id     title     year     runtime     director   } } \n``` ### Delete Multiple Documents The multiple document delete mutation field uses the name`deleteMany<Type>s` where `<Type>` is the singular name of the data type that the collection contains. It returns a `DeleteManyPayload`document that describes the number of documents that were deleted and accepts the following parameters:\n\n ``` mutation {   deleteManyMovies(query: { director: \"Tommy Wiseau\" }) {     deletedCount   } } \n``` ← [Authenticate GraphQL Requests](https://mongodb.com/docs/atlas/app-services/graphql/authenticate/ \"Previous Section\")[Define a Custom Resolver](https://mongodb.com/docs/atlas/app-services/graphql/custom-resolvers/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/upload-content-to-app-services/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Upload Content to Atlas App Services On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Navigate to the Hosting Configuration Page](#navigate-to-the-hosting-configuration-page)\n* [Upload Files to Atlas App Services](#upload-files-to-atlas-app-services)\n* [Pull Your App's Latest Configuration Files](#pull-your-app-s-latest-configuration-files)\n* [Add a Hosting Directory](#add-a-hosting-directory)\n* [Add a Metadata Configuration File](#add-a-metadata-configuration-file)\n* [Add Files to the Hosting Directory](#add-files-to-the-hosting-directory)\n* [Upload the Files](#upload-the-files) ## Overview You can upload content to App Services from the Hosting screen of the App Services UI or by [importing](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-cli) an application directory that includes the files. Select the tab below that corresponds to the method you want to use. ## Procedure ← [Host a Single-Page Application](https://mongodb.com/docs/atlas/app-services/hosting/host-a-single-page-application/ \"Previous Section\")[Use a Custom 404 Page](https://mongodb.com/docs/atlas/app-services/hosting/use-a-custom-404-page/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/file-metadata-attributes/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # File Metadata Attributes On this page * [Overview](#overview)\n* [Content-Type](#content-type)\n* [Content-Disposition](#content-disposition)\n* [Content-Encoding](#content-encoding)\n* [Content-Language](#content-language)\n* [Cache-Control](#cache-control)\n* [Website-Redirect-Location](#website-redirect-location) ## Overview You can define metadata attributes for each file that you host with Atlas App Services. Metadata attributes map to standard [HTTP headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) and allow you to optionally configure how App Services serves your files as well as how clients that request resources should handle them. This page provides examples and describes the purpose of each available attribute. ## Content-Type The [Content-Type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) file attribute indicates the [media type](https://en.wikipedia.org/wiki/Media%5Ftype) of the file. ## Note If you do not specify a `Content-Type` attribute for a file, App Services will attempt to automatically add a `Content-Type` attribute to it based on the file extension. For example, App Services would automatically add the attribute`Content-Type: application/html` to the file `myPage.html`. ### Examples #### Indicate that a File Contains HTML `| Content-Type: application/html |\n| ------------------------------ | ` ## Content-Disposition The [Content-Disposition](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)file attribute indicates to client applications (such as your web browser) whether the file should be downloaded as an attachment or displayed inline as a web page. ### Examples #### Display the File Inline ``` Content-Disposition: inline \n``` #### Download the File ``` Content-Disposition: attachment \n``` #### Download the File with a Custom Filename ``` Content-Disposition: attachment; filename=\"myFile.txt\" \n``` ## Content-Encoding The [Content-Encoding](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding) file attribute indicates any encodings that were applied to the file. Client applications can use this header to determine how to properly decode the file. ### Examples #### Indicate No Encoding ``` Content-Encoding: identity \n``` #### Indicate GZIP Encoding ``` Content-Encoding: gzip \n``` #### Indicate Multiple Encodings in Application Order ``` Content-Encoding: gzip, identity \n``` ## Content-Language The [Content-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Language) file attribute optionally specifies the language used by the file's intended target audience. This attribute does not necessarily represent the language that file is actually written in. ### Examples #### Specify a Single Language ``` Content-Language: en-US \n``` #### Specify Multiple Languages ``` Content-Language: en-US, en-CA, en-UK \n``` ## Cache-Control The [Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) file attribute instructs CDN servers on how they should handle cached copies of the file. ### Examples #### Refresh a Cached File Every Five Minutes ``` Cache-Control: max-age=300 \n``` #### Never Cache a File ``` Cache-Control: no-cache \n``` ## Website-Redirect-Location The `Website-Redirect-Location` file redirects requests to the specified destination. ### Examples #### Redirect Requests to a Different File ``` Website-Redirect-Location: https://example.com/file/redirectedFile.txt \n``` ← [Configure File Metadata](https://mongodb.com/docs/atlas/app-services/hosting/configure-file-metadata/ \"Previous Section\")[Flush the CDN Cache](https://mongodb.com/docs/atlas/app-services/hosting/flush-the-cdn-cache/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/use-a-custom-404-page/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Use a Custom 404 Page On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Create a Custom 404 Page File](#create-a-custom-404-page-file)\n* [Host the 404 File in App Services](#host-the-404-file-in-app-services)\n* [Configure the 404 Resource Path in App Services](#configure-the-404-resource-path-in-app-services)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Create a Custom 404 Page HTML File](#create-a-custom-404-page-html-file)\n* [Host the HTML File in App Services](#host-the-html-file-in-app-services)\n* [Specify the 404 Page in the Application Configuration](#specify-the-404-page-in-the-application-configuration)\n* [Deploy the Updated Hosting Configuration](#deploy-the-updated-hosting-configuration) ## Overview You can replace the default [404 page](https://en.wikipedia.org/wiki/HTTP%5F404#Custom%5Ferror%5Fpages) that Atlas App Services displays when a user tries to access a resource that does not exist with a custom HTML document. You can specify this custom 404 page from the App Services UI or by [importing](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-cli) an application configuration directory that includes the page in its `hosting` directory. Select the tab below that corresponds to the method you want to use. ## Note ### 404 Errors in Single-Page Apps When [single-page application hosting](https://mongodb.com/docs/atlas/app-services/hosting/host-a-single-page-application/) is enabled, App Services always returns an HTTP 200 response with the app root regardless of the requested route. This means that you cannot [specify a custom 404 page](https://mongodb.com/docs/atlas/app-services/hosting/use-a-custom-404-page/) for a SPA. Instead, you should include custom code in your application to handle invalid routes. ## Procedure ← [Upload Content to Atlas App Services](https://mongodb.com/docs/atlas/app-services/hosting/upload-content-to-app-services/ \"Previous Section\")[Use a Custom Domain Name](https://mongodb.com/docs/atlas/app-services/hosting/use-a-custom-domain-name/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/flush-the-cdn-cache/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Flush the CDN Cache On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Navigate to the Hosted File Tree](#navigate-to-the-hosted-file-tree)\n* [Select the Purge Cache Action](#select-the-purge-cache-action)\n* [Select the Attribute Type and Value](#select-the-attribute-type-and-value)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Deploy with the Reset CDN Cache Flag](#deploy-with-the-reset-cdn-cache-flag) ## Overview Atlas App Services serves hosted files through a [Content Delivery Network (CDN)](https://en.wikipedia.org/wiki/Content%5Fdelivery%5Fnetwork) in order to minimize the latency between receiving a request for a resource and returning the requested resource. When a client requests a resource that's hosted in App Services, the CDN server that processes the request checks for a cached copy of the file. If the server finds a valid cached copy of the resource, it returns it to the client. Otherwise, it forwards the request to App Services and caches the returned file before returning it to the client. The CDN caching process decreases the latency for end users when they request a resource but may cause users to receive an out-of-date version of a resource if the file has changed since the CDN server cached it. You can _flush_ the CDN cache in order to make it drop all cached files and start serving the latest version of each file. ## Note ### Automatic Cache Invalidation The CDN automatically refreshes cached files periodically. You can configure the caching behavior for an individual file by adding a a[Cache-Control](https://mongodb.com/docs/atlas/app-services/hosting/file-metadata-attributes/#std-label-metadata-cache-control) attribute to the file. ## Procedure ← [File Metadata Attributes](https://mongodb.com/docs/atlas/app-services/hosting/file-metadata-attributes/ \"Previous Section\")[Host a Single-Page Application](https://mongodb.com/docs/atlas/app-services/hosting/host-a-single-page-application/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/use-a-custom-domain-name/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Use a Custom Domain Name On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Acquire the Custom Domain Name](#acquire-the-custom-domain-name)\n* [Specify the Custom Domain in Atlas App Services](#specify-the-custom-domain-in-atlas-app-services)\n* [Add a Validation CNAME Record](#add-a-validation-cname-record)\n* [Add a Redirect CNAME Record](#add-a-redirect-cname-record)\n* [Acquire the Custom Domain Name](#acquire-the-custom-domain-name-1)\n* [Pull the Latest Version of Your App](#pull-the-latest-version-of-your-app)\n* [Specify the Custom Domain](#specify-the-custom-domain)\n* [Import the Application Directory](#import-the-application-directory)\n* [Deploy the Updated Hosting Configuration](#deploy-the-updated-hosting-configuration)\n* [Add a Validation CNAME Record](#add-a-validation-cname-record-1)\n* [Add a Redirect CNAME Record](#add-a-redirect-cname-record-1) ## Overview You can use your own custom domain name for your hosted content. By default, content that you upload is available at a domain with the following form: `| <Your App ID>.mongodbstitch.com |\n| ------------------------------- | ` You can configure a custom domain name for your application's hosted content from the App Services UI or by [importing](https://mongodb.com/docs/atlas/app-services/apps/update/#std-label-deploy-cli) an application configuration directory that specifies the domain in its `config.json` configuration file. Select the tab below that corresponds to the method you want to use. ## Procedure ## Note ### Add App Services's AWS CAAs to Verify Your Domain If you have trouble verifying your domain: * clear any unnecessary [CAA](https://en.wikipedia.org/wiki/DNS%5FCertification%5FAuthority%5FAuthorization)'s from your site's records\n* add the following CAA records:  \n| Domain          | Record Type | Flags | Tag   | Value             |  \n| --------------- | ----------- | ----- | ----- | ----------------- |  \n| www.example.com | CAA         | 0     | issue | \"amazon.com\"      |  \n| www.example.com | CAA         | 0     | issue | \"amazontrust.com\" |  \n| www.example.com | CAA         | 0     | issue | \"awstrust.com\"    | ← [Use a Custom 404 Page](https://mongodb.com/docs/atlas/app-services/hosting/use-a-custom-404-page/ \"Previous Section\")[Reference](https://mongodb.com/docs/atlas/app-services/reference/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/hosting/configure-file-metadata/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Configure File Metadata On this page * [Overview](#overview)\n* [Procedure](#procedure)\n* [Navigate to the File in the File Tree](#navigate-to-the-file-in-the-file-tree)\n* [Add a New Attribute](#add-a-new-attribute)\n* [Select the Attribute Type and Value](#select-the-attribute-type-and-value)\n* [Pull Your App's Latest Configuration Files](#pull-your-app-s-latest-configuration-files)\n* [Add Attributes to the Metadata Configuration File](#add-attributes-to-the-metadata-configuration-file)\n* [Import the File Metadata Configuration](#import-the-file-metadata-configuration) ## Overview You can configure a file's [metadata attributes](https://mongodb.com/docs/atlas/app-services/hosting/file-metadata-attributes/) to describe aspects of the file, such as its content type, language, or encoding. You can also use metadata attributes to configure the CDN's caching behavior and specify how clients should handle files when they access them. ## Note If you do not specify a `Content-Type` metadata attribute for a hosted file, Atlas App Services will attempt to automatically add a `Content-Type`attribute to it based on the file extension. For example, App Services would automatically add the attribute`Content-Type: application/html` to the file `myPage.html`. ## Procedure ← [Enable Hosting](https://mongodb.com/docs/atlas/app-services/hosting/enable-hosting/ \"Previous Section\")[File Metadata Attributes](https://mongodb.com/docs/atlas/app-services/hosting/file-metadata-attributes/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-describe/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli apps describe On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Displays information about your App View all of the aspects of your App to see what is configured and enabled (e.g. services, functions, etc.). If you have more than one App, you will be prompted to select an App to view. ## Syntax `| realm-cli apps describe [options] |\n| --------------------------------- | ` ## Options | Name        | Type   | Required          | Description                                  |\n| ----------- | ------ | ----------------- | -------------------------------------------- |\n| \\-a, --app  | string | false             | Specify the name or ID of an App to describe |\n| \\-h, --help | false  | help for describe |                                              | ## Inherited Options\n\n ← [realm-cli apps delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-delete/ \"Previous Section\")[realm-cli apps diff](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-diff/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-login/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli login On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Log the CLI into Atlas App Services using a MongoDB Cloud API key Begins an authenticated session with App Services. To get a MongoDB Cloud API Key, open your App in the App Services UI. Navigate to \"Deployment\" in the left navigation menu, and select the \"Export App\" tab. From there, create a programmatic API key to authenticate your realm-cli session. ## Syntax `| realm-cli login [options] |\n| ------------------------- | ` ## Options | Name               | Type   | Required       | Description                                                    |\n| ------------------ | ------ | -------------- | -------------------------------------------------------------- |\n| \\--api-key         | string | false          | Specify the public portion of your Atlas programmatic API Key  |\n| \\--private-api-key | string | false          | Specify the private portion of your Atlas programmatic API Key |\n| \\-h, --help        | false  | help for login |                                                                | ## Inherited Options\n\n ← [realm-cli function run](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-function-run/ \"Previous Section\")[realm-cli logout](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logout/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-list/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli secrets list On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) List the Secrets in your App (alias: ls) This will display the IDs and Names of the Secrets in your App. ## Syntax `| realm-cli secrets list [options] |\n| -------------------------------- | ` ## Options | Name        | Type   | Required      | Description                                          |\n| ----------- | ------ | ------------- | ---------------------------------------------------- |\n| \\-a, --app  | string | false         | Specify the name or ID of an App to list its secrets |\n| \\-h, --help | false  | help for list |                                                      | ## Inherited Options\n\n ← [realm-cli secrets delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-delete/ \"Previous Section\")[realm-cli secrets update](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-update/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-function/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli function On this page * [Options](#options)\n* [Inherited Options](#inherited-options)\n* [Related Commands](#related-commands) Interact with the Functions of your app (alias: functions) ## Options | Name        | Type  | Required          | Description |\n| ----------- | ----- | ----------------- | ----------- |\n| \\-h, --help | false | help for function |             | ## Inherited Options\n\n ## Related Commands * [realm-cli function run](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-function-run/#std-label-realm-cli-function-run) \\- Run a Function from your app ← [realm-cli apps list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-list/ \"Previous Section\")[realm-cli function run](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-function-run/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli accessList delete On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Delete an IP address or CIDR block from the Access List of your App Removes an existing entry from the Access List of your App. You will be prompted to select an IP address or CIDR block if none are provided in the initial command. ## Syntax `| realm-cli accessList delete [options] |\n| ------------------------------------- | ` ## Options | Name        | Type    | Required        | Description                                                             |\n| ----------- | ------- | --------------- | ----------------------------------------------------------------------- |\n| \\-a, --app  | string  | false           | Specify the name or ID of an App to remove entries from its Access List |\n| \\--ip       | strings | false           | Specify the IP address(es) or CIDR block(s) to delete                   |\n| \\-h, --help | false   | help for delete |                                                                         | ## Inherited Options\n\n ← [realm-cli accessList create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-create/ \"Previous Section\")[realm-cli accessList list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-list/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-users-create/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli users create On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Create an application user for your App Adds a new user to your App. You can create a user for the following enabled authentication providers: \"Email/Password\" or \"API Key\". ## Syntax `| realm-cli users create [options] |\n| -------------------------------- | ` ## Options | Name        | Type   | Required        | Description                                                                               |\n| ----------- | ------ | --------------- | ----------------------------------------------------------------------------------------- |\n| \\-a, --app  | string | false           | Specify the name or ID of an App to create its users                                      |\n| \\--type     | String | false           | Select the type of user to create (Default value: <none>; Allowed values: api-key, email) |\n| \\--name     | string | false           | Specify the name of the new API Key                                                       |\n| \\--email    | string | false           | Specify the email of the new user                                                         |\n| \\--password | string | false           | Specify the password of the new user                                                      |\n| \\-h, --help | false  | help for create |                                                                                           | ## Inherited Options\n\n ← [realm-cli users](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users/ \"Previous Section\")[realm-cli users delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-update/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli secrets update On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Update a Secret in your App NOTE: The Name of the Secret cannot be modified. In order to do so, you will need to delete and re-create the Secret. ## Syntax `| realm-cli secrets update [options] |\n| ---------------------------------- | ` ## Options | Name          | Type   | Required        | Description                                            |\n| ------------- | ------ | --------------- | ------------------------------------------------------ |\n| \\-a, --app    | string | false           | Specify the name or ID of an App to update its secrets |\n| \\-s, --secret | string | false           | Specify the name or ID of the secret to update         |\n| \\-n, --name   | string | false           | Re-name the secret                                     |\n| \\-v, --value  | string | false           | Specify the new secret value                           |\n| \\-h, --help   | false  | help for update |                                                        | ## Inherited Options\n\n ← [realm-cli secrets list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-list/ \"Previous Section\")[realm-cli users](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli secrets On this page * [Options](#options)\n* [Inherited Options](#inherited-options)\n* [Related Commands](#related-commands) Manage the Secrets of your App (alias: secret) ## Options | Name        | Type  | Required         | Description |\n| ----------- | ----- | ---------------- | ----------- |\n| \\-h, --help | false | help for secrets |             | ## Inherited Options\n\n ## Related Commands * [realm-cli secrets create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-create/#std-label-realm-cli-secrets-create) \\- Create a Secret for your App\n* [realm-cli secrets delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-delete/#std-label-realm-cli-secrets-delete) \\- Delete a Secret from your App\n* [realm-cli secrets list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-list/#std-label-realm-cli-secrets-list) \\- List the Secrets in your App (alias: ls)\n* [realm-cli secrets update](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-update/#std-label-realm-cli-secrets-update) \\- Update a Secret in your App ← [realm-cli schema datamodels](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-schema-datamodels/ \"Previous Section\")[realm-cli secrets create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-update/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli accessList update On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Modify an IP address or CIDR block in the Access List of your App Changes an existing entry from the Access List of your App. You must specify either the `--new-ip` or `--comment` option. You will be prompted to select an IP address or CIDR block to update if neither is specified. ## Syntax `| realm-cli accessList update [options] |\n| ------------------------------------- | ` ## Options | Name        | Type   | Required                            | Description                                                                   |\n| ----------- | ------ | ----------------------------------- | ----------------------------------------------------------------------------- |\n| \\--new-ip   | string | true if \\--comment is not specified | Specify the new IP address or CIDR block that will replace the existing entry |\n| \\--comment  | string | true if \\--new-ip is not specified  | Add or edit a comment to the IP address or CIDR block that is being modified  |\n| \\-a, --app  | string | false                               | Specify the name or ID of an App to modify an entry in its Access List        |\n| \\--ip       | string | false                               | Specify the existing IP address or CIDR block that you would like to modify   |\n| \\-h, --help | false  | help for update                     |                                                                               | ## Inherited Options\n\n ← [realm-cli accessList list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-list/ \"Previous Section\")[realm-cli apps](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli apps delete On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Delete an App If you have more than one App, you will be prompted to select one or multiple apps that you would like to delete from a list of all your Atlas App Services Apps. The list includes App Services Apps from all projects associated with your user profile. ## Syntax `| realm-cli apps delete [options] |\n| ------------------------------- | ` ## Options | Name        | Type    | Required        | Description                                                 |\n| ----------- | ------- | --------------- | ----------------------------------------------------------- |\n| \\-a, --app  | strings | false           | Specify the name(s) or ID(s) of App Services Apps to delete |\n| \\-h, --help | false   | help for delete |                                                             | ## Inherited Options\n\n ← [realm-cli apps create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-create/ \"Previous Section\")[realm-cli apps describe](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-describe/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-function-run/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli function run On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Run a Function from your App Atlas Functions allow you to define and execute server-side logic for your Atlas App Services app. Once you select and run a Function for your App, the following will be displayed: * A list of logs, if present\n* The function result as a document\n* A list of error logs, if present ## Syntax `| realm-cli function run [options] |\n| -------------------------------- | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli function](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-function/ \"Previous Section\")[realm-cli login](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-login/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-schema-datamodels/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli schema datamodels On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Generate data models based on your Schema (alias: datamodel) Translates your Schema's objects into Atlas App Services data models. The data models define your data as native objects, which can be easily integrated into your own repo to use with Atlas Device Sync. NOTE: You must have a valid JSON Schema before using this command. With this command, you can: * Specify the language with a \"--language\" flag\n* Filter which Schema objects you'd like to include in your output with \"--name\" flags\n* Combine your Schema objects into a single output with a \"--flat\" flag\n* Omit import groups from your model with a \"--no-imports\" flag ## Syntax `| realm-cli schema datamodels [options] |\n| ------------------------------------- | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli schema](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-schema/ \"Previous Section\")[realm-cli secrets](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-create/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli accessList create On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Create an IP address or CIDR block in the Access List for your App You will be prompted to input an IP address or CIDR block if none is provided in the initial command. ## Syntax `| realm-cli accessList create [options] |\n| ------------------------------------- | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli accessList](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList/ \"Previous Section\")[realm-cli accessList delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli accessList On this page * [Options](#options)\n* [Inherited Options](#inherited-options)\n* [Related Commands](#related-commands) Manage the allowed IP addresses and CIDR blocks of your App (aliases: accesslist, access-list) ## Options | Name        | Type  | Required            | Description |\n| ----------- | ----- | ------------------- | ----------- |\n| \\-h, --help | false | help for accessList |             | ## Inherited Options\n\n ## Related Commands * [realm-cli accessList create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-create/#std-label-realm-cli-accessList-create) \\- Create an IP address or CIDR block in the Access List for your App\n* [realm-cli accessList delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-delete/#std-label-realm-cli-accessList-delete) \\- Delete an IP address or CIDR block from the Access List of your App\n* [realm-cli accessList list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-list/#std-label-realm-cli-accessList-list) \\- List the allowed entries in the Access List of your App (alias: ls)\n* [realm-cli accessList update](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-update/#std-label-realm-cli-accessList-update) \\- Modify an IP address or CIDR block in the Access List of your App ← [Realm CLI](https://mongodb.com/docs/atlas/app-services/cli/ \"Previous Section\")[realm-cli accessList create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-users-revoke/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli users revoke On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Revoke an application user's sessions from your App Logs a user out of your App. A revoked user can log in again if they provide valid credentials. ## Syntax `| realm-cli users revoke [options] |\n| -------------------------------- | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli users list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-list/ \"Previous Section\")[realm-cli whoami](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-whoami/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-list/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli apps list On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) List the Atlas App Services Apps you have access to (alias: ls) Lists and filters your App Services Apps. ## Syntax `| realm-cli apps list [options] |\n| ----------------------------- | ` ## Options | Name        | Type   | Required      | Description                                  |\n| ----------- | ------ | ------------- | -------------------------------------------- |\n| \\-a, --app  | string | false         | Filter the list of App Services Apps by name |\n| \\-h, --help | false  | help for list |                                              | ## Inherited Options\n\n ← [realm-cli apps init](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-init/ \"Previous Section\")[realm-cli function](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-function/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-users-delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli users delete On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Delete an application user from your App You can remove multiple users at once with the \"--user\" flag. You can only specify these users using their ID values. ## Syntax `| realm-cli users delete [options] |\n| -------------------------------- | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli users create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-create/ \"Previous Section\")[realm-cli users disable](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-disable/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-apps/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli apps On this page * [Options](#options)\n* [Inherited Options](#inherited-options)\n* [Related Commands](#related-commands) Manage the Atlas App Services Apps associated with the current user (alias: app) ## Options | Name        | Type  | Required      | Description |\n| ----------- | ----- | ------------- | ----------- |\n| \\-h, --help | false | help for apps |             | ## Inherited Options\n\n ## Related Commands * [realm-cli apps create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-create/#std-label-realm-cli-apps-create) \\- Create a new app from your current working directory and deploy it to the App Services server\n* [realm-cli apps delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-delete/#std-label-realm-cli-apps-delete) \\- Delete an App\n* [realm-cli apps describe](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-describe/#std-label-realm-cli-apps-describe) \\- Displays information about your App\n* [realm-cli apps diff](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-diff/#std-label-realm-cli-apps-diff) \\- Show differences between your local directory and your App\n* [realm-cli apps init](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-init/#std-label-realm-cli-apps-init) \\- Initialize an App in your current working directory (alias: initialize)\n* [realm-cli apps list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-list/#std-label-realm-cli-apps-list) \\- List the App Services Apps you have access to (alias: ls) ← [realm-cli accessList update](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-update/ \"Previous Section\")[realm-cli apps create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-diff/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli apps diff On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Show differences between your local directory and your App Displays file-by-file differences between your local directory and the latest version of your App. If you have more than one App, you will be prompted to select an App to view. ## Syntax `| realm-cli apps diff [options] |\n| ----------------------------- | ` ## Options | Name                        | Type   | Required                              | Description                                  |\n| --------------------------- | ------ | ------------------------------------- | -------------------------------------------- |\n| \\--local                    | string | false                                 | Specify the local filepath of an App to diff |\n| \\--remote                   | string | false                                 | Specify the name or ID of an App to diff     |\n| \\-d, --include-dependencies | false  | Include App dependencies in the diff  |                                              |\n| \\-s, --include-hosting      | false  | Include App hosting files in the diff |                                              |\n| \\-h, --help                 | false  | help for diff                         |                                              | ## Inherited Options\n\n ← [realm-cli apps describe](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-describe/ \"Previous Section\")[realm-cli apps init](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-init/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-logs-list/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli logs list On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Lists the Logs in your App (alias: ls) Displays a list of your App's Logs sorted by recentness, with most recent Logs appearing towards the bottom. You can specify a \"--tail\" flag to monitor your Logs and follow any newly created Logs in real-time. ## Syntax `| realm-cli logs list [options] |\n| ----------------------------- | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli logs](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logs/ \"Previous Section\")[realm-cli pull](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-pull/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-init/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli apps init On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Initialize an App in your current working directory (alias: initialize) Initializes a new App by saving your configuration files in your current working directory. You can specify a \"--remote\" flag to initialize an App from an existing app; if you do not specify a \"--remote\" flag, the CLI will initialize a default App. NOTE: To create a new App and have it deployed, use \"app create\". ## Syntax `| realm-cli apps init [options] |\n| ----------------------------- | ` ## Options | Name                    | Type   | Required      | Description                                                                                                |\n| ----------------------- | ------ | ------------- | ---------------------------------------------------------------------------------------------------------- |\n| \\--remote               | string | false         | Specify the name or ID of a remote App to clone                                                            |\n| \\-n, --name             | string | false         | Name your new App                                                                                          |\n| \\-l, --location         | String | false         | Select the App's location (Default value: <none>; Allowed values: US-VA, US-OR, DE-FF, IE, AU, IN-MB, SG)  |\n| \\-d, --deployment-model | String | false         | Select the App's deployment model (Default value: <none>; Allowed values: GLOBAL, LOCAL)                   |\n| \\-e, --environment      | String | false         | Select the App's environment (Default value: <none>; Allowed values: development, testing, qa, production) |\n| \\-h, --help             | false  | help for init |                                                                                                            | ## Inherited Options\n\n ← [realm-cli apps diff](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-diff/ \"Previous Section\")[realm-cli apps list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-list/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-logout/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli logout On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Log the CLI out of Atlas App Services Ends the authenticated session and deletes cached auth tokens. To re-authenticate, you must call Login with your Atlas programmatic API key. ## Syntax `| realm-cli logout [options] |\n| -------------------------- | ` ## Options | Name        | Type  | Required        | Description |\n| ----------- | ----- | --------------- | ----------- |\n| \\-h, --help | false | help for logout |             | ## Inherited Options\n\n ← [realm-cli login](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-login/ \"Previous Section\")[realm-cli logs](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logs/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-create/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli apps create On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Create a new app from your current working directory and deploy it to the Atlas App Services server Creates a new App by saving your configuration files in a local directory and deploying the new app to the App Services server. This command will create a new directory for your project. You can specify a \"--remote\" flag to create an App from an existing app; if you do not specify a \"--remote\" flag, the CLI will create a default App. NOTE: To create an App without deploying it, use \"app init\". ## Syntax `| realm-cli apps create [options] |\n| ------------------------------- | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli apps](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps/ \"Previous Section\")[realm-cli apps delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-apps-delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-schema/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli schema On this page * [Options](#options)\n* [Inherited Options](#inherited-options)\n* [Related Commands](#related-commands) Manage the Schemas of your App (alias: schemas) ## Options | Name        | Type  | Required        | Description |\n| ----------- | ----- | --------------- | ----------- |\n| \\-h, --help | false | help for schema |             | ## Inherited Options\n\n ## Related Commands * [realm-cli schema datamodels](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-schema-datamodels/#std-label-realm-cli-schema-datamodels) \\- Generate data models based on your Schema (alias: datamodel) ← [realm-cli push](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-push/ \"Previous Section\")[realm-cli schema datamodels](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-schema-datamodels/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-logs/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli logs On this page * [Options](#options)\n* [Inherited Options](#inherited-options)\n* [Related Commands](#related-commands) Interact with the Logs of your App (alias: log) ## Options | Name        | Type  | Required      | Description |\n| ----------- | ----- | ------------- | ----------- |\n| \\-h, --help | false | help for logs |             | ## Inherited Options\n\n ## Related Commands * [realm-cli logs list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logs-list/#std-label-realm-cli-logs-list) \\- Lists the Logs in your App (alias: ls) ← [realm-cli logout](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logout/ \"Previous Section\")[realm-cli logs list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logs-list/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-create/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli secrets create On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Create a Secret for your App You will be prompted to name your Secret and define the value of your Secret. ## Syntax `| realm-cli secrets create [options] |\n| ---------------------------------- | ` ## Options | Name         | Type   | Required        | Description                                            |\n| ------------ | ------ | --------------- | ------------------------------------------------------ |\n| \\-a, --app   | string | false           | Specify the name or ID of an App to create its secrets |\n| \\-n, --name  | string | false           | Name the secret                                        |\n| \\-v, --value | string | false           | Specify the secret value                               |\n| \\-h, --help  | false  | help for create |                                                        | ## Inherited Options\n\n ← [realm-cli secrets](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets/ \"Previous Section\")[realm-cli secrets delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-delete/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-delete/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli secrets delete On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Delete a Secret from your App With this command, you can: * Remove multiple Secrets at once with \"--secret\" flags. You can specify these Secrets using their ID or Name values ## Syntax `| realm-cli secrets delete [options] |\n| ---------------------------------- | ` ## Options | Name          | Type    | Required        | Description                                            |\n| ------------- | ------- | --------------- | ------------------------------------------------------ |\n| \\-a, --app    | string  | false           | Specify the name or ID of an App to delete its secrets |\n| \\-s, --secret | strings | false           | Specify the name or ID of the secret to delete         |\n| \\-h, --help   | false   | help for delete |                                                        | ## Inherited Options\n\n ← [realm-cli secrets create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-create/ \"Previous Section\")[realm-cli secrets list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-list/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-reference-v1/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Realm CLI v1 On this page * [Overview](#overview)\n* [Installation](#installation)\n* [General Options](#general-options)\n* [Authentication](#authentication)\n* [Authenticate a CLI User](#authenticate-a-cli-user)\n* [Log Out the Current CLI User](#log-out-the-current-cli-user)\n* [View the Currently Logged In User](#view-the-currently-logged-in-user)\n* [Apps](#apps)\n* [Import an Application](#import-an-application)\n* [Export an Application](#export-an-application)\n* [Diff Pending Application Changes](#diff-pending-application-changes)\n* [Secrets](#secrets)\n* [List All Secrets](#list-all-secrets)\n* [Create a Secret](#create-a-secret)\n* [Update a Secret's Value](#update-a-secret-s-value)\n* [Remove a Secret](#remove-a-secret)\n* [Import Strategies](#import-strategies)\n* [Merge](#merge)\n* [Replace](#replace)\n* [Replace by Name](#replace-by-name) ## Overview The Atlas App Services Command Line Interface ([realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli)) allows you to programmatically manage your Apps. With [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli), you can create or update Apps from a local directory as well as export existing applications to a local directory. ## Installation Realm CLI is available on `npm`. To install version 1 of the Realm CLI on your system, ensure that you have [Node.js](https://nodejs.org/en/download/)installed and then run the following command in your shell: `| npm install -g mongodb-realm-cli@1.3.4 |\n| -------------------------------------- | ` ## General Options ## Important ### Check your CLI version This page documents commands, arguments, and flags for version 1 of[realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli). If you have a newer version of Realm CLI, run [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) `--help` for a list of updated commands and usage examples. To check your CLI version, use: `realm-cli --version`. The following options are available for all [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) commands: `--config-path <File System Path>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli.--config-path \"Permalink to this definition\") **Optional.** If included with `realm-cli login`, stores information about the authenticated session in a file at the specified path. Session information includes your MongoDB Cloud username, [MongoDB Atlas programmatic API Key](https://www.mongodb.com/docs/atlas/configure-api-access/#programmatic-api-keys), and a session refresh token. If included with any other command, authenticates the request with the session saved at the specified path (if it exists) instead of the current CLI authentication state. ## Warning Since the session configuration file contains your MongoDB Atlas programmatic API private key, you should avoid sharing this file unintentionally. `--disable-color`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli.--disable-color \"Permalink to this definition\") **Optional.** If specified, suppress all text color in [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) output. By default, some output such as errors and import diffs are colorized. Use this flag if you wish to prevent this behavior.\n\n **Optional.** If specified, automatically respond affirmatively to any yes/no prompts from[realm-cli.](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) ## Authentication ### Authenticate a CLI User Use `realm-cli login` to authenticate a MongoDB Cloud user with a [MongoDB Atlas programmatic API Key.](https://www.mongodb.com/docs/atlas/configure-api-access/#programmatic-api-keys) ```shell realm-cli login --api-key=\"<my api key>\" --private-api-key=\"<my private api key>\" \n``` `--api-key <api key>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-login.--api-key \"Permalink to this definition\") A valid public MongoDB Atlas [programmatic API key](https://www.mongodb.com/docs/atlas/configure-api-access/#programmatic-api-keys) for the MongoDB Cloud account you wish to log in with. `--private-api-key <private api key>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-login.--private-api-key \"Permalink to this definition\") A valid private MongoDB Atlas [programmatic API key](https://www.mongodb.com/docs/atlas/configure-api-access/#programmatic-api-keys) for the MongoDB Cloud account you wish to log in with. `--username <MongoDB Cloud username>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-login.--username \"Permalink to this definition\") (Deprecated) The username of the MongoDB Cloud account you wish to log in with using [personal API keys.](https://www.mongodb.com/docs/atlas/configure-api-access/#personal-api-keys-deprecated) ### Log Out the Current CLI User Use `realm-cli logout` to log out the currently logged in user. ```shell realm-cli logout \n``` ### View the Currently Logged In User Use `realm-cli whoami` to see details on the user that is currently logged in to the CLI, if applicable. ```shell realm-cli whoami \n``` If there is a currently logged-in user, their information will display on the next line in the following format: ```shell <username> [API Key: ********-****-****-****-<last 12 digits of API key>] \n``` If no user is logged in, [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) will return the following message: ```shell no user info available \n``` ## Apps ### Import an Application Use `realm-cli import` to import a local application directory into a hosted App. If you import a directory into an application that doesn't exist, [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) can [create the application](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) for you. ## Tip You must be a `Project Owner` to import an App. For more info, see: [Atlas User Roles.](https://www.mongodb.com/docs/atlas/reference/user-roles/#project-roles) ```shell realm-cli import \\   --app-id=myapp-abcde \\   --path=./path/to/app/dir \\   --strategy=merge \\   --include-hosting \\   --include-dependencies \n``` `--app-id <App Services Application ID>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-import.--app-id \"Permalink to this definition\") **Optional.** The Application ID of your App.\n\n ## Note ### New Application App IDs If you create a new application with [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli), App Services generates a new App ID and ignores any value that you specify for the `--app-id` flag. `--path <path>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-import.--path \"Permalink to this definition\") **Optional.** The path to the directory containing files you wish to import. The directory must contain, at minimum, a valid [config.json](https://mongodb.com/docs/atlas/app-services/reference/config/legacy/#std-label-legacy-appschema-realm-config) file. If the `path` argument is omitted, [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) will search for a`config.json` file in the current application directory. `--strategy ['merge|replace|replace-by-name']`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-import.--strategy \"Permalink to this definition\") **Optional.** **Default:** Merge The [import strategy](#std-label-realm-import-strategies-v1) that[realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) should use when reconciling imported entities. `--project-id <MongoDB Cloud Project ID>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-import.--project-id \"Permalink to this definition\") **Optional.** The Project ID of the [Atlas project](https://www.mongodb.com/docs/atlas/organizations-projects/#std-label-projects) on which you want to host a newly created App. If specified, [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) will not prompt you to select a project when creating a new app. ## Note [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) ignores the value of `--project-id`unless you are [importing a new application.](https://mongodb.com/docs/atlas/app-services/apps/create/#std-label-create-app) `--include-hosting`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-import.--include-hosting \"Permalink to this definition\") **Optional.** If specified, uploads and deploys any static assets in the`/hosting/files` directory of your App. `--include-dependencies`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-import.--include-dependencies \"Permalink to this definition\") **Optional.** If specified, uploads and deploys any external dependencies included in a `node_modules` archive in the `/functions` directory of your App. ### Export an Application Use `realm-cli export` to save an App configuration to a local application directory. ```shell realm-cli export \\   --app-id=myRealmApp-abcde \\   --output=path/to/exported/app/dir \\   --include-hosting \\   --as-template \n``` `--app-id <App Services Application ID>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-export.--app-id \"Permalink to this definition\") **Optional.** The Application ID of your App. `--output <path>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-export.--output \"Permalink to this definition\") **Optional.** The path of the directory where App Services will export your application.\n\n ## Note If the `output` argument is omitted, [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) will export the application configuration to a new directory within the current working directory. `--include-hosting`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-export.--include-hosting \"Permalink to this definition\") **Optional.** If specified, exports all hosted static assets in the `hosting/files`directory of your App. `--for-source-control`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-export.--for-source-control \"Permalink to this definition\") **Optional.** If enabled, [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) exports the application configuration without any fields that conflict with deployment via GitHub source control, including fields like `name`, `app_id`, `location`, and `deployment_model` in the `config.json` file as well as the `config.clusterName` field in the`config.json` of any Atlas data sources linked to the application. `--as-template`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-export.--as-template \"Permalink to this definition\") **Optional.** If enabled, [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) exports the application configuration without any service ID values, including the App ID. This simplifies the creation of new applications from an exported configuration. ### Diff Pending Application Changes Use `realm-cli diff` to return a diff of the configuration files between the deployed application and your local application directory. ```shell # Diff application config files realm-cli diff # Diff application config files and hosted files realm-cli diff --include-hosting \n``` The diff resembles the following: ```shell --- functions/oldFunctionName/config.json +++ functions/oldFunctionName/config.json @@ -1,6 +1 @@ -{ -    \"id\": \"5d4c6a5cd28e555496a705da\", -    \"name\": \"oldFunctionName\", -    \"private\": false -} --- functions/newFunctionName/config.json +++ functions/newFunctionName/config.json @@ -1 +1,6 @@ +{ +    \"id\": \"5d4c6a5cd28e555496a705da\", +    \"name\": \"newFunctionName\", +    \"private\": false +} Modified Files:         * /index.html         * /auth/confirmEmail.html         * /auth/resetPassword.html \n``` `--include-hosting`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-diff.--include-hosting \"Permalink to this definition\") **Optional.** If specified, the diff includes a list of files in the`hosting/files` directory of your App that are different from your app's deployed files. ## Secrets ### List All Secrets Use `realm-cli secrets list` to return a list that contains the Name and ID of each [Secret](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-secret) in your application. ```shell realm-cli secrets list \n``` The returned list of secrets resembles the following: ```shell ID                       Name 5d5c25415e30c7ef857c6a10 test-secret-please-ignore 5d56dd453b467e2a48a6ec32 some-other-secret \n``` ### Create a Secret Use `realm-cli secrets add` to create a new [Secret](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-secret) with the specified name and value. ```shell\n\n \n``` `--name <Secret Name>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-add.--name \"Permalink to this definition\") A unique name for the new Secret. If an existing Secret already has the specified name then this operation will fail. `--value <Secret Value>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-add.--value \"Permalink to this definition\") The value of the new Secret. ### Update a Secret's Value Use `realm-cli secrets update` to change the value of an existing[Secret](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-secret) in your application. ```shell # Update a Secret by name realm-cli secrets update --secret-name=mySecret --value=NewSecretValue realm-cli secrets update --name=mySecret --value=NewSecretValue # Update a Secret by name realm-cli secrets update --secret-id=5ba9c5c2e707c02b38031412 --value=NewSecretValue realm-cli secrets update --id=5ba9c5c2e707c02b38031412 --value=NewSecretValue \n``` `--secret-name <Secret Name>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-update.--secret-name \"Permalink to this definition\") `--name <Secret Name>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-update.--name \"Permalink to this definition\") The name of the Secret to update. `--secret-id <Secret ID>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-update.--secret-id \"Permalink to this definition\") `--id <Secret ID>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-update.--id \"Permalink to this definition\") The ID value of the Secret to update. `--value <Secret Value>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-update.--value \"Permalink to this definition\") The new value of the Secret. ### Remove a Secret Use `realm-cli secrets remove` to delete an existing [Secret](https://mongodb.com/docs/atlas/app-services/values-and-secrets/#std-label-app-secret) from your application. ```shell # Remove a Secret by name realm-cli secrets remove --secret-name=mySecret realm-cli secrets remove --name=mySecret # Remove a Secret by ID realm-cli secrets remove --secret-id=5ba9c5c2e707c02b38031412 realm-cli secrets remove --id=5ba9c5c2e707c02b38031412 \n``` `--secret-name <Secret Name>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-remove.--secret-name \"Permalink to this definition\") `--name <Secret Name>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-remove.--name \"Permalink to this definition\") The name of the Secret to remove from your App. `--secret-id <Secret ID>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-remove.--secret-id \"Permalink to this definition\") `--id <Secret ID>`[![](https://mongodb.com/docs/atlas/app-services/assets/link.svg)](#std-option-realm-cli-secrets-remove.--id \"Permalink to this definition\") The ID value of the Secret to remove from your App. ## Import Strategies\n\n All imports default to the `merge` strategy unless otherwise specified. ### Merge ```shell realm-cli import --strategy=merge \n``` Under the `merge` strategy, entities in the application directory are added to the application non-destructively. Any existing entities in an application are left unchanged if they are not represented in the imported application directory. If an imported entity's `id` value matches the `id` of an existing entity, the existing entity will be updated to match the imported entity. App Services assigns system-generated `id` values to entities without `id` values before importing them as new entities. If an entity is imported with an `id` that does not match an existing entity, the import will fail. Importing an entity with a non-ObjectID `id` value causes an error. ## Note If an imported entity has an `id` field, the value must be an ObjectID or the merge will fail. ## Example An existing application has three functions: ``` { \"id\": <ObjectID 1>, \"name\": \"FunctionA\", ... } { \"id\": <ObjectID 2>, \"name\": \"FunctionB\", ... } { \"id\": <ObjectID 3>, \"name\": \"FunctionC\", ... } \n``` A local application directory is imported with the `merge`strategy. The directory contains configuration files for the following functions: ``` { \"id\": <ObjectID 1>, \"name\": \"FunctionA_Updated!\", ... } { \"name\": \"FunctionD\", ... } \n``` After importing, the application has the following functions: ``` { \"id\": <ObjectID 1>, \"name\": \"FunctionA_Updated!\" } { \"id\": <ObjectID 2>, \"name\": \"FunctionB\", ... } { \"id\": <ObjectID 3>, \"name\": \"FunctionC\", ... } { \"id\": <ObjectID 4>, \"name\": \"FunctionD\", ... } \n``` `FunctionA` was updated based on its imported configuration file.`FunctionB` and `FunctionC` were not included in the imported application directory, so they remained unchanged after importing with the `merge` strategy. `FunctionD` was imported as a new entity and assigned a system-generated `id` value. ### Replace ```shell realm-cli import --strategy=replace \n``` Under the `replace` strategy, if an imported entity's `id` value matches the `id` of an existing entity, App Services replaces the existing entity with the imported entity. If an imported entity's `id`value does not match an existing entity, the import fails. If an existing entity's `id` does not match the `id` of any imported entity, App Services deletes that existing entity. App Services generates `id` values for entities that lack `id`values before importing them as new entities. Importing an entity with a non-ObjectID `id` value does not throw an error. ## Example An existing application has three functions: ``` { \"id\": <ObjectID 1>, \"name\": \"FunctionA\", ... } { \"id\": <ObjectID 2>, \"name\": \"FunctionB\", ... } { \"id\": <ObjectID 3>, \"name\": \"FunctionC\", ... } \n``` A local application directory is imported with the `replace`strategy. The directory contains configuration files for the following functions: ``` { \"id\": <ObjectID 1>, \"name\": \"FunctionA_Updated!\", ... } { \"name\": \"FunctionD\", ... } { \"id\": \"non-ObjectID-value\", \"name\": \"FunctionE\", ... } \n``` After importing, the application has the following functions: ``` { \"id\": <ObjectID 1>, \"name\": \"FunctionA_Updated!\" } { \"id\": <ObjectID 4>, \"name\": \"FunctionD\", ... } { \"id\": <ObjectID 5>, \"name\": \"FunctionE\", ... } \n``` `FunctionA` was updated based on its imported configuration file.`FunctionB` and `FunctionC` were not included in the imported application directory, so they are not present in the app after importing with the `replace` strategy. `FunctionD` and`FunctionE` were imported as new entities and assigned system-generated `id` values. ### Replace by Name ```shell realm-cli import --strategy=replace-by-name \n```\n\n If an imported entity has no `name` value, [realm-cli](https://mongodb.com/docs/atlas/app-services/cli/#mongodb-binary-bin.realm-cli) will throw an error. ## Example An existing application has three functions: ``` { \"id\": <ObjectID 1>, \"name\": \"FunctionA\", ... } { \"id\": <ObjectID 2>, \"name\": \"FunctionB\", ... } { \"id\": <ObjectID 3>, \"name\": \"FunctionC\", ... } \n``` A local application directory is imported with the `replace`strategy. The directory contains configuration files for the following functions: ``` { \"name\": \"FunctionZ\", ... } { \"name\": \"FunctionB\", ... } { \"name\": \"FunctionC\", ... } \n``` After importing, the application has the following functions: ``` { \"id\": <ObjectID 2>, \"name\": \"FunctionB\", ... } { \"id\": <ObjectID 3>, \"name\": \"FunctionC\", ... } { \"id\": <ObjectID 4>, \"name\": \"FunctionZ\", ... } \n``` Both the existing application and the imported configuration directory contained functions with the names `FunctionB` and `FunctionC`. As a result, both functions retained their previous `id` values and names. The rest of both function's values reflect the values uploaded from the configuration files. `FunctionA` was not included in the imported application directory, so it is not present in the app after importing with the `replace-by-name` strategy. `FunctionZ` was imported as a new entity and assigned a system-generated `id`value. ← [realm-cli whoami](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-whoami/ \"Previous Section\")[Billing](https://mongodb.com/docs/atlas/app-services/billing/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-list/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli accessList list On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) List the allowed entries in the Access List of your App (alias: ls) This will display the IP addresses and/or CIDR blocks in the Access List of your App ## Syntax `| realm-cli accessList list [options] |\n| ----------------------------------- | ` ## Options | Name        | Type   | Required      | Description                                                                          |\n| ----------- | ------ | ------------- | ------------------------------------------------------------------------------------ |\n| \\-a, --app  | string | false         | Specify the name or ID of an App to list its allowed IP addresses and/or CIDR blocks |\n| \\-h, --help | false  | help for list |                                                                                      | ## Inherited Options\n\n ← [realm-cli accessList delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-delete/ \"Previous Section\")[realm-cli accessList update](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-accessList-update/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-pull/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli pull On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Exports the latest version of your App into your local directory (alias: export) Exports the latest version of your App into your local directory Pulls changes from your remote App into your local directory. If applicable, Hosting Files and/or Dependencies associated with your App will be exported as well. ## Syntax `| realm-cli pull [options] |\n| ------------------------ | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli logs list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-logs-list/ \"Previous Section\")[realm-cli push](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-push/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-push/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli push On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Imports and deploys changes from your local directory to your App (alias: import) Updates a remote App with your local directory. First, input an App that you would like changes pushed to. This input can be either the application Client App ID of an existing App you would like to update, or the Name of a new App you would like to create. Changes pushed are automatically deployed. ## Syntax `| realm-cli push [options] |\n| ------------------------ | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli pull](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-pull/ \"Previous Section\")[realm-cli schema](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-schema/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-users-disable/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli users disable On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Disable an application user of your App Deactivates a user on your App. A user that has been disabled will not be allowed to log in, even if they provide valid credentials. ## Syntax `| realm-cli users disable [options] |\n| --------------------------------- | ` ## Options | Name        | Type    | Required         | Description                                           |\n| ----------- | ------- | ---------------- | ----------------------------------------------------- |\n| \\-a, --app  | string  | false            | Specify the name or ID of an App to disable its users |\n| \\-u, --user | strings | false            | Specify the App's users' ID(s) to disable             |\n| \\-h, --help | false   | help for disable |                                                       | ## Inherited Options\n\n ← [realm-cli users delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-delete/ \"Previous Section\")[realm-cli users enable](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-enable/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-users-enable/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli users enable On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Enable an application user of your App Activates a user on your App. A user that has been enabled will have no restrictions with logging in. ## Syntax `| realm-cli users enable [options] |\n| -------------------------------- | ` ## Options | Name        | Type    | Required        | Description                                          |\n| ----------- | ------- | --------------- | ---------------------------------------------------- |\n| \\-a, --app  | string  | false           | Specify the name or ID of an App to enable its users |\n| \\-u, --user | strings | false           | Specify the App's users' ID(s) to enable             |\n| \\-h, --help | false   | help for enable |                                                      | ## Inherited Options\n\n ← [realm-cli users disable](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-disable/ \"Previous Section\")[realm-cli users list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-list/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-users-list/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli users list On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) List the application users of your App (alias: ls) Displays a list of your App's users' details. The list is grouped by Auth Provider type and sorted by Last Authentication Date. ## Syntax `| realm-cli users list [options] |\n| ------------------------------ | ` ## Options\n\n ## Inherited Options\n\n ← [realm-cli users enable](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-enable/ \"Previous Section\")[realm-cli users revoke](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-revoke/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-whoami/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli whoami On this page * [Syntax](#syntax)\n* [Options](#options)\n* [Inherited Options](#inherited-options) Display information about the current user Displays a table that includes your Public and redacted Private Atlas programmatic API Key (e.g. ........-....-....-....-3ba985aa367a). No session data will be surfaced if you are not logged in. NOTE: To log in and authenticate your session, use \"realm-cli login\" ## Syntax `| realm-cli whoami [options] |\n| -------------------------- | ` ## Options | Name        | Type  | Required        | Description |\n| ----------- | ----- | --------------- | ----------- |\n| \\-h, --help | false | help for whoami |             | ## Inherited Options\n\n ← [realm-cli users revoke](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-revoke/ \"Previous Section\")[Realm CLI v1](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-reference-v1/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/cli/realm-cli-users/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # realm-cli users On this page * [Options](#options)\n* [Inherited Options](#inherited-options)\n* [Related Commands](#related-commands) Manage the users of your App (alias: user) ## Options | Name        | Type  | Required       | Description |\n| ----------- | ----- | -------------- | ----------- |\n| \\-h, --help | false | help for users |             | ## Inherited Options\n\n ## Related Commands * [realm-cli users create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-create/#std-label-realm-cli-users-create) \\- Create an application user for your App\n* [realm-cli users delete](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-delete/#std-label-realm-cli-users-delete) \\- Delete an application user from your App\n* [realm-cli users disable](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-disable/#std-label-realm-cli-users-disable) \\- Disable an application user of your App\n* [realm-cli users enable](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-enable/#std-label-realm-cli-users-enable) \\- Enable an application user of your App\n* [realm-cli users list](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-list/#std-label-realm-cli-users-list) \\- List the application users of your App (alias: ls)\n* [realm-cli users revoke](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-revoke/#std-label-realm-cli-users-revoke) \\- Revoke an application user's sessions from your App ← [realm-cli secrets update](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-secrets-update/ \"Previous Section\")[realm-cli users create](https://mongodb.com/docs/atlas/app-services/cli/realm-cli-users-create/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/data-api/examples/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Data API Examples On this page * [Specify BSON Types in Requests](#specify-bson-types-in-requests)\n* [Binary](#binary)\n* [Date](#date)\n* [Decimal128](#decimal128)\n* [Double](#double)\n* [Int32](#int32)\n* [Int64](#int64)\n* [ObjectId](#objectid)\n* [Query Examples](#query-examples)\n* [Find All Documents](#find-all-documents)\n* [Find Document by ID](#find-document-by-id)\n* [Find By Date](#find-by-date)\n* [Data Access Permissions](#data-access-permissions)\n* [Define Permissions for Specific API Keys](#define-permissions-for-specific-api-keys)\n* [Define Permissions for a Specific Collection](#define-permissions-for-a-specific-collection) The following examples demonstrate how to send requests to the Atlas Data API. ## Specify BSON Types in Requests Data API requests can specify BSON types that don't exist in JSON by instead using the EJSON [data format](https://mongodb.com/docs/atlas/app-services/data-api/data-formats/#std-label-data-api-data-formats) in the request body. You can use EJSON to match BSON types in query filters or write BSON types in insert and update operations. To specify that a request body uses EJSON, set the `Content-Type` header: `| Content-Type: application/ejson |\n| ------------------------------- | ` ### Binary To specify a binary value, use `$binary` with the value encoded in Base64 and a [BSON subtype](https://bsonspec.org/spec.html) encoded as a two-character hexadecimal string: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertOne' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"document\": {         \"data\": {           \"$binary\": {             \"base64\": \"46d989eaf0bde5258029534bc2dc2089\",             \"subType\": \"05\"           }         }       }   }' \n``` ### Date To specify a date, use `$date` with the [UNIX timestamp in milliseconds](https://currentmillis.com/) as a 64-bit integer: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertOne' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"document\": {         \"createdAt\": { \"$date\": { \"$numberLong\": \"1638551310749\" } }       }   }' \n``` ### Decimal128 To specify a 128-bit decimal, use `$numberDecimal` with the decimal value as a string: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertOne' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\\n\n       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"document\": {         \"accountBalance\": { \"$numberDecimal\": \"128452.420523\" }       }   }' \n``` ### Double To specify a 64-bit signed floating point value (commonly referred to as a \"double\"), use `$numberDouble` with the integer value as a string: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertOne' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"document\": {         \"temperatureCelsius\": { \"$numberDouble\": \"23.847\" }       }   }' \n``` ### Int32 To specify a 32-bit signed integer value, use `$numberInt` with the integer value as a string: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertOne' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"document\": {         \"coins\": { \"$numberInt\": \"2147483647\" }       }   }' \n``` ### Int64 To specify a 64-bit signed integer value, use `$numberLong` with the integer value as a string: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertOne' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"document\": {         \"population\": { \"$numberLong\": \"8047923148\" }       }   }' \n``` ### ObjectId To specify an ObjectId value, use `$oid` with the ID as a byte string: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertOne' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"document\": {         \"_id\": { \"$oid\": \"61f02ea3af3561e283d06b91\" }       }   }' \n``` ## Query Examples The code snippets in this section demonstrate common patterns you can use in your read and write operations. ### Find All Documents To match all documents in a collection, use an empty query object: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/find' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",\n\n       \"collection\": \"<collection name>\",       \"filter\": {}   }' \n``` ### Find Document by ID MongoDB stores each document with a unique identifier in the `_id`field. For most apps, this is a BSON ObjectID value. You can match any ObjectID field, including a document using an EJSON `$oid` object: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/find' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"filter\": {         \"_id\": { \"$oid\": \"630e51b3f4cd7d9e606caab6\" }       }   }' \n``` ### Find By Date You can match documents on a specific date by matching an EJSON`$date` object with a field that contains a date value: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/find' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"filter\": {         \"createdAt\": { \"$date\": { \"$numberLong\": \"1661881925033\" } }       }   }' \n``` You can query a range of dates with `$gt`, `$gte`, `$lt`, and`$lte`: ```bash curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/find' \\   --header 'Content-Type: application/ejson' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"<cluster name>\",       \"database\": \"<database name>\",       \"collection\": \"<collection name>\",       \"filter\": {         \"createdAt\": {           \"$gte\": { \"$date\": { \"$numberLong\": \"1640995200000\" } },           \"$lt\": { \"$date\": { \"$numberLong\": \"1672531200000\" } }         }       }   }' \n``` ## Data Access Permissions You can secure Data API requests using your app's built-in role-based permissions. The examples in this section demonstrate how to set up common permissions schemes. You can mix and match these and more complex schemes to meet your API's needs. For more examples and information on how permissions work, see [Role-based Permissions.](https://mongodb.com/docs/atlas/app-services/rules/roles/#std-label-permissions) ### Define Permissions for Specific API Keys You can define multiple roles with different data access permissions and assign specific API keys to each role. For example, you can create a`read-only` role that allows users to read all data but not insert, delete, or modify data. You map each role to an API key in the role's `apply_when` expression. Each API key corresponds to a separate user account with a unique account ID. You can access the account ID and other data of the user making a request with the [%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user) expansion. To associate a role with a single API key, set the `apply_when`expression to match the API key's account ID: apply\\_when - One user per role ``` {   \"database\": \"<database>\",   \"collection\": \"<collection>\",   \"roles\": [\n\n        \"name\": \"SpecificUser\",        \"apply_when\": {          \"%%user.id\": \"61f9a5e69cd3c0199dc1bb88\"        },        \"insert\": true,        \"delete\": true,        \"read\": true,        \"write\": true     }   ],   \"filters\": [] } \n``` To associate a role with multiple API keys, set the `apply_when`expression to match an array of API key account IDs: apply\\_when - Multiple users per role ``` {   \"database\": \"<database>\",   \"collection\": \"<collection>\",   \"roles\": [     {        \"name\": \"MultipleUsers\",        \"apply_when\": {          \"%%user.id\": {             \"$in\": [               \"61f9a5e69cd3c0199dc1bb88\",               \"61f9a5e69cd3c0199dc1bb89\"             ]          }        },        \"insert\": true,        \"delete\": true,        \"read\": true,        \"write\": true     }   ],   \"filters\": [] } \n``` You can also use a custom system to determine if a user has a role. For example, you can write a function that looks up a user's roles from an Atlas cluster. functions/hasRole.js ```javascript exports = async function hasRole({   userId, // The user account ID, e.g. \"60d0c1bdee9d3c23b677f929\"   roleName, // The name of a role the user might have, e.g. \"admin\" }) {   // 1. Get a reference to a custom user data collection   const users = context.services.get(\"mongodb-atlas\").db(\"app\").collection(\"users\")   // 2. Query the user's document and make sure it exists   const user = await users.findOne({ userId })   if(!user) {     console.error(`User.id ${userId} not found in custom user data collection`)     return false   }   // 3. Decide if the user has the role we're checking   return user.roles.includes(roleName) }; \n``` And then call that function from the role's `apply_when` expression with the [%function](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-operator--function) operator: apply\\_when - Custom function ``` {   \"database\": \"<database>\",   \"collection\": \"<collection>\",   \"roles\": [     {        \"name\": \"SomeCustomRole\",        \"apply_when\": {          \"%%true\": {            \"%function\": {              \"name\": \"hasRole\",              \"arguments\": [{                \"userId\": \"%%user.id\",                \"roleName\": \"SomeCustomRole\"              }]            }          }        },        \"insert\": true,        \"delete\": true,        \"read\": true,        \"write\": true     }   ],   \"filters\": [] } \n``` This example uses a custom user data collection, but you can use any external service to determine if a user has a role. The function code and arguments you pass are up to you.\n\n You can define roles that control data access permissions for a specific collection in your cluster. For example, you can create a `read-only`role that allows users to read all data in a collection but not insert, delete, or modify any data. To define roles for a specific collection, update the collection's configuration file with the [collection-specific role configurations:](https://mongodb.com/docs/atlas/app-services/reference/config/data%5Fsources/#std-label-role-config) /data\\_sources/<data source>/<database>/<collection>/rules.json ``` {   \"database\": \"<database>\",   \"collection\": \"<collection>\",   \"roles\": [     {        \"name\": \"IsOwner\",        \"apply_when\": { \"owner_id\": \"%%user.id\" },        \"insert\": false,        \"delete\": false,        \"read\": true,        \"write\": true     }   ],   \"filters\": [] } \n``` If no collection roles match, then the request is also evaluated against the data source's default roles. If you don't want to apply default roles, remove any roles and filters from the default rule configuration file. /data\\_sources/<data source>/default\\_rule.json ``` {   \"roles\": [],   \"filters\": [] } \n``` ← [Authenticate Data API Requests](https://mongodb.com/docs/atlas/app-services/data-api/authenticate/ \"Previous Section\")[Data Formats](https://mongodb.com/docs/atlas/app-services/data-api/data-formats/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/data-api/data-formats/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Data Formats On this page * [BSON Types](#bson-types)\n* [Array](#array)\n* [Binary](#binary)\n* [Date](#date)\n* [Decimal128](#decimal128)\n* [Document](#document)\n* [Double](#double)\n* [Int32](#int32)\n* [Int64](#int64)\n* [MaxKey](#maxkey)\n* [MinKey](#minkey)\n* [ObjectId](#objectid)\n* [Regular Expression](#regular-expression)\n* [Timestamp](#timestamp) MongoDB stores data in a format called [BSON](https://bsonspec.org/), which is similar to a JSON object in structure but supports additional data types and uses a binary encoding. BSON is efficient for computers but is not human readable, so you can't work with it directly. Instead, the Data API uses two formats to represent data in requests and responses: * The **JSON** format uses standard types that any tool can parse and understand. However, JSON cannot represent all BSON types so JSON responses may lose type information for some fields. For example, BSON has distinct types for 32-bit integers and 64-bit floats but a JSON response represents both as a `number`.\n* The **EJSON** format, short for [MongoDB Extended JSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/), is a superset of standard JSON that uses structured fields to represent BSON data that don't have corresponding JSON types. This fully represents your data but requires your client to understand how to work with EJSON. ## Example This document can be represented in either JSON or EJSON shows BSON types represented in JSON and EJSON: You define a single default return type for all generated Data API endpoints and individually for each custom endpoint. Incoming requests can also specify a preferred data format that overrides the default using an `Accept` header. ## BSON Types This sections lists the BSON types that the Data API supports and shows how each type is represented in JSON and EJSON format. ### Array | EJSON            | JSON             |\n| ---------------- | ---------------- |\n| \\[ <elements> \\] | \\[ <elements> \\] | ### Binary | EJSON                                                                                         | JSON                                                            |\n| --------------------------------------------------------------------------------------------- | --------------------------------------------------------------- |\n| {   \"$binary\": {      \"base64\": \"e67803a39588be8a95731a21e27d7391\",      \"subType\": \"05\"   }} | {   \"Subtype\": 5,   \"Data\": \"e67803a39588be8a95731a21e27d7391\"} | ### Date | EJSON                                                   | JSON                       |\n| ------------------------------------------------------- | -------------------------- |\n| {   \"$date\": {      \"$numberLong\": \"1641954803067\"   }} | \"2022-01-12T02:33:23.067Z\" | ### Decimal128\n\n ### Document | EJSON         | JSON          |\n| ------------- | ------------- |\n| { <content> } | { <content> } | ### Double | EJSON                        | JSON |\n| ---------------------------- | ---- |\n| {   \"$numberDouble\": \"10.5\"} | 10.5 | ### Int32 | EJSON               | JSON |\n| ------------------- | ---- |\n| {\"$numberInt\":\"10\"} | 10   | ### Int64 | EJSON                | JSON |\n| -------------------- | ---- |\n| {\"$numberLong\":\"50\"} | 50   | ### MaxKey | EJSON            | JSON                   |\n| ---------------- | ---------------------- |\n| { \"$maxKey\": 1 } | {}_No JSON equivalent_ | ### MinKey | EJSON            | JSON                   |\n| ---------------- | ---------------------- |\n| { \"$minKey\": 1 } | {}_No JSON equivalent_ | ### ObjectId | EJSON                                  | JSON                       |\n| -------------------------------------- | -------------------------- |\n| {   \"$oid\":\"5d505646cf6d4fe581014ab2\"} | \"5d505646cf6d4fe581014ab2\" | ### Regular Expression | EJSON                                                                    | JSON                                   |\n| ------------------------------------------------------------------------ | -------------------------------------- |\n| {   \"$regularExpression\": {      \"pattern\":\"^H\",      \"options\":\"i\"   }} | {   \"Pattern\": \"^H\",   \"Options\": \"i\"} | ### Timestamp | EJSON                                                     | JSON                           |\n| --------------------------------------------------------- | ------------------------------ |\n| {   \"$timestamp\": {      \"t\":1565545664,      \"i\":1    }} | {   \"T\": 1565545664,   \"I\": 1} | ← [Data API Examples](https://mongodb.com/docs/atlas/app-services/data-api/examples/ \"Previous Section\")[Atlas Functions](https://mongodb.com/docs/atlas/app-services/functions/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Custom HTTPS Endpoints On this page * [Structure of an Endpoint](#structure-of-an-endpoint)\n* [Base URL](#base-url)\n* [Endpoint Routes](#endpoint-routes)\n* [HTTP Methods](#http-methods)\n* [Create a Custom HTTPS Endpoint](#create-a-custom-https-endpoint)\n* [Authentication](#authentication)\n* [Authorization](#authorization)\n* [Write an Endpoint Function](#write-an-endpoint-function)\n* [Access Request Data](#access-request-data)\n* [Return an HTTPS Response](#return-an-https-response)\n* [Example](#example)\n* [Call a Custom Endpoint](#call-a-custom-endpoint)\n* [Choose a Response Data Format](#choose-a-response-data-format)\n* [Authenticate the Request](#authenticate-the-request)\n* [Authorize the Request](#authorize-the-request) You can define custom HTTPS endpoints to create app-specific API routes or webhooks that integrate with external services. A custom endpoint uses a serverless function that you write to handle incoming requests for a specific URL and HTTP method. Endpoints use standard, encrypted HTTPS requests, which means that you don't need to install any database drivers or opinionated libraries to call them. Instead, you send requests like this from any HTTP client: `| curl -X POST \\                                              |\n| ----------------------------------------------------------- |\n| -H 'apiKey: <API Key>' \\                                    |\n| -H 'Content-Type: application/json' \\                       |\n| -H 'Accept: application/json' \\                             |\n| -d '{ \"message\": \"Hello, world!\" }' \\                       |\n| https://data.mongodb-api.com/app/myapp-abcde/endpoint/hello | ` ## Structure of an Endpoint An endpoint handles one or more HTTP methods sent to a specific URL. ### Base URL Endpoints in an app share a base URL. The URL uses your App ID to uniquely point to your app. Globally deployed apps use the following format: Endpoint Base URL (Global Apps): ``` https://data.mongodb-api.com/app/<App ID>/endpoint \n``` Endpoints in a locally deployed app use a base URL specific to the app's[deployment region](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-regions) (e.g. `us-east-1`) Endpoint Base URL (Local Apps) ``` https://<Region>.aws.data.mongodb-api.com/app/<App ID>/endpoint \n``` ### Endpoint Routes Every HTTPS endpoint has a route that serves as a name for the endpoint. An endpoint's route is arbitrary and specific to your app. However, it appears in the endpoint URL path and so should represent the action the route performs. Route names must begin with a forward slash (`/`) and may contain additional forward slashes to indicate a nested path. An endpoint route ``` /my/nested/route \n``` You call an endpoint by appending its route to your app's base URL and sending an HTTP request. An endpoint URL ``` https://data.mongodb-api.com/app/<App ID>/endpoint/my/nested/route \n``` ### HTTP Methods\n\n You can define multiple custom endpoints that serve the same route but handle different request methods. Alternatively, you can define a single endpoint for the route that handles all methods. Custom endpoints support the following standard HTTP methods: * [GET](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET)\n* [POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST)\n* [PUT](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT)\n* [PATCH](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH)\n* [DELETE](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE) ## Create a Custom HTTPS Endpoint You can configure the Data API for your app from the App Services UI or by deploying configuration files with Realm CLI: ### Authentication Custom endpoints run in the context of a specific user, which allows your app to enforce rules and validate document schemas for each request. By default, endpoints use Application Authentication, which requires each request to include credentials for one of your application users, like an API key or JWT. You can also configure other custom authentication schemes to fit your application's needs. For examples of how to authenticate requests, see [Authenticate Data API Requests.](https://mongodb.com/docs/atlas/app-services/data-api/authenticate/#std-label-data-api-authenticate-requests) ## Tip New endpoints that you create in the UI use System authentication by default. ### Authorization An endpoint can require authenticated users to provide additional authorization information in the request. You define the authorization scheme for each custom endpoint by configuring the endpoint function. Endpoints natively support a set of built-in authorization schemes that use a secret string to prove that the request is authorized. You can also define a custom authorization scheme that you can use together with or instead of the built-in schemes. To learn how to configure authorization for a specific function, see[Define a Function.](https://mongodb.com/docs/atlas/app-services/functions/#std-label-define-a-function) #### Built-In Authorization Schemes Endpoints support the following built-in authorization schemes: #### Custom Authorization Schemes You can define a custom authorization [expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) to determine if an incoming authenticated request is allowed to run. The expression is evaluated for each request and must evaluate to `true`to allow the request. If the expression evaluates to `false`, the request is not authorized and fails with an error. Requests that fail authorization are not counted toward your App's billed usage. Authorization expressions can use variables like[%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user) to authorize based on the calling user's data or [%%request](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---request) to make decisions based on the specifics of each incoming request. To define a custom authorization scheme, specify the expression in the endpoint function's configuration: http\\_endpoints/config.json ``` [   {      ...,      \"can_evaluate\": {        \"%%request.headers.x-secret-key\": \"my-secret\"      }   } ] \n``` ## Write an Endpoint Function Every custom endpoint is associated with a [function](https://mongodb.com/docs/atlas/app-services/functions/#std-label-functions)that runs whenever the endpoint receives an incoming request. In the function, you can import libraries from npm, connect to a linked MongoDB Atlas cluster, and call other serverless functions. To define a new function when [creating an endpoint](#std-label-create-custom-endpoint) in the App Services UI, navigate to the Function section and select\\+ New Function from the dropdown. Depending on your workflow, you can also define and edit endpoint handler functions:\n\n Endpoint functions always receive two arguments: * A [Request](#std-label-endpoint-request-object) object that lets you access incoming request headers, query parameters, and body data.\n* A [Response](#std-label-endpoint-response-object) object that you use to configure the HTTPS response sent back to the caller. For a sample function and an example request and response, see[Example.](#std-label-endpoint-function-example) ### Access Request Data A custom endpoint `Request` object represents the HTTP request that called the endpoint. You can access the incoming request's headers, query parameters, and body data. Endpoint Request Object ``` {   \"headers\": { \"<Header>\": [\"<Header Value>\"] },   \"query\": { \"<Query Parameter>\": \"<Parameter Value>\" },   \"body\": <BSON.Binary> } \n```\n\n ### Return an HTTPS Response A custom endpoint `Response` object lets you configure the HTTPS response sent back to the caller. You can set the status code, customize headers, and include data in the response body.\n\n ### Example Consider an endpoint function that parses the body of an incoming `POST`request, stores the parsed body in a MongoDB collection, and then responds to the caller: ```javascript exports = async function (request, response) {    try {       // 1. Parse data from the incoming request       if(request.body === undefined) {       throw new Error(`Request body was not defined.`)       }       const body = JSON.parse(request.body.text());       // 2. Handle the request       const { insertedId } = await context.services       .get(\"mongodb-atlas\")       .db(\"myDb\")       .collection(\"myCollection\")       .insertOne({ date: new Date(), requestBody: body });       // 3. Configure the response       response.setStatusCode(201);       // tip: You can also use EJSON.stringify instead of JSON.stringify.       response.setBody(JSON.stringify({          message: \"Successfully saved the request body\",          insertedId,       }));    } catch (error) {       response.setStatusCode(400);       response.setBody(error.message);    } } \n``` The function receives the following `POST` request: ```bash curl -X POST \\    -H 'apiKey: abcde12345' \\    -H 'Content-Type: application/json' \\    -H 'Accept: application/json' \\    -d '{ \"foo\": \"bar\" }' \\    https://data.mongodb-api.com/app/myapp-abcde/endpoint/custom \n``` HIDE OUTPUT `| {                                                 |\n| ------------------------------------------------- |\n| \"message\": \"Successfully saved the request body\", |\n| \"insertedId\": \"639a521bbdec9b85ba94014b\"          |\n| }                                                 | ` After the function verifies that the body of the incoming request is defined, it stores the parsed body as a new document in a collection named `myCollection`. The resulting output displays the configured response, which includes a custom message and the `insertedId`. ## Call a Custom Endpoint You can call a custom endpoint from any standard HTTPS client. ```bash curl -X GET \\   -H 'apiKey: <API Key>' \\   -H 'Content-Type: application/ejson' \\   -H 'Accept: application/json' \\   --data-raw '{     \"name\": \"Leafie\",     \"date\": { \"$date\": { \"$numberLong\": \"1638551310749\" } }   }'   https://data.mongodb-api.com/app/myapp-abcde/endpoint/hello \n``` ### Choose a Response Data Format A request can include an `Accept` header to request a specific data format for the response body, either JSON or EJSON. If a request does not include a valid `Accept` header, the response uses the default data format specified in the endpoint configuration. ### Authenticate the Request If an endpoint is configured to use Application Authentication then you must include a valid user access token or login credentials with every request. In general, bearer authentication with an access token has higher throughput and is more secure than credential headers. Use an access token instead of credential headers when possible. The token lets you run multiple requests without re-authenticating the user. It also lets you send requests from a web browser that enforces [CORS.](https://en.wikipedia.org/wiki/Cross-origin%5Fresource%5Fsharing)\n\n ```shell curl -X GET \\    -H 'Authorization: Bearer <AccessToken>' \\    -H 'Content-Type: application/json' \\    https://data.mongodb-api.com/app/myapp-abcde/endpoint/hello \n``` Alternatively, you can include valid login credentials for the user in the request headers. ## Important ### Don't Use API Keys in User-Facing Clients If you're authenticating from a browser or another user-facing client application, avoid using an API key to log in. Instead, use another authentication provider that takes user-provided credentials. Never store API keys or other sensitive credentials locally. ### Authorize the Request Depending on the [endpoint configuration](#std-label-endpoint-authorization), your requests may need to include additional authorization information. ← [Data API Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/generated-endpoints/ \"Previous Section\")[Authenticate Data API Requests](https://mongodb.com/docs/atlas/app-services/data-api/authenticate/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/data-api/authenticate/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Authenticate Data API Requests On this page * [Overview](#overview)\n* [Bearer Authentication](#bearer-authentication)\n* [Credential Headers](#credential-headers)\n* [Email/Password](#email-password)\n* [API Key](#api-key)\n* [Custom JWT](#custom-jwt) ## Overview Data API endpoints generally require that incoming requests include authentication information for the user calling the endpoint. This lets the endpoint enforce rules and validate document schemas for each request. Requests must include authentication data in specific request headers. App Services uses the following process to authenticate a given request: 1. Check for an `Authorization` header. If it's present, try to use[Bearer Authentication](#std-label-data-api-bearer-authentication). The header must contain a valid user access token. If the token is invalid, the request fails.\n2. If the `Authorization` header is not present or does not use the \"Bearer\" scheme, check for [Credential Headers](#std-label-data-api-credential-headers). The headers must contain valid Email/Password, API Key, or Custom JWT credentials for an App user. ## Note You must [enable an authentication provider](https://mongodb.com/docs/atlas/app-services/authentication/#std-label-authentication-providers) before users can authenticate with it. ## Bearer Authentication The Data API supports Bearer Authentication, which lets you authenticate a request by including a valid user access token in the request's`Authorization` header. To learn how to get and manage an access token, see [Manage User Sessions.](https://mongodb.com/docs/atlas/app-services/users/sessions/#std-label-manage-user-sessions) The Authorization header uses the following format: `| Authorization: Bearer <AccessToken> |\n| ----------------------------------- | ` For example, the following request uses Bearer Authentication: ```shell curl -X POST 'https://data.mongodb-api.com/app/<AppID>/endpoint/data/v1/action/find' \\    --header 'Authorization: Bearer <AccessToken>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"dataSource\": \"mongodb-atlas\",      \"database\": \"sample_mflix\",      \"collection\": \"movies\",      \"filter\": {        \"title\": \"The Matrix\"      }    }' \n``` In general, bearer authentication with an access token has higher throughput and is more secure than credential headers. Use an access token instead of credential headers when possible. The token lets you run multiple requests without re-authenticating the user. It also lets you send requests from a web browser that enforces [CORS.](https://en.wikipedia.org/wiki/Cross-origin%5Fresource%5Fsharing) ## Important ### Don't Use API Keys in User-Facing Clients If you're authenticating from a browser or another user-facing client application, avoid using an API key to log in. Instead, use another authentication provider that takes user-provided credentials. Never store API keys or other sensitive credentials locally. Bearer authentication is useful for: * sending requests from a web browser.\n* sending multiple requests without storing user credentials or prompting the user on each request.\n* sending requests from an app that also uses a [Realm SDK](https://www.mongodb.com/docs/realm/sdk/#std-label-realm-sdks) to authenticate users. ## Credential Headers You can authenticate a Data API request by including the user's login credentials in the request headers. The exact headers to include depend on the authentication provider. Credential headers are useful for: * requests sent from a server-side application\n* requests sent from a command-line tool\n* manual or test requests sent from an HTTPS client like Postman ## Important\n\n ### Email/Password To authenticate a Data API request as an [email/password](https://mongodb.com/docs/atlas/app-services/authentication/email-password/#std-label-email-password-authentication) user, include the user's credentials in the request's `email` and `password` headers. ```shell curl -X POST 'https://data.mongodb-api.com/app/<AppID>/endpoint/data/v1/action/find' \\    --header 'email: <EmailAddress>' \\    --header 'password: <Password>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"dataSource\": \"mongodb-atlas\",      \"database\": \"sample_mflix\",      \"collection\": \"movies\",      \"filter\": {        \"title\": \"The Matrix\"      }    }' \n``` ### API Key To authenticate a Data API request with an [API Key](https://mongodb.com/docs/atlas/app-services/authentication/api-key/#std-label-api-key-authentication), include the API key in the request's`apiKey` header. ```shell curl -X POST 'https://data.mongodb-api.com/app/<AppID>/endpoint/data/v1/action/find' \\    --header 'apiKey: <APIKey>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"dataSource\": \"mongodb-atlas\",      \"database\": \"sample_mflix\",      \"collection\": \"movies\",      \"filter\": {        \"title\": \"The Matrix\"      }    }' \n``` ## Important ### Don't Use API Keys in User-Facing Clients If you're authenticating from a browser or another user-facing client application, avoid using an API key to log in. Instead, use another authentication provider that takes user-provided credentials. Never store API keys or other sensitive credentials locally. ### Custom JWT To authenticate a Data API request as a [Custom JWT](https://mongodb.com/docs/atlas/app-services/authentication/custom-jwt/#std-label-custom-jwt-authentication) user, include the JWT string in the request's `jwtTokenString` header. ```shell curl -X POST 'https://data.mongodb-api.com/app/<AppID>/endpoint/data/v1/action/find' \\    --header 'jwtTokenString: <JWT>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"dataSource\": \"mongodb-atlas\",      \"database\": \"sample_mflix\",      \"collection\": \"movies\",      \"filter\": {        \"title\": \"The Matrix\"      }    }' \n``` ← [Custom HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/ \"Previous Section\")[Data API Examples](https://mongodb.com/docs/atlas/app-services/data-api/examples/ \"Next Section\") →",
  "https://www.mongodb.com/docs/atlas/app-services/data-api/generated-endpoints/": " [Docs Home](https://www.mongodb.com/docs/) → [Atlas App Services](https://mongodb.com/docs/atlas/app-services/) # Data API Endpoints On this page * [When to Use the Data API](#when-to-use-the-data-api)\n* [Base URL](#base-url)\n* [Set Up the Data API](#set-up-the-data-api)\n* [Authentication](#authentication)\n* [Authorization](#authorization)\n* [Response Type](#response-type)\n* [Access Permissions](#access-permissions)\n* [API Versions](#api-versions)\n* [Call a Data API Endpoint](#call-a-data-api-endpoint)\n* [Choose an API Version](#choose-an-api-version)\n* [Specify the Request Data Format](#specify-the-request-data-format)\n* [Choose a Response Data Format](#choose-a-response-data-format)\n* [Authenticate the Request](#authenticate-the-request)\n* [Authorize the Request](#authorize-the-request)\n* [Endpoints](#endpoints)\n* [Find a Single Document](#find-a-single-document)\n* [Find Multiple Documents](#find-multiple-documents)\n* [Insert a Single Document](#insert-a-single-document)\n* [Insert Multiple Documents](#insert-multiple-documents)\n* [Update a Single Document](#update-a-single-document)\n* [Update Multiple Documents](#update-multiple-documents)\n* [Replace a Single Document](#replace-a-single-document)\n* [Delete a Single Document](#delete-a-single-document)\n* [Delete Multiple Documents](#delete-multiple-documents)\n* [Run an Aggregation Pipeline](#run-an-aggregation-pipeline)\n* [Error Codes](#error-codes) The Data API lets you securely read and write data using standard HTTPS requests. The API includes automatically generated endpoints that each represent a MongoDB operation. You can use the endpoints to create, read, update, delete, and aggregate documents in a MongoDB data source. For example, this [POST](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) request stores a document in a linked cluster by calling the `insertOne` endpoint:\n\n ` HIDE OUTPUT `| { \"insertedId\": \"5f1a785e1536b6e6992fd588\" } |\n| -------------------------------------------- | ` ## When to Use the Data API You can use the Data API to integrate with any app or service that supports HTTPS requests. For example, you might: * call the API from a serverless edge function\n* query Atlas from a mobile application\n* access test data and log events in a CI/CD workflow\n* integrate Atlas into a federated API gateway\n* connect from an environment not currently supported via a MongoDB Driver or Realm SDK An operation called through an API endpoint will likely take longer than the corresponding MongoDB operation called through a connected MongoDB Driver. For high-load use-cases and latency sensitive applications, we recommend connecting directly to your database with a MongoDB driver. To learn more, visit the [MongoDB Drivers](https://www.mongodb.com/docs/drivers/) documentation. ## Base URL The Data API endpoints in an app share a base URL. The URL uses your App ID to uniquely point to your app and specifies which version of the Data API to call. Each endpoint has a unique URL formed by appending the endpoint's route to your app's base URL. Globally deployed apps use the following format: Endpoint Base URL (Global Apps): ``` https://data.mongodb-api.com/app/<App ID>/endpoint/data/<API Version> \n``` Endpoints in a locally deployed app use a base URL specific to the app's[deployment region](https://mongodb.com/docs/atlas/app-services/apps/deployment-models-and-regions/#std-label-deployment-regions) (e.g. `us-east-1.aws`): Endpoint Base URL (Local Apps) ``` https://<Region>.<Cloud>.data.mongodb-api.com/app/<App ID>/endpoint/data/<API Version> \n``` ## Set Up the Data API You can configure the Data API for your app from the App Services UI or by deploying configuration files with Realm CLI: ### Authentication Data API endpoints run in the context of a specific user, which allows your app to enforce rules and validate document schemas for each request. By default, endpoints use Application Authentication, which requires each request to include credentials for one of your application users, like an API key or JWT. You can also configure other custom authentication schemes to fit your application's needs. For examples of how to authenticate requests, see [Authenticate Data API Requests.](https://mongodb.com/docs/atlas/app-services/data-api/authenticate/#std-label-data-api-authenticate-requests) ### Authorization You can require authenticated users to provide additional authorization information in each request. You define the authorization scheme for all generated Data API endpoints in your Data API configuration. Endpoints natively support a set of built-in authorization schemes that use a secret string to prove that the request is authorized. You can also define a custom authorization scheme that you can use together with or instead of the built-in schemes. #### Built-In Authorization Schemes Endpoints support the following built-in authorization schemes: #### Custom Authorization Schemes You can define a custom authorization [expression](https://mongodb.com/docs/atlas/app-services/rules/expressions/#std-label-expressions) to determine if an incoming authenticated request is allowed to run. The expression is evaluated for each request and must evaluate to `true`to allow the request. If the expression evaluates to `false`, the request is not authorized and fails with an error. Requests that fail authorization are not counted toward your App's billed usage. Authorization expressions can use variables like[%%user](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---user) to authorize based on the calling user's data or [%%request](https://mongodb.com/docs/atlas/app-services/rules/expressions/#mongodb-json-expansion---request) to make decisions based on the specifics of each incoming request. To define a custom authorization scheme, specify the expression in your app's Data API configuration: http\\_endpoints/data\\_api\\_config.json ``` {   ...,   \"can_evaluate\": {     \"%%request.headers.x-secret-key\": \"my-secret\"   } } \n``` ### Response Type\n\n By default, endpoints return JSON, which is a standard data format that is widely supported modern langauges and platforms. However, JSON cannot represent every data type that you can store in MongoDB and loses type information for some data types. You can also configure endpoints to return EJSON, which uses structured JSON objects to fully represent the types that MongoDB supports. This preserves type information in responses but requires that your application understands how to parse and use EJSON. ## Tip The official MongoDB drivers include methods for working with EJSON. You can also download a standalone parser like [bson](https://www.npmjs.com/package/bson) on npm. ### Access Permissions The Data API uses your app's [data access rules](https://mongodb.com/docs/atlas/app-services/rules/#std-label-rules) to determine if a user can read and write data. To allow Data API requests to access a specific collection, you must first define rules for the collection. You can also set up an [IP Access List](https://mongodb.com/docs/atlas/app-services/security/network/#std-label-ip-access-list) for additional security. ### API Versions The Data API uses a built-in versioning scheme to upgrade endpoints over time while maintaining backwards compatibility. Incoming requests can specify which version of an endpoint to use in the request URL and the Data API can serve any version that you have enabled. You must enable a new version before users can call endpoints with that version. You can always enable the most recent Data API version. However, you cannot enable an older version after a newer version has been released. The following versions are currently supported: * `beta`\n* `v1` ## Call a Data API Endpoint You can call a Data API endpoint from any standard HTTP client. Each request can include configuration headers and arguments in the request body. ### Choose an API Version Data API requests specify which version of the API to use in the request URL. A request can specify any version that is enabled for your app. ```bash https://data.mongodb-api.com/app/<App ID>/endpoint/data/<API Version> \n``` ### Specify the Request Data Format Data API requests must include a `Content-Type` header to specify the[data format](https://mongodb.com/docs/atlas/app-services/data-api/data-formats/#std-label-data-api-data-formats) used in the request body. * Use `Content-Type: application/json` to represent standard JSON types in a Data API request body.\n* Use `Content-Type: application/ejson` to represent standard JSON types _and_ additional EJSON types in a Data API request body. ### Choose a Response Data Format A request can include an `Accept` header to request a specific data format for the response body, either JSON or EJSON. If a request does not include a valid `Accept` header, the response uses the data format specified in your [Data API configuration.](#std-label-data-api-response-type) ### Authenticate the Request If an endpoint is configured to use Application Authentication then you must include a valid user access token or login credentials with every request. In general, bearer authentication with an access token has higher throughput and is more secure than credential headers. Use an access token instead of credential headers when possible. The token lets you run multiple requests without re-authenticating the user. It also lets you send requests from a web browser that enforces [CORS.](https://en.wikipedia.org/wiki/Cross-origin%5Fresource%5Fsharing) To use an access token, first authenticate the user through an App Services authentication provider. Then, get the access token returned from App Services and include it in the request's Authorization header using a Bearer token scheme. For more information on how to acquire and use an access token, see [Bearer Token Authentication.](https://mongodb.com/docs/atlas/app-services/data-api/authenticate/#std-label-data-api-bearer-authentication) ```shell curl -X POST 'https://data.mongodb-api.com/app/<AppID>/endpoint/data/v1/action/find' \\    --header 'Authorization: Bearer <AccessToken>' \\    --header 'Content-Type: application/json' \\    --data-raw '{      \"dataSource\": \"mongodb-atlas\",      \"database\": \"sample_mflix\",      \"collection\": \"movies\",      \"filter\": {\n\n      }    }' \n``` Alternatively, you can include valid login credentials for the user in the request headers. ## Important ### Don't Use API Keys in User-Facing Clients If you're authenticating from a browser or another user-facing client application, avoid using an API key to log in. Instead, use another authentication provider that takes user-provided credentials. Never store API keys or other sensitive credentials locally. ### Authorize the Request Depending on your Data API [authorization configuration](#std-label-data-api-authorization), your requests may need to include additional authorization information. ## Endpoints ### Find a Single Document #### Endpoint ``` POST /action/findOne \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/findOne' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"filter\": {         \"text\": \"Do the dishes\"       }   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"filter\": <query filter>,   \"projection\": <projection> } \n``` | Name       | Type   | Necessity | Description                         | Default |\n| ---------- | ------ | --------- | ----------------------------------- | ------- |\n| dataSource | string | Required  | The name of the linked data source. |         |\n| database   | string | Required  | The name of the database.           |         |\n| collection | string | Required  | The name of the collection.         |         | | filter     | object | Optional | A [MongoDB Query Filter](https://www.mongodb.com/docs/manual/tutorial/query-documents/). The findOne action returns the first document in the collection that matches this filter.If you do not specify a filter, the action matches all document in the collection. | {} |\n| ---------- | ------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -- |\n| projection | object | Optional | A [MongoDB Query Projection](https://www.mongodb.com/docs/manual/tutorial/project-fields-from-query-results/). Depending on the projection, the returned document will either omit specific fields or include only specified fields or values                        | {} | #### Response The `findOne` action returns the matched document in the `document`field: ``` { \"document\": { \"_id\": \"6193504e1be4ab27791c8133\", \"test\": \"foo\" } } \n``` If the action does not match any documents, the `document` field is`null`: ``` { \"document\": null } \n``` ### Find Multiple Documents #### Endpoint ``` POST /action/find \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/find' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"filter\": {         \"status\": \"complete\"       },       \"sort\": { \"completedAt\": 1 },       \"limit\": 10   }' \n``` #### Request Body\n\n {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"filter\": <query filter>,   \"projection\": <projection>,   \"sort\": <sort expression>,   \"limit\": <number>,   \"skip\": <number> } \n``` | Name       | Type   | Necessity | Description                         | Default |\n| ---------- | ------ | --------- | ----------------------------------- | ------- |\n| dataSource | string | Required  | The name of the linked data source. |         |\n| database   | string | Required  | The name of the database.           |         |\n| collection | string | Required  | The name of the collection.         |         |\n\n #### Response The `find` action returns an array of matched document in the`documents` field: ``` {   \"documents\": [     { \"_id\": \"6193504e1be4ab27791c8133\", ... },     { \"_id\": \"6194604e1d38dc33792d8257\", ... }   ] } \n``` If the action does not match any documents, the `documents` field is an empty array: ``` { \"documents\": [] } \n``` ### Insert a Single Document #### Endpoint ``` POST /action/insertOne \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertOne' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"document\": {         \"status\": \"open\",         \"text\": \"Do the dishes\"       }   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"document\": { ... }, } \n``` | Name       | Type   | Necessity | Description                         | Default |\n| ---------- | ------ | --------- | ----------------------------------- | ------- |\n| dataSource | string | Required  | The name of the linked data source. |         |\n| database   | string | Required  | The name of the database.           |         |\n| collection | string | Required  | The name of the collection.         |         | | document | object | Required | An [EJSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/) document to insert into the collection. |\n| -------- | ------ | -------- | ------------------------------------------------------------------------------------------------------------------------ | #### Response The `insertOne` action returns the `_id` value of the inserted document as a string in the `insertedId` field: ### Insert Multiple Documents #### Endpoint ``` POST /action/insertMany \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/insertMany' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"documents\": [         { \"status\": \"open\", \"text\": \"Mop the floor\" },         { \"status\": \"open\", \"text\": \"Clean the windows\" }       ]   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"documents\": [{ ... }, ...] } \n```\n\n | documents | array of objects | Required | An array of one or more [EJSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/)documents to insert into the collection. |\n| --------- | ---------------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------- | #### Response The `insertMany` action returns the `_id` values of all inserted documents as an array of strings in the `insertedIds` field: ``` { \"insertedIds\": [\"61935189ec53247016a623c9\", \"61935189ec53247016a623ca\"] } \n``` ### Update a Single Document #### Endpoint ``` POST /action/updateOne \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/updateOne' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"filter\": { \"_id\": { \"$oid\": \"6193ebd53821e5ec5b4f6c3b\" } },       \"update\": {           \"$set\": {               \"status\": \"complete\",               \"completedAt\": { \"$date\": { \"$numberLong\": \"1637083942954\" } }           }       }   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"filter\": { ... },   \"update\": { ... },   \"upsert\": true|false } \n``` | Name       | Type   | Necessity | Description                         | Default |\n| ---------- | ------ | --------- | ----------------------------------- | ------- |\n| dataSource | string | Required  | The name of the linked data source. |         |\n| database   | string | Required  | The name of the database.           |         |\n| collection | string | Required  | The name of the collection.         |         | | filter | object  | Required | A [MongoDB Query Filter](https://www.mongodb.com/docs/manual/tutorial/query-documents/). The updateOne action modifies the first document in the collection that matches this filter.         |       |\n| ------ | ------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- |\n| update | object  | Required | A [MongoDB Update Expression](https://www.mongodb.com/docs/manual/tutorial/update-documents/)that specifies how to modify the matched document.                                               |       |\n| upsert | boolean | Optional | The upsert flag only applies if no documents match the specified filter. If true, the updateOne action inserts a new document that matches the filter with the specifiedupdate applied to it. | false | #### Response The `updateOne` action returns: * the number of documents that the filter matched in the `matchedCount` field\n* the number of matching documents that were updated in the `modifiedCount` field ``` { \"matchedCount\": 1, \"modifiedCount\": 1 } \n``` If `upsert` is set to `true` and no documents match the filter, the action returns the `_id` value of the inserted document as a string in the `upsertedId` field: ```\n\n \n``` ### Update Multiple Documents #### Endpoint ``` POST /action/updateMany \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/updateMany' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"filter\": { \"status\": \"open\" },       \"update\": {           \"$set\": {               \"status\": \"complete\",               \"completedAt\": { \"$date\": { \"$numberLong\": \"1637083942954\" } }           }       }   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"filter\": { ... },   \"update\": { ... },   \"upsert\": true|false } \n``` | Name       | Type   | Necessity | Description                         | Default |\n| ---------- | ------ | --------- | ----------------------------------- | ------- |\n| dataSource | string | Required  | The name of the linked data source. |         |\n| database   | string | Required  | The name of the database.           |         |\n| collection | string | Required  | The name of the collection.         |         | | filter | object  | Required | A [MongoDB Query Filter](https://www.mongodb.com/docs/manual/tutorial/query-documents/). The updateMany action modifies all documents in the collection that match this filter.                |       |\n| ------ | ------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- |\n| update | object  | Required | A [MongoDB Update Expression](https://www.mongodb.com/docs/manual/tutorial/update-documents/)that specifies how to modify matched documents.                                                   |       |\n| upsert | boolean | Optional | The upsert flag only applies if no documents match the specified filter. If true, the updateMany action inserts a new document that matches the filter with the specifiedupdate applied to it. | false | #### Response The `updateMany` action returns: * the number of documents that the filter matched in the `matchedCount` field\n* the number of matching documents that were updated in the `modifiedCount` field ``` { \"matchedCount\": 12, \"modifiedCount\": 12 } \n``` If `upsert` is set to `true` and no documents match the filter, the action returns the `_id` value of the inserted document as a string in the `upsertedId` field: ``` { \"matchedCount\": 0, \"modifiedCount\": 0, \"upsertedId\": \"619353593821e5ec5b0f8944\" } \n``` ### Replace a Single Document #### Endpoint ``` POST /action/replaceOne \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/replaceOne' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",\n\n       \"collection\": \"tasks\",       \"filter\": { \"text\": \"Call Jessica\" },       \"replacement\": {         \"status\": \"open\",         \"text\": \"Call Amy\"       }   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"filter\": { ... },   \"replacement\": { ... },   \"upsert\": true|false } \n``` | Name       | Type   | Necessity | Description                         | Default |\n| ---------- | ------ | --------- | ----------------------------------- | ------- |\n| dataSource | string | Required  | The name of the linked data source. |         |\n| database   | string | Required  | The name of the database.           |         |\n| collection | string | Required  | The name of the collection.         |         | | filter      | object  | Required | A [MongoDB Query Filter](https://www.mongodb.com/docs/manual/tutorial/query-documents/). The replaceOne action overwrites the first document in the collection that matches this filter. |       |\n| ----------- | ------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- |\n| replacement | object  | Required | An [EJSON](https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/) document that overwrites the matched document.                                                          |       |\n| upsert      | boolean | Optional | The upsert flag only applies if no documents match the specified filter. If true, the replaceOne action inserts the replacement document.                                                | false | #### Response The `replaceOne` action returns: * the number of documents that the filter matched in the `matchedCount` field\n* the number of matching documents that were replaced in the `modifiedCount` field ``` { \"matchedCount\": 1, \"modifiedCount\": 1 } \n``` If `upsert` is set to `true` and no documents match the filter, the action returns the `_id` value of the inserted document as a string in the `upsertedId` field: ``` { \"matchedCount\": 0, \"modifiedCount\": 0, \"upsertedId\": \"619353593821e5ec5b0f8944\" } \n``` ### Delete a Single Document #### Endpoint ``` POST /action/deleteOne \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/deleteOne' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"filter\": { \"_id\": { \"$oid\": \"6193ebd53821e5ec5b4f6c3b\" } }   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"filter\": { ... } } \n```\n\n | filter | object | Required | A [MongoDB Query Filter](https://www.mongodb.com/docs/manual/tutorial/query-documents/). The deleteOne action deletes the first document in the collection that matches this filter. |\n| ------ | ------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | #### Response The `deleteOne` action returns the number of deleted documents in the`deletedCount` field: ``` { \"deletedCount\": 1 } \n``` ### Delete Multiple Documents #### Endpoint ``` POST /action/deleteMany \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/deleteMany' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"filter\": { \"status\": \"complete\" }   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"filter\": { ... } } \n``` | Name       | Type   | Necessity | Description                         | Default |\n| ---------- | ------ | --------- | ----------------------------------- | ------- |\n| dataSource | string | Required  | The name of the linked data source. |         |\n| database   | string | Required  | The name of the database.           |         |\n| collection | string | Required  | The name of the collection.         |         | | filter | object | Required | A [MongoDB Query Filter](https://www.mongodb.com/docs/manual/tutorial/query-documents/). The deleteMany action deletes all documents in the collection that match this filter. |\n| ------ | ------ | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | #### Response The `deleteMany` action returns the number of deleted documents in the`deletedCount` field: ``` { \"deletedCount\": 42 } \n``` ### Run an Aggregation Pipeline #### Endpoint ``` POST /action/aggregate \n``` #### Example ```shell curl --request POST \\   'https://data.mongodb-api.com/app/<App ID>/endpoint/data/v1/action/aggregate' \\   --header 'Content-Type: application/json' \\   --header 'apiKey: <API Key>' \\   --data-raw '{       \"dataSource\": \"mongodb-atlas\",       \"database\": \"learn-data-api\",       \"collection\": \"tasks\",       \"pipeline\": [         {           \"$group\": {             \"_id\": \"$status\",             \"count\": { \"$sum\": 1 },             \"text\": { \"$push\": \"$text\" }           }         },         { \"$sort\": { \"count\": 1 } }       ]   }' \n``` #### Request Body ``` {   \"dataSource\": \"<data source name>\",   \"database\": \"<database name>\",   \"collection\": \"<collection name>\",   \"pipeline\": [<aggregation pipeline>] } \n```\n\n | pipeline | array of objects | Required | A [MongoDB Aggregation Pipeline.](https://www.mongodb.com/docs/manual/core/aggregation-pipeline/) |\n| -------- | ---------------- | -------- | ------------------------------------------------------------------------------------------------- | #### Response The `aggregate` action returns the result set of the final stage of the pipeline as an array of documents in the `documents` field: ``` { \"documents\": [{ ... }, ...] } \n``` ## Error Codes\n\n ← [Atlas Data API](https://mongodb.com/docs/atlas/app-services/data-api/ \"Previous Section\")[Custom HTTPS Endpoints](https://mongodb.com/docs/atlas/app-services/data-api/custom-endpoints/ \"Next Section\") →"
}